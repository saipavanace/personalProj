<html lang="en-US">
<head>
<meta content="IE=edge" http-equiv="X-UA-Compatible" />
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
<title>Caches</title>
<meta content="Caches" name="title_original" />
<link href="../../../rhstylemapping.css" rel="stylesheet" type="text/css" />
<link href="../Reference_Guide.css" rel="stylesheet" type="text/css" />
<link href="../../../editstyle.css" rel="stylesheet" type="text/css" /><script type="text/javascript" language="JavaScript">
//<![CDATA[
function reDo() {
  if (innerWidth != origWidth || innerHeight != origHeight)
     location.reload();
}
if ((parseInt(navigator.appVersion) == 4) && (navigator.appName == "Netscape")) {
	origWidth = innerWidth;
	origHeight = innerHeight;
	onresize = reDo;
}
onerror = null; 
//]]>
</script>
<style type="text/css">
<!--
div.WebHelpPopupMenu { position:absolute;
left:0px;
top:0px;
z-index:4;
visibility:hidden; }
p.WebHelpNavBar { text-align:right; }
-->
</style>
 <meta name="generator" content="Adobe FrameMaker v17.0" />
<script type="text/javascript" src="../../../template/scripts/rh.min.js"></script>
<script type="text/javascript" src="../../../template/scripts/common.min.js"></script>
<script type="text/javascript" src="../../../template/scripts/topic.min.js"></script>
<script type="text/javascript" src="../../../template/scripts/constants.js"></script>
<script type="text/javascript" src="../../../template/scripts/utils.js"></script>
<script type="text/javascript" src="../../../template/scripts/mhutils.js"></script>
<script type="text/javascript" src="../../../template/scripts/mhlang.js"></script>
<script type="text/javascript" src="../../../template/scripts/mhver.js"></script>
<script type="text/javascript" src="../../../template/scripts/settings.js"></script>
<script type="text/javascript" src="../../../template/scripts/XmlJsReader.js"></script>
<script type="text/javascript" src="../../../template/scripts/loadparentdata.js"></script>
<script type="text/javascript" src="../../../template/scripts/loadscreen.js"></script>
<script type="text/javascript" src="../../../template/scripts/loadprojdata.js"></script>
<script type="text/javascript" src="../../../template/scripts/mhtopic.js"></script>
 <link rel="stylesheet" type="text/css" href="../../../template/styles/topic.min.css">
<script type="text/javascript" >
gRootRelPath = "../../..";
gCommonRootRelPath = "../../..";
gTopicId = "4.3.2";
</script>
 <meta name="brsprev" value="Ncore_3_Online_Documentation/Reference_Guide/System_Attributes/NCAIUs.htm">
 <meta name="brsnext" value="Ncore_3_Online_Documentation/Reference_Guide/System_Attributes/Credits_and_Resources.htm">
 <meta name="topic-breadcrumbs" content="Reference Guide > System Attributes" />
</head>
<body dir="ltr">
<script type="text/javascript" src="../../../ehlpdhtm.js"></script>
<div><p class="Heading1" id="980731"><a id="1094_Heading1_980731" name="1094_Heading1_980731"></a>3.4 Caches</p><p class="Body" id="980732">An Ncore system can be configured with two different types of caches&#x3A;</p><p class="Step1" id="994636"><span class="StepNumber">1.  </span>Proxy cache&#x3A; Optional cache configured within an AXI only</p><p class="step_contd" id="994704"><span class="StepNumber">2.  </span>System memory cache&#x3A; Optional cache configured within a DMI</p><p class="Heading2" id="980733"><a id="1094_Heading2_980733" name="1094_Heading2_980733"></a>3.4.1 Proxy Cache</p><p class="Body" id="980734">The NCAIU with an AXI interface can be configured with proxy cache. This allows NCAIUs to buffer data coherently with respect to other coherent caches in the system. Requests received by the NCAIU access the proxy cache, and if data is present in the cache, the request is serviced from the cache. If not, the cache may be filled, based on the allocation policy indicated by the requests AxCache bits. If a proxy cache miss results in a cache allocation, then the NCAIU performs a fully&#x2D;coherent request within Ncore. If the proxy cache miss does not result in a cache allocation, the NCAU performs an IO&#x2D;coherent request within Ncore. </p><p class="Body" id="993704">An NCAIU with a proxy cache can access coherent and non&#x2D;coherent traffic. An address&#x2D;based coherency mode exists with a coherency bit added to the address map. This allows the AXI NCAIU to access both the DMI coherent address space as well as the non&#x2D;coherent address space of the DII.</p><p class="Body" id="993706">To enable support for Legacy agents which do not support read data interleaving, interleaving for the NCAIU can be turned off. In this mode, data returned from the cache will be returned non&#x2D;interleaved.</p><p class="Body" id="980735">The proxy cache supports the MOSI (Modified, Owned, Shared and Invalid) cache state model. A cache line in the modified state is <span style="font-weight:Bold;font-style:Italic;">unique</span> (i.e., the only cached copy in the caching agent caches) and <span style="font-weight:Bold;font-style:Italic;">dirty</span> (i.e., inconsistent with respect to the next level of the memory hierarchy). A cache line in the owned state may not be unique (i.e., a valid copy may be present in another caching agent cache) and may be dirty. A cache line in shared state may not be unique and is presumed to be clean. Finally, a cache line in the invalid state is not present in the cache.</p><p class="Body" id="980736" style="font-kerning:none;">The capacity of the proxy cache is determined by specifying the number of sets and the degree of associativity (i.e., number of ways), and the product of both determines the number of cache lines that are buffered in the cache. </p><p class="Body" id="984488">The proxy cache allocates cache lines based on AxCache signaling on the AXI interface. Allocation and visibility mapping is shown in the table below. Visibility here refers to when Ncore issues the response for the writer request, Early means Ncore issues the response as soon as the request leaves Ncore via a DMI or DII, Late means it waits for the response from the downstream agent.<div align="left"><table class="normal" style="max-width: 100% ;height: auto;"><caption class="ttw-TableTitleWide"><p class="ttw_TableTitleWide" id="984656">Table 5. AxCache Allocation &#x26; Visibility Mapping</p></caption><col width="76.00px"/><col width="103.07px"/><col width="86.27px"/><col width="323.87px"/><thead><tr height="31.33px"><th><p class="CellHeading" id="984664">AxCache</p></th><th><p class="CellHeading" id="984666">Allocation</p></th><th><p class="CellHeading" id="984668">Visibility </p></th><th><p class="CellHeading" id="984670">Notes</p></th></tr></thead><tr height="22.67px"><td><p class="CellBody" id="984672" style="font-family : Consolas ; ">&#x30;&#x30;&#x30;&#x30;</p></td><td><p class="CellBody" id="984674">No</p></td><td><p class="CellBody" id="984676">Late (system)</p></td><td><p class="CellBody" id="984678">Device Non&#x2D;bufferable </p></td></tr><tr height="22.67px"><td><p class="CellBody" id="984680"><span style="font-family : Consolas ; ">&#x30;&#x30;&#x30;</span>1</p></td><td><p class="CellBody" id="984682">No </p></td><td><p class="CellBody" id="984684">Early</p></td><td><p class="CellBody" id="984686">Device bufferable </p></td></tr><tr height="22.67px"><td><p class="CellBody" id="984688"><span style="font-family : Consolas ; ">&#x30;&#x30;</span>1<span style="font-family : Consolas ; ">&#x30;</span></p></td><td><p class="CellBody" id="984690">No </p></td><td><p class="CellBody" id="984692">Late (system)</p></td><td><p class="CellBody" id="984694">Normal Non&#x2D;cacheable, Non&#x2D;bufferable </p></td></tr><tr height="22.67px"><td><p class="CellBody" id="984696"><span style="font-family : Consolas ; ">&#x30;&#x30;</span>11</p></td><td><p class="CellBody" id="984698">No</p></td><td><p class="CellBody" id="984700">Early </p></td><td><p class="CellBody" id="984702">Normal Non&#x2D;cacheable, Bufferable </p></td></tr><tr height="22.67px"><td><p class="CellBody" id="984704"><span style="font-family : Consolas ; ">&#x30;</span>11<span style="font-family : Consolas ; ">&#x30;</span></p></td><td><p class="CellBody" id="984706">Yes(R)&#47;No(W)</p></td><td><p class="CellBody" id="984708">Early </p></td><td><p class="CellBody" id="984710">Write through no allocate &#47; read allocate </p></td></tr><tr height="22.67px"><td><p class="CellBody" id="984712"><span style="font-family : Consolas ; ">&#x30;</span>111</p></td><td><p class="CellBody" id="984714">Yes(R)&#47;No(W)</p></td><td><p class="CellBody" id="984716">Early </p></td><td><p class="CellBody" id="984718">Write back no allocate &#47; read allocate </p></td></tr><tr height="22.67px"><td><p class="CellBody" id="984720">1<span style="font-family : Consolas ; ">&#x30;</span>1<span style="font-family : Consolas ; ">&#x30;</span></p></td><td><p class="CellBody" id="984722">No(R)&#47;Yes(W)</p></td><td><p class="CellBody" id="984724">Early</p></td><td><p class="CellBody" id="984726">Write through write allocate </p></td></tr><tr height="22.67px"><td><p class="CellBody" id="984728">1<span style="font-family : Consolas ; ">&#x30;</span>11</p></td><td><p class="CellBody" id="984730">No(R)&#47;Yes(W)</p></td><td><p class="CellBody" id="984732">Early</p></td><td><p class="CellBody" id="984734">Write back write allocate </p></td></tr><tr height="22.67px"><td><p class="CellBody" id="984736">111<span style="font-family : Consolas ; ">&#x30;</span></p></td><td><p class="CellBody" id="984738">Yes</p></td><td><p class="CellBody" id="984740">Early </p></td><td><p class="CellBody" id="984742">Write through read &#x26; write allocate </p></td></tr><tr height="22.67px"><td><p class="CellBody" id="984744">1111</p></td><td><p class="CellBody" id="984746">Yes</p></td><td><p class="CellBody" id="984748">Early</p></td><td><p class="CellBody" id="984750">Write back read and write allocate</p></td></tr></table></div></p><p class="Body" id="985088">Three&#160;cache line replacement policies are supported as described in <a  href="#XREF_81926__Cache_line_replacement_policy23" style="color:#0000ff;">“Cache line Replacement Policy”</a>. </p><p class="Heading2" id="980737"><a id="1094_Heading2_980737" name="1094_Heading2_980737"></a>3.4.2  System Memory Cache</p><p class="Body" id="980738">The system memory cache (SMC) allows DMI(s) to buffer cache lines and service requests without accessing the next level of memory hierarchy. The SMC represents a lower level cache in the memory hierarchy relative to those in the caching agents and NCAIU. SMC is a pseudo&#x2D;exclusive cache i.e., it is primarily an exclusive cache, which increases total available cache on the chip but there are certain scenarios where SMC may hold a copy of cache line that also resides in the cache hierarchy above SMC.</p><p class="Body" id="1002774">An example scenario is when a dirty owner evicts a shared cache line.</p><p class="Body" id="980739">SMC supports a three&#x2D;state cache model, a cache line may either be in an <span style="font-weight:Bold;font-style:Italic;">invalid </span>state (i.e., not present in the cache) or <span style="font-weight:Bold;font-style:Italic;">clean </span>state (i.e., present and consistent with respect to the next level of the memory hierarchy) or <span style="font-weight:Bold;font-style:Italic;">dirty </span>state (i.e., present and inconsistent with respect to the next level of the memory hierarchy).  SMC in general uses the native interface (CHI, ACE, ACE&#x2D;Lite, ACE5&#x2D;Lite, AXI4, and AXI5) allocation hint to allocate to the cache. These hints can be overwritten by a configuration register setting, where following types of requests may individually be disabled from allocation into SMC.</p><p class="Bullet_1" id="999723"><span class="BulletSymbol">&#x2022; </span>WriteUnique request from CHI&#47;ACE processor</p><p class="Bullet_1" id="980740"><span class="BulletSymbol">&#x2022; </span>Write request with clean data</p><p class="Bullet_1" id="980741"><span class="BulletSymbol">&#x2022; </span>Write request with dirty data </p><p class="Bullet_1" id="980742"><span class="BulletSymbol">&#x2022; </span>All read request data</p><p class="Bullet_1" id="980743"><span class="BulletSymbol">&#x2022; </span>All write request data</p><p class="Body" id="980744">The capacity of the SMC is determined by specifying the number of sets and the degree of associativity (i.e., number of ways), and the product of both determines the number of cache lines that are buffered in the cache. SMC supports three  cache line replacement policies, which are described in the cache line replacement policy section below. SMC supports the following optional features&#x3A;</p><p class="Bullet_1" id="1001446"><span class="BulletSymbol">&#x2022; </span>Scratchpad</p><p class="Bullet_1" id="1001455"><span class="BulletSymbol">&#x2022; </span>Way Partitioning</p><p class="Bullet_1" id="1001458"><span class="BulletSymbol">&#x2022; </span>Cache line Replacement Policy</p><p class="Bullet_1" id="1001461"><span class="BulletSymbol">&#x2022; </span>Address Hashing</p><p class="Heading3" id="980746"><span style="padding-right:18pt ;">&#8203</span>Scratchpad</p><p class="Body" id="980747"><span class="SC_4_221188" style="font-family : Georgia ; font-weight:normal;font-style:normal;font-size : 10.00pt;color:#000000;">Scratchpad can be thought of as a standalone, low latency memory which is separate from the cache. This memory can be direct mapped to a configurable address range. Accesses to this address range will be directed only to the scratchpad and will not be seen by the caching partition of SMC or the downstream memory.</span></p><p class="Body" id="980707"><span class="SC_4_221188" style="font-family : Georgia ; font-weight:normal;font-style:normal;font-size : 10.00pt;color:#000000;">SMC can be configured at initialization to partition one part of the cache as scratchpad on a per way basis. <a  href="#XREF_58977__Figure%117__Scratchpad_RAM23" style="color:#0000ff;">Figure&#160;10</a></span><span class="SC_4_221188" style="color:#000000;"> illustrates a 4 MB SMC with 8 ways that has 4 of its ways configured as scratchpad, i.e., 2 MB as scratchpad and 2 MB as regular cache.</span><div align="left"><table class="note" style="max-width: 100% ;height: auto;"><col width="67.13px"/><col width="403.12px"/><tr height="56.00px"><td><p class="aaNote" id="1000913">NOTE&#x3A;</p></td><td><p class="CellBody" id="1000915" style="font-size : 10.00pt;">When a way is configured as scratchpad, all the sets associated with that way will be configured as scratchpad. Only contiguous ways starting from way &#x30; can be configured as scratchpad.</p></td></tr></table></div></p><p class="Figure" id="980784">Figure&#160;1&#x30;. <a id="XREF_58977__Figure%117__Scratchpad_RAM23" name="XREF_58977__Figure%117__Scratchpad_RAM23">Scratchpad RAM</a><img align="" alt="100052_007" class="imageSettings" height="auto" preserveAspectRatio="none" src="../assets/100052_007.jpg" style="max-width: 100% ;height: auto;display:block;margin:auto;" width="350.699463" x="8.000000" y="8.000000" /></p><p class="Body" id="1002383"><a id="1094_Body_1002383" name="1094_Body_1002383"></a>If Atomic transactions to outside of the scratchpad address space are possible, at least one way must not be configured as scratchpad, otherwise all or none of the SMC Cache can be configured as scratchpad. When a transaction address is outside the scratchpad address space, the transaction is received by the memory attached to the DMI. The downstream memory detects that out&#x2D;of&#x2D;range transaction and responds with an address decode error on the native interface.</p><p class="Heading3" id="980808"><span style="padding-right:18pt ;">&#8203</span> Way Partitioning</p><p class="Body" id="980809"><span class="SC_4_221188" style="font-family : Georgia ; font-weight:normal;font-style:normal;font-size : 10.00pt;color:#000000;">Way partitioning capability enables reservation of a portion of the cache for a single or multiple CAIUs&#47;NCAIUs, for the purpose of brevity CAIU&#47;NCAIU is referred to as AIU in this </span><span class="SC_4_221188" style="font-family : Georgia ; font-weight:normal;font-style:normal;font-size : 10.00pt;color:#000000;">d</span><span class="SC_4_221188" style="font-family : Georgia ; font-weight:normal;font-style:normal;font-size : 10.00pt;color:#000000;">escription. SMC can be configured to partition the cache on per way basis. Note that</span><span class="SC_4_221188" style="font-family : Georgia ; font-weight:normal;font-style:normal;font-size : 10.00pt;color:#000000;">,</span><span class="SC_4_221188" style="font-family : Georgia ; font-weight:normal;font-style:normal;font-size : 10.00pt;color:#000000;"> when a way is reserved, all the sets associated with that way will be reserved for the configured AIU. When way partitioning is enabled, all incoming requests with configured AIUs will only allocate to the enabled way(s). No other AIUs requests will be able to allocate to the enabled way(s)</span><span class="SC_4_221188" style="font-family : Georgia ; font-weight:normal;font-style:normal;font-size : 10.00pt;color:#000000;">; f</span><span class="SC_4_221188" style="font-family : Georgia ; font-weight:normal;font-style:normal;font-size : 10.00pt;color:#000000;">urthermore</span><span class="SC_4_221188" style="font-family : Georgia ; font-weight:normal;font-style:normal;font-size : 10.00pt;color:#000000;">,</span><span class="SC_4_221188" style="font-family : Georgia ; font-weight:normal;font-style:normal;font-size : 10.00pt;color:#000000;"> all incoming requests will be able to hit on all the cache ways</span><span class="SC_4_221188" style="font-family : Georgia ; font-weight:normal;font-style:normal;font-size : 10.00pt;color:#000000;">,</span><span class="SC_4_221188" style="font-family : Georgia ; font-weight:normal;font-style:normal;font-size : 10.00pt;color:#000000;"> irrespective of the AIU it is from. Way partition</span><span class="SC_4_221188" style="font-family : Georgia ; font-weight:normal;font-style:normal;font-size : 10.00pt;color:#000000;">ing</span><span class="SC_4_221188" style="font-family : Georgia ; font-weight:normal;font-style:normal;font-size : 10.00pt;color:#000000;"> can be configured via configuration and status registers. </span></p><p class="Heading3" id="980810"><span style="padding-right:18pt ;">&#8203</span><a id="XREF_81926__Cache_line_replacement_policy23" name="XREF_81926__Cache_line_replacement_policy23">Cache line </a>Replacement Policy</p><p class="Body" id="997271"><a id="1094_Body_997271" name="1094_Body_997271"></a>Allocating a new cache line may cause a valid cache line to be replaced based on a configurable replacement policy. The cache will search for an invalid entry in the set to which the cache line maps. If an invalid entry exists, that entry is selected for the new cache line, but if an invalid entry does not exist, the cache selects a cache line for replacement using either a random policy or a not&#x2D;recently&#x2D;used policy (NRU) or a pseudo least&#x2D;recently&#x2D;used policy (PLRU). The random policy uses a pseudo&#x2D;random pointer to choose a valid cache line for replacement, while the NRU policy tracks cache lines that have been recently used (i.e., recently accessed) and uses the pseudo&#x2D;random pointer to choose a valid cache line for replacement from the set of cache lines that have not been recently used.</p><p class="Body" id="997280">The recently used status is reset once all entries in a set are deemed recently used. The PLRU policy uses a binary decision tree &#x2013; where the leaf nodes represent the cache lines in a set &#x2D; to find a node currently accessed, and updates the binary decision tree to point to the node that is farthest away from the node currently accessed. As a result, the PLRU policy uses the binary decision tree to approximate the relative age order of cache lines. A dual port memory implemented in FLOP or SRAM is required for the PLRU replacement policy to store the cache lines age. The dual port memory is protected by logic to prevent simultaneous read and write accesses to the same address.</p><p class="Heading3" id="997182"><span style="padding-right:18pt ;">&#8203</span><a id="XREF_23531__Address_Hashing23" name="XREF_23531__Address_Hashing23">Address Hashing</a></p><p class="Body" id="997183"><a id="1094_Body_997183" name="1094_Body_997183"></a>A good address hashing function enables the uniform distribution of cache entries. This reduces address conflicts, resulting in less cache entries evictions. This also reduces memory bank and index collisions, allowing higher memory throughput. This also reduces traffic congestions and hotspots.  Ncore implements hashing through the use of primary and secondary selection bits.  Primary selection bits are used to specify and access the sets of the cache.  Secondary selection bits can be specified to enable an XOR&#x2D;based permutation of each primary selection bit by a set of secondary selection bits.</p><p class="Body" id="997197">If secondary selection bits are specified then each selection index bit is equal to the logical XOR of the corresponding primary selection bit and the list of associated secondary selection bits.  If secondary selection bits are not specified then the selection index bit is equal to the primary selection bit.  The number of secondary selection bits and the number of primary selection bits must match and the primary and secondary selection bits cannot overlap.</p></div>
</body>
</html>