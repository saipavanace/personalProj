<html lang="en-US">
<head>
<meta content="IE=edge" http-equiv="X-UA-Compatible" />
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
<title>Functional_Safety_Elements_Description</title>
<meta content="Functional Safety Elements Description" name="title_original" />
<link href="../../../rhstylemapping.css" rel="stylesheet" type="text/css" />
<link href="../Reference_Guide.css" rel="stylesheet" type="text/css" />
<link href="../../../editstyle.css" rel="stylesheet" type="text/css" /><script type="text/javascript" language="JavaScript">
//<![CDATA[
function reDo() {
  if (innerWidth != origWidth || innerHeight != origHeight)
     location.reload();
}
if ((parseInt(navigator.appVersion) == 4) && (navigator.appName == "Netscape")) {
	origWidth = innerWidth;
	origHeight = innerHeight;
	onresize = reDo;
}
onerror = null; 
//]]>
</script>
<style type="text/css">
<!--
div.WebHelpPopupMenu { position:absolute;
left:0px;
top:0px;
z-index:4;
visibility:hidden; }
p.WebHelpNavBar { text-align:right; }
-->
</style>
 <meta name="generator" content="Adobe FrameMaker v17.0" />
<script type="text/javascript" src="../../../template/scripts/rh.min.js"></script>
<script type="text/javascript" src="../../../template/scripts/common.min.js"></script>
<script type="text/javascript" src="../../../template/scripts/topic.min.js"></script>
<script type="text/javascript" src="../../../template/scripts/constants.js"></script>
<script type="text/javascript" src="../../../template/scripts/utils.js"></script>
<script type="text/javascript" src="../../../template/scripts/mhutils.js"></script>
<script type="text/javascript" src="../../../template/scripts/mhlang.js"></script>
<script type="text/javascript" src="../../../template/scripts/mhver.js"></script>
<script type="text/javascript" src="../../../template/scripts/settings.js"></script>
<script type="text/javascript" src="../../../template/scripts/XmlJsReader.js"></script>
<script type="text/javascript" src="../../../template/scripts/loadparentdata.js"></script>
<script type="text/javascript" src="../../../template/scripts/loadscreen.js"></script>
<script type="text/javascript" src="../../../template/scripts/loadprojdata.js"></script>
<script type="text/javascript" src="../../../template/scripts/mhtopic.js"></script>
 <link rel="stylesheet" type="text/css" href="../../../template/styles/topic.min.css">
<script type="text/javascript" >
gRootRelPath = "../../..";
gCommonRootRelPath = "../../..";
gTopicId = "4.4.0_2";
</script>
 <meta name="brsprev" value="Ncore_3_Online_Documentation/Reference_Guide/Resiliency/Functional_Safety_Overview.htm">
 <meta name="brsnext" value="Ncore_3_Online_Documentation/Reference_Guide/SysSoftwareGuide/SysSoftwareGuide.htm">
 <meta name="topic-breadcrumbs" content="Reference Guide > Resiliency" />
</head>
<body dir="ltr">
<script type="text/javascript" src="../../../ehlpdhtm.js"></script>
<div><p class="Heading1" id="997106"><a id="1098_Heading1_997106" name="1098_Heading1_997106"></a>4.2 Functional Safety Elements Description</p><p class="BodyAfterHead" id="998617">Ncore is automatically configured selecting one of the four Maestro GUI options&#x3A; No&#x2D;ASIL, ASIL&#x2D;A, ASIL&#x2D;B, or ASIL&#x2D;D.</p><p class="Heading3" id="993847"><span style="padding-right:18pt ;">&#8203</span>Component Logic Duplication</p><p class="BodyAfterHead" id="996836">Component logic duplication is applied to all Ncore components in a resiliency enabled interconnect. The two identical modules are identified as functional component and checker component. Component duplication, when enabled, applies to all Ncore components (CAIU, NCAIU, DCE, DII, DMI, and DVE). This feature creates logic for two identical RTL modules of the logical component, excluding any SRAM memories. If SRAM memories are used by a component, they must be protected either by ECC or parity, using the protection setting. The two identical modules are a functional component and checker component. </p><p class="Body" id="996861">The checker component receives a version of the same inputs as the functional component, delayed by one to four clock cycles. The safety checker module receives the functional component&#x2019;s outputs and delays them by the same number of one to four clock cycles before comparing them with the checker component&#x2019;s outputs. Any discrepancy will be considered a fault. Faults detected will be logged and reported to the fault controller as mission fault. Once detected, the fault will remain sticky inside the checker component status register until a BIST sequence clears it. </p><p class="Body" id="993850">To detect latent faults in the fault reporting logic, the safety checker module implements two identical comparator trees checking simultaneously that the output of the checker component is identical to the delayed version of the output of the functional component. A latent fault is reported if the outputs of the two comparator trees do not match.</p><p class="Body" id="993851">There are two clock inputs at the top level of the duplicated component; the functional clock and the checker clock. The functional clock drives the functional component, memory, delay module and safety checker, while the checker clock drives the checker component. The two clocks should be identical and balanced. Having two different clock inputs enables the detection of problems in one of the clock trees.</p><p class="Body" id="993843">The following figure illustrates the Ncore component duplication.</p><p class="Figure" id="993863">Figure&#160;19. Ncore Component duplication<img align="" alt="100052_012" class="imageSettings" height="auto" preserveAspectRatio="none" src="../assets/100052_012.jpg" style="max-width: 100% ;height: auto;display:block;margin:auto;" width="615.693787" x="3.024434" y="7.167155" /></p><p class="Heading3" id="993902"><span style="padding-right:18pt ;">&#8203</span> CDTI Message Protection</p><p class="BodyAfterHead" id="993903">Messages transmitted over the CDTI are protected using either ECC or parity. The protection is applied to the data and address parts of the message, and also to some control information. The protection logic is duplicated as a byproduct of component duplication.</p><p class="Body" id="993904">Each component generates protection information for messages entering the CDTI and checks protection information of all messages exiting the CDTI. Correctable ECC errors increment the correctable error counter. When this counter meets the set threshold, it generates a fault signal to the fault controller. Uncorrectable errors are considered as faults which are reported to the fault controller.</p><p class="Heading3" id="993905"><span style="padding-right:18pt ;">&#8203</span>External Interface Protection</p><p class="BodyAfterHead" id="993906">The External Interface Protection is an optional feature which can be enabled on individual interfaces. Once enabled, the tool permits&#160;the definition of a set of arbitrary signals at this interface, in addition to the CHI ACE or AXI signals. These signals are configurable in name, size, and direction. The intended use model is to allow protected agent interfaces that provide data and control signals ECC and&#47;or parity to be properly defined.</p><p class="Body" id="993907">During RTL generation, for this component, an empty RTL module with proper interface signals such as, clock, reset, user defined signals and appropriate fault signals are created. </p><p class="Body" id="993908">Users may add their own protection logic in this empty RTL module and connect the logic to provided fault signal outputs. The fault signals are propagated to the fault controller. Ncore interface timing constraints apply on the interface signals to and from this module to internal Ncore logic. This module is also part of the component duplication. Ncore supports already pre&#x2D;defined protections for CHI interfaces.</p><p class="Heading3" id="997388"><span style="padding-right:18pt ;">&#8203</span>SRAM Memory Protection</p><p class="Body" id="997405">SRAM memory used by a component is protected both for address and data. The protection type can be configured to either ECC or parity. Correctable ECC errors increment the correctable error counter. When this counter reaches the set threshold, it generates a fault signal to the fault controller. Uncorrectable ECC errors are considered as faults which are reported to the fault controller.</p><p class="Heading3" id="997451"><span style="padding-right:18pt ;">&#8203</span>Unattended activation protection</p><p class="BodyAfterHead" id="997458">The unattended activation protection is enabled to prevent, in mission mode, the write accesses to the control registers below by a faulty system by adding gating logic controlled by a signal at the Ncore 3 interface&#x3A;</p><p class="Step1" id="997459"><span class="StepNumber">1.  </span>BIST control register in the fault controller.</p><p class="step_contd" id="997525"><span class="StepNumber">2.  </span>Debug and Trace control registers in the component but the DCE.</p><p class="step_contd" id="997530"><span class="StepNumber">3.  </span>All the component control registers through the APB port.</p><p class="Body" id="997607">The system should follow the sequence below to execute the BIST and enable the APB port write access&#x3A;</p><p class="Step1" id="997463"><span class="StepNumber">1.  </span>Set the unattended activation protection signal.</p><p class="step_contd" id="997547"><span class="StepNumber">2.  </span>Write to the Ncore component control registers through the APB port or the fault controller BIST control register.</p><p class="step_contd" id="997552"><span class="StepNumber">3.  </span>Reset the unattended activation protection signal.<div align="left"><table class="note" style="max-width: 100% ;height: auto;"><col width="67.13px"/><col width="403.12px"/><tr height="56.00px"><td><p class="aaNote" id="997983">NOTE&#x3A;</p></td><td><p class="CellBody" id="997985" style="font-size : 10.00pt;">Same sequence should be used for enabling the Debug and Trace feature. However, this feature should only be enabled in the lab and always disabled in mission mode.</p></td></tr></table></div></p><p class="Heading3" id="997468"><span style="padding-right:18pt ;">&#8203</span>Control and Status register access protection</p><p class="BodyAfterHead" id="997469" style="font-size : 10.00pt;">The access to the Control and Status registers can be protected by limiting the read and write operation to only one CAIU or NCAIU of the Ncore. In mission mode, additional CAIU&#47;NCAIU can be promoted to access the Control and Status registers as well.<div align="left"><table class="note" style="max-width: 100% ;height: auto;"><col width="67.13px"/><col width="403.12px"/><tr height="40.00px"><td><p class="aaNote" id="997930">NOTE&#x3A;</p></td><td><p class="CellBody" id="997932" style="font-size : 10.00pt;">An NCAIU with AXI interface and set in coherent mode cannot be selected to access the Control and Status registers. </p></td></tr></table></div></p><p class="Heading3" id="993909"><span style="padding-right:18pt ;">&#8203</span>Fault Controller</p><p class="BodyAfterHead" id="997750">The fault controller monitors and logs faults reported by all safety checkers in the system. It has a Built&#x2D;In Self Test (BIST) Finite State Machine (FSM) that communicates with the safety checkers and is used for key&#x2D;on check of the fault reporting logic, as well as clearing mission and latent faults. The BIST FSM can detect stuck&#x2D;at&#x2D;faults. The BIST FSM is based on 9 states in addition to the idle&#47; reset state&#x3A;</p><p class="Step1" id="997752"><span class="StepNumber">1.  </span>Reset safety checkers fault Data Flip Flop (DFF). The fault controller expects all correctable error other threshold, mission, and latent faults from the safety checkers to go to &apos;&#x30;&apos;.</p><p class="step_contd" id="997831"><span class="StepNumber">2.  </span>(a) Force the safety checkers correctable error other threshold fault functional comparator output to ‘1&#x2019;. The fault controller expects all correctable error other threshold faults from the safety checkers to go to &apos;1&apos;.<br/><br/>(b) Reset safety checkers fault Data Flip Flop (DFF). The fault controller expects all correctable error other threshold faults from the safety checkers to go to &apos;&#x30;&apos;.</p><p class="step_contd" id="997828"><span class="StepNumber">3.  </span>(a) Force the safety checkers latent fault functional comparator output to ‘1&#x2019;. The fault controller expects all latent faults from the safety checkers to go to ‘1&#x2019;.<br/><br/>(b) Reset safety checkers fault Data Flip Flop (DFF). The fault controller expects all latent faults from the safety checkers to go to ‘&#x30;&#x2019;.</p><p class="step_contd" id="997867"><span class="StepNumber">4.  </span>(a) Force the safety checkers mission fault functional comparator output to ‘1&#x2019;. The fault controller expects all mission faults from the safety checkers to go to &apos;1&apos;.<br/><br/>(b) Reset safety checkers fault Data Flip Flop (DFF). The fault controller expects all mission faults from the safety checkers to go to ‘&#x30;&#x2019;.</p><p class="BodyAfterHead" id="997759">5. BIST indicates the Ncore components to conduct the Timeout test. The fault controller expects all Timeout uncorrectable errors from the functional and checker Ncore components to go to ‘1&#x2019;.</p><p class="BodyAfterHead" id="997760">Note&#x3A; If no error is reported after 2<sup>14</sup> clock cycles, a BIST error is asserted.</p><p class="BodyAfterHead" id="997761">6. Reset Timeout fault DFF. The fault controller expects to see all Timeout uncorrectable errors from the Ncore components to go to &apos;&#x30;&apos;; and is now back to idle mode.</p><p class="BodyAfterHead" id="997763">The BIST sequence can either be executed automatically or by single stepping via the fault controller BIST control register. The use model is as follows&#x3A; after a fault detection, clear the fault by executing all the steps of the sequence automatically. If the BIST fails, it is possible to refine the diagnostic by executing each step one by one, to isolate which step fails. The BIST status register reports the steps that are completed by setting the corresponding bit to ‘1&#x2019; and the steps that failed by setting the corresponding bit to ‘1&#x2019;.</p><p class="BodyAfterHead" id="997765">The Fault controller must be assigned a clock identical to one of the Ncore components that will be the last clock to go off and first to go on. It should be in a power domain that will be the last domain to power down and the first power domain to power up. In an Ncore interconnect with multiple clock and power domains, where some components might go to a power down mode, the clock for the fault controller must be chosen so that it&apos;s in the power domain that will be the last one to go OFF and the first one to go ON.<div align="left"><table class="note" style="max-width: 100% ;height: auto;"><col width="67.13px"/><col width="403.12px"/><tr height="40.00px"><td><p class="aaNote" id="995933">NOTE&#x3A;</p></td><td><p class="CellBody" id="995935"><span style="font-size : 10.00pt;">In th</span><span style="font-size : 10.00pt;">e current implementation, it is not possible to run the BIST sequence if some power domains are down. </span></p></td></tr></table></div></p><p class="Body" id="995926">Therefore, in an Ncore interconnect with multiple power domains, if some of the domains are OFF, only fault detection will be provided, and the whole system must be reset to clear the fault.</p><p class="Body" id="993918">All fault and BIST signals between fault controller and the safety checker are treated as asynchronous signals, and they are synchronized at both destinations. These signals may need level shifters, depending on the different power domains that go across in the system.</p><p class="Heading3" id="998523"><span style="padding-right:18pt ;">&#8203</span>FMEDA file automatic generation</p><p class="Body" id="998524">Maestro exports, for each Automotive customer configuration, a Failure Mode, Effects, and Diagnostic Analysis file. The file contains the contribution of each Ncore unit including the network to the failure budget, and failure impact based on the fault detection mechanism implemented in Ncore 3 at the configuration time.</p></div>
</body>
</html>