<html lang="en-US">
<head>
<meta content="IE=edge" http-equiv="X-UA-Compatible" />
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
<title>System_Overview</title>
<meta content="System Overview" name="title_original" />
<link href="../../../rhstylemapping.css" rel="stylesheet" type="text/css" />
<link href="../Reference_Guide.css" rel="stylesheet" type="text/css" />
<link href="../../../editstyle.css" rel="stylesheet" type="text/css" /><script type="text/javascript" language="JavaScript">
//<![CDATA[
function reDo() {
  if (innerWidth != origWidth || innerHeight != origHeight)
     location.reload();
}
if ((parseInt(navigator.appVersion) == 4) && (navigator.appName == "Netscape")) {
	origWidth = innerWidth;
	origHeight = innerHeight;
	onresize = reDo;
}
onerror = null; 
//]]>
</script>
<style type="text/css">
<!--
div.WebHelpPopupMenu { position:absolute;
left:0px;
top:0px;
z-index:4;
visibility:hidden; }
p.WebHelpNavBar { text-align:right; }
-->
</style>
 <meta name="generator" content="Adobe FrameMaker v17.0" />
<script type="text/javascript" src="../../../template/scripts/rh.min.js"></script>
<script type="text/javascript" src="../../../template/scripts/common.min.js"></script>
<script type="text/javascript" src="../../../template/scripts/topic.min.js"></script>
<script type="text/javascript" src="../../../template/scripts/constants.js"></script>
<script type="text/javascript" src="../../../template/scripts/utils.js"></script>
<script type="text/javascript" src="../../../template/scripts/mhutils.js"></script>
<script type="text/javascript" src="../../../template/scripts/mhlang.js"></script>
<script type="text/javascript" src="../../../template/scripts/mhver.js"></script>
<script type="text/javascript" src="../../../template/scripts/settings.js"></script>
<script type="text/javascript" src="../../../template/scripts/XmlJsReader.js"></script>
<script type="text/javascript" src="../../../template/scripts/loadparentdata.js"></script>
<script type="text/javascript" src="../../../template/scripts/loadscreen.js"></script>
<script type="text/javascript" src="../../../template/scripts/loadprojdata.js"></script>
<script type="text/javascript" src="../../../template/scripts/mhtopic.js"></script>
 <link rel="stylesheet" type="text/css" href="../../../template/styles/topic.min.css">
<script type="text/javascript" >
gRootRelPath = "../../..";
gCommonRootRelPath = "../../..";
gTopicId = "4.1.1";
</script>
 <meta name="brsprev" value="Ncore_3_Online_Documentation/Reference_Guide/Intro/Terminology.htm">
 <meta name="brsnext" value="Ncore_3_Online_Documentation/Reference_Guide/Protocols_and_Interfaces/Protocols_and_Interfaces.htm">
 <meta name="topic-breadcrumbs" content="Reference Guide > Ncore 3 Introduction" />
</head>
<body dir="ltr">
<script type="text/javascript" src="../../../ehlpdhtm.js"></script>
<div><p class="Heading1" id="1001648"><a id="1084_Heading1_1001648" name="1084_Heading1_1001648"></a>1.2 System Overview</p><p class="BodyAfterHead" id="1003843">A system based on the Ncore interconnect consists of a set of master agents and a set of slave agents that communicate through the Ncore interconnect. A master agent is an external logic block that initiates read and write transactions to a particular physical address. Typical examples of a master agent include processor clusters, graphics processing units, accelerators, or peripheral devices. A slave agent is an external logic block that services read and write transactions for a given set of physical addresses. Typical examples of a slave agent include memory or cache controllers or peripheral devices.</p><p class="BodyAfterHead" id="1003844">Master agent transactions are characterized based on their access semantics, which may be classified as either non&#x2D;coherent or coherent. For a given physical address, a non&#x2D;coherent transaction directly accesses the data in the corresponding memory location or peripheral device. Specifically, a non&#x2D;coherent read transaction transfers data from a memory location, while a non&#x2D;coherent write transaction transfers data to a memory location. Alternatively, for a given physical address, a coherent transaction may access the data either in the corresponding memory location or in one of the caches of the system. Specifically, a coherent read transaction transfers data values from the most recent copy, either in the memory location or in a cache, while a coherent write transaction transfers data to a memory location and invalidates any other cached copies.</p><p class="BodyAfterHead" id="1003845">A coherent transaction is further classified as a fully&#x2D;coherent transaction or an IO&#x2D;coherent transaction. In the former case, the master agent performing the coherent transaction obtains a copy that is required to remain coherent with respect to coherent transactions from other master agents. In the latter case, the master agent obtains a copy that is not required to remain coherent.</p><p class="BodyAfterHead" id="1003846">The same memory location may be accessed with transactions that have different access semantics; however, the Ncore interconnect does not enforce coherence in these cases and does not provide any ordering between transactions to the same memory location with different access semantics.</p><p class="BodyAfterHead" id="1003847">A master agent is classified by the transactions the agent is capable of issuing&#x3A;</p><p class="Bullet_1" id="1003862"><span class="BulletSymbol">&#x2022; </span>A fully&#x2D;coherent agent, e.g., a processor cluster may issue fully&#x2D;coherent, IO&#x2D;coherent, and non&#x2D;coherent transactions.</p><p class="Bullet_1" id="1003863"><span class="BulletSymbol">&#x2022; </span>An IO&#x2D;coherent agent e.g., a graphics processing unit may issue IO&#x2D;coherent and non&#x2D;coherent transactions.</p><p class="Bullet_1" id="1003864"><span class="BulletSymbol">&#x2022; </span>A non&#x2D;coherent agent e.g., a typical DMA engine only issues non&#x2D;coherent transactions.</p><p class="BodyAfterHead" id="1003888">Collectively, fully&#x2D;coherent agents and IO&#x2D;coherent agents are known as coherent agents. Furthermore, fully&#x2D;coherent agents are also classified as caching agents, which incorporate caches that store coherent copies of data and implement snooping interfaces on which coherent operations are presented. IO&#x2D;coherent and non&#x2D;coherent agents may implement caches; however, these caches store only non&#x2D;coherent copies of data. Data in non&#x2D;coherent caches may be kept coherent with data in coherent caches using software coherence methods.</p><p class="BodyAfterHead" id="1003889">A slave agent is classified by how the agent services access that result from read and write transactions. A memory agent provides access to memory locations, and accesses to the physical addresses serviced by a memory agent have the following properties&#x3A;</p><p class="Bullet_1" id="1003907"><span class="BulletSymbol">&#x2022; </span>A read access returns the last value written, and in particular, multiple read accesses to the same memory location return the same value unless an intervening write access has changed the value at the memory location</p><p class="Bullet_1" id="1003908"><span class="BulletSymbol">&#x2022; </span>Read and write accesses do not cause side&#x2D;effects</p><p class="BodyAfterHead" id="1003909">The memory locations serviced by a memory agent may be accessed by a master agent using coherent or non&#x2D;coherent transactions, and if those memory locations are accessed with fully&#x2D;coherent transactions, copies of data from a memory agent can be cached and are kept coherent by the Ncore interconnect. To access a memory agent, the Ncore interconnect issues memory read transactions and memory write transactions, which perform read accesses and write accesses respectively.</p><p class="BodyAfterHead" id="1003910">A non&#x2D;memory agent provides access to other forms of system functionality, and accesses to the physical addresses serviced by a non&#x2D;memory agent have the following properties&#x3A;</p><p class="Bullet_1" id="1003911"><span class="BulletSymbol">&#x2022; </span>A read access may not return the last value written, and multiple read accesses to the same memory location may return different values</p><p class="Bullet_1" id="1003912"><span class="BulletSymbol">&#x2022; </span>Read and write accesses may cause side&#x2D;effects, e.g., raising an interrupt or initiating a hardware state machine</p><p class="BodyAfterHead" id="1003913">The system functionality provided by a non&#x2D;memory agent may be accessed by a master agent using non&#x2D;coherent transactions only. Copies of data from a non&#x2D; memory agent are not cached and cannot be kept coherent.</p><p class="Heading2" id="1003839"><a id="1084_Heading2_1003839" name="1084_Heading2_1003839"></a>1.2.1 Functional Overview</p><p class="BodyAfterHead" id="1003967"><a  href="#XREF_96781__Figure%111__Ncore_3_Functional_Overview19" style="color:#0000ff;">Figure&#160;1</a> illustrates a set of functional components in the Ncore system. This functional view of an Ncore system describes the functional components and their relationship to each other. Agents communicate with an Ncore system address space through various interface components. A coherent agent accesses via a coherent agent interface, while a non&#x2D;coherent agent accesses via a non&#x2D;coherent agent interface. Correspondingly, a memory agent is accessed via a memory interface and non&#x2D;memory agent is accessed via an IO interface.</p><p class="Figure" id="1003982">Figure&#160;1. <a id="XREF_96781__Figure%111__Ncore_3_Functional_Overview19" name="XREF_96781__Figure%111__Ncore_3_Functional_Overview19">Ncore 3 Functional Overview</a><span style="font-family : Georgia ; font-weight:normal;font-style:normal;font-size : 10.00pt;"><img align="" alt="100052_001" class="imageSettings" height="436.321991" preserveAspectRatio="none" src="../assets/100052_001.jpg" style="max-width: 100% ;height: auto;display:block;margin:auto;" width="603.000000" x="8.000000" y="8.000000" /></span></p><p class="Body" id="1004085"><a id="1084_Body_1004085" name="1084_Body_1004085"></a>A memory interface may be configured with a dedicated system memory cache, which caches data based on configurable policies. In a memory interface configured with a system memory cache, any transaction first accesses the system memory cache, and, depending on transaction type and the configuration of the system memory cache, the memory interface may service the transaction from the cache or perform a memory access. System memory caches may be configured to support additional features such as way partitioning, scratchpad, and atomic transactions.</p><p class="Body" id="1004086">The Directory enforces coherence on memory granules known as directory cache lines and serializes coherent transactions to the same directory cache line. The directory also implements one or more snoop filters that track the cache state of caching agents, and each caching agent is assigned to a single snoop filter. A caching agent may be a fully&#x2D;coherent agent or an non&#x2D;coherent agent interface configured with a proxy cache, as described below. The type of coherent transaction and the result of the snoop filter access determines&#160;which coherent operations need to be performed and the number of snoops that will be issued.</p><p class="Body" id="1004087">A non&#x2D;coherent agent interface may be configured with a fully&#x2D;coherent proxy cache which caches data on behalf of the non&#x2D;coherent agent. A transaction first accesses the proxy cache. On a proxy cache hit, the transaction is serviced using the proxy cache. On a proxy cache miss, the transactions result in either a fully&#x2D;coherent or an IO&#x2D;coherent transaction downstream. The decision is based on the original transaction attributes. If the data should be allocated in the proxy cache, a fully&#x2D;coherent transaction is issued or else an IO&#x2D;coherent transaction is issued.</p><p class="Body" id="1006855">A virtual memory manager handles all DVM traffic within the Ncore system and it also processes DVM commands.</p><p class="Body" id="1004088">Communication among components occurs via transport interconnect. A transport interconnect is a communication fabric that transports information from one component to another without altering the transmitted information or changing the semantics of the original transaction.</p><p class="Body" id="1004089">Ncore contains two transport interconnect structures characterized by the functionality that they provide.</p><p class="Bullet_1" id="1004090"><span class="BulletSymbol">&#x2022; </span>Control and data transport interconnect (CDTI) is responsible for exchanging coherent and non&#x2D;coherent control and data information between all components of the Ncore system. </p><p class="Bullet_1" id="1004091"><span class="BulletSymbol">&#x2022; </span>Control and status transport interconnect (CSTI) provides access to the control and status registers in the Ncore system.</p><p class="Heading2" id="1004081"><a id="1084_Heading2_1004081" name="1084_Heading2_1004081"></a>1.2.2 Structural Overview</p><p class="BodyAfterHead" id="1004146">The Ncore functionality described in the previous section is represented by a set of structural units connected by the transport interconnects. The structural view of an Ncore interconnect describes these structural units and their connectivity illustrated in <a  href="#XREF_20776__Figure%112_19" style="color:#0000ff;">Figure&#160;2</a>. Each functional component has an analogous structural unit as follows&#x3A;</p><p class="Bullet_1" id="1004147"><span class="BulletSymbol">&#x2022; </span>Coherent agent interface &#x2D;&#x3E; Coherent agent interface unit (CAIU)</p><p class="Bullet_1" id="1004148"><span class="BulletSymbol">&#x2022; </span>Non coherent agent interface &#x2D;&#x3E; Non&#x2D;Coherent agent interface unit (NCAIU)</p><p class="Bullet_1" id="1004149"><span class="BulletSymbol">&#x2022; </span>Directory &#x2D;&#x3E; Distributed Coherence Engine (DCE)</p><p class="Bullet_1" id="1004150"><span class="BulletSymbol">&#x2022; </span>Memory Interface &#x2D;&#x3E; Distributed memory interface (DMI)</p><p class="Bullet_1" id="1004151"><span class="BulletSymbol">&#x2022; </span>IO Interface &#x2D;&#x3E; Distributed IO interface (DII)</p><p class="Bullet_1" id="1006991"><span class="BulletSymbol">&#x2022; </span>Virtual memory manager &#x2D;&#x3E; Distributed Virtual memory Engine (DVE)</p><p class="Figure" id="1004398">Figure&#160;2. <a id="XREF_20776__Figure%112_19" name="XREF_20776__Figure%112_19"> Ncore 3 Structural View</a><img align="" alt="100052_002" class="imageSettings" height="345.154144" preserveAspectRatio="none" src="../assets/100052_002.jpg" style="max-width: 100% ;height: auto;display:block;margin:auto;" width="610.607056" x="3.889689" y="3.835490" /></p><p class="Heading3" id="1004260"><a id="1084_Heading3_1004260" name="1084_Heading3_1004260"></a><span style="padding-right:18pt ;">&#8203</span> Coherent Agent Interface Unit</p><p class="BodyAfterHead" id="1004294" style="margin-bottom : 12.00pt;line-height : 12.00pt;font-family : Calibri ; font-size : 11.00pt;font-kerning:none;">A CAIU can be configured to implement one of four fully coherent interface protocols&#x3A; ACE, ACE5, CHI&#x2D;B, or CHI&#x2D;E.</p><p class="Heading3" id="1004325"><span style="padding-right:18pt ;">&#8203</span>Non&#x2D;Coherent Agent Interface Unit</p><p class="BodyAfterHead" id="1004372">An NCAIU can be configured to implement one of <span style="font-family : Calibri ; font-size : 11.00pt;font-kerning:none;">four</span>&#160;non&#x2D;coherent or IO&#x2D;coherent interface protocols; AXI4 or AXI5, ACE&#x2D;Lite, and ACE5&#x2D;Lite. The interface can be configured through the GPAR registers to access coherent or non&#x2D;coherent address space.</p><p class="Body" id="1011924">Each GPAR can be configured for coherent or non&#x2D;coherent even if a ProxyCache resides in the NCAIU.</p><p class="Heading3" id="1004251"><span style="padding-right:18pt ;">&#8203</span>Distributed Coherence Engine</p><p class="BodyAfterHead" id="1004448">A DCE implements directory structures to track the location of data. An Ncore system must be configured with at least one DCE. Depending on system transaction bandwidth multiple DCEs may be initiated. DCE instances may be physically distributed and logically interleaved. The address bits used for interleaving must be chosen during system configuration.</p><p class="Heading3" id="1004463"><span style="padding-right:18pt ;">&#8203</span>Distributed Memory Interface</p><p class="BodyAfterHead" id="1004500">A DMI provides an AXI4 master interface to normal memory for coherent and non&#x2D;coherent transactions. Multiple DMI may be implemented. They can be distributed and may be address interleaved within the Ncore system for bandwidth and physical placement. The number of instances and caching capabilities is chosen during configuration. Different interleaving options can be specified during configuration,&#160;and one of the specified options can be selected via registers at run time.</p><p class="Heading3" id="1005835"><span style="padding-right:18pt ;">&#8203</span>Distributed Virtual Memory Engine</p><p class="BodyAfterHead" id="1007100">The DVE is a virtual memory manager within the Ncore system. The current version of Ncore allows only one instance of DVE to manage DVM capable agents. </p><p class="Heading3" id="1008527"><span style="padding-right:18pt ;">&#8203</span>Distributed IO Interface</p><p class="Body" id="1008556">A DII provides an AXI4 master interface to IO devices for non&#x2D;coherent requests.</p></div>
</body>
</html>