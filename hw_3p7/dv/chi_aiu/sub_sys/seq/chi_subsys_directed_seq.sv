class chi_subsys_directed_seq extends svt_chi_rn_coherent_transaction_base_sequence;

  typedef bit [(`SVT_CHI_MAX_DATA_WIDTH-1):0] store_data_type;
  store_data_type store_data, directed_store_data;

  /** 
   * Indicates that the data provided in directed_data_mailbox should be used
   * for the transactions generated by this sequence
   */
  bit randomize_with_directed_data;

  //for coherent and noncohrent transaction 
  bit write_coh;

  //for data_size
  bit [2:0] size;

  /**
   * Applicable if randomize_with_directed_data is set.
   * A mailbox into which a user can put data to which transactions have to be
   * generated.
   */
  mailbox #(store_data_type) directed_data_mailbox;
  
  `svt_xvm_object_utils(chi_subsys_directed_seq)
  `svt_xvm_declare_p_sequencer(svt_chi_rn_transaction_sequencer)

  function new(string name = "chi_subsys_directed_seq");
    super.new(name);
    directed_data_mailbox=new();
  endfunction // new

 /** 
  * This sequence randomizes a single transaction based on the weights assigned.
  *  - If randomized_with_directed_addr is set, the transaction is randomized with
  *    the address specified in directed_addr
  *  - If randomized_with_directed_data is set, the transaction is randomized with
  *    the data specified in directed_store_data
  *  - If store_data is set, the transaction is randomized with
  *    the data specified in store_data
  *  .
  */
  virtual task randomize_xact(svt_chi_rn_transaction           rn_xact,
                              bit                              randomize_with_directed_addr, 
                              bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0] directed_addr,
                              bit                              directed_snp_attr_is_snoopable,
                              svt_chi_common_transaction::snp_attr_snp_domain_type_enum directed_snp_attr_snp_domain_type,
                              bit                              directed_mem_attr_allocate_hint,
                              bit                              directed_is_non_secure_access,
                              bit                              directed_allocate_in_cache,
                              svt_chi_common_transaction::data_size_enum directed_data_size, 
                              bit [(`SVT_CHI_MAX_DATA_WIDTH-1):0] directed_data,
                              bit [(`SVT_CHI_MAX_BE_WIDTH-1):0] directed_byte_enable,
                              output bit                       req_success,
                              input  int                       sequence_index = 0,
                              input  bit                       gen_uniq_txn_id = 0);
    
    `svt_debug("randomize_xact", "chi_subsys_directed_seq - Entered ");

    // Get config from corresponding sequencer and assign it here.
    rn_xact.cfg      = node_cfg;
    if (randomize_with_directed_data)begin
      void'(directed_data_mailbox.try_get(directed_store_data));
    end
    
    req_success = rn_xact.randomize() with 
    { 
    if(write_coh==0){
    xact_type inside {       
                    svt_chi_common_transaction::WRITENOSNPFULL,  
                    svt_chi_common_transaction::WRITENOSNPPTL };
                    }
    else{
    xact_type inside { 
                        
                        svt_chi_common_transaction::WRITEBACKFULL, 
                        svt_chi_common_transaction::WRITEBACKPTL, 
                        svt_chi_common_transaction::WRITECLEANFULL, 
                        svt_chi_common_transaction::WRITECLEANPTL, 
                        svt_chi_common_transaction::WRITEEVICTFULL,
                        svt_chi_common_transaction::WRITEUNIQUEFULL,
                        svt_chi_common_transaction::WRITEUNIQUEPTL
                     };
                     }
      
      

    
    if (randomize_with_directed_addr)  addr == directed_addr;
    // `ifdef SVT_CHI_ISSUE_A_ENABLE
      if (randomize_with_directed_addr && directed_snp_attr_is_snoopable && use_directed_snp_attr)  snp_attr_snp_domain_type == directed_snp_attr_snp_domain_type;
    // `endif
    if (randomize_with_directed_addr && use_directed_mem_attr)  mem_attr_allocate_hint == directed_mem_attr_allocate_hint;
    if (randomize_with_directed_addr && use_directed_non_secure_access)  is_non_secure_access == directed_is_non_secure_access;
    
    requires_go_before_barrier == 1;

    if(store_data != 0) data == store_data;
    if (randomize_with_directed_data)  data == directed_store_data;

    order_type == svt_chi_common_transaction::REQ_ORDERING_REQUIRED;
      
    if(size==0){
    data_size == svt_chi_rn_transaction::SIZE_1BYTE && byte_enable == 'h1};
    else if(size==1){
    data_size == svt_chi_rn_transaction::SIZE_2BYTE && byte_enable == 'h3};
    else if(size==2){
    data_size == svt_chi_rn_transaction::SIZE_4BYTE && byte_enable == 'hF};
    else if(size==3){
    data_size == svt_chi_rn_transaction::SIZE_8BYTE && byte_enable == 'hFF};
    else if(size==4){
    data_size == svt_chi_rn_transaction::SIZE_16BYTE &&  byte_enable == 'hFFFF};
    else if(size==5){
    data_size == svt_chi_rn_transaction::SIZE_32BYTE && byte_enable == 'hFFFFFFFF};
    else if(size==6){
    data_size == svt_chi_rn_transaction::SIZE_64BYTE && byte_enable == 'hFFFFFFFFFFFFFFFF};

    mem_attr_is_cacheable == 0;
    //byte_enable == 'hFFFF;
//    `ifndef SVT_CHI_ISSUE_A_ENABLE
    if(xact_type==svt_chi_common_transaction::WRITENOSNPPTL) {
        is_writedatacancel_used_for_write_xact == 0;
    }
    // `endif
    };
    `svt_debug("randomize_xact", $sformatf("chi_subsys_directed_seq - After randomization, randomize_xact \nrandomize_with_directed_addr %0b directed_addr %0h directed_snp_attr_is_snoopable %0b directed_snp_attr_snp_domain_type %0s directed_mem_attr_allocate_hint %0b directed_is_non_secure_access %0b directed_allocate_in_cache %0b directed_data_size %0s directed_data %0h directed_byte_enable %0h req_success %0b sequence_index %0b gen_uniq_txn_id %0b directed_store_data %0h randomize_with_directed_data %0b store_data %0h data_size %0s xact_type %0s byte_enable %0h data %0h",randomize_with_directed_addr, directed_addr, directed_snp_attr_is_snoopable, directed_snp_attr_snp_domain_type.name, directed_mem_attr_allocate_hint, directed_is_non_secure_access, directed_allocate_in_cache, directed_data_size.name, directed_data, directed_byte_enable, req_success, sequence_index, gen_uniq_txn_id, directed_store_data,randomize_with_directed_data,store_data,rn_xact.data_size.name,rn_xact.xact_type.name,rn_xact.byte_enable,rn_xact.data));
  
    //rn_xact.addr[5:0] = 'h0;
    store_data = 'h0;
    `svt_debug("randomize_xact",$psprintf("chi_subsys_directed_seq req_success - %b \n%0s", req_success, rn_xact.sprint()));
  endtask // randomize_xact
  
  virtual task body();
    if((readnosnp_wt+writenosnpfull_wt+writenosnpptl_wt+writeuniquefull_wt+writeuniqueptl_wt) == 0)
      `svt_fatal("body","Wight should be non zero value for atleast one Non-Coherent transaction (READNOSNP, WRITENOSNPPTL, WRITENOSNPFULL)");
    super.body();
  endtask // body

  virtual function svt_chi_rn_transaction get_xact_from_active_queue(int unsigned index);
    if(index > active_xacts.size())
      get_xact_from_active_queue = null;
    else
      get_xact_from_active_queue = active_xacts[index];
  endfunction // get_xact_from_active_queue
  
endclass