\jsbegin
//=============================================================================
// Copyright(C) 2025 Arteris, Inc.
// All rights reserved
//=============================================================================
// AXI Shim
//=============================================================================

var u = obj.lib;
var utilFunctions = obj.userLib;
var utilFunctionsSym = obj.userLib.symLib;
var bundleFunctions      = obj.userLib.bundleFunctions;
var log2ceil = function(n) { return Math.ceil(Math.log(n)/Math.LN2); };

u.paramDefault('depth',  'int', 1);
u.paramDefault('wData',  'int', 1);
u.paramDefault('wId',    'int', 1);

var depth      = u.getParam('depth');
var wData      = u.getParam('wData');
var wId        = u.getParam('wId');

u.port('input', 'clk',      1);
u.port('input', 'reset_n',  1);

u.port('input', 'push',      1);
u.port('input', 'push_id',   wId);
u.port('input', 'push_data', wData);

u.port('input', 'pop',      1);
u.port('input', 'pop_id',   wId);
u.port('output','pop_data', wData);
u.port('output','pop_match', 1);
u.port('input', 'pop_update',1);

u.port('output','full',  1);
u.port('output','empty', 1);

\jsend
module \=obj.lib.getModuleName()=\ (\=obj.lib.getPorts('\n')=\);

\js // Transaction Context

wire [\=depth=\-1:0]           valid_vector;
wire [\=depth=\-1:0]           valid_vector_sel;
wire [\=depth=\-1:0]           entry_clear_vec;
wire [\=depth=\-1:0]           entry_match_vec;
wire [\=depth=\-1:0]           depnd_match_vec;
wire [\=depth=\-1:0]           pop_match_vec;
wire [\=depth=\-1:0]           pop_update_vec;
reg  [\=log2ceil(depth)=\-1:0] depnd_match;

always @ (*) begin
 case(1'b1)
\js for (let i = 0; i < depth; i++) {
   depnd_match_vec[\=i=\]:
       depnd_match = \=log2ceil(depth)=\'d\=i=\;
\js }
   default:
       depnd_match = \=log2ceil(depth)=\'h0;
 endcase
end

assign full  = &valid_vector;
assign empty = |valid_vector;

\js for (let i = 0; i < depth; i++) {

\js var context_width = wData + wId + 3 + log2ceil(depth);
 
  wire [\=wId-1=\:0]                       id\=i=\;
  wire [\=wId-1=\:0]                       id\=i=\in;

  wire                                     valid\=i=\;
  wire                                     valid\=i=\in;

  wire [\=wData-1=\:0]                     data\=i=\;
  wire [\=wData-1=\:0]                     data\=i=\in;
  
  assign valid_vector[\=i=\]               = valid\=i=\;

  wire                                     oldest\=i=\;
  wire                                     oldest\=i=\in;

  wire                                     youngest\=i=\;
  wire                                     youngest\=i=\in;

  wire [\=log2ceil(depth)-1=\:0]  depnd\=i=\;
  wire [\=log2ceil(depth)-1=\:0]  depnd\=i=\in;

  wire [\=context_width=\-1:0]             state_in\=i=\,state_out\=i=\;

  wire entry_written\=i=\       = push & valid_vector_sel[\=i=\];
  wire entry_clear\=i=\         = pop & oldest\=i=\ & (pop_id == id\=i=\);
//wire entry_match\=i=\         = pop & oldest\=i=\ & (pop_id == id\=i=\);
  wire entry_match\=i=\         =       oldest\=i=\ & (pop_id == id\=i=\);

  assign entry_clear_vec[\=i=\] = entry_clear\=i=\;
  assign entry_match_vec[\=i=\] = entry_match\=i=\;
  assign pop_match_vec[\=i=\]   = valid\=i=\ & (pop_id == id\=i=\);
  assign pop_update_vec[\=i=\]  = valid\=i=\ & oldest\=i=\ & pop_update & (pop_id == id\=i=\);

  assign   data\=i=\in          = (entry_written\=i=\)                       ? push_data                                                    : pop_update_vec[\=i=\] ? {1'b0,data\=i=\[\=wData-2=\:0]} : data\=i=\;
  assign   id\=i=\in            = (entry_written\=i=\)                       ? push_id                                                      : id\=i=\;

  assign   valid\=i=\in         = (valid\=i=\)                               ? ~entry_clear\=i=\                                            : entry_written\=i=\;
  assign   oldest\=i=\in        = (oldest\=i=\ & ~entry_written\=i=\)        ? ~entry_clear\=i=\                                            : ((entry_written\=i=\ & ~(|depnd_match_vec)) | (valid\=i=\ & entry_clear_vec[depnd\=i=\]));
  assign   youngest\=i=\in      = (youngest\=i=\ & ~entry_written\=i=\)      ? ~(push & (push_id == id\=i=\))                               : entry_written\=i=\;
  assign   depnd\=i=\in         = (entry_written\=i=\)                       ? depnd_match                                                  : depnd\=i=\;

  assign  depnd_match_vec[\=i=\] = (push_id == id\=i=\) & valid\=i=\ & youngest\=i=\ & ~entry_clear_vec[\=i=\];

  assign state_in\=i=\ = {
    data\=i=\in,
    id\=i=\in,
    valid\=i=\in,
    oldest\=i=\in,
    youngest\=i=\in,
    depnd\=i=\in
  };

  assign {
    data\=i=\,
    id\=i=\,
    valid\=i=\,
    oldest\=i=\,
    youngest\=i=\,
    depnd\=i=\
  } = state_out\=i=\;

  \=u.dffre(  context_width
          , 'state_out'+i
	  , 'state_in'+i
	  , context_width + '\'b0'
	  , "1'b1"
	  , 'clk'
	  , 'reset_n')=\

\js }

reg [\=wData-1=\:0]    r_data;

always @ (*) begin
 case(1'b1)
\js for (let i = 0; i < depth; i++) {
   entry_match_vec[\=i=\]: begin
       r_data                 = data\=i=\;
   end
\js }
   default: begin
       r_data = \=wData=\'b0;
   end
 endcase
end

assign pop_data = r_data;

\=u.instance({
    instanceName: 'u_find_first_one',
    moduleName: 'find_first_one',
    params: { width : depth},
    verilogParams: { WIDTH : depth},
    ports: {
        invec  : '~valid_vector', 
        outvec : 'valid_vector_sel'
    }
})=\

assign pop_match = |pop_match_vec;

endmodule
