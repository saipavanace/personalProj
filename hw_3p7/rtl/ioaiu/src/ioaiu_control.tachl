\jsbegin
/////////////////////////////////////////////////////////////////////////
// Arteris Inc. 2021
///////////////////////////////////////////////////////////////////////////
//////////// //////////////////////////////////////////////////////////////
// NCore 3.2
// Author : Nabil
// Date   : May 2021
//
// Description : IOAIU control.
//
//////////////////////////////////////////////////////////////////////////

var u = obj.lib;
var m = obj.userLib;
var log2ceil = function(n) { return Math.ceil(Math.log(n)/Math.LN2); };
var ioaiu_pos = function(n) { return Math.max(n,1); };

var concParams = u.getParam('concParams');
var axiParams = u.getParam('axiParams');
var ccpParams = u.getParam('ccpParams');
var sselParams = u.getParam('sselParams');
var halfSpeedOD = u.getParam('halfSpeedOD');
var owo = u.getParam('owo');
var cmType = u.getParam('cmType');
var enPoison = u.getParam('enPoison');
var useSharerPromotion = u.getParam('useSharerPromotion');
var useOwnerTransfer = u.getParam('useOwnerTransfer');
var useNoAXIDinterleave = u.getParam('useNoAXIDinterleave');
var fnDisableRdInterleave = u.getParam('fnDisableRdInterleave');
var useConnectivity = u.getParam('useConnectivity');
var useSoftwareCreditManagement = u.getParam('useSoftwareCreditManagement');
var cfgACE = u.getParam('cfgACE');
var useCache = u.getParam('useCache');
var CLO = u.getParam('CLO');
var cm_type = u.getParam('cm_type');
var AxIdProcSelectBits = u.getParam('AxIdProcSelectBits');
var usePLRU = u.getParam('usePLRU');
var ODRN = (useCache>0) ? 4 : 2;
var ACE = axiParams.eAc?axiParams.eAc:0;
var CDW = axiParams.wCdData ? axiParams.wCdData : 0;
var CDWP = enPoison ? /* istanbul ignore next env ncore_3p7 */ CDW : 0;
var ODB = u.getParam('ODB');
var ODN = u.getParam('ODN');
var STE = ACE | (useCache>0);
var CTKM = u.getParam('CTKM');
var MTKM = u.getParam('MTKM');
var ITKM = u.getParam('ITKM');
var VTKM = u.getParam('VTKM');
var CTKS = u.getParam('CTKS');
var MTKS = u.getParam('MTKS');
var ITKS = u.getParam('ITKS');
var VTKS = u.getParam('VTKS');
var CWKS = u.getParam('CWKS');
var MWKS = u.getParam('MWKS');
var IWKS = u.getParam('IWKS');
var VWKS = u.getParam('VWKS');
var isDvmAgent = u.getParam('isDvmAgent');
var COH_MSI = u.getParam('COH_MSI');
var COH_MOESI = u.getParam('COH_MOESI');
var COH_MEI = 0;
var COH_MOSI = 0;
var nSelectBits = u.getParam('nSelectBits');
var CGE = u.getParam('CGE');
var LIDE = u.getParam('LIDW');
var LIDW = ioaiu_pos(LIDE);
var SECS = u.getParam('SECS');
var PRIS = u.getParam('PRIS');
var ODEE = u.getParam('ODEE');
var ODEW = u.getParam('ODEW');
var QMAP = u.getParam('QMAP');
var STP = u.getParam('STP');
var P0E = u.getParam('P0E');
var DRST = u.getParam('DRST');
var XO = u.getParam('XO');
var CTW = u.getParam('CTW');
var WAYS = ccpParams.nWays ? ccpParams.nWays : 1;
var eStarve = u.getParam('eStarve');
var PIDW = u.getParam('PIDW');
var FIDW = u.getParam('FIDW');
var QOSN = u.getParam('QOSN');
var QOSW = (QOSN>0) ? log2ceil(QOSN) : 1;
var QOSE = QOSN;
var QOSA = QOSE>0 ? 1 : 0;
var CST_IX = "3'h0";                                    //ccpParams.Invalid;
var CST_SC = !useCache ? "3'h0" : "3'h1";               //ccpParams.SharedClean;
var CST_SD = !useCache ? "3'h0" : "3'h3";               //ccpParams.SharedDirty;
var CST_UC = !useCache ? "3'h0" : "3'h5";               //ccpParams.UniqueClean;
var CST_UD = !useCache ? "3'h0" : "3'h7";               //ccpParams.UniqueDirty;

var ODDW = u.getParam('ODDW');
var ODAW = u.getParam('ODAW');
var ODDRW = u.getParam('ODDRW');
var OCN = u.getParam('OCN');
var OCA = log2ceil(OCN);
var OLA = log2ceil(OCN);
var OTEN = ((OCN>=48) || (OCN==10)) ? 1 : owo ? 1 : 0;
var P1EN = (useCache || (OTEN))?1:0;
var W2EN = 1;
var AW = axiParams.wAddr;
var DW = axiParams.wData
var DWP = enPoison?/* istanbul ignore next env ncore_3p7 */axiParams.wData/64:1;
var AWL = log2ceil(DW/8); //Bus aligned address
var BWL = u.getParam('BWL');
var BPL = 1<<BWL;
var BW = axiParams.wData/8;
var CSW = u.getParam('CSW');
var CKB = u.getParam('CKB');
var CTB = u.getParam('CTB');
var STN = u.getParam('STN');
var STA = ioaiu_pos(log2ceil(STN));
var XTA = Math.max(STA,OCA);
var XTAW = Math.pow(2,XTA);

var IW    = Math.max(axiParams.wArId,axiParams.wAwId);
var AXUW  = Math.max(axiParams.wArUser,axiParams.wAwUser,1);
var AXKW  = Math.max(axiParams.wLoop?axiParams.wLoop:0+axiParams.eTrace?axiParams.eTrace:0,1);
var WDUW  = Math.max(axiParams.wWUser,1);
var BUW   = Math.max(axiParams.wBUser,1);

var ODPW  = (CDW>1) ? 4+2 : 2+2;
var ODRIW = AXKW+OCA+1+IW+1+ODPW+1;
var ODFIW = OCA+BWL+1;
var ODWIW = OCA+BWL+1;
var ODIW  = Math.max(ODRIW, ODFIW)+1;

var ODIES = (ODRN==2) ? [0, 1, 1] : [1, 1, 1, 0];
ODIES.reverse();
var ODIWS = (ODRN==2) ? [0, ODFIW, ODRIW] : [ODWIW, ODFIW, ODRIW, 1];
ODIWS.reverse();

var enPoison = u.getParam('enPoison');

var enSRAMPipe = u.getParam('enSRAMPipe');
var nProcs = u.getParam('nProcs');

var evictDataFifoWidth = 1+(DW/8)+DW+DWP;

// Needs to match depth of Info FIFO in ioaiu_cache (EID) = {1'b1, {BWL{1'b0}}} + 9 multiplied by beats per cacheline
var evictDataFifoDepth = (Math.pow(2,BWL) + 9) * (512/DW);

var RMIDS = Math.max(STN,OCN);
var wRMIDS = log2ceil(RMIDS);

var nDCEs      		   = u.getParam('nDCEs');
var nDMIs      		   = u.getParam('nDMIs');
var nDIIs      		   = u.getParam('nDIIs');
var nDVEs      		   = u.getParam('nDVEs');
var nCreditRegs            = u.getParam('nCreditRegs');

var wOCN = log2ceil(OCN);
var ageBuffEntries = OCN; //Math.min(OCN, 32);

var useSysEvtReceiver = u.getParam('useSysEvtReceiver');
var useSysCohSender = u.getParam('useSysCohSender');
var nativeTrigger = u.getParam('nativeTrigger');
var noCacheLineInterleave = u.getParam('noCacheLineInterleave');

var useEarlyDtr = true;

// eP0(P0E)  P0T                     P0D
// --------------------------------------------------
//   0         1   dwPipeFwd==no       1   w0Depth==1
//                 p0rPipeFwd==no          p0rDepth==1
//                 w0PipeFwd==no           w0Depth==1
// 
//   1         0   dwPipeBck==no       1   w0Depth==1
//                 p0rPipeFwd==no          p0rDepth==1
//                 w0PipeFwd==no           w0Depth==1
// 
//   2         3                       2   w0Depth==2
//                                         p0rDepth==2
//                                         w0Depth==2
var P0T = (P0E==0) ? /* istanbul ignore next env ncore_3p7 */1 :
                    (P0E==1) ? /* istanbul ignore next env ncore_3p7 */0 :
                    3;
var P0D = (P0T==3) ? P0E : /* istanbul ignore next env ncore_3p7 */1;

var AXI = ((!axiParams.eDomain) && (useCache == 0));
var CMHT = concParams.hdrParams.wTargetId;
var CMHI = concParams.hdrParams.wInitiatorId;
var CMHM = concParams.hdrParams.wMsgId;
var CMHH = concParams.hdrParams.wHProt;
//var CMHE = concParams.hdrParams.wTTier;
//var CMHS = concParams.hdrParams.wSteering;
var CMHP = concParams.hdrParams.wPriority;
var CMHL = concParams.hdrParams.wQl;

var SRCM = CMHM;
var SRCI = CMHI;

var MRCA = concParams.cmdReqParams.wAddr;
var MRC1 = concParams.cmdReqParams.wMpf1;
var MRC2 = concParams.cmdReqParams.wMpf2;
var MRCF = concParams.cmdReqParams.wTof;
var MRCQ = concParams.cmdReqParams.wQos;
var MRCX = concParams.cmdReqParams.wNdpAux;
var MRCD = concParams.cmdReqParams.wDId;
var MRCH = concParams.cmdReqParams.wMProt;

var MRRR = concParams.dtrReqParams.wMsgId;
var MRRD = concParams.dtrReqParams.wData;
var MRRB = MRRD/8;
var MRRZ = MRRD/64;
var MRRU = concParams.dtrReqParams.wUser;
var MRRX = concParams.dtrReqParams.wNdpAux;
var MRRH = concParams.dtrReqParams.wMProt;
var MRRO = concParams.dtrReqParams.wDProt;
var MRRM = CMHM;
var MRRT = CMHT;
var MRCM = CMHM;
var MRCT = CMHT;

var MRWV = concParams.dtwReqParams.wRBID;
var MRW1 = concParams.dtwReqParams.wMpf1;
var MRW2 = concParams.dtwReqParams.wMpf2;
var MRWD = concParams.dtwReqParams.wData;
var MRWB = MRWD/8;
var MRWZ = MRWD/64;
var MRWU = concParams.dtwReqParams.wUser;
var MRWX = concParams.dtwReqParams.wNdpAux;
var MRWH = concParams.dtwReqParams.wMProt;
var MRWO = concParams.dtwReqParams.wDProt;
var MRWT = CMHT;
var MRWM = CMHM;

var MRUA = concParams.updReqParams.wAddr;
var MRUQ = concParams.updReqParams.wQos;
var MRUH = concParams.updReqParams.wMProt;
var MRUT = CMHT;
var MRUM = CMHM;

var MPCT = CMHT;
var MPCI = CMHI;

var SRCR = concParams.strReqParams.wMsgId;
var SRCB = concParams.strReqParams.wRBID;
var SRC1 = concParams.strReqParams.wMpf1;
var SRC2 = concParams.strReqParams.wMpf2;

var SPCR = concParams.strRspParams.wMsgId;
var SPCH = concParams.strRspParams.wMProt;
var SPCR = SPCR;
var SPCT = CMHT;
var SPCI = CMHI;

var SRRR = concParams.dtrReqParams.wMsgId;
var SRRD = concParams.dtrReqParams.wData;
var SRRB = SRRD/8;
var SRRZ = SRRD/64;
var SRRP = ioaiu_pos(CMHP);
var SRRM = CMHM;
var SRRI = CMHI;
var SRRU = concParams.dtrReqParams.wUser;
var SPRR = concParams.dtrRspParams.wMsgId;
var SPRH = concParams.dtrRspParams.wMProt;
var SPRT = CMHT;

var SRNA = concParams.snpReqParams.wAddr;
var SRN1 = concParams.snpReqParams.wMpf1;
var SRN2 = concParams.snpReqParams.wMpf2;
var SRN3 = concParams.snpReqParams.wMpf3;
var SRND = concParams.snpReqParams.wDId;
var SRNF = concParams.snpReqParams.wTof;
var SRNB = concParams.snpReqParams.wRBID;
var SRNP = ioaiu_pos(CMHP);
var SRNI = CMHI;
var SRNM = CMHM;

var SPNR = concParams.snpRspParams.wMsgId;
var SPN1 = concParams.snpRspParams.wMpf1;
var SPNH = concParams.snpRspParams.wMProt;
var SPN1 = SPN1;
var SPNR = SPNR;
var SPNI = CMHI;
var SPNT = CMHT;

var SPVR = concParams.cmpRspParams.wMsgId;
var SPVH = concParams.cmpRspParams.wMProt;

var XO = `1'b0`;

var assertOn = u.getParam('assertOn');

var MRRDB = (MRRD==256) ? 12 : (MRRD==128) ? 6 :3;
var QW = axiParams.wQos?4:1;
var MW = axiParams.eDomain?2:1;
var SW = (axiParams.eDomain) ?4:1;
var CWW = ioaiu_pos(log2ceil(WAYS));
var ODA = log2ceil(ODN);
var SHLW = Math.max(concParams.strReqParams.wMpf2, 5);
var TINW = ioaiu_pos(log2ceil(Math.max(nDCEs, nDMIs, nDIIs)));
var AWTW = (axiParams.eAtomic>0) ? 6 : 1;
var AWSE = (axiParams.eStash>0) ? 18 : 0;
var AWSW = (axiParams.eStash>0) ? 1+5+1+FIDW : 1;
var ARPW = axiParams.wResp;
var RW = axiParams.wRegion?/* istanbul ignore next env ncore_3p7 */axiParms.wRegion:1;
var RUW = ioaiu_pos(axiParams.wRUser);
var WDUW = ioaiu_pos(axiParams.wWUser);
var BUW = ioaiu_pos(axiParams.wBUser);
var AXW = AW+21+RW+QW+IW+MW+SW+MW+AXUW+AXKW;
var PXW = AXW+AWTW+AWSW+XTA+5;
var AMCW = (P1EN>0) ? 5+4+3*FIDW+3*5+3+5 : 1;
var MRRW = 3+(MRWZ*3)+MRRB+MRRD+DWP+QOSW+MRRT+MRRM+MRRR+8;
var BSE = STE && (MRRD>64);
var MRWW = 3+(MRWZ*3)+MRWB+MRWD+1+DWP+QOSW+MRWT+MRWM+MRWV+MRW1+MRW2+10+2;
var DRW = AXKW+IW+ARPW+1+DW+DWP;
var SPNW = 8+SRCM+SPNT+SRNP;
var SPCW = 8+SPCR+SPCT+QOSW;
var SPRW = 8+SRRP+SRRM+SPRT;

//Function called but within jsbegin/end
/* istanbul ignore next env ncore_3p7 */
function set_select (sselParams,aname) {
    var SecSubRows = m.convertSecSubRowsToOld(sselParams.SecSubRows); // convert array of string (verilog hex format) to array of positive integer
    var nSelectBits = sselParams.PriSubDiagAddrBits.length;
//    var strg = "assign index_out_vec["+(nSelectBits-1)+":0] = {";
    var strg = "{";
    for (var i = nSelectBits-1; i>=0; i--) {
        strg += "^{";
        var PrimaryBit = sselParams.PriSubDiagAddrBits[i];
        var SecRow     = SecSubRows[i];
        strg += aname+"["+PrimaryBit+"]";
        /* istanbul ignore next env ncore_3p2, ncore_3p4, ncore_3p6,ncore_3p7 */
        for (var SecBit = SecRow.length-1; SecBit >=0; SecBit--) {
            var SecRowBit = SecRow[SecBit];
            strg += ", "+aname+"["+SecRowBit+"]";
        }
        strg += "}";
        strg += i>0 ? "," :"";
    }
    strg += "}";
    return(strg);
}

var CLK_ASSERT_INTF = [];
/* istanbul ignore else env ncore_3p7 */
if (assertOn) {
var clkAssertInterface = { name : '', signals : {'clk_i' : 1,'reset_ni' : 1}};
} else {
var clkAssertInterface = { };
}

\jsend

/////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

module \=u.getModuleName()=\ (
	myid_i,
	dce_ids_i,
	dmi_ids_i,
	dii_ids_i,
	dve_ids_i,
	external_i,
	csr_id_i,
        clk_en,
        clk_i_ng,
        test_en_i,
	reset_ni,
	bist_timeout_trigger,
	rack_i,		wack_i,
	ar_ready_o,	aw_ready_o,	dw_ready_o,	
	ar_valid_i,	aw_valid_i,	dw_valid_i,	
	ar_addr_i,	aw_addr_i,	dw_wdata_i,     dw_poison_i,	
	ar_len_i,	aw_len_i,	dw_be_i,	
	ar_size_i,	aw_size_i,	dw_last_i,	
	ar_burst_i,	aw_burst_i,	dw_user_i,
	ar_lock_i,	aw_lock_i,	dw_trace_i,
	ar_cache_i,	aw_cache_i,
	ar_prot_i,	aw_prot_i,
	ar_region_i,	aw_region_i,
	ar_qos_i,	aw_qos_i,
	ar_id_i,	aw_id_i,
	ar_bar_i,	aw_bar_i,
	ar_snoop_i,	aw_snoop_i,
	ar_domain_i,	aw_domain_i,
	ar_user_i,	aw_user_i,
	ar_track_i,	aw_track_i,
			aw_atop_i,
			aw_stashid_i,
        ar_vmidext_i,

	dr_ready_i,	pw_ready_i,
	dr_valid_o,	pw_valid_o,
	dr_resp_o,	pw_resp_o,
	dr_id_o,	pw_id_o,
	dr_user_o,	pw_user_o,
	dr_track_o,	pw_track_o,
	dr_rdata_o,
	dr_last_o,
	dr_poison_o,

	ac_ready_i,	cr_ready_o,	cd_ready_o,
	ac_valid_o,	cr_valid_i,	cd_valid_i,
	ac_addr_o,	cr_resp_i,	cd_data_i,      cd_poison_i,
	ac_snoop_o,			cd_last_i,
	ac_prot_o,
	ac_track_o,
        ac_vmidext_o,

	cmd_req_ready_i,	dtr_req_tx_ready_i,	dtw_req_ready_i,	upd_req_ready_i,
	cmd_req_valid_o,	dtr_req_tx_valid_o,	dtw_req_valid_o,	upd_req_valid_o,
			dtr_req_tx_last_o,	dtw_req_last_o,
	cmd_req_tid_o,	dtr_req_tx_tid_o,	dtw_req_tid_o,	upd_req_tid_o,
	cmd_req_iid_o,	dtr_req_tx_iid_o,	dtw_req_iid_o,	upd_req_iid_o,
	cmd_req_mid_o,	dtr_req_tx_mid_o,	dtw_req_mid_o,	upd_req_mid_o,
			dtr_req_tx_rid_o,
					dtw_req_bid_o,
	cmd_req_cmd_o,	dtr_req_tx_cmd_o,	dtw_req_cmd_o,	upd_req_cmd_o,
	cmd_req_pri_o,	dtr_req_tx_pri_o,	dtw_req_pri_o,	upd_req_pri_o,
	cmd_req_ql_o,	dtr_req_tx_ql_o,	dtw_req_ql_o,	upd_req_ql_o,
	cmd_req_status_o,	dtr_req_tx_status_o,	dtw_req_status_o,	upd_req_status_o,
	cmd_req_addr_o,					upd_req_addr_o,
	cmd_req_attr_o,	dtr_req_tx_attr_o,	dtw_req_attr_o,	upd_req_attr_o,
	cmd_req_mpf1_o,			dtw_req_mpf1_o,
	cmd_req_mpf2_o,			dtw_req_mpf2_o,
	cmd_req_size_o,
	cmd_req_isize_o,			dtw_req_isize_o,
	cmd_req_did_o,
	cmd_req_tof_o,
	cmd_req_qos_o,					upd_req_qos_o,
	                                                upd_req_trace_o,
	cmd_req_aux_o,
			dtr_req_tx_dwid_o,	dtw_req_dwid_o,
			dtr_req_tx_poison_o,	dtw_req_poison_o,
			dtr_req_tx_data_o,	dtw_req_data_o,
			dtr_req_tx_be_o,	dtw_req_be_o,
			dtr_req_tx_user_o,	dtw_req_user_o,

	cmd_rsp_ready_o,	dtr_rsp_rx_ready_o,	dtw_rsp_ready_o,	upd_rsp_ready_o, 
	cmd_rsp_valid_i,	dtr_rsp_rx_valid_i,	dtw_rsp_valid_i,	upd_rsp_valid_i, 
	cmd_rsp_mid_i,	dtr_rsp_rx_mid_i,	dtw_rsp_mid_i,	upd_rsp_mid_i, 
	cmd_rsp_tid_i,	dtr_rsp_rx_tid_i,	dtw_rsp_tid_i,	upd_rsp_tid_i, 
	cmd_rsp_iid_i,	dtr_rsp_rx_iid_i,	dtw_rsp_iid_i,	upd_rsp_iid_i,
	cmd_rsp_status_i,	dtr_rsp_rx_status_i,	dtw_rsp_status_i,	upd_rsp_status_i,
			dtr_rsp_rx_attr_i,	dtw_rsp_attr_i,
	cmd_rsp_uce_i,	dtr_rsp_rx_uce_i,	dtw_rsp_uce_i,	upd_rsp_uce_i,
	cmd_rsp_ce_i,	dtr_rsp_rx_ce_i,	dtw_rsp_ce_i,	upd_rsp_ce_i,

	str_req_ready_o,	dtr_req_rx_ready_o,	snp_req_ready_o, 	cmp_rsp_ready_o,
	str_req_valid_i,	dtr_req_rx_valid_i,	snp_req_valid_i, 	cmp_rsp_valid_i,
			dtr_req_rx_last_i,
			dtr_req_rx_pri_i,	snp_req_pri_i,
	str_req_mid_i,	dtr_req_rx_mid_i,	snp_req_mid_i,	cmp_rsp_mid_i,
	str_req_rid_i,	dtr_req_rx_rid_i,
	str_req_bid_i,			snp_req_bid_i,
	str_req_iid_i,	dtr_req_rx_iid_i,	snp_req_iid_i,      cmp_rsp_iid_i,
	str_req_tid_i,	dtr_req_rx_tid_i,	snp_req_tid_i,	cmp_rsp_tid_i,
	str_req_cmd_i,	dtr_req_rx_cmd_i,	snp_req_cmd_i,
	str_req_status_i,	dtr_req_rx_status_i,	snp_req_status_i,	cmp_rsp_status_i,
			dtr_req_rx_dbad_i,
			dtr_req_rx_data_i,
			dtr_req_rx_be_i,
					snp_req_addr_i,
	str_req_isize_i,			snp_req_isize_i,
			dtr_req_rx_attr_i,	snp_req_attr_i,
	str_req_mpf1_i,			snp_req_mpf1_i,
	str_req_mpf2_i,			snp_req_mpf2_i,
					snp_req_mpf3_i,
					snp_req_did_i,
					snp_req_tof_i,
	str_req_uce_i,	dtr_req_rx_uce_i,	snp_req_uce_i,	cmp_rsp_uce_i,
	str_req_ce_i,	dtr_req_rx_ce_i,	snp_req_ce_i,	cmp_rsp_ce_i,

	str_rsp_ready_i,	dtr_rsp_tx_ready_i,	snp_rsp_ready_i, 
	str_rsp_valid_o,	dtr_rsp_tx_valid_o,	snp_rsp_valid_o, 
	str_rsp_tid_o,	dtr_rsp_tx_tid_o,	snp_rsp_tid_o,
	str_rsp_iid_o,	dtr_rsp_tx_iid_o,	snp_rsp_iid_o,
	str_rsp_mid_o,	dtr_rsp_tx_mid_o,	snp_rsp_mid_o,
	str_rsp_rid_o,	dtr_rsp_tx_rid_o,	snp_rsp_rid_o,
	str_rsp_pri_o,	dtr_rsp_tx_pri_o,	snp_rsp_pri_o,
	str_rsp_ql_o,	dtr_rsp_tx_ql_o,	snp_rsp_ql_o,
			dtr_rsp_tx_cmd_o,	snp_rsp_cmd_o,
	str_rsp_trace_o,    dtr_rsp_tx_trace_o,    snp_rsp_trace_o,
	str_rsp_status_o,	dtr_rsp_tx_status_o,	snp_rsp_status_o,
					snp_rsp_mpf1_o,

	od_we_o,
	od_waddr_o,
	od_wdata_o,
	od_wecc_o,
	od_re_o,
	od_raddr_o,
	od_rdata_i,
	od_recc_i,

	amc_val_evict_o,
	amc_addr_evict_o,
	amc_vals_evict_i,

	amc_val_o,
	amc_addr_o,
	amc_ignore_o,
	amc_security_o,
	amc_vals_i,
	amc_fids_i,
	amc_tins_i,
	amc_mig_i,
	amc_errs_i,
	amc_order_i,
        amc_size_of_ig_i,
        amc_nrs_region_hit_i,
\js if ((axiParams.eDomain?1:0)==0) {
        amc_nc_i,
        amc_nc_evict_i,	
\js }
        amc_unconnected_dce_access,
        amc_unconnected_dmi_access,
        amc_unconnected_dii_access,

	ccp_init_o,	ccp_ready_i,
	cp0_ready_i,
	cp0_valid_o,
	cp0_addr_o,
	cp0_security_o,
	cp2_alloc_o,
	cp2_rd_o,
	cp2_wr_o,
	cp2_port_o,
	cp2_lru_o,
	cp2_update_o,
	cp2_nstate_o,
	cp2_len_o,
	cp2_busy_o,
	cp2_evict_i,
	cp2_eaddr_i,
	cp2_esecurity_i,
	cp2_estate_i,
	cp2_valid_i,
	cp2_cstate_i,
	cp2_cnru_i,
	cp2_hits_i,
	cp2_ways_i,
	cp2_nacks_i,
	cp2_setw_o,
	cp2_setn_o,
	cp2_wayn_o,
	cfd_ready_i,
	cfd_valid_o,
        cfd_full_o,
	cfd_poison_o,
	cfd_data_o,
	cfd_be_o,
	cfd_way_o,
	cfd_last_o,
	cfd_beat_o,
	cfd_addr_o,
	cfd_oid_o,
	cfd_done_i,
	cfd_nid_i,
	cft_ready_i,
	cft_valid_o,
	cft_state_o,
	cft_addr_o,
	cft_security_o,
	cft_way_o,
	ccd_ready_o,
	ccd_valid_i,
	ccd_poison_i,
	ccd_rdata_i,
	ccd_be_i,
	ccd_last_i,
	ccd_cancel_i,
	ccw_ready_i,
	ccw_valid_o,
	ccw_poison_o,
	ccw_wdata_o,
	ccw_be_o,
	ccw_offset_o,
	ccw_last_o,
	cce_ready_o,
	cce_valid_i,
	cce_poison_i,
	cce_rdata_i,
	cce_be_i,
	cce_last_i,
	cce_cancel_i,
	cmr_init_i,
	cmr_ready_o,
	cmr_valid_i,
	cmr_cmd_i,
	cmr_way_i,
	cmr_addr_i,
	cmr_security_i,
	cmr_last_i,
	cmr_done_o,
	cfg_rproducer_i, cfg_wproducer_i,
	cfg_tperiod_i, cfg_top_i, cfg_external_i,
	cfg_eperiod_i, cfg_evp_i,
        cfg_useEvQos_i, 
        cfg_evQos_i,
	cfg_dcredit_i, cfg_mcredit_i, cfg_icredit_i, cfg_vcredit_i, 
						     cfg_qcredit_i,
	cfg_cmd_req_max_i, cfg_dtr_req_tx_max_i, cfg_dtw_req_max_i, cfg_upd_req_max_i,
	cfg_rd_pool_i, cfg_wr_pool_i,
	cfg_st_limit_i, 
	cfg_oc_limit_i, cfg_rd_limit_i, cfg_wr_limit_i, cfg_ev_limit_i,
	cfg_control_i,
	cfg_cache_i,
	cfg_alloc_i,
	cfg_update_i,
	            uerrs_o, uinfo_o,
	            cerrs_o, cinfo_o,
	elog_o,
	eaddr_o,
	starve_o,
	ctar_o,
	interleaved_count_o,
	idle_o,

        pmon_address_collision,
	pmon_cache_r_hit,
	pmon_cache_w_hit,
	pmon_cache_s_hit,
	pmon_cache_evict,
	pmon_no_ways,
	pmon_cache_f_stall,
	pmon_cache_r_stall,
	pmon_cache_w_stall,
	pmon_cache_replay,
	pmon_cache_r_miss,
	pmon_cache_w_miss,
	pmon_cache_s_miss,
	pmon_ott_entries,

        pmon_ott_read_latency_alloc,
        pmon_ott_read_latency_dealloc,

        pmon_ott_write_latency_alloc,
        pmon_ott_write_latency_dealloc,

        dtw_dbg_rsp_valid_i,
	dtw_dbg_rsp_ready_i,
	dtw_dbg_rsp_tid_i,
	dtw_dbg_rsp_iid_i,
	dtw_dbg_rsp_uce_i,
	dtw_dbg_rsp_ce_i,
	
        sysrq_valid_i,
	sysrq_ready_i,
	sysrq_tid_i,
	sysrq_iid_i,
	sysrq_uce_i,
	sysrq_ce_i,

	sysrp_valid_i,
	sysrp_ready_i,
	sysrp_tid_i,
	sysrp_iid_i,
	sysrp_uce_i,
	sysrp_ce_i,

\js for ( let i = 0; i < nDCEs; i++ ) {
        XAIUCCR\=i=\_DCECounterState_in,
        XAIUCCR\=i=\_DCECounterState_wr,
        XAIUCCR\=i=\_DCECreditLimit_out,
        XAIUCCR\=i=\_DCECounterState_out,
\js }

\js for ( let i = 0; i < nDMIs; i++ ) {
        XAIUCCR\=i=\_DMICounterState_in,
        XAIUCCR\=i=\_DMICounterState_wr,
        XAIUCCR\=i=\_DMICreditLimit_out,
        XAIUCCR\=i=\_DMICounterState_out,
\js }

\js for ( let i = 0; i < nDIIs; i++ ) {
        XAIUCCR\=i=\_DIICounterState_in,
        XAIUCCR\=i=\_DIICounterState_wr,
        XAIUCCR\=i=\_DIICreditLimit_out,
        XAIUCCR\=i=\_DIICounterState_out,
\js }
        hexAiuDceVec,
        hexAiuDmiVec,
        hexAiuDiiVec,

\js if (nativeTrigger.signals.user>0) {
        trace_user,
\js }
	trace_addr,
	trace_opcode,
	trace_dmi_hit,
	trace_dii_hit,
	trace_hui,
	trace_aw,
	trace_ar,
	trace_memattr,
	trace_trace,
	trace_size_of_ig,

	tracetag,
	outstanding_coherent_count_zero
);

   localparam XO = \=XO=\;
   localparam FIDW = \=FIDW=\;
   localparam PIDW = \=PIDW=\;
   localparam DCEN = \=nDCEs=\;
   localparam DMIN = \=nDMIs=\;
   localparam DIIN = \=nDIIs=\;
   localparam DVEN = \=nDVEs=\;
   localparam QOSE = \=QOSN=\;
   localparam QOSN = \=ioaiu_pos(QOSN)=\;

   localparam CACHE = \=useCache=\;
   localparam WAYS = \=WAYS=\;
   localparam CWW = \=CWW=\;
   localparam CLO = \=CLO=\;
   localparam CSW = \=CSW=\;
   localparam CTB = \=CTB=\;
   localparam CTW = \=CTW=\;
   localparam OCN = \=OCN=\;
   localparam OLN = \=OCN=\;
   localparam ODN = \=ODN=\;
   localparam ODB = \=ODB=\;
   localparam ODAW = \=ODAW=\;
   localparam ODDW = \=ODDW=\;
   localparam ODEW = \=ODEW=\;
   localparam STN = \=STN=\;
   localparam AWTW = \=AWTW=\;
   localparam AWSE = \=AWSE=\;
   localparam AWSW = \=AWSW=\;
   localparam SW = \=SW=\;
   localparam MW = \=MW=\;
   localparam IW = \=IW=\;
   localparam NPROCS = \=nProcs=\;
   localparam LIDE = \=LIDE=\;
   localparam LIDW = \=LIDW=\;
   localparam AW = \=AW=\;
   localparam QW = \=QW=\;
   localparam RW = \=RW=\;
   localparam AXUW = \=AXUW=\;
   localparam AXKW = \=AXKW=\;
   localparam DW = \=DW=\;
   localparam DWP = \=DWP=\;
   localparam BWL = \=BWL=\;
   localparam BW = \=BW=\;
   localparam OCA = \=OCA=\;
   localparam ARPW = \=ARPW=\;
   localparam RUW = \=RUW=\;
   localparam WDUW = \=WDUW=\;
   localparam BUW = \=BUW=\;
   localparam ACE = \=ACE=\;
   localparam CDW = \=ioaiu_pos(CDW)=\;
   localparam CDWP = \=ioaiu_pos(CDWP)=\;

localparam MRCT = \=CMHT=\;
localparam MRCI = \=CMHI=\;
localparam MRCM = \=CMHM=\;
localparam MRCP = \=ioaiu_pos(CMHP)=\;
localparam MRCL = \=ioaiu_pos(CMHL)=\;
localparam MRCA = \=MRCA=\;
localparam MRC1 = \=MRC1=\;
localparam MRC2 = \=MRC2=\;
localparam MRCF = \=MRCF=\;
localparam MRCQ = \=ioaiu_pos(MRCQ)=\;
localparam MRCX = \=ioaiu_pos(MRCX)=\;
localparam MRCD = \=MRCD=\;

localparam MPCT = \=CMHT=\;
localparam MPCI = \=CMHI=\;

localparam MRRT = \=CMHT=\;
localparam MRRI = \=CMHI=\;
localparam MRRM = \=CMHM=\;
localparam MRRR = \=MRRR=\;
localparam MRRD = \=MRRD=\;
localparam MRRB = \=MRRB=\;
localparam MRRZ = \=MRRZ=\;
localparam MRRU = \=ioaiu_pos(MRRU)=\;
localparam MRRP = \=ioaiu_pos(CMHP)=\;
localparam MRRL = \=ioaiu_pos(CMHL)=\;

localparam MRWT = \=CMHT=\;
localparam MRWI = \=CMHI=\;
localparam MRWM = \=CMHM=\;
localparam MRWV = \=MRWV=\;
localparam MRWP = \=ioaiu_pos(CMHP)=\;
localparam MRWL = \=ioaiu_pos(CMHL)=\;
localparam MRW1 = \=MRW1=\;
localparam MRW2 = \=MRW2=\;
localparam MRWD = \=MRWD=\;
localparam MRWB = \=MRWB=\;
localparam MRWZ = \=MRWZ=\;
localparam MRWU = \=ioaiu_pos(MRWU)=\;

localparam MRUT = \=CMHT=\;
localparam MRUI = \=CMHI=\;
localparam MRUM = \=CMHM=\;
localparam MRUP = \=ioaiu_pos(CMHP)=\;
localparam MRUL = \=ioaiu_pos(CMHL)=\;
localparam MRUA = \=MRUA=\;
localparam MRUQ = \=ioaiu_pos(MRUQ)=\;
localparam MPUT = \=CMHT=\;
localparam MPUI = \=CMHI=\;

localparam MPRT = \=CMHT=\;
localparam MPRI = \=CMHI=\;
localparam MPWT = \=CMHT=\;
localparam MPWI = \=CMHI=\;

localparam SRCI = \=CMHI=\;
localparam SRCT = \=CMHT=\;
localparam SRCM = \=CMHM=\;
localparam SRCR = \=SRCR=\;
localparam SRCB = \=SRCB=\;
localparam SRC1 = \=SRC1=\;
localparam SRC2 = \=SRC2=\;
localparam SPCR = \=SPCR=\;
localparam SPCT = \=CMHT=\;
localparam SPCI = \=CMHI=\;
localparam SPCP = \=ioaiu_pos(CMHP)=\;
localparam SPCL = \=ioaiu_pos(CMHL)=\;

localparam SRRI = \=CMHI=\;
localparam SRRT = \=CMHT=\;
localparam SRRM = \=CMHM=\;
localparam SRRR = \=SRRR=\;
localparam SRRD = \=SRRD=\;
localparam SRRB = \=SRRB=\;
localparam SRRZ = \=SRRZ=\;
localparam SPRT = \=CMHT=\;
localparam SPRI = \=CMHI=\;
localparam SPRP = \=ioaiu_pos(CMHP)=\;
localparam SPRL = \=ioaiu_pos(CMHL)=\;
localparam SPRR = \=SPRR=\;

localparam SRNI = \=CMHI=\;
localparam SRNT = \=CMHT=\;
localparam SRNM = \=CMHM=\;
localparam SRNB = \=SRNB=\;
localparam SRNA = \=SRNA=\;
localparam SRN1 = \=SRN1=\;
localparam SRN2 = \=SRN2=\;
localparam SRN3 = \=SRN3=\;
localparam SRND = \=SRND=\;
localparam SRNF = \=SRNF=\;
localparam SRNP = \=ioaiu_pos(CMHP)=\;
localparam SRRP = \=ioaiu_pos(CMHP)=\;
localparam SPN1 = \=SPN1=\;
localparam SPNR = \=SPNR=\;
localparam SPNI = \=CMHI=\;
localparam SPNT = \=CMHT=\;
localparam SPNP = \=ioaiu_pos(CMHP)=\;
localparam SPNL = \=ioaiu_pos(CMHL)=\;

   localparam QOSA = \=QOSA=\;
   localparam OTEN = \=OTEN=\;
   localparam P1EN = \=P1EN=\;
   localparam TINW = \=TINW=\;
   localparam QOSW = \=QOSW=\;
   localparam DOFF = \=ioaiu_pos(nSelectBits)=\;
   localparam AWL = \=AWL=\;
   localparam ODA = \=ODA=\;
   localparam OLA = \=OLA=\;
   localparam STA = \=STA=\;
   localparam XTA = \=XTA=\;
   localparam RMIDS = \=RMIDS=\;
   localparam ODPW = \=ODPW=\;
   localparam ODRN = \=ODRN=\;
   localparam ODRIW = \=ODRIW=\;
   localparam ODFIW = \=ODFIW=\;
   localparam ODWIW = \=ODWIW=\;
   localparam ODIW = \=ODIW=\;
   localparam STE = \=STE=\;
   localparam BSE = STE & (MRRD>64);
   localparam MRRDB = \=MRRDB=\;

   localparam CST_IX = 3'h0;
   localparam CST_SC = \=CST_SC=\;
   localparam CST_SD = \=CST_SD=\;
   localparam CST_UC = \=CST_UC=\;
   localparam CST_UD = \=CST_UD=\;
   localparam TOF_CHI = 3'h1;

   localparam XTAW = \=XTAW=\;

localparam ReadClean = \=cmType.CmdRdCln=\;
localparam ReadUnique = \=cmType.CmdRdUnq=\;
localparam ReadNotSharedDirty = \=cmType.CmdRdNshDty=\;
localparam CleanUnique = \=cmType.CmdClnUnq=\;
localparam MakeUnique = \=cmType.CmdMkUnq=\;
localparam CleanInvalid = \=cmType.CmdClnInv=\;
localparam MakeInvalid = \=cmType.CmdMkInv=\;
localparam ReadNonCoherent = \=cmType.CmdRdNC=\;
localparam DVMOp = \=cmType.CmdDvmMsg=\;
localparam WriteUniqueFull = \=cmType.CmdWrUnqFull=\;
localparam WriteNonCohPtl = \=cmType.CmdWrNCPtl=\;
localparam WriteNonCohFull = \=cmType.CmdWrNCFull=\;
localparam WriteEvict = \=cmType.CmdWrEvict=\;
localparam CleanSharedPersist = \=cmType.CmdClnShPsist=\;
localparam SnpClnDtr = \=cmType.SnpClnDtr=\;
localparam SnpNITC = \=cmType.SnpNitc=\;
localparam SnpVldDtr = \=cmType.SnpVldDtr=\;
localparam SnpInvDtr = \=cmType.SnpInvDtr=\;
localparam SnpInvDtw = \=cmType.SnpInvDtw=\;
localparam SnpInv = \=cmType.SnpInv=\;
localparam SnpVldDtw = \=cmType.SnpClnDtw=\;
localparam SnpNoSDInt = \=cmType.SnpNoSDInt=\;
localparam SnpInvStsh = \=cmType.SnpInvStsh=\;
localparam SnpUnqStsh = \=cmType.SnpUnqStsh=\;
localparam SnpStshShd = \=cmType.SnpStshShd=\;
localparam SnpStshUnq = \=cmType.SnpStshUnq=\;
localparam SnpDvmMsg = \=cmType.SnpDvmMsg=\;
localparam SnpNITCCI = \=cmType.SnpNitcCI=\;
localparam SnpNITCMI = \=cmType.SnpNitcMI=\;
localparam UpdInv = \=cmType.UpdInv=\;
localparam STRreq = \=cmType.StrReq=\;
localparam DtrDataInv = \=cmType.DtrDataInv=\;
localparam DtrDataSCln = \=cmType.DtrDataSCln=\;
localparam DtrDataSDty = \=cmType.DtrDataSDty=\;
localparam DtrDataUCln = \=cmType.DtrDataUCln=\;
localparam DtrDataUDty = \=cmType.DtrDataUDty=\;
localparam DtwDataCln = \=cmType.DtwDataFullCln=\;
localparam DtwDataPtl = \=cmType.DtwDataPtlDty=\;
localparam DtwDataDty = \=cmType.DtwDataFullDty=\;
localparam DtwMrgMrdUDty = \=cmType.DtwMrgMrdUDty=\;
localparam DtrRsp = \=cmType.DtrRsp=\;
localparam SnpRsp = \=cmType.SnpRsp=\;

   input [MRCI-1:0] 		myid_i;
   input [DCEN*FIDW-1:0] 	dce_ids_i;
   input [DMIN*FIDW-1:0] 	dmi_ids_i;
   input [DIIN*FIDW-1:0] 	dii_ids_i;
   input [DVEN*FIDW-1:0] 	dve_ids_i;
   input			external_i;
   input [31:0] 		csr_id_i;
   input                        bist_timeout_trigger;
   input clk_en;			
   input			clk_i_ng;
   input 			test_en_i;
   input			reset_ni;
   input			rack_i,		wack_i;
   output			ar_ready_o,	aw_ready_o;
   input			ar_valid_i,	aw_valid_i;
   input [AW-1:0] 	ar_addr_i,	aw_addr_i;
   input [7:0] 		ar_len_i,	aw_len_i;
   input [2:0] 		ar_size_i,	aw_size_i;
   input [1:0] 		ar_burst_i,	aw_burst_i;
   input 		ar_lock_i,	aw_lock_i;
   input [3:0] 		ar_cache_i,	aw_cache_i;
   input [2:0] 		ar_prot_i,	aw_prot_i;
   input [RW-1:0] 	ar_region_i,	aw_region_i;
   input [QW-1:0] 	ar_qos_i,	aw_qos_i;
   input [IW-1:0] 	ar_id_i,	aw_id_i;
   input [MW-1:0] 	ar_bar_i,	aw_bar_i;
   input [SW-1:0] 	ar_snoop_i,	aw_snoop_i;
   input [MW-1:0] 	ar_domain_i,	aw_domain_i;
   input [AXUW-1:0] 	ar_user_i,	aw_user_i;
   input [AXKW-1:0] 	ar_track_i,	aw_track_i;
   input [3:0]          ar_vmidext_i;
   input [AWTW-1:0] 	aw_atop_i;
   input [AWSW-1:0] 	aw_stashid_i;
   input 		dr_ready_i;
   output 		dr_valid_o;
   output [DW-1:0] 	dr_rdata_o;
   output [DWP-1:0] 	dr_poison_o;
   output 		dr_last_o;
   output [ARPW-1:0] 	dr_resp_o;
   output [IW-1:0] 	dr_id_o;
   output [RUW-1:0] 	dr_user_o;
   output [AXKW-1:0] 	dr_track_o;
   output 		dw_ready_o;
   input 		dw_valid_i;
   input [DW-1:0] 	dw_wdata_i;
   input [DWP-1:0] 	dw_poison_i;
   input [BW-1:0] 	dw_be_i;
   input 		dw_last_i;
   input [WDUW-1:0] 	dw_user_i;
   input 		dw_trace_i;
   input 		pw_ready_i;
   output 		pw_valid_o;
   output [1:0] 	pw_resp_o;
   output [IW-1:0] 	pw_id_o;
   output [BUW-1:0] 	pw_user_o;
   output [AXKW-1:0] 	pw_track_o;
   
   input 		ac_ready_i;
   output 		ac_valid_o;
   output [AW-1:0] 	ac_addr_o;
   output [3:0] 	ac_snoop_o;
   output [2:0] 	ac_prot_o;
   output   		ac_track_o;
   output [3:0]         ac_vmidext_o;
   output 		cr_ready_o;
   input 		cr_valid_i;
   input [4:0] 		cr_resp_i;
   output 		cd_ready_o;
   input 		cd_valid_i;
   input [CDW-1:0] 	cd_data_i;
   input [CDWP-1:0] 	cd_poison_i;
   input 		cd_last_i;
   
   input 		cmd_req_ready_i;
   output 		cmd_req_valid_o;
   output [MRCT-1:0] 	cmd_req_tid_o;
   output [MRCI-1:0] 	cmd_req_iid_o;
   output [MRCM-1:0] 	cmd_req_mid_o;
   output [7:0] 	cmd_req_cmd_o;
   output [MRCP-1:0] 	cmd_req_pri_o;
   output [MRCL-1:0] 	cmd_req_ql_o;
   output [7:0] 	cmd_req_status_o;
   output [MRCA-1:0] 	cmd_req_addr_o;
   output [15:0] 	cmd_req_attr_o;
   output [MRC1-1:0] 	cmd_req_mpf1_o;
   output [MRC2-1:0] 	cmd_req_mpf2_o;
   output [2:0] 	cmd_req_size_o;
   output [1:0] 	cmd_req_isize_o;
   output [MRCD-1:0] 	cmd_req_did_o;
   output [MRCF-1:0] 	cmd_req_tof_o;
   output [MRCQ-1:0] 	cmd_req_qos_o;
   output [MRCX-1:0] 	cmd_req_aux_o;
   
   input 		dtr_req_tx_ready_i;
   output 		dtr_req_tx_valid_o;
   output 		dtr_req_tx_last_o;
   output [MRRT-1:0] 	dtr_req_tx_tid_o;
   output [MRRI-1:0] 	dtr_req_tx_iid_o;
   output [MRRM-1:0] 	dtr_req_tx_mid_o;
   output [MRRR-1:0] 	dtr_req_tx_rid_o;
   output [7:0] 	dtr_req_tx_cmd_o;
   output [MRRP-1:0] 	dtr_req_tx_pri_o;
   output [MRRL-1:0] 	dtr_req_tx_ql_o;
   output [7:0] 	dtr_req_tx_status_o;
   output [2:0] 	dtr_req_tx_attr_o;
   output [MRRZ*3-1:0] 	dtr_req_tx_dwid_o;
   output [MRRZ-1:0] 	dtr_req_tx_poison_o;
   output [MRRD-1:0] 	dtr_req_tx_data_o;
   output [MRRB-1:0] 	dtr_req_tx_be_o;
   output [MRRU-1:0] 	dtr_req_tx_user_o;
   
   input 		dtw_req_ready_i;
   output 		dtw_req_valid_o;
   output 		dtw_req_last_o;
   output [MRWT-1:0] 	dtw_req_tid_o;
   output [MRWI-1:0] 	dtw_req_iid_o;
   output [MRWM-1:0] 	dtw_req_mid_o;
   output [MRWV-1:0] 	dtw_req_bid_o;
   output [7:0] 	dtw_req_cmd_o;
   output [MRWP-1:0] 	dtw_req_pri_o;
   output [MRWL-1:0] 	dtw_req_ql_o;
   output [7:0] 	dtw_req_status_o;
   output [3:0] 	dtw_req_attr_o;
   output [1:0] 	dtw_req_isize_o;
   output [MRWZ*3-1:0] 	dtw_req_dwid_o;
   output [MRWZ-1:0] 	dtw_req_poison_o;
   output [MRW1-1:0] 	dtw_req_mpf1_o;
   output [MRW2-1:0] 	dtw_req_mpf2_o;
   output [MRWD-1:0] 	dtw_req_data_o;
   output [MRWB-1:0] 	dtw_req_be_o;
   output [MRWU-1:0] 	dtw_req_user_o;
   
   input 		upd_req_ready_i;
   output 		upd_req_valid_o;
   output [MRUT-1:0] 	upd_req_tid_o;
   output [MRUI-1:0] 	upd_req_iid_o;
   output [MRUM-1:0] 	upd_req_mid_o;
   output [7:0] 	upd_req_cmd_o;
   output [MRUP-1:0] 	upd_req_pri_o;
   output [MRUL-1:0] 	upd_req_ql_o;
   output [7:0] 	upd_req_status_o;
   output [MRUA-1:0] 	upd_req_addr_o;
   output 		upd_req_attr_o;
   output [MRUQ-1:0] 	upd_req_qos_o;
   output 		upd_req_trace_o;
   
   output 		cmd_rsp_ready_o;
   input 		cmd_rsp_valid_i;
   input [7:0] 		cmd_rsp_status_i;
   input [MRCM-1:0] 	cmd_rsp_mid_i;
   input [MPCT-1:0] 	cmd_rsp_tid_i;
   input [MPCI-1:0] 	cmd_rsp_iid_i;
   input 		cmd_rsp_uce_i;
   input 		cmd_rsp_ce_i;
   
   output 		dtr_rsp_rx_ready_o;
   input 		dtr_rsp_rx_valid_i;
   input [7:0] 		dtr_rsp_rx_status_i;
   input [15:0] 	dtr_rsp_rx_attr_i;
   input [MRRM-1:0] 	dtr_rsp_rx_mid_i;
   input [MPRT-1:0] 	dtr_rsp_rx_tid_i;
   input [MPRI-1:0] 	dtr_rsp_rx_iid_i;
   input 		dtr_rsp_rx_uce_i;
   input 		dtr_rsp_rx_ce_i;

   output 		dtw_rsp_ready_o;
   input 		dtw_rsp_valid_i;
   input [7:0] 		dtw_rsp_status_i;
   input [15:0] 	dtw_rsp_attr_i;
   input [MRWM-1:0] 	dtw_rsp_mid_i;
   input [MPWT-1:0] 	dtw_rsp_tid_i;
   input [MPWI-1:0] 	dtw_rsp_iid_i;
   input 		dtw_rsp_uce_i;
   input 		dtw_rsp_ce_i;
   
   output 		upd_rsp_ready_o;
   input 		upd_rsp_valid_i;
   input [7:0] 		upd_rsp_status_i;
   input [MRUM-1:0] 	upd_rsp_mid_i;
   input [MPUT-1:0] 	upd_rsp_tid_i;
   input [MPUI-1:0] 	upd_rsp_iid_i;
   input 		upd_rsp_uce_i;
   input 		upd_rsp_ce_i;
   
   output 		str_req_ready_o;
   input 		str_req_valid_i;
   input [SRCI-1:0] 	str_req_iid_i;
   input [SRCT-1:0] 	str_req_tid_i;
   input [SRCM-1:0] 	str_req_mid_i;
   input [SRCR-1:0] 	str_req_rid_i;
   input [SRCB-1:0] 	str_req_bid_i;
   input [7:0] 		str_req_cmd_i;
   input [7:0] 		str_req_status_i;
   input [1:0] 		str_req_isize_i;
   input [SRC1-1:0] 	str_req_mpf1_i;
   input [SRC2-1:0] 	str_req_mpf2_i;
   input 		str_req_uce_i;
   input 		str_req_ce_i;
   
   output 		dtr_req_rx_ready_o;
   input 		dtr_req_rx_valid_i;
   input 		dtr_req_rx_last_i;
   input [7:0] 		dtr_req_rx_cmd_i;
   input [7:0] 		dtr_req_rx_status_i;
   input [SRRP-1:0] 	dtr_req_rx_pri_i;
   input [SRRM-1:0] 	dtr_req_rx_mid_i;
   input [SRRI-1:0] 	dtr_req_rx_iid_i;
   input [SRRT-1:0] 	dtr_req_rx_tid_i;
   input [SRRR-1:0] 	dtr_req_rx_rid_i;
   input [SRRZ-1:0] 	dtr_req_rx_dbad_i;
   input [SRRD-1:0] 	dtr_req_rx_data_i;
   input [SRRB-1:0] 	dtr_req_rx_be_i;
   input [15:0] 	dtr_req_rx_attr_i;
   input 		dtr_req_rx_uce_i;
   input 		dtr_req_rx_ce_i;
   
   
   output 		snp_req_ready_o;
   input 		snp_req_valid_i;
   input [7:0] 		snp_req_cmd_i;
   input [7:0] 		snp_req_status_i;
   input [SRNP-1:0] 	snp_req_pri_i;
   input [SRNM-1:0] 	snp_req_mid_i;
   input [SRNB-1:0] 	snp_req_bid_i;
   input [SRNI-1:0] 	snp_req_iid_i;
   input [SRNT-1:0] 	snp_req_tid_i;
   input [SRNA-1:0] 	snp_req_addr_i;
   input [1:0] 		snp_req_isize_i;
   input [9:0] 		snp_req_attr_i;
   input [SRN1-1:0] 	snp_req_mpf1_i;
   input [SRN2-1:0] 	snp_req_mpf2_i;
   input [SRN3-1:0] 	snp_req_mpf3_i;
   input [SRND-1:0] 	snp_req_did_i;
   input [SRNF-1:0] 	snp_req_tof_i;
   input 		snp_req_uce_i;
   input 		snp_req_ce_i;
   
   input 		str_rsp_ready_i;
   output 		str_rsp_valid_o;
   output 		str_rsp_trace_o;
   output [SPCT-1:0] 	str_rsp_tid_o;
   output [SPCI-1:0] 	str_rsp_iid_o;
   output [SRCM-1:0] 	str_rsp_mid_o;
   output [SPCR-1:0] 	str_rsp_rid_o;
   output [SPCP-1:0] 	str_rsp_pri_o;
   output [SPCL-1:0] 	str_rsp_ql_o;
   output [7:0] 	str_rsp_status_o;
   
   input 		dtr_rsp_tx_ready_i;
   output 		dtr_rsp_tx_valid_o;
   output 		dtr_rsp_tx_trace_o;
   output [SPRT-1:0] 	dtr_rsp_tx_tid_o;
   output [SPRI-1:0] 	dtr_rsp_tx_iid_o;
   output [SRRM-1:0] 	dtr_rsp_tx_mid_o;
   output [SPRR-1:0] 	dtr_rsp_tx_rid_o;
   output [SPRP-1:0] 	dtr_rsp_tx_pri_o;
   output [SPRL-1:0] 	dtr_rsp_tx_ql_o;
   output [7:0] 	dtr_rsp_tx_cmd_o;
   output [7:0] 	dtr_rsp_tx_status_o;
   
   input 		snp_rsp_ready_i;
   output 		snp_rsp_valid_o;
   output 		snp_rsp_trace_o;
   output [SPNT-1:0] 	snp_rsp_tid_o;
   output [SPNI-1:0] 	snp_rsp_iid_o;
   output [SRNM-1:0] 	snp_rsp_mid_o;
   output [SPNR-1:0] 	snp_rsp_rid_o;
   output [SPNP-1:0] 	snp_rsp_pri_o;
   output [SPNL-1:0] 	snp_rsp_ql_o;
   output [7:0] 	snp_rsp_cmd_o;
   output [7:0] 	snp_rsp_status_o;
   output [SPN1-1:0] 	snp_rsp_mpf1_o;
   
   output 		cmp_rsp_ready_o;
   input 		cmp_rsp_valid_i;
   input [MRCM-1:0] 	cmp_rsp_mid_i;
   input [MPCT-1:0] 	cmp_rsp_tid_i;
   input [MPCT-1:0] 	cmp_rsp_iid_i;
   input [7:0] 		cmp_rsp_status_i;
   input 		cmp_rsp_uce_i;
   input 		cmp_rsp_ce_i;
   
   input 		dtw_dbg_rsp_valid_i;
   input 		dtw_dbg_rsp_ready_i;
   input [MRCT-1:0] 	dtw_dbg_rsp_tid_i;
   input [MRCI-1:0] 	dtw_dbg_rsp_iid_i;
   input 		dtw_dbg_rsp_uce_i;
   input 		dtw_dbg_rsp_ce_i;
	
   input 		sysrq_valid_i;
   input 		sysrq_ready_i;
   input [MRCT-1:0] 	sysrq_tid_i;
   input [MRCI-1:0] 	sysrq_iid_i;
   input 		sysrq_uce_i;
   input 		sysrq_ce_i;

   input 		sysrp_valid_i;
   input 		sysrp_ready_i;
   input [MRCT-1:0] 	sysrp_tid_i;
   input [MRCI-1:0] 	sysrp_iid_i;
   input 		sysrp_uce_i;
   input 		sysrp_ce_i;
   
   output [ODB-1:0] 	od_we_o;
   output [(ODB*ODAW)-1:0] od_waddr_o;
   output [(ODB*ODDW)-1:0] od_wdata_o;
   output [(ODB*ODEW)-1:0] od_wecc_o;
   output [ODB-1:0] 	   od_re_o;
   output [(ODB*ODAW)-1:0] od_raddr_o;
   input [(ODB*ODDW)-1:0]  od_rdata_i;
   input [(ODB*ODEW)-1:0]  od_recc_i;

   output 		   amc_val_evict_o;
   output [AW-1:0] 	   amc_addr_evict_o;
   input [3:0] 		   amc_vals_evict_i;

   output 		   amc_val_o;
   output [AW-1:0] 	   amc_addr_o;
   output 		   amc_ignore_o;
   output 		   amc_security_o;
   input [3:0] 		   amc_vals_i;
   input [(3*FIDW)-1:0]    amc_fids_i;
   input [(3*5)-1:0] 	amc_tins_i;
   input [4:0] 		amc_mig_i;
   input [3:0] 		amc_errs_i;
   input [4:0] 		amc_order_i;
   input [3:0] 		amc_size_of_ig_i;
   input       		amc_nrs_region_hit_i;
\js if ((axiParams.eDomain?1:0)==0) {
   input                   amc_nc_i;
   input                   amc_nc_evict_i;   
\js }
  input                   amc_unconnected_dce_access;
   input 		  amc_unconnected_dmi_access;
   input 		  amc_unconnected_dii_access;

   output 		  ccp_init_o;
   input 		  ccp_ready_i;
   input [CTB-1:0] 	  cp0_ready_i;
   output [CTB-1:0] 	  cp0_valid_o;
   output [AW-1:0] 	  cp0_addr_o;
   output 		  cp0_security_o;
   output 		  cp2_alloc_o;
   output 		cp2_rd_o;
   output 		cp2_wr_o;
   output 		cp2_port_o;
   output 		cp2_lru_o;
   output 		cp2_update_o;
   output [CSW-1:0] 	cp2_nstate_o;
   output [BWL-1:0] 	cp2_len_o;
   output [WAYS-1:0] 	cp2_busy_o;
   input 		cp2_evict_i;
   input [AW-1:0] 	cp2_eaddr_i;
   input 		cp2_esecurity_i;
   input [CSW-1:0] 	cp2_estate_i;
   input 		cp2_valid_i;
   input [CSW-1:0] 	cp2_cstate_i;
   input [WAYS-1:0] 	cp2_cnru_i;
   input [WAYS-1:0] 	cp2_hits_i;
   input [WAYS-1:0] 	cp2_ways_i;
   input [3:0] 		cp2_nacks_i;
   output 		cp2_setw_o;
   output [19:0] 	cp2_setn_o;
   output [5:0] 	cp2_wayn_o;
   input 		cfd_ready_i;
   output 		cfd_valid_o;
   output [DWP-1:0]	cfd_poison_o;
   output               cfd_full_o;
   output [DW-1:0] 	cfd_data_o;
   output [BW-1:0] 	cfd_be_o;
   output [CWW-1:0] 	cfd_way_o;
   output 		cfd_last_o;
   output [BWL-1:0] 	cfd_beat_o;
   output [AW-1:0] 	cfd_addr_o;
   output [OCA-1:0] 	cfd_oid_o;
   input 		cfd_done_i;
   input [OCA-1:0] 	cfd_nid_i;
   input 		cft_ready_i;
   output 		cft_valid_o;
   output [CSW-1:0] 	cft_state_o;
   output [AW-1:0] 	cft_addr_o;
   output 		cft_security_o;
   output [CWW-1:0] 	cft_way_o;
   output 		ccd_ready_o;
   input 		ccd_valid_i;
   input [DWP-1:0]	ccd_poison_i;
   input [DW-1:0] 	ccd_rdata_i;
   input [BW-1:0] 	ccd_be_i;
   input 		ccd_last_i;
   input 		ccd_cancel_i;
   input 		ccw_ready_i;
   output 		ccw_valid_o;
   output [DWP-1:0] 	ccw_poison_o;
   output [DW-1:0] 	ccw_wdata_o;
   output [BW-1:0] 	ccw_be_o;
   output [BWL-1:0] 	ccw_offset_o;
   output 		ccw_last_o;
   output 		cce_ready_o;
   input 		cce_valid_i;
   input [DWP-1:0] 	cce_poison_i;
   input [DW-1:0] 	cce_rdata_i;
   input [BW-1:0] 	cce_be_i;
   input 		cce_last_i;
   input 		cce_cancel_i;
   input		cmr_init_i;
   output		cmr_ready_o;
   input		cmr_valid_i;
   input [1:0] 		cmr_cmd_i;	//0:Rd, 1:Wr, 2:Flush addr, 3:Flush entry.
   input [5:0] 		cmr_way_i;
   input [AW-1:0] 	cmr_addr_i;
   input		cmr_security_i;
   input		cmr_last_i;
   output		cmr_done_o;
   input [1:0] 	 cfg_rproducer_i, cfg_wproducer_i;
   input 	 cfg_external_i;
   input [30:0]  cfg_top_i;
   input [15:0]  cfg_evp_i;
   input         cfg_useEvQos_i;                                       
   input [3:0]   cfg_evQos_i;
   input [31:12] cfg_tperiod_i;
   input [15:4]  cfg_eperiod_i;
   input [3:0] 	 cfg_dcredit_i, cfg_mcredit_i, cfg_icredit_i, cfg_vcredit_i,
		 cfg_qcredit_i;
   input [7:0] 	 cfg_cmd_req_max_i, cfg_dtr_req_tx_max_i, cfg_dtw_req_max_i, cfg_upd_req_max_i;
   input [7:0] 	 cfg_rd_pool_i, cfg_wr_pool_i;
   input [7:0] 	 cfg_st_limit_i, 
		 cfg_oc_limit_i, cfg_rd_limit_i, cfg_wr_limit_i, cfg_ev_limit_i;
   input [29:0]  cfg_control_i;
   input 	 cfg_cache_i, cfg_alloc_i;
   input         cfg_update_i;
   output [5:0] uerrs_o;
   output [19:0] uinfo_o;
   output [2:0]  cerrs_o;
   output [15:6] cinfo_o;
   output [25:0] elog_o;
   output [64:0] eaddr_o;
   output [1:0]  starve_o;
   output [1:0]  ctar_o;
   output [7:0]  interleaved_count_o;
   output 	 idle_o;

\js if (nativeTrigger.signals.user>0) {
output [\=ioaiu_pos(nativeTrigger.signals.user)-1=\:0]     trace_user;
\js }

output [\=nativeTrigger.signals.addr=\-1:0]	trace_addr;
output [\=nativeTrigger.signals.opcode=\-1:0]	trace_opcode;
output [\=nativeTrigger.signals.dmi_hit=\-1:0]	trace_dmi_hit;
output [\=nativeTrigger.signals.dii_hit=\-1:0]	trace_dii_hit;
output [\=nativeTrigger.signals.hui=\-1:0]	trace_hui;
output [\=nativeTrigger.signals.aw=\-1:0]	trace_aw;
output [\=nativeTrigger.signals.ar=\-1:0]	trace_ar;
output [\=nativeTrigger.signals.memattr=\-1:0]	trace_memattr;
output trace_trace;
output [3:0]                                    trace_size_of_ig;

input						tracetag;
output                                          outstanding_coherent_count_zero;

output                  pmon_address_collision;
output			pmon_cache_r_hit;
output			pmon_cache_w_hit;
output			pmon_cache_s_hit;
output			pmon_cache_evict;
output			pmon_no_ways;
output			pmon_cache_f_stall;
output			pmon_cache_r_stall;
output			pmon_cache_w_stall;
output			pmon_cache_replay;
output			pmon_cache_r_miss;
output			pmon_cache_w_miss;
output			pmon_cache_s_miss;
output [7:0]		pmon_ott_entries;

output [OCN-1:0]        pmon_ott_read_latency_alloc;
output [OCN-1:0]        pmon_ott_read_latency_dealloc;
output [OCN-1:0]        pmon_ott_write_latency_alloc;
output [OCN-1:0]        pmon_ott_write_latency_dealloc;

\js for ( let i = 0; i < nDCEs; i++ ) {
output  [2:0]        XAIUCCR\=i=\_DCECounterState_in;
output               XAIUCCR\=i=\_DCECounterState_wr;
input	[4:0]        XAIUCCR\=i=\_DCECreditLimit_out;
input	[2:0]        XAIUCCR\=i=\_DCECounterState_out;
\js }

\js for ( let i = 0; i < nDMIs; i++ ) {
output  [2:0]        XAIUCCR\=i=\_DMICounterState_in;
output               XAIUCCR\=i=\_DMICounterState_wr;
input   [4:0]        XAIUCCR\=i=\_DMICreditLimit_out;
input   [2:0]        XAIUCCR\=i=\_DMICounterState_out;
\js }

\js for ( let i = 0; i < nDIIs; i++ ) {
output  [2:0]        XAIUCCR\=i=\_DIICounterState_in;
output               XAIUCCR\=i=\_DIICounterState_wr;
input   [4:0]        XAIUCCR\=i=\_DIICreditLimit_out;
input   [2:0]        XAIUCCR\=i=\_DIICounterState_out;
\js }

input [\=nDCEs=\-1:0]            hexAiuDceVec;
input [\=nDMIs=\-1:0]            hexAiuDmiVec;
input [\=nDIIs=\-1:0]            hexAiuDiiVec;

///////////////////////////////////////////////////////////////////

wire clk_i;

wire [31:12]	t_cfg_tperiod_in;
wire [31:12]	t_cfg_tperiod;
wire            t_cfg_tperiod_eq_0_in;
wire            t_cfg_tperiod_eq_0;
wire [15:0]	t_cfg_eperiod;

wire [STA:0]    t_cfg_st_limit;
wire [STA:0]    t_cfg_st_limit_ns = (~(|cfg_st_limit_i) | (cfg_st_limit_i[STA:0]>\=STA+1=\'d\=STN=\)) ?  \=STA+1=\'d\=STN=\ : cfg_st_limit_i[\=STA=\:0];
\=u.dffre(STA+1, `t_cfg_st_limit`, `t_cfg_st_limit_ns`, (STA+1)+`'d`+STN, `1'b1`, `clk_i`, `reset_ni`)=\

wire [OCA:0]    t_cfg_oc_limit;
wire [OCA:0]    t_cfg_oc_limit_ns = (~(|cfg_oc_limit_i) | (cfg_oc_limit_i[OCA:0]>\=OCA+1=\'d\=OCN=\)) ?  \=OCA+1=\'d\=OCN=\ : cfg_oc_limit_i[\=OCA=\:0];
\=u.dffre(OCA+1, `t_cfg_oc_limit`, `t_cfg_oc_limit_ns`, (OCA+1)+`'d`+OCN, `1'b1`, `clk_i`, `reset_ni`)=\

wire [OCA:0]    t_cfg_rd_limit;
wire [OCA:0]    t_cfg_rd_limit_ns = (~(|cfg_rd_limit_i) | (cfg_rd_limit_i[OCA:0]>\=OCA+1=\'d\=OCN=\)) ?  \=OCA+1=\'d\=OCN=\ : cfg_rd_limit_i[\=OCA=\:0];
\=u.dffre(OCA+1, `t_cfg_rd_limit`, `t_cfg_rd_limit_ns`, (OCA+1)+`'d`+OCN, `1'b1`, `clk_i`, `reset_ni`)=\

wire [OCA:0]    t_cfg_wr_limit;
wire [OCA:0]    t_cfg_wr_limit_ns = (~(|cfg_wr_limit_i) | (cfg_wr_limit_i[OCA:0]>\=OCA+1=\'d\=OCN=\)) ?  \=OCA+1=\'d\=OCN=\ : cfg_wr_limit_i[\=OCA=\:0];
\=u.dffre(OCA+1, `t_cfg_wr_limit`, `t_cfg_wr_limit_ns`, (OCA+1)+`'d`+OCN, `1'b1`, `clk_i`, `reset_ni`)=\

wire [OCA:0]    t_cfg_ev_limit;
wire [OCA:0]    t_cfg_ev_limit_ns = (~(|cfg_ev_limit_i) | (cfg_ev_limit_i[OCA:0]>\=OCA+1=\'d\=OCN=\)) ?  \=OCA+1=\'d\=OCN=\ : cfg_ev_limit_i[\=OCA=\:0];
\=u.dffre(OCA+1, `t_cfg_ev_limit`, `t_cfg_ev_limit_ns`, (OCA+1)+`'d`+OCN, `1'b1`, `clk_i`, `reset_ni`)=\

wire t_cfg_oc_limit_gt_9_ns, t_cfg_oc_limit_gt_8_ns;
wire t_cfg_oc_limit_gt_7_ns, t_cfg_oc_limit_gt_6_ns, t_cfg_oc_limit_gt_5_ns, t_cfg_oc_limit_gt_4_ns;
wire t_cfg_oc_limit_gt_9, t_cfg_oc_limit_gt_8;
wire t_cfg_oc_limit_gt_7, t_cfg_oc_limit_gt_6, t_cfg_oc_limit_gt_5, t_cfg_oc_limit_gt_4;

assign t_cfg_oc_limit_gt_9_ns = t_cfg_oc_limit > \=OCA+1=\'d9;
assign t_cfg_oc_limit_gt_8_ns = t_cfg_oc_limit > \=OCA+1=\'d8;
assign t_cfg_oc_limit_gt_7_ns = t_cfg_oc_limit > \=OCA+1=\'d7;
assign t_cfg_oc_limit_gt_6_ns = t_cfg_oc_limit > \=OCA+1=\'d6;
assign t_cfg_oc_limit_gt_5_ns = t_cfg_oc_limit > \=OCA+1=\'d5;
assign t_cfg_oc_limit_gt_4_ns = t_cfg_oc_limit > \=OCA+1=\'d4;

\=u.dffre(1, `t_cfg_oc_limit_gt_9`, `t_cfg_oc_limit_gt_9_ns`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
\=u.dffre(1, `t_cfg_oc_limit_gt_8`, `t_cfg_oc_limit_gt_8_ns`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
\=u.dffre(1, `t_cfg_oc_limit_gt_7`, `t_cfg_oc_limit_gt_7_ns`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
\=u.dffre(1, `t_cfg_oc_limit_gt_6`, `t_cfg_oc_limit_gt_6_ns`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
\=u.dffre(1, `t_cfg_oc_limit_gt_5`, `t_cfg_oc_limit_gt_5_ns`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
\=u.dffre(1, `t_cfg_oc_limit_gt_4`, `t_cfg_oc_limit_gt_4_ns`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
						    
wire		t_cfg_coal = 1'b0;
wire		t_cfg_owo_allow_make_unique = cfg_control_i[24];
wire		t_cfg_evict = cfg_control_i[23];
wire		t_cfg_qos = cfg_control_i[22];
wire		t_cfg_dve = cfg_control_i[21];
wire		t_cfg_dhit = 1'b0; //cfg_control_i[20];
wire		t_cfg_external = cfg_control_i[19];
wire		t_cfg_starve = cfg_control_i[18] | (~| t_cfg_eperiod);
wire		t_cfg_timeout =                  t_cfg_tperiod_eq_0;
wire		t_cfg_age = cfg_control_i[17];// | (CACHE==0);
wire		t_cfg_order = cfg_control_i[16];
wire		t_cfg_init = cfg_control_i[15] | cmr_init_i;
wire		t_cfg_echain = cfg_control_i[14];
wire		t_cfg_partial = cfg_control_i[13];
wire		t_cfg_share = cfg_control_i[12];
wire		t_cfg_single = cfg_control_i[11];
wire		t_cfg_single_wake = cfg_control_i[10];
wire 		t_cfg_ahit1 = 1'b0;		//cfg_control_i[9];
\js // This bit allows a SNPRsp to be generated after a CR Resp for a DVM Sync on the AC Channel rather than the DVM Complete.
wire 		t_cfg_sync_cr_to_snp_rsp = cfg_control_i[9];
wire 		t_cfg_ahit = cfg_control_i[8];
\js if (fnDisableRdInterleave==1) {
wire		t_cfg_ihit = 1'b1;
\js } else {
wire		t_cfg_ihit = cfg_control_i[7];
\js }
wire		t_cfg_bypass = cfg_control_i[6];
wire		t_cfg_qok = cfg_control_i[5];
wire		t_cfg_skid = cfg_control_i[4];
wire [3:0]	t_cfg_pvc = cfg_control_i[3:0];		//4'h8;

wire		t_p0_single, t_p0_single_wake;
wire [OCA:0]	t_p0_limit, t_p0_rd_limit, t_p0_wr_limit;
wire [OCA:0]	            t_p0_rd_limit_ns, t_p0_wr_limit_ns;
wire [7:0]	t_p0_wr_pool;
wire		w_dw_ready,	n_dw_ready;
wire		n_dw_valid,	w_dw_valid;
wire		           	w_dw_valid_pre;
wire				n_adw_ready;
wire				w_adw_valid;
wire [WDUW-1:0]			w_adw_user;
wire				w_adw_trace;
wire				w_adw_last;
wire [BW-1:0]			w_adw_be;
wire [DW-1:0]			w_adw_wdata;
wire [DWP-1:0]			w_adw_poison;
wire [DW-1:0]			t_adw_wdata;
wire [DWP-1:0]			t_adw_poison;
wire [ODA-1:0]			t_adw_waddr;
wire		w_wkq_ready;
wire		n_wkq_valid,	w_wkq_valid;
wire		w_pw0_ready,	n_pw0_ready;
wire		n_pw0_valid,	w_pw0_valid;
wire [OCA-1:0]	n_pw0_oid,	w_pw0_oid;
wire [OCN-1:0]	n_pw0_obv,	w_pw0_obv;
wire		w_pw_ready;
wire		n_pw_valid;
wire [AXKW-1:0]	n_pw_track;
wire [BUW-1:0]	n_pw_user;
wire [IW-1:0]	n_pw_id;
wire [1:0]	n_pw_resp;
wire		w_w0_ready,	n_w0_ready;
wire		n_w0_valid,	w_w0_valid;
wire [AW-1:0]			w_w0_addr;
wire [7:0]			w_w0_len;
wire [2:0]			w_w0_size;
wire [1:0]			w_w0_burst, w_w0_burst_post;
wire				w_w0_lock;
wire [3:0]			w_w0_cache;
wire [2:0]			w_w0_prot;
wire [RW-1:0]			w_w0_region;
wire [QW-1:0]			w_w0_qos;
wire [IW-1:0]			w_w0_id;
wire [MW-1:0]			w_w0_bar;
wire [SW-1:0]			w_w0_snoop;
wire [MW-1:0]			w_w0_domain;
wire [AXUW-1:0] 		w_w0_user;
wire [AXKW-1:0]			w_w0_track;
wire [AWTW-1:0]			w_w0_atop;
wire [AWSW-1:0]			w_w0_stashid;
wire [1:0]	t_w0_sel,	t_w1_sel;
wire		w_w1_ready_raw;
wire		w_w1_ready,	n_w1_ready,	n_w2_ready, 	n_aw_ready, 
		n_w1_valid_raw,					t_aw_ready;
wire		n_w1_valid,	w_w1_valid,	w_w2_valid, 	w_aw_valid;
wire [AW-1:0]	n_w1_addr,	w_w1_addr,	w_w2_addr;
wire [7:0]	n_w1_len,	w_w1_len,	w_w2_len;
wire [2:0]	n_w1_size,	w_w1_size,	w_w2_size;
wire [1:0]	n_w1_burst,	w_w1_burst,	w_w2_burst;
wire		n_w1_lock,	w_w1_lock,	w_w2_lock;
wire [3:0]	n_w1_cache,	w_w1_cache,	w_w2_cache;
wire [2:0]	n_w1_prot,	w_w1_prot,	w_w2_prot;
wire [RW-1:0]	n_w1_region,	w_w1_region,	w_w2_region;
wire [QW-1:0]	n_w1_qos,	w_w1_qos,	w_w2_qos;
wire [IW-1:0]	n_w1_id,	w_w1_id,	w_w2_id;
wire [MW-1:0]	n_w1_bar,	w_w1_bar,	w_w2_bar;
wire [SW-1:0]	n_w1_snoop,	           	w_w2_snoop;
wire [3:0]	w_w1_snoop;
wire [MW-1:0]	n_w1_domain,	            	w_w2_domain;
wire [1:0]	w_w1_domain;
wire [AXUW-1:0] n_w1_user,	w_w1_user,	w_w2_user;
wire [AXKW-1:0] n_w1_track,	w_w1_track,	w_w2_track,
				t_w1_track;
wire [AWTW-1:0]	n_w1_atop,	w_w1_atop,	w_w2_atop;
wire [AWSW-1:0]	n_w1_stashid,	w_w1_stashid,	w_w2_stashid;
wire [OLA-1:0]	n_w1_dptr,	w_w1_dptr,	w_w2_dptr;
wire [OCN-1:0]  n_w1_dptr_vec;
wire				t_w1_stash;
wire				t_w1_partial,	w_w2_partial;
wire				t_w1_end;
wire [CLO-1:AWL]		t_w1_offset;
wire [BWL:0]			w_w1_beats, t_w1_beats;


wire		w_p0r_ready,	n_p0r_ready;
wire		n_p0r_valid,	w_p0r_valid, t_p0r_valid;
wire		w_w2_ready,	n_p0w_ready;
wire		n_w2_valid,	w_p0w_valid, t_p0w_valid;
wire		w_p0_ready,	n_p0_ready;
wire		n_p0_valid,	w_p0_valid;
wire [AW-1:0]	n_p0_addr,	w_p0_addr;
wire [7:0]	n_p0_len,	w_p0_len;
wire [2:0]	n_p0_size,	w_p0_size;
wire [1:0]	n_p0_burst,	w_p0_burst;
wire		n_p0_lock,	w_p0_lock;
wire [3:0]	n_p0_cache,	w_p0_cache;
wire [2:0]	n_p0_prot,	w_p0_prot;
wire [RW-1:0]	n_p0_region,	w_p0_region;
wire [QW-1:0]	n_p0_qos,	w_p0_qos;
wire [IW-1:0]	n_p0_id,	w_p0_id;
wire [MW-1:0]	n_p0_bar,	w_p0_bar;
wire [SW-1:0]	n_p0_snoop,	w_p0_snoop;
wire [MW-1:0]	n_p0_domain,	w_p0_domain;
wire [AXUW-1:0] n_p0_user,	w_p0_user;
wire [AXKW-1:0] n_p0_track,	w_p0_track;
wire [3:0]      n_p0_vmidext,   w_p0_vmidext;
wire            n_p0_trace_wake,w_p0_trace_wake;
wire [AWTW-1:0]	n_p0_atop,	w_p0_atop;
wire [AWSW-1:0]	n_p0_stashid,	w_p0_stashid;
wire		n_p0_write,	w_p0_write;
wire [1:0]	n_p0_cmr,	w_p0_cmr;
wire      	n_p0_snp,	w_p0_snp;
wire		n_p0_wake,	w_p0_wake;
wire [XTA-1:0]	n_p0_kid,	w_p0_kid;
wire		n_p0_partial,	w_p0_partial;
wire [5:0]	n_p0_sel;
wire [1:0]			w_p0_sel,	w_p1_sel;
wire		w_p1_ready,	n_p1_ready;
wire		n_p1_valid,	w_p1_valid;
wire [AW-1:0]	n_p1_addr,	w_p1_addr,	w_rr_addr,   w_rr_guts_addr[2:0];
wire [7:0]	n_p1_len,	w_p1_len,	w_rr_len,    w_rr_guts_len[2:0];
wire [2:0]	n_p1_size,	w_p1_size,	w_rr_size,   w_rr_guts_size[2:0];
wire [1:0]	n_p1_burst,	w_p1_burst,	w_rr_burst,  w_rr_guts_burst[2:0];
wire		n_p1_lock,	w_p1_lock,	w_rr_lock,   w_rr_guts_lock[2:0];
wire [3:0]	n_p1_cache,	w_p1_cache,	w_rr_cache,  w_rr_guts_cache[2:0];
wire [2:0]	n_p1_prot,	w_p1_prot,	w_rr_prot,   w_rr_guts_prot[2:0];
wire [RW-1:0]	n_p1_region,	w_p1_region,	w_rr_region, w_rr_guts_region[2:0];
wire [QW-1:0]	n_p1_qos,	w_p1_qos,	w_rr_qos,    w_rr_guts_qos[2:0];
wire [IW-1:0]	n_p1_id,	w_p1_id,	w_rr_id,     w_rr_guts_id[2:0];
wire [MW-1:0]	n_p1_bar,	w_p1_bar,	w_rr_bar,    w_rr_guts_bar[2:0];
wire [SW-1:0]	n_p1_snoop,	           	w_rr_snoop,  w_rr_guts_snoop[2:0];
wire [3:0]	w_p1_snoop;
wire [3:0]	w_mod_snoop;
wire            w_mod_cmo;
wire            w_mod_wns;
wire [MW-1:0]	n_p1_domain,	w_p1_domain,	w_rr_domain, w_rr_guts_domain[2:0];
wire [1:0]	t_p1_domain;
wire [AXUW-1:0] n_p1_user,	w_p1_user,	w_rr_user,   w_rr_guts_user[2:0];
wire                                            w_rr_upmatch,w_rr_guts_upmatch[2:0];
wire [1:0]                                      w_rr_up,     w_rr_guts_up[2:0];
wire [AXKW-1:0] n_p1_track,	w_p1_track,	w_rr_track,  w_rr_guts_track[2:0];
wire [3:0]      n_p1_vmidext,   w_p1_vmidext,   w_rr_vmidext,w_rr_guts_vmidext[2:0];
wire            n_p1_trace_wake,w_p1_trace_wake;
wire [AWTW-1:0]	n_p1_atop,	w_p1_atop,	w_rr_atop,   w_rr_guts_atop[2:0];
wire [AWSW-1:0]	n_p1_stashid,	w_p1_stashid,	w_rr_stashid,w_rr_guts_stashid[2:0];
wire		n_p1_write,	w_p1_write,	w_rr_write,  w_rr_guts_write[2:0];
wire                                            w_rr_trace,  w_rr_guts_trace[2:0];
wire                                            w_rr_snp,    w_rr_guts_snp[2:0];
wire [1:0]	n_p1_cmr,	w_p1_cmr,	w_rr_cmr,    w_rr_guts_cmr[2:0];
wire       	n_p1_snp,	w_p1_snp;
wire		n_p1_wake,	w_p1_wake,	w_rr_wake,   w_rr_guts_wake[2:0];
wire [XTA-1:0]	n_p1_kid,	w_p1_kid,	w_rr_kid,    w_rr_guts_kid[2:0];
wire		n_p1_partial,	w_p1_partial,	w_rr_partial,w_rr_guts_partial[2:0];
wire                            w_p1_trace;
wire				t_p1_correctable_error, t_p2_correctable_error;
wire [OCN-1:0]			t_p1_skid;
wire [OCA-1:0]			w_p1_iptr_lookup;
wire		w_p2_ready,	n_p2_ready,	n_pt_ready;
wire            n_p2m_ready;
wire		n_p2_valid,	w_p2_valid,	w_pt_valid;
wire				t_p0w_update;
wire [AW-1:0]	w_p0r_addr,	w_p0w_addr,	w_pt_addr;
wire [7:0]	w_p0r_len,	w_p0w_len,	w_pt_len, w_mod_len;
wire [2:0]					t_pt_len;
wire [2:0]	w_p0r_size,	w_p0w_size,	w_pt_size;
wire [1:0]	w_p0r_burst,	w_p0w_burst,	w_pt_burst, p0r_burst_modified;
wire		w_p0r_lock,	w_p0w_lock,	w_pt_lock;
wire [3:0]	w_p0r_cache,	w_p0w_cache,	w_pt_cache;
wire [2:0]	w_p0r_prot,	w_p0w_prot,	w_pt_prot;
wire [RW-1:0]	w_p0r_region,	w_p0w_region,	w_pt_region;
wire [QW-1:0]	w_p0r_qos,	w_p0w_qos,	w_pt_qos;
wire [IW-1:0]	w_p0r_id,	w_p0w_id,	w_pt_id;
wire [LIDW-1:0]					t_pt_lpid;
wire [MW-1:0]	w_p0r_bar,	w_p0w_bar,	w_pt_bar;
wire [SW-1:0]	w_p0r_snoop,	w_p0w_snoop;
wire [3:0]    	w_pt_snoop;
wire [MW-1:0]	w_p0r_domain,	w_p0w_domain;
wire [1:0]	w_pt_domain;
wire [MW-1:0]	w_pt_domain_unqual;
wire [AXUW-1:0] w_p0r_user,	w_p0w_user,	w_pt_user;
wire [AXKW-1:0] w_p0r_track,	w_p0w_track,	w_pt_track;
wire [3:0]      w_p0r_vmidext,                  w_pt_vmidext;
wire                                            w_pt_trace_wake;
wire [AWTW-1:0]			w_p0w_atop;
wire [5:0]			w_pt_atop;
wire [AWSW-1:0]			w_p0w_stashid,	w_pt_stashid;
wire				w_p0w_partial,	w_pt_partial;
wire						t_pt_partial;
wire		w_p0_pr,	w_p1_pr,	w_pt_pr;
wire		w_p0_security,	w_p1_security,	w_pt_security;
wire		w_p0_lcmr,	w_p1_lcmr,	w_pt_lcmr;
wire            w_p1_upgrade;
wire            w_pt_upgrade;
wire						t_pt_unique;
wire						t_pt_catop;
wire						t_pt_stash, t_pt_stash_once;
wire						w_pt_stashlpiden;
wire [4:0]					w_pt_stashlpid;
wire						w_pt_stashniden;
wire [FIDW-1:0]					w_pt_stashnid;
wire						t_pt_evict;
wire						t_pt_snp;
wire						t_pt_cmo;
wire						t_pt_wns;
wire						t_pt_dce;
reg                                             r_pt_dce;
wire						t_pt_dmi;
wire						t_pt_dii;
wire						t_pt_csr;
wire				t_p1_dve,	t_pt_dve;
wire				t_p1_dvm,	t_pt_dvm;
wire                                            t_pt_coherent;
wire						t_pt_err, t_pt_uerr, t_pt_uerr_dec, t_pt_uerr_config;
wire                                            t_pt_illegal_dii_access_type;
wire                                            t_pt_illegal_csr_access_format;
wire						w_pt_write;
wire						w_pt_trace;
wire						w_pt_trace_out;
wire [1:0]					w_pt_cmr;
wire       					w_pt_snp;
wire						w_pt_wake;
wire						w_pt_wake_last;
wire [XTA-1:0]					w_pt_kid;
wire [XTAW-1:0]					w_pt_kid_oh;
wire [XTAW-1:0]					w_pt_kid_oh_last;
wire [OCA-1:0]					w_pt_iptr_lookup;
wire                                            w_pt_cmo;
wire                                            w_pt_wns;
wire [OCA-1:0]					t_pt_oid;
wire						t_pt_ok;
wire						t_pt_ok_no_err;
wire						t_pt_ok_maybe;
wire						t_pt_skid;
wire						t_pt_correctable_error,	t_pe_correctable_error;
wire						w_pt_iok;
wire                                            w_p2_pt_iok;
wire                                            w_pvc_pt_iok;
wire						t_pt_ohit;
wire [3:0]					w_amc_vals;
wire [(3*FIDW)-1:0]				w_amc_fids;
wire [(3*5)-1:0]				w_amc_tins;
wire [4:0]                                      w_amc_mig;
wire [3:0]                                      w_p2_amc_vals;
wire [(3*FIDW)-1:0]                             w_p2_amc_fids;
wire [(3*5)-1:0]                                w_p2_amc_tins;
wire [4:0]                                      w_p2_amc_mig;
wire [3:0]                                      w_pvc_amc_vals;
wire [(3*FIDW)-1:0]                             w_pvc_amc_fids;
wire [(3*5)-1:0]                                w_pvc_amc_tins;
wire [4:0]                                      w_pvc_amc_mig;
\js if ((axiParams.eDomain?1:0)==0) {
wire                                            n_amc_nc = amc_nc_i;
\js } else {
wire                                            n_amc_nc = 1'b0;
\js }
wire                                            w_amc_nrs_region_hit;
wire                                            w_amc_nc;
wire [3:0]					w_amc_errs;
wire [4:0]					w_amc_order;
wire [3:0]                                      w_amc_size_of_ig;
wire                                            w_amc_unconnected_dce_access;
wire                                            w_amc_unconnected_dmi_access;
wire                                            w_amc_unconnected_dii_access;
wire                                            w_p2_amc_nrs_region_hit;
wire                                            w_p2_amc_nc;
wire [3:0]                                      w_p2_amc_errs;
wire [4:0]                                      w_p2_amc_order;
wire [3:0]                                      w_p2_amc_size_of_ig;
wire                                            w_p2_amc_unconnected_dce_access;
wire                                            w_p2_amc_unconnected_dmi_access;
wire                                            w_p2_amc_unconnected_dii_access;
wire                                            w_pvc_amc_nrs_region_hit;
wire                                            w_pvc_amc_nc;
wire [3:0]                                      w_pvc_amc_errs;
wire [4:0]                                      w_pvc_amc_order;
wire [3:0]                                      w_pvc_amc_size_of_ig;
wire                                            w_pvc_amc_unconnected_dce_access;
wire                                            w_pvc_amc_unconnected_dmi_access;
wire                                            w_pvc_amc_unconnected_dii_access;
wire                                            no_credit_access;
wire	t_pt_ReadNoSnoop, t_pt_WriteNoSnoop, t_pt_CleanShared,
	t_pt_CleanSharedPersist, t_pt_CleanInvalid, t_pt_MakeInvalid,
	t_pt_DvmMessage, t_pt_ReadOnceMakeInvalid, t_pt_AceEvict,
	t_pt_WriteBack, t_pt_ReadValid, t_pt_ReadNITC, t_pt_ReadShared, 
	t_pt_ReadClean, t_pt_ReadUnique, t_pt_ReadNotSharedDirty, 
	t_pt_CleanUnique, t_pt_MakeUnique, t_pt_StashOnceShared, 
	t_pt_StashOnceUnique, t_pt_WriteUniqueRd, t_pt_WriteLineUniqueLine,
	t_pt_WriteClean, t_pt_WriteEvict;	
wire		n_dtv_ready;
wire		w_dtv_ready;
wire		n_dtv_valid;
wire		w_dtv_valid;
wire		t_dve_state;
wire		t_cmr_stall;
wire		t_ag_inc, t_ag_dec;
wire [OCA:0]	t_ag_count;
wire		t_sv_timeout, t_sv_starve;
wire [64:0]	t_sv_eaddr;
wire [IW-1:0]	t_sv_id;
wire [1:0]	t_sv_type;
wire [OLA-1:0]			w_p0w_dptr;
wire [BWL:0]					t_pt_beats, n_oc_beats, n_owo_beats, n_oc_beats_calc;
wire [5:0]      n_oc_beats_adj;
wire		w_poc_ready,	n_poc_ready;
wire		n_poc_valid,	w_poc_valid, t_poc_valid;
wire                                         t_poc_valid_qual;
wire [OCA-1:0]	n_poc_oid,	w_poc_oid;
wire [OCN-1:0]	n_poc_obv;
wire [OCN-1:0]	q_poc_obv;
wire [OCN-1:0]	q_poc_obv_ns;
wire		w_pvc_ready,	n_pvc_ready;
wire		n_pvc_valid,	w_pvc_valid;
wire [OCA-1:0]	n_pvc_oid,	w_pvc_oid;
wire [OCN-1:0]	n_pvc_obv;
wire [AW-1:0]	n_pvc_addr,	w_pvc_addr;
wire		n_pvc_security,	w_pvc_security;
wire            w_ppvc_ready;
wire            n_ppvc_valid;
wire [OCA-1:0]  n_ppvc_oid,      w_ppvc_oid;
wire [OCN-1:0]  n_ppvc_obv;
wire		t_prb_valid;
wire		w_rb_ready, 	n_rb_ready,	w_wb_ready, 	n_wb_ready;
wire		n_rb_valid, 	w_rb_valid,	n_wb_valid, 	w_wb_valid;
wire [AW-1:0]	n_rb_addr,	w_rb_addr,	n_wb_addr,	w_wb_addr;
wire [7:0]	n_rb_len,	w_rb_len,	n_wb_len,	w_wb_len;
wire [2:0]	n_rb_size,	w_rb_size,	n_wb_size,	w_wb_size;
wire [1:0]	n_rb_burst,	w_rb_burst,	n_wb_burst,	w_wb_burst;
wire		n_rb_lock,	w_rb_lock,	n_wb_lock,	w_wb_lock;
wire [3:0]	n_rb_cache,	w_rb_cache,	n_wb_cache,	w_wb_cache;
wire [2:0]	n_rb_prot,	w_rb_prot,	n_wb_prot,	w_wb_prot;
wire [RW-1:0]	n_rb_region,	w_rb_region,	n_wb_region,	w_wb_region;
wire [QW-1:0]	n_rb_qos,	w_rb_qos,	n_wb_qos,	w_wb_qos;
wire [IW-1:0]	n_rb_id,	w_rb_id,	n_wb_id,	w_wb_id;
wire [MW-1:0]	n_rb_domain,	w_rb_domain,	n_wb_domain,	w_wb_domain;
wire [SW-1:0]	n_rb_snoop,	w_rb_snoop,	n_wb_snoop,	w_wb_snoop;
wire [MW-1:0]	n_rb_bar,	w_rb_bar,	n_wb_bar,	w_wb_bar;
wire [AXUW-1:0] n_rb_user,	w_rb_user,	n_wb_user,	w_wb_user;
wire [AXKW-1:0] n_rb_track,	w_rb_track,	n_wb_track,	w_wb_track;
wire [1:0]	n_rb_wrap,	w_rb_wrap,	n_wb_wrap,	w_wb_wrap;
wire [15:AWL]	n_rb_count,	w_rb_count,	n_wb_count,	w_wb_count;
wire [1:0]	t_c0_sel;
wire		w_ce_af;
wire		w_wq_af;
wire				n_wq_ready;
wire				w_wq_valid;
wire [OCA-1:0]	n_wq_oid;
wire [OCA-1:0]	w_wq_oid, w_fq_oid;
wire            w_fq_fkm;
wire		w_c0_af;
wire		w_c1_ready;
wire		n_c1_valid;
wire [\=PXW+1+2+1+4=\:0]	n_c1_data;
wire				n_c2_ready;
wire				w_c2_valid, t_c2_valid;
wire [STN-1:0]  upmatch;  // upmatch signal per STT entry.
wire 		t_c2_upmatch_i; // Match from snoop for AXI proxy cache response (Sharer promotion)
wire 		n_p0_upmatch;
wire 		w_p0_upmatch;
wire 		n_p1_upmatch;
wire            w_p1_upmatch;
wire 		w_p2_upmatch;

wire [1:0] 	t_c2_up_i;
wire [1:0] 	n_p0_up;
wire [1:0]	w_p0_up;
wire [1:0]	n_p1_up;
wire [1:0]      w_p1_up;
wire [1:0]	w_p2_up;

wire				w_c2_chit;
wire				t_c2_cancel;
wire				t_c2_cancel_alloc;
wire				t_c2_delay;
wire				w_c2_retry;
wire				w_c2_room;
wire [3:0]			t_c2_nacks;
wire				t_c2_lookup;
wire [BWL:0]			t_c2_len;
wire [BWL-1:0]			t_c2_drop,
				t_c2_offset;
wire				t_c2_eob;
wire [ARPW-1:0]			t_c2_resp;
wire				w_c2_flush;
wire				w_c2_sndtr, w_c2_sndtw;
wire				w_c2_evict;
wire [CSW-1:0]			w_c2_state, t_c2_estate;
wire		w_rp1_ready,	w_rpt_ready,	n_rr_ready;
wire		n_rp1_valid,	n_rpt_valid,	w_rr_valid, t_rr_valid;
wire [2:0]      w_rr_guts_valid;
wire [XTA-1:0]			n_rpt_kid;
wire				n_rpt_wake;
wire		n_oc_ready;
wire		n_oc_eob;
wire		t_oc_we,
		t_oc_rinc, t_oc_winc,
		w_oc_rdec, w_oc_wdec;
wire            t_oc_cmd_sent_ns;
wire            t_oc_cmd_sent;
wire            t_oc_cmd_error_ns;
wire            t_oc_cmd_error;
wire [1:0]	t_oc_rdec, t_oc_wdec;
wire		w_oc_eval;
wire [OCN-1:0]	t_oc_free, t_oc_alloc, t_oc_dealloc, t_oc_stp, t_oc_ihit,
		t_oc_ohit, t_oc_wrbk, t_oc_dve, t_oc_dtv, t_oc_dvm, t_oc_dve_sync,
		t_oc_rok, t_oc_dtw, t_oc_coal, t_oc_fkm, t_oc_iok,
		t_oc_wake, t_oc_wfmru, t_oc_wfcmd, t_oc_wrev, t_oc_error,
		t_oc_ahit, t_oc_ahitr, t_oc_ahite, t_oc_rack, t_oc_wack, t_oc_ahit_outstanding,
		t_oc_wdone, t_oc_rdone, t_oc_ihead, t_oc_wfcwd, t_oc_dval,
		w_oc_kwbv, w_upd_req_obv,
		t_oc_wfcfd, t_oc_wfcft, t_oc_str_err, t_oc_chit, t_oc_update,
		t_oc_valloc, t_oc_wfupr, t_oc_evict, t_oc_ce, t_oc_cmr,
		t_oc_edealloc, w_oc_edbv0, w_oc_edbv1,
		t_oc_rdealloc, w_oc_rdbv0, w_oc_rdbv1, 
		t_oc_wdealloc, w_oc_wdbv0, w_oc_wdbv1;
wire            cft_ready;
wire            cft_valid;
wire [CSW-1:0]  cft_state;
wire [AW-1:0]   cft_addr;
wire            cft_security;
wire [CWW-1:0]  cft_way;
wire [OCN-1:0]  cft_obv_o;
wire [OCN-1:0]	addr_match;
wire [OCN-1:0]	t_oc_fini;
wire [OCA:0]	t_oc_count, t_oc_ecount;
wire  [OCA:0]    q_oc_count;
wire [OCA-1:0]	n_oc_wptr, w_oc_ihid, n_pw_oid,
		w_upd_req_oid,
		w_oc_ahidr, w_oc_ahide, w_oc_eptr, n_oc_eptr, t_oc_ehid; 
wire [OLN-1:0]	t_oc_dbusy[OCN-1:0], t_px_dbusy;
wire [OCN-1:0]	t_od_dbusy[OLN-1:0];
wire [OLN-1:0]	t_od_free, t_od_alloc, t_od_dealloc, 
		t_od_wfree, w_od_candidate,
		t_od_efree, w_od_ecandidate;
wire [OLA-1:0]  w_od_eptr;
wire		n_od_ready, w_od_wready, w_od_eready;
wire		t_od_we;
wire [OLA-1:0]	n_od_wptr, n_oc_dptr, w_od_dptr, t_od_eptr;
wire [OCN-1:0]	w_od_dptr_vec, t_od_eptr_vec;
wire		t_pvc_throttle;
wire				w_cmd_req0_af;
wire				w_cmd_req0_ready,	n_cmd_req0_ready;
wire				n_cmd_req0_valid,	w_cmd_req0_valid;
wire				n_cmd_req0_valid_no_err;
wire				n_cmd_req0_valid_last;
wire [2:0]			n_cmd_req0_size,	w_cmd_req0_size;
wire [MRCD-1:0]			n_cmd_req0_did,	w_cmd_req0_did;
wire [MRCQ-1:0]			n_cmd_req0_qos,	w_cmd_req0_qos;
wire [QOSW-1:0]			n_cmd_req0_qin,	w_cmd_req0_qin;
wire [AXUW-1:0]			n_cmd_req0_user,	w_cmd_req0_user;
wire [MRCA-1:0] 		n_cmd_req0_addr,	w_cmd_req0_addr;
wire [MRCM-1:0]			n_cmd_req0_mid,	w_cmd_req0_mid;
wire [MRCT-1:0]			n_cmd_req0_tid,	w_cmd_req0_tid;
wire [7:0]			n_cmd_req0_cmd,	w_cmd_req0_cmd;
wire				n_cmd_req0_st, 	w_cmd_req0_st,
				n_cmd_req0_ch, 	w_cmd_req0_ch,
				n_cmd_req0_ca, 	w_cmd_req0_ca,
				n_cmd_req0_ac, 	w_cmd_req0_ac,
                                n_cmd_req0_ac_int,
				n_cmd_req0_vz, 	w_cmd_req0_vz,
				n_cmd_req0_tr, 	w_cmd_req0_tr,
				n_cmd_req0_ns,	w_cmd_req0_ns,
				n_cmd_req0_es,	w_cmd_req0_es,
				n_cmd_req0_pr,	w_cmd_req0_pr,
				n_cmd_req0_ts;
wire [1:0] 		        n_cmd_req0_rl,      w_cmd_req0_rl;				
reg [1:0]			n_cmd_req0_or;
wire [1:0] w_cmd_req0_or;
wire [MRC1-1:0]			n_cmd_req0_mpf1,	w_cmd_req0_mpf1;
wire [MRC2-1:0]			n_cmd_req0_mpf2,	w_cmd_req0_mpf2;
wire [MRCI-1:0]			n_cmd_req0_iid;
wire [DOFF-1:0]			n_upd_req0_doff;
wire						n_cmd_req1_ready;
wire						w_cmd_req1_valid;
wire [2:0]					w_cmd_req1_size;
wire [MRCD-1:0]					w_cmd_req1_did;
wire [MRCQ-1:0]					w_cmd_req1_qos;
wire [QOSW-1:0]					w_cmd_req1_qin;
wire [AXUW-1:0]					w_cmd_req1_user;
wire [MRCA-1:0] 				w_cmd_req1_addr;
wire [MRCM-1:0]					w_cmd_req1_mid;
wire [MRCT-1:0]					w_cmd_req1_tid;
wire [7:0]					w_cmd_req1_cmd;
wire						w_cmd_req1_st,
						w_cmd_req1_ch,
						w_cmd_req1_ca,
						w_cmd_req1_ac,
						w_cmd_req1_vz,
						w_cmd_req1_tr,
						w_cmd_req1_ns,
						w_cmd_req1_es,
						w_cmd_req1_pr;
wire [1:0] 				        w_cmd_req1_rl;
wire [1:0]					w_cmd_req1_or;
wire [MRC1-1:0]					w_cmd_req1_mpf1;
wire [MRC2-1:0]					w_cmd_req1_mpf2;
wire						t_cmd_req_ok;
wire						t_cmd_req_inc, t_cmd_req_dec;
wire [3:0]	n_cmd_req0_incs;
wire [3:0]	n_cmd_req0_incs_no_err;
wire		t_cmd_rsp_dec;
wire		w_dce_idle, w_dmi_idle, w_dii_idle, w_dve_idle, w_qos_idle;

wire [DCEN-1:0]	w_dce_boks, w_dce_woks;
wire [DMIN-1:0]	w_dmi_boks, w_dmi_woks;
wire [DIIN-1:0]	w_dii_boks, w_dii_woks;

wire [DCEN-1:0]	w_dce_haveNoCredits;
wire [DMIN-1:0]	w_dmi_haveNoCredits;
wire [DIIN-1:0]	w_dii_haveNoCredits;

wire [DVEN-1:0]	w_dve_boks;

wire [DCEN-1:0]	w_dce_sp_write_used; 
wire [DMIN-1:0]	w_dmi_sp_write_used; 
wire [DIIN-1:0]	w_dii_sp_write_used;
wire [DVEN-1:0]	w_dve_sp_write_used;

wire [QOSN-1:0]	w_qos_boks, w_qos_woks;
wire		w_upd_req0_ready,	n_upd_req0_ready;
wire		n_upd_req0_valid,	w_upd_req0_valid;
wire [QOSW-1:0] n_upd_req0_qin,	w_upd_req0_qin;
wire [MRUM-1:0]	n_upd_req0_mid,	w_upd_req0_mid;
wire [MRUT-1:0]	n_upd_req0_tid,	w_upd_req0_tid;
wire [MRUA-1:0]	n_upd_req0_addr,	w_upd_req0_addr;
wire		n_upd_req0_security,w_upd_req0_security;
wire		n_upd_req0_trace   ,w_upd_req0_trace;
wire [MRUQ-1:0]	n_upd_req0_qos,	w_upd_req0_qos;
wire				n_upd_req1_ready;
wire				w_upd_req1_valid;
wire [QOSW-1:0]			w_upd_req1_qin;
wire [MRUM-1:0]			w_upd_req1_mid;
wire [MRUT-1:0]			w_upd_req1_tid;
wire [MRUA-1:0]			w_upd_req1_addr;
wire				w_upd_req1_security;
wire				w_upd_req1_trace;
wire [MRUQ-1:0]			w_upd_req1_qos;
wire				t_upd_req_ok;
wire				t_upd_req_inc, t_upd_req_dec;
wire		w_dtr_req_tx0_ready,	n_dtr_req_tx0_ready;
wire		w_dtr_req_tx0_ready_pre;
wire		n_dtr_req_tx0_valid,	w_dtr_req_tx0_valid;
wire [7:0]	w_dtr_req_tx0_cmd;
wire [7:0]     n_dtr_req_tx0_cmd;
reg [7:0] n_moesi_dtr;
wire [7:0] n_ace_dtr;
wire [7:0] n_ace_dtw;
wire [MRRM-1:0]	n_dtr_req_tx0_mid,	w_dtr_req_tx0_mid;
wire [MRRR-1:0]	n_dtr_req_tx0_rid,	w_dtr_req_tx0_rid;
wire [MRRT-1:0]	n_dtr_req_tx0_tid,	w_dtr_req_tx0_tid;
wire [QOSW-1:0]	n_dtr_req_tx0_qin,	w_dtr_req_tx0_qin;
wire		n_dtr_req_tx0_tr,	w_dtr_req_tx0_tr;
wire		n_dtr_req_tx0_last,	w_dtr_req_tx0_last;
reg [MRWZ*3-1:0]  n_dtr_req_tx0_dwid;
wire [MRWZ*3-1:0] w_dtr_req_tx0_dwid;
wire [DWP-1:0]		n_dtr_req_tx0_poison,	w_dtr_req_tx0_poison;
wire		n_dtr_req_tx0_status,	w_dtr_req_tx0_status;
wire [MRRD-1:0]	n_dtr_req_tx0_wdata,	w_dtr_req_tx0_wdata;
wire [MRRB-1:0]	n_dtr_req_tx0_be,	w_dtr_req_tx0_be;
wire [BSE*8:0]	             	w_dtr_req_tx0_tbits;
wire [8:0]	n_dtr_req_tx0_tbits;
wire [AW-1:0]	n_dtr_req_tx0_addr;
wire [1:0]	n_dtr_req_tx0_isize;
wire [BWL-1:0]	t_dtr_req_tx0_dwid;
wire				w_dtr_req_tx1_af;
wire		w_dtr_req_tx1_ready,	n_dtr_req_tx1_ready;
wire		n_dtr_req_tx1_valid,	w_dtr_req_tx1_valid;
wire [7:0]	n_dtr_req_tx1_cmd,	w_dtr_req_tx1_cmd;
wire [MRRM-1:0]	n_dtr_req_tx1_mid,	w_dtr_req_tx1_mid;
wire [MRRR-1:0]	n_dtr_req_tx1_rid,	w_dtr_req_tx1_rid;
wire [MRRT-1:0]	n_dtr_req_tx1_tid,	w_dtr_req_tx1_tid;
wire [QOSW-1:0]	n_dtr_req_tx1_qin,	w_dtr_req_tx1_qin;
wire		n_dtr_req_tx1_tr,	w_dtr_req_tx1_tr;
wire		n_dtr_req_tx1_last,	w_dtr_req_tx1_last;
wire [MRWZ*3-1:0]n_dtr_req_tx1_dwid,	w_dtr_req_tx1_dwid;
wire [DWP-1:0]	n_dtr_req_tx1_poison,	w_dtr_req_tx1_poison;
wire		n_dtr_req_tx1_status,	w_dtr_req_tx1_status;
wire [MRRD-1:0]	n_dtr_req_tx1_wdata,	w_dtr_req_tx1_wdata;
wire [MRRB-1:0]	n_dtr_req_tx1_be,	w_dtr_req_tx1_be;
wire				t_dtr_req_tx_ok;
wire				t_dtr_req_tx_inc, t_dtr_req_tx_dec;
wire [AW-1:0]	n_dtw_req0_addr;
wire		n_dtw_req0_security;
wire		w_dtw_req0_ready,	n_dtw_req0_ready;
wire		n_dtw_req0_valid,	w_dtw_req0_valid;
wire		n_dtw_req0_py,	w_dtw_req0_py;
wire		n_dtw_req0_tr,	w_dtw_req0_tr;
wire [1:0]	n_dtw_req0_rl,	w_dtw_req0_rl;
wire [1:0]	n_dtw_req0_isize,	w_dtw_req0_isize;
wire [MRW1-1:0]	n_dtw_req0_mpf1,	w_dtw_req0_mpf1;
wire [MRW2-1:0]	n_dtw_req0_mpf2,	w_dtw_req0_mpf2;
wire [7:0]	n_dtw_req0_cmd,	w_dtw_req0_cmd;
wire [MRWM-1:0]	n_dtw_req0_mid,	w_dtw_req0_mid;
wire [MRWT-1:0]	n_dtw_req0_tid,	w_dtw_req0_tid;
wire [QOSW-1:0]	n_dtw_req0_qin,	w_dtw_req0_qin;
wire [MRWV-1:0]	n_dtw_req0_bid,	w_dtw_req0_bid;
wire		n_dtw_req0_last,	w_dtw_req0_last;
reg  [MRWZ*3-1:0] n_dtw_req0_dwid;	
wire [MRWZ*3-1:0] w_dtw_req0_dwid;
wire [DWP-1:0]	n_dtw_req0_poison,	w_dtw_req0_poison;
wire		n_dtw_req0_status,	w_dtw_req0_status;
wire [MRWD-1:0]	n_dtw_req0_wdata,	w_dtw_req0_wdata;
wire [MRWB-1:0]	n_dtw_req0_be,	w_dtw_req0_be;
wire [BWL-1:0]	t_dtw_req0_dwid;
wire				w_dtw_req1_af;
wire				n_dtw_req1_ready;
wire				w_dtw_req1_valid;
wire				w_dtw_req1_py;
wire				w_dtw_req1_tr;
wire [1:0]			w_dtw_req1_rl;
wire [1:0]			w_dtw_req1_isize;
wire [MRW1-1:0]			w_dtw_req1_mpf1;
wire [MRW2-1:0]			w_dtw_req1_mpf2;
wire [7:0]			w_dtw_req1_cmd;
wire [MRWM-1:0]			w_dtw_req1_mid;
wire [MRWT-1:0]			w_dtw_req1_tid;
wire [QOSW-1:0]			w_dtw_req1_qin;
wire [MRWV-1:0]			w_dtw_req1_bid;
wire				w_dtw_req1_last;
wire [MRWZ*3-1:0]		w_dtw_req1_dwid;
wire [DWP-1:0]			w_dtw_req1_poison;
wire				w_dtw_req1_status;
wire [MRWD-1:0]			w_dtw_req1_wdata;
wire [MRWB-1:0]			w_dtw_req1_be;
wire				t_dtw_req_ok;
wire				t_dtw_req_inc, t_dtw_req_dec;
wire		w_cmd_rsp_ready,	n_cmd_rsp_ready;
wire		n_cmd_rsp_valid,	w_cmd_rsp_valid;
wire [7:0]			w_cmd_rsp_status;
wire [OCA-1:0]			w_cmd_rsp_mid;
wire [MPCI-1:0]			w_cmd_rsp_iid;
wire		w_dtr_rsp_rx_ready,	n_dtr_rsp_rx_ready, n_dtr_rsp_rx_ready_mod;
wire		n_dtr_rsp_rx_valid,	w_dtr_rsp_rx_valid, w_dtr_rsp_rx_valid_mod;
wire [7:0]			w_dtr_rsp_rx_status;
wire [MRRM-1:0]			w_dtr_rsp_rx_mid;
wire		w_dtw_rsp_ready,	n_dtw_rsp_ready;
wire		n_dtw_rsp_valid,	w_dtw_rsp_valid;
wire [7:0]			w_dtw_rsp_status;
wire [MRWM-1:0]			w_dtw_rsp_mid;
wire		w_upd_rsp_ready,	n_upd_rsp_ready;
wire		n_upd_rsp_valid,	w_upd_rsp_valid;
wire [7:0]			w_upd_rsp_status;
wire [OCA-1:0]			w_upd_rsp_mid;
wire		w_str_req_ready,	n_str_req_ready;
wire		n_str_req_valid,	w_str_req_valid;
wire [SRCI-1:0]			w_str_req_iid;
wire [OCN-1:0]                  w_str_req_rid_bv;
wire [SRCM-1:0]			w_str_req_mid;
wire [SRCB-1:0]			w_str_req_bid;
wire [OCA-1:0]			w_str_req_rid;
wire [7:0]			w_str_req_status;
wire [1:0]			w_str_req_isize;
wire [SRC1-1:0]			w_str_req_mpf1;
wire [SRC2-1:0]			w_str_req_mpf2;
wire		w_snp_req_ready,	n_snp_req_ready;
wire		n_snp_req_valid,	w_snp_req_valid;
wire [1:0]	n_snp_req_rl,
		n_snp_req_up,	w_snp_req_up;
wire		n_snp_req_tr, 
		n_snp_req_pr,	w_snp_req_pr,
		n_snp_req_ns,	w_snp_req_security,
		n_snp_req_ca, 
		n_snp_req_ac, 
		n_snp_req_vz;
wire [7:0]			w_snp_req_cmd;
wire [7:0]			w_snp_req_status;
wire				w_snp_req_trace;
wire				w_snp_req_as;
wire [1:0]			w_snp_req_isize;
wire [SRNA-1:0]			w_snp_req_addr;
wire [AW-1:0]			t_snp_req_addr, t_snp_req_mask, t_str_req_mask;
wire [SRNP-1:0]			w_snp_req_pri;
wire [SRNM-1:0]			w_snp_req_mid;
wire [SRNB-1:0]			w_snp_req_bid;
wire [SRNI-1:0]			w_snp_req_iid;
wire [SRN1-1:0]			w_snp_req_mpf1;
wire [SRN2-1:0]			w_snp_req_mpf2;
wire [SRN3-1:0]			w_snp_req_mpf3;
wire [SRND-1:0]			w_snp_req_did;
wire [SRNF-1:0]			w_snp_req_tof;
wire						w_srs_ready;
wire						n_srs_valid;
wire		w_dtr_req_rx_ready,	n_dtr_req_rx_ready,			n_srm_ready;
wire		n_dtr_req_rx_valid,	w_dtr_req_rx_valid,			w_srm_valid;
wire				w_dtr_req_rx_last;
wire [SRRR-1:0]			w_dtr_req_rx_rid,	w_fkm_rid,	w_srm_rid;
wire [OCN-1:0]			w_dtr_req_rx_obv,			w_srm_obv;
wire [SRRP-1:0]			w_dtr_req_rx_pri;
wire [SRRI-1:0]			w_dtr_req_rx_iid;
wire [SRRM-1:0]			w_dtr_req_rx_mid;
wire [DWP-1:0]			w_dtr_req_rx_poison;
wire [3:2]			w_dtr_req_rx_aresp;
wire [SRRZ-1:0]			w_dtr_req_rx_dbad;
wire [SRRD-1:0]			w_dtr_req_rx_data;
wire [SRRB-1:0]			w_dtr_req_rx_be;
wire				w_dtr_req_rx_trace;
wire [OCA-1:0]			w_srd_oid;
wire [OCN-1:0]			w_srd_obv;
wire           		        w_srd_fkm;
wire [OCN-1:0]			n_sod_oid_bv;
wire [OCN-1:0]			w_sod_oid_bv;
wire [7:0]			w_dtr_req_rx_cmd;
wire [7:0]			w_dtr_req_rx_status;
wire [1:0]					w_srm_wbv;
wire				t_srd_dtr;
wire [5:0]			t_srd_sel;
wire [BWL:0]			t_srd_beats, t_srd_offset, t_srd_pre_offset;
wire				t_srd_ihead;
wire				t_srd_dirty;
wire				t_srd_adone;
wire				t_srd_bypass;
wire		w_sod_ready,	n_sod_ready;
wire		n_sod_valid,	w_sod_valid;
wire [OCA-1:0]	n_sod_oid,	w_sod_oid;
wire [ODA-1:0]	n_sod_waddr,	w_sod_waddr;
wire [DW-1:0]	n_sod_wdata,	w_sod_wdata;
wire [BW-1:0]	n_sod_be,	w_sod_be;
wire [DWP-1:0]	n_sod_poison,	w_sod_poison;
wire		n_dd_valid;
wire		w_fq_ready,	w_wq_ready;
wire		n_fq_valid,	n_rd_valid;
wire		w_oms_ready;
wire		n_oms_valid;
wire [ODA-1:0]	n_oms_raddr;
wire		w_odm_ready,	n_odm_ready;
wire		n_odm_valid,	w_odm_valid;
wire [ODA-1:0]	n_odm_raddr;
wire [DWP-1:0]			w_odm_poison;
wire [DW-1:0]			w_odm_rdata;
wire [BW-1:0]			w_odm_be;
wire		w_odw_ready,	n_odw_ready;
wire		n_odw_valid,	w_odw_valid;
wire [ODA-1:0]	n_odw_raddr;
wire [DWP-1:0]			w_odw_poison;
wire [DW-1:0]			w_odw_rdata;
wire [BW-1:0]			w_odw_be;
wire [OCA-1:0]	n_odw_oid,	w_odw_oid;
wire [BWL-1:0]	             	w_odw_offset;
wire [CLO-1:0]	n_odw_offset;
wire		n_odw_last,	w_odw_last;
wire		w_odr_ready, t_odr_ready;
wire		n_odr_valid,	w_c2_done;
wire [ODA-1:0]	n_odr_raddr;
wire [AXKW-1:0]	n_odr_track;
wire		n_odr_eob;
wire [IW-1:0]	n_odr_id;
wire		n_odr_last;
wire		n_odr_cmo;
wire		n_odr_csr;
wire		n_odr_bar;
wire [ODPW-1:0]	n_odr_resp;
wire [BWL:0]	n_odr_beats;
wire [CLO-1:0]	n_odr_offset;
wire		n_odr_adone;
wire [OCA-1:0]	n_odr_oid; 
wire [OCN-1:0]	n_odr_obv, n_odr_lbv;
wire		w_ocr_ready,	n_ocr_ready,	w_ocw_ready,	n_ocw_ready;
wire		n_ocr_valid,	w_ocr_valid,	n_ocw_valid,	w_ocw_valid;
wire [OCA-1:0]	n_ocr_oid,	w_ocr_oid,	n_ocw_oid,	w_ocw_oid;
wire [OCN-1:0]	n_ocr_obv, n_ocr_lbv, w_ocr_obv,		n_ocw_obv, n_ocw_lbv;
wire		w_fkm_ready,	n_fkm_ready, t_fkm_ready;
wire		n_fkm_valid,	w_fkm_valid;
wire [OCA-1:0]	n_fkm_oid,	w_fkm_oid;
wire [OCN-1:0]	n_fkm_obv, 	w_fkm_obv,
		n_fkm_lbv;
wire				w_fkm_last;
wire		n_cdr_ready,	n_odr_ready,	n_sdr_ready;
wire		w_cdr_valid,	w_odr_valid,	w_sdr_valid;
wire		t_cdr_valid;
wire		t_cdr_in_progress_in;
wire		t_cdr_in_progress;
wire [BWL-1:0]	w_cdr_drop,	t_cdr_count,
		w_cdr_offset;
wire [AXKW-1:0]	w_cdr_track,	w_odr_track,	w_sdr_track;
wire		w_cdr_eob,	w_odr_eob,	w_sdr_eob;
wire [OCA-1:0]	w_cdr_oid,	w_odr_oid,	w_sdr_oid;
wire [IW-1:0]	w_cdr_id,	w_odr_id,	w_sdr_id;
wire [ARPW-1:0]	w_cdr_resp,	w_odr_resp,	w_sdr_resp,
		t_cdr_resp,	t_odr_resp;
wire            w_cdr_err;
wire				w_odr_cmo;
wire				w_odr_csr;
wire				w_odr_bar;
wire [ODPW-1:0]			w_odr_response;
wire		w_cdr_last,	w_odr_last,	w_sdr_last;
wire [DW-1:0]	w_cdr_rdata,	w_odr_rdata,	w_sdr_rdata,
				t_odr_rdata;
wire [BW-1:0]			w_odr_be;
wire [DWP-1:0]	w_cdr_poison,	w_odr_poison,	w_sdr_poison;
wire [DWP-1:0]  t_odw_poison,   t_odf_poison, t_odr_poison, t_odm_poison;
wire				n_drx_ready;
wire				w_drx_valid;
wire				w_drx_eob;
wire [AXKW-1:0]			w_drx_track;
wire [OCA-1:0]			w_drx_oid;
wire [IW-1:0]			w_drx_id;
wire [ARPW-1:0]			w_drx_resp;
wire				w_drx_last;
wire [DW-1:0]			w_drx_rdata;
wire [DWP-1:0]			w_drx_poison;
wire [2:0]	t_drx_sel;
wire		w_rkq_ready;
wire		n_rkq_valid,	w_rkq_valid;
wire		t_rkq_valid;
wire		w_do_af;
wire		w_do_ready,	n_do_ready;
wire		n_do_valid,	w_do_valid;
wire [1:0]	n_do_data,	w_do_data;
wire		w_dr0_af;
wire		w_dr0_ready,	n_dr0_ready;
wire		n_dr0_valid,	w_dr0_valid;
wire [AXKW-1:0]	n_dr0_track,	w_dr0_track;
wire [IW-1:0]	n_dr0_id,	w_dr0_id;
wire [ARPW-1:0]	n_dr0_resp,	w_dr0_resp;
wire		n_dr0_last,	w_dr0_last;
wire [DW-1:0]	n_dr0_rdata,	w_dr0_rdata;
wire [DWP-1:0]	n_dr0_poison,	w_dr0_poison;
wire				n_dr1_ready;
wire				w_dr1_valid;
wire [AXKW-1:0]			w_dr1_track;
wire [IW-1:0]			w_dr1_id;
wire [ARPW-1:0]			w_dr1_resp;
wire				w_dr1_last;
wire [DW-1:0]			w_dr1_rdata;
wire [DWP-1:0]			w_dr1_poison;
wire [OCN-1:0]			n_odf_obv;
wire		w_odf_ready,	n_odf_ready,	n_of_ready;
wire		n_odf_valid,	w_odf_valid,	w_of_valid;
wire [ODA-1:0]	n_odf_raddr;
wire [BWL-1:0]	n_odf_count,	w_odf_count,	w_of_count, t_odf_count;
wire		n_odf_last,	w_odf_last,	w_of_last;
wire [OCN-1:0]  n_odf_oid_bv;
wire [OCA-1:0]	n_odf_oid,	w_odf_oid,	w_of_oid;
wire [DWP-1:0]			w_odf_poison,	w_of_poison;
wire [DW-1:0]			w_odf_rdata,	w_of_rdata;
wire [BW-1:0]			w_odf_be,	w_of_be;
wire [2:0]					t_of_sel;
wire [1:0]					t_of_stash;
wire [1:0]	t_ce_sel;
wire		w_ce_evict, t_ce_dtr, t_ce_dtw, w_ce_dropped;
wire            t_ce_dtw_stall;
wire            t_ce_drop;
wire [STA-1:0]					w_cs_sid;
wire						w_cs_security;
wire                                            w_cs_sndtr;
wire                                            w_cs_sndtw;
wire						w_cs_trace;
wire		w_ce_ready,	n_co_ready,	n_cs_ready;
wire		n_ce_valid,	w_co_valid,	w_cs_valid;
wire		n_ce_last,	w_co_last,	w_cs_last;
wire [DW-1:0]	n_ce_rdata,	w_co_rdata,	w_cs_rdata;
wire [BW-1:0]	n_ce_be,	w_co_be,	w_cs_be;
wire [DWP-1:0]	n_ce_poison,	w_co_poison,	w_cs_poison;
wire [BWL-1:0]			w_co_count,	w_cs_count;
wire [OCA-1:0]			w_co_oid;
wire [OCN-1:0]			w_co_obv;
wire [OLA-1:0]			w_co_dptr, w_odr_dptr, w_odf_dptr, w_srd_dptr;
wire [OCN*OLA-1:0]		t_co_dptr, t_odr_dptr, t_odf_dptr, t_srd_dptr;
wire [ODA-1:0]			t_co_waddr;
wire				t_co_fdone;

wire t_odr_in_progress_in,t_odr_in_progress;
wire [ODRN-1:0]		  w_rn_ready;
wire [ODRN-1:0]		  n_rn_valid;
wire [(ODRN*ODA)-1:0]	  n_rn_raddr;
wire [(ODRN*ODIW)-1:0]	  n_rn_info;
wire [ODRN-1:0]		  n_rn_ready;
wire [ODRN-1:0]		  w_rn_valid;
wire [(ODRN*(DW+BW+DWP))-1:0] w_rn_rdata;
wire [(ODRN*ODIW)-1:0]	  w_rn_info;
wire [ODIW-ODFIW-1:0] n_odf_pad, w_odf_pad;
wire [ODIW-ODRIW-1:0] n_odr_pad, w_odr_pad;
wire [ODIW-1:0]       n_odm_pad, w_odm_pad;
wire [ODIW-ODWIW-1:0]       n_odw_pad, w_odw_pad;
wire [OCA-1:0]			w_dtv_oid;
wire [OCA-1:0]			n_dtv_oid;
wire [OCN-1:0]			w_dtv_obv;
wire [OCN-1:0]			n_dtv_obv;
wire		w_ocp_ready,	n_ocp_ready;
wire		n_ocp_valid,	w_ocp_valid;
wire [OCA-1:0]	n_ocp_oid,	w_ocp_oid;
wire [OCN-1:0]	n_ocp_obv,	w_ocp_obv;
wire		w_str_rsp0_ready,	n_str_rsp0_ready;
wire		n_str_rsp0_valid,	w_str_rsp0_valid;
wire		n_str_rsp0_cancel;
wire		n_str_rsp0_trace,	w_str_rsp0_trace;
wire [7:0]	n_str_rsp0_status,	w_str_rsp0_status;
wire [SPCT-1:0]	n_str_rsp0_tid,	w_str_rsp0_tid;
wire [SPCR-1:0]	n_str_rsp0_rid,	w_str_rsp0_rid;
wire [QOSW-1:0]	n_str_rsp0_qin,	w_str_rsp0_qin;
wire				n_str_rsp1_ready;
wire				w_str_rsp1_valid;
wire				w_str_rsp1_trace;
wire [7:0]			w_str_rsp1_status;
wire [SPCT-1:0]			w_str_rsp1_tid;
wire [SPCR-1:0]			w_str_rsp1_rid;
wire [QOSW-1:0]			w_str_rsp1_qin;
wire		w_snp_rsp0_ready,	n_snp_rsp0_ready;
wire		n_snp_rsp0_valid,	w_snp_rsp0_valid;
wire [7:0]	n_snp_rsp0_status,	w_snp_rsp0_status;
wire        	n_snp_rsp0_trace,	w_snp_rsp0_trace;
wire		n_snp_rsp0_rv, n_snp_rsp0_rs, n_snp_rsp0_dc, n_snp_rsp0_dt0, n_snp_rsp0_dt1,
		n_snp_rsp0_drop;
wire [SRNP-1:0]	n_snp_rsp0_pri,	w_snp_rsp0_pri;
wire [SRCM-1:0]	n_snp_rsp0_mid,	w_snp_rsp0_mid;
wire [SPNT-1:0]	n_snp_rsp0_tid,	w_snp_rsp0_tid;
wire				n_snp_rsp1_ready;
wire				w_snp_rsp1_valid;
wire [7:0]			w_snp_rsp1_status;
wire                            w_snp_rsp1_trace;
wire [SRNP-1:0]			w_snp_rsp1_pri;
wire [SRCM-1:0]			w_snp_rsp1_mid;
wire [SPNT-1:0]			w_snp_rsp1_tid;
wire		w_dtr_rsp_tx_ready,	n_dtr_rsp_tx_ready;
wire		n_dtr_rsp_tx_valid,	w_dtr_rsp_tx_valid;
wire		n_dtr_rsp_tx_trace,	w_dtr_rsp_tx_trace;
wire [7:0]	n_dtr_rsp_tx_status,	w_dtr_rsp_tx_status; 
wire [SRRP-1:0]	n_dtr_rsp_tx_pri,	w_dtr_rsp_tx_pri;
wire [SRRM-1:0]	n_dtr_rsp_tx_mid,	w_dtr_rsp_tx_mid;
wire [SPRT-1:0]	n_dtr_rsp_tx_tid,	w_dtr_rsp_tx_tid;
wire				n_dtr_rsp_tx1_ready;
wire				w_dtr_rsp_tx1_valid;
wire				w_dtr_rsp_tx1_trace;
wire [7:0]			w_dtr_rsp_tx1_status; 
wire [SRRP-1:0]			w_dtr_rsp_tx1_pri;
wire [SRRM-1:0]			w_dtr_rsp_tx1_mid;
wire [SPRT-1:0]			w_dtr_rsp_tx1_tid;
wire				n_cm0_ready;
wire				w_cm0_valid;
wire [MRCM-1:0]			w_cm0_mid;
wire [7:0]			w_cm0_status;
wire                            n_cm1_ready;
wire                            w_cm1_ready;
wire [MRCM-1:0]			w_cm1_mid;
wire                            w_cm1_valid;
wire		w_cmp_rsp_ready,	n_cmp_rsp_ready;
wire		n_cmp_rsp_valid,	w_cmp_rsp_valid, w_cmp_rsp_valid_raw;
wire            n_cm1_valid;
wire [MRCM-1:0]			w_cmp_rsp_mid;
wire		w_init_ready;
wire		t_init_valid;
wire [5:0]	t_uerrs;
wire [19:0]	t_uinfo;
wire [2:0]	t_cerrs;
wire [15:6]	t_cinfo;
wire [25:0]	t_elog;
wire [64:0]	t_eaddr;

wire		q_reset_n;
wire [ODA-1:0]	q_init_count;
wire [BWL-1:0]	q_w1_beats;
wire		q_w1_partial;
wire [MRCT-1:0] q_oc_tid[OCN-1:0];
wire [OCA:0]	q_oc_rcount, q_oc_wcount;
wire [OCA:0]	q_oc_ecount_next,q_oc_rcount_next,q_oc_wcount_next;
wire [OCA-1:0]	q_oc_wptr;
wire		q_oc_ready;
wire [OCN-1:0]  q_oc_wfcmp;
wire [OCN-1:0]  q_oc_wfcmp_rsp_ns;
wire [OCN-1:0]  q_oc_wfa_next;
wire [OCN-1:0]  q_oc_wfstr_next;
wire [OCN-1:0]	q_oc_val;
wire [OCN-1:0]	q_oc_valid_in;
wire [OCN-1:0]	q_oc_err;
wire [OCN-1:0]	q_oc_err_in;
wire [OCN-1:0]	q_oc_nc;
wire [OCN-1:0]	q_oc_nc_ns;
wire [OCN-1:0]  q_oc_eob, q_oc_itail, q_oc_atail,  q_oc_otail, q_oc_null,
		q_oc_wfresp, q_oc_wfstr, q_oc_wfdtr, q_oc_wfstp, q_oc_wfa, 
		q_oc_wfdtw, q_oc_wfdtp, q_oc_wfadw, q_oc_wfodr,
		q_oc_wake, q_oc_wake_persist, q_oc_wrap, q_oc_partial, q_oc_line,
                q_oc_wake_persist_alt,
                q_oc_wake_persist_pre,
                q_oc_dve_2nd,
                q_oc_wake_pre,
		q_oc_owned, q_oc_oldest,
		q_oc_oldest_alt,
		q_oc_write, q_oc_dce, q_oc_dval, q_oc_wfstr_at_iptr,q_oc_iptr_eq,q_oc_iptr_eq_next;
wire [OCN-1:0]  q_oc_eob_ns, q_oc_itail_ns, q_oc_atail_ns,  q_oc_otail_ns, q_oc_null_ns,
                q_oc_wfresp_ns, q_oc_wfstr_ns, q_oc_wfdtr_ns, q_oc_wfstp_ns, q_oc_wfa_ns,
                q_oc_wfdtw_ns, q_oc_wfdtp_ns, q_oc_wfadw_ns, q_oc_wfodr_ns,
                q_oc_wake_ns, q_oc_wake_persist_ns, q_oc_wrap_ns, q_oc_partial_ns, q_oc_line_ns,
                q_oc_wake_persist_alt_ns,
                q_oc_wake_persist_local_ns,
                q_oc_dve_2nd_ns,
                q_oc_wake_pre_ns,
                q_oc_write_ns, q_oc_dce_ns, q_oc_dval_ns, q_oc_wfstr_at_iptr_ns;
wire [OCN-1:0]  t_oc_dtp_received;
wire [MRCT-1:0] q_oc_tid_ns[OCN-1:0];
// OWO OTT Fields
wire [OCN-1:0]  t_oc_writeback_phase;
wire [1:0]	t_oc_phase[OCN-1:0];
wire [OCN-1:0]	t_oc_phase_neq_0;
wire [OCN-1:0]	t_oc_waking;
wire [OCN-1:0]  t_oc_owned;
wire [OCN-1:0]  sending_writeback;
wire [OCN-1:0]  sent_writeback;
wire [OCN-1:0]  sending_writeback_alt;
wire [OCN-1:0]  sent_writeback_alt;
wire [OCN-1:0]  t_oc_oldest;
wire [OCN-1:0]  t_oc_owo_wfstp;
wire [OCN-1:0]  t_oc_coh;

wire [OCN-1:0]  q_oc_ext, q_oc_rdone;
wire [OCN-1:0]  q_oc_ext_ns, q_oc_rdone_ns;
wire [2:0]	t_oc_dstate[OCN-1:0];
wire [1:0]	t_oc_aresp[OCN-1:0];
wire [OCN-1:0]	t_oc_wfack;
wire [OCN-1:0]  t_oc_wfack_stp;
wire [OCN-1:0]  q_oc_cmo;
wire [OCN-1:0]  q_oc_cmo_ns;
wire [CWW-1:0]	t_oc_way[OCN-1:0];
wire [SRCB-1:0]	q_oc_bid[OCN-1:0];
wire [SRCB-1:0]	q_oc_bid_ns[OCN-1:0];
wire [7:0]	q_oc_status[OCN-1:0];
wire [7:0]	q_oc_status_update[OCN-1:0];
wire [7:0]	q_oc_status_next[OCN-1:0];
wire [IW-1:0]	q_oc_id[OCN-1:0];
wire [IW-1:0]	q_oc_id_ns[OCN-1:0];
wire [1:0]	t_oc_isize[OCN-1:0];
wire [SRCM-1:0]	q_oc_mid[OCN-1:0];
wire [SRCM-1:0]	q_oc_mid_ns[OCN-1:0];
wire [SRCI-1:0]	q_oc_iid[OCN-1:0];
wire [SRCI-1:0]	q_oc_iid_ns[OCN-1:0];
wire [TINW+1:0]	q_oc_tin[OCN-1:0];
wire [TINW+1:0]	q_oc_tin_ns[OCN-1:0];
wire [TINW+1:0]	q_oc_tin_ns_alt[OCN-1:0];
wire [2:1]	q_oc_order[OCN-1:0];
wire [2:1]	q_oc_order_ns[OCN-1:0];
wire [2:0]	q_oc_size[OCN-1:0];
wire [2:0]	q_oc_size_ns[OCN-1:0];
wire [4:0]	q_oc_beats_adj[OCN-1:0];
wire [BWL-1:0]	q_oc_beats[OCN-1:0];
wire [BWL-1:0]	q_oc_beats_ns[OCN-1:0];
wire [BWL-1:0]	q_oc_beats_shift;
wire [OCA-1:0]  q_oc_iptr_next[OCN-1:0];
wire [OCA-1:0]  q_oc_iptr_next_ns[OCN-1:0];
wire [OCA-1:0]	q_oc_iptr[OCN-1:0], q_oc_aptr[OCN-1:0];
wire [OCA-1:0]	q_oc_iptr_ns[OCN-1:0], q_oc_aptr_ns[OCN-1:0];
wire [OLA-1:0]	q_oc_dptr[OCN-1:0];
wire [OLA-1:0]	q_oc_dptr_ns[OCN-1:0];
wire [AW-1:0]	q_oc_addr[OCN-1:0];
wire [AW-1:0]	q_oc_addr_ns[OCN-1:0];
wire [OCN-1:0]  q_oc_trace;
wire [OCN-1:0]  q_oc_trace_ns;
wire [3:0]	q_oc_cache[OCN-1:0];
wire [3:0]	q_oc_cache_ns[OCN-1:0];
wire [1:0]	t_oc_domain[OCN-1:0];
wire [3:0]	t_oc_snoop[OCN-1:0];
wire [MW-1:0]	t_oc_bar[OCN-1:0];
wire [3:0]	t_oc_vmidext[OCN-1:0];
wire [5:0]	t_oc_atop[OCN-1:0];
wire [OCN-1:0]	t_oc_atop_persist;
wire [OCN-1:0]  t_oc_atop_rw;
wire [SRCM-1:0]	t_oc_mid2[OCN-1:0];
wire [SRCI-1:0]	t_oc_iid2[OCN-1:0];
wire [AWSW-1:0]	t_oc_stashid[OCN-1:0];
wire [SRC2-1:0]	t_oc_stashrid[OCN-1:0];
wire [FIDW-1:0]	t_oc_stashnid[OCN-1:0];
wire [OCN-1:0]	t_oc_stashniden;
\js // kok is qos, credits, and mechanical dependencies are free. dok is just mechanical
wire [OCN-1:0]	t_oc_skid, t_oc_kok, t_oc_dok, t_oc_cok, t_oc_qval, t_oc_agok,
		t_oc_svok, t_oc_catop, t_oc_catope, t_oc_wfatop,t_starve_qual, t_oc_kok_in;
wire [QW-1:0]	q_oc_qos[OCN-1:0];
wire [QW-1:0]	q_oc_qos_ns[OCN-1:0];
wire [QOSW-1:0]	w_oc_qin[OCN-1:0];
wire [QOSN-1:0]	w_oc_qok;
wire [AXUW-1:0]	q_oc_user[OCN-1:0];
wire [AXUW-1:0]	q_oc_user_ns[OCN-1:0];
wire [AXKW-1:0]	t_oc_track[OCN-1:0];
wire           	t_oc_trace[OCN-1:0];
wire [OCN-1:0]	q_oc_security;
wire [OCN-1:0]	q_oc_security_ns;
wire [OCN-1:0]	q_oc_pr;
wire [OCN-1:0]	q_oc_pr_ns;
wire [OCN-1:0]	q_oc_lock;
wire [OCN-1:0]	q_oc_lock_ns;
wire chaining_in_progress_ns;
wire chaining_in_progress;
\js for (let i=0;i<OCN;i++) {
wire q_oc_chain_complete_ns\=i=\;
wire q_oc_chain_complete\=i=\;
wire [\=OCA=\:0] q_oc_ancestor_transfer\=i=\;
wire q_oc_val\=i=\;
wire q_oc_val_lat\=i=\;
assign q_oc_val[\=i=\] = q_oc_val\=i=\;
wire q_oc_err\=i=\;
assign q_oc_err[\=i=\] = q_oc_err\=i=\;
wire q_oc_ext\=i=\;
assign q_oc_ext[\=i=\] = q_oc_ext\=i=\;
wire q_oc_rdone\=i=\;
assign q_oc_rdone[\=i=\] = q_oc_rdone\=i=\;
wire q_oc_wfstr_at_iptr\=i=\;
assign q_oc_wfstr_at_iptr[\=i=\] = q_oc_wfstr_at_iptr\=i=\;
wire q_poc_obv\=i=\;
assign q_poc_obv[\=i=\] = q_poc_obv\=i=\;
wire q_oc_iptr_eq\=i=\;
assign q_oc_iptr_eq[\=i=\] = q_oc_iptr_eq\=i=\;
wire q_oc_wake_pre\=i=\;
assign q_oc_wake_pre[\=i=\] = q_oc_wake_pre\=i=\;
wire q_oc_wake_persist_pre\=i=\;
assign q_oc_wake_persist_pre[\=i=\] = q_oc_wake_persist_pre\=i=\;
wire q_oc_wake_persist_alt\=i=\;
assign q_oc_wake_persist_alt[\=i=\] = q_oc_wake_persist_alt\=i=\;
wire q_oc_wfresp\=i=\;
assign q_oc_wfresp[\=i=\] = q_oc_wfresp\=i=\;
wire q_oc_wfstr\=i=\;
assign q_oc_wfstr[\=i=\] = q_oc_wfstr\=i=\;
wire q_oc_wfadw\=i=\;
assign q_oc_wfadw[\=i=\] = q_oc_wfadw\=i=\;
wire q_oc_wfcmp\=i=\;
assign q_oc_wfcmp[\=i=\] = q_oc_wfcmp\=i=\;
wire q_oc_cmo\=i=\;
assign q_oc_cmo[\=i=\] = q_oc_cmo\=i=\;
wire q_oc_wfdtr\=i=\;
assign q_oc_wfdtr[\=i=\] = q_oc_wfdtr\=i=\;
wire q_oc_wfdtp\=i=\;
assign q_oc_wfdtp[\=i=\] = q_oc_wfdtp\=i=\;
wire q_oc_wfstp\=i=\;
assign q_oc_wfstp[\=i=\] = q_oc_wfstp\=i=\;
wire q_oc_wfdtw\=i=\;
assign q_oc_wfdtw[\=i=\] = q_oc_wfdtw\=i=\;
wire q_oc_wfa\=i=\;
assign q_oc_wfa[\=i=\] = q_oc_wfa\=i=\;
wire q_oc_wfodr\=i=\;
assign q_oc_wfodr[\=i=\] = q_oc_wfodr\=i=\;
wire q_oc_null\=i=\;
assign q_oc_null[\=i=\] = q_oc_null\=i=\;
wire q_oc_write\=i=\;
assign q_oc_write[\=i=\] = q_oc_write\=i=\;
wire q_oc_nc\=i=\;
assign q_oc_nc[\=i=\] = q_oc_nc\=i=\;
wire q_oc_eob\=i=\;
assign q_oc_eob[\=i=\] = q_oc_eob\=i=\;
wire q_oc_security\=i=\;
assign q_oc_security[\=i=\] = q_oc_security\=i=\;
wire q_oc_pr\=i=\;
assign q_oc_pr[\=i=\] = q_oc_pr\=i=\;
wire q_oc_lock\=i=\;
assign q_oc_lock[\=i=\] = q_oc_lock\=i=\;
wire q_oc_wrap\=i=\;
assign q_oc_wrap[\=i=\] = q_oc_wrap\=i=\;
wire q_oc_dve_2nd\=i=\;
assign q_oc_dve_2nd[\=i=\] = q_oc_dve_2nd\=i=\;
wire q_oc_line\=i=\;
assign q_oc_line[\=i=\] = q_oc_line\=i=\;
wire q_oc_dce\=i=\;
assign q_oc_dce[\=i=\] = q_oc_dce\=i=\;
wire [MRCT-1:0] q_oc_tid\=i=\;
assign q_oc_tid[\=i=\] = q_oc_tid\=i=\;
wire q_oc_itail\=i=\;
assign q_oc_itail[\=i=\] = q_oc_itail\=i=\;
wire q_oc_otail\=i=\;
assign q_oc_otail[\=i=\] = q_oc_otail\=i=\;
wire q_oc_atail\=i=\;
assign q_oc_atail[\=i=\] = q_oc_atail\=i=\;
wire q_oc_dval\=i=\;
assign q_oc_dval[\=i=\] = q_oc_dval\=i=\;
wire q_oc_partial\=i=\;
assign q_oc_partial[\=i=\] = q_oc_partial\=i=\;
wire q_oc_trace\=i=\;
assign q_oc_trace[\=i=\] = q_oc_trace\=i=\;

wire [SRCB-1:0] q_oc_bid\=i=\;
wire [7:0]      q_oc_status\=i=\;
wire [IW-1:0]   q_oc_id\=i=\;
wire [SRCM-1:0] q_oc_mid\=i=\;
wire [SRCI-1:0] q_oc_iid\=i=\;
wire [TINW+1:0] q_oc_tin\=i=\;
wire [2:1]      q_oc_order\=i=\;
wire [2:0]      q_oc_size\=i=\;
wire [BWL-1:0]  q_oc_beats\=i=\;
wire [OCA-1:0]  q_oc_iptr\=i=\;
wire [OCA-1:0]  q_oc_aptr\=i=\;
wire [OLA-1:0]  q_oc_dptr\=i=\;
wire [AW-1:0]   q_oc_addr\=i=\;
wire [3:0]      q_oc_cache\=i=\;
wire [QW-1:0]   q_oc_qos\=i=\;
wire [AXUW-1:0] q_oc_user\=i=\;
assign q_oc_bid[\=i=\] = q_oc_bid\=i=\;
assign q_oc_status[\=i=\] = q_oc_status\=i=\;
assign q_oc_id[\=i=\] = q_oc_id\=i=\;
assign q_oc_mid[\=i=\] = q_oc_mid\=i=\;
assign q_oc_iid[\=i=\] = q_oc_iid\=i=\;
assign q_oc_tin[\=i=\] = q_oc_tin\=i=\;
assign q_oc_order[\=i=\] = q_oc_order\=i=\;
assign q_oc_size[\=i=\] = q_oc_size\=i=\;
assign q_oc_beats[\=i=\] = q_oc_beats\=i=\;
assign q_oc_iptr[\=i=\] = q_oc_iptr\=i=\;
assign q_oc_aptr[\=i=\] = q_oc_aptr\=i=\;
assign q_oc_dptr[\=i=\] = q_oc_dptr\=i=\;
assign q_oc_addr[\=i=\] = q_oc_addr\=i=\;
assign q_oc_cache[\=i=\] = q_oc_cache\=i=\;
assign q_oc_qos[\=i=\] = q_oc_qos\=i=\;
assign q_oc_user[\=i=\] = q_oc_user\=i=\;
\js }
wire [OLA-1:0]	q_od_wptr;
wire [OCN-1:0]	q_od_wptr_vec;
wire		q_od_ready;
wire [OLN-1:0]	q_od_val, q_od_busy;
wire [BWL-1:0]	q_srd_count;
wire [BWL-1:0]	q_odr_count;
wire [BWL-1:0]  q_odf_count;
wire [BWL:0]	q_odr_count_p1;
wire [BWL-1:0]  q_odr_count_next;
wire		q_srd_bypass;
wire [OCA-1:0]	q_srd_oid;
wire [1:0]	q_do_last;
wire [7:0]	q_cmd_req_count;
wire [7:0]	q_dtr_req_tx_count;
wire [7:0]	q_dtw_req_count;
wire [7:0]	q_upd_req_count;
wire [3:0]	t_pvc_count;

wire [AW-1:0]	q_st_addr[STN-1:0];
wire [STN-1:0]	q_st_val;
wire [STN-1:0]	q_st_ns;

\js if (STE) {
wire		w_st_ready;
wire [STA-1:0]	w_st_sid, w_st_nid, w_st_fid;
wire [STN-1:0]	t_st_done, w_st_dbv, t_st_wake, t_st_alloc, t_st_hits;
wire [STN-1:0]	t_st_done_qual;
\jsbegin
// always enabled on 3.6
/* istanbul ignore else env ncore_3p6,ncore_3p7 */
    if (useEarlyDtr) { \jsend
wire [STN-1:0]	t_st_fini;
\js }
wire [STN-1:0]	t_st_val, t_st_wfdrp, t_st_wfdwp, t_st_wfac, t_st_wfcr,
		t_st_wfcmp,
		t_st_chit, t_st_sleep, t_st_pr, t_st_security, t_st_trace;
wire [1:0]	t_st_isize[STN-1:0], t_st_up[STN-1:0];
wire [AW-1:0]	t_st_addr[STN-1:0];
wire [7:0]	t_st_cmd[STN-1:0];
wire [SRCI-1:0]	t_st_iid[STN-1:0];
wire [SRNP-1:0]	t_st_pri[STN-1:0];
wire [SRCM-1:0]	t_st_mid[STN-1:0];
wire [SRCB-1:0]	t_st_bid[STN-1:0];
wire [SRNF-1:0]	t_st_tof[STN-1:0];
wire [SRND-1:0]	t_st_sdid[STN-1:0];
wire [SRN1-1:0]	t_st_mpf1[STN-1:0];
wire [SRN2-1:0]	t_st_stid[STN-1:0];
wire [SRN3-1:0]	t_st_mpf3[STN-1:0];
wire [STA-1:0]	t_st_ptr[STN-1:0];
wire [2:0]	t_st_cstate[STN-1:0];
wire [STN-1:0]	t_st_tag_uce;
wire [STN-1:0]	t_st_status;
wire [STA:0]	t_st_count;
wire		t_dvm_state;
wire		w_ac_ready;
wire		n_ac_valid;
wire [STN-1:0]	t_st_ac;
wire [STN-1:0]	t_st_ac_alt;
wire [STA-1:0]	n_ac_sid;
wire [STN-1:0]	n_ac_sbv;
wire [STA-1:0]			w_crq_sid,	w_cmq_sid;
wire		w_cdq_ready,	n_cdq_ready,	n_cmq_ready;
wire				w_cdq_valid,	w_cmq_valid;
wire [STA-1:0]			w_cdq_sid;
wire [OCA-1:0]			t_cdq_sid;
wire [DWP-1:0]			t_cdq_poison;
wire		t_crs_valid, t_cro_valid;
wire [4:0]	t_cr_resp;
wire [OCA-1:0]	w_crq_oid;
wire		w_cr_wu, w_cr_is, w_cr_pd, w_cr_error, w_cr_dt;
wire [STN-1:0]	t_st_wu, t_st_is, t_st_pd, t_st_error, t_st_dt; // ACE response bits.
wire		n_cd_ready;
wire		w_cd_valid, t_cd_valid;
wire		w_cd_last;
wire [CDW-1:0]	w_cd_data;
wire [CDWP-1:0]	w_cd_poison;
wire [DWP-1:0]  w_cd_poison_qual;
\js } // STE

wire            halt_dtr_rsp_id_clear;

wire                          age_fifo_push;
wire [\=OCN-1=\:0]            age_fifo_initvec;
wire [\=OCN-1=\:0]            age_arb_grant_vec;
wire [\=wOCN-1=\:0]           age_fifo_grant_index;
wire [\=OCN-1=\:0]            age_fifo_pop_vector;
wire [\=wOCN-1=\:0]           age_fifo_pop_index;
wire [\=wOCN-1=\:0]           age_fifo_dealloc_index;
wire                          age_fifo_dealloc_valid;
wire [\=OCN-1=\:0]            age_fifo_dealloc_vector;
wire [\=OCN-1=\:0]            age_arb_req_vec;
wire                          age_arb_empty;
wire                          age_arb_full;
wire [\=ageBuffEntries-1=\:0] age_arb_valid_vec;
wire                          age_fifo_pop;
wire                          age_grant_ack;
wire                          grant_nc;

wire [\=OCN-1=\:0]            dealloc_collect;
wire [\=OCN-1=\:0]            dealloc_collect_in;

wire [OCN-1:0]                wakeup_ok;
wire                          non_coh_ex;

wire                          dce_mru;

wire [XTA-1:0] pt_iptr;

wire extra_beat;

\js //============================================================================
\js // Clock Gate Native Layer FIFOs Locally
\js //============================================================================

wire aw_clk, ar_clk, w_clk;
wire aw_clk_en, ar_clk_en, w_clk_en;

\js if (CGE) {

\=obj.lib.instance ({
	moduleName: 'cg',
	instanceName: 'clk_i_cg',
	params: {width: 1},
	verilogParams: {},
	ports: {
		clk_in:		'clk_i_ng',
		clk_out:	'clk_i',
		test_en:	'test_en_i',
		en:		'clk_en'
	},
	portsDelimiter: '\n\t'
})=\
\js } else {
    assign clk_i = clk_i_ng;
\js }

\js if (CGE) {
    assign aw_clk_en = aw_valid_i | w_w0_valid;

\=obj.lib.instance ({
	moduleName: 'cg',
	instanceName: 'aw_cg',
	params: {width: 1},
	verilogParams: {},
	ports: {
		clk_in:		'clk_i_ng',
		clk_out:	'aw_clk',
		test_en:	'test_en_i',
		en:		'aw_clk_en'
	},
	portsDelimiter: '\n\t'
})=\
\js } else {
    assign aw_clk = clk_i_ng;
\js }

\js if (CGE) {
assign ar_clk_en = ar_valid_i | w_p0r_valid;

\=obj.lib.instance ({
	moduleName: 'cg',
	instanceName: 'ar_cg',
	params: {width: 1},
	verilogParams: {},
	ports: {
		clk_in:		'clk_i_ng',
		clk_out:	'ar_clk',
		test_en:	'test_en_i',
		en:		'ar_clk_en'
	},
	portsDelimiter: '\n\t'
})=\
\js } else {
assign ar_clk = clk_i_ng;
\js }

\js if (CGE) {
assign w_clk_en = dw_valid_i | w_dw_valid;

\=obj.lib.instance ({
	moduleName: 'cg',
	instanceName: 'w_cg',
	params: {width: 1},
	verilogParams: {},
	ports: {
		clk_in:		'clk_i_ng',
		clk_out:	'w_clk',
		test_en:	'test_en_i',
		en:		'w_clk_en'
	},
	portsDelimiter: '\n\t'
})=\
\js } else {
assign w_clk = clk_i_ng;
\js }

\js //============================================================================
\js // Extra Write Credit Used Indication Per Target
\js //============================================================================

\js // Generate signals indicating whether there is a write outstanding to each target. If there is then that is considered the extra write credit.
localparam MAX_TARGET_ID = \=Math.max(nDCEs,nDMIs,nDIIs)=\;

wire [OCN-1:0]	outstanding_write_vector;
wire [OCN-1:0]	outstanding_read_vector;
wire            outstanding_read;

wire [OCN-1:0]	to_dmi_vector;
wire [OCN-1:0]	to_dii_vector;
wire [OCN-1:0]	to_dce_vector;

wire [OCN*MAX_TARGET_ID-1:0] target_id_match_vec;

\=u.instance({
        portsDelimiter: '\n    ',
        instanceName: 'u_outstanding_read',
        moduleName:   'logic_tree',
        params: {
          'width' : OCN,
          'logic' : '|'},
        ports: {
          'din'  : 'outstanding_read_vector',
          'dout' : 'outstanding_read'}})=\

\js // Generate match vectors indicating whether an entry goes to a dii,dce, or dmi and also a 2d vector indicating which target id to go to.
     assign outstanding_write_vector = q_oc_val &  q_oc_write & ~q_oc_wfresp;
     assign outstanding_read_vector  = q_oc_val & ~q_oc_write & ~q_oc_wfresp;

\js for (let i=0; i<OCN; i=i+1) {
     assign to_dmi_vector[\=i=\] = q_oc_tin[\=i=\][TINW];
     assign to_dii_vector[\=i=\] = q_oc_tin[\=i=\][TINW+1];
     assign to_dce_vector[\=i=\] = ~| q_oc_tin[\=i=\][TINW+1-:2];

\js   for (let x=0; x<Math.max(nDMIs,nDCEs,nDIIs); x=x+1) {
         assign target_id_match_vec[\=(x*OCN) + i=\] = (q_oc_tin[\=i=\][0+:TINW] == \=ioaiu_pos(log2ceil(Math.max(nDMIs,nDCEs,nDIIs)))=\'d\=x=\);
\js   }
\js }

\js // For each DMI Target Generate an outstanding write vector.
\js for (let x=0; x<nDMIs; x=x+1) {
     wire [OCN-1:0] dmi_entry_match_vec\=x=\;
     wire           dmi_entry_match\=x=\;
     
\js  for (let i=0; i<OCN; i=i+1) {
         assign dmi_entry_match_vec\=x=\[\=i=\] = outstanding_write_vector[\=i=\] & to_dmi_vector[\=i=\] & target_id_match_vec[\=(x*OCN) + i=\];
\js  }

     \=u.instance({
        portsDelimiter: '\n    ',
        instanceName: 'u_entry_match_write_dmi'+x,
        moduleName:   'logic_tree',
        params: {
          'width' : OCN,
          'logic' : '|'},
        ports: {
          'din'  : 'dmi_entry_match_vec'+x,
          'dout' : 'dmi_entry_match'+x}})=\

     assign w_dmi_sp_write_used[\=x=\] = dmi_entry_match\=x=\;
\js }

\js // For each DII Target Generate an outstanding write vector.
\js for (let x=0; x<nDIIs; x=x+1) {
     wire [OCN-1:0] dii_entry_match_vec\=x=\;
     wire           dii_entry_match\=x=\;
     
\js    for (let i=0; i<OCN; i=i+1) {
         assign dii_entry_match_vec\=x=\[\=i=\] = outstanding_write_vector[\=i=\] & to_dii_vector[\=i=\] & target_id_match_vec[\=(x*OCN) + i=\]; 
\js    }
 
     \=u.instance({
        portsDelimiter: '\n    ',
        instanceName: 'u_entry_match_write_dii'+x,
        moduleName:   'logic_tree',
        params: {
          'width' : OCN,
          'logic' : '|'},
        ports: {
          'din'  : 'dii_entry_match_vec'+x,
          'dout' : 'dii_entry_match'+x}})=\
     
     assign w_dii_sp_write_used[\=x=\] = dii_entry_match\=x=\;
\js }

\js // For each DCE Target Generate an outstanding write vector.
\js for (let x=0; x<nDCEs; x=x+1) {
     wire [OCN-1:0] dce_entry_match_vec\=x=\;
     wire           dce_entry_match\=x=\;
     
\js    for (let i=0; i<OCN; i=i+1) {
         assign dce_entry_match_vec\=x=\[\=i=\] = outstanding_write_vector[\=i=\] & to_dce_vector[\=i=\] & target_id_match_vec[\=(x*OCN) + i=\];
\js    }

     \=u.instance({
        portsDelimiter: '\n    ',
        instanceName: 'u_entry_match_write_dce'+x,
        moduleName:   'logic_tree',
        params: {
          'width' : OCN,
          'logic' : '|'},
        ports: {
          'din'  : 'dce_entry_match_vec'+x,
          'dout' : 'dce_entry_match'+x}})=\

     assign w_dce_sp_write_used[\=x=\] = dce_entry_match\=x=\;
\js }

\js //============================================================================
\js // Starvation Special Write Wakeup
\js //============================================================================

\js // Mask out every transaction, unless its a write to a target which doesnt have its extra credit used.
\js // This will allow writes to trickle through in Starvation Mode.

wire [OCN-1:0]	special_write_wakeup;
wire [OCN-1:0]	special_write_nused;
wire [OCN-1:0]	special_write_mask;

wire            special_write_avail;
wire            ioaiu_outstanding_write_used;

\=u.instance({
        portsDelimiter: '\n    ',
        instanceName: 'u_outstanding_write',
        moduleName:   'logic_tree',
        params: {
          'width' : OCN,
          'logic' : '|'},
        ports: {
          'din'  : 'outstanding_write_vector',
          'dout' : 'ioaiu_outstanding_write_used'}})=\

\=u.instance({
        portsDelimiter: '\n    ',
        instanceName: 'u_entry_special_write_avail',
        moduleName:   'logic_tree',
        params: {
          'width' : OCN,
          'logic' : '|'},
        ports: {
          'din'  : 'special_write_wakeup',
          'dout' : 'special_write_avail'}})=\

         assign special_write_mask = ~outstanding_write_vector;

\js //============================================================================
\js // Perf Monitor: Address Collision
\js //============================================================================

wire pmon_address_collision_in = {|{addr_match}} & ~w_pt_wake & w_pt_valid & n_pt_ready;

\=u.dffre(1, `pmon_address_collision`, `pmon_address_collision_in`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\

\js if (ACE) {
wire t_crq_valid;
\js }

assign ccp_init_o = ~q_reset_n;
assign idle_o = (q_reset_n | (~| q_init_count)) &
\js if (ACE) {
                ~t_crq_valid &
\js }
		w_dce_idle & w_dmi_idle & w_dii_idle & w_dve_idle & w_qos_idle &
		(~| q_oc_rcount) & (~| q_oc_wcount) & (~| t_oc_ecount) &
\js if (STE) {
		(~| t_st_val) &
\js }
                ccp_ready_i &
		~w_p0r_valid & ~w_rb_valid & 
		~w_p0w_valid & ~w_wb_valid & ~w_dw_valid & 
		~w_dr0_valid & ~w_dr1_valid & ~w_do_valid &
		~w_w0_valid & ~w_w1_valid & ~w_w2_valid & ~pw_valid_o & ~ac_valid_o &
		~w_p1_valid & ~w_p2_valid & ~w_rr_valid &
		~w_cmd_rsp_valid & ~w_dtr_rsp_rx_valid & ~w_dtw_rsp_valid & ~w_upd_rsp_valid &
		~w_snp_req_valid & ~w_snp_rsp0_valid & ~w_snp_rsp1_valid &
		~w_str_rsp0_valid & ~w_str_rsp1_valid &
		~w_dtr_rsp_tx_valid & ~w_dtr_rsp_tx1_valid;

assign ctar_o = {(| (q_oc_val & t_oc_wfcft)),
		 (| (q_oc_val & (t_oc_evict | t_oc_wrbk)))};

assign dw_ready_o = q_reset_n & w_dw_ready;
assign n_dw_valid = q_reset_n & dw_valid_i;

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'dw',
	params: {
                depth:          P0D,
		width:		1+WDUW+1+BW+DW+DWP,
                pipeForward:    (P0T==1)? /* istanbul ignore next env ncore_3p7 */"no" : "yes",
                pipeBackward:   (P0T==0)? /* istanbul ignore next env ncore_3p7 */"no" : "yes",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'w_clk',
		reset_n:	'reset_ni',
		in_ready:	'w_dw_ready',
		in_valid:	'n_dw_valid',
		in_data:	`{dw_poison_i,dw_trace_i, dw_user_i, 
				  dw_last_i, dw_be_i, dw_wdata_i}`,
		out_ready:	'n_dw_ready',
		out_valid:	'w_dw_valid_pre',
		out_data:	`{w_adw_poison, w_adw_trace, w_adw_user,
				  w_adw_last, w_adw_be, w_adw_wdata}`
	},
	portsDelimiter: '\n\t'
})=\

assign w_dw_valid = w_dw_valid_pre | (w_aw_valid & w_w1_bar[0]);

\=u.instance({
	moduleName: 'ioaiu_combine',
	instanceName: 'adw',
	params: {
                 clkAssertInterface : clkAssertInterface,
                 DW:             2,
                 assertOn : assertOn
        },
	ports: {
		ready_o:	'{t_aw_ready, n_dw_ready}',
		valid_i:	'{w_aw_valid, w_dw_valid}',
		ready_i:	'n_adw_ready',
		valid_o:	'w_adw_valid'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

assign t_adw_waddr = {w_w1_dptr, t_w1_offset};
\js for (let j=0; j<(axiParams.wData/8); j=j+1) {
    assign t_adw_wdata[\=j*8=\ +: 8] = w_adw_wdata[\=j*8=\ +: 8];
\js }
assign t_adw_poison = w_adw_poison;

\=u.instance({
	moduleName: 'ioaiu_arbiter',
	instanceName: 'ocpw',
	params: {
                DRST:           DRST,
                DW:             OCN,
                ATOMIC:         0,
                HP:             `{`+OCN+`{1'b0}}`,
                VAL:            1,
		 assertOn: assertOn
	},
	ports: {
		clk_i:		'clk_i',
		reset_ni:	'reset_ni',
		ready_i:	'w_pw0_ready',
		bv_i:		't_oc_wdone',
		lv_i:		`{OCN{1'b1}}`,
		winner_o:	'n_pw0_oid',
		wbv_o:		'n_pw0_obv'
	},
	portsDelimiter: '\n\t'
})=\

assign n_pw_oid = w_pw0_oid;
assign n_pw_track = t_oc_track[n_pw_oid];
\jsbegin
// BUser unused in 3.7
/* istanbul ignore if env ncore_3p7 */
    if (axiParams.wBUser>Math.max(axiParams.wArUser,axiParams.wAwUser)) { \jsend
	assign n_pw_user = {{\=ioaiu_pos(BUW-AXUW)=\{1'b0}}, q_oc_user[n_pw_oid]};
\js } else {
	assign n_pw_user = q_oc_user[n_pw_oid][BUW-1:0];
\js }

assign n_pw_id = q_oc_id[n_pw_oid];
assign n_pw_resp = {(q_oc_val[n_pw_oid] & q_oc_status[n_pw_oid][7]), ((q_oc_val[n_pw_oid] & ((q_oc_status[n_pw_oid]==8'h84)|(q_oc_status[n_pw_oid]==8'h87))) |
					       (q_oc_lock[n_pw_oid] & ~q_oc_status[n_pw_oid][7]))};

\=u.instance({
	moduleName: 'ioaiu_demux',
	instanceName: 'pw_split',
	params: {
		NUM:		2,
		DW:		1,
                NO_DATA_OUT:    1,
                clkAssertInterface : clkAssertInterface,
                assertOn : assertOn
        },
	verilogParams: {
	},
	ports: {
		ready_o:	'n_pw0_ready',
		valid_i:	'w_pw0_valid',
		data_i:		`1'b0`,
		ready_i:	'{w_wkq_ready,  w_pw_ready}',
		valid_o:	'{n_wkq_valid,  n_pw_valid}',
		bvsel_i:	`2'h3`
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'pw',
	params: {
                depth:          2,
		width:		AXKW+BUW+IW+2,
                pipeForward:    "yes",
                pipeBackward:   "yes",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_pw_ready',
		in_valid:	'n_pw_valid',
		in_data:	'{n_pw_track, n_pw_user, n_pw_id, n_pw_resp}',
		out_ready:	'pw_ready_i',
		out_valid:	'pw_valid_o',
		out_data:	'{pw_track_o, pw_user_o, pw_id_o, pw_resp_o}'
	},
	portsDelimiter: '\n\t'
})=\

assign ar_ready_o = q_reset_n & w_p0r_ready;
assign n_p0r_valid = q_reset_n & ar_valid_i;
\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'p0r',
	params: {
                depth:          P0D,
		width:		AXW+4,
                pipeForward:    (P0T==1)? /* istanbul ignore next env ncore_3p7 */"no" : "yes",
                pipeBackward:   (P0T==0)? /* istanbul ignore next env ncore_3p7 */"no" : "yes",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'ar_clk',
		reset_n:	'reset_ni',
		in_ready:	'w_p0r_ready',
		in_valid:	'n_p0r_valid',
		in_data:	`{ar_track_i, ar_user_i, ar_domain_i, 
                                  ar_vmidext_i,
				  ar_snoop_i, ar_bar_i, ar_id_i, ar_qos_i, 
				  ar_region_i, ar_prot_i, ar_cache_i, 
				  ar_lock_i, ar_burst_i, ar_size_i,
				  ar_len_i, ar_addr_i}`,
		out_ready:	'n_p0r_ready',
		out_valid:	'w_p0r_valid',
		out_data:	`{w_p0r_track, w_p0r_user, w_p0r_domain, 
                                  w_p0r_vmidext,
				  w_p0r_snoop, w_p0r_bar, w_p0r_id, w_p0r_qos, 
				  w_p0r_region, w_p0r_prot, w_p0r_cache, 
				  w_p0r_lock, w_p0r_burst, w_p0r_size, 
				  w_p0r_len, w_p0r_addr}`
	},
	portsDelimiter: '\n\t'
})=\

assign n_rb_count = (~((w_p0r_burst==2'h2) & (w_p0r_len < 8'd\=BPL=\)) &
		     w_p0r_valid & n_p0r_ready) ? (({{8-AWL{1'b0}},w_p0r_len} + 
						 {{16-AWL-BWL{1'b0}},w_p0r_addr[AWL+:BWL]}) >> BWL) :
		    (w_rb_valid & n_rb_ready) ? w_rb_count - 1'b1 :
		     w_rb_valid ? w_rb_count :
				  {16-AWL{1'b0}};

wire [1:0] p0r_burst_modified_alt = (|n_rb_count) ? 2'h1 : w_p0r_burst; // Force all multilin TXNs to be INCR
wire       p0r_multiline          = ~((w_p0r_burst==2'h2) & (w_p0r_len < 8'd\=BPL=\)) &
                                     |(({{8-AWL{1'b0}},w_p0r_len} + {{16-AWL-BWL{1'b0}},w_p0r_addr[AWL+:BWL]}) >> BWL);
assign     p0r_burst_modified     = p0r_multiline ? 2'h1 : w_p0r_burst;

assign aw_ready_o = q_reset_n & w_w0_ready;
assign n_w0_valid = q_reset_n & aw_valid_i;

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'w0',
	params: {
                depth:          P0D,
		width:		AXW+AWTW+AWSW,
                pipeForward:    (P0T==1)? /* istanbul ignore next env ncore_3p7 */"no" : "yes",
                pipeBackward:   (P0T==0)? /* istanbul ignore next env ncore_3p7 */"no" : "yes",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'aw_clk',
		reset_n:	'reset_ni',
		in_ready:	'w_w0_ready',
		in_valid:	'n_w0_valid',
		in_data:	`{aw_track_i, aw_user_i, aw_domain_i, 
				  aw_snoop_i, aw_bar_i, aw_id_i, aw_qos_i, 
				  aw_region_i, aw_prot_i, aw_cache_i, 
				  aw_lock_i, aw_burst_i, aw_size_i, 
				  aw_len_i, aw_addr_i, aw_atop_i, 
				  aw_stashid_i}`,
		out_ready:	'n_w0_ready',
		out_valid:	'w_w0_valid',
		out_data:	`{w_w0_track, w_w0_user, w_w0_domain, 
				  w_w0_snoop, w_w0_bar, w_w0_id, w_w0_qos, 
				  w_w0_region, w_w0_prot, w_w0_cache, 
				  w_w0_lock, w_w0_burst, w_w0_size, 
				  w_w0_len, w_w0_addr, w_w0_atop, 
				  w_w0_stashid}`
	},
	portsDelimiter: '\n\t'
})=\

assign w_w0_burst_post = (|n_wb_count) ? 2'h1 : w_w0_burst; // Force INCR if it needs to be split.

assign n_wb_count = (~((w_w0_burst==2'h2) & (w_w0_len < 8'd\=BPL=\)) &
		     w_w0_valid & n_w0_ready) ? (({{8-AWL{1'b0}},w_w0_len} + 
						 {{16-AWL-BWL{1'b0}},w_w0_addr[AWL+:BWL]}) >> BWL) :
		    (w_wb_valid & n_wb_ready) ? w_wb_count - 1'b1 :
		     w_wb_valid ? w_wb_count :
				  {16-AWL{1'b0}};

\=u.instance({
	moduleName: 'ioaiu_mux',
	instanceName: 'w0_mux',
	params: {
                                NUM : 2,
		                DW : AXW+AWTW+AWSW,
                                clkAssertInterface : clkAssertInterface,
				assertOn: assertOn
	},
	verilogParams: {
	},
	ports: {
		ready_o:	'{n_wb_ready, n_w0_ready}',
		valid_i:	'{w_wb_valid, w_w0_valid}',
		data_i:		`{{w_wb_track, w_wb_user, w_wb_domain, 
				   w_wb_snoop, w_wb_bar, w_wb_id, w_wb_qos, 
				   w_wb_region, w_wb_prot, w_wb_cache, 
				   w_wb_lock, 2'h1 , w_wb_size, 
				   w_wb_len, w_wb_addr, {AWTW{1'b0}}, 
				   {AWSW{1'b0}}}, 
				  {w_w0_track, w_w0_user, w_w0_domain, 
				   w_w0_snoop, w_w0_bar, w_w0_id, w_w0_qos, 
				   w_w0_region, w_w0_prot, w_w0_cache, 
				   w_w0_lock, w_w0_burst_post, w_w0_size, 
				   w_w0_len, w_w0_addr, w_w0_atop,
				   w_w0_stashid}}`,
		ready_i:	'w_w1_ready',
		valid_o:	'n_w1_valid_raw',
		data_o:		`{n_w1_track, n_w1_user, n_w1_domain, 
				  n_w1_snoop, n_w1_bar, n_w1_id, n_w1_qos, 
				  n_w1_region, n_w1_prot, n_w1_cache, 
				  n_w1_lock, n_w1_burst, n_w1_size, 
				  n_w1_len, n_w1_addr, n_w1_atop, 
				  n_w1_stashid}`,
		bvsel_i:	't_w0_sel'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\
assign t_w0_sel = w_wb_valid ? 2'h2 : 2'h1;

\js // CONC-9521
wire t_od_wready;

\js // CONC-10769
\js // t_od_we prevents write data od entry being allocated same cycle as a read od entry at the end of the pipe.
\js // If this would occur the clocked in ptr and the next_ptr would be used and the next_ptr is clocked in.
\js // This means the next time the clocked ptr is used it will overwrite data.

wire t_od_one_free = ~n_od_ready & q_od_ready & n_w1_valid_raw & w_w1_ready_raw & w_p0r_valid & n_cmd_req0_ready & (t_oc_count == \=OCA+1=\'d\=(OCN-2-1-(W2EN>0)-(P1EN>0)-(useCache>0)-(useCache>0))=\);
assign {w_w1_ready, n_w1_valid} = {w_w1_ready_raw, n_w1_valid_raw} & 
		    {2{~t_od_we & t_od_wready & (q_od_ready & ~t_od_one_free & (((OCN>5) & (t_oc_count < \=OCA+1=\'d\=(OCN-2-(W2EN>0)-(P1EN>0)-(useCache>0)-(useCache>0))=\)) |
				                                                (((~| q_oc_wcount) | (t_oc_count<\=OCA+1=\'d\=(OCN-3)=\)) & ~w_w1_valid & (~w_w2_valid | (1'b\=W2EN=\==1'b0)) & ~w_p0w_valid & (~w_p1_valid | (1'b\=P1EN=\==1'b0)) & ~w_pt_valid)
                                                                               )
                                                )}};

assign n_w1_dptr         = ~w_pt_valid ? q_od_wptr : w_od_dptr;
assign n_w1_dptr_vec     = ~w_pt_valid ? q_od_wptr_vec : w_od_dptr_vec;
assign t_od_wready       = ~w_pt_valid ?      1'b1 : w_od_wready;

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'w1',
	params: {
                depth:          1,
		width:		AXW+AWTW+AWSW+OLA,
                pipeForward:    "yes",
                pipeBackward:   "no",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_w1_ready_raw',
		in_valid:	'n_w1_valid',
		in_data:	`{n_w1_track, n_w1_user, n_w1_domain, 
				  n_w1_snoop, n_w1_bar, n_w1_id, n_w1_qos, 
				  n_w1_region, n_w1_prot, n_w1_cache, 
				  n_w1_lock, n_w1_burst, n_w1_size, 
				  n_w1_len, n_w1_addr, n_w1_atop, 
				  n_w1_stashid, n_w1_dptr}`,
		out_ready:	'n_w1_ready',
		out_valid:	'w_w1_valid',
		out_data:	`{w_w1_track, w_w1_user, w_w1_domain[MW-1:0], 
				  w_w1_snoop[SW-1:0], w_w1_bar, w_w1_id, w_w1_qos, 
				  w_w1_region, w_w1_prot, w_w1_cache, 
				  w_w1_lock, w_w1_burst, w_w1_size, 
				  w_w1_len, w_w1_addr, w_w1_atop, 
				  w_w1_stashid, w_w1_dptr}`
	},
	portsDelimiter: '\n\t'
})=\
\js if ((axiParams.eDomain?1:0)==0) {
assign w_w1_domain[1] = 1'b0;
assign w_w1_snoop[3:1] = 3'b0;
\js }

assign t_w1_track = w_w1_track | (w_adw_trace & w_dw_valid);
assign t_w1_partial = (| q_w1_beats) ? q_w1_partial | ((~& w_adw_be) & w_dw_valid) :  
				       ((~& w_adw_be) & w_dw_valid);
assign t_w1_end = ((t_w1_beats-1'b1) == {1'b0,q_w1_beats});
\js // FIXME Spyglass W164a : The addition causes an extra bit for the left side to take.
wire t_w1_offset_carry;
assign {t_w1_offset_carry,t_w1_offset} = {1'b0,w_w1_addr[CLO-1:AWL]} + {1'b0,q_w1_beats};
assign t_w1_stash = (w_w1_snoop==4'hc) | (w_w1_snoop==4'hd);

assign n_aw_ready = t_aw_ready & t_w1_end;
\js //assign n_aw_ready = n_w2_valid & t_w1_end & n_adw_ready; // fix for comboloop

assign n_w1_ready = ((w_w2_ready | ~t_w1_sel[1]) & (n_aw_ready | ~t_w1_sel[0])) & (t_w1_sel[1] | t_w1_sel[0]);
assign n_w2_valid = w_w1_valid & (n_aw_ready | ~t_w1_sel[0]) & t_w1_sel[1];
assign w_aw_valid = w_w1_valid & (w_w2_ready | ~t_w1_sel[1]) & t_w1_sel[0];

assign t_w1_sel = (w_w1_valid & ((~w_w1_bar[0] &	//Evict
				  ((w_w1_domain==2'h1) | (w_w1_domain==2'h2)) &
				  (w_w1_snoop==4'h4)) |
				  t_w1_stash)) ? 2'h2 : 2'h3;

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'w2',
	params: {
                depth:          1,
		width:		AXW+AWTW+AWSW+OLA+1,
                pipeForward:    "yes",
                pipeBackward:   "no",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_w2_ready',
		in_valid:	'n_w2_valid',
		in_data:	`{t_w1_track, w_w1_user, w_w1_domain[MW-1:0], 
				  w_w1_snoop[SW-1:0], w_w1_bar, w_w1_id, w_w1_qos, 
				  w_w1_region, w_w1_prot, w_w1_cache, 
				  w_w1_lock, w_w1_burst, w_w1_size, 
				  w_w1_len, w_w1_addr, w_w1_atop, 
				  w_w1_stashid, w_w1_dptr, t_w1_partial}`,
		out_ready:	'n_w2_ready',
		out_valid:	'w_w2_valid',
		out_data:	`{w_w2_track, w_w2_user, w_w2_domain, 
				  w_w2_snoop, w_w2_bar, w_w2_id, w_w2_qos, 
				  w_w2_region, w_w2_prot, w_w2_cache, 
				  w_w2_lock, w_w2_burst, w_w2_size, 
				  w_w2_len, w_w2_addr, w_w2_atop,
				  w_w2_stashid, w_w2_dptr, w_w2_partial}`
	},
	portsDelimiter: '\n\t'
})=\

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'p0w',
	params: {
                depth:          1,
		width:		AXW+AWTW+AWSW+OLA+1,
                pipeForward:    "no",
                pipeBackward:   "yes",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'n_w2_ready',
		in_valid:	'w_w2_valid',
		in_data:	`{w_w2_track, w_w2_user, w_w2_domain, 
				  w_w2_snoop, w_w2_bar, w_w2_id, w_w2_qos, 
				  w_w2_region, w_w2_prot, w_w2_cache, 
				  w_w2_lock, w_w2_burst, w_w2_size, 
				  w_w2_len, w_w2_addr, w_w2_atop, 
				  w_w2_stashid, w_w2_dptr, w_w2_partial}`,
		out_ready:	'n_p0w_ready',
		out_valid:	'w_p0w_valid',
		out_data:	`{w_p0w_track, w_p0w_user, w_p0w_domain, 
				  w_p0w_snoop, w_p0w_bar, w_p0w_id, w_p0w_qos, 
				  w_p0w_region, w_p0w_prot, w_p0w_cache, 
				  w_p0w_lock, w_p0w_burst, w_p0w_size, 
				  w_p0w_len, w_p0w_addr, w_p0w_atop,
				  w_p0w_stashid, w_p0w_dptr, w_p0w_partial}`
	},
	portsDelimiter: '\n\t'
})=\

assign t_p0w_update = 1'b0;

wire [AXUW-1:0] poc_user =
\js if ((axiParams.wArUser+axiParams.wAwUser)>0) {
                  q_oc_user[w_poc_oid];
\js } else {
                  1'b0;
\js }


\jsbegin
const p0_mux_snp_str = STE ?
                         `{t_st_up[w_st_sid], upmatch[w_st_sid], {AXKW{1'b0}} | t_st_trace[w_st_sid],
                           {AXUW{1'b0}}, // user
                           {MW{1'b0}},  // w_wb_domain,
                           {SW{1'b0}},  // w_wb_snoop,
                           4'b0,
                           {MW{1'b0}},  //  w_wb_bar,
                           {IW{1'b0}},  //  id
                           {QW{1'b0}},  //  | w_snp_req_urgency :
                           {RW{1'b0}},  // w_wb_region,
                           {1'b0, t_st_security[w_st_sid], t_st_pr[w_st_sid]},
                           4'h0,        // w_wb_cache,
                           1'b0,        // w_wb_lock,
                           2'h0,        // w_wb_burst,
                           3'h0,        // w_wb_size,
                           8'h0,        // w_wb_len,
                           t_st_addr[w_st_sid], {AWTW{1'b0}}, {AWSW{1'b0}},
                         `+((XTA>STA)?`{{XTA-STA{1'b0}},w_st_sid}`:`w_st_sid`)+`, 1'b0, 1'b0, 2'h0, 1'b0,1'b0, 1'b1},` : `{`+PXW+`+1+1+2+1+4{1'b0}},`;
\jsend


\=u.instance({
	moduleName: 'ioaiu_mux',
	instanceName: 'p0_mux',
	params: {
		NUM:		'6',
		DW:		PXW+1+1+2+1+4,
                clkAssertInterface : clkAssertInterface,
				assertOn: assertOn
	},
	verilogParams: {
	},
	ports: {
	ready_o:	`{n_rr_ready, w_srs_ready,
			  n_poc_ready, n_rb_ready, n_p0w_ready, n_p0r_ready}`,
	valid_i:	`{w_rr_valid, n_srs_valid,
			  w_poc_valid, w_rb_valid, w_p0w_valid, w_p0r_valid}`,
	data_i:		`{//Retry
			  {w_rr_up, w_rr_upmatch, w_rr_track, w_rr_user, w_rr_domain, w_rr_snoop, 
                           w_rr_vmidext,
			   w_rr_bar, w_rr_id, w_rr_qos, w_rr_region, w_rr_prot,
			   w_rr_cache, w_rr_lock, w_rr_burst, w_rr_size,
			   w_rr_len, w_rr_addr, w_rr_atop, w_rr_stashid,
			   w_rr_kid, w_rr_wake, w_rr_partial, 
			   w_rr_cmr, w_rr_write, w_rr_trace, w_rr_snp},
			  //Snoop
                        `+p0_mux_snp_str+` 
			  //Wake
			  {2'd0, 1'b0, t_oc_track[w_poc_oid],
			   poc_user, 
			   t_oc_domain[w_poc_oid][MW-1:0],
			   t_oc_snoop[w_poc_oid][SW-1:0],
                           t_oc_vmidext[w_poc_oid],
			   t_oc_bar[w_poc_oid],
			   `+(IW>0 ? `q_oc_id[w_poc_oid]` : /* istanbul ignore next env ncore_3p7 */ `1'b0`)+`, 
			   q_oc_qos[w_poc_oid], 
			   {RW{1'b0}},	// w_wb_region, 
			   {1'b0, q_oc_security[w_poc_oid], q_oc_pr[w_poc_oid]},
			   q_oc_cache[w_poc_oid],
			   q_oc_lock[w_poc_oid],
			   (q_oc_wrap[w_poc_oid] ? 2'h2 : 2'h1),
			   q_oc_size[w_poc_oid],
			   ({`+(8-BWL-1)+`'b0,(~| q_oc_beats[w_poc_oid]), 
					q_oc_beats[w_poc_oid]} - 8'b1),
			   q_oc_addr[w_poc_oid], t_oc_atop[w_poc_oid][AWTW-1:0],
			   t_oc_stashid[w_poc_oid],
			   `+(XTA>OCA?`{{XTA-OCA{1'b0}},w_poc_oid}`:`w_poc_oid`)+`, 
			   1'b1, q_oc_partial[w_poc_oid], 
			   2'h0, q_oc_write[w_poc_oid], q_oc_trace[w_poc_oid], 1'b0},
			  //Read Burst - All multi line Reads will be split into INCRs. Force burst to 2'b01
			  {2'd0, 1'b0, w_rb_track, w_rb_user, w_rb_domain, w_rb_snoop, 
                           4'b0,
			   w_rb_bar, w_rb_id, w_rb_qos, w_rb_region, 
			   w_rb_prot, w_rb_cache, w_rb_lock, 
			   2'b01, w_rb_size,
			   w_rb_len, w_rb_addr, {AWTW{1'b0}}, {AWSW{1'b0}},
			   {XTA{1'b0}}, 1'b0, 1'b0, 2'h0, 1'b0, 1'b0, 1'b0},
			  //Write
			  {2'd0, 1'b0, w_p0w_track, w_p0w_user, w_p0w_domain, w_p0w_snoop, 
                           4'b0,
			   w_p0w_bar, w_p0w_id, w_p0w_qos, w_p0w_region, 
			   w_p0w_prot, w_p0w_cache, w_p0w_lock, 
			   w_p0w_burst, w_p0w_size,
			   w_p0w_len, w_p0w_addr, w_p0w_atop, w_p0w_stashid,
			   ({XTA{1'b0}}|w_p0w_dptr), 1'b0, w_p0w_partial, 
			   2'h0, 1'b1, 1'b0, 1'b0},
			  //Read
			  {2'd0, 1'b0, w_p0r_track, w_p0r_user, w_p0r_domain, w_p0r_snoop, 
                           w_p0r_vmidext,
			   w_p0r_bar, w_p0r_id, w_p0r_qos, w_p0r_region, 
			   w_p0r_prot, w_p0r_cache, w_p0r_lock, 
			   p0r_burst_modified, w_p0r_size,
			   w_p0r_len, w_p0r_addr, {AWTW{1'b0}}, {AWSW{1'b0}},
			   {XTA{1'b0}}, 1'b0, 1'b0, 2'h0, 1'b0, 1'b0, 1'b0}}`,
	ready_i:	'w_p0_ready',
	valid_o:	'n_p0_valid',
	data_o:		`{n_p0_up, n_p0_upmatch, n_p0_track, n_p0_user, n_p0_domain, n_p0_snoop, 
                          n_p0_vmidext,
			  n_p0_bar, n_p0_id, n_p0_qos, n_p0_region, 
			  n_p0_prot, n_p0_cache, n_p0_lock, 
			  n_p0_burst, n_p0_size, n_p0_len, n_p0_addr, 
			  n_p0_atop, n_p0_stashid, n_p0_kid, n_p0_wake, 
			  n_p0_partial, n_p0_cmr, n_p0_write, n_p0_trace_wake, n_p0_snp}`,
	bvsel_i:	'n_p0_sel'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

wire t_oc_einc;
\js if (useCache) {

wire [3:0] t_p0_up_res =
\jsbegin
// Not testing smaller otts when there's a cache
/* istanbul ignore else env ncore_3p7 */
    if (OCN>9) { \jsend
             (w_p2_valid & w_p1_valid   & t_cfg_oc_limit_gt_9) ? 4'h9 :
\js } else /* istanbul ignore next env ncore_3p7 */ if (OCN>8) {
             (w_p2_valid & w_p1_valid   & t_cfg_oc_limit_gt_8) ? 4'h8 :
\js } else /* istanbul ignore next env ncore_3p7 */ if (OCN>7) {
	     (w_p2_valid & w_p1_valid   & t_cfg_oc_limit_gt_7) ? 4'h7 :
\js } else /* istanbul ignore next env ncore_3p7 */ if (OCN>6) {
	     (w_p2_valid & w_p1_valid   & t_cfg_oc_limit_gt_6) ? 4'h6 :
\js } else /* istanbul ignore next env ncore_3p7 */ if (OCN>5) {
	     (w_p2_valid & w_p1_valid   & t_cfg_oc_limit_gt_5) ? 4'h5 :
\js }
\jsbegin
// Not testing smaller otts when there's a cache
/* istanbul ignore else env ncore_3p7 */
    if (OCN>7) { \jsend
             ((w_p2_valid | w_p1_valid) & t_cfg_oc_limit_gt_7) ? 4'h7 :
\js } else /* istanbul ignore next env ncore_3p7 */ if (OCN>6) {
	     ((w_p2_valid | w_p1_valid) & t_cfg_oc_limit_gt_6) ? 4'h6 :
\js } else /* istanbul ignore next env ncore_3p7 */ if (OCN>5) {
	     ((w_p2_valid | w_p1_valid) & t_cfg_oc_limit_gt_5) ? 4'h5 :
\js }
                                                              t_oc_einc ? 4'h5 :
									  4'h4;
wire t_p0_limit_underflow;
\jsbegin
// Not testing smaller otts when there's a cache
/* istanbul ignore if env ncore_3p7 */
    if (OCA==2) { \jsend
assign {t_p0_limit_underflow,t_p0_limit} = {1'b0,t_cfg_oc_limit} - {1'b0,                    t_p0_up_res[2:0]};
\js } else /* istanbul ignore next env ncore_3p7 */ if (OCA==3) {
assign {t_p0_limit_underflow,t_p0_limit} = {1'b0,t_cfg_oc_limit} - {1'b0,                    t_p0_up_res};
\js } else {
assign {t_p0_limit_underflow,t_p0_limit} = {1'b0,t_cfg_oc_limit} - {1'b0,{\=OCA+1-4=\{1'b0}},t_p0_up_res};
\js }
\js } else { // useCache
assign t_p0_limit = t_cfg_oc_limit;
\js }

\js // The read  limit is the oc limit minus the write pool.
\js // The write limit is the oc limit minus the read pool.
\js //
\js // The oc limit = either the engineering debug limit, it if is set, or the full OTT or "OCN"
\js // The pool = either the engineering debug pool, if it is set, or the settings from XAIUCR.
\js //
\js // The XAIUCR settings are:
\js // 00 : write pool=3, read pool=1 (default)
\js // 01 : 1/6
\js // 10 : 1/3
\js // 11 : 1/2
\js // The read/write pools can be selected independently.

wire t_p0_rd_limit_carry;
assign {t_p0_rd_limit_carry,t_p0_rd_limit_ns} = {1'b0,t_cfg_oc_limit[\=OCA=\:0]} - \=OCA+2=\'h1 - {1'b0,cfg_wr_pool_i[\=OCA=\:0]};
\=u.dffre(OCA+1, `t_p0_rd_limit`, `t_p0_rd_limit_ns`, (OCA+1)+`'d0`, `1'b1`, `clk_i`, `reset_ni`)=\

wire t_p0_wr_limit_carry;
assign {t_p0_wr_limit_carry,t_p0_wr_limit_ns} = {1'b0,t_cfg_oc_limit[\=OCA=\:0]} - \=OCA+2=\'h1 - {1'b0,cfg_rd_pool_i[\=OCA=\:0]};
\=u.dffre(OCA+1, `t_p0_wr_limit`, `t_p0_wr_limit_ns`, (OCA+1)+`'d0`, `1'b1`, `clk_i`, `reset_ni`)=\

assign t_p0_single = ((w_p1_valid & w_p1_cmr[1] & (P1EN>0)) |
		      (w_p2_valid & w_pt_cmr[1])) ? 1'b0 :
		     (~t_cfg_single & ({{32-OCA-1{1'b0}},t_oc_count} < (OCN-4)) &
				      q_od_ready) ? 1'b1 :
		     				    ((P1EN==0) | ~w_p1_valid) &
						    ~w_p2_valid;
assign t_p0_single_wake = (~t_cfg_single_wake & q_od_ready &
			   ({{32-OCA-1{1'b0}},t_oc_count} < (OCN-2))) ? 1'b1 :
						     ((P1EN==0) | ~w_p1_valid) &
						     ~w_p2_valid;


\js // Allow one cycle for reads and one cycle for writes. Should be able to have full BW as for either or only one command
\js // \ needs to be sent every two cycles. At a basic level each type gets a channel. Only needs to be done when there is
\js // \ arbitration between reads and writes. Otherwise let the stream of reads and writes through. 

wire t_p0r_valid_wakeup_block;
wire write_holdup = (w_w0_valid | w_wb_valid) & ~w_w1_valid & ~w_w2_valid & ~w_p0w_valid & t_p0r_valid_wakeup_block & (t_oc_count >= \=OCA+1=\'d\=(OCN-2-(W2EN>0)-(P1EN>0)-(useCache>0)-(useCache>0))=\) & n_p0r_ready;
wire [2:0] write_override;
wire [2:0] write_override_ns = n_w1_valid ? 3'b001 : write_override[2] ? write_override : write_holdup ? { write_override[1:0], 1'b0 } : write_override;
\=u.dffre(3, `write_override`, `write_override_ns`, "3'b001", "1'b1", `clk_i`, `reset_ni`)=\
wire write_block = write_override[2];

wire [7:0] lfsr_ns;
wire [7:0] lfsr;
assign lfsr_ns = { lfsr[6:0], lfsr[7]^lfsr[3]^lfsr[2]^lfsr[1] };
\=u.dffre(8, `lfsr`, `lfsr_ns`, "{8{1'b1}}", "1'b1", `clk_i`, `reset_ni`)=\

wire read_cycle;
wire read_cycle_b = ~read_cycle;
wire read_cycle_enable = ~(lfsr[4:0]==5'h1c);
\=u.dffre(1, `read_cycle`, `read_cycle_b`, `1'd0`, `read_cycle_enable`, `clk_i`, `reset_ni`)=\

assign t_p0r_valid = n_cmd_req0_ready & ~w_do_af & ~w_c0_af & ~w_rr_valid &
                     ~write_block &
		     ~t_pvc_throttle & ~w_cmd_req0_af & ~t_cmr_stall &
		     ~(t_cfg_evict & n_ce_valid) & q_od_ready & ~chaining_in_progress &
		     w_p0r_valid & (read_cycle | ~w_p0w_valid) & (~w_rb_valid | ((w_rb_id != w_p0r_id) & 1'b0 &
		    (~|((w_p0r_len + {{\=8-BWL=\{1'b0}},w_p0r_addr[AWL+:BWL]})>>BWL))))&
				   t_p0_single & ~w_ce_af &
				   (t_oc_count < t_p0_limit) &
				   (q_oc_rcount < t_p0_rd_limit) &
				   (q_oc_rcount < t_cfg_rd_limit) &
				   (t_oc_ecount < t_cfg_ev_limit);
assign t_p0w_valid = n_cmd_req0_ready & ~w_rr_valid & ~w_wq_af & ~w_ce_af &
		     ~t_pvc_throttle & ~w_cmd_req0_af & ~t_cmr_stall &
		     ~(t_cfg_evict & n_ce_valid) & (q_od_ready | (CACHE==0)) &
		     w_p0w_valid & (~read_cycle | ~(w_p0r_valid | w_rb_valid) ) & t_p0_single &
				   (t_oc_count < t_p0_limit) &
				   ((q_oc_wcount < t_p0_wr_limit) |
				    ((q_oc_wcount == t_p0_wr_limit) &
					t_p0w_update)) &
				   (q_oc_wcount < t_cfg_wr_limit) &
				   (t_oc_ecount < t_cfg_ev_limit);
assign t_prb_valid = n_cmd_req0_ready & ~w_do_af & ~w_c0_af & ~w_rr_valid &
		     ~t_pvc_throttle & ~w_cmd_req0_af & ~t_cmr_stall &
		     ~(t_cfg_evict & n_ce_valid) & q_od_ready & ~chaining_in_progress &
		     w_rb_valid & (read_cycle | ~w_p0w_valid) & t_p0_single & ~w_ce_af &
				  (t_oc_count < t_p0_limit) &
				  (q_oc_rcount < t_p0_rd_limit) &
				  (q_oc_rcount < t_cfg_rd_limit) &
				  (t_oc_ecount < t_cfg_ev_limit);


\js var wakeupArbTimeout = log2ceil(64);
wire [\=wakeupArbTimeout-1=\:0] wakeup_block_cnt, wakeup_block_cnt_ns;
wire        wakeup_block;
wire t_prb_valid_qual;
assign wakeup_block = wakeup_block_cnt[\=wakeupArbTimeout-1=\];
assign wakeup_block_cnt_ns = (n_p0_sel[3] & ~wakeup_block & w_pvc_valid) ? wakeup_block_cnt + \=wakeupArbTimeout=\'b1 : \=wakeupArbTimeout=\'b0;
assign t_poc_valid_qual = t_poc_valid & ~wakeup_block_cnt[\=wakeupArbTimeout-1=\];
assign t_prb_valid_qual = t_prb_valid & ~wakeup_block_cnt[\=wakeupArbTimeout-1=\];
\=u.dffre(wakeupArbTimeout, `wakeup_block_cnt`, `wakeup_block_cnt_ns`, `{`+wakeupArbTimeout+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

wire t_p0w_valid_wakeup_block = t_p0w_valid & ~wakeup_block; // & ~t_poc_valid;
assign t_p0r_valid_wakeup_block = t_p0r_valid & ~wakeup_block; // & ~t_poc_valid;

\=u.instance({
	moduleName: 'ioaiu_arbiter',
	instanceName: 'p0_arb_new',
	params: {
                DRST:           DRST,
                DW:             6,
                ATOMIC:         0,
                HP:             `6'h38`,
                VAL:            1,
                NO_WINNER_OUT:  1,
		 assertOn: assertOn
	},
	ports: {
		clk_i:		'clk_i',
		reset_ni:	'reset_ni',
		ready_i:	'w_p0_ready',
		bv_i:		'{t_rr_valid, n_srs_valid, t_poc_valid_qual, t_prb_valid_qual, t_p0w_valid_wakeup_block, t_p0r_valid_wakeup_block}',
		lv_i:		`{6{1'b1}}`,
		wbv_o:		'n_p0_sel'
	},
	portsDelimiter: '\n\t'
})=\

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'p0',
	params: {
                depth:          0,
		width:		PXW+3+1+2+1+4,
                pipeForward:    "no",
                pipeBackward:   "no",
                simplePipe:     "yes",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		in_ready:	'w_p0_ready',
		in_valid:	'n_p0_valid',
		in_data:	`{n_p0_up, n_p0_upmatch, n_p0_track, n_p0_user, n_p0_domain, 
                                  n_p0_vmidext,
				  n_p0_snoop, n_p0_bar, n_p0_id, n_p0_qos, 
				  n_p0_region, n_p0_prot, n_p0_cache, 
				  n_p0_lock, n_p0_burst, n_p0_size, 
				  n_p0_len, n_p0_addr, n_p0_atop, n_p0_stashid,
				  n_p0_kid, n_p0_wake, n_p0_partial, 
				  n_p0_cmr, n_p0_write,
				  n_p0_sel[1], (n_p0_sel[0] | n_p0_sel[2]), n_p0_trace_wake, n_p0_snp}`,
		out_ready:	'n_p0_ready',
		out_valid:	'w_p0_valid',
		out_data:	`{w_p0_up, w_p0_upmatch, w_p0_track, w_p0_user, w_p0_domain, 
                                  w_p0_vmidext,
				  w_p0_snoop, w_p0_bar, w_p0_id, w_p0_qos, 
				  w_p0_region, w_p0_prot, w_p0_cache, 
				  w_p0_lock, w_p0_burst, w_p0_size, 
				  w_p0_len, w_p0_addr, w_p0_atop, w_p0_stashid,
				  w_p0_kid, w_p0_wake, w_p0_partial, 
				  w_p0_cmr, w_p0_write, w_p0_sel, w_p0_trace_wake, w_p0_snp}`
	},
	portsDelimiter: '\n\t'
})=\

\=u.instance({
	moduleName: 'ioaiu_demux',
	instanceName: 'p0_split',
	params: {
		 NUM:		2,
		 DW:		PXW+1+1+2+1+4,
                 clkAssertInterface : clkAssertInterface,
                 assertOn : assertOn
        },
	verilogParams: {
	},
	ports: {
		ready_o:	'n_p0_ready',
		valid_i:	'w_p0_valid',
		data_i:		`{w_p0_up, w_p0_upmatch, w_p0_track, w_p0_user, w_p0_domain, 
                                  w_p0_vmidext,
				  w_p0_snoop, w_p0_bar, w_p0_id, w_p0_qos, 
				  w_p0_region, w_p0_prot, w_p0_cache, 
				  w_p0_lock, w_p0_burst, w_p0_size, 
				  w_p0_len, w_p0_addr, w_p0_atop, w_p0_stashid,
				  w_p0_kid, w_p0_wake, w_p0_partial, 
				  w_p0_cmr, w_p0_write, w_p0_trace_wake, w_p0_snp}`,
		ready_i:	'{w_c1_ready, w_p1_ready}',
		valid_o:	'{n_c1_valid, n_p1_valid}',
		data_o:		`{n_c1_data,
		                  n_p1_up, n_p1_upmatch, n_p1_track, n_p1_user, n_p1_domain, 
                                  n_p1_vmidext,
				  n_p1_snoop, n_p1_bar, n_p1_id, n_p1_qos, 
				  n_p1_region, n_p1_prot, n_p1_cache, 
				  n_p1_lock, n_p1_burst, n_p1_size, 
				  n_p1_len, n_p1_addr, n_p1_atop, n_p1_stashid,
				  n_p1_kid, n_p1_wake, n_p1_partial, 
				  n_p1_cmr, n_p1_write, n_p1_trace_wake, n_p1_snp}`,
		bvsel_i:	't_c0_sel'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

wire status_error = w_p0_wake & q_oc_val[w_p0_kid] & q_oc_status[w_p0_kid][7];

assign t_c0_sel = t_pe_correctable_error ? 2'h0 : {(cfg_cache_i | 
				       (t_rr_valid & w_rr_cmr[1])) & w_p0_valid & ~status_error &
				     ~(w_p0_wake & t_oc_evict[w_p0_kid]), 1'b1};
\js if (P1EN) {
    wire [1:0] t_p1_sel;
    wire       n_p2m_p2_valid,  w_p2m_p2_valid;
    wire       n_p2m_pvc_valid, w_p2m_pvc_valid;

    \=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'p1',
	params: {
                depth:          1,
		width:		PXW+3+1+2+1+4,
                pipeForward:    "yes",
                pipeBackward:   "no",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_p1_ready',
		in_valid:	'n_p1_valid',
		in_data:	`{n_p1_up, n_p1_upmatch, n_p1_track, n_p1_user, n_p1_domain, 
                                  n_p1_vmidext,
				  n_p1_snoop, n_p1_bar, n_p1_id, n_p1_qos, 
				  n_p1_region, n_p1_prot, n_p1_cache, 
				  n_p1_lock, n_p1_burst, n_p1_size, 
				  n_p1_len, n_p1_addr, n_p1_atop, n_p1_stashid,
				  n_p1_kid, n_p1_wake, n_p1_partial, 
				  n_p1_cmr, n_p1_write, w_p0_sel, n_p1_trace_wake, n_p1_snp}`,
		out_ready:	'n_p1_ready',
		out_valid:	'w_p1_valid',
		out_data:	`{w_p1_up, w_p1_upmatch, w_p1_track, w_p1_user, w_p1_domain, 
                                  w_p1_vmidext,
				  w_p1_snoop[SW-1:0], w_p1_bar, w_p1_id, w_p1_qos, 
				  w_p1_region, w_p1_prot, w_p1_cache, 
				  w_p1_lock, w_p1_burst, w_p1_size, 
				  w_p1_len, w_p1_addr, w_p1_atop, w_p1_stashid,
				  w_p1_kid, w_p1_wake, w_p1_partial, 
				  w_p1_cmr, w_p1_write, w_p1_sel, w_p1_trace_wake, w_p1_snp}`
	},
	portsDelimiter: '\n\t'
    })=\
\jsbegin
// eDomain always 1 in 3.7
/* istanbul ignore next env ncore_3p7 */
    if ((axiParams.eDomain?1:0)==0) { \jsend
assign w_p1_snoop[3:1] = 3'b0;
\js }

\js if (useCache) {
      \=u.instance({
	moduleName: 'ioaiu_demux',
	instanceName: 'p1_demux',
	params: {
		 NUM:		2,
		 DW:		1,
                 NO_DATA_OUT:   1,
                 clkAssertInterface : clkAssertInterface,
                 assertOn : assertOn
        },
	verilogParams: {
	},
	ports: {
		ready_o:	'n_p1_ready',
		valid_i:	'w_p1_valid',
		data_i:		`1'b0`,
		ready_i:	`{1'b1,  	w_p2_ready}`,
		valid_o:	'{n_rp1_valid,  n_p2_valid}',
		bvsel_i:	't_p1_sel'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
      })=\
      assign t_p1_sel = ((w_p2_valid & t_pt_correctable_error) | (w_p1_valid & t_pe_correctable_error)) ? 2'h2 : 2'h1;				       
\js } else {
      assign n_p1_ready = w_p2_ready;
      assign n_p2_valid = w_p1_valid;
      assign n_rp1_valid = 1'b0;
      assign t_p1_sel = 2'h1;				       
\js }
				      
    \=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'p2m',
	params: {
                depth:          1,
		width:		AMCW+1+8+1+1,
                pipeForward:    "yes",
                pipeBackward:   "no",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'',
                in_valid:      	'n_p2_valid',
		in_data:	`{amc_mig_i, amc_order_i, amc_errs_i, amc_tins_i,
                                  amc_nrs_region_hit_i,
                                  n_amc_nc,
				  amc_fids_i, amc_vals_i, t_oc_iok[w_p1_kid],amc_size_of_ig_i,amc_unconnected_dce_access,amc_unconnected_dmi_access,amc_unconnected_dii_access}`,
                out_ready:     	'n_p2_ready',
                out_valid:     	'w_p2m_p2_valid',
                out_data:      	`{w_p2_amc_mig, w_p2_amc_order, w_p2_amc_errs, w_p2_amc_tins,
                                  w_p2_amc_nrs_region_hit,
                                  w_p2_amc_nc,
                                  w_p2_amc_fids, w_p2_amc_vals, w_p2_pt_iok, w_p2_amc_size_of_ig,w_p2_amc_unconnected_dce_access,w_p2_amc_unconnected_dmi_access,w_p2_amc_unconnected_dii_access}`
	},
	portsDelimiter: '\n\t'
    })=\

    \=u.instance({
        moduleName: 'rdy_vld_pipe',
        instanceName: 'p2m_pvc',
        params: {
                depth:          1,
                width:          AMCW+1+8+1+1,
                pipeForward:    "yes",
                pipeBackward:   "no",
                simplePipe:     "no",
                circular:       "no"
                 },
        verilogParams: {
        },
        ports: {
                clk:          	'clk_i',
                reset_n:       	'reset_ni',
                in_ready:     	'',
                in_valid:     	'n_pvc_valid & ~w_p1_valid',
                in_data:     	`{amc_mig_i, amc_order_i, amc_errs_i, amc_tins_i,
                                  amc_nrs_region_hit_i,
                                  n_amc_nc,
                                  amc_fids_i, amc_vals_i, t_oc_iok[w_p1_kid],amc_size_of_ig_i,amc_unconnected_dce_access,amc_unconnected_dmi_access,amc_unconnected_dii_access}`,
                out_ready:      'n_pvc_ready',
                out_valid:      'w_p2m_pvc_valid',
                out_data:     	`{w_pvc_amc_mig, w_pvc_amc_order, w_pvc_amc_errs, w_pvc_amc_tins,
                                  w_pvc_amc_nrs_region_hit,
                                  w_pvc_amc_nc,
                                  w_pvc_amc_fids, w_pvc_amc_vals, w_pvc_pt_iok, w_pvc_amc_size_of_ig,w_pvc_amc_unconnected_dce_access,w_pvc_amc_unconnected_dmi_access,w_pvc_amc_unconnected_dii_access}`
        },
        portsDelimiter: '\n\t'
    })=\

assign {w_amc_mig, w_amc_order, w_amc_errs, w_amc_tins,
                                  w_amc_nrs_region_hit,
                                  w_amc_nc,
                                  w_amc_fids, w_amc_vals, w_pt_iok, w_amc_size_of_ig,w_amc_unconnected_dce_access,w_amc_unconnected_dmi_access,w_amc_unconnected_dii_access} = w_p2_valid ?
{w_p2_amc_mig, w_p2_amc_order, w_p2_amc_errs, w_p2_amc_tins,
                                  w_p2_amc_nrs_region_hit,
                                  w_p2_amc_nc,
                                  w_p2_amc_fids, w_p2_amc_vals, w_p2_pt_iok, w_p2_amc_size_of_ig,w_p2_amc_unconnected_dce_access,w_p2_amc_unconnected_dmi_access,w_p2_amc_unconnected_dii_access} :
{w_pvc_amc_mig, w_pvc_amc_order, w_pvc_amc_errs, w_pvc_amc_tins,
                                  w_pvc_amc_nrs_region_hit,
                                  w_pvc_amc_nc,
                                  w_pvc_amc_fids, w_pvc_amc_vals, w_pvc_pt_iok, w_pvc_amc_size_of_ig,w_pvc_amc_unconnected_dce_access,w_pvc_amc_unconnected_dmi_access,w_pvc_amc_unconnected_dii_access};

\js } else { // P1EN
    assign w_p1_upmatch = n_p1_upmatch;				       
    assign w_p1_up = n_p1_up; 
    assign n_p1_ready = 1'b1;
    assign w_p1_ready = w_p2_ready;
    assign w_p1_valid = n_p1_valid;
    assign {w_p1_vmidext,w_p1_track, w_p1_user, w_p1_domain, w_p1_snoop[SW-1:0], w_p1_bar, w_p1_id, 
	w_p1_qos, w_p1_region, w_p1_prot, w_p1_cache, w_p1_lock, w_p1_burst, 
	w_p1_size, w_p1_len, w_p1_addr, w_p1_atop, w_p1_stashid, w_p1_kid, 
	w_p1_wake, w_p1_partial, w_p1_cmr, w_p1_write, w_p1_sel, w_p1_trace_wake, w_p1_snp} = {n_p1_vmidext,n_p1_track, 
		       n_p1_user, n_p1_domain, n_p1_snoop, n_p1_bar,
		       n_p1_id, n_p1_qos, n_p1_region, n_p1_prot,
		       n_p1_cache, n_p1_lock, n_p1_burst, n_p1_size,
		       n_p1_len, n_p1_addr, n_p1_atop, n_p1_stashid,
		       n_p1_kid, n_p1_wake, n_p1_partial,
		       n_p1_cmr, n_p1_write, w_p0_sel, n_p1_trace_wake, n_p1_snp};
\js if ((axiParams.eDomain?1:0)==0) {
assign w_p1_snoop[3:1] = 3'b0;
\js }
    assign {w_amc_mig, w_amc_order, w_amc_errs, w_amc_tins,  w_amc_nc,
            w_amc_nrs_region_hit,
 	    w_amc_fids, w_amc_vals, w_amc_size_of_ig, w_amc_unconnected_dce_access, w_amc_unconnected_dmi_access, w_amc_unconnected_dii_access} =      
           {amc_mig_i, amc_order_i, amc_errs_i, amc_tins_i, n_amc_nc,
            amc_nrs_region_hit_i,
	    amc_fids_i, amc_vals_i,amc_size_of_ig_i, amc_unconnected_dce_access, amc_unconnected_dmi_access, amc_unconnected_dii_access};
    assign w_pt_iok = t_oc_iok[w_pt_kid];
    assign n_p2_valid = w_p1_valid;				       
\js } // P1EN

\js if (nativeTrigger.signals.user>0) {
     assign trace_user = {{(\=nativeTrigger.signals.user=\ - AXUW){1'b0}},w_pt_user}; 
\js }

  assign     trace_addr		= w_pt_addr;
  assign     trace_opcode	=
\js if (axiParams.eDomain) { 
                                  {{15-AWTW-MW-SW{1'b0}},w_pt_atop[AWTW-1:0],w_pt_domain[MW-1:0],w_pt_snoop[SW-1:0]};
\js } else {
                                  \=nativeTrigger.signals.opcode=\'b0;
\js }
  assign     trace_dmi_hit	= w_amc_vals[1];
  assign     trace_dii_hit	= w_amc_vals[2];
  assign     trace_hui          = ({\=nativeTrigger.signals.hui=\{w_amc_vals[1]}} & w_amc_mig) | ({\=nativeTrigger.signals.hui=\{w_amc_vals[2]}} & w_amc_tins[2*5 +: 5]);
  assign     trace_aw		= w_pt_valid &   w_pt_write;
  assign     trace_ar		= w_pt_valid &  ~w_pt_write;
  assign     trace_memattr	= w_pt_cache;
  assign     trace_trace        = w_pt_track;

  assign     trace_size_of_ig   = w_amc_size_of_ig;

  assign     w_p1_trace         = 1'h0;
  assign     w_pt_trace         = w_pt_wake ? w_pt_trace_wake : tracetag;

\js /////////////////////////////////////////////////////////////////////
\js // SysCO pin functionality depending on configuration
\js /////////////////////////////////////////////////////////////////////
\js // AXI                          pin func:
\js //  No cache                          
\js //   Coherent                   All ops in the OTT are considered coherent. pin =  ~|OTT_valids
\js //   Non-coherent               pin = 1 
\js //   Cache (coherent)           All ops in the OTT are considered coherent. pin =  ~|OTT_valids
\js // ACE
\js //  Disregarding cache or not : pin = ~|coherent_and_valid_op(OTT_entries)
\js /////////////////////////////////////////////////////////////////////
wire [OCN-1:0] t_oc_coherent; // coherent operation in OTT

\js if (ACE==1) {
\js for (let i=0; i<OCN; i=i+1) { // ACE, ops can be coh or not
      assign t_oc_coherent[\=i=\] = q_oc_val[\=i=\] && 
                              ((t_oc_domain[\=i=\] == 2'h1) || (t_oc_domain[\=i=\] == 2'h2)) && (t_oc_bar[\=i=\] == 2'h0) &&
                              ((t_oc_snoop[\=i=\] == 4'h0) ||
			       (t_oc_snoop[\=i=\] == 4'h1) ||
			       (t_oc_snoop[\=i=\] == 4'h2) ||
			       (t_oc_snoop[\=i=\] == 4'h3) ||
			       (t_oc_snoop[\=i=\] == 4'hb) ||
			       (t_oc_snoop[\=i=\] == 4'hc) ||
			       (t_oc_snoop[\=i=\] == 4'h7) ||
			       (t_oc_snoop[\=i=\] == 4'ha)
			     );
\js }
    assign outstanding_coherent_count_zero = ~|t_oc_coherent;
\js } else {
\js if (useCache==1) {
      assign outstanding_coherent_count_zero = ~|q_oc_val;
\js } else {
      assign outstanding_coherent_count_zero = 1'b1;
\js }
\js }
\js /////////////////////////////////////////////////////////////////////

assign w_p1_iptr_lookup = q_oc_iptr[w_p1_kid];

wire t_p1_wns =  w_p1_write & ~w_p1_bar[0] & ~((w_p1_snoop==4'h1) |   //WriteUniqueFull
                                               (w_p1_snoop==4'h4) |   //Evict
                                               (w_p1_snoop==4'h8) |   //WriteUniquePartialStash
                                               (w_p1_snoop==4'h9));   //WriteUniqueFullStash

\js if ((axiParams.eDomain?1:0)==0) {
  assign t_p1_domain = {1'b0,(amc_nc_i | amc_ignore_o) ? 1'b0 : 1'b1};
\js } else {
  assign t_p1_domain = w_p1_domain;
\js }

wire t_p1_cmo = ~w_p1_write & ~w_p1_bar[0] & (
			((t_p1_domain < 2'h3) & 
				((w_p1_snoop==4'h8) |	//CleanShared
				 (w_p1_snoop==4'h9) |	//CleanInvalid
			 	 (w_p1_snoop==4'ha) | 	//CleanSharedPersist
				 (w_p1_snoop==4'hd))) |	//MakeInvalid
			(((t_p1_domain==2'h1) | (t_p1_domain==2'h2)) &
				((w_p1_snoop==4'hb) |	//ACE CleanUnique
				 (w_p1_snoop==4'hc))));	//ACE MakeUnique

wire [\=XTAW-1=\:0] w_p1_kid_oh;

\js for ( let i = 0; i < XTAW; i++) {
    assign w_p1_kid_oh[\=i=\] = (w_p1_kid == \=XTA=\'d\=i=\);
\js }

\js /////////////////////////////////////////////////////////////////////
\js // OWO Address Match Logic
\js //    For OWO do address matching logic before p2 to enable timing
\js /////////////////////////////////////////////////////////////////////

\jsbegin
// No owo on 3.7.0
    if (owo) { \jsend

wire [\=OCN=\-1:0] match_address;
wire [\=OCN=\-1:0] entry_in_uce_or_ud;


wire [\=STN=\-1:0] match_snoop;

  \js for ( let i = 0; i < OCN; i++) {
    assign match_address[\=i=\] = q_oc_val[\=i=\] & ({w_p1_prot[1],w_p1_addr[\=AW-1=\:\=CLO=\]} == {q_oc_security[\=i=\],q_oc_addr[\=i=\][\=AW-1=\:\=CLO=\]});
    assign entry_in_uce_or_ud[\=i=\] = (q_oc_owned[\=i=\]);
  \js }

  \js for ( let i = 0; i < STN; i++) {
    assign match_snoop[\=i=\] = q_st_val[\=i=\] & ({w_p1_prot[1],w_p1_addr[\=AW-1=\:\=CLO=\]} == {q_st_ns[\=i=\],q_st_addr[\=i=\][\=AW-1=\:\=CLO=\]});
  \js }

  // As long as the txn doesnt match a snoop, if the IOAIU has it in an owned state
  // it can just initialize the txn to an owned state. No CMO needed;
  assign w_p1_upgrade = 1'b0; // Removed upgrade optimization for at least 3.7 |(match_address & entry_in_uce_or_ud) & ~(|match_snoop);

\js } else {

  assign w_p1_upgrade = 1'b0;

\js }

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'p2',
	params: {
                depth:          1,
		width:		PXW+OCA+2+1+1+1+2+1+4+XTAW+1,
                pipeForward:    "yes",
                pipeBackward:   "no",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_p2_ready',
		in_valid:	'n_p2_valid',
		in_data:	`{w_p1_up, w_p1_upmatch, w_p1_track, w_p1_user, t_p1_domain[MW-1:0], 
                                  w_p1_vmidext,
				  w_p1_snoop[SW-1:0], w_p1_bar, w_p1_id, w_p1_qos, 
				  w_p1_region, w_p1_prot, w_p1_cache, 
				  w_p1_lock, w_p1_burst, w_p1_size, 
				  w_p1_len, w_p1_addr, w_p1_atop[AWTW-1:0], w_p1_stashid,
				  w_p1_kid, w_p1_wake, w_p1_partial, 
				  w_p1_cmr, w_p1_write, w_p1_iptr_lookup, w_p1_trace, w_p1_trace_wake, t_p1_cmo, t_p1_wns, w_p1_snp, w_p1_kid_oh,w_p1_upgrade}`,
		out_ready:	'n_p2_ready',
		out_valid:	'w_p2_valid',
		out_data:	`{w_p2_up, w_p2_upmatch, w_pt_track, w_pt_user, w_pt_domain_unqual[MW-1:0], 
                                  w_pt_vmidext,
				  w_mod_snoop[SW-1:0], w_pt_bar, w_pt_id, w_pt_qos, 
				  w_pt_region, w_pt_prot, w_pt_cache, 
				  w_pt_lock, w_pt_burst, w_pt_size, 
				  w_mod_len, w_pt_addr, w_pt_atop[AWTW-1:0], w_pt_stashid,
				  w_pt_kid, w_pt_wake, w_pt_partial, 
				  w_pt_cmr, w_pt_write, w_pt_iptr_lookup, w_pt_trace_out, w_pt_trace_wake, w_mod_cmo, w_mod_wns, w_pt_snp, w_pt_kid_oh,w_pt_upgrade}`
	},
	portsDelimiter: '\n\t'
})=\

\=u.dffre(XTAW, `w_pt_kid_oh_last`, `w_pt_kid_oh`, XTAW+`'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
\=u.dffre(1, `w_pt_wake_last`, `w_pt_wake`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
\=u.dffre(1, `n_cmd_req0_valid_last`, `n_cmd_req0_valid`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\

\js // For OWO need to force the snoop value to be CMO if its:
\js // - A new write
\js // - A write that needs to regain ownership
\js // The snoop placed into q_oc_snoop will be the correct snoop for the writeback
\js // The generated_writeback is only a owo concept
\js // For the generated writeback use the original len. For some reason the p0_mux zeros out the length.

wire generated_writeback;
wire generated_cmo;
wire command_sent;
wire noncoh_writeback;

\jsbegin
// No owo on 3.7.0
    if (owo) { \jsend
assign generated_cmo       = (w_pt_write & ~(|w_pt_atop) & (w_pt_domain != 2'd0 & w_pt_domain != 2'd3) & (~w_pt_wake | ~t_oc_owned[w_pt_kid]));
assign generated_writeback = (w_pt_write & ~(|w_pt_atop) & t_oc_coh[w_pt_kid] & w_pt_wake & t_oc_owned[w_pt_kid]);
assign noncoh_writeback    =  w_pt_write & ~(|w_pt_atop) & ~t_pt_coherent;
assign w_pt_snoop          = generated_cmo ? 4'hb : \=((axiParams.eDomain?1:0)==0) ? "{3'b0,w_mod_snoop[0]}" : "w_mod_snoop"=\;
assign w_pt_wns            = generated_cmo ? 1'b0 : w_mod_wns;
assign w_pt_cmo            = (w_pt_snoop==4'hb | w_pt_snoop==4'hc);
assign w_pt_len            = generated_writeback ? {{8-BWL{1'b0}},q_oc_beats[w_pt_kid]} : w_mod_len;

wire [\=TINW+1=\:0] writeback_tin = {t_pt_dii,t_pt_dmi,(t_pt_dmi ? w_amc_tins[5 +: TINW] :w_amc_tins[10+: TINW])};

wire [OCN-1:0] w_pt_dtp_collision;
wire [OCN-1:0] dtp_clear_collision;
\js for (let i=0; i<OCN; i=i+1) {

wire generated_writeback_retry\=i=\;
wire generated_writeback_retried\=i=\;

assign generated_writeback_retry\=i=\ = t_oc_update[\=i=\] ? w_pt_valid & generated_writeback & ~q_oc_oldest[\=i=\] : t_oc_alloc[\=i=\] ? 1'b0 : generated_writeback_retried\=i=\;
\=u.dffre(1, `generated_writeback_retried`+i, `generated_writeback_retry`+i, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\

assign w_pt_dtp_collision[\=i=\] = q_oc_val[\=i=\] & q_oc_write[\=i=\] & ~(|t_oc_atop[\=i=\]) & ~dtp_clear_collision[\=i=\] &
                                      (                            (((t_oc_phase[\=i=\] == 2'h1) | (t_oc_phase[\=i=\] == 2'h2)) & (q_oc_id[\=i=\] == w_pt_id) & (q_oc_wfdtw[\=i=\] | q_oc_wfdtp[\=i=\]))) & (
                                            ( (q_oc_tin[\=i=\] == writeback_tin) & q_oc_tin[\=i=\][TINW] & 1'b1           & ~t_oc_coh[\=i=\]) |
                                            (~(q_oc_tin[\=i=\] == writeback_tin) & 1'b1                  & ~t_pt_coherent &  t_oc_coh[\=i=\]) |
                                            (~(q_oc_tin[\=i=\] == writeback_tin) & 1'b1                  &  t_pt_coherent & ~t_oc_coh[\=i=\]) |
                                            (~(q_oc_tin[\=i=\] == writeback_tin) & 1'b1                  & ~t_pt_coherent & ~t_oc_coh[\=i=\]));

wire [\=OCN-1=\:0] q_oc_dtp_collision_ns\=i=\;
wire [\=OCN-1=\:0] q_oc_dtp_collision\=i=\;

  assign q_oc_dtp_collision_ns\=i=\ = //(t_oc_alloc[\=i=\]  & ~noncoh_writeback) ? {\=OCN=\{1'b0}} :
                                     ((t_oc_alloc[\=i=\]|t_oc_update[\=i=\]) & (generated_writeback | noncoh_writeback)) ? w_pt_dtp_collision :
                                      (|dtp_clear_collision) ? (q_oc_dtp_collision\=i=\ & ~dtp_clear_collision) :
                                      q_oc_dtp_collision\=i=\;

  \=u.dffre(OCN, `q_oc_dtp_collision`+i, `q_oc_dtp_collision_ns`+i, `{`+OCN+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

\js // If an error is stopping all future smi operations for a transaction, let any ordered writes or blocked snoops proceed.
\js // Also, add a failsafe 
wire t_oc_fini_ns\=i=\;
wire t_oc_fini\=i=\;

assign t_oc_fini_ns\=i=\ = (t_oc_alloc[\=i=\]|t_oc_update[\=i=\]) ? t_pt_err : t_oc_fini\=i=\;
  \=u.dffre(1, `t_oc_fini`+i, `t_oc_fini_ns`+i, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\

assign t_oc_fini[\=i=\] = t_oc_fini\=i=\;

assign dtp_clear_collision[\=i=\] = (w_dtw_rsp_valid & ~w_dtw_rsp_mid[\=Math.max(OCA, STA)=\] & (w_dtw_rsp_mid[OCA-1:0]==\=OCA=\'d\=i=\)) | ~q_oc_val[\=i=\] | t_oc_fini\=i=\;
\js }

\js } else {
assign generated_cmo       = 1'b0;
assign generated_writeback = 1'b0;
assign w_pt_snoop[SW-1:0]  = w_mod_snoop[SW-1:0];
assign w_pt_wns            = w_mod_wns;
assign w_pt_cmo            = w_mod_cmo;
assign w_pt_len            = w_mod_len;
\js }

\js if ((axiParams.eDomain?1:0)==0) {
\jsbegin
// No owo on 3.7.0
     if (!owo) { \jsend
  assign w_pt_snoop[3:1] = 3'b0;
 \js }
  assign w_pt_domain[1] = 1'b0;
  assign w_pt_domain[0] = (generated_writeback) ? 1'b0 : ((P1EN>0) ? w_pt_domain_unqual[0] : (amc_nc_i | amc_ignore_o) ? 1'b0 : 1'b1);
\js } else {
  assign w_pt_domain = (generated_writeback) ? 2'b0 : w_pt_domain_unqual;
\js }

\js // FIXME Spyglass W164a : bar a two bit signal shifted right by 1 makes a single bit signal. (Why not just select [1]?)
  wire [MW-1:0] w_pt_bar_tmp = w_pt_bar>>1;
  assign t_pt_unique = ((CDW>1) & w_pt_write) ? w_pt_bar_tmp[0] : 1'b0;
  assign t_pt_correctable_error = cp2_nacks_i[2];
  assign {w_p0_lcmr, w_p0_security, w_p0_pr} = w_p0_prot;
  assign {w_p1_lcmr, w_p1_security, w_p1_pr} = w_p1_prot;
  assign {w_pt_lcmr, w_pt_security, w_pt_pr} = w_pt_prot;

\js if (axiParams.eStash) {
     assign {w_pt_stashnid, w_pt_stashniden, w_pt_stashlpid, w_pt_stashlpiden} = w_pt_stashid;

     assign t_pt_stash = w_p2_valid & w_pt_write &
				 ((w_pt_snoop==4'h8) | (w_pt_snoop==4'h9) |
				  (w_pt_snoop==4'hc) | (w_pt_snoop==4'hd));
     assign t_pt_stash_once = w_p2_valid & w_pt_write &
				 ((w_pt_snoop==4'hc) | (w_pt_snoop==4'hd));
\js } else {
     assign {w_pt_stashnid, w_pt_stashniden, w_pt_stashlpid, w_pt_stashlpiden} = {1+5+1+FIDW{1'b0}};

     assign t_pt_stash = 1'b0;
     assign t_pt_stash_once = 1'b0;
\js }

assign t_pt_catop = (| w_pt_atop) & (| w_pt_cache[3:2]) &
				   ~(~w_pt_bar[0] & (w_pt_snoop==4'h0) &
						    ((w_pt_domain==2'h0) |
						     (w_pt_domain==2'h3)));

assign t_pt_evict = w_p2_valid & w_pt_write & ~w_pt_bar[0] & (ACE>0) &
				 (w_pt_snoop==4'h4) &
				 ((w_pt_domain==2'h1) | (w_pt_domain==2'h2));

\js // The partial stored in the OC is in relation to the CMO beats. 
\js // For the generated write flow use the stored partial always. When calculating from the generated CMO need to use calculated value verses forced value to 1. 
assign t_pt_partial = (generated_writeback) ? w_pt_partial : 
                         (t_cfg_partial | w_pt_partial | 
		         ((w_pt_write | w_amc_nc) & ((generated_cmo ? (| n_oc_beats_calc[BWL-1:0]) : (| n_oc_beats[BWL-1:0])) |
			     ((| w_pt_addr[AWL +: BWL]) & (w_pt_burst!=2'h2)))));

assign t_pt_snp = w_p2_valid & ~w_pt_write & w_pt_snp & ~t_pt_correctable_error & 
							    ~t_pe_correctable_error;
\js if(OCA>STA) {
     assign t_pt_oid = w_pt_wake ? w_pt_kid : q_oc_wptr;
\js } else {
     assign t_pt_oid = w_pt_wake ? w_pt_kid[OCA-1:0] : q_oc_wptr;
\js }

   assign n_pt_ready = ~t_pt_correctable_error & ~t_pe_correctable_error; // & ~dealloc_collect[q_oc_wptr];

   assign n_p2_ready = n_pt_ready;
   assign w_pt_valid = w_p2_valid & ~t_pe_correctable_error & ~t_pt_correctable_error;

\js if (AxIdProcSelectBits.length==0) {
assign   t_pt_lpid[0] = 1'b0;
\js } else {
\js   for (let i=0;i<AxIdProcSelectBits.length;i++) {
assign   t_pt_lpid[\=i=\] = w_pt_id[\=AxIdProcSelectBits[i]=\];
\js   }
\js }

   assign t_pt_wns = w_pt_wns;
   assign t_pt_cmo = w_pt_cmo;

\js // Flush cmr looked like it used to set beats == 4, but that really wasn't the case for all configs
\js // the upper bit gets truncated in 256-bit config. The only side effect seemed to be that port_sel_p1
\js // was being set for flush non-evict for 64 bit configs, bit not 128/256. So for now, tying this to 0 for all.
   assign t_pt_beats = \=BWL+1=\'d\=BPL=\ - {1'b0,w_pt_addr[AWL +: BWL]};
\js if (BWL==1) {
   assign n_oc_beats = (t_pt_err & (|w_pt_atop)) ? (((w_pt_atop==6'h31) & (w_pt_len==8'h3) & 1'b\=(DW==64)?1:0=\) ? {              2'b10} : {{BWL{1'b0}},1'b1}) : w_pt_cmr[1] ? \=BWL+1=\'b0 :
\js } else {
   assign n_oc_beats = (t_pt_err & (|w_pt_atop)) ? (((w_pt_atop==6'h31) & (w_pt_len==8'h3) & 1'b\=(DW==64)?1:0=\) ? {{BWL-1{1'b0}},2'b10} : {{BWL{1'b0}},1'b1}) : w_pt_cmr[1] ? \=BWL+1=\'b0 :
\js }
		       ((t_pt_cmo) | t_pt_csr)   ? {{BWL{1'b0}},1'b1} : n_oc_beats_calc; 

   assign n_oc_beats_calc = ((w_pt_burst==2'h2) & (w_pt_len<8'd\=BPL=\)) ? w_pt_len[BWL:0] + 1'b1 :
                            (({1'b0,w_pt_len}+1'b1)>={\=9-(BWL+1)=\'b0,t_pt_beats}) ? t_pt_beats[0+:BWL+1]:
                            w_pt_len[BWL:0] + 1'b1;

\js // For OWO the stored beats value needs to be representative of the write, not the CMO.
\js // Only modify the stored value. Not what value is used during the generated CMO
\js // Since the writeback is generated, it doesnt have the large w_pt_len that would make the 0-1=3, so need to store 3.
\js // - This storage must be done on the generated cmo. 
\js // - Effectivly if its the split case then need to store beats as if thats what will be used in t_pt_len
\js // - In the end for generated CMO we just store the original axlen and not the +1 modification to it.  Thats why its all - 1
\jsbegin
// No owo on 3.7.0
    if (owo) { \jsend
   assign n_owo_beats = (t_pt_err & (|w_pt_atop)) ? {{BWL{1'b0}},1'b1} : w_pt_cmr[1] ? \=BWL+1=\'b0 :
		       (           t_pt_csr) ? {{BWL{1'b0}},1'b1}: //'h1 
		       ((w_pt_burst==2'h2) & (w_pt_len<8'd\=BPL=\)) ? (generated_cmo) ? w_pt_len[BWL:0] : w_pt_len[BWL:0] + 1'b1 :
		       (({1'b0,w_pt_len}+1'b1)>={\=9-(BWL+1)=\'b0,t_pt_beats}) ? (generated_cmo ? (t_pt_beats[0+:BWL+1] - 1'b1) : t_pt_beats[0+:BWL+1]):
                       ((generated_cmo) ? w_pt_len[BWL:0] : w_pt_len[BWL:0] + 1'b1);
\js } else {
   assign n_owo_beats = n_oc_beats;
\js }


\jsbegin
// This would only be possible with a 16-bit data bus (CLO-log2(16/8)=6-1)
/* istanbul ignore if env ncore_3p7 */
    if (BWL==5) { \jsend
    assign n_oc_beats_adj = n_oc_beats;
\js } else {
    assign n_oc_beats_adj = {\=5-BWL=\'b0,n_oc_beats};
\js }

\js // FIXME Spyglass W1641 : w_pt_len width contain the AXI len whereas t_pt_len has a max beats of 4 for a single tranasaction.

wire [2:0] t_pt_beats_m1;
\js if (BWL>=3) {
wire t_pt_beats_m1_underflow;
assign {t_pt_beats_m1_underflow,t_pt_beats_m1} = t_pt_beats[0 +: BWL+1] - 3'b1;
\js } else {
assign t_pt_beats_m1 = t_pt_beats[0 +: BWL+1] - 3'b1;
\js }
  assign t_pt_len = (t_pt_cmo | t_pt_csr) ? 3'b0 :
		    ((w_pt_burst==2'h2) & (w_pt_len<8'd\=BPL=\)) ? w_pt_len[2:0] :
		    (({1'b0,w_pt_len}+9'h1)>={\=9-(BWL+1)=\'b0,t_pt_beats}) ? t_pt_beats_m1:
						  w_pt_len[2:0];

   assign w_w1_beats = \=BWL+1=\'d\=BPL=\ - w_w1_addr[AWL +: BWL];
   assign t_w1_beats = ((w_w1_burst==2'h2) & (w_w1_len<8'd\=BPL=\)) ? w_w1_len[BWL:0] + 1'b1 :
		       (w_w1_len >= {{7-BWL{1'b0}},w_w1_beats}) ? w_w1_beats :
		       w_w1_len[BWL:0] + 1'b1;

\jsbegin
// Can Never be true because log2ceil(OCN) <= Max(log2ceil(OCN),log2ceil(STA)
/* istanbul ignore if env ncore_3p4,ncore_3p6,ncore_3p7 */
    if(OLA>XTA) { \jsend
      assign n_oc_dptr = //(| t_oc_lhit) ? q_oc_dptr[w_oc_lhid] : 
			 (w_pt_write & ~w_pt_wake) ? {{OLA-XTA{1'b0}},w_pt_kid} :
			 q_od_wptr;
\js } else {
      assign n_oc_dptr = //(| t_oc_lhit) ? q_oc_dptr[w_oc_lhid] : 
			 (w_pt_write & ~w_pt_wake) ? w_pt_kid[OLA-1:0] :
			 q_od_wptr;
\js }
   
   assign n_oc_eob = (w_pt_burst==2'h2) ? (w_pt_len < 8'd\=BPL=\) :
		     (({{\=9-BWL=\{1'b0}},w_pt_addr[AWL+:BWL]} + {1'b0, w_pt_len})<9'd\=BPL=\);

   wire [1:0] w_pt_phase = (w_pt_wake) ? t_oc_phase[w_pt_kid] : 2'd0;
   wire w_pt_oldest = (w_pt_wake) ? t_oc_oldest[w_pt_kid] : 1'd0;
   wire w_pt_owner = (w_pt_wake) ? t_oc_owned[w_pt_kid] : 1'd0;

   \=u.instance({
        moduleName: 'ioaiu_command_decode',
        instanceName: 'ioaiu_command_decode',
        params: {
	   cm_type: cm_type,
	   atomic : (axiParams.eAtomic ? 1 : 0),
	   axi : AXI,
	   stash : (axiParams.eStash ? 1 : 0),
           ift : (axiParams.eDomain ? 1 : 0),
           dvm : isDvmAgent,
	   owo : owo
	},
        verilogParams: {},
        ports: {
           owo_allow_make_unique: 't_cfg_owo_allow_make_unique',
           w_pt_write: 'w_pt_write',
           w_pt_domain: 'w_pt_domain',
           w_pt_snoop: 'w_pt_snoop',
           t_pt_partial: 't_pt_partial',
           w_c2_room: 'w_c2_room',
           w_pt_cache: 'w_pt_cache',
           w_pt_atop: 'w_pt_atop',
	   w_pt_phase: 'w_pt_phase',
	   w_pt_oldest: 'w_pt_oldest',
	   w_pt_owner: 'w_pt_owner',	   
	   w_pt_coherent: 't_pt_coherent',
           w_p2_valid: 'w_p2_valid',
           t_pt_ReadNoSnoop: 't_pt_ReadNoSnoop',
           t_pt_ReadValid: 't_pt_ReadValid',
           t_pt_ReadShared: 't_pt_ReadShared',
           t_pt_ReadClean: 't_pt_ReadClean',
           t_pt_ReadNotSharedDirty: 't_pt_ReadNotSharedDirty',
           t_pt_ReadUnique: 't_pt_ReadUnique',
           t_pt_CleanShared: 't_pt_CleanShared',
           t_pt_CleanSharedPersist: 't_pt_CleanSharedPersist',
           t_pt_CleanUnique: 't_pt_CleanUnique',
           t_pt_MakeUnique: 't_pt_MakeUnique',
           t_pt_CleanInvalid: 't_pt_CleanInvalid',
           t_pt_MakeInvalid: 't_pt_MakeInvalid',
           t_pt_ReadOnceMakeInvalid: 't_pt_ReadOnceMakeInvalid',
           t_pt_DvmMessage: 't_pt_DvmMessage',
           t_pt_StashOnceShared: 't_pt_StashOnceShared',
           t_pt_StashOnceUnique: 't_pt_StashOnceUnique',
           t_pt_WriteNoSnoop: 't_pt_WriteNoSnoop',
           t_pt_WriteUniqueRd: 't_pt_WriteUniqueRd',
           t_pt_WriteLineUniqueLine: 't_pt_WriteLineUniqueLine',
           t_pt_WriteClean: 't_pt_WriteClean',
           t_pt_WriteBack: 't_pt_WriteBack',
           t_pt_AceEvict: 't_pt_AceEvict',
           t_pt_WriteEvict: 't_pt_WriteEvict',
           n_mrc0_cmd: 'n_cmd_req0_cmd'
        },
        portsDelimiter: '\n\t'
   })=\


   assign n_cmd_req0_tr =  w_p2_valid ? w_pt_trace : q_oc_trace[w_pvc_oid];
				 
   assign n_cmd_req0_ts = 1'b0;
   assign n_cmd_req0_st = (w_p2_valid & (t_pt_ReadNoSnoop |
				     t_pt_CleanShared | 
				     t_pt_CleanSharedPersist | 
				     t_pt_CleanInvalid | 
				     t_pt_MakeInvalid | 
				     t_pt_WriteNoSnoop)) ? (~| w_pt_atop) & (~| w_pt_cache[3:1]) : 1'b0;
   
   assign n_cmd_req0_ch = ((n_cmd_req0_cmd != ReadNonCoherent) & 
		      w_p2_valid) ? ((| w_pt_cache[3:2]) | 
\js if (axiParams.eDomain) {
		                       1'b0 ) : 1'b0;
\js } else {
		      (           ~w_amc_nc)) : 1'b0;
\js } 
   assign n_cmd_req0_ca = w_p2_valid & (| w_pt_atop) |
\js if (axiParams.eDomain) {
                                       1'b0 |
\js } else {
                     (           ~w_amc_nc & ~generated_writeback) |
\js }
		      (~t_pt_DvmMessage &
		      ~((t_pt_ReadNoSnoop |
			 t_pt_WriteNoSnoop) & w_pt_lock) &
				 ~((t_pt_ReadNoSnoop | 
				    t_pt_CleanShared | 
				    t_pt_CleanSharedPersist | 
				    t_pt_CleanInvalid | 
				    t_pt_MakeInvalid | 
				    t_pt_WriteNoSnoop |
				    t_pt_WriteClean |
				    t_pt_WriteBack |
				    t_pt_WriteEvict) & (~| w_pt_cache[3:2])));
				   
   assign n_cmd_req0_ac_int = (~w_p2_valid) || //&& (n_cmd_req0_cmd == WriteNonCohFull)) || // cache eviction CONC-9232
   (w_p2_valid && (((~t_pt_ReadOnceMakeInvalid & ~t_pt_AceEvict & ~t_pt_DvmMessage & ~((t_pt_ReadNoSnoop | t_pt_WriteNoSnoop) & w_pt_lock) &
                     ((| w_pt_atop) |
                      (w_pt_write & (t_pt_WriteEvict)) |   //WriteEvict
                      (w_pt_write ? (w_pt_cache[3] & ~(w_amc_nc & t_pt_partial)) | (| cp2_hits_i) :
                       (w_pt_cache[2] & ~(w_amc_nc & t_pt_partial)) | (| cp2_hits_i)))))));

   assign n_cmd_req0_ac = (~w_p2_valid) || //&& (n_cmd_req0_cmd == WriteNonCohFull)) || // cache eviction CONC-9232
   (w_p2_valid && (((~t_pt_ReadOnceMakeInvalid & ~t_pt_AceEvict & ~t_pt_DvmMessage & ~((t_pt_ReadNoSnoop | t_pt_WriteNoSnoop) & w_pt_lock) &
		     ((| w_pt_atop) |
	              (w_pt_write & (t_pt_WriteEvict)) |   //WriteEvict
		      (w_pt_write ? (w_pt_cache[3] & ~cp2_alloc_o & ~(|w_c2_state)) :
		                    (w_pt_cache[2] & ~cp2_alloc_o) ))))));
   
   assign n_cmd_req0_rl = (w_pt_cmo & n_cmd_req0_vz) ? 2'h2 : 2'h1;

   \js // TODO Case Statement
   assign n_cmd_req0_vz = (w_p2_valid ? ((~| w_pt_atop) & 
				     ~(~w_pt_write & 	
				       ((w_pt_snoop==4'h1) |   //ACE ReadShared
					(w_pt_snoop==4'h2) |   //ACE ReadClean
					(w_pt_snoop==4'h3) |//ACE ReadNotSharedDirty
					(w_pt_snoop==4'h7) |   //ACE ReadUnique
					//(w_pt_snoop==4'hb) |   //ACE CleanUnique
					(w_pt_snoop==4'hc) |   //ACE MakeUnique
					(w_pt_snoop==4'hf))) & //ACE DvmMessage
				     ~(w_pt_write & 	
				   (w_pt_snoop==4'h4)) &   //ACE Evict
				     ((((w_pt_domain==2'h0) | 
					(w_pt_domain==2'h3)) & (w_pt_snoop==4'h0) &
				       w_pt_lock) |	//non-coherent exclusive
				      t_pt_cmo | 
\js if (owo) {
                                      w_pt_write |
\js }
				      (((w_pt_cache==4'h0) | 
					(w_pt_cache==4'h2))))) : (t_pt_dii ? 1'b1 : 1'b0));
  
\js //////////////////////////////////////////////////////////////////////////
\js // OR ordering encoding as per tables 7,8 and 9 in PCIe spec
\js //////////////////////////////////////////////////////////////////////////
   wire NotSomeCmds = ~t_pt_ReadValid & ~t_pt_ReadShared & ~t_pt_ReadClean & ~t_pt_ReadNotSharedDirty &
	~t_pt_ReadUnique & ~t_pt_CleanShared & ~t_pt_CleanSharedPersist & ~t_pt_CleanUnique &
	~t_pt_MakeUnique & ~t_pt_CleanInvalid & ~t_pt_MakeInvalid & ~t_pt_DvmMessage &
	~t_pt_StashOnceShared & ~t_pt_StashOnceUnique & ~t_pt_WriteUniqueRd & ~t_pt_WriteLineUniqueLine &
	~t_pt_AceEvict;
  
 \js // For OWO make writes have write order, always use WriteID, and keep the Device order override. 
 wire [4:0] mod_amc_order;
\jsbegin
// No owo on 3.7.0
     if (owo) { \jsend
 assign mod_amc_order = (w_pt_write) ? {3'b010,w_amc_order[1:0]} : w_amc_order[4:0];
 \js } else {
 assign mod_amc_order = w_amc_order[4:0];
 \js }
 
 always @(*) begin // add unique for checking with SV.
  casez ({w_p2_valid, w_pt_write, (cfg_wproducer_i==2'h2), (cfg_rproducer_i==2'h2), w_pt_cache[3:0], mod_amc_order[4:0]})
    13'b1_0_?1_000?_????0 : n_cmd_req0_or = 2'b11; // Device read
    13'b1_1_1?_000?_????0 : n_cmd_req0_or = 2'b11; // Device write

    13'b1_0_?1_??1?_10?00 : n_cmd_req0_or = 2'b10; // Memory read, ARID order
    13'b1_0_?1_??1?_11??0 : n_cmd_req0_or = 2'b11; // Memory read, Endpoint order
    13'b1_0_?1_??1?_01??0 : n_cmd_req0_or = 2'b01; // Memory read, Write Order // JIRA 9674
    13'b1_0_?1_??1?_00??0 : n_cmd_req0_or = 2'b11; // Memory read, Endpoint order // JIRA 7858+
    13'b1_0_?1_??1?_10?10 : n_cmd_req0_or = 2'b00; // Memory read, No dependency

    13'b1_1_1?_??1?_100?0 : n_cmd_req0_or = 2'b10; // Memory write, AWID order
    13'b1_1_1?_??1?_11??0 : n_cmd_req0_or = 2'b11; // Memory write, Endpoint order
    13'b1_1_1?_??1?_01??0 : n_cmd_req0_or = 2'b01; // Memory write, Write Order order // JIRA 9674
    13'b1_1_1?_??1?_00??0 : n_cmd_req0_or = 2'b11; // Memory write, Endpoint order // JIRA 7858+
    13'b1_1_1?_??1?_101?0 : n_cmd_req0_or = 2'b00; // Memory write, No dependency

    default : n_cmd_req0_or = (w_p2_valid && (NotSomeCmds || t_cfg_order)) ? {1'b1, (~|w_pt_cache[3:1])} : 2'd0;
  endcase
 end
//////////////////////////////////////////////////////////////////////////

   wire [MRC1-1:0] w_pt_atop_tmp;
\js if (!axiParams.eAtomic) {
    assign w_pt_atop[5:1] = 5'b0;
\js }

\js if (concParams.cmdReqParams.wMpf1>(axiParams.eAtomic?6:1)) {
    assign w_pt_atop_tmp = {{MRC1-AWTW{1'b0}},w_pt_atop[AWTW-1:0]};
\js } else {
    assign w_pt_atop_tmp = w_pt_atop[MRC1-1:0];
\js }

   wire [MRC1-1:0] n_cmd_req0_mpf1_tmp;
   wire [7:0] 	   w_pt_burst_size_len = {w_pt_burst, w_pt_size, t_pt_len};

\js if (concParams.cmdReqParams.wMpf1>8) {
     assign n_cmd_req0_mpf1_tmp = {{MRC1-8{1'b0}},w_pt_burst_size_len};
\js } else {
     assign n_cmd_req0_mpf1_tmp = w_pt_burst_size_len[MRC1-1:0];
\js }

   assign n_cmd_req0_mpf1 = (| w_pt_atop) ? w_pt_atop_tmp :
			t_pt_stash ? {w_pt_stashniden, {MRC1-1{1'b0}}} |
			{{(MRC1-\=Math.min(FIDW, concParams.cmdReqParams.wMpf1-1)=\){1'b0}}, w_pt_stashnid[0 +: \=Math.min(FIDW, concParams.cmdReqParams.wMpf1-1)=\]} :
			(w_pt_write & ~w_pt_bar[0] &
			(//(w_pt_snoop==4'h2) | 	//ACE WriteClean
			 //(w_pt_snoop==4'h3) | 	//ACE WriteBack
			 //(w_pt_snoop==4'h5) |		//ACE WriteEvict
			 (((w_pt_domain == 2'h1) | (w_pt_domain == 2'h2)) &
			  ((w_pt_snoop==4'h0) |		//WriteUnique
			   (w_pt_snoop==4'h1)))) &	//WriteLineUnique
			(CDW>1)) ? {{MRC1-1{1'b0}}, t_pt_unique} :
			n_cmd_req0_mpf1_tmp;
   
wire [\=MRC2-1=\:0] q_oc_id_tmp =
\jsbegin
// FlowId should always be 1 more than greatest axiId in 3.7
/* istanbul ignore else env ncore_3p7 */
    if (MRC2>IW) { \jsend
                                {{\=MRC2-IW=\{1'b0}},q_oc_id[w_pvc_oid]}; 
\js } else {
                                q_oc_id[w_pvc_oid]; 
\js }
wire [\=MRC2-1=\:0] w_pt_id_mpf2_tmp =
\jsbegin
// FlowId should always be 1 more than greatest axiId in 3.7
/* istanbul ignore else env ncore_3p7 */
    if (MRC2>IW) { \jsend
                                {{\=MRC2-IW=\{1'b0}},w_pt_id};
\js } else {
                                w_pt_id;
\js }
wire [\=MRC2-1=\:0] t_pt_lpid_tmp =
\jsbegin
// FlowId should always be 1 more than greatest axiId in 3.7
/* istanbul ignore else env ncore_3p7 */
    if (MRC2>IW) { \jsend
                                {{\=MRC2-LIDW=\{1'b0}},t_pt_lpid};
\js } else {
                                t_pt_lpid;
\js }
wire [\=MRC2-1=\:0] w_pt_stashlpid_tmp =
\js if (MRC2>5) {
                                {{\=MRC2-5=\{1'b0}},w_pt_stashlpid[0 +: \=Math.min(5, concParams.cmdReqParams.wMpf2-1)=\]};
\js } else {
                                w_pt_stashlpid[0 +: \=Math.min(5, concParams.cmdReqParams.wMpf2-1)=\];
\js }

   assign n_cmd_req0_mpf2 = ~w_p2_valid ? 
\jsbegin
// wArId/wAwId minimum value of 1 in 3.7
/* istanbul ignore else env ncore_3p4,ncore_3p6,ncore_3p7 */
    if (Math.max(axiParams.wArId,axiParams.wAwId)>0) { \jsend
			~({MRC2{1'b1}}>>1) | q_oc_id_tmp :
\js } else {
			 ({MRC2{1'b1}}>>1) & q_oc_id_tmp :
\js }
			t_pt_stash ? ({MRC2{w_pt_stashlpiden}} & 
			~({MRC2{1'b1}}>>1)) |
			w_pt_stashlpid_tmp :
			((n_cmd_req0_cmd == ReadNonCoherent) |
			(n_cmd_req0_cmd == WriteNonCohFull) |
			(n_cmd_req0_cmd == WriteNonCohPtl)) ?
\jsbegin
// wArId/wAwId minimum value of 1 in 3.7
/* istanbul ignore else env ncore_3p4,ncore_3p6,ncore_3p7 */
    if (Math.max(axiParams.wArId,axiParams.wAwId)>0) { \jsend
			~({MRC2{1'b1}}>>1) | w_pt_id_mpf2_tmp :
\js } else {
			 ({MRC2{1'b1}}>>1) & w_pt_id_mpf2_tmp :
\js }
			(((LIDE>0) & (NPROCS > 1)) ? ~({MRC2{1'b1}}>>1) | t_pt_lpid_tmp :
			(~({MRC2{1'b1}}>>1))); \js // Make ID 0 and Flow Valid 1 in case of No Proc Select Bits

   assign n_cmd_req0_ns = w_p2_valid ? w_pt_security : q_oc_security[w_pvc_oid];
   assign n_cmd_req0_es = (~| w_pt_atop) ? (w_pt_lock & w_p2_valid) : (((CACHE>0) | (CDW>1)) & w_p2_valid & (| w_pt_cache[3:2]));
   assign n_cmd_req0_pr = w_p2_valid ? w_pt_pr : 1'b0;
   
   assign non_coh_ex = ( w_p2_valid ? (w_pt_lock & ~t_pt_evict) : (q_oc_lock[w_pvc_oid] & ~t_oc_evict[w_pvc_oid])) & (t_pt_dii | (t_pt_dmi & ~t_pt_dce));

   // CONC-11485
   // In Concerto, The data accessed is aligned to the amount of data that is being requested.
   // So if for example 32B of data is being accessed, however the start address isnt aligned to the 32B, then 64B of data needs to be retrieved.
   // This is because the data accessed is past that 32B boundary

   reg  [2:0]       r_cmd_req0_size;
   reg              cross_boundary;
   wire             single_beat = (n_oc_beats == \=BWL+1=\'d1);
   wire             is_atomic = |w_pt_atop;
   wire             is_excl = w_pt_lock;
   wire             is_incr = (w_pt_burst == 2'b01);
   wire             eligible_to_modify = is_incr & !is_excl & !is_atomic;
   
   // Data accessed has to be a multiple of 16B (64bits since that is the smallesnt width, and more than 1 beat)
   wire [BWL+AWL:0]  data_accessed = {n_oc_beats, {AWL{1'b0}}};
   
   wire accessed_16B = (data_accessed <= 16);
   wire accessed_32B = (data_accessed <= 32);

   always @ (*) begin
      casez({single_beat, accessed_16B, accessed_32B}) 
      	3'b1??  : begin
\js //        r_cmd_req0_size = (t_pt_dii & w_pt_cache[1]) ? 3'd\=log2ceil(DW/8)=\ : w_pt_size;
	             r_cmd_req0_size = w_pt_size;
		  end
	3'b011  : begin
	             r_cmd_req0_size = \js if (DW == 64) {
		                   ((w_pt_addr[5:4] == 2'b01) & eligible_to_modify)   ? 3'h6 : 		     		                   
				   \js } 
		                   ((|w_pt_addr[3:0]) & eligible_to_modify)           ? 3'h5 : 3'h4;		     
		  end
	3'b001  : begin
	             r_cmd_req0_size = ((|w_pt_addr[4:0]) & eligible_to_modify)           ? 3'h6 : 3'h5;		     
		  end
	default : begin
	             r_cmd_req0_size = 3'h6;		     
		  end
      endcase
   end

   wire full_cache_line_size = ((~(t_pt_dii) & ~is_atomic) | cp2_alloc_o | t_pt_cmo | ~w_p2_valid) & ~non_coh_ex;
   
   assign n_cmd_req0_size = full_cache_line_size ? 3'h6 : r_cmd_req0_size;
			
   assign n_cmd_req0_did = ({FIDW{t_pt_dmi}} & w_amc_fids[1*FIDW +: FIDW]) | ({FIDW{t_pt_dii}} & w_amc_fids[2*FIDW +: FIDW]);
   assign n_cmd_req0_qos = w_p2_valid ? w_pt_qos : q_oc_qos[w_pvc_oid];
   assign n_cmd_req0_user = w_p2_valid ? w_pt_user : {AXUW{1'b0}};

   wire [63:0]	t_dve_addr = {{64-AW{1'b0}},w_pt_addr};
   wire [43:0] 	n_cmd_req0_addr_tmp = {
                1'b0,                   // [43:43] Reserved
                1'b0,                   // [42:42] Reserved (CHI has NUM[4])
                t_dve_addr[7],          // [41:41] Range
                t_dve_addr[4],		// [40:40] LeafEntry Invalidation
		t_dve_addr[3:2],	// [39:38] Staged Invalidation
		t_dve_addr[39:32],	// [37:30] ASID[15:8]
		t_dve_addr[23:16],	// [29:22] ASID[7:0] or VA[19:12]
		t_dve_addr[31:24],	// [21:14] VMID[7:0] or VA[27:20]
		t_dve_addr[14:12],	// [13:11] DVMOp Type
		t_dve_addr[11:10],	// [10: 9] Guest/Hypervisor
		t_dve_addr[9:8],	// [ 8: 7] Security
		t_dve_addr[5],		// [ 6: 6] ASID_valid
		t_dve_addr[6],		// [ 5: 5] VMID_vlaid
		t_dve_addr[0],		// [ 4: 4] 2-part message
		2'b0,                   // [ 3: 2] Reserved
		t_dve_addr[1],		// [ 1: 1] Reserved
		1'b0};                  // [ 0: 0]   

\js if (concParams.cmdReqParams.wAddr>44) {
      assign n_cmd_req0_addr = t_pt_dve ? {{MRCA-44{1'b0}},n_cmd_req0_addr_tmp} :
		     		 	w_p2_valid ? t_dve_addr[MRCA-1:0] : q_oc_addr[w_pvc_oid][AW-1:0];
\js } else {
      assign n_cmd_req0_addr = t_pt_dve ? n_cmd_req0_addr_tmp[MRCA-1:0] : w_p2_valid ? t_dve_addr[MRCA-1:0] : q_oc_addr[w_pvc_oid][AW-1:0];
\js }

   wire [MRCM-1:0] w_pt_kid_tmp;
   wire [MRCM-1:0] q_oc_wptr_tmp;
   wire [MRCM-1:0] w_pvc_oid_tmp;
  
\jsbegin
// wMsgId is always be 1 more than greatest of OCA/STA in 3.7
/* istanbul ignore else env ncore_3p7 */
    if(concParams.hdrParams.wMsgId>XTA) { \jsend
      assign w_pt_kid_tmp = {{MRCM-XTA{1'b0}},w_pt_kid};
      assign q_oc_wptr_tmp = {{MRCM-OCA{1'b0}},q_oc_wptr};
      assign w_pvc_oid_tmp = {{MRCM-OCA{1'b0}},w_pvc_oid};
\jsbegin
    } else { /* istanbul ignore else env ncore_3p7 */ if (concParams.hdrParams.wMsgId>OCA) { \jsend
      assign w_pt_kid_tmp = w_pt_kid[MRCM-1:0];
      assign q_oc_wptr_tmp = {{MRCM-OCA{1'b0}},q_oc_wptr};
      assign w_pvc_oid_tmp = {{MRCM-OCA{1'b0}},w_pvc_oid};
\js } else {
      assign w_pt_kid_tmp = w_pt_kid[MRCM-1:0];
      assign q_oc_wptr_tmp = q_oc_wptr[MRCM-1:0];
      assign w_pvc_oid_tmp = w_pvc_oid[MRCM-1:0];
\js } }

   assign n_cmd_req0_mid = (w_p2_valid & w_pt_wake) ? w_pt_kid_tmp :
		       w_p2_valid ? q_oc_wptr_tmp :
		       w_pvc_oid_tmp;

   assign n_cmd_req0_iid = myid_i;

\js if (nSelectBits>0) {
\js   for (let i=0; i<nSelectBits; i=i+1) {
	 assign n_upd_req0_doff[\=i=\] = (^ {n_upd_req0_addr[\=PRIS[i]=\], 
				     (n_upd_req0_addr & \=concParams.updReqParams.wAddr=\\=SECS[i]=\)});
\js   }
\js } else {
      assign n_upd_req0_doff = 1'b0;
\js }

   assign amc_val_o = ((P1EN>0) ? (w_p1_valid & ~w_p1_cmr[1] & ~t_p1_dve & 
				   ~t_p1_dvm & ~(w_p1_snp)) :
		      (w_p2_valid & ~w_pt_cmr[1] & ~t_pt_dve & 
		       ~t_pt_dvm & ~(w_pt_snp))) |
                      n_pvc_valid;
   assign {amc_security_o,
     amc_addr_o} = ((P1EN>0)  & w_p1_valid & ~w_p1_cmr[1] & ~t_p1_dve & ~t_p1_dvm & ~(w_p1_snp)) ? {w_p1_security, w_p1_addr} :
		   ((P1EN==0) & w_p2_valid & ~w_pt_cmr[1] & ~t_pt_dve & ~t_pt_dvm & ~(w_pt_snp)) ? {w_pt_security, w_pt_addr} : 
                   {n_pvc_security, n_pvc_addr};
   
   assign amc_ignore_o = ~((P1EN>0)  & w_p1_valid & ~w_p1_cmr[1] & ~t_p1_dve & ~t_p1_dvm & ~(w_p1_snp)) &
			 ~((P1EN==0) & w_p2_valid & ~w_pt_cmr[1] & ~t_pt_dve & ~t_pt_dvm & ~(w_pt_snp)) &
                         ~n_pvc_valid;

   assign t_pt_coherent = (w_pt_wake) ? t_oc_coh[w_pt_kid] : ~(t_pt_dii | (t_pt_dmi & ~t_pt_dce));

   \js if (isDvmAgent) {
   assign t_p1_dve = w_p1_valid & ~w_p1_write & (w_p1_snoop==4'hf);
   assign t_pt_dve = w_p2_valid & ~w_pt_write & (w_pt_snoop==4'hf);
   \js } else {
   assign t_p1_dve = 1'b0;
   assign t_pt_dve = 1'b0;   
   \js }

   wire atomic = (| w_pt_atop);
   wire non_alloc = (~| w_pt_cache[3:2]);
   wire domain_zero_or_three = ((w_pt_domain==2'h0) | (w_pt_domain==2'h3));

   always @ (*) begin
   	  casez({w_p2_valid,t_pt_dve,domain_zero_or_three,w_pt_write,w_pt_snoop,atomic,non_alloc})
		10'b0_?_?_?_????_?_?: r_pt_dce = 1'b0;
		10'b1_1_?_?_????_?_?: r_pt_dce = 1'b0;
\jsbegin
// No owo on 3.7.0
		    if (owo) { \jsend
		10'b1_0_?_1_0000_0_?: r_pt_dce = 1'b0; //Non-Coherent - Snoop 0 cannot go to DCE for writes. (Only CMOs will)
\js //          10'b1_0_?_1_0000_1_0: r_pt_dce = 1'b0; //Non-Coherent - Snoop 0 cannot go to DCE for writes. (Only CMOs will)
                10'b1_0_1_0_0000_0_?: r_pt_dce = 1'b0; //Non-Coherent
                10'b1_0_1_?_0000_1_0: r_pt_dce = 1'b0; //Non-Coherent
		\js } else {
                10'b1_0_1_?_0000_?_?: r_pt_dce = 1'b0; //Non-Coherent 
\js //          10'b1_0_1_?_0000_1_0: r_pt_dce = 1'b0; //Non-Coherent 
		\js }
		\js if (!AXI) {		
		10'b1_0_1_0_1000_0_?: r_pt_dce = 1'b0; //CleanShared  
		10'b1_0_1_0_1001_0_?: r_pt_dce = 1'b0; //CleanInvalid
		10'b1_0_1_0_1010_0_?: r_pt_dce = 1'b0; //CleanSharedPersist
		10'b1_0_1_0_1101_0_?: r_pt_dce = 1'b0; //MakeInvalid

		10'b1_0_?_1_0010_0_?: r_pt_dce = 1'b0; //ACE WriteClean
		10'b1_0_?_1_0011_0_?: r_pt_dce = 1'b0; //ACE WriteBack
		10'b1_0_?_1_0100_0_?: r_pt_dce = 1'b0; //ACE Evict
		10'b1_0_?_1_0101_0_?: r_pt_dce = 1'b0; //ACE WriteEvict
		\js }
                \js if (axiParams.eAtomic ? 1 : 0) {
                10'b1_0_0_1_0000_1_1: r_pt_dce = 1'b0; //Non-Coh Atomic
                \js }
		default: r_pt_dce = 1'b1;
	  endcase
   end
		    
   assign t_pt_dce = r_pt_dce;

   assign t_pt_dmi = w_amc_vals[1];
   assign t_pt_dii = w_amc_vals[2];
   assign t_pt_csr = w_amc_vals[3] | t_pt_dvm | w_pt_bar[0];

   \js if (isDvmAgent) {
   assign t_p1_dvm = w_p1_valid & ~w_p1_write & ~w_p1_bar[0] & (w_p1_snoop==4'he) &
		     ((t_p1_domain == 2'h1) | (t_p1_domain == 2'h2));
   assign t_pt_dvm = w_p2_valid & ~w_pt_write & ~w_pt_bar[0] & (w_pt_snoop==4'he) &
		     ((w_pt_domain == 2'h1) | (w_pt_domain == 2'h2));
   \js } else {
   assign t_p1_dvm = 1'b0;
   assign t_pt_dvm = 1'b0;  
   \js }

  assign t_pt_err = t_pt_uerr | (w_pt_wake ? (q_oc_val[w_pt_kid] & q_oc_status[w_pt_kid][7]) : 1'b0);
   
   assign t_pt_illegal_csr_access_format = t_pt_dii & w_amc_nrs_region_hit &
                                            ((|w_pt_addr[1:0]) |
                                             (w_pt_size != 3'h2) |
                                             (|w_pt_cache[3:1]));

   assign t_pt_illegal_dii_access_type = t_pt_dii & ((| w_pt_snoop & ~t_pt_cmo & ~t_pt_wns) |
                                           (w_pt_domain==2'h1) |
                                           (w_pt_domain==2'h2));

   assign t_pt_uerr = t_pt_uerr_dec | t_pt_uerr_config;

   assign t_pt_uerr_dec =                 w_pt_valid & (w_pt_snoop<4'he) &
		      (t_pt_illegal_dii_access_type |
                       t_pt_illegal_csr_access_format |
		      (| w_amc_errs));
   
   assign t_pt_uerr_config =                 w_pt_valid & (w_pt_snoop<4'he) &
                      ((t_pt_dce & w_amc_unconnected_dce_access) | w_amc_unconnected_dmi_access | w_amc_unconnected_dii_access ) | ( no_credit_access ) ;

   assign n_cmd_req0_tid = {((n_cmd_req0_cmd == DVMOp) ? dve_ids_i[0 +: FIDW] :
			 t_pt_dce ? w_amc_fids[0*FIDW +: FIDW] : 
			 ({FIDW{t_pt_dmi}} & w_amc_fids[1*FIDW +: FIDW]) |
			 ({FIDW{t_pt_dii}} & w_amc_fids[2*FIDW +: FIDW])), {PIDW{1'b0}}};

\js if (nSelectBits>0) {
   assign n_upd_req0_tid = {dce_ids_i[n_upd_req0_doff*FIDW +: FIDW], {PIDW{1'b0}}};
\js } else {
   assign n_upd_req0_tid = {dce_ids_i[          0*FIDW +: FIDW], {PIDW{1'b0}}};
\js }

\js // These ties are here for the tb. If renamed from the tb, then can be removed here.
wire n_mrc0_valid = n_cmd_req0_valid;
wire [MRCM-1:0] n_mrc0_mid = n_cmd_req0_mid;

   assign n_cmd_req0_valid = t_pt_ok & 
			  (w_pt_valid ? (n_pt_ready & ~(w_pt_snp)&
					 ~(t_pt_dve & ~w_pt_wake & t_dve_state) & 
					 ~t_pt_evict &
                                         ~(t_pt_WriteNoSnoop & ~t_pt_partial & w_amc_nc & w_pt_cache[3] & w_c2_room) &
					 ~t_pt_csr & ~t_pt_err & ~w_pt_cmr[1] &
					 (~| t_oc_ahit) & ~w_c2_chit & ~w_c2_retry):
				    (w_pvc_valid & ~(w_p2_valid & (t_pe_correctable_error | t_pt_correctable_error))));
   
   assign n_cmd_req0_valid_no_err = t_pt_ok_no_err &
                          ((w_p2_valid & ~t_pe_correctable_error & ~1'b0      ) ? ((~1'b0       & ~t_pe_correctable_error) & ~(w_pt_snp)&
                                         ~(t_pt_dve & ~w_pt_wake & t_dve_state) &
                                         ~t_pt_evict &
                                         ~(t_pt_WriteNoSnoop & ~t_pt_partial & w_amc_nc & w_pt_cache[3] & w_c2_room) &
                                         ~t_pt_csr & ~1'b0     & ~w_pt_cmr[1] &
                                         (~| t_oc_ahit) & ~w_c2_chit & ~(cp2_valid_i & (1'b0          |cp2_nacks_i[0]))):
                                    (w_pvc_valid & ~(w_p2_valid & (t_pe_correctable_error | 1'b0      ))));

   assign n_cmd_req0_incs = {4{w_cmd_req0_ready & n_cmd_req0_valid}} & {t_pt_dve,
     t_pt_dii & ~t_pt_dce,
     t_pt_dmi & ~t_pt_dce,
     t_pt_dce};
   
   assign n_cmd_req0_incs_no_err = {4{w_cmd_req0_ready & n_cmd_req0_valid_no_err}} & {t_pt_dve,
     t_pt_dii & ~t_pt_dce,
     t_pt_dmi & ~t_pt_dce,
     t_pt_dce};

   assign t_pt_skid = ~t_pt_ok & (~| t_oc_ahit) & ~t_pt_dvm & 
		      ~(t_pt_dve & ~w_pt_wake & t_dve_state);
   
   wire wakeup_in_progress = t_poc_valid | (w_p0_valid & w_p0_wake) | (w_p1_valid & w_p1_wake);

\js if (nDIIs>1) {
wire mux_dii_haveNoCredits =
\js for (let j=0;j<nDIIs;j++) {
                         ((w_amc_tins[2*5+:\=log2ceil(nDIIs)=\] == \=log2ceil(nDIIs)=\'d\=j=\) ? w_dii_haveNoCredits[\=j=\] : 1'b0)\=(j==(nDIIs-1))?";":"|"=\
\js }
\js }

\js if (nDMIs>1) {
wire mux_dmi_haveNoCredits =
\js for (let j=0;j<nDMIs;j++) {
                         ((w_amc_tins[1*5+:\=log2ceil(nDMIs)=\] == \=log2ceil(nDMIs)=\'d\=j=\) ? w_dmi_haveNoCredits[\=j=\] : 1'b0)\=(j==(nDMIs-1))?";":"|"=\
\js }
\js }

\js if (nDCEs==1) {
   assign no_credit_access = t_pt_dce ? w_dce_haveNoCredits[0] :
\js } else {
   assign no_credit_access = t_pt_dce ? w_dce_haveNoCredits[w_amc_tins[0*5+:\=log2ceil(nDCEs)=\]] :
\js }
\js if (nDMIs==1) {
                             t_pt_dmi ? w_dmi_haveNoCredits[0] :
\js } else {
                             t_pt_dmi ? mux_dmi_haveNoCredits :
\js }
\js if (nDIIs==1) {
                             t_pt_dii ? w_dii_haveNoCredits[0] : 1'b0;
\js } else {
                             t_pt_dii ? mux_dii_haveNoCredits : 1'b0;
\js }

\js if (nDIIs>1) {
wire mux_dii_boks_ok =
\js for (let j=0;j<nDIIs;j++) {
                                             ((w_amc_tins[2*5+:\=log2ceil(nDIIs)=\] == \=log2ceil(nDIIs)=\'d\=j=\) ? w_dii_boks[\=j=\] : 1'b0)\=(j==(nDIIs-1))?";":"|"=\
\js }
wire mux_dii_woks_ok =
\js for (let j=0;j<nDIIs;j++) {
                                             ((w_amc_tins[2*5+:\=log2ceil(nDIIs)=\] == \=log2ceil(nDIIs)=\'d\=j=\) ? w_dii_woks[\=j=\] : 1'b0)\=(j==(nDIIs-1))?";":"|"=\
\js }
\js }
\js if (nDMIs>1) {
wire mux_dmi_boks_ok =
\js for (let j=0;j<nDMIs;j++) {
                                             ((w_amc_tins[1*5+:\=log2ceil(nDMIs)=\] == \=log2ceil(nDMIs)=\'d\=j=\) ? w_dmi_boks[\=j=\] : 1'b0)\=(j==(nDMIs-1))?";":"|"=\
\js }
wire mux_dmi_woks_ok =
\js for (let j=0;j<nDMIs;j++) {
                                             ((w_amc_tins[1*5+:\=log2ceil(nDMIs)=\] == \=log2ceil(nDMIs)=\'d\=j=\) ? w_dmi_woks[\=j=\] : 1'b0)\=(j==(nDMIs-1))?";":"|"=\
\js }
\js }

   assign t_pt_ok = (w_c2_chit | w_c2_retry | t_pt_snp) ? 1'b1 : t_pt_ok_maybe;
\js //assign t_pt_ok_no_err = (w_c2_chit | (cp2_valid_i & (cp2_nacks_i[2]|cp2_nacks_i[0])) | (w_p2_valid & ~w_pt_write & w_pt_snp & ~t_pt_correctable_error & ~t_pe_correctable_error)) ? 1'b1 : t_pt_ok_maybe;
   assign t_pt_ok_no_err =    (w_c2_chit | (cp2_valid_i & (1'b0          |cp2_nacks_i[0])) | (w_p2_valid & ~w_pt_write & w_pt_snp & ~1'b0       & ~t_pe_correctable_error)) ? 1'b1 : t_pt_ok_maybe;

\js // Use this for canceling the alloc back to the ccp because this excludes the nacks signals,
\js // and this will removed the look from nack->pt_ok->ctrl_op_allocate0->evict
   assign t_pt_ok_maybe = 
		    ((t_cfg_skid | t_sv_starve) & w_p2_valid & ~w_pt_wake) ? 1'b0 :
\js if (!owo) {
                    (wakeup_in_progress & ~w_pt_wake) ? 1'b0 :
\js }
		    (~w_p2_valid |
		    // Cannot ignore write ID ordering rules for Ordered Write Observation
\jsbegin
// 3.7.0 not supporting owo
		        if (!owo) { \jsend
		    ((cfg_wproducer_i==2'h2) & (w_amc_order[2]) & w_pt_write & ~t_cfg_ihit)  |
		    \js }
		    ((cfg_rproducer_i==2'h2) & (w_amc_order[1]) & ~w_pt_write & ~t_cfg_ihit) |
		    ~t_pt_ohit) &
		    (t_cfg_qos | (QOSA==0) |
\js // The tachl parameter QOSN is either 0 or 8
\js if (QOSN==0) {
		    1'b1) &
\js } else {
		    w_qos_boks[n_cmd_req0_qin] | 
		    (w_qos_woks[n_cmd_req0_qin] & w_pt_write)) &
\js }
		    (t_pt_dve ? w_dve_boks[0] :		    
\js if (nDCEs==1) {
                    t_pt_dce ? (w_dce_boks[0] |
				(w_dce_woks[0] & (w_pt_write | (~outstanding_read & w_pt_wake)) )) :
\js } else {
                    t_pt_dce ? (w_dce_boks[w_amc_tins[0*5+:\=log2ceil(nDCEs)=\]] |
                                (w_dce_woks[w_amc_tins[0*5+:\=log2ceil(nDCEs)=\]] & (w_pt_write | (~outstanding_read & w_pt_wake)) )) :
\js }
\js if (nDMIs==1) {
                    t_pt_dmi ? (w_dmi_boks[0] |
                                (w_dmi_woks[0] & (w_pt_write | (~outstanding_read & w_pt_wake)) )) :
\js } else {
		    t_pt_dmi ? (mux_dmi_boks_ok |
				(mux_dmi_woks_ok & (w_pt_write | (~outstanding_read & w_pt_wake)) )) :
\js }
\js if (nDIIs==1) {
                    t_pt_dii ? (w_dii_boks[0] |
                                (w_dii_woks[0] & (w_pt_write | (~outstanding_read & w_pt_wake)) )) :
\js } else {
		    t_pt_dii ? (mux_dii_boks_ok |
				(mux_dii_woks_ok & (w_pt_write | (~outstanding_read & w_pt_wake)) )) :
\js }
		    1'b1);

\js if (OCA>=STA) {
      assign pt_iptr = w_pt_iptr_lookup;
\js } else {
      assign pt_iptr = {{STA-OCA{1'b0}},w_pt_iptr_lookup};
\js }
   
// Ordered Write Observation has differant CMDReq ordering table
// - Wont see DVMs
// - For OWO, if it is woken up then ordering has been satisfied. Wont check ordering in two spots. 
//      - Will rely on t_oc_ohit for new transactions into the pipeline.
//      - If it is upgraded and is coherent the ioaiu should block the CMO.
\jsbegin
// No owo on 3.7.0
    if (owo) { \jsend
   assign t_pt_ohit = ~w_pt_wake ? ((| t_oc_ohit) | (w_pt_upgrade & t_pt_coherent)) : (generated_writeback & ~q_oc_oldest[w_pt_kid]);
\js } else {
   wire pt_val = q_oc_val[w_pt_iptr_lookup];
   wire pt_wfresp = q_oc_wfresp[w_pt_iptr_lookup];
   wire pt_wfstr =  q_oc_wfstr[w_pt_iptr_lookup];
   wire pt_wfdtr = q_oc_wfdtr[w_pt_iptr_lookup];
   wire pt_wfdtw = q_oc_wfdtw[w_pt_iptr_lookup];
   wire pt_wfdtp = q_oc_wfdtp[w_pt_iptr_lookup];
   wire pt_write = q_oc_write[w_pt_iptr_lookup];
   wire pt_wfotail = ~(q_oc_val[w_pt_iptr_lookup] & q_oc_otail[w_pt_iptr_lookup]);
   wire pt_err = q_oc_status[w_pt_iptr_lookup][7];
   wire pt_evict = t_oc_evict[w_pt_iptr_lookup];
   wire pt_cmo = q_oc_cmo[w_pt_iptr_lookup];
   wire [IW-1:0] pt_id = q_oc_id[w_pt_iptr_lookup];

   wire dvm_ohit = (pt_val & pt_wfdtp & (w_pt_kid != pt_iptr));
   wire txn_ohit = ~w_pt_iok |
                      (pt_val &
                      (pt_wfresp | pt_err |
                       (~(w_pt_write | pt_cmo) ? (pt_wfstr & pt_wfdtr) : pt_wfstr) |
                       pt_wfotail |
                       (((pt_wfdtr & ~w_pt_write) |
                         (pt_wfdtw & w_pt_write) |
                         pt_wfdtp) &
                        (w_pt_cache[1] & w_pt_write &
                         (w_amc_order[4:3]==2'h3)))) &
                      (pt_write ~^ w_pt_write) &
                      (w_pt_kid != pt_iptr) &
                      ~pt_evict &
                      ((pt_id == w_pt_id) | t_cfg_ihit));

   assign t_pt_ohit = w_pt_wake ? 
                       (t_pt_dve ? dvm_ohit : txn_ohit) :
                       (| t_oc_ohit);
\js }

\js // Get almost-full functionality by exposing the valids, and seeing how full the fifo is.
wire [3:0] cmd_req0_valids;
assign w_cmd_req0_af = cmd_req0_valids[1];
\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'cmd_req0',
	params: {
                depth:          4,
		width:		1+(MRCA)+MRCM+ioaiu_pos(MRCQ)+AXUW+MRCT+MRCD+
				MRC1+MRC2+21+QOSW+2,
                pipeForward:    "yes",
                pipeBackward:   "yes",
                simplePipe:     "no",
                circular:       "no",
                exposeValids:   "true",
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
                valids:         'cmd_req0_valids',
		in_ready:	'w_cmd_req0_ready',
		in_valid:	'n_cmd_req0_valid',
		in_data:	`{n_cmd_req0_ns, n_cmd_req0_addr, n_cmd_req0_qos, 
				  n_cmd_req0_user, n_cmd_req0_did, 
				  n_cmd_req0_st, n_cmd_req0_ch, n_cmd_req0_ca, n_cmd_req0_ac, 
				  n_cmd_req0_vz, n_cmd_req0_or, n_cmd_req0_tr, 
				  n_cmd_req0_mpf1, n_cmd_req0_mpf2, n_cmd_req0_size, 
				  n_cmd_req0_pr, n_cmd_req0_tid, n_cmd_req0_mid, 
				  n_cmd_req0_es, n_cmd_req0_cmd, n_cmd_req0_qin, n_cmd_req0_rl}`,
		out_ready:	'n_cmd_req0_ready',
		out_valid:	'w_cmd_req0_valid',
		out_data:	`{w_cmd_req0_ns, w_cmd_req0_addr, w_cmd_req0_qos, 
				  w_cmd_req0_user, w_cmd_req0_did, 
				  w_cmd_req0_st, w_cmd_req0_ch, w_cmd_req0_ca, w_cmd_req0_ac, 
				  w_cmd_req0_vz, w_cmd_req0_or, w_cmd_req0_tr, 
				  w_cmd_req0_mpf1, w_cmd_req0_mpf2, w_cmd_req0_size, 
				  w_cmd_req0_pr, w_cmd_req0_tid, w_cmd_req0_mid, 
				  w_cmd_req0_es, w_cmd_req0_cmd, w_cmd_req0_qin, w_cmd_req0_rl}`
	},
	portsDelimiter: '\n\t'
})=\

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'cmd_req1',
	params: {
                depth:          1,
		width:		1+(MRCA)+MRCM+ioaiu_pos(MRCQ)+AXUW+MRCT+MRCD+
				MRC1+MRC2+21+QOSW+2,
                pipeForward:    "no",
                pipeBackward:   "yes",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'n_cmd_req0_ready',
		in_valid:	'w_cmd_req0_valid',
		in_data:	`{w_cmd_req0_ns, w_cmd_req0_addr, w_cmd_req0_qos, 
				  w_cmd_req0_user, w_cmd_req0_did, 
				  w_cmd_req0_st, w_cmd_req0_ch, w_cmd_req0_ca, w_cmd_req0_ac, 
				  w_cmd_req0_vz, w_cmd_req0_or, w_cmd_req0_tr, 
				  w_cmd_req0_mpf1, w_cmd_req0_mpf2, w_cmd_req0_size, 
				  w_cmd_req0_pr, w_cmd_req0_tid, w_cmd_req0_mid, 
				  w_cmd_req0_es, w_cmd_req0_cmd, w_cmd_req0_qin, w_cmd_req0_rl}`,
		out_ready:	'n_cmd_req1_ready',
		out_valid:	'w_cmd_req1_valid',
		out_data:	`{w_cmd_req1_ns, w_cmd_req1_addr, w_cmd_req1_qos, 
				  w_cmd_req1_user, w_cmd_req1_did, 
				  w_cmd_req1_st, w_cmd_req1_ch, w_cmd_req1_ca, w_cmd_req1_ac, 
				  w_cmd_req1_vz, w_cmd_req1_or, w_cmd_req1_tr, 
				  w_cmd_req1_mpf1, w_cmd_req1_mpf2, w_cmd_req1_size, 
				  w_cmd_req1_pr, w_cmd_req1_tid, w_cmd_req1_mid, 
				  w_cmd_req1_es, w_cmd_req1_cmd, w_cmd_req1_qin, w_cmd_req1_rl}`
	},
	portsDelimiter: '\n\t'
})=\

assign n_cmd_req1_ready = cmd_req_ready_i & t_cmd_req_ok;
assign cmd_req_valid_o = w_cmd_req1_valid & t_cmd_req_ok;

assign cmd_req_tid_o = w_cmd_req1_tid;
assign cmd_req_iid_o = myid_i;
assign cmd_req_mid_o = w_cmd_req1_mid;
assign cmd_req_cmd_o = w_cmd_req1_cmd;

wire [MRCP-1:0] w_cmd_req1_qin_tmp;
\jsbegin
// wPriority = 3/0, QOSW = 3/1, so wPriority is never greater
/* istanbul ignore if env ncore_3p7 */
    if (concParams.hdrParams.wPriority>QOSW) { \jsend
    assign w_cmd_req1_qin_tmp = {{MRCP-QOSW{1'b0}},w_cmd_req1_qin};
\js } else {
    assign w_cmd_req1_qin_tmp = w_cmd_req1_qin[MRCP-1:0];
\js }

assign cmd_req_pri_o = w_cmd_req1_qin_tmp;
assign cmd_req_ql_o = {MRCL{1'b0}};
assign cmd_req_status_o = 8'h0;
assign cmd_req_addr_o = w_cmd_req1_addr;

assign cmd_req_attr_o = {w_cmd_req1_tr,		\js //TR: Trace
		     w_cmd_req1_rl,		\js //RL: Response Level
		     2'h0,		\js //LK: Lock
		     w_cmd_req1_or,		\js //OR: Order
		     w_cmd_req1_pr,		\js //PR: Privilege
		     w_cmd_req1_ns,		\js //NS: Non-Secure
		     w_cmd_req1_es,		\js //ES: Exclusive/Self-Snoop
		     1'b0,		\js //EN: Endianness
		     w_cmd_req1_st,		\js //ST: Storage Type
		     w_cmd_req1_ch,		\js //CH: Coherent Access
		     w_cmd_req1_ca,		\js //CA: Cacheable
		     w_cmd_req1_ac,		\js //AC: Allocate
		     w_cmd_req1_vz};	\js //VZ: Visibility
assign cmd_req_mpf1_o = w_cmd_req1_mpf1;
assign cmd_req_mpf2_o = w_cmd_req1_mpf2;
assign cmd_req_size_o = w_cmd_req1_size;
assign cmd_req_isize_o = 2'd\=log2ceil(DW/8)-3=\;
assign cmd_req_did_o = w_cmd_req1_did;
\js if (CDW||owo) {
assign cmd_req_tof_o = 3'h2; \js //2:ACE/owo, 3:AXI
\js } else {
assign cmd_req_tof_o = 3'h3; \js //2:ACE/owo, 3:AXI
\js }
assign cmd_req_qos_o = w_cmd_req1_qos;
\js if(concParams.cmdReqParams.wNdpAux>Math.max(axiParams.wArUser,axiParams.wAwUser)) {
	assign cmd_req_aux_o = {{MRCX-AXUW{1'b0}},w_cmd_req1_user};
\js } else {
	assign cmd_req_aux_o = w_cmd_req1_user[MRCX-1:0];
\js }

wire [OCN*AW-1:0] upd_req_addr_ports;
wire [OCN*QW-1:0] upd_req_qos_ports;
wire [OCN*QOSW-1:0] upd_req_qin_ports;
wire [OCN-1:0] upd_req_sec_ports;
wire [OCN-1:0] upd_req_trace_ports;

\js for (let i=0; i<OCN; i=i+1) {
assign upd_req_addr_ports[\=i=\*AW +: AW] = q_oc_addr[\=i=\];
assign upd_req_qos_ports[\=i=\*QW +: QW] = q_oc_qos[\=i=\];
assign upd_req_qin_ports[\=i=\*QOSW +: QOSW] = w_oc_qin[\=i=\];
\js }
assign upd_req_sec_ports = q_oc_security;
assign upd_req_trace_ports = q_oc_trace;

\=u.instance({
        moduleName: 'ioaiu_aomux',
	instanceName: 'u_upd_req_qos',
        params: {
                clkAssertInterface : clkAssertInterface,
		NUM:      OCN,
                DW:       axiParams.wQos?axiParams.wQos:1, 
		assertOn: assertOn
        },
        ports: {
		data_o:         'n_upd_req0_qos',
		bvsel_i:        'w_upd_req_obv',
		data_i:         'upd_req_qos_ports'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

\=u.instance({
        moduleName: 'ioaiu_aomux',
	instanceName: 'u_upd_req_qin',
        params: {
                clkAssertInterface : clkAssertInterface,
		NUM:      OCN,
                DW:       QOSW,
		assertOn: assertOn
        },
        ports: {
		data_o:         'n_upd_req0_qin',
		bvsel_i:        'w_upd_req_obv',
		data_i:         'upd_req_qin_ports'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

\=u.instance({
        moduleName: 'ioaiu_aomux',
	instanceName: 'u_upd_req_qsec',
        params: {
                clkAssertInterface : clkAssertInterface,
		NUM:      OCN,
                DW:       1,
		assertOn: assertOn
        },
        ports: {
		data_o:         'n_upd_req0_security',
		bvsel_i:        'w_upd_req_obv',
		data_i:         'upd_req_sec_ports'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

\=u.instance({
        moduleName: 'ioaiu_aomux',
	instanceName: 'u_upd_req_tr',
        params: {
                clkAssertInterface : clkAssertInterface,
		NUM:      OCN,
                DW:       1,
		assertOn: assertOn
        },
        ports: {
		data_o:         'n_upd_req0_trace',
		bvsel_i:        'w_upd_req_obv',
		data_i:         'upd_req_trace_ports'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\


\=u.instance({
        moduleName: 'ioaiu_aomux',
	instanceName: 'u_upd_req_add',
        params: {
                clkAssertInterface : clkAssertInterface,
		NUM:      OCN,
                DW:       AW,
		assertOn: assertOn
        },
        ports: {
		data_o:         'n_upd_req0_addr',
		bvsel_i:        'w_upd_req_obv',
		data_i:         'upd_req_addr_ports'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

assign amc_val_evict_o  = (| t_oc_wfmru);
assign amc_addr_evict_o = n_upd_req0_addr;

\js if ((axiParams.eDomain?1:0)==0) {
assign dce_mru = amc_vals_evict_i[0] & ~amc_nc_evict_i;
\js } else {
assign dce_mru = 1'b1;
\js }
\jsbegin
// wMsgId always sized to fit OCA
/* istanbul ignore else env ncore_3p7 */
    if(concParams.hdrParams.wMsgId>OCA) { \jsend
	assign n_upd_req0_mid = {{MRUM-OCA{1'b0}},w_upd_req_oid};
\js } else {
	assign n_upd_req0_mid = w_upd_req_oid[MRUM-1:0];
\js }

assign n_upd_req0_valid = (| t_oc_wfmru) & (~cfg_update_i & (dce_mru | (ACE==1)));

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'upd_req0',
	params: {
                depth:          3,
		width:		1+MRUA+ioaiu_pos(MRUQ)+MRUT+MRUM+QOSW+1,
                pipeForward:    "yes",
                pipeBackward:   "yes",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_upd_req0_ready',
		in_valid:	'n_upd_req0_valid',
		in_data:	`{n_upd_req0_trace, n_upd_req0_security, n_upd_req0_addr, n_upd_req0_qos,
				  n_upd_req0_tid, n_upd_req0_mid, n_upd_req0_qin}`,
		out_ready:	'n_upd_req0_ready',
		out_valid:	'w_upd_req0_valid',
		out_data:	`{w_upd_req0_trace, w_upd_req0_security, w_upd_req0_addr, w_upd_req0_qos,
				  w_upd_req0_tid, w_upd_req0_mid, w_upd_req0_qin}`
	},
	portsDelimiter: '\n\t'
})=\

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'upd_req1',
	params: {
                depth:          1,
		width:		1+MRUA+ioaiu_pos(MRUQ)+MRUT+MRUM+QOSW+1,
                pipeForward:    "no",
                pipeBackward:   "yes",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'n_upd_req0_ready',
		in_valid:	'w_upd_req0_valid',
		in_data:	`{w_upd_req0_trace, w_upd_req0_security, w_upd_req0_addr, w_upd_req0_qos,
				  w_upd_req0_tid, w_upd_req0_mid, w_upd_req0_qin}`,
		out_ready:	'n_upd_req1_ready',
		out_valid:	'w_upd_req1_valid',
		out_data:	`{w_upd_req1_trace, w_upd_req1_security, w_upd_req1_addr, w_upd_req1_qos,
				  w_upd_req1_tid, w_upd_req1_mid, w_upd_req1_qin}`
	},
	portsDelimiter: '\n\t'
})=\

assign n_upd_req1_ready = upd_req_ready_i & t_upd_req_ok;
assign upd_req_valid_o = w_upd_req1_valid & t_upd_req_ok;

assign upd_req_tid_o = w_upd_req1_tid;
assign upd_req_iid_o = cmd_req_iid_o;
assign upd_req_mid_o = w_upd_req1_mid;
assign upd_req_cmd_o = UpdInv;

wire [MRUP-1:0] w_upd_req1_qin_tmp;
\jsbegin
// wPriority = 3/0, QOSW = 3/1, so wPriority is never greater
/* istanbul ignore if env ncore_3p7 */
    if (concParams.hdrParams.wPriority>QOSW) { \jsend
    assign w_upd_req1_qin_tmp = {{MRUP-QOSW{1'b0}},w_upd_req1_qin};
\js } else {
    assign w_upd_req1_qin_tmp = w_upd_req1_qin[MRUP-1:0];
\js }

assign upd_req_pri_o = w_upd_req1_qin_tmp;
assign upd_req_ql_o = {MRUL{1'b0}};
assign upd_req_addr_o = w_upd_req1_addr;
assign upd_req_status_o = 8'h0;
assign upd_req_attr_o = w_upd_req1_security;	\js //NS: Non-Secure
assign upd_req_qos_o = w_upd_req1_qos;
assign upd_req_trace_o = w_upd_req1_trace;

\js if (STE) {
\js ////////////////////////////////////////////////////////////////
\js // AXI with cache responses.
\js ////////////////////////////////////////////////////////////////
always @(*) begin
  casez (t_st_cmd[w_cs_sid])
    SnpClnDtr : n_moesi_dtr = DtrDataSCln;
    SnpNoSDInt: n_moesi_dtr = DtrDataSCln;
\jsbegin
/* istanbul ignore else env ncore_3p4,ncore_3p6,ncore_3p7 */
if (useOwnerTransfer>0) { \jsend
    SnpVldDtr : n_moesi_dtr = ((t_st_cstate[w_cs_sid]==CST_SD)||(t_st_cstate[w_cs_sid]==CST_UD)) ? DtrDataSDty : DtrDataSCln;
    SnpVldDtw : n_moesi_dtr = DtwDataDty; // SnpVldDtw is SnpClnDtw in the spec....
    SnpInvDtr : begin
                       n_moesi_dtr = (t_st_cstate[w_cs_sid]==CST_SC) ? DtrDataUCln : 
                                     (t_st_cstate[w_cs_sid]==CST_SD) ? DtrDataUDty : 
                                     (t_st_cstate[w_cs_sid]==CST_UC) ? DtrDataUCln : DtrDataUDty;
                end
    SnpNITC   : n_moesi_dtr = ((t_st_tof[w_cs_sid]==TOF_CHI) || (t_st_cstate[w_cs_sid]==CST_UD) || (t_st_cstate[w_cs_sid]==CST_UC)) ? DtrDataInv : DtrDataSCln;
    SnpNITCCI : n_moesi_dtr = DtrDataInv;
    SnpNITCMI : n_moesi_dtr = DtrDataInv;
    SnpInvDtw : n_moesi_dtr = DtrDataInv; // DtwDataDty??
    SnpInv    : n_moesi_dtr = DtrDataInv;
\jsbegin
} else { \jsend
    SnpVldDtr : n_moesi_dtr = DtrDataSCln;
    SnpVldDtw : n_moesi_dtr = DtrDataInv; 
    SnpInvDtr : n_moesi_dtr = (t_st_cstate[w_cs_sid]==CST_SC) ? DtrDataSCln : (t_st_cstate[w_cs_sid]==CST_UC) ? DtrDataUCln : DtrDataUDty;
    SnpNITC   : n_moesi_dtr = (t_st_tof[w_cs_sid]!=TOF_CHI) && (t_st_cstate[w_cs_sid]==CST_SD) ? DtrDataSCln : DtrDataInv;
    SnpNITCCI : n_moesi_dtr = (t_st_cstate[w_cs_sid]==CST_SC) ? DtrDataSCln : DtrDataInv;
    SnpNITCMI : n_moesi_dtr = (t_st_cstate[w_cs_sid]==CST_SC) ? DtrDataSCln : DtrDataInv;
    SnpInvDtw : n_moesi_dtr = DtrDataInv; // DtwDataDty??
    SnpInv    : n_moesi_dtr = DtrDataInv;
\jsbegin
} \jsend
    default   : n_moesi_dtr = DtrDataInv;
  endcase
end
\js }

////////////////////////////////////////////////////////////////
assign n_dtr_req_tx0_cmd = ~t_ce_dtr ? {8{XO}} :
		    t_of_stash[0] ? DtrDataUDty :
\js if (CDW>1) {
		    n_ace_dtr;
\js } else if (COH_MOESI>0) {
		    n_moesi_dtr;
\js } else if (STE) {
		    (t_st_cstate[w_cs_sid]==CST_UD) ? DtrDataSDty : DtrDataSCln;
\js } else {
                    8'b0;
\js }

\js if (STE) {
wire [QOSW-1:0]	t_st_pri_tmp [STN-1:0];
\jsbegin
// Always equal. Max(1,log2(8))>Max(1,3) // With SRNP being wPriority
/* istanbul ignore if env ncore_3p7 */
    if(QOSW>SRNP) { \jsend
\js	for(let i=0;i<STN;i=i+1) {
		assign t_st_pri_tmp[\=i=\] = {{\=QOSW-SRNP=\{1'b0}},t_st_pri[\=i=\]};
\js	}
\js } else {
\js	for(let i=0;i<STN;i=i+1) {
		assign t_st_pri_tmp[\=i=\] = t_st_pri[\=i=\][QOSW-1:0];
\js	}
\js }
\js } // STE

assign n_dtr_req_tx0_tr = t_of_stash[0] ? q_oc_trace[w_of_oid] : 
\js if (STE) {
                                                          w_cs_trace;
\js } else {
                                                          1'b0;
\js }
assign n_dtr_req_tx0_qin = t_of_stash[0] ? w_oc_qin[w_of_oid] : 
\js if (STE) {
                                                          t_st_pri_tmp[w_cs_sid];
\js } else {
                                                          \=QOSW=\'b0;
\js }

\jsbegin
// wTargetId = FIDW+PIDW, so not greater
/* istanbul ignore if env ncore_3p7 */
    if(concParams.hdrParams.wTargetId>Math.max(FIDW+PIDW,concParams.snpReqParams.wMpf1+PIDW)) { \jsend
        assign n_dtr_req_tx0_tid = {(t_of_stash[0] ? {{(MRRT-FIDW-PIDW){1'b0}},t_oc_stashnid[w_of_oid]} : {{(MRRT-SRN1-PIDW){1'b0}},
\js if (STE) {
                                                                                                                             t_st_mpf1[w_cs_sid]
\js } else { // STE
                                                                                                                             \=SRN1=\'b0
\js } // STE
                                                                                                                                                }), {PIDW{1'b0}}};
\jsbegin
    } else { 
/* istanbul ignore next env ncore_3p7 */
      if(concParams.hdrParams.wTargetId<=Math.min(FIDW+PIDW,concParams.snpReqParams.wMpf1+PIDW)) { \jsend
        wire    [\=Math.max(FIDW+PIDW,concParams.snpReqParams.wMpf1+PIDW)-1=\:0]        n_dtr_req_tx0_tid_tmp;
\js     if(FIDW<concParams.snpReqParams.wMpf1) {
                assign n_dtr_req_tx0_tid_tmp = {(t_of_stash[0] ? {{(SRN1-FIDW){1'b0}},t_oc_stashnid[w_of_oid]} : 
\js if (STE) {
                                                                                                          t_st_mpf1[w_cs_sid]
\js } else { // STE
                                                                                                          \=SRN1=\'b0
\js } // STE
                                                                                                                             ), {PIDW{1'b0}}};
\js     } else if(FIDW>concParams.snpReqParams.wMpf1) {
                assign n_dtr_req_tx0_tid_tmp = {(t_of_stash[0] ? t_oc_stashnid[w_of_oid] : {{(FIDW-SRN1){1'b0}},
\js if (STE) {
                                                                                                         t_st_mpf1[w_cs_sid]
\js } else { // STE
                                                                                                         \=SRN1=\'b0
\js } // STE
                                                                                                                            }), {PIDW{1'b0}}};
\js     } else {
                assign n_dtr_req_tx0_tid_tmp = {(t_of_stash[0] ? t_oc_stashnid[w_of_oid] : 
\js if (STE) {
                                                                                    t_st_mpf1[w_cs_sid]
\js } else { // STE
                                                                                    \=SRN1=\'b0
\js } // STE
                                                                                                       ), {PIDW{1'b0}}};
\js     }
        assign n_dtr_req_tx0_tid = n_dtr_req_tx0_tid_tmp[MRRT-1:0];
\jsbegin
    } /* istanbul ignore next env ncore_3p7 */ else { \jsend
\js     if(FIDW<concParams.snpReqParams.wMpf1) {
                assign n_dtr_req_tx0_tid = {(t_of_stash[0] ? {{(MRRT-FIDW-PIDW){1'b0}},t_oc_stashnid[w_of_oid]} : 
\js if (STE) {
                                                                                                           t_st_mpf1[w_cs_sid][MRRT-PIDW-1:0]
\js } else { // STE
                                                                                                           \=MRRT-PIDW=\'b0
\js } // STE
                                                                                                                                             ), {PIDW{1'b0}}};
\js     } else {
                assign n_dtr_req_tx0_tid = {(t_of_stash[0] ? t_oc_stashnid[w_of_oid][MRRT-PIDW-1:0] : {{(MRRT-SRN1-PIDW){1'b0}},
\js if (STE) {
                                                                                                                         t_st_mpf1[w_cs_sid]
\js } else { // STE
                                                                                                                         \=SRN1=\'b0
\js } // STE
                                                                                                                                            }), {PIDW{1'b0}}};
        }
\js } }
\js }

\jsbegin
// always enabled on 3.6
/* istanbul ignore else env ncore_3p6,ncore_3p7 */
    if (useEarlyDtr) { \jsend
wire             dtr_mid_free_load;
wire [RMIDS-1:0] dtr_mid_free_clr;
wire [RMIDS-1:0] dtr_mid_free_set;
wire [RMIDS-1:0] dtr_mid_free_set_bit;
wire [RMIDS-1:0] dtr_mid_free;
wire [RMIDS-1:0] dtr_mid_free_ns;
wire [RMIDS-1:0] dtr_mid_free_sel;
wire [XTA-1:0]   dtr_mid;
wire [XTA-1:0]   dtr_mid_next;
wire             dtr_mid_full;

\=u.instance({
    instanceName: 'u_free_find_first_one',
    moduleName: 'find_first_one',
    params: { width : RMIDS},
    verilogParams: { WIDTH : 'RMIDS'},
    ports: {
        invec  : 'dtr_mid_free',
        outvec : 'dtr_mid_free_sel'
    }
})=\

\jsbegin
/* istanbul ignore else env ncore_3p4,ncore_3p6,ncore_3p7 */
if(RMIDS>1) { \jsend
\=u.instance({
    instanceName: 'u_free_encoder',
    moduleName: 'encoder',
    params: { width : RMIDS},
    verilogParams: { },
    ports: {
        invector  : 'dtr_mid_free_sel',
        outdecode : 'dtr_mid_next'
    }
})=\
\jsbegin
} else { \jsend //lint fix
\=u.instance({
    instanceName: 'u_free_encoder',
    moduleName: 'encoder',
    params: { width : RMIDS},
    verilogParams: { },
    ports: {
        invector  : 'dtr_mid_free_sel',
        outdecode : 'dtr_mid_next[0]'
    }
})=\
assign dtr_mid_next[1] = 1'b0;
\jsbegin
} \jsend

wire dtr_mid_en;

assign dtr_mid_en = (n_dtr_req_tx0_valid & w_dtr_req_tx0_ready & n_dtr_req_tx0_last & ~w_dtr_req_tx0_mid[\=Math.max(OCA, STA)=\]);

\=u.dffre(wRMIDS, `dtr_mid`, `dtr_mid_next`, `{`+wRMIDS+`{1'b0}}`, `dtr_mid_en`, `clk_i`, `reset_ni`)=\

\js for (let i=0; i<RMIDS; i=i+1) {
\jsbegin
// log2 of Max(OCA,STA) will be less than Max(OCA,STA)
/* istanbul ignore if env ncore_3p7 */
    if (wRMIDS>Math.max(OCA, STA)+1) { \jsend
        assign dtr_mid_free_set_bit[\=i=\] = ({{\=wRMIDS=\-\=Math.max(OCA, STA)=\-1{1'b0}},w_dtr_rsp_rx_mid[\=Math.max(OCA, STA)=\:0]}==\=Math.max(OCA,STA)+1=\'d\=i=\);
\js } else {
        assign dtr_mid_free_set_bit[\=i=\] = (w_dtr_rsp_rx_mid[\=Math.max(OCA, STA)=\:0]==\=Math.max(OCA,STA)+1=\'d\=i=\);
\js }
\js }

assign dtr_mid_free_load = n_dtr_req_tx0_valid & w_dtr_req_tx0_ready & n_dtr_req_tx0_last & ~w_dtr_req_tx0_mid[\=Math.max(OCA, STA)=\];

assign dtr_mid_free_set = (w_dtr_rsp_rx_valid_mod & ~w_dtr_rsp_rx_mid[\=Math.max(OCA, STA)=\]) ? dtr_mid_free_set_bit : {RMIDS{1'b0}};
assign dtr_mid_free_clr = dtr_mid_free_load ? ~dtr_mid_free_sel : {RMIDS{1'b1}};
assign dtr_mid_free_ns  = (dtr_mid_free & dtr_mid_free_clr) | dtr_mid_free_set;

\=u.dffre(RMIDS, `dtr_mid_free`, `dtr_mid_free_ns`, `{{`+(RMIDS-1)+`{1'b1}},1'b0}`, `1'b1`, `clk_i`, `reset_ni`)=\
assign dtr_mid_full = ~(|dtr_mid_free);
\js }

wire [MRRM-1:0] w_cs_sid_tmp;
wire [MRRM-1:0]	w_of_oid_tmp;
wire [XTA:0] w_of_oid_tmp_mask = {1'b1,{XTA{1'b0}}};

\jsbegin
// always enabled on 3.6
/* istanbul ignore else env ncore_3p6,ncore_3p7 */
    if (useEarlyDtr) { \jsend
\jsbegin
// wMsgId is always be 1 more than greatest of OCA/STA in 3.7
/* istanbul ignore else env ncore_3p7 */
         if(concParams.hdrParams.wMsgId>XTA) { \jsend
	assign w_cs_sid_tmp = {{MRRM-XTA{1'b0}},dtr_mid};
\js      } else {
	assign w_cs_sid_tmp = dtr_mid[MRRM-1:0];
\js      }
\js } else {
\js if(concParams.hdrParams.wMsgId>STA) {
	assign w_cs_sid_tmp = {{MRRM-STA{1'b0}},w_cs_sid};
\js } else {
	assign w_cs_sid_tmp = w_cs_sid[MRRM-1:0];
\js }
\js }

\jsbegin
// wMsgId always sized to fit OCA
/* istanbul ignore else env ncore_3p7 */
    if(concParams.hdrParams.wMsgId>OCA) { \jsend
	assign w_of_oid_tmp = {{MRRM-OCA{1'b0}},w_of_oid};
\js } else {
	assign w_of_oid_tmp = w_of_oid[MRRM-1:0];
\js }
\js if(concParams.hdrParams.wMsgId>XTA+1) {
	assign n_dtr_req_tx0_mid = t_of_stash[0] ? w_of_oid_tmp | {{MRRM-XTA-1{1'b0}},w_of_oid_tmp_mask} : w_cs_sid_tmp;
\js } else {
	assign n_dtr_req_tx0_mid = t_of_stash[0] ? w_of_oid_tmp | w_of_oid_tmp_mask[MRRM-1:0] : w_cs_sid_tmp;
\js }

\jsbegin
/* istanbul ignore if env ncore_3p7 */
    if(concParams.dtrReqParams.wMsgId>Math.max(concParams.strReqParams.wMpf2,concParams.snpReqParams.wMpf2)) { \jsend
	assign n_dtr_req_tx0_rid = t_of_stash[0] ? {{(MRRR-SRC2){1'b0}},t_oc_stashrid[w_of_oid]} : {{(MRRR-SRN2){1'b0}},
\js if (STE) {
	                                                                                                         t_st_stid[w_cs_sid]};
\js } else { // STE
	                                                                                                         \=SRN2=\'b0        };
\js } // STE
\jsbegin
    } /* istanbul ignore next env ncore_3p7 */ else if(concParams.dtrReqParams.wMsgId<=Math.min(concParams.strReqParams.wMpf2,concParams.snpReqParams.wMpf2)) { \jsend
	assign n_dtr_req_tx0_rid = t_of_stash[0] ? t_oc_stashrid[w_of_oid][MRRR-1:0] :
\js if (STE) {
	                                                                        t_st_stid[w_cs_sid][MRRR-1:0];
\js } else { // STE
	                                                                        \=MRRR=\'b0;
\js } // STE
\jsbegin
    } else /* istanbul ignore next env ncore_3p7 */ { \jsend
\js	if(concParams.strReqParams.wMpf2<concParams.snpReqParams.wMpf2) {
		assign n_dtr_req_tx0_rid =  t_of_stash[0] ? {{(MRRR-SRC2){1'b0}},t_oc_stashrid[w_of_oid]} :
\js if (STE) {
		                                                                                     t_st_stid[w_cs_sid][MRRR-1:0];
\js } else { // STE
		                                                                                     \=MRRR=\'b0;
\js } // STE
\js     } else {
		assign n_dtr_req_tx0_rid =  t_of_stash[0] ? t_oc_stashrid[w_of_oid][MRRR-1:0] : {{(MRRR-SRN2){1'b0}},
\js if (STE) {
		                                                                                              t_st_stid[w_cs_sid]};
\js } else { // STE
		                                                                                              \=SRN2=\'b0};
\js } // STE
\js     }
\js }

assign n_dtr_req_tx0_last = w_of_last;	
assign n_dtr_req_tx0_be = w_of_be;
assign n_dtr_req_tx0_wdata = w_of_rdata;
wire t_dtr_req_tx0_dwid_carry;
assign {t_dtr_req_tx0_dwid_carry,t_dtr_req_tx0_dwid} = {1'b0,w_of_count} + {1'b0,n_dtr_req_tx0_addr[5 -: BWL]};

\js //////////////////////////////////////////////////////////////////////////////////////////
\js // Better code (n_dtr_req_tx0_dwid needs to be a reg)
\js //   DW   BWL
\js //   64   3
\js //   128  2
\js //   256  1

wire [6:0] current_addrr = {{\=7-BWL-BWL=\{1'b0}},w_of_count,{BWL{1'b0}}} + {1'b0,n_dtr_req_tx0_addr[5:0]};
\js if(BWL>1) {
wire [2:0] dwid_three_bit_rr = {t_dtr_req_tx0_dwid[1:0], 1'b0};
\js } else {
wire [2:0] dwid_three_bit_rr = {1'b0, t_dtr_req_tx0_dwid, 1'b0};	
\js }
wire [3:0] wrap_two_rr = current_addrr [6:3] - 3'd2;
wire [3:0] wrap_four_rr = current_addrr [6:3] - 3'd4;

\js // t_of_stash[0] == 0 : Snoop.
\js // t_oc_atop[w_of_oid] : ATomic OP. atomic op when |t_oc_atop[w_of_oid] == 1.
  wire n_dtr_req_tx0_snoop_or_atomic_or_notwrap = (~t_of_stash[0]) ? 1'b1 : ((|t_oc_atop[w_of_oid]) || ~q_oc_wrap[w_of_oid]); // need this construct to filter Xs on snoops

always @(*) begin
  casez ({n_dtr_req_tx0_snoop_or_atomic_or_notwrap, (BWL==1), (BWL==2), (BWL==3), n_dtr_req_tx0_addr[5:4], ({{\=8-BWL=\{1'b0}},q_oc_beats[w_of_oid]}==8'd2), ({{\=8-BWL=\{1'b0}},q_oc_beats[w_of_oid]}==8'd4), extra_beat})
\js // INCR
    \js if ( BWL == 1 ) {
    9'b1_100_??_??? : n_dtr_req_tx0_dwid = {t_dtr_req_tx0_dwid, 2'h3, t_dtr_req_tx0_dwid, 2'h2, t_dtr_req_tx0_dwid, 2'h1, t_dtr_req_tx0_dwid, 2'h0};
    \js }
    \js if ( BWL == 2 ) {
    9'b1_010_??_??? : n_dtr_req_tx0_dwid = {t_dtr_req_tx0_dwid, 1'b1, t_dtr_req_tx0_dwid, 1'b0};
     \js }
    \js if ( BWL == 3 ) {
    9'b1_001_??_??? : n_dtr_req_tx0_dwid = t_dtr_req_tx0_dwid;
    \js }
\js // WRAP
\js // 64
    \js if ( BWL == 3 ) {
    9'b0_001_0?_010 : n_dtr_req_tx0_dwid = current_addrr[5] ? wrap_four_rr[2:0] : t_dtr_req_tx0_dwid;
    9'b0_001_1?_010 : n_dtr_req_tx0_dwid = current_addrr[6] ? wrap_four_rr[2:0] : t_dtr_req_tx0_dwid;
    9'b0_001_00_100 : n_dtr_req_tx0_dwid = (current_addrr[5:4] == 2'b01) ? wrap_two_rr[2:0] : t_dtr_req_tx0_dwid;
    9'b0_001_01_100 : n_dtr_req_tx0_dwid = (current_addrr[5:4] == 2'b10) ? wrap_two_rr[2:0] : t_dtr_req_tx0_dwid;
    9'b0_001_10_100 : n_dtr_req_tx0_dwid = (current_addrr[5:4] == 2'b11) ? wrap_two_rr[2:0] : t_dtr_req_tx0_dwid;
    9'b0_001_11_100 : n_dtr_req_tx0_dwid = current_addrr[6] ? wrap_two_rr[2:0] : t_dtr_req_tx0_dwid;
    9'b0_001_??_101 : n_dtr_req_tx0_dwid = {3{~n_dtr_req_tx0_addr[5]}};
    9'b0_001_??_011 : n_dtr_req_tx0_dwid = {3{~n_dtr_req_tx0_addr[5]}};
    9'b0_001_??_00? : n_dtr_req_tx0_dwid = t_dtr_req_tx0_dwid;
    \js }
\js // 128
    \js if ( BWL == 2 ) {
    9'b0_010_00_10? : n_dtr_req_tx0_dwid = {t_dtr_req_tx0_dwid, 1'b1, t_dtr_req_tx0_dwid, 1'b0};
    9'b0_010_01_100 : n_dtr_req_tx0_dwid = (w_of_count==1) ? {dwid_three_bit_rr-3'd3, dwid_three_bit_rr-3'd4} : {dwid_three_bit_rr+3'd1, dwid_three_bit_rr};
    9'b0_010_01_101 : n_dtr_req_tx0_dwid = 6'b111111;
    9'b0_010_10_10? : n_dtr_req_tx0_dwid = {t_dtr_req_tx0_dwid, 1'b1, t_dtr_req_tx0_dwid, 1'b0};
    9'b0_010_11_100 : n_dtr_req_tx0_dwid = (w_of_count==1) ? {3'd5, 3'd4} : {dwid_three_bit_rr+3'd1, dwid_three_bit_rr};
    9'b0_010_11_101 : n_dtr_req_tx0_dwid = 6'b000000;
    9'b0_010_??_0?? : n_dtr_req_tx0_dwid = {t_dtr_req_tx0_dwid, 1'b1, t_dtr_req_tx0_dwid, 1'b0};
    \js }
\js // 256
    \js if ( BWL == 1 ) {
    9'b0_100_??_??? : n_dtr_req_tx0_dwid = {t_dtr_req_tx0_dwid, 2'd3, t_dtr_req_tx0_dwid, 2'd2, t_dtr_req_tx0_dwid, 2'd1, t_dtr_req_tx0_dwid, 2'd0};
    \js }
\js // Default
    default: begin
               n_dtr_req_tx0_dwid = {MRWZ*3{XO}};
             end
  endcase
end
//////////////////////////////////////////////////////////////////////////////////////////

assign n_dtr_req_tx0_poison = w_of_poison;
assign n_dtr_req_tx0_status = ((|w_of_poison) & ~t_of_sel[1]);

assign n_dtr_req_tx0_addr = t_of_stash[0] ? q_oc_addr[w_of_oid] :
\js if (STE) {
                                                           t_st_addr[w_cs_sid];
\js } else { // STE
                                                           \=AW=\'b0;
\js } // STE
assign n_dtr_req_tx0_isize = t_of_stash[0]? t_oc_isize[w_of_oid]:
\js if (STE) {
                                                           t_st_isize[w_cs_sid];
\js } else { // STE
                                                           2'b0;
\js } // STE
assign n_dtr_req_tx0_tbits = ({9{((MRRD==256) & (n_dtr_req_tx0_isize==2'h0) & (n_dtr_req_tx0_addr[4:3]==2'h0))}} & 9'd256) |
		      ({9{((MRRD==256) & (n_dtr_req_tx0_isize==2'h0) & (n_dtr_req_tx0_addr[4:3]==2'h1))}} & 9'd192) |
		      ({9{((MRRD==256) & (n_dtr_req_tx0_isize==2'h0) & (n_dtr_req_tx0_addr[4:3]==2'h2))}} & 9'd128) |
		      ({9{((MRRD==256) & (n_dtr_req_tx0_isize==2'h0) & (n_dtr_req_tx0_addr[4:3]==2'h3))}} & 9'd64) |
		      ({9{((MRRD==256) & (n_dtr_req_tx0_isize==2'h1) & (n_dtr_req_tx0_addr[4]==1'b0))}} & 9'd256) |
		      ({9{((MRRD==256) & (n_dtr_req_tx0_isize==2'h1) & (n_dtr_req_tx0_addr[4]==1'b1))}} & 9'd128) |
		      ({9{((MRRD==256) & (n_dtr_req_tx0_isize==2'h2))}} & 9'd256) |
		      ({9{((MRRD==128) & (n_dtr_req_tx0_isize==2'h0) & (n_dtr_req_tx0_addr[3]==1'h0))}} & 9'd128) |
		      ({9{((MRRD==128) & (n_dtr_req_tx0_isize==2'h0) & (n_dtr_req_tx0_addr[3]==1'h1))}} & 9'd64) |
		      ({9{((MRRD==128) & (n_dtr_req_tx0_isize>=2'h1))}} & 9'd128) |
		      ({9{(MRRD==64)}} & 9'd64) |
		      ({9{(MRRD<64)|(MRRD>256)}} & {9{XO}});

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'dtr_req_tx0',
	params: {
                depth:          1,
		width:		MRRW+(BSE?9:1),
                pipeForward:    "yes",
                pipeBackward:   "no",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_dtr_req_tx0_ready_pre',
		in_valid:	'n_dtr_req_tx0_valid & ~dtr_mid_full',
		in_data:	`{n_dtr_req_tx0_tbits[BSE*8:0], n_dtr_req_tx0_last, n_dtr_req_tx0_dwid,
				  n_dtr_req_tx0_status,
				  n_dtr_req_tx0_poison, n_dtr_req_tx0_be, n_dtr_req_tx0_wdata, 
				  n_dtr_req_tx0_tr, n_dtr_req_tx0_qin, n_dtr_req_tx0_tid, 
				  n_dtr_req_tx0_mid, n_dtr_req_tx0_rid, n_dtr_req_tx0_cmd}`,
		out_ready:	'n_dtr_req_tx0_ready',
		out_valid:	'w_dtr_req_tx0_valid',
		out_data:	`{w_dtr_req_tx0_tbits, w_dtr_req_tx0_last, w_dtr_req_tx0_dwid,
				  w_dtr_req_tx0_status,
				  w_dtr_req_tx0_poison, w_dtr_req_tx0_be, w_dtr_req_tx0_wdata, 
				  w_dtr_req_tx0_tr, w_dtr_req_tx0_qin, w_dtr_req_tx0_tid, 
				  w_dtr_req_tx0_mid, w_dtr_req_tx0_rid, w_dtr_req_tx0_cmd}`
	},
	portsDelimiter: '\n\t'
})=\
assign w_dtr_req_tx0_ready = w_dtr_req_tx0_ready_pre & ~dtr_mid_full;

\js if (STE && concParams.dtrReqParams.wData>64) {
     wire [8:0]	t_bs_bits, t_bs_dbits, w_dtr_req_tx0_dbits;
     wire [1:0] 	q_bs_state;
     reg [1:0] n_bs_state;
     wire 	             q_bs_status;
     wire [DWP-1:0] q_bs_poison;
     wire [MRWZ*3-1:0] q_bs_dwid;
     wire [MRRD-1:0]   q_bs_data;
     wire [7:0] 	      q_bs_cmd;
     wire [MRRM-1:0]   q_bs_mid;
     wire [MRRR-1:0]   q_bs_rid;
     wire [MRRT-1:0]   q_bs_tid;
     wire [QOSW-1:0]   q_bs_qin;
     wire 	      q_bs_tr;

     assign w_dtr_req_tx0_dbits = (w_dtr_req_tx0_tbits[7:6]==2'h3) ? 9'd9 :
			   (w_dtr_req_tx0_tbits[7:6]==2'h2) ? 9'd6 :
			   (w_dtr_req_tx0_tbits[7:6]==2'h1) ? 9'd3 :
			   9'd12;
     assign t_bs_dbits = 9'd\=MRRDB=\ - w_dtr_req_tx0_dbits;
     assign t_bs_bits = 9'd\=MRRD=\ - w_dtr_req_tx0_tbits;

     always @(*) begin
	case (q_bs_state)
	  2'h0: n_bs_state = (({{32-(BSE*8+1){1'b0}},w_dtr_req_tx0_tbits}<MRRD) & ~w_dtr_req_tx0_last) ? 2'h1 : 2'h0;
	  2'h1: n_bs_state = w_dtr_req_tx0_last ? 2'h2 : 2'h1;
	  2'h2: n_bs_state = (({{32-(BSE*8+1){1'b0}},w_dtr_req_tx0_tbits} >= MRRD) |
			     ~w_dtr_req_tx0_valid) ? 2'h0 :
			     ~w_dtr_req_tx0_last ? 2'h1 : 
			     2'h2;
	  default: n_bs_state = {2{\=DRST=\}};
	endcase
     end
     wire [2-1:0] q_bs_state_ns = (w_dtr_req_tx1_ready & (w_dtr_req_tx0_valid | q_bs_state[1])) ? n_bs_state : q_bs_state;
     \=u.dffre(2, `q_bs_state`, `q_bs_state_ns`, `2'd0`, `1'b1`, `clk_i`, `reset_ni`)=\

     wire [MRWZ*6-1:0] q_bs_dwid_tmp = {2{w_dtr_req_tx0_dwid}} >> t_bs_dbits;
     wire [MRRD*2-1:0] q_bs_data_tmp = {2{w_dtr_req_tx0_wdata}} >> t_bs_bits;

     wire q_bs_status_ns = (~w_dtr_req_tx0_valid | ~n_dtr_req_tx0_ready) ? q_bs_status : ~q_bs_state[0] ? w_dtr_req_tx0_status : w_dtr_req_tx0_status | q_bs_status;
     \=u.dffre(1, `q_bs_status`, `q_bs_status_ns`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
     wire [DWP-1:0] q_bs_poison_ns = (~w_dtr_req_tx0_valid | ~n_dtr_req_tx0_ready) ? q_bs_poison : ~q_bs_state[0] ? w_dtr_req_tx0_poison : w_dtr_req_tx0_poison | q_bs_poison;
     \=u.dffre(DWP, `q_bs_poison`, `q_bs_poison_ns`, `{`+DWP+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
     wire [MRWZ*3-1:0] q_bs_dwid_ns = (~w_dtr_req_tx0_valid | ~n_dtr_req_tx0_ready) ? q_bs_dwid : ~q_bs_state[0] ? q_bs_dwid_tmp[MRWZ*3-1:0] : (q_bs_dwid & ({MRRDB{1'b1}}<<(MRRDB-t_bs_dbits))) | (w_dtr_req_tx0_dwid >> t_bs_dbits);
     \=u.dffre(MRWZ*3, `q_bs_dwid`, `q_bs_dwid_ns`, `{`+(3*MRWZ)+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
     wire [MRRD-1:0] q_bs_data_ns = (~w_dtr_req_tx0_valid | ~n_dtr_req_tx0_ready) ? q_bs_data : ~q_bs_state[0] ? q_bs_data_tmp[MRRD-1:0] : (q_bs_data & ({MRRD{1'b1}} << (MRRD-t_bs_bits)))| (w_dtr_req_tx0_wdata >> t_bs_bits);
     \=u.dffre(MRRD, `q_bs_data`, `q_bs_data_ns`, `{`+MRRD+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
     wire [8-1:0] q_bs_cmd_ns = (w_dtr_req_tx0_valid & n_dtr_req_tx0_ready) ? w_dtr_req_tx0_cmd : q_bs_cmd;
     \=u.dffre(8, `q_bs_cmd`, `q_bs_cmd_ns`, `8'd0`, `1'b1`, `clk_i`, `reset_ni`)=\
     wire [MRRM-1:0] q_bs_mid_ns = (w_dtr_req_tx0_valid & n_dtr_req_tx0_ready) ? w_dtr_req_tx0_mid : q_bs_mid;
     \=u.dffre(MRRM, `q_bs_mid`, `q_bs_mid_ns`, `{`+MRRM+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
     wire [MRRR-1:0] q_bs_rid_ns = (w_dtr_req_tx0_valid & n_dtr_req_tx0_ready) ? w_dtr_req_tx0_rid : q_bs_rid;
     \=u.dffre(MRRR, `q_bs_rid`, `q_bs_rid_ns`, `{`+MRRR+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
     wire [MRRT-1:0] q_bs_tid_ns = (w_dtr_req_tx0_valid & n_dtr_req_tx0_ready) ? w_dtr_req_tx0_tid : q_bs_tid;
     \=u.dffre(MRRT, `q_bs_tid`, `q_bs_tid_ns`, `{`+MRRT+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
     wire [QOSW-1:0] q_bs_qin_ns = (w_dtr_req_tx0_valid & n_dtr_req_tx0_ready) ? w_dtr_req_tx0_qin : q_bs_qin;
     \=u.dffre(QOSW, `q_bs_qin`, `q_bs_qin_ns`, `{`+QOSW+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
     wire q_bs_tr_ns = (w_dtr_req_tx0_valid & n_dtr_req_tx0_ready) ? w_dtr_req_tx0_tr : q_bs_tr;
     \=u.dffre(1, `q_bs_tr`, `q_bs_tr_ns`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
     
     assign n_dtr_req_tx0_ready = w_dtr_req_tx1_ready & ~(q_bs_state[1] & w_dtr_req_tx0_valid & ({{32-(BSE*8+1){1'b0}},w_dtr_req_tx0_tbits} >= MRRD));
     assign n_dtr_req_tx1_valid = q_bs_state[1] | (w_dtr_req_tx0_valid & (q_bs_state[0] | ({{32-(BSE*8+1){1'b0}},w_dtr_req_tx0_tbits} >= MRRD)));
     assign n_dtr_req_tx1_last = q_bs_state[1] | ((~| q_bs_state) & w_dtr_req_tx0_last);
     assign n_dtr_req_tx1_status = q_bs_state[1] ? q_bs_status : q_bs_state[0] ? q_bs_status | w_dtr_req_tx0_status : w_dtr_req_tx0_status;
     assign n_dtr_req_tx1_poison = q_bs_state[1] ? q_bs_poison : q_bs_state[0] ? q_bs_poison | w_dtr_req_tx0_poison : w_dtr_req_tx0_poison;
     assign n_dtr_req_tx1_dwid = q_bs_state[1] ? q_bs_dwid : q_bs_state[0] ? (q_bs_dwid & ({MRRDB{1'b1}}>> t_bs_dbits))| (w_dtr_req_tx0_dwid << w_dtr_req_tx0_dbits) : w_dtr_req_tx0_dwid;
     assign n_dtr_req_tx1_wdata = q_bs_state[1] ? q_bs_data : q_bs_state[0] ? (q_bs_data & ({MRRD{1'b1}} >> t_bs_bits))| (w_dtr_req_tx0_wdata << w_dtr_req_tx0_tbits) : w_dtr_req_tx0_wdata;
     assign n_dtr_req_tx1_be = (| q_bs_state) ? {MRRB{1'b1}} : w_dtr_req_tx0_be;
     assign n_dtr_req_tx1_cmd = q_bs_state[1] ? q_bs_cmd : w_dtr_req_tx0_cmd;
     assign n_dtr_req_tx1_mid = q_bs_state[1] ? q_bs_mid : w_dtr_req_tx0_mid;
     assign n_dtr_req_tx1_rid = q_bs_state[1] ? q_bs_rid : w_dtr_req_tx0_rid;
     assign n_dtr_req_tx1_tid = q_bs_state[1] ? q_bs_tid : w_dtr_req_tx0_tid;
     assign n_dtr_req_tx1_qin = q_bs_state[1] ? q_bs_qin : w_dtr_req_tx0_qin;
     assign n_dtr_req_tx1_tr = q_bs_state[1] ? q_bs_tr : w_dtr_req_tx0_tr;
\js } else {
     assign n_dtr_req_tx0_ready = w_dtr_req_tx1_ready;
     assign n_dtr_req_tx1_valid = w_dtr_req_tx0_valid;
     assign n_dtr_req_tx1_last = w_dtr_req_tx0_last;
     assign n_dtr_req_tx1_dwid = w_dtr_req_tx0_dwid;
     assign n_dtr_req_tx1_poison = w_dtr_req_tx0_poison;
     assign n_dtr_req_tx1_status = w_dtr_req_tx0_status;
     assign n_dtr_req_tx1_wdata = w_dtr_req_tx0_wdata;
     assign n_dtr_req_tx1_be = w_dtr_req_tx0_be;
     assign n_dtr_req_tx1_cmd = w_dtr_req_tx0_cmd;
     assign n_dtr_req_tx1_mid = w_dtr_req_tx0_mid;
     assign n_dtr_req_tx1_rid = w_dtr_req_tx0_rid;
     assign n_dtr_req_tx1_tid = w_dtr_req_tx0_tid;
     assign n_dtr_req_tx1_qin = w_dtr_req_tx0_qin;
     assign n_dtr_req_tx1_tr = w_dtr_req_tx0_tr;
\js }

\js // Get almost-full functionality by exposing the valids, and seeing how full the fifo is.
wire [\=BPL+1-1=\:0] dtr_req_tx1_valids;
assign w_dtr_req_tx1_af = dtr_req_tx1_valids[1];
\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'dtr_req_tx1',
	params: {
                depth:          BPL+1,
		width:		MRRW,
                pipeForward:    "yes",
                pipeBackward:   "yes",
                simplePipe:     "no",
                circular:       "no",
                exposeValids:   "true"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		valids:		'dtr_req_tx1_valids',
		in_ready:	'w_dtr_req_tx1_ready',
		in_valid:	'n_dtr_req_tx1_valid',
		in_data:	`{n_dtr_req_tx1_last, n_dtr_req_tx1_dwid, n_dtr_req_tx1_status,
				  n_dtr_req_tx1_poison, n_dtr_req_tx1_be, n_dtr_req_tx1_wdata, 
				  n_dtr_req_tx1_tr, n_dtr_req_tx1_qin, n_dtr_req_tx1_tid, 
				  n_dtr_req_tx1_mid, n_dtr_req_tx1_rid, n_dtr_req_tx1_cmd}`,
		out_ready:	'n_dtr_req_tx1_ready',
		out_valid:	'w_dtr_req_tx1_valid',
		out_data:	`{w_dtr_req_tx1_last, w_dtr_req_tx1_dwid, w_dtr_req_tx1_status,
				  w_dtr_req_tx1_poison, w_dtr_req_tx1_be, w_dtr_req_tx1_wdata, 
				  w_dtr_req_tx1_tr, w_dtr_req_tx1_qin, w_dtr_req_tx1_tid, 
				  w_dtr_req_tx1_mid, w_dtr_req_tx1_rid, w_dtr_req_tx1_cmd}`
	},
	portsDelimiter: '\n\t'
})=\

   assign n_dtr_req_tx1_ready = dtr_req_tx_ready_i & t_dtr_req_tx_ok;
   assign dtr_req_tx_valid_o = w_dtr_req_tx1_valid & t_dtr_req_tx_ok;
   assign dtr_req_tx_last_o = w_dtr_req_tx1_last;
   assign dtr_req_tx_tid_o = w_dtr_req_tx1_tid;
   assign dtr_req_tx_iid_o = cmd_req_iid_o;
   assign dtr_req_tx_mid_o = w_dtr_req_tx1_mid;
   assign dtr_req_tx_rid_o = w_dtr_req_tx1_rid;
   assign dtr_req_tx_cmd_o = w_dtr_req_tx1_cmd;
   
   wire [MRRP-1:0] w_dtr_req_tx1_qin_tmp;

\jsbegin
// wPriority = 3/0, QOSW = 3/1, so wPriority is never greater
/* istanbul ignore if env ncore_3p7 */
    if (concParams.hdrParams.wPriority>QOSW) { \jsend
     assign w_dtr_req_tx1_qin_tmp = {{MRRP-QOSW{1'b0}},w_dtr_req_tx1_qin};
\js } else {
     assign w_dtr_req_tx1_qin_tmp = w_dtr_req_tx1_qin[MRRP-1:0];
\js }

   assign dtr_req_tx_pri_o = w_dtr_req_tx1_qin_tmp;
   assign dtr_req_tx_ql_o = {MRRL{1'b0}};
   assign dtr_req_tx_status_o = w_dtr_req_tx1_status ? 8'h83 : 8'h0;
   assign dtr_req_tx_attr_o = {w_dtr_req_tx1_tr,	//TR: Trace
                        2'h2};	//RL: Response Level
   assign dtr_req_tx_dwid_o = w_dtr_req_tx1_dwid;
\jsbegin
// Poison not enabled on 3.7
/* istanbul ignore if env ncore_3p7 */
    if (enPoison) { \jsend
   assign dtr_req_tx_poison_o = w_dtr_req_tx1_poison;
\js } else {
   assign dtr_req_tx_poison_o = {MRRZ{w_dtr_req_tx1_poison}};
\js }
   assign dtr_req_tx_data_o = w_dtr_req_tx1_wdata;
   assign dtr_req_tx_be_o = w_dtr_req_tx1_be;
   assign dtr_req_tx_user_o = {MRRU{1'b0}};

\jsbegin
// wMpf1 is always be 1 more than FIDW in 3.7
/* istanbul ignore else env ncore_3p7 */
    if(concParams.dtwReqParams.wMpf1>FIDW) { \jsend
      assign n_dtw_req0_mpf1 = t_of_stash[1] ? {{MRW1-FIDW{1'b0}},t_oc_stashnid[w_of_oid]} : {MRW1{1'b0}};
\js } else {
      assign n_dtw_req0_mpf1 = t_of_stash[1] ? t_oc_stashnid[w_of_oid][MRW1-1:0] : {MRW1{1'b0}};
\js }
   assign n_dtw_req0_mpf2 = t_of_stash[1] ? t_oc_stashrid[w_of_oid] : {MRW2{1'b0}};
   assign n_dtw_req0_rl = t_of_stash[1] ? 2'h3 : 2'h2;
   assign n_dtw_req0_isize = t_of_stash[1] ? t_oc_isize[w_of_oid] : 2'd\=log2ceil(DW/8)-3=\;  
   assign n_dtw_req0_cmd = t_of_stash[1] ? DtwMrgMrdUDty :
\js if (STE) {
\jsbegin
/* istanbul ignore else env ncore_3p4,ncore_3p6,ncore_3p7 */
if (useOwnerTransfer>0) { \jsend
                        t_of_sel[0] ? ((~t_st_wu[w_cdq_sid] && t_st_dt[w_cdq_sid] && ~t_st_pd[w_cdq_sid] && ~t_st_is[w_cdq_sid] && t_st_cmd[w_cdq_sid]==SnpInvDtr) ? DtwDataCln : DtwDataDty) :
\jsbegin
} else { \jsend
			t_of_sel[0] ? DtwDataDty :
\jsbegin
} \jsend
\js } // STE
			(t_of_sel[1] & q_oc_write[w_odf_oid] &	//WriteEvict
			(t_oc_snoop[w_odf_oid]==4'h5)) ? DtwDataCln :
			(q_oc_write[w_of_oid] & ~q_oc_wfadw[w_of_oid] & 
			((| q_oc_beats[w_of_oid]) |
			 q_oc_partial[w_of_oid])) ? DtwDataPtl :
			DtwDataDty;
   assign n_dtw_req0_qin = 
\js if (STE) {
                       t_of_sel[0] ? t_st_pri_tmp[w_cs_sid] :
\js } // STE
                                                              w_oc_qin[w_of_oid];

\js if(concParams.hdrParams.wMsgId>OCA+1 && concParams.hdrParams.wMsgId>STA+1) {
      assign n_dtw_req0_mid = t_of_sel[0] ? {{MRWM-STA{1'b0}},w_cs_sid} | {{MRWM-1-\=Math.max(STA,OCA)=\{1'b0}},1'b1,{\=Math.max(STA, OCA)=\{1'b0}}}:{{MRWM-OCA{1'b0}},w_of_oid};
\jsbegin
    } else /* istanbul ignore next env ncore_3p7 */ if(concParams.hdrParams.wMsgId==OCA+1 && concParams.hdrParams.wMsgId>STA+1) { \jsend
      assign n_dtw_req0_mid = t_of_sel[0] ? {{MRWM-STA{1'b0}},w_cs_sid} | {1'b1,{\=Math.max(STA, OCA)=\{1'b0}}}:{1'b0,w_of_oid};
\js } else if(concParams.hdrParams.wMsgId>OCA+1 && concParams.hdrParams.wMsgId==STA+1) {
	assign n_dtw_req0_mid = t_of_sel[0] ? {1'b0,w_cs_sid} | {1'b1,{\=Math.max(STA, OCA)=\{1'b0}}}: {{MRWM-OCA{1'b0}},w_of_oid};
\js } else if(concParams.hdrParams.wMsgId==OCA+1 && concParams.hdrParams.wMsgId==STA+1) {
      assign n_dtw_req0_mid = t_of_sel[0] ? {1'b0,w_cs_sid} | {1'b1,{\=Math.max(STA, OCA)=\{1'b0}}}: {1'b0,w_of_oid};
\js } else {
      assign n_dtw_req0_mid = t_of_sel[0] ? w_cs_sid | {1'b1,{\=Math.max(STA, OCA)=\{1'b0}}}:
				 {1'b0,w_of_oid};
\js }

   assign n_dtw_req0_bid =
\js if (STE) { 
                       t_of_sel[0] ? t_st_bid[w_cs_sid] : 
\js } // STE
			(t_of_sel[2] & q_oc_wfdtr[w_of_oid]) ? q_oc_bid[w_of_oid] :
			t_of_sel[2] ? q_oc_bid[q_oc_iptr[w_of_oid]] :
			q_oc_bid[w_of_oid];
   assign n_dtw_req0_py = ~t_of_sel[0];
   assign n_dtw_req0_tr = t_of_sel[0] ? w_cs_trace :  q_oc_trace[w_of_oid];

\js if (nDIIs > 1) {
wire [\=FIDW-1=\:0] mux_dii_ids =
\js for (let i=0;i<nDIIs;i++) {
                                  ((q_oc_tin[w_of_oid][\=log2ceil(nDIIs)-1=\:0]==\=log2ceil(nDIIs)=\'d\=i=\)? dii_ids_i[\=(i*FIDW)+FIDW-1=\:\=i*FIDW=\] : {\=FIDW=\{1'b0}})\=(i==(nDIIs-1))?";":"|"=\
\js }
\js }
\js if (nDMIs > 1) {
wire [\=FIDW-1=\:0] mux_dmi_ids =
\js for (let i=0;i<nDMIs;i++) {
                                  ((q_oc_tin[w_of_oid][\=log2ceil(nDMIs)-1=\:0]==\=log2ceil(nDMIs)=\'d\=i=\)? dmi_ids_i[\=(i*FIDW)+FIDW-1=\:\=i*FIDW=\] : {\=FIDW=\{1'b0}})\=(i==(nDMIs-1))?";":"|"=\
\js }
\js }

   assign n_dtw_req0_tid = {(t_of_sel[2] ? dve_ids_i[0 +: FIDW] :
\js if (STE) {
			 t_of_sel[0] ? t_st_sdid[w_cs_sid] :
\js } // STE
			 q_oc_tin[w_of_oid][TINW+1] ?
\js if (nDIIs==1) {
			 dii_ids_i[0*FIDW +: FIDW] :
\js } else {
			 mux_dii_ids :
\js }
\js if (nDMIs==1) {
			 dmi_ids_i[0*FIDW +: FIDW]),
\js } else {
			 mux_dmi_ids),
\js }
                       {PIDW{1'b0}}};

   assign n_dtw_req0_addr = 
\js if (STE) {
                        t_of_sel[0] ? t_st_addr[w_cs_sid] : 
\js } // STE
                                                            q_oc_addr[w_of_oid];
   assign n_dtw_req0_security = t_of_sel[0] ? w_cs_security : q_oc_security[w_of_oid];
   assign n_dtw_req0_last = w_of_last;
   wire t_dtw_req0_dwid_carry;
   assign {t_dtw_req0_dwid_carry,t_dtw_req0_dwid} = {1'b0,w_of_count} + {1'b0,n_dtw_req0_addr[5 -: BWL]};

\js //////////////////////////////////////////////////////////////////////////////////////////
\js // Better code (n_dtw_req0_dwid needs to be a reg)
\js //   DW   BWL
\js //   64   3
\js //   128  2
\js //   256  1

wire [6:0] current_addr = {{\=7-BWL-BWL=\{1'b0}},w_of_count,{BWL{1'b0}}} + {1'b0,n_dtw_req0_addr[5:0]};
\js if(BWL>1) {
wire [2:0] dwid_three_bit = {t_dtw_req0_dwid[1:0], 1'b0};
\js } else {
wire [2:0] dwid_three_bit = {1'b0, t_dtw_req0_dwid, 1'b0};
\js }
wire [3:0] wrap_two = current_addr [6:3] - 3'd2;
wire [3:0] wrap_four = current_addr [6:3] - 3'd4;

\js // t_of_sel[0] == 1 -> Snoop
\js // |t_oc_atop[w_of_oid] == 1 -> Atomic
wire n_dtw_req0_snoop_or_atomic_or_notwrap = t_of_sel[0] ? 1'b1 : (|t_oc_atop[w_of_oid] || ~q_oc_wrap[w_of_oid]); // Need this construct ti filter Xs on snoops.

\js if (BWL==3) {
assign extra_beat = ({{\=8-BWL=\{1'b0}},q_oc_beats[w_of_oid]}==8'd4) ? ({{\=8-BWL=\{1'b0}},w_of_count} >= 8'd4) : ({{\=8-BWL=\{1'b0}},w_of_count} >= 8'd2);
\js } else if (BWL==2) {
assign extra_beat = ({{\=8-BWL=\{1'b0}},w_of_count} >= 8'd2);
\js } else {
assign extra_beat = 1'b0;
\js }

always @(*) begin
  casez ({n_dtw_req0_snoop_or_atomic_or_notwrap, (BWL==1), (BWL==2), (BWL==3), n_dtw_req0_addr[5:4], ({{\=8-BWL=\{1'b0}},q_oc_beats[w_of_oid]}==8'd2), ({{\=8-BWL=\{1'b0}},q_oc_beats[w_of_oid]}==8'd4), extra_beat})
\js // INCR
    \js if ( BWL == 1 ) {
    9'b1_100_??_??? : n_dtw_req0_dwid = {t_dtw_req0_dwid, 2'h3, t_dtw_req0_dwid, 2'h2, t_dtw_req0_dwid, 2'h1, t_dtw_req0_dwid, 2'h0};
    \js }
    \js if ( BWL == 2 ) {
    9'b1_010_??_??? : n_dtw_req0_dwid = {t_dtw_req0_dwid, 1'b1, t_dtw_req0_dwid, 1'b0}; 
    \js }
    \js if ( BWL == 3 ) {
    9'b1_001_??_??? : n_dtw_req0_dwid = t_dtw_req0_dwid;
    \js }
\js // WRAP
\js // 64
    \js if ( BWL == 3 ) {
    9'b0_001_0?_010 : n_dtw_req0_dwid = current_addr[5] ? wrap_four[2:0] : t_dtw_req0_dwid;
    9'b0_001_1?_010 : n_dtw_req0_dwid = current_addr[6] ? wrap_four[2:0] : t_dtw_req0_dwid;
    9'b0_001_00_100 : n_dtw_req0_dwid = (current_addr[5:4] == 2'b01) ? wrap_two[2:0] : t_dtw_req0_dwid;
    9'b0_001_01_100 : n_dtw_req0_dwid = (current_addr[5:4] == 2'b10) ? wrap_two[2:0] : t_dtw_req0_dwid;
    9'b0_001_10_100 : n_dtw_req0_dwid = (current_addr[5:4] == 2'b11) ? wrap_two[2:0] : t_dtw_req0_dwid;
    9'b0_001_11_100 : n_dtw_req0_dwid = current_addr[6] ? wrap_two[2:0] : t_dtw_req0_dwid;
    9'b0_001_??_101 : n_dtw_req0_dwid = {3{~n_dtw_req0_addr[5]}};
    9'b0_001_??_011 : n_dtw_req0_dwid = {3{~n_dtw_req0_addr[5]}};
    9'b0_001_??_00? : n_dtw_req0_dwid = t_dtw_req0_dwid;
    \js }
\js // 128
    \js if ( BWL == 2 ) {
    9'b0_010_00_10? : n_dtw_req0_dwid = {t_dtw_req0_dwid, 1'b1, t_dtw_req0_dwid, 1'b0};
    9'b0_010_01_100 : n_dtw_req0_dwid = (w_of_count==1) ? {dwid_three_bit-3'd3, dwid_three_bit-3'd4} : {dwid_three_bit+3'd1, dwid_three_bit};
    9'b0_010_01_101 : n_dtw_req0_dwid = 6'b111111;
    9'b0_010_10_10? : n_dtw_req0_dwid = {t_dtw_req0_dwid, 1'b1, t_dtw_req0_dwid, 1'b0};
    9'b0_010_11_100 : n_dtw_req0_dwid = (w_of_count==1) ? {3'd5, 3'd4} : {dwid_three_bit+3'd1, dwid_three_bit};
    9'b0_010_11_101 : n_dtw_req0_dwid = 6'b000000;
    9'b0_010_??_0?? : n_dtw_req0_dwid = {t_dtw_req0_dwid, 1'b1, t_dtw_req0_dwid, 1'b0};
    \js }
\js // 256
    \js if ( BWL == 1 ) {
    9'b0_100_??_??? : n_dtw_req0_dwid = {t_dtw_req0_dwid, 2'd3, t_dtw_req0_dwid, 2'd2, t_dtw_req0_dwid, 2'd1, t_dtw_req0_dwid, 2'd0};
    \js }
\js // Default
    default: begin
               n_dtw_req0_dwid = {MRWZ*3{XO}};
             end
  endcase
end
//////////////////////////////////////////////////////////////////////////////////////////

   assign n_dtw_req0_status = (|w_of_poison);
   assign n_dtw_req0_poison = w_of_poison;
   assign n_dtw_req0_wdata = w_of_rdata;
   assign n_dtw_req0_be = ((t_of_sel[0]) | ({1'b0,w_of_count} < {(~| q_oc_beats[w_of_oid]),q_oc_beats[w_of_oid]})) ? w_of_be : {MRWB{1'b0}};

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'dtw_req0',
	params: {
                depth:          1,
		width:		MRWW,
                pipeForward:    "yes",
                pipeBackward:   "no",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_dtw_req0_ready',
		in_valid:	'n_dtw_req0_valid',
		in_data:	`{n_dtw_req0_last, n_dtw_req0_dwid, n_dtw_req0_status,
				  n_dtw_req0_poison, n_dtw_req0_be, n_dtw_req0_wdata, 
				  n_dtw_req0_py, n_dtw_req0_tr, n_dtw_req0_rl, n_dtw_req0_qin,
				  n_dtw_req0_mpf1, n_dtw_req0_mpf2,
				  n_dtw_req0_tid, n_dtw_req0_mid, 
				  n_dtw_req0_bid, n_dtw_req0_cmd, n_dtw_req0_isize}`,
		out_ready:	'n_dtw_req0_ready',
		out_valid:	'w_dtw_req0_valid',
		out_data:	`{w_dtw_req0_last, w_dtw_req0_dwid, w_dtw_req0_status,
				  w_dtw_req0_poison, w_dtw_req0_be, w_dtw_req0_wdata, 
				  w_dtw_req0_py, w_dtw_req0_tr, w_dtw_req0_rl, w_dtw_req0_qin,
				  w_dtw_req0_mpf1, w_dtw_req0_mpf2,
				  w_dtw_req0_tid, w_dtw_req0_mid, 
				  w_dtw_req0_bid, w_dtw_req0_cmd,w_dtw_req0_isize}`
	},
	portsDelimiter: '\n\t'
})=\
\js // Get almost-full functionality by exposing the valids, and seeing how full the fifo is.
wire [\=(((useCache>0) || (CDW>1)) ? BPL+1 : 1)-1=\:0] dtw_req1_valids;
\js if ((useCache>0) || (CDW>1)) {
assign w_dtw_req1_af = dtw_req1_valids[1];
\js } else {
assign w_dtw_req1_af = 1'b0;
\js }
\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'dtw_req1',
	params: {
                depth:          (((useCache>0) || (CDW>1)) ? BPL+1 : 1),
		width:		MRWW,
                pipeForward:    ((useCache>0) || (CDW>1)) ? "yes" : "no",
                pipeBackward:   "yes",
                simplePipe:     "no",
                circular:       "no",
                exposeValids:   "true"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		valids:		'dtw_req1_valids',
		in_ready:	'n_dtw_req0_ready',
		in_valid:	'w_dtw_req0_valid',
		in_data:	`{w_dtw_req0_last, w_dtw_req0_dwid, w_dtw_req0_status,
				  w_dtw_req0_poison, w_dtw_req0_be, w_dtw_req0_wdata, 
				  w_dtw_req0_py, w_dtw_req0_tr, w_dtw_req0_rl, w_dtw_req0_qin,
				  w_dtw_req0_mpf1, w_dtw_req0_mpf2,
				  w_dtw_req0_tid, w_dtw_req0_mid, 
				  w_dtw_req0_bid, w_dtw_req0_cmd,w_dtw_req0_isize}`,
		out_ready:	'n_dtw_req1_ready',
		out_valid:	'w_dtw_req1_valid',
		out_data:	`{w_dtw_req1_last, w_dtw_req1_dwid, w_dtw_req1_status,
				  w_dtw_req1_poison, w_dtw_req1_be, w_dtw_req1_wdata, 
				  w_dtw_req1_py, w_dtw_req1_tr, w_dtw_req1_rl, w_dtw_req1_qin,
				  w_dtw_req1_mpf1, w_dtw_req1_mpf2,
				  w_dtw_req1_tid, w_dtw_req1_mid, 
				  w_dtw_req1_bid, w_dtw_req1_cmd,w_dtw_req1_isize}`
	},
	portsDelimiter: '\n\t'
})=\

   assign n_dtw_req1_ready = dtw_req_ready_i & t_dtw_req_ok;
   assign dtw_req_valid_o = w_dtw_req1_valid & t_dtw_req_ok;
   assign dtw_req_last_o = w_dtw_req1_last;
   assign dtw_req_tid_o = w_dtw_req1_tid;
   assign dtw_req_iid_o = cmd_req_iid_o;
   assign dtw_req_mid_o = w_dtw_req1_mid;
   assign dtw_req_bid_o = w_dtw_req1_bid;
   assign dtw_req_cmd_o = w_dtw_req1_cmd;
   
   wire [MRWP-1:0] w_dtw_req1_qin_tmp;
\jsbegin
// wPriority = 3/0, QOSW = 3/1, so wPriority is never greater
/* istanbul ignore if env ncore_3p7 */
    if (concParams.hdrParams.wPriority>QOSW) { \jsend
     assign w_dtw_req1_qin_tmp = {{MRWP-QOSW{1'b0}},w_dtw_req1_qin};
\js } else {
     assign w_dtw_req1_qin_tmp = w_dtw_req1_qin[MRWP-1:0];
\js }

   assign dtw_req_pri_o = w_dtw_req1_qin_tmp;
   assign dtw_req_ql_o = {MRWL{1'b0}};
   assign dtw_req_status_o = w_dtw_req1_status ? 8'h83 : 8'h0;
   assign dtw_req_attr_o = {w_dtw_req1_py,		//PY: Primary
     w_dtw_req1_tr,		//TR: Trace
     w_dtw_req1_rl};	//RL: Response Level
   assign dtw_req_isize_o = w_dtw_req1_isize;

   assign dtw_req_dwid_o = w_dtw_req1_dwid;
\jsbegin
// Poison not enabled on 3.7
/* istanbul ignore if env ncore_3p7 */
    if (enPoison) { \jsend
   assign dtw_req_poison_o = w_dtw_req1_poison;
\js } else {
   assign dtw_req_poison_o = {MRWZ{w_dtw_req1_poison}};
\js }
   assign dtw_req_mpf1_o = w_dtw_req1_mpf1;
   assign dtw_req_mpf2_o = w_dtw_req1_mpf2;
   assign dtw_req_data_o = w_dtw_req1_wdata;
   assign dtw_req_be_o = w_dtw_req1_be;
   assign dtw_req_user_o = {MRWU{1'b0}};

   assign cmd_rsp_ready_o = w_cmd_rsp_ready & q_reset_n;
   assign n_cmd_rsp_valid = cmd_rsp_valid_i & q_reset_n & (cmd_rsp_tid_i == myid_i) & ~cmd_rsp_uce_i;

   assign n_cmd_rsp_ready = 1'b1;
   
\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'cmd_rsp',
	params: {
                depth:          2,
		width:		8+OCA+MPCI,
                pipeForward:    "yes",
                pipeBackward:   "yes",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_cmd_rsp_ready',
		in_valid:	'n_cmd_rsp_valid',
		in_data:	'{cmd_rsp_status_i, cmd_rsp_mid_i[OCA-1:0], cmd_rsp_iid_i}',
		out_ready:	'n_cmd_rsp_ready',
		out_valid:	'w_cmd_rsp_valid',
		out_data:	'{w_cmd_rsp_status, w_cmd_rsp_mid, w_cmd_rsp_iid}'
	},
	portsDelimiter: '\n\t'
})=\

   assign t_cmd_rsp_dec = w_cmd_rsp_valid & n_cmd_rsp_ready;
   assign dtr_rsp_rx_ready_o = w_dtr_rsp_rx_ready & q_reset_n;
   assign n_dtr_rsp_rx_valid = dtr_rsp_rx_valid_i & q_reset_n & (dtr_rsp_rx_tid_i == myid_i) & ~dtr_rsp_rx_uce_i;
   assign n_dtr_rsp_rx_ready_mod = 1'b1;

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'dtr_rsp_rx',
	params: {
                depth:          2,
		width:		8+MRRM,
                pipeForward:    "yes",
                pipeBackward:   "yes",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_dtr_rsp_rx_ready',
		in_valid:	'n_dtr_rsp_rx_valid',
		in_data:	'{dtr_rsp_rx_status_i, dtr_rsp_rx_mid_i}',
		out_ready:	'n_dtr_rsp_rx_ready',
		out_valid:	'w_dtr_rsp_rx_valid',
		out_data:	'{w_dtr_rsp_rx_status, w_dtr_rsp_rx_mid}'
	},
	portsDelimiter: '\n\t'
})=\

\jsbegin
// always enabled on 3.6
/* istanbul ignore else env ncore_3p6,ncore_3p7 */
    if (useEarlyDtr) { \jsend
   assign w_dtr_rsp_rx_valid_mod = w_dtr_rsp_rx_valid     ; //& ~halt_dtr_rsp_id_clear;
   assign n_dtr_rsp_rx_ready     = n_dtr_rsp_rx_ready_mod ; //& ~halt_dtr_rsp_id_clear;
\js } else {
   assign w_dtr_rsp_rx_valid_mod = w_dtr_rsp_rx_valid     ;
   assign n_dtr_rsp_rx_ready     = n_dtr_rsp_rx_ready_mod ;
\js }

   assign dtw_rsp_ready_o = w_dtw_rsp_ready & q_reset_n;
   assign n_dtw_rsp_valid = dtw_rsp_valid_i & q_reset_n & (dtw_rsp_tid_i == myid_i) & ~dtw_rsp_uce_i;
   assign n_dtw_rsp_ready = 1'b1;

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'dtw_rsp',
	params: {
                depth:          2,
		width:		8+MRWM,
                pipeForward:    "yes",
                pipeBackward:   "yes",
                simplePipe:     "no",
                circular:       "no",
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_dtw_rsp_ready',
		in_valid:	'n_dtw_rsp_valid',
		in_data:	'{dtw_rsp_status_i, dtw_rsp_mid_i}',
		out_ready:	'n_dtw_rsp_ready',
		out_valid:	'w_dtw_rsp_valid',
		out_data:	'{w_dtw_rsp_status, w_dtw_rsp_mid}'
	},
	portsDelimiter: '\n\t'
})=\

   assign upd_rsp_ready_o = w_upd_rsp_ready & q_reset_n;
   assign n_upd_rsp_valid = upd_rsp_valid_i & q_reset_n & (upd_rsp_tid_i == myid_i) & ~upd_rsp_uce_i;
   assign n_upd_rsp_ready = 1'b1;

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'upd_rsp',
	params: {
                depth:          2,
		width:		8+OCA,
                pipeForward:    "yes",
                pipeBackward:   "yes",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_upd_rsp_ready',
		in_valid:	'n_upd_rsp_valid',
		in_data:	'{upd_rsp_status_i, upd_rsp_mid_i[OCA-1:0]}',
		out_ready:	'n_upd_rsp_ready',
		out_valid:	'w_upd_rsp_valid',
		out_data:	'{w_upd_rsp_status, w_upd_rsp_mid}'
	},
	portsDelimiter: '\n\t'
})=\

   assign t_cmd_req_inc = w_cmd_req1_valid & n_cmd_req1_ready;
   assign t_cmd_req_dec = w_cmd_rsp_valid & n_cmd_rsp_ready;
   assign t_cmd_req_ok = ((~| cfg_cmd_req_max_i) | (q_cmd_req_count < cfg_cmd_req_max_i));
   
   assign t_dtr_req_tx_inc = w_dtr_req_tx1_valid & n_dtr_req_tx1_ready & w_dtr_req_tx1_last;
   assign t_dtr_req_tx_dec = w_dtr_rsp_rx_valid_mod & n_dtr_rsp_rx_ready_mod;
   assign t_dtr_req_tx_ok = (~| cfg_dtr_req_tx_max_i) | (q_dtr_req_tx_count < cfg_dtr_req_tx_max_i);

   assign t_dtw_req_inc = w_dtw_req1_valid & n_dtw_req1_ready & w_dtw_req1_last;
   assign t_dtw_req_dec = w_dtw_rsp_valid & n_dtw_rsp_ready;
   assign t_dtw_req_ok = (~| cfg_dtw_req_max_i) | (q_dtw_req_count < cfg_dtw_req_max_i);

   assign t_upd_req_inc = w_upd_req1_valid & n_upd_req1_ready;
   assign t_upd_req_dec = w_upd_rsp_valid & n_upd_rsp_ready;
   assign t_upd_req_ok = (~| cfg_upd_req_max_i) | (q_upd_req_count < cfg_upd_req_max_i);

   wire q_reset_n_ns = t_cfg_init ? 1'b0 : q_reset_n ? q_reset_n : ({{32-ODA{1'b0}},q_init_count}==(ODN-1));
   \=u.dffre(1, `q_reset_n`, `q_reset_n_ns`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
   wire [ODA-1:0] q_init_count_p1;
   wire q_init_count_carry;
   assign {q_init_count_carry,q_init_count_p1} = {1'b0,q_init_count} + 1'b1;
   wire [ODA-1:0] q_init_count_ns = t_cfg_init ? {ODA{1'b0}} : (~q_reset_n & w_init_ready) ? q_init_count_p1 : q_init_count;
   \=u.dffre(ODA, `q_init_count`, `q_init_count_ns`, `{`+ODA+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
   wire [BWL-1:0] q_w1_beats_p1;
   wire q_w1_beats_carry;
   assign {q_w1_beats_carry,q_w1_beats_p1} = {1'b0,q_w1_beats} + 1'b1;
   wire [BWL-1:0] q_w1_beats_ns = (t_w1_end & w_dw_valid & n_dw_ready) ? {BWL{1'b0}} : (w_dw_valid & n_dw_ready) ? q_w1_beats_p1 : q_w1_beats;
   \=u.dffre(BWL, `q_w1_beats`, `q_w1_beats_ns`, `{`+BWL+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
   wire q_w1_partial_ns = n_aw_ready ? 1'b0 : (w_dw_valid & n_dw_ready & (~&w_adw_be)) ? 1'b1: q_w1_partial;
   \=u.dffre(1, `q_w1_partial`, `q_w1_partial_ns`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
	  
   wire [7:0] q_cmd_req_count_m1;
   wire q_cmd_req_count_underflow;
   assign {q_cmd_req_count_underflow,q_cmd_req_count_m1} = {1'b0,q_cmd_req_count} - 1'b1;
   wire [7:0] q_cmd_req_count_p1;
   wire q_cmd_req_count_carry;
   assign {q_cmd_req_count_carry,q_cmd_req_count_p1} = {1'b0,q_cmd_req_count} + 1'b1;
   wire [8-1:0] q_cmd_req_count_ns = (t_cmd_req_inc & ~t_cmd_req_dec) ? q_cmd_req_count_p1 : (~t_cmd_req_inc & t_cmd_req_dec) ? q_cmd_req_count_m1 : q_cmd_req_count;
   \=u.dffre(8, `q_cmd_req_count`, `q_cmd_req_count_ns`, `8'd0`, `1'b1`, `clk_i`, `reset_ni`)=\
   wire [7:0] q_dtr_req_tx_count_m1;
   wire q_dtr_req_tx_count_underflow;
   assign {q_dtr_req_tx_count_underflow,q_dtr_req_tx_count_m1} = {1'b0,q_dtr_req_tx_count} - 1'b1;
   wire [7:0] q_dtr_req_tx_count_p1;
   wire q_dtr_req_tx_count_carry;
   assign {q_dtr_req_tx_count_carry,q_dtr_req_tx_count_p1} = {1'b0,q_dtr_req_tx_count} + 1'b1;
   wire [8-1:0] q_dtr_req_tx_count_ns = (t_dtr_req_tx_inc & ~t_dtr_req_tx_dec) ? q_dtr_req_tx_count_p1 : (~t_dtr_req_tx_inc & t_dtr_req_tx_dec) ? q_dtr_req_tx_count_m1 : q_dtr_req_tx_count;
   \=u.dffre(8, `q_dtr_req_tx_count`, `q_dtr_req_tx_count_ns`, `8'd0`, `1'b1`, `clk_i`, `reset_ni`)=\
   wire [7:0] q_dtw_req_count_m1;
   wire q_dtw_req_count_underflow;
   assign {q_dtw_req_count_underflow,q_dtw_req_count_m1} = {1'b0,q_dtw_req_count} - 1'b1;
   wire [7:0] q_dtw_req_count_p1;
   wire q_dtw_req_count_carry;
   assign {q_dtw_req_count_carry,q_dtw_req_count_p1} = {1'b0,q_dtw_req_count} + 1'b1;
   wire [8-1:0] q_dtw_req_count_ns = (t_dtw_req_inc & ~t_dtw_req_dec) ? q_dtw_req_count_p1 : (~t_dtw_req_inc & t_dtw_req_dec) ? q_dtw_req_count_m1 : q_dtw_req_count;
   \=u.dffre(8, `q_dtw_req_count`, `q_dtw_req_count_ns`, `8'd0`, `1'b1`, `clk_i`, `reset_ni`)=\
   wire [7:0] q_upd_req_count_m1;
   wire q_upd_req_count_underflow;
   assign {q_upd_req_count_underflow,q_upd_req_count_m1} = {1'b0,q_upd_req_count} - 1'b1;
   wire [7:0] q_upd_req_count_p1;
   wire q_upd_req_count_carry;
   assign {q_upd_req_count_carry,q_upd_req_count_p1} = {1'b0,q_upd_req_count} + 1'b1;
   wire [8-1:0] q_upd_req_count_ns = (t_upd_req_inc & ~t_upd_req_dec) ? q_upd_req_count_p1 : (~t_upd_req_inc & t_upd_req_dec) ? q_upd_req_count_m1 : q_upd_req_count;
   \=u.dffre(8, `q_upd_req_count`, `q_upd_req_count_ns`, `8'd0`, `1'b1`, `clk_i`, `reset_ni`)=\
	  
\js // var    64    128    256
\js // CLO     6      6      6
\js // AWL     3      4      5
\js // BWL     3      2      1

   assign n_rb_valid = (| n_rb_count);
   assign n_rb_addr = 
\jsbegin
// Only applicable if bus width is 512bits or greater
/* istanbul ignore if env ncore_3p7 */
    if ((AWL+1-CLO)>0) { \jsend
                      (w_rb_valid & (w_rb_burst==2'h2) & (w_rb_wrap==2'h0)) ? {w_rb_addr[AW-1:AWL+1], (w_rb_addr[CLO +: \=ioaiu_pos(AWL+1-CLO)=\] + 1'b1), {CLO{1'b0}}} :
\js }
\js if ((AWL+2-CLO)>0) {
		      (w_rb_valid & (w_rb_burst==2'h2) & (w_rb_wrap==2'h1)) ? {w_rb_addr[AW-1:AWL+2], (w_rb_addr[CLO +: \=ioaiu_pos(AWL+2-CLO)=\] + 1'b1), {CLO{1'b0}}} :
\js }
\js if ((AWL+3-CLO)>0) {
		      (w_rb_valid & (w_rb_burst==2'h2) & (w_rb_wrap==2'h2)) ? {w_rb_addr[AW-1:AWL+3], (w_rb_addr[CLO +: \=ioaiu_pos(AWL+3-CLO)=\] + 1'b1), {CLO{1'b0}}} :
\js }
\jsbegin
// Always true if bus width is 64 bits or greater
/* istanbul ignore else env ncore_3p7 */
    if ((AWL+4-CLO)>0) { \jsend
		      (w_rb_valid & (w_rb_burst==2'h2) & (w_rb_wrap==2'h3)) ? {w_rb_addr[AW-1:AWL+4], (w_rb_addr[CLO +: \=ioaiu_pos(AWL+4-CLO)=\] + 1'b1), {CLO{1'b0}}} :
\js }
		      (w_rb_valid & (w_rb_burst==2'h1)) ? {w_rb_addr[AW-1:12], (w_rb_addr[11:CLO] + 1'b1), {CLO{1'b0}}}:
		      w_rb_valid ? w_rb_addr :
\jsbegin
// Only applicable if bus width is 512bits or greater
/* istanbul ignore if env ncore_3p7 */
    if ((AWL+1-CLO)>0) { \jsend
		      ((w_p0r_burst==2'h2) & (w_p0r_len==8'h1)) ? {w_p0r_addr[AW-1:AWL+1], (w_p0r_addr[CLO +: \=ioaiu_pos(AWL+1-CLO)=\] + 1'b1), {CLO{1'b0}}} :
\js }
\js if ((AWL+2-CLO)>0) {
		      ((w_p0r_burst==2'h2) & (w_p0r_len==8'h3)) ? {w_p0r_addr[AW-1:AWL+2], (w_p0r_addr[CLO +: \=ioaiu_pos(AWL+2-CLO)=\] + 1'b1), {CLO{1'b0}}} :
\js }
\js if ((AWL+3-CLO)>0) {
		      ((w_p0r_burst==2'h2) & (w_p0r_len==8'h7)) ? {w_p0r_addr[AW-1:AWL+3], (w_p0r_addr[CLO +: \=ioaiu_pos(AWL+3-CLO)=\] + 1'b1), {CLO{1'b0}}} :
\js }
\jsbegin
// Always true if bus width is 64 bits or greater
/* istanbul ignore else env ncore_3p7 */
    if ((AWL+4-CLO)>0) { \jsend
		      ((w_p0r_burst==2'h2) & (w_p0r_len==8'hf)) ? {w_p0r_addr[AW-1:AWL+4], (w_p0r_addr[CLO +: \=ioaiu_pos(AWL+4-CLO)=\] + 1'b1), {CLO{1'b0}}} :
\js }
		      (w_p0r_burst==2'h1) ? {w_p0r_addr[AW-1:12], (w_p0r_addr[11:CLO] + 1'b1), {CLO{1'b0}}} :
		      w_p0r_addr;
   assign n_rb_len = w_rb_valid ? (w_rb_len - 8'd\=BPL=\) : (w_p0r_len + {\=8-BWL=\'b0,w_p0r_addr[AWL +: BWL]} - 8'd\=BPL=\);
   assign n_rb_size = w_rb_valid ? w_rb_size : w_p0r_size;
   assign n_rb_burst = w_rb_valid ? w_rb_burst : w_p0r_burst;
   assign n_rb_lock = w_rb_valid ? w_rb_lock : w_p0r_lock;
   assign n_rb_cache = w_rb_valid ? w_rb_cache : w_p0r_cache;
   assign n_rb_prot = w_rb_valid ? w_rb_prot : w_p0r_prot;
   assign n_rb_region = w_rb_valid ? w_rb_region : w_p0r_region;
   assign n_rb_qos = w_rb_valid ? w_rb_qos : w_p0r_qos;
   assign n_rb_id = w_rb_valid ? w_rb_id : w_p0r_id;
   assign n_rb_domain = w_rb_valid ? w_rb_domain : w_p0r_domain;
   assign n_rb_snoop = w_rb_valid ? w_rb_snoop : w_p0r_snoop;
   assign n_rb_bar = w_rb_valid ? w_rb_bar : w_p0r_bar;
   assign n_rb_user = w_rb_valid ? w_rb_user : w_p0r_user;
   assign n_rb_track = w_rb_valid ? w_rb_track : w_p0r_track;
   assign n_rb_wrap = w_rb_valid ? w_rb_wrap :
		      (w_p0r_len == 8'hf) ? 2'h3 :
		      (w_p0r_len == 8'h7) ? 2'h2 :
		      (w_p0r_len == 8'h3) ? 2'h1 :
		      2'h0;

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'rb',
	params: {
                depth:          1,
		width:		AXW+2+(16-AWL),
                pipeForward:    "yes",
                pipeBackward:   "no",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_rb_ready',
		in_valid:	'n_rb_valid',
		in_data:	`{n_rb_addr, n_rb_len, n_rb_size, n_rb_burst, 
				  n_rb_lock, n_rb_cache, n_rb_prot, n_rb_region,
				  n_rb_qos, n_rb_id, n_rb_domain, n_rb_snoop, 
				  n_rb_bar, n_rb_user, n_rb_track, n_rb_wrap, 
				  n_rb_count}`,
		out_ready:	'n_rb_ready',
		out_valid:	'w_rb_valid',
		out_data:	`{w_rb_addr, w_rb_len, w_rb_size, w_rb_burst, 
				  w_rb_lock, w_rb_cache, w_rb_prot, w_rb_region,
				  w_rb_qos, w_rb_id, w_rb_domain, w_rb_snoop, 
				  w_rb_bar, w_rb_user, w_rb_track, w_rb_wrap, 
				  w_rb_count}`
	},
	portsDelimiter: '\n\t'
})=\

   assign n_wb_valid = (| n_wb_count);
   assign n_wb_addr = 
\jsbegin
// Only applicable if bus width is 512bits or greater
/* istanbul ignore if env ncore_3p7 */
    if ((AWL+1-CLO)>0) { \jsend
                      (w_wb_valid & (w_wb_burst==2'h2) & (w_wb_wrap==2'h0)) ? {w_wb_addr[AW-1:AWL+1], (w_wb_addr[CLO +: \=ioaiu_pos(AWL+1-CLO)=\] + 1'b1), {CLO{1'b0}}} :
\js }
\js if ((AWL+2-CLO)>0) {
		      (w_wb_valid & (w_wb_burst==2'h2) & (w_wb_wrap==2'h1)) ? {w_wb_addr[AW-1:AWL+2], (w_wb_addr[CLO +: \=ioaiu_pos(AWL+2-CLO)=\] + 1'b1), {CLO{1'b0}}} :
\js }
\js if ((AWL+3-CLO)>0) {
		      (w_wb_valid & (w_wb_burst==2'h2) & (w_wb_wrap==2'h2)) ? {w_wb_addr[AW-1:AWL+3], (w_wb_addr[CLO +: \=ioaiu_pos(AWL+3-CLO)=\] + 1'b1), {CLO{1'b0}}} :
\js }
\jsbegin
// Always true if bus width is 64 bits or greater
/* istanbul ignore else env ncore_3p7 */
    if ((AWL+4-CLO)>0) { \jsend
		      (w_wb_valid & (w_wb_burst==2'h2) & (w_wb_wrap==2'h3)) ? {w_wb_addr[AW-1:AWL+4], (w_wb_addr[CLO +: \=ioaiu_pos(AWL+4-CLO)=\] + 1'b1), {CLO{1'b0}}} :
\js }
		      (w_wb_valid & (w_wb_burst==2'h1)) ? {w_wb_addr[AW-1:12], (w_wb_addr[11:CLO] + 1'b1), {CLO{1'b0}}}:
		      w_wb_valid ? w_wb_addr :
\jsbegin
// Only applicable if bus width is 512bits or greater
/* istanbul ignore if env ncore_3p7 */
    if ((AWL+1-CLO)>0) { \jsend
		      ((w_w0_burst==2'h2) & (w_w0_len==8'h1)) ? {w_w0_addr[AW-1:AWL+1], (w_w0_addr[CLO +: \=ioaiu_pos(AWL+1-CLO)=\] + 1'b1), {CLO{1'b0}}} :
\js }
\js if ((AWL+2-CLO)>0) {
		      ((w_w0_burst==2'h2) & (w_w0_len==8'h3)) ? {w_w0_addr[AW-1:AWL+2], (w_w0_addr[CLO +: \=ioaiu_pos(AWL+2-CLO)=\] + 1'b1), {CLO{1'b0}}} :
\js }
\js if ((AWL+3-CLO)>0) {
		      ((w_w0_burst==2'h2) & (w_w0_len==8'h7)) ? {w_w0_addr[AW-1:AWL+3], (w_w0_addr[CLO +: \=ioaiu_pos(AWL+3-CLO)=\] + 1'b1), {CLO{1'b0}}} :
\js }
\jsbegin
// Always true if bus width is 64 bits or greater
/* istanbul ignore else env ncore_3p7 */
    if ((AWL+4-CLO)>0) { \jsend
		      ((w_w0_burst==2'h2) & (w_w0_len==8'hf)) ? {w_w0_addr[AW-1:AWL+4], (w_w0_addr[CLO +: \=ioaiu_pos(AWL+4-CLO)=\] + 1'b1), {CLO{1'b0}}} :
\js }
		      (w_w0_burst==2'h1) ? {w_w0_addr[AW-1:12], (w_w0_addr[11:CLO] + 1'b1), {CLO{1'b0}}} :
		      w_w0_addr;
   assign n_wb_len = w_wb_valid ? (w_wb_len - 8'd\=BPL=\) : (w_w0_len + {\=8-BWL=\'b0,w_w0_addr[AWL +: BWL]} - 8'd\=BPL=\);
   assign n_wb_size = w_wb_valid ? w_wb_size : w_w0_size;
   assign n_wb_burst = w_wb_valid ? w_wb_burst : w_w0_burst;
   assign n_wb_lock = w_wb_valid ? w_wb_lock : w_w0_lock;
   assign n_wb_cache = w_wb_valid ? w_wb_cache : w_w0_cache;
   assign n_wb_prot = w_wb_valid ? w_wb_prot : w_w0_prot;
   assign n_wb_region = w_wb_valid ? w_wb_region : w_w0_region;
   assign n_wb_qos = w_wb_valid ? w_wb_qos : w_w0_qos;
   assign n_wb_id = w_wb_valid ? w_wb_id : w_w0_id;
   assign n_wb_domain = w_wb_valid ? w_wb_domain : w_w0_domain;
   assign n_wb_snoop = w_wb_valid ? w_wb_snoop : w_w0_snoop;
   assign n_wb_bar = w_wb_valid ? w_wb_bar : w_w0_bar;
   assign n_wb_user = w_wb_valid ? w_wb_user : w_w0_user;
   assign n_wb_track = w_wb_valid ? w_wb_track : w_w0_track;
   assign n_wb_wrap = w_wb_valid ? w_wb_wrap :
		      (w_w0_len == 8'hf) ? 2'h3 :
		      (w_w0_len == 8'h7) ? 2'h2 :
		      (w_w0_len == 8'h3) ? 2'h1 :
		      2'h0;

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'wb',
	params: {
                depth:          1,
		width:		AXW+2+(16-AWL),
                pipeForward:    "yes",
                pipeBackward:   "no",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_wb_ready',
		in_valid:	'n_wb_valid',
		in_data:	`{n_wb_addr, n_wb_len, n_wb_size, n_wb_burst, 
				  n_wb_lock, n_wb_cache, n_wb_prot, n_wb_region,
				  n_wb_qos, n_wb_id, n_wb_domain, n_wb_snoop, 
				  n_wb_bar, n_wb_user, n_wb_track, n_wb_wrap, 
				  n_wb_count}`,
		out_ready:	'n_wb_ready',
		out_valid:	'w_wb_valid',
		out_data:	`{w_wb_addr, w_wb_len, w_wb_size, w_wb_burst, 
				  w_wb_lock, w_wb_cache, w_wb_prot, w_wb_region,
				  w_wb_qos, w_wb_id, w_wb_domain, w_wb_snoop, 
				  w_wb_bar, w_wb_user, w_wb_track, w_wb_wrap, 
				  w_wb_count}`
	},
	portsDelimiter: '\n\t'
})=\

   assign t_oc_edealloc = t_oc_dealloc & t_oc_evict;
   assign t_oc_rdealloc = t_oc_dealloc & ~q_oc_write & ~t_oc_evict;

\=u.instance({
	moduleName: 'ioaiu_enc',
	instanceName: 'rddec0',
	params: {
                DW:             OCN,
                BE:             0,
                NO_INDEX_OUT:   1,
                clkAssertInterface : clkAssertInterface,
		assertOn: assertOn
	},
	ports: {
		bv_i:		't_oc_rdealloc',
		valid_o:	'w_oc_rdec',
		bv_o:		'w_oc_rdbv0'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

\=u.instance({
	moduleName: 'ioaiu_enc',
	instanceName: 'rddec1',
	params: {
                DW:             OCN,
                BE:             1,
                NO_VALID_OUT:   1,
                NO_INDEX_OUT:   1,
                clkAssertInterface : clkAssertInterface,
		assertOn: assertOn
	},
	ports: {
		bv_i:		't_oc_rdealloc',
		bv_o:		'w_oc_rdbv1'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

  assign t_oc_wdealloc = t_oc_dealloc & q_oc_write & ~t_oc_evict;

\=u.instance({
	moduleName: 'ioaiu_enc',
	instanceName: 'wrdec0',
	params: {
                DW:             OCN,
                BE:             0,
                NO_INDEX_OUT:   1,
                clkAssertInterface : clkAssertInterface,
		assertOn: assertOn
	},
	ports: {
		bv_i:		't_oc_wdealloc',
		valid_o:	'w_oc_wdec',
		bv_o:		'w_oc_wdbv0'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

\=u.instance({
	moduleName: 'ioaiu_enc',
	instanceName: 'wrdec1',
	params: {
                DW:             OCN,
                BE:             1,
                NO_VALID_OUT:   1,
                NO_INDEX_OUT:   1,
                clkAssertInterface : clkAssertInterface,
		assertOn: assertOn
	},
	ports: {
		bv_i:		't_oc_wdealloc',
		bv_o:		'w_oc_wdbv1'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

   assign t_oc_we = w_pt_valid & n_pt_ready & ~w_pt_wake & ~w_pt_cmr[1] & ~(w_pt_snp);
   assign t_oc_cmd_sent_ns = w_cmd_req0_ready & n_cmd_req0_valid;
   \=u.dffre(1, `t_oc_cmd_sent`, `t_oc_cmd_sent_ns`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
   assign t_oc_cmd_error_ns = w_pt_valid & t_pt_err & ~w_pt_wake;
   \=u.dffre(1, `t_oc_cmd_error`, `t_oc_cmd_error_ns`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
   assign t_oc_rinc = (P1EN>0) ? w_p1_sel[0] & w_p1_valid : n_p0_sel[0] | n_p0_sel[2];
   assign t_oc_rdec = ~w_oc_rdec ? 2'h0 : 2'h1;
   assign t_oc_winc = (P1EN>0) ? w_p1_sel[1] & w_p1_valid : n_p0_sel[1];
   assign t_oc_wdec = (~w_oc_wdec | w_oc_rdec) ? 2'h0 : 2'h1;
   assign t_oc_count = q_oc_count; //q_oc_rcount + q_oc_wcount + t_oc_ecount;   
wire		w_oc_edec;
wire [1:0]	t_oc_edec;
wire t_oc_rwinc;
wire t_oc_rwdec;
wire [5:0] t_oc_count_vec;
reg  [OCA:0] t_oc_count_next_c;
wire [OCA:0] t_oc_count_next;
assign t_oc_rwinc = t_oc_rinc | t_oc_winc;
assign t_oc_rwdec = t_oc_rdec[0] | t_oc_wdec[0];
assign t_oc_count_vec[5] =
      ( t_oc_rwinc & ~t_oc_rwdec &  t_oc_einc & ~t_oc_edec[1] & ~t_oc_edec[0]) ; // 6'b100000 +2
assign t_oc_count_vec[4] =
      (~t_oc_rwinc & ~t_oc_rwdec &  t_oc_einc & ~t_oc_edec[1] & ~t_oc_edec[0]) | // 6'b010000 +1
      ( t_oc_rwinc & ~t_oc_rwdec & ~t_oc_einc & ~t_oc_edec[1] & ~t_oc_edec[0]) | // 6'b010000 +1
      ( t_oc_rwinc & ~t_oc_rwdec &  t_oc_einc & ~t_oc_edec[1] &  t_oc_edec[0]) | // 6'b010000 +1
      ( t_oc_rwinc & ~t_oc_rwdec &  t_oc_einc &  t_oc_edec[1] & ~t_oc_edec[0]) | // 6'b010000 +1
      ( t_oc_rwinc &  t_oc_rwdec &  t_oc_einc & ~t_oc_edec[1] & ~t_oc_edec[0]) ; // 6'b010000 +1
assign t_oc_count_vec[3] =
      (~t_oc_rwinc & ~t_oc_rwdec & ~t_oc_einc & ~t_oc_edec[1] & ~t_oc_edec[0]) | // 6'b001000 +0
      (~t_oc_rwinc & ~t_oc_rwdec &  t_oc_einc & ~t_oc_edec[1] &  t_oc_edec[0]) | // 6'b001000 +0
      (~t_oc_rwinc & ~t_oc_rwdec &  t_oc_einc &  t_oc_edec[1] & ~t_oc_edec[0]) | // 6'b001000 +0
      (~t_oc_rwinc &  t_oc_rwdec &  t_oc_einc & ~t_oc_edec[1] & ~t_oc_edec[0]) | // 6'b001000 +0
      ( t_oc_rwinc & ~t_oc_rwdec & ~t_oc_einc & ~t_oc_edec[1] &  t_oc_edec[0]) | // 6'b001000 +0
      ( t_oc_rwinc & ~t_oc_rwdec & ~t_oc_einc &  t_oc_edec[1] & ~t_oc_edec[0]) | // 6'b001000 +0
      ( t_oc_rwinc & ~t_oc_rwdec &  t_oc_einc &  t_oc_edec[1] &  t_oc_edec[0]) | // 6'b001000 +0
      ( t_oc_rwinc &  t_oc_rwdec & ~t_oc_einc & ~t_oc_edec[1] & ~t_oc_edec[0]) | // 6'b001000 +0
      ( t_oc_rwinc &  t_oc_rwdec &  t_oc_einc & ~t_oc_edec[1] &  t_oc_edec[0]) | // 6'b001000 +0
      ( t_oc_rwinc &  t_oc_rwdec &  t_oc_einc &  t_oc_edec[1] & ~t_oc_edec[0]) ; // 6'b001000 +0
assign t_oc_count_vec[2] =
      (~t_oc_rwinc & ~t_oc_rwdec & ~t_oc_einc & ~t_oc_edec[1] &  t_oc_edec[0]) | // 6'b000100 -1
      (~t_oc_rwinc & ~t_oc_rwdec & ~t_oc_einc &  t_oc_edec[1] & ~t_oc_edec[0]) | // 6'b000100 -1
      (~t_oc_rwinc & ~t_oc_rwdec &  t_oc_einc &  t_oc_edec[1] &  t_oc_edec[0]) | // 6'b000100 -1
      (~t_oc_rwinc &  t_oc_rwdec & ~t_oc_einc & ~t_oc_edec[1] & ~t_oc_edec[0]) | // 6'b000100 -1
      (~t_oc_rwinc &  t_oc_rwdec &  t_oc_einc & ~t_oc_edec[1] &  t_oc_edec[0]) | // 6'b000100 -1
      (~t_oc_rwinc &  t_oc_rwdec &  t_oc_einc &  t_oc_edec[1] & ~t_oc_edec[0]) | // 6'b000100 -1
      ( t_oc_rwinc & ~t_oc_rwdec & ~t_oc_einc &  t_oc_edec[1] &  t_oc_edec[0]) | // 6'b000100 -1
      ( t_oc_rwinc &  t_oc_rwdec & ~t_oc_einc & ~t_oc_edec[1] &  t_oc_edec[0]) | // 6'b000100 -1
      ( t_oc_rwinc &  t_oc_rwdec & ~t_oc_einc &  t_oc_edec[1] & ~t_oc_edec[0]) | // 6'b000100 -1
      ( t_oc_rwinc &  t_oc_rwdec &  t_oc_einc &  t_oc_edec[1] &  t_oc_edec[0]) ; // 6'b000100 -1
assign t_oc_count_vec[1] =
      (~t_oc_rwinc & ~t_oc_rwdec & ~t_oc_einc &  t_oc_edec[1] &  t_oc_edec[0]) | // 6'b000010 -2
      (~t_oc_rwinc &  t_oc_rwdec & ~t_oc_einc & ~t_oc_edec[1] &  t_oc_edec[0]) | // 6'b000010 -2
      (~t_oc_rwinc &  t_oc_rwdec & ~t_oc_einc &  t_oc_edec[1] & ~t_oc_edec[0]) | // 6'b000010 -2
      (~t_oc_rwinc &  t_oc_rwdec &  t_oc_einc &  t_oc_edec[1] &  t_oc_edec[0]) | // 6'b000010 -2
      ( t_oc_rwinc &  t_oc_rwdec & ~t_oc_einc &  t_oc_edec[1] &  t_oc_edec[0]) ; // 6'b000010 -2
assign t_oc_count_vec[0] =
      (~t_oc_rwinc &  t_oc_rwdec & ~t_oc_einc &  t_oc_edec[1] &  t_oc_edec[0]) ; // 6'b000001 -3
always @(*) begin
  casez (t_oc_count_vec[5:0])
    6'b100000 : t_oc_count_next_c = q_oc_count + \=OCA+1=\'h2;
    6'b010000 : t_oc_count_next_c = q_oc_count + \=OCA+1=\'h1;
    6'b000100 : t_oc_count_next_c = q_oc_count - \=OCA+1=\'h1;
    6'b000010 : t_oc_count_next_c = q_oc_count - \=OCA+1=\'h2;
    6'b000001 : t_oc_count_next_c = q_oc_count - \=OCA+1=\'h3;
    default: t_oc_count_next_c = q_oc_count;
  endcase
end
   assign t_oc_count_next = t_oc_count_next_c;
   assign pmon_ott_read_latency_alloc  = t_oc_alloc & {OCN{~w_pt_write}};
   assign pmon_ott_write_latency_alloc = t_oc_alloc & {OCN{ w_pt_write}};
   assign pmon_ott_read_latency_dealloc  = t_oc_rdealloc;
   assign pmon_ott_write_latency_dealloc = t_oc_dealloc & q_oc_write;

\js if (OCA==7) {
   assign pmon_ott_entries = q_oc_count;
\js } else {
   assign pmon_ott_entries = {\=8-OCA-1=\'b0,q_oc_count};
\js }

\js /////////////////////////////
   assign t_od_we = t_oc_we & ~w_pt_write; //& (~| t_oc_lhit) 
   assign q_oc_rcount_next = (t_oc_rinc & (~|t_oc_rdec)) ? q_oc_rcount + \=OCA=\'b1:
			  (~t_oc_rinc & (& t_oc_rdec)) ? q_oc_rcount - \=OCA=\'h2:
			  ((~t_oc_rinc & (| t_oc_rdec)) |
			   (t_oc_rinc & (& t_oc_rdec)))? q_oc_rcount - \=OCA=\'b1:
			     q_oc_rcount;

   assign q_oc_wcount_next = (t_oc_winc & (~|t_oc_wdec)) ? q_oc_wcount + \=OCA=\'b1:
			     (~t_oc_winc & (& t_oc_wdec)) ? q_oc_wcount - \=OCA=\'h2:
			     ((~t_oc_winc & (| t_oc_wdec)) |
			      (t_oc_winc & (& t_oc_wdec)))? q_oc_wcount - \=OCA=\'b1:
			     q_oc_wcount;

   \=u.dffre(1, `q_oc_ready`, `n_oc_ready`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
   wire [OCA-1:0] q_oc_wptr_ns = ((~q_oc_ready & n_oc_ready) | t_oc_we | q_oc_val[q_oc_wptr]) ? n_oc_wptr : q_oc_wptr;
   \=u.dffre(OCA, `q_oc_wptr`, `q_oc_wptr_ns`, `{`+OCA+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
   \=u.dffre(OCA+1, `q_oc_count`, `t_oc_count_next`, `{`+(OCA+1)+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
   \=u.dffre(OCA+1, `q_oc_rcount`, `q_oc_rcount_next`, `{`+(OCA+1)+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
   \=u.dffre(OCA+1, `q_oc_wcount`, `q_oc_wcount_next`, `{`+(OCA+1)+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
   wire q_od_ready_ns = (~w_od_eready & w_c2_evict & w_c2_flush & (~n_od_ready | t_od_we)) ? 1'b0 : (~q_od_ready | (n_w1_valid & w_w1_ready_raw & ~w_pt_valid) | t_od_we) ? n_od_ready : q_od_ready;
   \=u.dffre(1, `q_od_ready`, `q_od_ready_ns`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
   wire [OLA-1:0] q_od_wptr_ns = ((~q_od_ready & n_od_ready) | (n_w1_valid & w_w1_ready_raw & ~w_pt_valid) | t_od_we) ? n_od_wptr : q_od_wptr;
   \=u.dffre(OLA, `q_od_wptr`, `q_od_wptr_ns`, `{`+OLA+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
   wire [OCN-1:0] q_od_wptr_vec_ns = ((~q_od_ready & n_od_ready) | (n_w1_valid & w_w1_ready_raw & ~w_pt_valid) | t_od_we) ? w_od_candidate : q_od_wptr_vec;
   \=u.dffre(OCN, `q_od_wptr_vec`, `q_od_wptr_vec_ns`, `{`+OCN+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

   assign t_oc_free = ~((q_oc_val | dealloc_collect_in) | (\=OCN=\'b1 << q_oc_wptr));// & !dealloc_collect);
	  
\=u.instance({
	moduleName: 'ioaiu_enc',
	instanceName: 'ocfree',
	params: {
                DW:             OCN,
                BE:             0,
                NO_BV_OUT:      1,
                clkAssertInterface : clkAssertInterface,
		assertOn: assertOn
	},
	ports: {
		bv_i:		't_oc_free',
		valid_o:	'n_oc_ready',
		index_o:	'n_oc_wptr'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

   assign t_od_free = ~((q_od_val) | ({OLN{q_od_ready}} & (q_od_wptr_vec)));

\=u.instance({
	moduleName: 'ioaiu_enc',
	instanceName: 'odfree',
	params: {
                DW:             OCN,
                BE:             0,
                clkAssertInterface : clkAssertInterface,
		assertOn: assertOn
	},
	ports: {
		bv_i:		't_od_free',
		valid_o:	'n_od_ready',
		index_o:	'n_od_wptr',
		bv_o:		'w_od_candidate'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

  assign t_od_wfree = t_od_free & ~w_od_ecandidate; //& ~w_od_candidate

\=u.instance({
	moduleName: 'ioaiu_enc',
	instanceName: 'odwfree',
	params: {
                DW:             OCN,
                BE:             1,
                clkAssertInterface : clkAssertInterface,
		assertOn: assertOn
	},
	ports: {
		bv_i:		't_od_wfree',
		valid_o:	'w_od_wready',
		index_o:	'w_od_dptr',
		bv_o:		'w_od_dptr_vec'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

\js if (useCache) {

    assign t_od_efree = t_od_free & ~w_od_candidate;

\=u.instance({
	moduleName: 'ioaiu_enc',
	instanceName: 'odefree',
	params: {
                DW:             OCN,
                BE:             0,
                clkAssertInterface : clkAssertInterface,
		assertOn: assertOn
	},
	ports: {
		bv_i:		't_od_efree',
		valid_o:	'w_od_eready',
		index_o:	'w_od_eptr',
		bv_o:		'w_od_ecandidate'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

     assign t_od_eptr = w_od_eready ? w_od_eptr : 
	  n_od_ready ? n_od_wptr :
	  q_od_wptr;

     assign t_od_eptr_vec = w_od_eready ? w_od_ecandidate :
          n_od_ready ? w_od_candidate :
          q_od_wptr_vec;

\js } else {
    assign t_od_efree = {OLN{1'b0}};
    assign t_od_eptr = {OLA{1'b0}};
    assign t_od_eptr_vec = {OCN{1'b0}};
    assign w_od_eready = 1'b1;
    assign w_od_ecandidate = {OLN{1'b0}};
\js }

\=u.instance({
	moduleName: 'ioaiu_ohenc',
	instanceName: 'ocihit',
	params: {
                 VW:       OCN,
                 BW:       OCA},
	ports: {
		vec_i:		't_oc_ihit',
		bin_o:		'w_oc_ihid'
	},
	portsDelimiter: '\n\t'
})=\
 
   assign t_oc_ahit = t_oc_ahitr | t_oc_ahite;

\=u.instance({
	moduleName: 'ioaiu_ohenc',
	instanceName: 'ocahitr',
	params: {
                 VW:       OCN,
                 BW:       OCA},
	ports: {
		vec_i:		't_oc_ahitr',
		bin_o:		'w_oc_ahidr'
	},
	portsDelimiter: '\n\t'
})=\

\=u.instance({
	moduleName: 'ioaiu_ohenc',
	instanceName: 'ocahite',
	params: {
                 VW:       OCN,
                 BW:       OCA},
	ports: {
		vec_i:		't_oc_ahite',
		bin_o:		'w_oc_ahide'
	},
	portsDelimiter: '\n\t'
})=\

  assign wakeup_ok = (q_oc_val & q_oc_wake & t_oc_kok); // & t_oc_ihead); 

  assign special_write_wakeup = wakeup_ok & special_write_mask;

  // When in starvation we need to allow writes through if there is no outstanding write to that target.
  assign t_oc_wake = ((t_sv_starve) ? ((special_write_avail & ~ioaiu_outstanding_write_used) ? special_write_wakeup : t_oc_svok )  :
		     (1'b1) ? (q_oc_val & q_oc_wake & t_oc_kok) // & // ET: Age now selects oldes t_oc_wake signal. t_oc_kok contains qos selection
		                    // t_oc_ihead) // Always need to make sure dependencies are cleared. If QOS is turned off it cant come through t_oc_kok
				    //((CACHE>0) ? t_oc_ihead : {OCN{1'b1}}))
                                  : t_oc_agok) &
		    ({OCN{~w_c0_af}} & ~q_oc_write |
		     {OCN{~w_wq_af}} & q_oc_write) & 
		    {OCN{(t_oc_count <= t_p0_limit) | (CACHE==0)}};

  \js // TODO: Prevent this if there is a match inside the OTT
  assign t_oc_wfmru = q_oc_val & t_oc_ihead & ((t_oc_wrbk & q_oc_line) | t_oc_evict) & q_oc_wfa & ~q_oc_wfresp & ~q_oc_wfdtw & ~q_oc_wfdtp & ~q_oc_err;
  assign t_oc_wfcmd = q_oc_val & t_oc_evict & q_oc_wrap;

\js if (useCache || axiParams.wCdData) {

\=u.instance({
	moduleName: 'ioaiu_arbiter',
	instanceName: 'ocwakeu',
	params: {
                DRST:           DRST,
                DW:             OCN,
                ATOMIC:         0,
                HP:             `{`+OCN+`{1'b0}}`,
                VAL:            1,
		 assertOn: assertOn
	},
	ports: {
		clk_i:		'clk_i',
		reset_ni:	'reset_ni',
		ready_i:	'w_upd_req0_ready',
		bv_i:		't_oc_wfmru',
		lv_i:		`{OCN{1'b1}}`,
		winner_o:	'w_upd_req_oid',
		wbv_o:		'w_upd_req_obv'
	},
	portsDelimiter: '\n\t'
})=\

\js } else {
    assign w_upd_req_oid = {OCA{1'b0}};
    assign w_upd_req_obv = {OCN{1'b0}};
\js }

  assign n_poc_valid = (| t_oc_wake);

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'poc',
	params: {
                depth:          1,
		width:		OCA,
                pipeForward:    "yes",
                pipeBackward:   "no",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_poc_ready',
		in_valid:	'n_poc_valid',
		in_data:	'n_poc_oid',
		out_ready:	'n_poc_ready',
		out_valid:	'w_poc_valid',
		out_data:	'w_poc_oid'
	},
	portsDelimiter: '\n\t'
})=\

\js if (owo) {
wire generated_writeback_p0 = n_p0_sel[3] & n_poc_ready & w_poc_valid & q_oc_write[w_poc_oid] & ~(|t_oc_atop[w_poc_oid]) & t_oc_coh[w_poc_oid] & t_oc_owned[w_poc_oid];
wire generated_writeback_p1;
\=u.dffre(1, `generated_writeback_p1`, `generated_writeback_p0`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
\js }

  assign t_poc_valid = w_poc_valid & n_cmd_req0_ready & 
\js if (owo) {
                       ~generated_writeback_p1 &
\js }
		       t_p0_single & t_p0_single_wake &
		       ~t_pvc_throttle & (~w_rr_valid) & ~w_cmd_req0_af &
		       ~(t_cfg_evict & n_ce_valid) & ((CACHE==0) | q_od_ready) &
		       ~w_do_af & ~w_c0_af & ~w_wq_af & ~w_ce_af &
		       ((CACHE==0) | (t_oc_count < t_p0_limit) |
			(~w_p1_valid & ~w_p2_valid & ({{32-OCA-1{1'b0}},t_oc_count} < OCN))) &
		       (t_oc_ecount < t_cfg_ev_limit);

\jsbegin
/* istanbul ignore else env ncore_3p4,ncore_3p6,ncore_3p7 */
if (useSoftwareCreditManagement) {

// clk_i
// reset_ni

// ===== DCE
// n_cmd_req0_incs[0]
// w_amc_tins[0*5 +: TINW]

// t_cmd_rsp_dec
// w_cmd_rsp_iid[PIDW +: FIDW]

// w_dce_boks
// w_dce_woks
// w_dce_idle

// ===== DMI
// n_cmd_req0_incs[1]
// w_amc_tins[1*5 +: TINW]

// t_cmd_rsp_dec
// w_cmd_rsp_iid[PIDW +: FIDW]

// w_dmi_boks
// w_dmi_woks
// w_dmi_idle

// ===== DII
// n_cmd_req0_incs[2]
// w_amc_tins[2*5 +: TINW]
//
// t_cmd_rsp_dec
// w_cmd_rsp_iid[PIDW +: FIDW]
//
// w_dii_boks
// w_dii_woks
// w_dii_idle

// hexAiuDceVec;
// hexAiuDmiVec;
// hexAiuDiiVec;

// dce_ids_i [0*FIDW +: FIDW], [1*FIDW +: FIDW], ...
// dmi_ids_i
// dii_ids_i

// var nDCEs      		   = u.getParam('nDCEs');
// var nDMIs      		   = u.getParam('nDMIs');
// var nDIIs      		   = u.getParam('nDIIs');
// var nCreditRegs            = u.getParam('nCreditRegs');

var clkInterface = { name : '', signals : {'clk' : 1,'reset_n' : 1}};
var ccfInterface = { name : '', signals : {'CounterState_in'  : -3,
                                           'CounterState_wr'  : -1,
                                           'CreditLimit_out'  : 5,
                                           'CounterState_out' : 3}};
\jsend
wire [\=nDCEs=\-1:0] dce_idle_vec;
wire [\=nDMIs=\-1:0] dmi_idle_vec;
wire [\=nDIIs=\-1:0] dii_idle_vec;

assign w_dce_idle = (|dce_idle_vec);
assign w_dmi_idle = (|dmi_idle_vec);
assign w_dii_idle = (|dii_idle_vec);
\jsbegin

for (let i = 0; i < nCreditRegs; i++ ) {
  if ( i < nDCEs) {
    \jsend

    wire dce_dec_count_\=i=\ = n_cmd_req0_incs[0] & (w_amc_tins[0*5 +: TINW] == \=i=\);
    wire dce_dec_count_last_\=i=\;
    \=u.dffre(1, `dce_dec_count_last_`+i, `dce_dec_count_`+i, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
    wire dce_dec_count_no_err_\=i=\ = n_cmd_req0_incs_no_err[0] & (w_amc_tins[0*5 +: TINW] == \=i=\);
    wire dce_dec_count_no_err_last_\=i=\;
    \=u.dffre(1, `dce_dec_count_no_err_last_`+i, `dce_dec_count_no_err_`+i, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
    wire dce_inc_count_late_\=i=\ = dce_dec_count_no_err_last_\=i=\ & ~dce_dec_count_last_\=i=\;
    wire dce_inc_count_\=i=\ = t_cmd_rsp_dec      & (w_cmd_rsp_iid[PIDW +: FIDW] == dce_ids_i[\=i=\*FIDW +: FIDW]);
    wire dce_connected_\=i=\ = hexAiuDceVec[\=i=\];

    \=u.instance({
	moduleName: 'variable_limit_credit_counter',
	instanceName: 'credit_dce'+i,
	params: {clkInterface : clkInterface,
                 ccfInterface : ccfInterface,
                 useSecondIncrement : true,
		 assertOn: assertOn
		 },
	ports: {
                'clk'              : 'clk_i',
                'reset_n'          : 'reset_ni',
		'CounterState_in'  : 'XAIUCCR'+i+'_DCECounterState_in',
                'CounterState_wr'  : 'XAIUCCR'+i+'_DCECounterState_wr',
                'CreditLimit_out'  : 'XAIUCCR'+i+'_DCECreditLimit_out',
                'CounterState_out' : 'XAIUCCR'+i+'_DCECounterState_out',
                'dec_count'        : 'dce_dec_count_no_err_'+i,
                'inc_count'        : 'dce_inc_count_'+i,
                'inc_count1'       : 'dce_inc_count_late_'+i,
                'credit_avail'     : 'w_dce_woks['+i+']',
                'credit_p1_avail'  : 'w_dce_boks['+i+']',
                'connected'        : 'dce_connected_'+i
	},
	portsDelimiter: '\n\t'
    })=\

    assign w_dce_haveNoCredits[\=i=\] = (XAIUCCR\=i=\_DCECreditLimit_out == 5'h0);

    assign dce_idle_vec[\=i=\] = (XAIUCCR\=i=\_DCECounterState_out == 3'b111) || (XAIUCCR\=i=\_DCECounterState_out == 3'b100) || (XAIUCCR\=i=\_DCECreditLimit_out == 5'h0);
  \jsbegin
  }
  
  if ( i < nDMIs) {
    \jsend

    wire dmi_dec_count_\=i=\ = n_cmd_req0_incs[1] & (w_amc_tins[1*5 +: TINW] == \=i=\);
    wire dmi_dec_count_last_\=i=\;
    \=u.dffre(1, `dmi_dec_count_last_`+i, `dmi_dec_count_`+i, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
    wire dmi_dec_count_no_err_\=i=\ = n_cmd_req0_incs_no_err[1] & (w_amc_tins[1*5 +: TINW] == \=i=\);
    wire dmi_dec_count_no_err_last_\=i=\;
    \=u.dffre(1, `dmi_dec_count_no_err_last_`+i, `dmi_dec_count_no_err_`+i, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
    wire dmi_inc_count_late_\=i=\ = dmi_dec_count_no_err_last_\=i=\ & ~dmi_dec_count_last_\=i=\;
    wire dmi_inc_count_\=i=\ = t_cmd_rsp_dec      & (w_cmd_rsp_iid[PIDW +: FIDW] == dmi_ids_i[\=i=\*FIDW +: FIDW]);
    wire dmi_connected_\=i=\ = hexAiuDmiVec[\=i=\];

    \=u.instance({
	moduleName: 'variable_limit_credit_counter',
	instanceName: 'credit_dmi'+i,
	params: {clkInterface : clkInterface,
                 ccfInterface : ccfInterface,
                 useSecondIncrement : true,
		 assertOn: assertOn
		 },
	ports: {
                'clk'              : 'clk_i',
                'reset_n'          : 'reset_ni',
		'CounterState_in'  : 'XAIUCCR'+i+'_DMICounterState_in',
                'CounterState_wr'  : 'XAIUCCR'+i+'_DMICounterState_wr',
                'CreditLimit_out'  : 'XAIUCCR'+i+'_DMICreditLimit_out',
                'CounterState_out' : 'XAIUCCR'+i+'_DMICounterState_out',
                'dec_count'        : 'dmi_dec_count_no_err_'+i,
                'inc_count'        : 'dmi_inc_count_'+i,
                'inc_count1'       : 'dmi_inc_count_late_'+i,
                'credit_avail'     : 'w_dmi_woks['+i+']',
                'credit_p1_avail'  : 'w_dmi_boks['+i+']',
                'connected'        : 'dmi_connected_'+i
	},
	portsDelimiter: '\n\t'
    })=\

    assign w_dmi_haveNoCredits[\=i=\] = (XAIUCCR\=i=\_DMICreditLimit_out == 5'h0);

    assign dmi_idle_vec[\=i=\] = (XAIUCCR\=i=\_DMICounterState_out == 3'b111) || (XAIUCCR\=i=\_DMICounterState_out == 3'b100) || (XAIUCCR\=i=\_DMICreditLimit_out == 5'h0);
  \jsbegin
  } 

  if ( i < nDIIs) {
    \jsend

    wire dii_dec_count_\=i=\ = n_cmd_req0_incs[2] & (w_amc_tins[2*5 +: TINW] == \=i=\);
    wire dii_dec_count_last_\=i=\;
    \=u.dffre(1, `dii_dec_count_last_`+i, `dii_dec_count_`+i, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
    wire dii_dec_count_no_err_\=i=\ = n_cmd_req0_incs_no_err[2] & (w_amc_tins[2*5 +: TINW] == \=i=\);
    wire dii_dec_count_no_err_last_\=i=\;
    \=u.dffre(1, `dii_dec_count_no_err_last_`+i, `dii_dec_count_no_err_`+i, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
    wire dii_inc_count_late_\=i=\ = dii_dec_count_no_err_last_\=i=\ & ~dii_dec_count_last_\=i=\;
    wire dii_inc_count_\=i=\ = t_cmd_rsp_dec      & (w_cmd_rsp_iid[PIDW +: FIDW] == dii_ids_i[\=i=\*FIDW +: FIDW]);
    wire dii_connected_\=i=\ = hexAiuDiiVec[\=i=\];

    \=u.instance({
	moduleName: 'variable_limit_credit_counter',
	instanceName: 'credit_dii'+i,
	params: {clkInterface : clkInterface,
                 ccfInterface : ccfInterface,
                 useSecondIncrement : true,
		 assertOn: assertOn
		 },
	ports: {
                'clk'              : 'clk_i',
                'reset_n'          : 'reset_ni',
		'CounterState_in'  : 'XAIUCCR'+i+'_DIICounterState_in',
                'CounterState_wr'  : 'XAIUCCR'+i+'_DIICounterState_wr',
                'CreditLimit_out'  : 'XAIUCCR'+i+'_DIICreditLimit_out',
                'CounterState_out' : 'XAIUCCR'+i+'_DIICounterState_out',
                'dec_count'        : 'dii_dec_count_no_err_'+i,
                'inc_count'        : 'dii_inc_count_'+i,
                'inc_count1'       : 'dii_inc_count_late_'+i,
                'credit_avail'     : 'w_dii_woks['+i+']',
                'credit_p1_avail'  : 'w_dii_boks['+i+']',
                'connected'        : 'dii_connected_'+i
	},
	portsDelimiter: '\n\t'
    })=\

    assign w_dii_haveNoCredits[\=i=\] = (XAIUCCR\=i=\_DIICreditLimit_out == 5'h0);

    assign dii_idle_vec[\=i=\] = (XAIUCCR\=i=\_DIICounterState_out == 3'b111) || (XAIUCCR\=i=\_DIICounterState_out == 3'b100) || (XAIUCCR\=i=\_DIICreditLimit_out == 5'h0);
  \jsbegin
  } 
 }
\jsend

\jsbegin
} else { \jsend

\=u.instance({
	moduleName: 'ioaiu_credit',
	instanceName: 'credit_dce',
	params: {
                DRST:           DRST,
                DECT:           0,
                TINW:           ioaiu_pos(log2ceil(Math.max(nDMIs,nDCEs,nDIIs))),
                FIDW:           FIDW,
                NUM:            nDCEs,
                MAXK:           CTKM,
                TOTAL:          CTKS,
                WRITE:          CWKS,
                SHARE:          0,
		 assertOn: assertOn
		 },
	ports: {
		clk_i:		'clk_i',
		reset_ni:	'reset_ni',
		cfg_adj_i:	'cfg_dcredit_i',
		cfg_share_i:	`1'b0`,
		fids_i:		'dce_ids_i',
		inc_i:		'n_cmd_req0_incs[0]',
		inc_wr_i:	`1'b0`,
		inc_tin_i:	'w_amc_tins[0*5 +: TINW]',
		inc_tin_o:	'',
		dec_i:		't_cmd_rsp_dec',
		dec_fid_i:	'w_cmd_rsp_iid[PIDW +: FIDW]',
		bok_o:		'w_dce_boks',
		wok_o:		'w_dce_woks',
		idle_o:		'w_dce_idle'
	},
	portsDelimiter: '\n\t'
})=\
\=u.instance({
	moduleName: 'ioaiu_credit',
	instanceName: 'credit_dmi',
	params: {
                DRST:           DRST,
                DECT:           0,
                TINW:           ioaiu_pos(log2ceil(Math.max(nDMIs,nDCEs,nDIIs))),
                FIDW:           FIDW,
                NUM:            nDMIs,
                MAXK:           MTKM,
                TOTAL:          MTKS,
                WRITE:          MWKS,
                SHARE:          0,
		 assertOn: assertOn
		 },
	ports: {
		clk_i:		'clk_i',
		reset_ni:	'reset_ni',
		cfg_adj_i:	'cfg_mcredit_i',
		cfg_share_i:	`1'b0`,
		fids_i:		'dmi_ids_i',
		inc_i:		'n_cmd_req0_incs[1]',
		inc_wr_i:	`1'b0`,
		inc_tin_i:	'w_amc_tins[1*5 +: TINW]',
		inc_tin_o:	'',
		dec_i:		't_cmd_rsp_dec',
		dec_fid_i:	'w_cmd_rsp_iid[PIDW +: FIDW]',
		bok_o:		'w_dmi_boks',
		wok_o:		'w_dmi_woks',
		idle_o:		'w_dmi_idle'
	},
	portsDelimiter: '\n\t'
})=\
\=u.instance({
	moduleName: 'ioaiu_credit',
	instanceName: 'credit_dii',
	params: {
                DRST:           DRST,
                DECT:           0,
                TINW:           ioaiu_pos(log2ceil(Math.max(nDMIs,nDCEs,nDIIs))),
                FIDW:           FIDW,
                NUM:            nDIIs,
                MAXK:           ITKM,
                TOTAL:          ITKS,
                WRITE:          IWKS,
                SHARE:          0,
		 assertOn: assertOn
		 },
	ports: {
		clk_i:		'clk_i',
		reset_ni:	'reset_ni',
		cfg_adj_i:	'cfg_icredit_i',
		cfg_share_i:	`1'b0`,
		fids_i:		'dii_ids_i',
		inc_i:		'n_cmd_req0_incs[2]',
		inc_wr_i:	`1'b0`,
		inc_tin_i:	'w_amc_tins[2*5 +: TINW]',
		inc_tin_o:	'',
		dec_i:		't_cmd_rsp_dec',
		dec_fid_i:	'w_cmd_rsp_iid[PIDW +: FIDW]',
		bok_o:		'w_dii_boks',
		wok_o:		'w_dii_woks',
		idle_o:		'w_dii_idle'
	},
	portsDelimiter: '\n\t'
})=\

\jsbegin
} \jsend

\js if (isDvmAgent) {
     wire q_dve_state;

    wire dve_dec_count = n_cmd_req0_incs_no_err[3];
    wire dve_dec_count_last;
    \=u.dffre(1, `dve_dec_count_last`, `dve_dec_count`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
    wire dve_dec_count_no_err = n_cmd_req0_incs_no_err[3];
    wire dve_dec_count_no_err_last;
    \=u.dffre(1, `dve_dec_count_no_err_last`, `dve_dec_count_no_err`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
    wire dve_inc_count_late = dve_dec_count_no_err_last & ~dve_dec_count_last;
    wire dve_inc_count = t_cmd_rsp_dec & (w_cmd_rsp_iid[PIDW +: FIDW] == dve_ids_i[0 +: FIDW]);

    wire [2:0] dve_counterstate_in;
    \=u.instance({
        moduleName: 'variable_limit_credit_counter',
        instanceName: 'credit_dve',
        params: {clkInterface : clkInterface,
                 ccfInterface : ccfInterface,
                 useSecondIncrement : true,
                 assertOn: assertOn
                 },
        ports: {
                'clk'              : 'clk_i',
                'reset_n'          : 'reset_ni',
                'CounterState_in'  : 'dve_counterstate_in',
                'CounterState_wr'  : '',
                'CreditLimit_out'  : `5'd`+VTKM,
                'CounterState_out' : `3'd7`,
                'dec_count'        : 'dve_dec_count',
                'inc_count'        : 'dve_inc_count',
                'inc_count1'       : 'dve_inc_count_late',
                'credit_avail'     : '',
                'credit_p1_avail'  : 'w_dve_boks',
                'connected'        : `1'b1`
        },
        portsDelimiter: '\n\t'
    })=\

   assign w_dve_idle = (dve_counterstate_in==3'd1)|(dve_counterstate_in==3'd4);

   wire [\=OCN-1=\:0] last_selected_dtv_in;
   wire [\=OCN-1=\:0] last_selected_dtv;

\=u.instance({
	moduleName: 'ioaiu_arbiter',
	instanceName: 'dtv_arb',
	params: {
                DRST:           DRST,
                DW:             OCN,
                ATOMIC:         0,
                HP:             `{`+OCN+`{1'b0}}`,
                VAL:            1,
		 assertOn: assertOn
	},
	ports: {
		clk_i:		'clk_i',
		reset_ni:	'reset_ni',
		ready_i:	'w_dtv_ready',
		bv_i:		't_oc_dtv',
		lv_i:		`{OCN{1'b1}}`,
		winner_o:	'n_dtv_oid',
		wbv_o:		'n_dtv_obv'
	},
	portsDelimiter: '\n\t'
})=\

\=u.instance({
        moduleName: 'rdy_vld_pipe',
        instanceName: 'pdtv',
        params: {
                depth:          1,
                width:          OCN+OCA,
                pipeForward:    "yes",
                pipeBackward:   "no",
                simplePipe:     "no",
                circular:       "no"
                 },
        verilogParams: {
        },
        ports: {
                clk:          'clk_i',
                reset_n:      'reset_ni',
                in_ready:     'w_dtv_ready',
                in_valid:     'n_dtv_valid',
                in_data:      `{n_dtv_oid,n_dtv_obv}`,
                out_ready:    'n_dtv_ready',
                out_valid:    'w_dtv_valid',
                out_data:     `{w_dtv_oid,w_dtv_obv}`
        },
        portsDelimiter: '\n\t'
})=\

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'cmp_rsp0',
	params: {
                depth:          1,
		width:		8+MRCM,
                pipeForward:    "yes",
                pipeBackward:   "no",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'cmp_rsp_ready_o',
		in_valid:	'cmp_rsp_valid_i',
		in_data:	`{cmp_rsp_status_i, cmp_rsp_mid_i}`,
		out_ready:	'n_cm0_ready',
		out_valid:	'w_cm0_valid',
		out_data:	`{w_cm0_status, w_cm0_mid}`
	},
	portsDelimiter: '\n\t'
})=\

   assign n_cm0_ready = (w_cm1_ready & w_cm0_valid) | (w_cm0_valid & ~q_oc_addr[w_cm0_mid[\=wOCN-1=\:0]][15]);
   assign n_cm1_valid = w_cm0_valid & (
\js for (let i=0;i<OCN;i++) {
                       ((w_cm0_mid[\=wOCN-1=\:0] == \=wOCN=\'d\=i=\) & q_oc_addr[\=i=\][15]) | 
\js }
                        1'b0);

\=u.instance({
        moduleName: 'rdy_vld_pipe',
        instanceName: 'cmp_rsp1',
        params: {
                depth:          1,
                width:          MRCM,
                pipeForward:    "yes",
                pipeBackward:   "no",
                simplePipe:     "no",
                circular:       "no"
                 },
        verilogParams: {
        },
        ports: {
                clk:          	'clk_i',
                reset_n:       	'reset_ni',
                in_ready:     	'w_cm1_ready',
                in_valid:     	'n_cm1_valid',
                in_data:     	'w_cm0_mid',
                out_ready:     	'n_cm1_ready',
                out_valid:     	'w_cm1_valid',
                out_data:     	'w_cm1_mid'
        },
        portsDelimiter: '\n\t'
})=\

   assign n_cm1_ready = w_cmp_rsp_ready & q_oc_iptr_eq[w_cm1_mid[\=wOCN-1=\:0]];
   assign n_cmp_rsp_valid = w_cm1_valid & q_oc_iptr_eq[w_cm1_mid[\=wOCN-1=\:0]];

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'cmp_rsp2',
	params: {
                depth:          1,
		width:		MRCM,
                pipeForward:    "yes",
                pipeBackward:   "no",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_cmp_rsp_ready',
		in_valid:	'n_cmp_rsp_valid',
		in_data:	'w_cm1_mid',
		out_ready:	'n_cmp_rsp_ready',
		out_valid:	'w_cmp_rsp_valid_raw',
		out_data:	'w_cmp_rsp_mid'
	},
	portsDelimiter: '\n\t'
})=\

   assign n_cmp_rsp_ready = w_ac_ready & w_cmp_rsp_valid ;
   assign w_cmp_rsp_valid = w_cmp_rsp_valid_raw & ~t_dvm_state;
   wire q_dve_state_ns = q_dve_state ? ~(t_pt_dve & ~w_pt_wake) : t_pt_dve & w_pt_addr[0] & ~w_pt_wake;
   \=u.dffre(1, `q_dve_state`, `q_dve_state_ns`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
	  
   assign t_dve_state = q_dve_state;
\js } else {
     assign w_dve_boks = {DVEN{1'b1}};
     assign w_dve_idle = 1'b1;
     assign t_dve_state = 1'b0;
     assign w_dtv_oid = {OCA{1'b0}};
     assign w_dtv_obv = {OCN{1'b0}};
     assign n_dtv_obv = {OCN{1'b0}};
     assign w_dtv_ready = 1'b0;
     assign w_cm0_valid = 1'b0;
     assign w_cm0_mid = {MRCM{1'b0}};
     assign w_cm0_status = 8'h0;
     assign n_cmp_rsp_valid = 1'b0;
     assign n_cmp_rsp_ready = 1'b0;
     assign w_cmp_rsp_valid = 1'b0;
     assign w_cmp_rsp_mid = {MRCM{1'b0}};
     assign cmp_rsp_ready_o = 1'b0;
\js }

\js if (QOSE>0) {
     wire [QOSN*OCN-1:0]	w_oc_qbvs;
     wire [QOSN-1:0] 	w_oc_qbv;
     wire [OCN-1:0] 	q_oc_kok;
     wire [OCN-1:0] 	q_oc_dok;

\jsbegin
// If QOSE is set, then so is QOSA
/* istanbul ignore else env ncore_3p7 */
      if (QOSA) { \jsend
       wire [OCN-1:0]		t_oc_qok;

\=u.instance({
	moduleName: 'ioaiu_ror',
	instanceName: 'ror_qos',
	params: {
		NUM:		OCN,
		DW:		QOSN
        },
	ports: {
		vec_i:		'w_oc_qbvs',
		ror_o:		'w_oc_qbv'
	},
	portsDelimiter: '\n\t'
})=\

\=u.instance({
	moduleName: 'ioaiu_enc',
	instanceName: 'qok',
	params: {
                DW:             QOSN,
                BE:             0,
                NO_VALID_OUT:   1,
                NO_INDEX_OUT:   1,
                clkAssertInterface : clkAssertInterface,
		assertOn: assertOn
	},
	ports: {
		bv_i:		'w_oc_qbv',
		bv_o:		'w_oc_qok'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

\js for (let i=0; i<OCN; i=i+1) {
    assign t_oc_qok[\=i=\] = t_cfg_qos | t_cfg_qok | (~| (~({QOSN{1'b1}}<<w_oc_qin[\=i=\]) & w_oc_qok));

\js if (nDIIs>1) {
wire mux_dii_cok_boks\=i=\ =
\js for (let j=0;j<nDIIs;j++) {
                                             ((q_oc_tin[\=i=\][\=log2ceil(nDIIs)-1=\:0] == \=log2ceil(nDIIs)=\'d\=j=\) ? w_dii_boks[\=j=\] : 1'b0)\=(j==(nDIIs-1))?";":"|"=\
\js }
wire mux_dii_cok_woks\=i=\ =
\js for (let j=0;j<nDIIs;j++) {
                                             ((q_oc_tin[\=i=\][\=log2ceil(nDIIs)-1=\:0] == \=log2ceil(nDIIs)=\'d\=j=\) ? w_dii_woks[\=j=\] : 1'b0)\=(j==(nDIIs-1))?";":"|"=\
\js }
\js }
\js if (nDMIs>1) {
wire mux_dmi_cok_boks\=i=\ =
\js for (let j=0;j<nDMIs;j++) {
                                             ((q_oc_tin[\=i=\][\=log2ceil(nDMIs)-1=\:0] == \=log2ceil(nDMIs)=\'d\=j=\) ? w_dmi_boks[\=j=\] : 1'b0)\=(j==(nDMIs-1))?";":"|"=\
\js }
wire mux_dmi_cok_woks\=i=\ =
\js for (let j=0;j<nDMIs;j++) {
                                             ((q_oc_tin[\=i=\][\=log2ceil(nDMIs)-1=\:0] == \=log2ceil(nDMIs)=\'d\=j=\) ? w_dmi_woks[\=j=\] : 1'b0)\=(j==(nDMIs-1))?";":"|"=\
\js }
\js }

\js // If the special write credit is already used, and reads cant go. Allow reads to fight for arbitration.
assign t_oc_cok[\=i=\] = (t_cfg_qos |
\jsbegin
// The tachl parameter QOSN is either 0 or 8
/* istanbul ignore if env ncore_3p7 */
    if (QOSN==1) { \jsend
		      w_qos_boks[0] |
		     (w_qos_woks[0] & q_oc_write[\=i=\])) &
\js } else {
		      w_qos_boks[w_oc_qin[\=i=\]] |
		     (w_qos_woks[w_oc_qin[\=i=\]] & q_oc_write[\=i=\])) &
\js }
	     (~q_oc_write[\=i=\] & (t_oc_snoop[\=i=\]==4'hf) ? w_dve_boks[0] :	      
\js if (nDCEs==1) {
                  (~| q_oc_tin[\=i=\][TINW+1-:2]) ? (w_dce_boks[0] |
                            ((q_oc_write[\=i=\] | (~outstanding_read)) & w_dce_woks[0])):
\js } else {
                  (~| q_oc_tin[\=i=\][TINW+1-:2]) ? (w_dce_boks[q_oc_tin[\=i=\][\=log2ceil(nDCEs)-1=\:0]] |
			    ((q_oc_write[\=i=\] | (~outstanding_read)) & w_dce_woks[q_oc_tin[\=i=\][\=log2ceil(nDCEs)-1=\:0]])):
\js }
\js if (nDMIs==1) {
                      q_oc_tin[\=i=\][TINW] ? (w_dmi_boks[0] |
                            ((q_oc_write[\=i=\] | (~outstanding_read)) & w_dmi_woks[0])):
\js } else {
		      q_oc_tin[\=i=\][TINW] ? (mux_dmi_cok_boks\=i=\ |
			    ((q_oc_write[\=i=\] | (~outstanding_read)) & mux_dmi_cok_woks\=i=\)):
\js }
\js if (nDIIs==1) {
                      q_oc_tin[\=i=\][TINW+1] ? (w_dii_boks[0] |
                            ((q_oc_write[\=i=\] | (~outstanding_read)) & w_dii_woks[0])):
\js } else {
		      q_oc_tin[\=i=\][TINW+1] ? (mux_dii_cok_boks\=i=\ |
			    ((q_oc_write[\=i=\] | (~outstanding_read)) & mux_dii_cok_woks\=i=\)):
\js }
					1'b1); 

\js }

   wire [OCN-1:0] q_oc_kok_ns = (|t_oc_count) ? (q_oc_val & t_oc_cok & t_oc_qok & t_oc_iok) : q_oc_kok;
   \=u.dffre(OCN, `q_oc_kok`, `q_oc_kok_ns`, `{`+OCN+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
   wire [OCN-1:0] q_oc_dok_ns = (|t_oc_count) ? (q_oc_val & t_oc_iok) : q_oc_dok;
   \=u.dffre(OCN, `q_oc_dok`, `q_oc_dok_ns`, `{`+OCN+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
	  
   assign t_oc_kok_in = (|t_oc_count) ? (q_oc_val & t_oc_cok & t_oc_qok &  t_oc_iok) : q_oc_kok;
   assign t_oc_kok = q_oc_kok;
   assign t_oc_dok = q_oc_dok;

\js } else { // QOSA
\js // Copy and paste code above but remove qok
\js for (let i=0; i<OCN; i=i+1) {
\js // If the special write credit is already used, and reads cant go. Allow reads to fight for arbitration.
    assign t_oc_cok[\=i=\] = (t_cfg_qos |
\jsbegin
// The tachl parameter QOSN is either 0 or 8
/* istanbul ignore if env ncore_3p7 */
    if (QOSN==1) { \jsend
                      w_qos_boks[0] |
                     (w_qos_woks[0] & q_oc_write[\=i=\])) &
\js } else {
		      w_qos_boks[w_oc_qin[\=i=\]] |
		     (w_qos_woks[w_oc_qin[\=i=\]] & q_oc_write[\=i=\])) &
\js }
	     (~q_oc_write[\=i=\] & (t_oc_snoop[\=i=\]==4'hf) ? w_dve_boks[0] :	      
\js if (nDCEs==1) {
                  (~| q_oc_tin[\=i=\][TINW+1-:2]) ? (w_dce_boks[0] |
                            ((q_oc_write[\=i=\] | (~outstanding_read)) & w_dce_woks[0])):
\js } else {
                  (~| q_oc_tin[\=i=\][TINW+1-:2]) ? (w_dce_boks[q_oc_tin[\=i=\][\=log2ceil(nDCEs)-1=\:0]] |
			    ((q_oc_write[\=i=\] | (~outstanding_read)) & w_dce_woks[q_oc_tin[\=i=\][\=log2ceil(nDCEs)-1=\:0]])):
\js }
\js if (nDMIs==1) {
                      q_oc_tin[\=i=\][TINW] ? (w_dmi_boks[0] |
                            ((q_oc_write[\=i=\] | (~outstanding_read)) & w_dmi_woks[0])):
\js } else {
		      q_oc_tin[\=i=\][TINW] ? (w_dmi_boks[q_oc_tin[\=i=\][\=log2ceil(nDMIs)-1=\:0]] |
			    ((q_oc_write[\=i=\] | (~outstanding_read)) & w_dmi_woks[q_oc_tin[\=i=\][\=log2ceil(nDMIs)-1=\:0]])):
\js }
\js if (nDIIs==1) {
                      q_oc_tin[\=i=\][TINW+1] ? (w_dii_boks[0] |
                            ((q_oc_write[\=i=\] | (~outstanding_read)) & w_dii_woks[0])):
\js } else {
		      q_oc_tin[\=i=\][TINW+1] ? (w_dii_boks[q_oc_tin[\=i=\][\=log2ceil(nDIIs)-1=\:0]] |
			    ((q_oc_write[\=i=\] | (~outstanding_read)) & w_dii_woks[q_oc_tin[\=i=\][\=log2ceil(nDIIs)-1=\:0]])):
\js }
					1'b1);
\js }

   wire [OCN-1:0] q_oc_kok_ns = (|t_oc_count) ? (q_oc_val & t_oc_cok & t_oc_iok) : q_oc_kok;
   \=u.dffre(OCN, `q_oc_kok`, `q_oc_kok_ns`, `{`+OCN+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
   wire [OCN-1:0] q_oc_dok_ns = (|t_oc_count) ? (q_oc_val & t_oc_iok) : q_oc_dok;
   \=u.dffre(OCN, `q_oc_dok`, `q_oc_dok_ns`, `{`+OCN+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign t_oc_kok_in = (|t_oc_count) ? (q_oc_val & t_oc_cok &  t_oc_iok) : q_oc_kok;
  assign t_oc_kok = q_oc_kok;
  assign t_oc_dok = q_oc_dok;
\js } // QOSA

     assign t_oc_qval = q_oc_val & t_oc_iok & t_oc_skid & t_oc_cok;
\js for (let i=0; i<OCN; i=i+1) {

\=u.instance({
	moduleName: 'ioaiu_qmap',
	instanceName: 'oc_qmap'+i,
	params: {assertOn: assertOn,
                 clkAssertInterface : clkAssertInterface,
		 QOSA:	   QOSA,
		 QMAP:	   QMAP,
		 QOSN:	   QOSN,
		 QOSW:	   QOSW
	},
	ports: {
		val_i:		't_oc_qval['+i+']',
		qos_i:		'q_oc_qos['+i+']',
		qin_o:		'w_oc_qin['+i+']',
		qbv_o:		'w_oc_qbvs['+i+'*QOSN +: QOSN]'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

\js }

\=u.instance({
	moduleName: 'ioaiu_qmap',
	instanceName: 'pt_qmap',
	params: {assertOn: assertOn,
                 clkAssertInterface : clkAssertInterface,
		 QOSA:	   QOSA,
		 QMAP:	   QMAP,
		 QOSN:	   QOSN,
		 QOSW:	   QOSW
	},
	ports: {
		val_i:		'w_p2_valid',
		qos_i:		'n_cmd_req0_qos',
		qin_o:		'n_cmd_req0_qin',
		qbv_o:		''
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

\js } else { // QOSE > 0
  wire [OCN-1:0]		q_oc_kok;
  wire [OCN-1:0]		q_oc_dok;

\js // Copy and paste code above but romove qok
\js for (let i=0; i<OCN; i=i+1) {

\js if (nDIIs>1) {
wire mux_dii_cok_boks\=i=\ =
\js for (let j=0;j<nDIIs;j++) {
                                             ((q_oc_tin[\=i=\][\=log2ceil(nDIIs)-1=\:0] == \=log2ceil(nDIIs)=\'d\=j=\) ? w_dii_boks[\=j=\] : 1'b0)\=(j==(nDIIs-1))?";":"|"=\
\js }
wire mux_dii_cok_woks\=i=\ =
\js for (let j=0;j<nDIIs;j++) {
                                             ((q_oc_tin[\=i=\][\=log2ceil(nDIIs)-1=\:0] == \=log2ceil(nDIIs)=\'d\=j=\) ? w_dii_woks[\=j=\] : 1'b0)\=(j==(nDIIs-1))?";":"|"=\
\js }
\js }
\js if (nDMIs>1) {
wire mux_dmi_cok_boks\=i=\ =
\js for (let j=0;j<nDMIs;j++) {
                                             ((q_oc_tin[\=i=\][\=log2ceil(nDMIs)-1=\:0] == \=log2ceil(nDMIs)=\'d\=j=\) ? w_dmi_boks[\=j=\] : 1'b0)\=(j==(nDMIs-1))?";":"|"=\
\js }
wire mux_dmi_cok_woks\=i=\ =
\js for (let j=0;j<nDMIs;j++) {
                                             ((q_oc_tin[\=i=\][\=log2ceil(nDMIs)-1=\:0] == \=log2ceil(nDMIs)=\'d\=j=\) ? w_dmi_woks[\=j=\] : 1'b0)\=(j==(nDMIs-1))?";":"|"=\
\js }
\js }

\js // If the special write credit is already used, and reads cant go. Allow reads to fight for arbitration.
    assign t_oc_cok[\=i=\] = (t_cfg_qos |
		                                                  1'b1) &
	     (~q_oc_write[\=i=\] & (t_oc_snoop[\=i=\]==4'hf) ? w_dve_boks[0] :	      
\js if (nDCEs==1) {
                  (~| q_oc_tin[\=i=\][TINW+1-:2]) ? (w_dce_boks[0] |
                            ((q_oc_write[\=i=\] | (~outstanding_read)) & w_dce_woks[0])):
\js } else {
                  (~| q_oc_tin[\=i=\][TINW+1-:2]) ? (w_dce_boks[q_oc_tin[\=i=\][\=log2ceil(nDCEs)-1=\:0]] |
			    ((q_oc_write[\=i=\] | (~outstanding_read)) & w_dce_woks[q_oc_tin[\=i=\][\=log2ceil(nDCEs)-1=\:0]])):
\js }
\js if (nDMIs==1) {
                      q_oc_tin[\=i=\][TINW] ? (w_dmi_boks[0] |
                            ((q_oc_write[\=i=\] | (~outstanding_read)) & w_dmi_woks[0])):
\js } else {
		      q_oc_tin[\=i=\][TINW] ? (mux_dmi_cok_boks\=i=\ |
			    ((q_oc_write[\=i=\] | (~outstanding_read)) & mux_dmi_cok_woks\=i=\)):
\js }
\js if (nDIIs==1) {
                      q_oc_tin[\=i=\][TINW+1] ? (w_dii_boks[0] |
                            ((q_oc_write[\=i=\] | (~outstanding_read)) & w_dii_woks[0])):
\js } else {
		      q_oc_tin[\=i=\][TINW+1] ? (mux_dii_cok_boks\=i=\ |
			    ((q_oc_write[\=i=\] | (~outstanding_read)) & mux_dii_cok_woks\=i=\)):
\js }
					1'b1);
\js }

   wire [OCN-1:0] q_oc_kok_ns = (|t_oc_count) ? (q_oc_val & t_oc_cok & t_oc_iok) : q_oc_kok;
   \=u.dffre(OCN, `q_oc_kok`, `q_oc_kok_ns`, `{`+OCN+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
   wire [OCN-1:0] q_oc_dok_ns = (|t_oc_count) ? (q_oc_val & t_oc_iok) : q_oc_dok;
   \=u.dffre(OCN, `q_oc_dok`, `q_oc_dok_ns`, `{`+OCN+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign t_oc_kok_in = (|t_oc_count) ? (q_oc_val & t_oc_cok & t_oc_iok) : q_oc_kok;
  assign t_oc_kok = q_oc_kok;
  assign t_oc_dok = q_oc_dok;
  assign w_oc_qok = {QOSN{1'b0}};
  assign n_cmd_req0_qin = {QOSW{1'b0}};
\js for (let i=0; i<OCN; i=i+1) {
    assign w_oc_qin[\=i=\] = {QOSW{1'b0}};
\js }
\js } // QOSE>0

assign w_qos_boks = {QOSN{1'b1}};
assign w_qos_woks = {QOSN{1'b1}};
assign w_qos_idle = 1'b1;

assign n_dtv_valid = (| t_oc_dtv);

wire            w_oc_ehit;

assign chaining_in_progress_ns = 
\js for (let i=0;i<OCN;i++) {
                                (q_oc_val[\=i=\] & q_oc_write[\=i=\] & ~q_oc_eob[\=i=\] & q_oc_status[\=i=\][7]) |
\js }
                                1'b0;
\=u.dffre(1, `chaining_in_progress`, `chaining_in_progress_ns`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\

\jsbegin
if (owo) {
var tin_mux_ports = {};

for (let i=0; i<OCN ;i++) {
        tin_mux_ports['in'+i] = "q_oc_tin["+i+"][TINW+1]";
}

tin_mux_ports['sel']   = "t_oc_ihit";
tin_mux_ports['out']   = "is_dii";
\jsend  
  
wire is_dii;

\=u.instance({
        instanceName: 'u_tin_mux',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : OCN,
                        wMux             : 1
        },
        verilogParams: {},
        ports: tin_mux_ports
})=\

\jsbegin
var tid_mux_ports = {};

for (let i=0; i<OCN ;i++) {
        tid_mux_ports['in'+i] = "q_oc_tid["+i+"]";
}

tid_mux_ports['sel']   = "t_oc_ihit";
tid_mux_ports['out']   = "dii_tid";
\jsend 

wire [\=MRCT-1=\:0] dii_tid;

\=u.instance({
        instanceName: 'u_tid_mux',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : OCN,
                        wMux             : MRCT
        },
        verilogParams: {},
        ports: tid_mux_ports
})=\
\js }

\js for (let i=0; i<OCN; i=i+1) {

assign t_oc_alloc[\=i=\] = t_oc_we & (q_oc_wptr==\=OCA=\'d\=i=\);
assign t_oc_update[\=i=\] = w_pt_valid & n_pt_ready & w_pt_wake & (w_pt_kid_oh[\=i=\]);
assign t_oc_dealloc[\=i=\] = // (q_oc_status[\=i=\]==8'h84) && ~q_oc_wfresp[\=i=\] && q_oc_val[\=i=\] ||  // terminate on address error
                         q_oc_val[\=i=\] & ~q_oc_wfa[\=i=\] & ~q_oc_wake[\=i=\] &
                                       ~q_oc_dval[\=i=\] & ~q_oc_wfodr[\=i=\] &
                                      ~(w_poc_valid & (w_poc_oid==\=OCA=\'d\=i=\)) &
                                      ~(w_rr_valid & (w_rr_kid==\=XTA=\'d\=i=\) & w_rr_wake) &
                                      ~((P1EN>0) & w_p1_valid &
                                                   w_p1_wake & (w_p1_kid==\=XTA=\'d\=i=\)) &
                                      ~(w_p2_valid & w_pt_wake & w_pt_kid_oh[\=i=\])&
                                       (~| (t_oc_atop[\=i=\] & 6'h20)) &
                                       (t_oc_evict[\=i=\] ? ~q_oc_wfresp[\=i=\] :
                                                        ~t_oc_wfack[\=i=\]) &
                                       (~q_oc_wfstp[\=i=\] | t_oc_chit[\=i=\]);
assign t_oc_valloc[\=i=\] = w_c2_evict & (n_oc_eptr==\=OCA=\'d\=i=\);
assign t_oc_dval[\=i=\] = (q_oc_val[\=i=\] & ~(w_c2_done & ~q_oc_write[\=i=\] &
					w_pt_wake & w_pt_kid_oh[\=i=\]) &
				     ((q_oc_wfa[\=i=\] & ~w_pw0_obv[\=i=\] &
					~(w_odr_valid & w_odr_last & 
					  n_odr_ready & (w_odr_oid==\=OCA=\'d\=i=\))) |
				       q_oc_wfodr[\=i=\] |
				       (| (t_oc_atop[\=i=\] & 6'h20)) |
				       (q_oc_write[\=i=\] & t_oc_chit[\=i=\] & 
					w_wq_valid & (w_wq_oid==\=OCA=\'d\=i=\)) |
				       (q_oc_write[\=i=\] & q_oc_wfstr[\=i=\]) |
				       (q_oc_wfstr[\=i=\] & ~t_oc_chit[\=i=\]) | 
					q_oc_wfadw[\=i=\] | q_oc_wfdtw[\=i=\]));
assign t_oc_dbusy[\=i=\] = t_oc_dval[\=i=\] ? ({{OLN-1{1'b0}}, 1'b1} << q_oc_dptr[\=i=\]) :
					 {OLN{1'b0}};
assign t_co_dptr[\=i*OLA=\ +: OLA] = q_oc_dptr[\=i=\] & {OLA{w_co_obv[\=i=\]}};
assign t_odr_dptr[\=i*OLA=\ +: OLA] = q_oc_dptr[\=i=\] & {OLA{n_odr_obv[\=i=\]}};
assign t_odf_dptr[\=i*OLA=\ +: OLA] = q_oc_dptr[\=i=\] & {OLA{n_odf_obv[\=i=\]}};
assign t_srd_dptr[\=i*OLA=\ +: OLA] = q_oc_dptr[\=i=\] & {OLA{w_srd_obv[\=i=\]}};
assign t_oc_wrbk[\=i=\] = (CDW>1) & q_oc_val[\=i=\] & q_oc_write[\=i=\] & ~t_oc_bar[\=i=\][0] &
	     (//((t_oc_domain[\=i=\] < 2'h3) & (t_oc_snoop[\=i=\]==4'h2)) |//WriteClean
	       (((t_oc_domain[\=i=\]==2'h1) | (t_oc_domain[\=i=\]==2'h2)) & 
					((t_oc_snoop[\=i=\]==4'h3) |    //WriteBack
					 (t_oc_snoop[\=i=\]==4'h4) |    //Evict
					 (t_oc_snoop[\=i=\]==4'h5))));  //WriteEvict
assign t_oc_wrev[\=i=\] = (CDW>1) & q_oc_val[\=i=\] & q_oc_write[\=i=\] &
					((t_oc_snoop[\=i=\]==4'h2) |    //WriteClean
					 (t_oc_snoop[\=i=\]==4'h3) |    //WriteBack
					 (t_oc_snoop[\=i=\]==4'h4) |    //Evict
					 (t_oc_snoop[\=i=\]==4'h5));    //WriteEvict
assign t_oc_dtv[\=i=\] = t_oc_dve[\=i=\] & q_oc_wfdtw[\=i=\] & ~q_oc_wfstr[\=i=\] &
						   //~q_oc_wfstr[q_oc_iptr[\=i=\]];
						   ~q_oc_wfstr_at_iptr[\=i=\];

\js if (isDvmAgent) {
assign t_oc_dve[\=i=\] = q_oc_val[\=i=\] & ~q_oc_write[\=i=\] & 
					     (t_oc_snoop[\=i=\]==4'hf);					    
assign t_oc_dvm[\=i=\] = q_oc_val[\=i=\] & ~q_oc_write[\=i=\] & 
					     (t_oc_snoop[\=i=\]==4'he);
assign t_oc_dve_sync[\=i=\] = t_oc_dve[\=i=\] & (q_oc_addr[\=i=\][14:12]==3'b100) & ~q_oc_dve_2nd[\=i=\];
\js } else {
assign t_oc_dve[\=i=\] = 1'b0;				    
assign t_oc_dvm[\=i=\] = 1'b0;
assign t_oc_dve_sync[\=i=\] = 1'b0;
\js }

assign t_oc_stp[\=i=\] = q_oc_val[\=i=\] &
                        ((t_oc_owo_wfstp[\=i=\] & ((OTEN==0) | ~w_ocp_obv[\=i=\])) |
                        (q_oc_wfstp[\=i=\] & 
		          ((OTEN==0) | ~w_ocp_obv[\=i=\]) &
\js if (owo) {
                          ~((t_oc_phase[\=i=\] == 2'b0) & ~t_oc_atop_persist[\=i=\] & q_oc_write[\=i=\]) &
\js }
                          ~q_oc_wfcmp[\=i=\] &
		          (t_oc_evict[\=i=\] ? ~q_oc_wfa[\=i=\] : 1'b1) & 
		          ~t_oc_wfcfd[\=i=\] & ~t_oc_wfcft[\=i=\] & ~t_oc_wfack_stp[\=i=\] &
		          ~q_oc_wfresp[\=i=\] & ~q_oc_wfstr[\=i=\] & ~q_oc_wfdtr[\=i=\] &
		          ~q_oc_wfdtw[\=i=\] & ~q_oc_wfdtp[\=i=\] & ~q_oc_wfadw[\=i=\]));

\js // AXID serialization on no AXID interleave feature
  assign t_oc_ihit[\=i=\] = q_oc_val[\=i=\] & q_oc_itail[\=i=\] & 
		      (((t_pt_dve) & ~t_cfg_dhit) | q_oc_wfa[\=i=\] | q_oc_wfstr[\=i=\]) & 
		      (q_oc_write[\=i=\] ~^ w_pt_write) & ~w_pt_wake &
		      ~t_oc_evict[\=i=\] & (t_cfg_ihit | 
			((~t_cfg_dhit & (t_pt_dve)) ? (t_oc_dve[\=i=\] & ~t_oc_dealloc[\=i=\]) : (q_oc_id[\=i=\] == w_pt_id)));

\js // t_oc_ohit is only use as an indicator to sleep the transaction when its new through the pipe
\js // - For OWO Coh-Wr this hit wont happen as the CMO can always progress.
\js // - For OWO Non-Coh-Wr this will need to follow the table for the DII/DMI to same or differant targets.
\js // - For OWO Reads have no change.
\jsbegin
// No owo on 3.7.0
    if (owo) { \jsend


  wire id_channel_match_\=i=\ = ((q_oc_id[\=i=\] == w_pt_id) | t_cfg_ihit) & (q_oc_write[\=i=\] ~^ w_pt_write);

  reg r_oc_ohit\=i=\;

  wire same_dii_alt\=i=\      = t_pt_dii & q_oc_tin[w_oc_ihid][TINW+1] &({w_amc_fids[2*FIDW +: FIDW],1'b0} == q_oc_tid[w_oc_ihid]);
  wire same_dii\=i=\          = t_pt_dii & is_dii                      &({w_amc_fids[2*FIDW +: FIDW],1'b0} == dii_tid);
  wire differant_dii_alt\=i=\ = t_pt_dii & q_oc_tin[w_oc_ihid][TINW+1] &({w_amc_fids[2*FIDW +: FIDW],1'b0} != q_oc_tid[w_oc_ihid]);
  wire differant_dii\=i=\     = t_pt_dii & is_dii                      &({w_amc_fids[2*FIDW +: FIDW],1'b0} != dii_tid);

  // If Coherent you need to wait for the STRReq that goes to DMI, not the CMO STRReq
  // If Coherent you need to wait all during phase 0 also
  wire wf_str_req\=i=\    = t_oc_coh[\=i=\] ? ((q_oc_wfstr[\=i=\] & (t_oc_phase[\=i=\] != 0)) | (t_oc_phase[\=i=\] == 0)) : q_oc_wfstr[\=i=\];

  always @ (*) begin
       casez ({w_pt_write, t_pt_coherent & ~t_oc_atop_persist[\=i=\] & ~t_cfg_ihit})
       	    2'b0?: begin
	    	  r_oc_ohit\=i=\ = q_oc_val[\=i=\] & id_channel_match_\=i=\ & (q_oc_wfresp[\=i=\] | q_oc_wfstr[\=i=\]); // This is sending the Reads so they need to be ordered. 
 	    end
	    2'b10: begin
	    	  // This is conservative ordering ensuring that DTWReqs would make progress in the non-coherent case.
	    	  r_oc_ohit\=i=\ = (same_dii\=i=\) ?      q_oc_val[\=i=\] & id_channel_match_\=i=\ & (q_oc_wfresp[\=i=\] | wf_str_req\=i=\)                     :
				   (differant_dii\=i=\) ? q_oc_val[\=i=\] & id_channel_match_\=i=\ & (q_oc_wfresp[\=i=\] | wf_str_req\=i=\ | ~q_oc_otail[\=i=\]):
				                          q_oc_val[\=i=\] & id_channel_match_\=i=\ & (q_oc_wfresp[\=i=\] | wf_str_req\=i=\ |  q_oc_wfdtp[\=i=\]);
							  // The DMI is the same whether its to the same or differant targets. Need to wait for DTWRsps
	    end
	    2'b11: begin
	    	  r_oc_ohit\=i=\ = 1'b0; // This is sending the CMOs
	    end
	    default: begin
	    	  r_oc_ohit\=i=\ = 1'b0;
	    end
       endcase
  end

  assign t_oc_ohit[\=i=\] = r_oc_ohit\=i=\;
\js } else {
  assign t_oc_ohit[\=i=\] = q_oc_val[\=i=\] & (((~t_cfg_dhit & (t_pt_dve)) & t_oc_dve[\=i=\]) |
		      (q_oc_wfresp[\=i=\] | q_oc_wfstr[\=i=\] |
		       (((q_oc_wfdtr[\=i=\] & ~q_oc_write[\=i=\]) |
			 (q_oc_wfdtw[\=i=\] & q_oc_write[\=i=\]) |
			 q_oc_wfdtp[\=i=\]) & ((~| w_pt_cache[3:1]) |
					 (w_pt_cache[1] & w_pt_write & 
					  (w_amc_order[4:3]==2'h3))))) &
		      (q_oc_write[\=i=\] ~^ w_pt_write) &
		      (~w_pt_wake | !w_pt_kid_oh[\=i=\]) &
		      ~t_oc_evict[\=i=\] & ((q_oc_id[\=i=\] == w_pt_id) | t_cfg_ihit));
\js }

assign t_oc_ihead[\=i=\] = q_oc_iptr_eq[\=i=\]; //(q_oc_iptr[\=i=\] == i);

\js // Used to blindly catch case where two transactions with the same address, same id, and same channel
\js //  cannot be reordered in cases where AWID/ARID ordering is ignored.
assign t_oc_ahit_outstanding[\=i=\] =   q_oc_val[\=i=\] & !w_pt_kid_oh[\=i=\] & 
                                  ((q_oc_addr[\=i=\][AW-1:CLO] == w_pt_addr[AW-1:CLO]) &
			  	   (q_oc_security[\=i=\]       ==       w_pt_security) );

assign t_oc_ahitr[\=i=\] = //((CACHE>0) | (CDW>1) | (QOSE>0) | t_cfg_ahit[1]) & 
			 q_oc_val[\=i=\] & ~t_oc_evict[\=i=\] & 
					(~t_oc_wrev[\=i=\] | w_pt_write) &
				   ~((CDW>1) & w_pt_write & //~w_pt_bar[0] &
				     (w_pt_snoop==4'h4)) &  	//ACE Evict
				 ~((CDW>1) & ~q_oc_write[\=i=\] &
				   w_pt_write & //~w_pt_bar[0] &
				   ((w_pt_snoop==4'h2) | 	//ACE WriteClean
				    (w_pt_snoop==4'h3) | 	//ACE WriteBack
				    (w_pt_snoop==4'h5))) &	//ACE WriteEvict
			 (q_oc_wfstp[\=i=\] | t_oc_wfcwd[\=i=\]) &
			 q_oc_atail[\=i=\] & ~w_pt_wake &
				     ~t_oc_dve[\=i=\] & (CACHE>0) & (t_cfg_ahit |
				((q_oc_addr[\=i=\][AW-1:CLO]==w_pt_addr[AW-1:CLO]) &
			  	 (q_oc_security[\=i=\]==w_pt_security)));

assign addr_match[\=i=\] = q_oc_val[\=i=\] & ~t_oc_dealloc[\=i=\] & 
			 ((q_oc_addr[\=i=\][AW-1:CLO] == w_pt_addr[AW-1:CLO]) & (q_oc_security[\=i=\] == w_pt_security));
			  
assign t_oc_ahite[\=i=\] = //((CACHE>0) | (CDW>1) | (QOSE>0) | t_cfg_ahit[1]) & 
			 q_oc_val[\=i=\] & t_oc_evict[\=i=\] &
			 ~t_oc_dealloc[\=i=\] &
							(t_cfg_ahit |
			 ((q_oc_addr[\=i=\][AW-1:CLO] == w_pt_addr[AW-1:CLO]) &
			  (q_oc_security[\=i=\] == w_pt_security)));
assign t_oc_coal[\=i=\] = 1'b0;

\js // *_next signal creates loop if pipe does not exist.

assign t_oc_rdone[\=i=\] = (n_dtr_req_rx_ready & 
			   t_srd_dtr & (w_srd_oid==\=OCA=\'d\=i=\) & w_dtr_req_rx_last);

\js if (OTEN) {
assign t_oc_rok[\=i=\] = q_oc_val[\=i=\] & ~q_oc_wfdtr[\=i=\] & ~t_oc_evict[\=i=\] &
			 ~n_odr_obv[\=i=\] &
			(~w_sod_valid | (!w_sod_oid_bv[\=i=\])) & //(w_sod_oid != i[OCN-1:0])) &
			~t_oc_chit[\=i=\] & (~q_oc_wfstr[\=i=\] | (q_oc_rdone[\=i=\] & ~q_oc_lock[\=i=\]))  &
			((~q_oc_write[\=i=\] & q_oc_wfa[\=i=\]) |
			 ((| (t_oc_atop[\=i=\] & 6'h20)) & ~q_oc_wfdtr[\=i=\])) & 
			(~q_oc_wfdtp[\=i=\] & ~q_oc_wfdtw[\=i=\]) &
		     (q_oc_iptr_eq[\=i=\]);
\js } else {
assign t_oc_rok[\=i=\] = q_oc_val[\=i=\] & ~q_oc_wfdtr[\=i=\] & ~t_oc_evict[\=i=\] &
			(~w_sod_valid | (!w_sod_oid_bv[\=i=\])) &
			~t_oc_chit[\=i=\] & (~q_oc_wfstr[\=i=\] | (q_oc_rdone[\=i=\] & ~q_oc_lock[\=i=\]))  &
			((~q_oc_write[\=i=\] & q_oc_wfa[\=i=\]) |
			 ((| (t_oc_atop[\=i=\] & 6'h20)) & ~q_oc_wfdtr[\=i=\])) & 
			(~q_oc_wfdtp[\=i=\] & ~q_oc_wfdtw[\=i=\]) &
		     (q_oc_iptr_eq[\=i=\]);
\js }

assign t_oc_error[\=i=\] = q_oc_status[\=i=\][7];

\jsbegin
// No owo on 3.7.0
    if ( owo ) { \jsend
  reg mask_oc_dtw\=i=\;

  wire pt_coherent\=i=\ = t_oc_coh[q_oc_iptr[\=i=\]];
  wire pt_iptr_eq\=i=\ = q_oc_iptr_eq[q_oc_iptr[\=i=\]];
  
  wire pt_str\=i=\ =  q_oc_wfstr[q_oc_iptr[\=i=\]];
  wire pt_resp\=i=\ =  q_oc_wfresp[q_oc_iptr[\=i=\]];
  wire pt_dtw\=i=\ =  q_oc_wfdtw[q_oc_iptr[\=i=\]];
  wire pt_dtp\=i=\ =  q_oc_wfdtp[q_oc_iptr[\=i=\]];
  wire pt_upd\=i=\ =  q_oc_wfresp[q_oc_iptr[\=i=\]] & (t_oc_phase[q_oc_iptr[\=i=\]] == 2'd2);

  wire pt_target_match\=i=\ = (q_oc_tid[\=i=\] == q_oc_tid[q_oc_iptr[\=i=\]]);
  wire oc_dmi\=i=\ = q_oc_tin[\=i=\][TINW];
  wire oc_dii\=i=\ = q_oc_tin[\=i=\][TINW+1];
  wire pt_dmi\=i=\ = q_oc_tin[q_oc_iptr[\=i=\]][TINW];
  wire pt_dii\=i=\ = q_oc_tin[q_oc_iptr[\=i=\]][TINW+1];

  \js // Use original logic, and just mask off entries which arent ready ordering wise.
  \js // Possible timing optimization if it comes to it to combine the mask it. 
  wire pre_oc_dtw\=i=\ = ((OTEN==0) | (~w_ocw_valid | ~n_odf_obv[\=i=\])) &
\jsbegin
// For owo if phase is 0 that means a CMO is needed, and that first STRReq would be for the CMO. 
// Essentially the write needs to be in its "Writeback" phase to send a DTWReq
// No owo on 3.7.0
if (owo) {
\jsend
		    ((t_oc_phase[\=i=\] != 2'b0) | (|(t_oc_atop[\=i=\]))) &
\js }
		     ((q_oc_val[\=i=\] & q_oc_wfdtw[\=i=\] & ~q_oc_wfstr[\=i=\] &
				   ~t_oc_dve[\=i=\] &
				   ~q_oc_wfdtr[\=i=\] & ~q_oc_wfadw[\=i=\] &
				   (~w_sod_valid | (!w_sod_oid_bv[\=i=\])) &
				   ~t_oc_evict[\=i=\] & ~t_oc_catop[\=i=\]) |
		      (q_oc_val[\=i=\] & t_oc_evict[\=i=\] & q_oc_wfdtw[\=i=\] & 
				   ~q_oc_wfdtr[\=i=\] & ~q_oc_wfstr[\=i=\]));


  \js // Follows DTWReq ordering point table. 
  always @ (*) begin
  	 casez({q_oc_iptr_eq[\=i=\],pt_target_match\=i=\,oc_dii\=i=\,oc_dmi\=i=\,t_oc_coh[\=i=\],pt_coherent\=i=\})
		6'b1_?_?_?_?_?: begin
			     mask_oc_dtw\=i=\ = 1'b1; // No dependency match.
		end
		6'b0_1_1_0_0_0: begin
			     mask_oc_dtw\=i=\ = 1'b1; // Can send whenever it gets its STRReq
		end
		6'b0_1_0_1_?_0: begin
			     mask_oc_dtw\=i=\ = ~(pt_dtw\=i=\) & ~(pt_dtp\=i=\);	// Needs to wait for the DTWRsp of the previous TXN	
		end
		6'b0_0_?_?_1_1: begin
			     mask_oc_dtw\=i=\ = 1'b1; // Can send whenever it gets its STRReq		
		end
		6'b0_0_?_?_0_1: begin
			     mask_oc_dtw\=i=\ = ~(pt_upd\=i=\);	// Needs to wait for update to complete. 				     				
		end
		6'b0_0_?_?_1_0: begin
			     mask_oc_dtw\=i=\ = ~(pt_dtw\=i=\) & ~(pt_dtp\=i=\);	// Needs to wait for the DTWRsp of the previous TXN				     		
		end
		6'b0_0_?_?_0_0: begin
			     mask_oc_dtw\=i=\ = ~(pt_dtw\=i=\) & ~(pt_dtp\=i=\);	// Needs to wait for the DTWRsp of the previous TXN				     
		end
		default: begin
			     mask_oc_dtw\=i=\ = 1'b1; 				
		end
	 endcase
  end

//assign t_oc_dtw[\=i=\] = mask_oc_dtw\=i=\ & pre_oc_dtw\=i=\;
  assign t_oc_dtw[\=i=\] = ~(|q_oc_dtp_collision\=i=\) & pre_oc_dtw\=i=\;
  
\js } else {
  assign t_oc_dtw[\=i=\] = ((OTEN==0) | (~w_ocw_valid | ~n_odf_obv[\=i=\])) &
		     ((q_oc_val[\=i=\] & q_oc_wfdtw[\=i=\] & ~q_oc_wfstr[\=i=\] &
				   ~t_oc_dve[\=i=\] &
				   ~q_oc_wfdtr[\=i=\] & ~q_oc_wfadw[\=i=\] &
				   (~w_sod_valid | (!w_sod_oid_bv[\=i=\])) &
				   ~t_oc_evict[\=i=\] & ~t_oc_catop[\=i=\]) |
		      (q_oc_val[\=i=\] & t_oc_evict[\=i=\] & q_oc_wfdtw[\=i=\] & 
				   ~q_oc_wfdtr[\=i=\] & ~q_oc_wfstr[\=i=\]));
\js }

assign t_oc_wdone[\=i=\] = q_oc_val[\=i=\] & q_oc_write[\=i=\] & q_oc_eob[\=i=\] & q_oc_wfa[\=i=\] &
			((OTEN==0) | ~w_pw0_obv[\=i=\]) &
		       ~q_oc_wfresp[\=i=\] & ~q_oc_wfstr[\=i=\] & ~t_oc_wfcwd[\=i=\] &
		       ~q_oc_wfdtr[\=i=\] & ~q_oc_wfdtw[\=i=\] & ~q_oc_wfadw[\=i=\] & 
			(~w_sod_valid | (!w_sod_oid_bv[\=i=\])) &
		       ~q_oc_wfdtp[\=i=\] & ~t_oc_wfmru[\=i=\] &
			(~q_oc_wfstp[\=i=\] |
\js if (isDvmAgent||axiParams.wCdData) {
			                  1'b1)
\js } else {
			                  1'b0)
\js }
			                                       & (q_oc_iptr[\=i=\]==\=OCA=\'d\=i=\);

assign q_oc_chain_complete_ns\=i=\ = t_oc_alloc[\=i=\] ? 1'b0 : (q_oc_val[\=i=\] & q_oc_status[\=i=\][7] & ~q_oc_eob[\=i=\] & (|(
\js for (let j=0;j<OCN;j++) {
                                                                        (q_oc_ancestor_transfer\=j=\[\=OCA=\] & (q_oc_ancestor_transfer\=j=\[\=OCA-1=\:0] == \=OCA=\'d\=i=\)) |
\js }
                                                                        1'b0
                                                                                                                                ))) ? 1'b1 : q_oc_chain_complete\=i=\;

\=u.dffre(1, `q_oc_chain_complete`+i, `q_oc_chain_complete_ns`+i, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\

assign t_oc_fkm[\=i=\] = q_oc_val[\=i=\] & q_oc_write[\=i=\] & ~q_oc_partial[\=i=\] &
				   ((OTEN==0) | ~w_fkm_obv[\=i=\]) & (CACHE>0) &
				  ~q_oc_wfstr[\=i=\] & ~t_oc_chit[\=i=\] &
                                  ~q_oc_wfresp[\=i=\] &
				   q_oc_wfdtr[\=i=\];

wire [XTA-1:0] q_oc_iptr_tmp\=i=\;
\js if(OCA>=STA) {
	assign q_oc_iptr_tmp\=i=\ = q_oc_iptr[\=i=\];
\js } else {
	assign q_oc_iptr_tmp\=i=\ = {{STA-OCA{1'b0}},q_oc_iptr[\=i=\]};
\js }

assign q_oc_iptr_next[\=i=\] = (t_oc_alloc[\=i=\] & (| t_oc_ihit)) ? w_oc_ihid :
			 t_oc_alloc[\=i=\] ? q_oc_wptr :
			(t_oc_valloc[\=i=\] & ~w_c2_flush) |
			(t_oc_valloc[\=i=\] & 
			 t_co_fdone & (t_oc_ehid == w_co_oid)) ? \=OCA=\'d\=i=\ :
			 t_oc_valloc[\=i=\] ? t_oc_ehid :
			 (q_oc_val[\=i=\] & (
			   ((~t_cfg_dhit & t_oc_dve[\=i=\]) ? 
					  ~t_oc_wfack[q_oc_iptr[\=i=\]] :
					  ~q_oc_wfa[q_oc_iptr[\=i=\]] |
			   		  (t_srd_adone & t_srd_ihead & 
					   (q_oc_iptr[\=i=\] == w_srd_oid)) |
			   		  (w_c2_done & w_pt_wake & 
					   ~q_oc_write[\=i=\] &
					   (q_oc_iptr_tmp\=i=\ == w_pt_kid[XTA-1:0])) |
			     (t_co_fdone & (q_oc_iptr[\=i=\] == w_co_oid)) |
                             // This can be released once the last read request goes to the od. Write condition comes from immitation of adone
			     (~q_oc_write[\=i=\] & n_odr_valid & t_odr_ready & n_odr_obv[q_oc_iptr[\=i=\]]) ))) ? \=OCA=\'d\=i=\ :
								   q_oc_iptr[\=i=\];

assign q_oc_iptr_eq_next[\=i=\] = (t_oc_alloc[\=i=\] & (| t_oc_ihit)) ? 1'b0 :
                         t_oc_alloc[\=i=\] ? 1'b1 :
                        (t_oc_valloc[\=i=\] & ~w_c2_flush) |
                        (t_oc_valloc[\=i=\] &
                         t_co_fdone & (t_oc_ehid == w_co_oid)) ? 1'b1 :
                         t_oc_valloc[\=i=\] ? (w_oc_ehit ? 1'b0 : 1'b1) :
                         (q_oc_val[\=i=\] & (
                           ((~t_cfg_dhit & t_oc_dve[\=i=\]) ?
                                          ~t_oc_wfack[q_oc_iptr[\=i=\]] :
                                          ~q_oc_wfa[q_oc_iptr[\=i=\]] |
                                          (t_srd_adone & t_srd_ihead &
                                           (q_oc_iptr[\=i=\] == w_srd_oid)) |
                                          (w_c2_done & w_pt_wake &
                                           ~q_oc_write[\=i=\] &
                                           (q_oc_iptr_tmp\=i=\ == w_pt_kid[XTA-1:0])) |
                             (t_co_fdone & (q_oc_iptr[\=i=\] == w_co_oid)) |
                             // This can be released once the last read request goes to the od. Write condition comes from immitation of adone
                             (~q_oc_write[\=i=\] & n_odr_valid & t_odr_ready & n_odr_obv[q_oc_iptr[\=i=\]]) ))) ? 1'b1:
                                                                   q_oc_iptr_eq[\=i=\];

assign q_oc_wfa_next[\=i=\] =  t_oc_alloc[\=i=\] ? ~w_c2_done | w_pt_write | t_pt_csr :
          	       t_oc_valloc[\=i=\] ? 1'b1 :
		       ((w_upd_req_obv[\=i=\] & w_upd_req0_ready & ~t_oc_wrbk[\=i=\]) |
			(q_oc_write[\=i=\] & ~q_oc_wfresp[\=i=\] & ~q_oc_wfstr[\=i=\] & 
					 ~t_oc_wfcwd[\=i=\] &
					 ~q_oc_wfdtr[\=i=\] & ~q_oc_wfdtw[\=i=\] & 
					 (~w_sod_valid | (!w_sod_oid_bv[\=i=\])) &
					 ~q_oc_wfadw[\=i=\] & ~q_oc_wfdtp[\=i=\] &
					 (~q_oc_wfstp[\=i=\] |
\js if (isDvmAgent||axiParams.wCdData) {
                                                           1'b1) &
\js } else {
                                                           1'b0) &
\js }
					 (q_oc_iptr_eq[\=i=\]) &
					 (~(q_oc_val[\=i=\] & q_oc_status[\=i=\][7]) | q_oc_eob[\=i=\] | 
					   q_oc_chain_complete\=i=\ | t_cfg_echain) &
				 (~q_oc_eob[\=i=\] | (n_pw0_ready & w_pw0_obv[\=i=\])))|
			(t_srd_adone & t_srd_ihead & (w_srd_oid == \=OCA=\'d\=i=\) &
					~q_oc_write[\=i=\]) |
			(w_c2_done & w_pt_wake & w_pt_kid_oh[\=i=\] & 
				     ~q_oc_write[\=i=\]) |
			(n_odr_adone & n_odr_obv[\=i=\])) ? 1'b0 :
							q_oc_wfa[\=i=\];

assign q_oc_wfstr_next[\=i=\] = t_oc_alloc[\=i=\] ? ~w_c2_done & ~t_pt_csr & ~t_pt_err &
                                         ~(t_pt_WriteNoSnoop & ~t_pt_partial & w_amc_nc & w_pt_cache[3] & w_c2_room) &
					 ~t_pt_evict &
					 ~(t_pt_dve & t_dve_state) :
			 (t_oc_catope[\=i=\] |
			  (t_oc_update[\=i=\] & q_oc_write[\=i=\] & ~w_c2_chit & ~(t_pt_WriteNoSnoop & ~t_pt_partial & w_amc_nc & w_pt_cache[3] & w_c2_room) &
					       ~t_pt_err & ~t_pt_evict)) ? 1'b1:
			 t_oc_valloc[\=i=\] ? w_c2_flush :
			 (t_oc_coal[\=i=\] |
                          (t_oc_update[\=i=\] & q_oc_write[\=i=\] & ~w_c2_chit & t_pt_WriteNoSnoop & ~t_pt_partial & w_amc_nc & w_pt_cache[3] & w_c2_room) |
			  (w_c2_done & w_pt_wake & w_pt_kid_oh[\=i=\]) | 
			  (t_oc_update[\=i=\] & q_oc_write[\=i=\] & w_c2_chit) |
			  (t_oc_update[\=i=\] & t_pt_err) |
			  (w_str_req_valid & (w_str_req_rid_bv[\=i=\]))) ? 1'b0 :
							    q_oc_wfstr[\=i=\];

assign q_oc_valid_in[\=i=\] = (t_oc_alloc[\=i=\] | t_oc_valloc[\=i=\]) ? 1'b1 : 
			       ((t_oc_edealloc[\=i=\] & (w_oc_edbv0[\=i=\] |
						     w_oc_edbv1[\=i=\])) |
				(t_oc_rdealloc[\=i=\] & (w_oc_rdbv0[\=i=\] & 
						     w_oc_rdec)) | 
			        (t_oc_wdealloc[\=i=\] & (w_oc_wdbv0[\=i=\] & 
						     (~w_oc_rdec & w_oc_wdec)))) ? 1'b0 :
								    q_oc_val[\=i=\];

  \=u.dffre(1, `q_oc_val`+i, `q_oc_valid_in[`+i+`]`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
  \=u.dffre(1, `q_oc_val_lat`+i, `q_oc_val`+i, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\

assign q_oc_err_in[\=i=\] = (t_oc_alloc[\=i=\] | t_oc_valloc[\=i=\]) ? t_pt_err : q_oc_err[\=i=\];

  \=u.dffre(1, `q_oc_err`+i, `q_oc_err_in[`+i+`]`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_ext_ns[\=i=\] = (t_oc_alloc[\=i=\]|t_oc_update[\=i=\]) ? ((t_pt_WriteNoSnoop & ~t_pt_partial & w_amc_nc & w_pt_cache[3] & ~w_c2_room) & n_cmd_req0_valid) : q_oc_ext[\=i=\] ;
  \=u.dffre(1, `q_oc_ext`+i, `q_oc_ext_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_rdone_ns[\=i=\] = (t_oc_alloc[\=i=\]) ? 1'b0 : (q_oc_rdone[\=i=\]) ? 1'b1 : t_oc_rdone[\=i=\] ;
  \=u.dffre(1, `q_oc_rdone`+i, `q_oc_rdone_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_wfstr_at_iptr_ns[\=i=\] = t_oc_alloc[\=i=\] ? 1'b1 : q_oc_wfstr_next[q_oc_iptr[\=i=\]] ;
  \=u.dffre(1, `q_oc_wfstr_at_iptr`+i, `q_oc_wfstr_at_iptr_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  \=u.dffre(1, `q_oc_iptr_eq`+i, `q_oc_iptr_eq_next[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
  assign q_poc_obv_ns[\=i=\] = q_oc_val[\=i=\] & q_oc_wake[\=i=\] & n_poc_valid & w_poc_ready & (n_poc_obv[\=i=\]);
  \=u.dffre(1, `q_poc_obv`+i, `q_poc_obv_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_wake[\=i=\] = q_oc_wake_pre[\=i=\] & ~q_poc_obv[\=i=\];

  assign q_oc_wake_ns[\=i=\] = t_oc_alloc[\=i=\] ? 1'b0 :
                              (t_oc_alloc[\=i=\] | t_oc_valloc[\=i=\] | (w_upd_req_obv[\=i=\] & w_upd_req0_ready) | (q_poc_obv[\=i=\])) ? 1'b0 :
\jsbegin
// No owo on 3.7.0
                                  if (owo) { \jsend
                              \js // No need to wake up anymore once writeback has been sent. 
                              \js // But shouldent wake go low like any other normal writeback?
                              (q_oc_val[\=i=\] & q_oc_write[\=i=\] & t_oc_coh[\=i=\] & (t_oc_phase[\=i=\] == 2'd1)) ? 1'b0 :
                              \js}
			      (((q_oc_val[\=i=\] & ~t_oc_dealloc[\=i=\] & (q_oc_iptr[\=i=\]==\=OCA=\'d\=i=\) & (q_oc_write[\=i=\] ? q_oc_wfstp[\=i=\] : 1'b1) & t_oc_chit[\=i=\] & (q_oc_aptr[\=i=\] == \=OCA=\'d\=i=\)) |
			        (q_oc_val[\=i=\] & ~t_oc_dealloc[\=i=\] & t_oc_skid[\=i=\] & t_oc_kok_in[\=i=\]) |
				 t_oc_catope[\=i=\] |
				(q_oc_val[\=i=\] & ~t_oc_dealloc[\=i=\] & ~q_oc_wfstp[q_oc_aptr[\=i=\]] & ~t_oc_wfcwd[q_oc_aptr[\=i=\]] & (~t_oc_evict[q_oc_aptr[\=i=\]] | ~q_oc_wfresp[q_oc_aptr[\=i=\]]) & (q_oc_aptr[\=i=\] != \=OCA=\'d\=i=\)))) ? 1'b1 :
				q_oc_wake[\=i=\];
				
  \=u.dffre(1, `q_oc_wake_pre`+i, `q_oc_wake_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_wake_persist_alt_ns[\=i=\] = t_oc_alloc[\=i=\] ? 1'b0 & w_c2_retry & ~t_c2_cancel :(t_oc_alloc[\=i=\] | t_oc_valloc[\=i=\] |(w_upd_req_obv[\=i=\] & w_upd_req0_ready) | (w_pt_wake & w_pt_kid_oh[\=i=\] & n_cmd_req0_valid) ) ? 1'b0 : (((q_oc_val[\=i=\] & (q_oc_iptr[\=i=\]==\=OCA=\'d\=i=\) &(q_oc_write[\=i=\] ? q_oc_wfstp[\=i=\] : 1'b1) &t_oc_chit[\=i=\] & (q_oc_aptr[\=i=\] == \=OCA=\'d\=i=\)) |(q_oc_val[\=i=\] & t_oc_skid[\=i=\] & t_oc_kok_in[\=i=\]) | t_oc_catope[\=i=\] | (q_oc_val[\=i=\] & ~q_oc_wfstp[q_oc_aptr[\=i=\]] &~t_oc_wfcwd[q_oc_aptr[\=i=\]] &(~t_oc_evict[q_oc_aptr[\=i=\]] | ~q_oc_wfresp[q_oc_aptr[\=i=\]]) &(q_oc_aptr[\=i=\] != \=OCA=\'d\=i=\)))) ? 1'b1 :q_oc_wake_persist_alt[\=i=\] ;
  \=u.dffre(1, `q_oc_wake_persist_alt`+i, `q_oc_wake_persist_alt_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

\js if (!owo) {
 assign q_oc_wake_persist_ns[\=i=\] = ( t_oc_alloc[\=i=\] | 
                                        t_oc_valloc[\=i=\] |
                                       (w_upd_req_obv[\=i=\] & w_upd_req0_ready) ) ? 1'b0 : 
                                    (((q_oc_val[\=i=\] & (q_oc_iptr[\=i=\]==\=OCA=\'d\=i=\) &(q_oc_write[\=i=\] ? q_oc_wfstp[\=i=\] : 1'b1) &t_oc_chit[\=i=\] & (q_oc_aptr[\=i=\] == \=OCA=\'d\=i=\)) |
                                      (q_oc_val[\=i=\] & t_oc_skid[\=i=\] & t_oc_kok_in[\=i=\]) | 
                                       t_oc_catope[\=i=\] | 
                                      (q_oc_val[\=i=\] & ~q_oc_wfstp[q_oc_aptr[\=i=\]] &~t_oc_wfcwd[q_oc_aptr[\=i=\]] &(~t_oc_evict[q_oc_aptr[\=i=\]] | ~q_oc_wfresp[q_oc_aptr[\=i=\]]) &(q_oc_aptr[\=i=\] != \=OCA=\'d\=i=\)))) ? 1'b1 :
                                      (w_pt_wake_last & w_pt_kid_oh_last[\=i=\] & n_cmd_req0_valid_last) ? 1'b0 :
                                       q_oc_wake_persist[\=i=\] ;
\js } else {
 assign q_oc_wake_persist_ns[\=i=\] = ((q_oc_val[\=i=\] & t_oc_skid[\=i=\] & t_oc_kok_in[\=i=\]) |
                                       t_oc_catope[\=i=\]) ? 1'b1 :
                                      (t_oc_alloc[\=i=\] |
                                       (w_pt_wake_last & w_pt_kid_oh_last[\=i=\] & n_cmd_req0_valid_last)) ? 1'b0 :
                                      q_oc_wake_persist[\=i=\] ;
\js }
  \=u.dffre(1, `q_oc_wake_persist_pre`+i, `q_oc_wake_persist_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_wake_persist_pre[\=i=\] = q_oc_wake_persist_pre\=i=\;
  assign q_oc_wake_persist[\=i=\] = q_oc_wake_persist_pre\=i=\ & ~(w_pt_wake_last & w_pt_kid_oh_last[\=i=\] & n_cmd_req0_valid_last);

  assign q_oc_wfresp_ns[\=i=\] = t_oc_alloc[\=i=\] ? ~t_pt_csr & ~(t_pt_err & ~w_c2_retry) & ~t_pt_evict & (~(w_amc_nc & t_pt_WriteNoSnoop & ~t_pt_partial & w_pt_cache[3] & ~(w_c2_chit & t_c2_lookup) & w_c2_room & ~w_c2_retry) | t_c2_cancel) : 
                                (t_oc_update[\=i=\] & ((t_pt_err & ~w_c2_retry) | (w_amc_nc & t_pt_WriteNoSnoop & ~t_pt_partial & w_pt_cache[3] & ~(w_c2_chit & t_c2_lookup) & w_c2_room & ~w_c2_retry & ~t_c2_cancel)) & ~n_rpt_valid) ? 1'b0 : 
                                (t_oc_update[\=i=\] & (generated_cmo|generated_writeback)) ? 1'b1 :
                                (t_oc_catope[\=i=\] |(w_upd_req_obv[\=i=\] & w_upd_req0_ready & (~cfg_update_i & (dce_mru | 1'b\=ACE=\)))) ? 1'b1 :
                                 t_oc_valloc[\=i=\] ? w_c2_flush :
                                (t_oc_coal[\=i=\] |
                                    (t_oc_update[\=i=\] & q_oc_write[\=i=\] & w_c2_chit & t_pt_WriteNoSnoop & ~t_pt_partial & w_amc_nc & ~w_c2_retry & ~t_c2_cancel & ~t_c2_lookup & w_c2_room) |
                                    (t_oc_chit[\=i=\] & q_oc_write[\=i=\] &n_wq_ready & (w_wq_oid == \=OCA=\'d\=i=\)) |
                                    (w_dtv_obv[\=i=\] & n_dtv_ready & ~q_oc_wfdtr[\=i=\]) | 
                                    (w_cmd_rsp_valid & (w_cmd_rsp_mid==\=OCA=\'d\=i=\)) |(w_upd_rsp_valid & (w_upd_rsp_mid==\=OCA=\'d\=i=\))) ? 1'b0 : q_oc_wfresp[\=i=\] ;

  \=u.dffre(1, `q_oc_wfresp`+i, `q_oc_wfresp_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  \=u.dffre(1, `q_oc_wfstr`+i, `q_oc_wfstr_next[`+i+`] `, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  \=u.dffre(1, `q_oc_wfadw`+i, `1'b0 `, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
  assign q_oc_wfcmp_rsp_ns[\=i=\] = t_oc_alloc[\=i=\] ? t_pt_dve & ~t_dve_state & (w_pt_addr[14:12]==3'b100) :
\js if (ACE) {
                                                                                                           (t_cro_valid & (w_crq_oid==\=OCA=\'d\=i=\))
\js } else { // STE
                                                                                                           (1'b0                                     )
\js } // STE
                                                                                                                                                       ? 1'b0 : q_oc_wfcmp[\=i=\];
  \=u.dffre(1, `q_oc_wfcmp`+i, `q_oc_wfcmp_rsp_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_cmo_ns[\=i=\] =  t_oc_alloc[\=i=\] ? w_pt_cmo : q_oc_cmo[\=i=\];
  \=u.dffre(1, `q_oc_cmo`+i, `q_oc_cmo_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_wfdtr_ns[\=i=\] = ((t_oc_update[\=i=\] & q_oc_write[\=i=\]) |t_oc_alloc[\=i=\]) ? ~t_pt_cmo & ~t_pt_csr & ~t_pt_err &~(t_pt_WriteNoSnoop & (t_pt_partial | ~w_pt_cache[3]) & w_amc_nc) &~(t_pt_dve & t_dve_state) & (~w_pt_write |(w_c2_room & ~w_c2_chit)):(t_oc_valloc[\=i=\] & w_c2_flush) |(n_odf_valid & w_odf_ready & n_odf_last &(| (t_oc_atop[\=i=\] & 6'h20)) & n_odf_oid_bv[\=i=\]) ? 1'b1 : (t_oc_coal[\=i=\] | t_oc_valloc[\=i=\] |(t_oc_update[\=i=\] & t_pt_err) |(w_str_req_valid & (w_str_req_rid_bv[\=i=\]) & w_str_req_status[7]) |(w_cm0_valid & w_cm0_mid==\=concParams.hdrParams.wMsgId=\'d\=i=\ & ~q_oc_addr[\=i=\][15]) | (w_cmp_rsp_valid & (w_cmp_rsp_mid[\=wOCN-1=\:0]==\=wOCN=\'d\=i=\) & n_cmp_rsp_ready) | (t_oc_dve_sync[\=i=\] & (w_dtw_rsp_valid & ~w_dtw_rsp_mid[\=Math.max(OCA, STA)=\] & (w_dtw_rsp_mid[OCA-1:0]==\=OCA=\'d\=i=\)) ) | (t_co_fdone & w_co_obv[\=i=\]) |(n_fkm_ready & w_fkm_obv[\=i=\] & w_fkm_last) |(n_dtr_req_rx_ready &t_srd_dtr & (w_srd_oid==\=OCA=\'d\=i=\) & w_dtr_req_rx_last)) ? 1'b0 :q_oc_wfdtr[\=i=\] ;
  \=u.dffre(1, `q_oc_wfdtr`+i, `q_oc_wfdtr_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_wfdtw_ns[\=i=\] = ((w_pt_valid & w_pt_wake & w_pt_kid_oh[\=i=\] & ~t_pt_dve) | t_oc_alloc[\=i=\]) ?
                                                                                           ((t_pt_dve & ~t_dve_state &~w_pt_addr[0]) |
											    (t_pt_dve & t_dve_state) |
											    (w_pt_write & t_pt_WriteNoSnoop & (t_pt_partial | ~w_pt_cache[3]) & w_amc_nc & ~w_c2_chit) |
											    (w_pt_write & ~w_c2_room & ~w_c2_chit & ~t_pt_err &~t_pt_evict &~t_pt_csr & ~t_pt_stash_once)) & ~t_pt_err :
				t_oc_valloc[\=i=\] ? w_c2_flush :
				((t_oc_update[\=i=\] & t_pt_err) | (w_str_req_valid & (w_str_req_rid_bv[\=i=\]) & w_str_req_status[7]) | (n_dtv_obv[\=i=\] & w_dtv_ready) | (n_odf_valid & w_odf_ready & n_odf_last & n_odf_oid_bv[\=i=\])) ? 1'b0 : q_oc_wfdtw[\=i=\] ;
				
  \=u.dffre(1, `q_oc_wfdtw`+i, `q_oc_wfdtw_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_wfdtp_ns[\=i=\] = (t_oc_alloc[\=i=\] & t_pt_dve) ? 1'b1 : q_oc_dve_2nd[\=i=\] ? q_oc_wfdtp[q_oc_iptr[\=i=\]]: (t_oc_alloc[\=i=\] | t_oc_valloc[\=i=\] | (w_dtr_rsp_rx_valid_mod & w_dtr_rsp_rx_mid[\=Math.max(OCA, STA)=\] & (w_dtr_rsp_rx_mid[OCA-1:0]==\=OCA=\'d\=i=\)) | (w_dtw_rsp_valid & ~w_dtw_rsp_mid[\=Math.max(OCA, STA)=\] & (w_dtw_rsp_mid[OCA-1:0]==\=OCA=\'d\=i=\))) ? 1'b0 : (q_oc_wfdtw[\=i=\] & ((n_odf_valid & w_odf_ready & n_odf_last & n_odf_oid_bv[\=i=\]))) ? 1'b1 : q_oc_wfdtp[\=i=\];
  \=u.dffre(1, `q_oc_wfdtp`+i, `q_oc_wfdtp_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign t_oc_dtp_received[\=i=\] = w_dtw_rsp_valid & ~w_dtw_rsp_mid[\=Math.max(OCA, STA)=\] & (w_dtw_rsp_mid[OCA-1:0]==\=OCA=\'d\=i=\);

  assign q_oc_wfstp_ns[\=i=\] = t_oc_alloc[\=i=\] ? ~w_c2_done & ~t_pt_csr & ~t_pt_err &~t_pt_evict &~(t_pt_dve & t_dve_state) :
\jsbegin
// No owo on 3.7.0
                                    if (owo) { \jsend
                                (t_oc_update[\=i=\] & generated_cmo & ~t_pt_err) ? 1'b1 :
                                \js // Need to reassert for the second STRReq in OWO Write Flow
                                  (q_oc_val[\=i=\] & (t_oc_phase[\=i=\] != 0) & q_oc_wfstr[\=i=\] & q_oc_write[\=i=\] & t_oc_coh[\=i=\]) ? 1'b1 :
				\js }
                                t_oc_valloc[\=i=\] ? w_c2_flush :
                               (t_oc_wfatop[\=i=\] & n_ocp_ready & w_ocp_obv[\=i=\]) ? 1'b1 :
                               (t_oc_coal[\=i=\] | (t_oc_update[\=i=\] & t_pt_err) |(w_c2_done & w_pt_wake & w_pt_kid_oh[\=i=\]) |(w_ocp_obv[\=i=\] & n_ocp_ready)) ? 1'b0 :
                                q_oc_wfstp[\=i=\] ;

  \=u.dffre(1, `q_oc_wfstp`+i, `q_oc_wfstp_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  \=u.dffre(1, `q_oc_wfa`+i, `q_oc_wfa_next[`+i+`] `, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_wfodr_ns[\=i=\] = ((w_wq_valid & (w_wq_oid==\=OCA=\'d\=i=\)) |(n_odr_valid & n_odr_obv[\=i=\])) ? 1'b1 :((n_odw_ready & w_odw_valid &w_odw_last & (w_odw_oid==\=OCA=\'d\=i=\)) |(n_odr_ready & w_odr_valid &w_odr_last & (w_odr_oid==\=OCA=\'d\=i=\))) ? 1'b0 :q_oc_wfodr[\=i=\] ;
  \=u.dffre(1, `q_oc_wfodr`+i, `q_oc_wfodr_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_bid_ns[\=i=\] = (w_str_req_valid & (w_str_req_rid_bv[\=i=\])) ? w_str_req_bid : q_oc_bid[\=i=\] ;
  \=u.dffre(SRCB, `q_oc_bid`+i, `q_oc_bid_ns[`+i+`]`, `{`+SRCB+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  wire [7:0] q_oc_ancestor_status\=i=\;
  wire [7:0] q_oc_ancestor_status_ns\=i=\;

  assign q_oc_ancestor_status_ns\=i=\[7:0] = t_oc_alloc[\=i=\] ? 8'b0 : (q_oc_val[\=i=\] & q_oc_write[\=i=\] & ~q_oc_iptr_eq[\=i=\] & ~q_oc_eob[q_oc_iptr[\=i=\]]) ? q_oc_status[q_oc_iptr[\=i=\]] : q_oc_ancestor_status\=i=\;
  \=u.dffre(8, `q_oc_ancestor_status`+i, `q_oc_ancestor_status_ns`+i, `8'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
  assign q_oc_ancestor_transfer\=i=\ = q_oc_val[\=i=\] & ~q_oc_iptr_eq[\=i=\] & (|q_oc_status[q_oc_iptr[\=i=\]]) ? {1'b1,q_oc_iptr[\=i=\]} : {1'b0,\=OCA=\'b0};
 
  assign q_oc_status_update[\=i=\] = (({8{(w_str_req_valid & w_str_req_status[7] &  (w_str_req_rid_bv[\=i=\]))}}& w_str_req_status) |
				    ({8{(w_dtr_req_rx_valid & w_dtr_req_rx_status[7] &  (w_dtr_req_rx_rid==\=concParams.dtrReqParams.wMsgId=\'d\=i=\))}}& w_dtr_req_rx_status) |
				    ({8{(w_cm0_valid & w_cm0_status[7] & ((w_cm0_mid[\=wOCN-1=\:0]==\=wOCN=\'d\=i=\) | (q_oc_val[\=i=\] & q_oc_partial[\=i=\] &(w_cm0_mid[\=wOCN-1=\:0]==q_oc_iptr[\=i=\][\=wOCN-1=\:0]))))} }& w_cm0_status & 8'hfb) |
				    ({8{(w_cmd_rsp_valid & w_cmd_rsp_status[7] &  (w_cmd_rsp_mid==\=OCA=\'d\=i=\))}}& w_cmd_rsp_status) |
				    ({8{(w_upd_rsp_valid & w_upd_rsp_status[7] &  (w_upd_rsp_mid==\=OCA=\'d\=i=\))}}& w_upd_rsp_status) |
				    ({8{(w_dtr_rsp_rx_valid_mod & w_dtr_rsp_rx_status[7] &   w_dtr_rsp_rx_mid[\=Math.max(OCA, STA)=\] & (w_dtr_rsp_rx_mid[OCA-1:0]==\=OCA=\'d\=i=\))}} & w_dtr_rsp_rx_status) |
				    ({8{(w_dtw_rsp_valid & w_dtw_rsp_status[7] &  ~w_dtw_rsp_mid[\=Math.max(OCA, STA)=\] & (w_dtw_rsp_mid==\=concParams.hdrParams.wMsgId=\'d\=i=\))}} & w_dtw_rsp_status) |
				    q_oc_ancestor_status\=i=\);
  assign q_oc_status_next[\=i=\] =    (t_oc_alloc[\=i=\] | t_oc_valloc[\=i=\])      ? {t_pt_err, ((t_pt_uerr) ? 7'h4 :t_pt_err ? 7'h3 :7'h0)}:
                                   (t_oc_update[\=i=\] & ~q_oc_status[\=i=\][7] & ~q_oc_status_update[\=i=\][7]) ? {t_pt_err, ((t_pt_uerr) ? 7'h4 :t_pt_err ? 7'h3 :7'h0)}:
                                   (q_oc_val[\=i=\] & q_oc_status[\=i=\][7] & ((q_oc_status_update[\=i=\] == 8'h84) | (q_oc_status_update[\=i=\] == 8'h87)) ) ? 8'h84          :
                                   (q_oc_val[\=i=\] & q_oc_status[\=i=\][7]                                 ) ? q_oc_status[\=i=\] :
				    q_oc_status_update[\=i=\];

  \=u.dffre(8, `q_oc_status`+i, `q_oc_status_next[`+i+`]`, `{8{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

 assign q_oc_null_ns[\=i=\] = t_oc_alloc[\=i=\] ? 1'b0 : ((w_str_req_valid & (w_str_req_rid_bv[\=i=\]) & w_str_req_status[7]) |
                                                          (w_dtw_rsp_valid & (~w_dtw_rsp_mid[\=Math.max(OCA, STA)=\] & (w_dtw_rsp_mid[OCA-1:0]==\=OCA=\'d\=i=\)) & t_oc_atop[w_dtw_rsp_mid[OCA-1:0]][5] & w_dtw_rsp_status[7])) ? 1'b1 : q_oc_null[\=i=\];
  \=u.dffre(1, `q_oc_null`+i, `q_oc_null_ns[`+i+`]`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_write_ns[\=i=\] = t_oc_alloc[\=i=\] ? w_pt_write : t_oc_valloc[\=i=\] ? 1'b0 : q_oc_write[\=i=\] ;
  \=u.dffre(1, `q_oc_write`+i, `q_oc_write_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_size_ns[\=i=\] = t_oc_alloc[\=i=\] ? w_pt_size : t_oc_valloc[\=i=\] ? {1'b0,cmd_req_isize_o} : q_oc_size[\=i=\] ;
  \=u.dffre(3, `q_oc_size`+i, `q_oc_size_ns[`+i+`]`, `{3{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_beats_ns[\=i=\] = (t_oc_alloc[\=i=\]
\jsbegin
// No owo on 3.7.0
    if (owo) { \jsend
                                                  |(t_oc_update[\=i=\] & generated_writeback & command_sent)
\js }
                                                                                                            )  ? n_owo_beats[BWL-1:0] :
                                t_oc_valloc[\=i=\] ? {BWL{1'b0}} :
                              ((t_oc_atop[\=i=\] == 6'h31) & (| (q_oc_beats[\=i=\]>>1)) & ((w_str_req_valid & (w_str_req_rid_bv[\=i=\]) & w_str_req_status[7]) | (n_dtw_req0_valid & w_dtw_req0_ready & n_dtw_req0_last & (w_of_oid == \=OCA=\'d\=i=\)))) ? (q_oc_beats[\=i=\]>>1) :
                                q_oc_beats[\=i=\] ;

  \=u.dffre(BWL, `q_oc_beats`+i, `q_oc_beats_ns[`+i+`]`, `{`+BWL+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

\js // var    64    128    256
\js // CLO     6      6      6
\js // AWL     3      4      5
\js // BWL     3      2      1

\jsbegin
// Would only happen for 16 bit bus or smaller
/* istanbul ignore if env ncore_3p7 */
    if (BWL==5) { \jsend
  assign q_oc_beats_adj[\=i=\][4:0] = q_oc_beats[\=i=\];
\js } else {
  assign q_oc_beats_adj[\=i=\][4:0] = {\=5-BWL=\'b0,q_oc_beats[\=i=\]};
\js }

  assign q_oc_nc_ns[\=i=\] = t_oc_alloc[\=i=\] ? ((CACHE>0) & ((n_cmd_req0_cmd==ReadNonCoherent) | (n_cmd_req0_cmd==WriteNonCohPtl) | (n_cmd_req0_cmd==WriteNonCohFull)) & w_amc_nc & (|w_pt_cache[3:2])) : q_oc_nc[\=i=\] ;
  \=u.dffre(1, `q_oc_nc`+i, `q_oc_nc_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_eob_ns[\=i=\] = t_oc_alloc[\=i=\] ? n_oc_eob : t_oc_valloc[\=i=\] ? 1'b1 : q_oc_eob[\=i=\] ;
  \=u.dffre(1, `q_oc_eob`+i, `q_oc_eob_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_addr_ns[\=i=\] = t_oc_alloc[\=i=\] ? w_pt_addr :(t_oc_valloc[\=i=\] & w_pt_cmr[1] &~w_pt_write) ? w_pt_addr :t_oc_valloc[\=i=\] ? cp2_eaddr_i :(w_str_req_valid & (w_str_req_rid_bv[\=i=\]) &q_oc_val[w_str_req_rid] & q_oc_write[w_str_req_rid] &(t_oc_snoop[w_str_req_rid]==4'h9) &w_str_req_status[0]) ? q_oc_addr[\=i=\] & t_str_req_mask :q_oc_addr[\=i=\] ;
  \=u.dffre(AW, `q_oc_addr`+i, `q_oc_addr_ns[`+i+`]`, `{`+AW+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_cache_ns[\=i=\] = t_oc_alloc[\=i=\] ? w_pt_cache : t_oc_valloc[\=i=\] ? 4'h0 : t_oc_catope[\=i=\] ? q_oc_cache[\=i=\] & 4'h3 : q_oc_cache[\=i=\] ;
  \=u.dffre(4, `q_oc_cache`+i, `q_oc_cache_ns[`+i+`]`, `{4{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_qos_ns[\=i=\] = t_oc_alloc[\=i=\] ? w_pt_qos : t_oc_valloc[\=i=\] ? (cfg_useEvQos_i ? cfg_evQos_i[QW-1:0] : w_pt_qos) : q_oc_qos[\=i=\] ;
  \=u.dffre(QW, `q_oc_qos`+i, `q_oc_qos_ns[`+i+`]`, `{`+QW+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_security_ns[\=i=\] = t_oc_alloc[\=i=\] ? w_pt_security : (t_oc_valloc[\=i=\] & w_pt_cmr[1] & ~w_pt_write) ? w_pt_security : t_oc_valloc[\=i=\] ? cp2_esecurity_i : q_oc_security[\=i=\] ;
  \=u.dffre(1, `q_oc_security`+i, `q_oc_security_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_pr_ns[\=i=\] = t_oc_alloc[\=i=\] ? w_pt_pr : q_oc_pr[\=i=\] ;
  \=u.dffre(1, `q_oc_pr`+i, `q_oc_pr_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_lock_ns[\=i=\] = t_oc_alloc[\=i=\] ? w_pt_lock :(q_oc_lock[\=i=\] & ~q_oc_write[\=i=\] &((t_oc_domain[\=i=\]==2'h0) | (t_oc_domain[\=i=\]==2'h3)) &(t_oc_snoop[\=i=\]==4'h0) &w_dtr_req_rx_valid & (w_srd_oid==\=OCA=\'d\=i=\)) ? w_dtr_req_rx_status[0] : (q_oc_lock[\=i=\] & q_oc_write[\=i=\] &((t_oc_domain[\=i=\]==2'h0) | (t_oc_domain[\=i=\]==2'h3)) &(t_oc_snoop[\=i=\]==4'h0) &w_dtw_rsp_valid & ~w_dtw_rsp_mid[\=Math.max(OCA, STA)=\] &(w_dtw_rsp_mid==\=concParams.hdrParams.wMsgId=\'d\=i=\)) ? w_dtw_rsp_status[0] : (q_oc_lock[\=i=\] &~(((t_oc_domain[\=i=\]==2'h0) | (t_oc_domain[\=i=\]==2'h3)) &(t_oc_snoop[\=i=\]==4'h0)) &w_str_req_valid & (w_str_req_rid_bv[\=i=\])) ? w_str_req_status[0] :q_oc_lock[\=i=\] ;
  \=u.dffre(1, `q_oc_lock`+i, `q_oc_lock_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_user_ns[\=i=\] = t_oc_alloc[\=i=\] ? w_pt_user : t_oc_valloc[\=i=\] ? {AXUW{1'b0}} : q_oc_user[\=i=\] ;
  \=u.dffre(AXUW, `q_oc_user`+i, `q_oc_user_ns[`+i+`]`, `{`+AXUW+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_wrap_ns[\=i=\] = (t_oc_alloc[\=i=\] & t_pt_dve) ? ~t_dve_state :t_oc_alloc[\=i=\] ? (w_pt_burst==2'h2) :t_oc_valloc[\=i=\] ? w_c2_flush :((n_ppvc_obv[\=i=\] & w_ppvc_ready)) ? 1'b0 : q_oc_wrap[\=i=\] ;
  \=u.dffre(1, `q_oc_wrap`+i, `q_oc_wrap_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_dve_2nd_ns[\=i=\] = t_oc_alloc[\=i=\] ? (t_pt_dve & t_dve_state) ? 1'b1 : 1'b0 : q_oc_dve_2nd[\=i=\] ;
  \=u.dffre(1, `q_oc_dve_2nd`+i, `q_oc_dve_2nd_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_line_ns[\=i=\] = t_oc_alloc[\=i=\] ? (n_cmd_req0_size == 6) : t_oc_valloc[\=i=\] ? 1'b1 : (w_upd_req_obv[\=i=\] & w_upd_req0_ready & t_oc_wrbk[\=i=\]) ? 1'b0 : q_oc_line[\=i=\] ;
  \=u.dffre(1, `q_oc_line`+i, `q_oc_line_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_id_ns[\=i=\] = (t_oc_alloc[\=i=\] | t_oc_valloc[\=i=\]) ? w_pt_id : q_oc_id[\=i=\] ;
  \=u.dffre(IW, `q_oc_id`+i, `q_oc_id_ns[`+i+`]`, `{`+IW+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_mid_ns[\=i=\] = (w_str_req_valid & (w_str_req_rid_bv[\=i=\])) ? w_str_req_mid : (w_ocp_obv[\=i=\] & n_ocp_ready & t_oc_wfatop[\=i=\]) ? t_oc_mid2[\=i=\] : q_oc_mid[\=i=\] ;
  \=u.dffre(SRCM, `q_oc_mid`+i, `q_oc_mid_ns[`+i+`]`, `{`+SRCM+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_iid_ns[\=i=\] = (w_str_req_valid & (w_str_req_rid_bv[\=i=\])) ? w_str_req_iid : (w_ocp_obv[\=i=\] & n_ocp_ready & t_oc_wfatop[\=i=\]) ? t_oc_iid2[\=i=\] : q_oc_iid[\=i=\] ;
  \=u.dffre(SRCI, `q_oc_iid`+i, `q_oc_iid_ns[`+i+`]`, `{`+SRCI+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_dce_ns[\=i=\] = ((t_oc_alloc[\=i=\] | t_oc_update[\=i=\]) & ~t_pt_csr &t_pt_skid & t_pt_dce) ? 1'b1 :(t_oc_alloc[\=i=\] | t_oc_update[\=i=\] |(n_pvc_ready & w_pvc_valid & (w_pvc_oid==\=OCA=\'d\=i=\))) ?t_pt_dce : q_oc_dce[\=i=\] ;
  \=u.dffre(1, `q_oc_dce`+i, `q_oc_dce_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_tid_ns[\=i=\] = t_oc_alloc[\=i=\] ? n_cmd_req0_tid : 	q_oc_tid[\=i=\];
  \=u.dffre(MRCT, `q_oc_tid`+i, `q_oc_tid_ns[`+i+`]`, `{MRCT{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

\js // assign t_pt_skid = ~t_pt_ok & (~| t_oc_ahit) & ~t_pt_dvm &
\js //                    ~(t_pt_dve & ~w_pt_wake & t_dve_state);

  assign q_oc_tin_ns[\=i=\] = ((t_oc_alloc[\=i=\] | t_oc_update[\=i=\]) & ~t_pt_csr &t_pt_skid & t_pt_dce) ? {2'h0, w_amc_tins[0 +: TINW]} :
                              (t_oc_alloc[\=i=\] | t_oc_update[\=i=\] |(n_pvc_ready & w_pvc_valid & (w_pvc_oid==\=OCA=\'d\=i=\))) ? {(t_pt_dii | t_pt_csr | w_amc_errs[2]),
                                                                                                                                     (t_pt_dmi | t_pt_csr | w_amc_errs[2]),
                                                                                                                                     (t_pt_csr | w_amc_errs[2] ? {TINW{1'b0}} :
                                                                                                                                      t_pt_dmi ? w_amc_tins[5 +: TINW] :
                                                                                                                                                 w_amc_tins[10+: TINW])}
                                                                                                                                  :q_oc_tin[\=i=\] ;
  assign q_oc_tin_ns_alt[\=i=\] = ((t_oc_alloc[\=i=\] | t_oc_update[\=i=\]) & ~t_pt_csr            & t_pt_dce) ? {2'h0, w_amc_tins[0 +: TINW]} :(t_oc_alloc[\=i=\] | t_oc_update[\=i=\] |(n_pvc_ready & w_pvc_valid & (w_pvc_oid==\=OCA=\'d\=i=\))) ? {(t_pt_dii | t_pt_csr | w_amc_errs[2]),(t_pt_dmi | t_pt_csr | w_amc_errs[2]),(t_pt_csr | w_amc_errs[2] ? {TINW{1'b0}} :t_pt_dmi ? w_amc_tins[5 +: TINW] :w_amc_tins[10+: TINW])}:q_oc_tin[\=i=\] ;
  \=u.dffre(TINW+2, `q_oc_tin`+i, `q_oc_tin_ns[`+i+`]`, `{`+(TINW+2)+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_order_ns[\=i=\] = (t_oc_alloc[\=i=\] | t_oc_update[\=i=\] |t_oc_valloc[\=i=\]) ? w_amc_order[2:1] : q_oc_order[\=i=\] ;
  \=u.dffre(2, `q_oc_order`+i, `q_oc_order_ns[`+i+`]`, `{2{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_itail_ns[\=i=\] = (t_oc_alloc[\=i=\] | (t_oc_valloc[\=i=\] & w_c2_flush)) ? 1'b1:((t_oc_we & t_oc_ihit[\=i=\]) | t_oc_valloc[\=i=\] |(w_c2_flush & t_oc_evict[\=i=\])) ? 1'b0 :q_oc_itail[\=i=\] ;
  \=u.dffre(1, `q_oc_itail`+i, `q_oc_itail_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  \=u.dffre(OCA, `q_oc_iptr`+i, `q_oc_iptr_next[`+i+`] `, `{`+OCA+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_atail_ns[\=i=\] = t_oc_alloc[\=i=\] ? 1'b1 :t_oc_valloc[\=i=\] ? w_c2_flush :(t_oc_we & t_oc_ahit[\=i=\]) ? 1'b0 :q_oc_atail[\=i=\] ;
  \=u.dffre(1, `q_oc_atail`+i, `q_oc_atail_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_otail_ns[\=i=\] = (t_oc_alloc[\=i=\] & (| t_oc_ihit)) ? (q_oc_val[w_oc_ihid] & q_oc_otail[w_oc_ihid] & (~q_oc_wfstr[w_oc_ihid] & ~q_oc_wfresp[w_oc_ihid])) : t_oc_alloc[\=i=\] ? 1'b1 : (q_oc_val[q_oc_iptr[\=i=\]] & q_oc_otail[q_oc_iptr[\=i=\]] & (~q_oc_wfstr[q_oc_iptr[\=i=\]] & ~q_oc_wfresp[q_oc_iptr[\=i=\]])) ? 1'b1 : q_oc_otail[\=i=\] ;
  \=u.dffre(1, `q_oc_otail`+i, `q_oc_otail_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_aptr_ns[\=i=\] = ((t_oc_alloc[\=i=\] | t_oc_update[\=i=\]) & (| t_oc_ahitr)) ? w_oc_ahidr :((t_oc_alloc[\=i=\] |t_oc_update[\=i=\]) & (| t_oc_ahite)) ? w_oc_ahide :(t_oc_alloc[\=i=\] | t_oc_coal[\=i=\] | t_oc_valloc[\=i=\] | (q_oc_val[\=i=\] & ~q_oc_wfstp[q_oc_aptr[\=i=\]] &(~t_oc_evict[q_oc_aptr[\=i=\]] | ~q_oc_wfresp[q_oc_aptr[\=i=\]]) & ~t_oc_wfcwd[q_oc_aptr[\=i=\]])) ? \=OCA=\'d\=i=\ :q_oc_aptr[\=i=\] ;
  \=u.dffre(OCA, `q_oc_aptr`+i, `q_oc_aptr_ns[`+i+`]`, `{`+OCA+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_dptr_ns[\=i=\] = t_oc_alloc[\=i=\] ? n_oc_dptr :(t_oc_valloc[\=i=\] & w_c2_flush) ? t_od_eptr :q_oc_dptr[\=i=\] ;
  \=u.dffre(OLA, `q_oc_dptr`+i, `q_oc_dptr_ns[`+i+`]`, `{`+OLA+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_dval_ns[\=i=\] = t_oc_alloc[\=i=\] ? ~(~w_pt_write & w_c2_chit) &~t_pt_evict :t_oc_update[\=i=\] ? ~(~w_pt_write & w_c2_chit) &~t_pt_evict & ~(q_oc_val[\=i=\] & q_oc_status[\=i=\][7]) :t_oc_valloc[\=i=\] ? w_c2_flush :~t_oc_dval[\=i=\] ? 1'b0 :q_oc_dval[\=i=\] ;
  \=u.dffre(1, `q_oc_dval`+i, `q_oc_dval_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_partial_ns[\=i=\] = (t_oc_alloc[\=i=\] & t_pt_dve) ? t_dve_state :t_oc_alloc[\=i=\] ? t_pt_partial :t_oc_valloc[\=i=\] ? 1'b0 : q_oc_partial[\=i=\] ;
  \=u.dffre(1, `q_oc_partial`+i, `q_oc_partial_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_trace_ns[\=i=\] = (t_oc_alloc[\=i=\]) ? w_pt_trace : (t_oc_valloc[\=i=\]) ? w_pt_trace : q_oc_trace[\=i=\] ;
  \=u.dffre(1, `q_oc_trace`+i, `q_oc_trace_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

\js }

 wire [OCN-1:0]	q_oc_skid;
 wire [OCN-1:0]	q_oc_skid_ns;
 wire [OCN-1:0] q_oc_resurrect;
\js for (let i=0; i<OCN; i=i+1) {
        wire q_oc_resurrect\=i=\;
        wire q_oc_resurrect_ns\=i=\;
        assign q_oc_resurrect[\=i=\] = q_oc_resurrect\=i=\;
        assign q_oc_resurrect_ns\=i=\ = (t_oc_alloc[\=i=\]|t_oc_update[\=i=\]) ? 1'b0 : (q_oc_val[\=i=\] & (t_oc_cok[\=i=\]|t_oc_catope[\=i=\]) & t_oc_iok[\=i=\] & (
\js if (owo) {
                                          (t_oc_coh[\=i=\] & q_oc_write[\=i=\] & (t_oc_phase[\=i=\] == 2'd0) &  t_oc_owned[\=i=\] & t_oc_oldest[\=i=\] & q_oc_iptr_eq[\=i=\]) |
                                          (t_oc_coh[\=i=\] & q_oc_write[\=i=\] & (t_oc_phase[\=i=\] == 2'd0) & ~t_oc_owned[\=i=\] & t_oc_oldest[\=i=\] & ~q_oc_wfstr[\=i=\] & ~q_oc_wfstp[\=i=\] & q_oc_iptr_eq[\=i=\])|
\js }
                                          (t_oc_dok[\=i=\] & t_oc_ihead[\=i=\] & t_oc_catope[\=i=\] ))) ? 1'b1 : q_oc_resurrect[\=i=\]; 
        \=u.dffre(1, `q_oc_resurrect`+i, `q_oc_resurrect_ns`+i, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\

      \js // OWO WAKEUP ORDERING CASE
\jsbegin
// No owo on 3.7.0
          if (owo) { \jsend
        reg r_oc_iok\=i=\;
      
        wire same_dii_wake\=i=\      = t_pt_dii & q_oc_tin[q_oc_iptr[\=i=\]][TINW+1] &({w_amc_fids[2*FIDW +: FIDW],1'b0} == q_oc_tid[q_oc_iptr[\=i=\]]);
        wire differant_dii_wake\=i=\ = t_pt_dii & q_oc_tin[q_oc_iptr[\=i=\]][TINW+1] &({w_amc_fids[2*FIDW +: FIDW],1'b0} != q_oc_tid[q_oc_iptr[\=i=\]]);
	wire prior_coherent\=i=\   = t_oc_coh[q_oc_iptr[\=i=\]];
	wire both_coherent\=i=\   = t_oc_coh[\=i=\] & prior_coherent\=i=\;
        wire q_oc_waking_ns\=i=\;
        wire q_oc_waking\=i=\;

        wire qosdelta\=i=\ = q_oc_qos[\=i=\] != q_oc_qos[q_oc_iptr[\=i=\]];
        wire qiddelta\=i=\ = q_oc_id[\=i=\] != q_oc_id[q_oc_iptr[\=i=\]];

        always @ (*) begin
         casez ({q_oc_write[\=i=\], (t_oc_coh[\=i=\] & ~t_oc_owned[\=i=\] & ~t_oc_atop_persist[\=i=\] & ~t_cfg_ihit)})
       	    2'b0?: begin
	    	  r_oc_iok\=i=\ = q_oc_val[\=i=\] & ~q_oc_wfresp[q_oc_iptr[\=i=\]] & (~q_oc_wfstr[q_oc_iptr[\=i=\]] & q_oc_val[q_oc_iptr[\=i=\]] & q_oc_otail[q_oc_iptr[\=i=\]]); // This is sending the Reads so they need to be ordered. 
 	    end
	    2'b10: begin
	    	  \js // This is conservative ordering ensuring that DTWReqs would make progress in the non-coherent case.
		  \js // Based on performance feedback we can rely only on the DTWReq ordering
	    	  r_oc_iok\=i=\ =  (same_dii_wake\=i=\) ?      q_oc_val[\=i=\] & ~(q_oc_wfresp[q_oc_iptr[\=i=\]] | q_oc_wfstr[q_oc_iptr[\=i=\]] | q_oc_status[q_oc_iptr[\=i=\]][7])                     :
				   (differant_dii_wake\=i=\) ? q_oc_val[\=i=\] & ~(q_oc_wfresp[q_oc_iptr[\=i=\]] | q_oc_wfstr[q_oc_iptr[\=i=\]] | ~q_oc_otail[q_oc_iptr[\=i=\]] | q_oc_status[q_oc_iptr[\=i=\]][7]):
				   (both_coherent\=i=\)      ? q_oc_val[\=i=\] & ~(                                q_oc_status[q_oc_iptr[\=i=\]][7]) & 
                                                                                 ((t_oc_phase[q_oc_iptr[\=i=\]] != 0) | (t_oc_waking[q_oc_iptr[\=i=\]] & ~generated_writeback_retried\=i=\)) &
                                                                                 ~((q_oc_eob[q_oc_iptr[\=i=\]] & (qosdelta\=i=\ | qiddelta\=i=\)) ? q_oc_wfa[q_oc_iptr[\=i=\]] : 1'b0) :
				                               q_oc_val[\=i=\] & ~(q_oc_wfresp[q_oc_iptr[\=i=\]] | q_oc_wfstr[q_oc_iptr[\=i=\]] | q_oc_status[q_oc_iptr[\=i=\]][7]) &
										(prior_coherent\=i=\ ? (t_oc_phase[q_oc_iptr[\=i=\]] != 0) : 1'b1);
	    end
	    2'b11: begin
	    	  r_oc_iok\=i=\ = 1'b1; \js // This is sending the CMOs
	    end
	    default: begin
	    	  r_oc_iok\=i=\ = 1'b1;
	    end
         endcase
        end

        assign t_oc_iok[\=i=\] = ((cfg_rproducer_i==2'h2) & (q_oc_order[\=i=\][1]) & ~q_oc_write[\=i=\]) | (r_oc_iok\=i=\ | q_oc_iptr_eq[\=i=\]);

        wire q_oc_skid\=i=\;
        assign q_oc_skid[\=i=\] = q_oc_skid\=i=\;

        assign q_oc_wake_persist_local_ns[\=i=\] = t_oc_catope[\=i=\] ? 1'b1 :
                                                   (w_pt_wake_last & w_pt_kid_oh_last[\=i=\] & n_cmd_req0_valid_last) ? 1'b0 :
                                                   q_oc_wake_persist[\=i=\] ;

        \js // TODO: Condition to reenter skid if lose ownership
        assign q_oc_skid_ns[\=i=\] = (t_oc_alloc[\=i=\]  | t_oc_update[\=i=\]) ? t_pt_skid :                         
                                     (q_oc_val[\=i=\] & t_oc_skid[\=i=\] & t_oc_kok_in[\=i=\]) ? 1'b0 :
  				     (q_oc_val[\=i=\] & t_oc_coh[\=i=\] & q_oc_write[\=i=\] & (t_oc_phase[\=i=\] == 2'd0) & ~q_oc_wake_persist_local_ns[\=i=\] & 
                                        ((~t_oc_atop_persist[\=i=\] & t_oc_owned[\=i=\] &
                                            (q_oc_iptr_eq[\=i=\] | 
                                             (~t_oc_coh[q_oc_iptr[\=i=\]] & ~q_oc_wfstr[q_oc_iptr[\=i=\]] & t_oc_oldest[\=i=\]) | 
                                             ( t_oc_coh[q_oc_iptr[\=i=\]] & ((t_oc_phase[q_oc_iptr[\=i=\]]!=2'b0)|(t_oc_waking[q_oc_iptr[\=i=\]] & ~generated_writeback_retried\=i=\))))) |
                                         ( ~q_oc_wfstr[\=i=\] & ~q_oc_wfstp[\=i=\] & q_oc_iptr_eq[\=i=\] &
                                            ((~t_oc_owned[\=i=\] & t_oc_oldest[\=i=\]) | 
                                             (t_oc_owned[\=i=\] & ~t_oc_oldest[\=i=\] & q_oc_status[\=i=\][7]))))) ? 1'b1 :
				      q_oc_skid[\=i=\];
				   
        \=u.dffre(1, `q_oc_skid`+i, `q_oc_skid_ns[`+i+`]`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
        assign t_oc_skid[\=i=\] = q_oc_skid[\=i=\];

        assign q_oc_waking_ns\=i=\ = t_oc_update[\=i=\] ? 1'b0 : (q_oc_val\=i=\ & t_oc_coh[\=i=\] & q_oc_write[\=i=\] & (t_oc_phase[\=i=\] == 2'd0) & ~t_oc_atop_persist[\=i=\] & t_oc_owned[\=i=\] & (q_oc_iptr_eq[\=i=\] | (t_oc_coh[q_oc_iptr[\=i=\]] & ((t_oc_phase[q_oc_iptr[\=i=\]]!=2'b0)|t_oc_waking[q_oc_iptr[\=i=\]]))) & ~q_oc_wake_persist_ns[\=i=\]) ? 1'b1 : q_oc_waking\=i=\;
        \=u.dffre(1, `q_oc_waking`+i, `q_oc_waking_ns`+i, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
        assign t_oc_waking[\=i=\] = q_oc_waking\=i=\;

      \js } else {
        \js // NON OWO WAKEUP ORDERING CASE
        assign t_oc_iok[\=i=\] =
	     ((cfg_wproducer_i==2'h2) & (q_oc_order[\=i=\][2]) &  q_oc_write[\=i=\] & ~t_cfg_ihit) |
	     ((cfg_rproducer_i==2'h2) & (q_oc_order[\=i=\][1]) & ~q_oc_write[\=i=\] & ~t_cfg_ihit) |
	     //		     (q_oc_val[\=i=\] & (q_oc_iptr[\=i=\]==\=OCA=\'d\=i=\) & ~q_oc_wfstr[\=i=\]);
	     (q_oc_val[\=i=\] & ( 
                             (q_oc_iptr[\=i=\]==\=OCA=\'d\=i=\) |
                             (t_oc_dve[\=i=\] ? (~q_oc_wfdtp[q_oc_iptr[\=i=\]]) :
                              (
			        (~(q_oc_write[\=i=\] | q_oc_cmo[q_oc_iptr[\=i=\]])? (~q_oc_wfstr[q_oc_iptr[\=i=\]] | ~q_oc_wfdtr[q_oc_iptr[\=i=\]]) : ~q_oc_wfstr[q_oc_iptr[\=i=\]]) &
                                (~q_oc_wfresp[q_oc_iptr[\=i=\]] & (q_oc_val[q_oc_iptr[\=i=\]] & q_oc_otail[q_oc_iptr[\=i=\]])) 
                              )
                             )
                            )
                           );

        wire q_oc_skid\=i=\;
        assign q_oc_skid[\=i=\] = q_oc_skid\=i=\;
        assign q_oc_skid_ns[\=i=\] = (t_oc_alloc[\=i=\] | t_oc_update[\=i=\]) ? t_pt_skid : (t_oc_valloc[\=i=\] | (q_oc_val[\=i=\] & t_oc_skid[\=i=\] & t_oc_kok_in[\=i=\])) ? 1'b0 : q_oc_skid[\=i=\];
        \=u.dffre(1, `q_oc_skid`+i, `q_oc_skid_ns[`+i+`]`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
        assign t_oc_skid[\=i=\] = q_oc_skid[\=i=\];
      \js }
\js }
    assign age_grant_ack       = w_poc_ready;
    assign age_fifo_push       = t_oc_we;
    assign age_fifo_initvec    = t_oc_alloc;
    assign age_fifo_pop        = age_fifo_dealloc_valid;
    assign age_fifo_pop_index  = age_fifo_dealloc_index;
    assign age_arb_req_vec     = t_oc_wake;
    assign n_poc_oid           = age_fifo_grant_index;                         
    assign n_poc_obv           = age_arb_grant_vec;

\=u.dffre(OCN, `dealloc_collect`, `dealloc_collect_in`, `{`+OCN+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

      assign dealloc_collect_in = (dealloc_collect | t_oc_wdealloc | t_oc_rdealloc) & ~(age_fifo_dealloc_vector);

\=u.instance({
	moduleName: 'ioaiu_enc',
	instanceName: 'dealloc_sel',
	params: {
                DW:             OCN,
                BE:             0,
                clkAssertInterface : clkAssertInterface,
		assertOn: assertOn
	},
	ports: {
		bv_i:		'(dealloc_collect & ~q_oc_val)',
		valid_o:	'age_fifo_dealloc_valid',
		index_o:	'age_fifo_dealloc_index',
		bv_o:		'age_fifo_dealloc_vector'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

\jsbegin
var com_arb_params = {
        assertOn: assertOn,
        nPorts: OCN,
        wPorts: wOCN,
	usePipe: 0,
        nEntries: ageBuffEntries,
	useOnehotIndex: 0
};

var com_arb_ports = {
        clk:        'clk_i',
        reset_n:    'reset_ni',
        empty:      'age_arb_empty',
        full:       'age_arb_full',
        valid_vec:  'age_arb_valid_vec',
        push_en:    'age_fifo_push',
        pop_en:     'age_fifo_pop',
        pop_index:  'age_fifo_pop_index',
        push_index: 'age_fifo_initvec',
	grant_ack:  'age_grant_ack',
        req_vec:    'age_arb_req_vec',
        grant_vec:  'age_arb_grant_vec',
        grant_index:'age_fifo_grant_index',
	grant      : 'grant_nc'
};

\jsend

\=u.instance({
        instanceName: 'com_arb_age_buf',
        moduleName: 'com_arb_age_buf',
        params: com_arb_params,
        ports: com_arb_ports,
        portsDelimiter: '\n        '
})=\

    assign t_oc_agok = {OCN{1'b0}};
    assign t_ag_inc = 1'b0;
    assign t_ag_dec = 1'b0;
    assign t_ag_count = {OCA+1{1'b0}};

  wire		t_sv_ovt;
  wire [OCA-1:0]	t_sv_eid;

  wire [OCN-1:0]	q_oc_ovt;
  wire [31:0]	q_sv_timer;

\jsbegin
// Always 1 on 3.7
/* istanbul ignore else env ncore_3p7 */
    if (eStarve) { \jsend
    wire		t_sv_ove;
    wire		t_sv_set, t_sv_clr;

    wire [OCN-1:0]	q_oc_ove;
    wire [15:0]	        q_sv_counter;
    wire		q_sv_state;

    wire q_in_error;
    wire q_in_error_ns = |(q_oc_val & t_oc_error);
    \=u.dffre(1, `q_in_error`, `q_in_error_ns`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\

    assign t_cfg_eperiod = (| cfg_evp_i) ? cfg_evp_i : {4'b0,cfg_eperiod_i};

    assign t_sv_ove = ~t_cfg_starve & (q_sv_counter[15:0] == t_cfg_eperiod) & (| t_cfg_eperiod);

    assign t_sv_set = ~q_sv_state & (t_sv_ove & (| (q_oc_val & q_oc_ove))) & ~q_in_error;

    assign t_sv_clr = q_sv_state & ((t_cfg_starve) | (~| (q_oc_val & q_oc_ove)));

   wire [15:0] q_sv_counter_p1;
   wire q_sv_counter_carry;
   assign {q_sv_counter_carry,q_sv_counter_p1} = {1'b0,q_sv_counter} + 1'b1;
    wire [16-1:0] q_sv_counter_ns = ((q_sv_counter >= t_cfg_eperiod) | t_cfg_starve) ? 16'h0 : ((t_cfg_external ? external_i : t_oc_cmd_sent) & (| t_cfg_eperiod) & ~t_sv_starve) ? q_sv_counter_p1 : q_sv_counter;
    \=u.dffre(16, `q_sv_counter`, `q_sv_counter_ns`, `16'd0`, `1'b1`, `clk_i`, `reset_ni`)=\
    wire q_sv_state_ns = t_sv_set ? 1'b1 : t_sv_clr ? 1'b0 : q_sv_state;
    \=u.dffre(1, `q_sv_state`, `q_sv_state_ns`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
	  
\js // To qualify to be sent in starvation all dependencies have to be clear and have the credit / qos ok.(kok)
      assign t_oc_svok = {OCN{q_sv_state}} & q_oc_val & (q_oc_ovt | q_oc_ove) &
                                   q_oc_wake & t_oc_kok & t_oc_ihead;

\js // To qualify for starvation all dependencies have to be clear. Only blocked by qos and credits. (dok)
      assign t_starve_qual = q_oc_wake_persist & t_oc_dok & t_oc_ihead;

      wire [OCN-1:0] q_oc_ove_in;
\js for (let i=0; i<OCN; i=i+1) {
	     
      assign q_oc_ove_in[\=i=\] = (t_cfg_starve |  
//                              q_oc_status[\=i=\][7] |
                                q_in_error |
				t_oc_alloc[\=i=\] | t_oc_valloc[\=i=\] | ~(q_oc_val[\=i=\] & (q_oc_wake_persist[\=i=\]|q_oc_resurrect[\=i=\]|q_oc_wfresp[\=i=\])) |
				                  (t_pt_ok & t_oc_update[\=i=\] & (q_oc_val[\=i=\] & q_oc_ove[\=i=\]))) ? 1'b0 : 
			       ((q_oc_val[\=i=\] & (q_sv_state|q_sv_state_ns) & q_oc_resurrect[\=i=\] & (|(q_oc_val & q_oc_ove))) |
				(q_oc_val[\=i=\] & ~q_sv_state & t_starve_qual[\=i=\] & t_sv_ove & (~| (q_oc_val & q_oc_ove)))) ? 1'b1 :
							     q_oc_ove[\=i=\];
\js }
      \=u.dffre(OCN, `q_oc_ove`, `q_oc_ove_in`, `{`+OCN+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
	  
    assign t_sv_starve = q_sv_state;
    assign starve_o = {t_sv_set, t_sv_clr};
\js } else { // eStarve
    assign t_cfg_tperiod = 20'h0;
    assign t_cfg_eperiod = 16'h0;
    assign t_sv_starve = 1'b0;
    assign starve_o = 2'h0;
    assign t_oc_svok = {OCN{1'b0}};
\js } // eStarve

\js // Timeout Logic
wire period_en;

\=u.dffre(20, `t_cfg_tperiod`, `t_cfg_tperiod_in`, `20'b0`, `period_en`, `clk_i`, `reset_ni`)=\
\=u.dffre(1, `t_cfg_tperiod_eq_0`, `t_cfg_tperiod_eq_0_in`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\

\js // BIST Control
\js // - For first trigger force count register to threshold minus 1.
\js // - For second trigger for the threshold amount to smallest value to shorten rollover time. 
wire timeout_trigger_r;

\=u.dffre(1, `timeout_trigger_r`, `bist_timeout_trigger`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\

\js // This enable loads the smaller threshold value for the secong trigger
assign period_en = (~bist_timeout_trigger) | (bist_timeout_trigger & t_sv_ovt);

\js // This one shot forces the count register to go to threshold minus one for first trigger
wire timeout_trigger_os = bist_timeout_trigger & ~timeout_trigger_r;
wire timeout_trigger_os_falling = ~bist_timeout_trigger & timeout_trigger_r;

wire [31:0] timeout_test_value = {t_cfg_tperiod[31:12],12'b0} - 1;

assign t_cfg_tperiod_in = (bist_timeout_trigger) ? (20'b1) : ((| cfg_top_i) ? {(| cfg_top_i[30:19]), cfg_top_i[18:0]} : cfg_tperiod_i[31:12]);
assign t_cfg_tperiod_eq_0_in = ~(|t_cfg_tperiod_in);


assign t_sv_ovt = ~t_cfg_timeout & (q_sv_timer[31:12] == t_cfg_tperiod) & (~t_cfg_tperiod_eq_0);

						      
   wire [31:0] q_sv_timer_p1;
   wire q_sv_timer_carry;
   assign {q_sv_timer_carry,q_sv_timer_p1} = {1'b0,q_sv_timer} + 1'b1;
wire [32-1:0] q_sv_timer_ns = (timeout_trigger_os) ? timeout_test_value : ((q_sv_timer[31:12] >= t_cfg_tperiod) | t_cfg_timeout) ? 32'h0 : ((cfg_external_i ? external_i : 1'b1) & ( ~t_cfg_tperiod_eq_0)) ? q_sv_timer_p1 : q_sv_timer;
\=u.dffre(32, `q_sv_timer`, `q_sv_timer_ns`, `32'd0`, `1'b1`, `clk_i`, `reset_ni`)=\

wire [OCN-1:0] q_oc_ovt_in;
\js for (let i=0; i<OCN; i=i+1) {
    assign q_oc_ovt_in[\=i=\] = (t_cfg_timeout | t_oc_alloc[\=i=\] | t_oc_valloc[\=i=\]) ? 1'b0 : 
				(q_oc_val[\=i=\] & 
				 t_sv_ovt & (~| (q_oc_ovt & q_oc_val))) ? 1'b1 :
							     q_oc_ovt[\=i=\];
\js }

    \=u.dffre(OCN, `q_oc_ovt`, `q_oc_ovt_in`, `{`+OCN+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

\js //
\js // Functional Safety BIST-triggered Timeout
\js //

wire q_oc_ovt_bist;
wire q_oc_ovt_bist_in = (t_cfg_timeout | timeout_trigger_os_falling) ? 1'b0 :
                   (bist_timeout_trigger & t_sv_ovt)            ? 1'b1 :
                                                                  q_oc_ovt_bist;

\=u.dffre(1,  'q_oc_ovt_bist', 'q_oc_ovt_bist_in',  "1'b0", "1'b1", 'clk_i', 'reset_ni')=\

wire t_sv_timeout_bist = t_sv_ovt & bist_timeout_trigger & q_oc_ovt_bist;

\=u.instance({
	moduleName: 'ioaiu_enc',
	instanceName: 'svenc',
	params: {
                DW:             OCN,
                BE:             0,
                NO_VALID_OUT:   1,
                NO_BV_OUT:      1,
                clkAssertInterface : clkAssertInterface,
		assertOn: assertOn
	},
	ports: {
		bv_i:		'(q_oc_ovt & q_oc_val)',
		index_o:	't_sv_eid'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

  assign t_sv_eaddr = {q_oc_security[t_sv_eid], {{\=64-AW=\{1'b0}},q_oc_addr[t_sv_eid]}};
  assign t_sv_id = q_oc_id[t_sv_eid];
\js if (owo) {
  assign t_sv_type =                              (~q_oc_write[t_sv_eid] & ~t_oc_bar[t_sv_eid][0] & ((t_oc_snoop[t_sv_eid]==4'he) | (t_oc_snoop[t_sv_eid]==4'hf))) ? 2'b11 : (q_oc_write[t_sv_eid] | t_oc_evict[t_sv_eid]) ? 2'b01 : 2'b00;
\js } else {
  assign t_sv_type = q_oc_cmo[t_sv_eid] ? 2'b10 : (~q_oc_write[t_sv_eid] & ~t_oc_bar[t_sv_eid][0] & ((t_oc_snoop[t_sv_eid]==4'he) | (t_oc_snoop[t_sv_eid]==4'hf))) ? 2'b11 : (q_oc_write[t_sv_eid] | t_oc_evict[t_sv_eid]) ? 2'b01 : 2'b00;
\js }
  assign t_sv_timeout = (t_sv_ovt & (|(q_oc_val & q_oc_ovt))) |
                         t_sv_timeout_bist;

\js if (ACE) {
  assign t_uerrs[4] =                 t_crs_valid & w_cr_error;
\js } else { // ACE
  assign t_uerrs[4] = 1'b0;
\js } // ACE
  assign t_uerrs[3] = t_sv_timeout;

\js if (STE) {
\js // FIXME Spyglass W164a : top bits of addr isnt used so even if its cut off it wont matter
  wire [47:0]	t_dvm_addr_e0;
  wire [47:0]	t_dvm_addr_e1;
\js if(AW<48) {
    assign	t_dvm_addr_e0 = {{48-AW{1'b0}},t_st_addr[w_crq_sid]};
    assign	t_dvm_addr_e1 = {{48-AW{1'b0}},t_st_addr[t_st_ptr[w_crq_sid]]};
\js } else {
    assign	t_dvm_addr_e0 = t_st_addr[w_crq_sid][47:0];
    assign	t_dvm_addr_e1 = t_st_addr[t_st_ptr[w_crq_sid]][47:0];
\js }
wire [SRN1-1:0] t_dvm_mpf1_e0 = t_st_mpf1[w_crq_sid][SRN1-1:0];
wire [SRN1-1:0] t_dvm_mpf1_e1 = t_st_mpf1[t_st_ptr[w_crq_sid]][SRN1-1:0];
wire [SRN3-1:0] t_dvm_mpf3_e0 = t_st_mpf3[w_crq_sid][SRN3-1:0];

wire t_dvm_onepart_e = (t_dvm_addr_e0[4] == 1'b0);
\js }

  assign t_eaddr = 
\js if (ACE) {
                   ((t_st_cmd[w_crq_sid]==SnpDvmMsg) &
		                  t_crs_valid & w_cr_error) ?
		       {17'b0,  t_dvm_mpf1_e1[3:0],
              t_dvm_onepart_e ? t_dvm_mpf1_e0[7:4]
                              :{t_dvm_addr_e0[43:41],
                                t_dvm_addr_e1[43]},
				t_dvm_addr_e0[37:30],	//ASID[15:8]
				t_dvm_addr_e0[21:14],	//VMID[7:0] or VA[27:20]
				t_dvm_addr_e0[29:22],	//ASID[7:0] or VA[19:12]
			    (t_dvm_addr_e0[13:11]==3'h4),//CompletionRequired
				t_dvm_addr_e0[13:11],	//DVMOp Type
				t_dvm_addr_e0[10:9],	//Guest/Hypervisor
				t_dvm_addr_e0[8:7],	//Security
				t_dvm_mpf3_e0[1],	//Range
				t_dvm_addr_e0[5],	//VMID_valid
				t_dvm_addr_e0[6],	//ASID_valid
				t_dvm_addr_e0[40],	//LeafEntry Invalidation
				t_dvm_addr_e0[39:38],	//Staged Invalidation
				1'b0,			//Reserved
				t_dvm_addr_e0[4]} :	//2-part message
		 (                t_crs_valid & w_cr_error) ?
					      {t_st_security[w_crq_sid],
					       ({{\=64-AW=\{1'b0}},t_st_addr[w_crq_sid]})} :
\js } // ACE
		 t_sv_timeout ? t_sv_eaddr : 
				{w_pt_security, ({{\=64-AW=\{1'b0}},w_pt_addr})};

\js if (axiParams.eDomain) {
    wire [MW-1:0]	q_oc_domain[OCN-1:0];
    wire [MW-1:0]	q_oc_domain_ns[OCN-1:0];
    wire [SW-1:0]       w_pt_snoop_mod;
    wire [SW-1:0]	q_oc_snoop[OCN-1:0];
    wire [SW-1:0]	q_oc_snoop_ns[OCN-1:0];
    wire [MW-1:0]	q_oc_bar[OCN-1:0];
    wire [MW-1:0]	q_oc_bar_ns[OCN-1:0];
    wire [3:0]	        q_oc_vmidext[OCN-1:0];
    wire [3:0]	        q_oc_vmidext_ns[OCN-1:0];
\js for (let i=0; i<OCN; i++) {
    wire [MW-1:0]       q_oc_domain\=i=\;
    wire [SW-1:0]       q_oc_snoop\=i=\;
    wire [MW-1:0]       q_oc_bar\=i=\;
    wire [3:0]          q_oc_vmidext\=i=\;
    assign q_oc_domain[\=i=\] = q_oc_domain\=i=\;
    assign q_oc_snoop[\=i=\] = q_oc_snoop\=i=\;
    assign q_oc_bar[\=i=\] = q_oc_bar\=i=\;
    assign q_oc_vmidext[\=i=\] = q_oc_vmidext\=i=\;
\js }

\js // For OWO we only acceot and will process transactions with snoops of 0. However the CMO would corrupt this entry if allowed to pass.
\jsbegin
// No owo on 3.7.0
    if (owo){ \jsend
assign w_pt_snoop_mod = (w_pt_write) ? \=SW=\'h0 : w_pt_snoop;
\js } else {
assign w_pt_snoop_mod = w_pt_snoop;
\js }

\js for (let i=0; i<OCN; i=i+1) {
      assign q_oc_domain_ns[\=i=\] = t_oc_alloc[\=i=\] ? w_pt_domain : t_oc_valloc[\=i=\] ? {MW{1'b0}} : q_oc_domain[\=i=\];
      \=u.dffre(MW, `q_oc_domain`+i, `q_oc_domain_ns[`+i+`]`, `{`+MW+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
      assign q_oc_snoop_ns[\=i=\] = t_oc_alloc[\=i=\] ? w_pt_snoop_mod : t_oc_valloc[\=i=\] ? {SW{1'b0}} : q_oc_snoop[\=i=\];
      \=u.dffre(SW, `q_oc_snoop`+i, `q_oc_snoop_ns[`+i+`]`, `{`+SW+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
      assign q_oc_bar_ns[\=i=\] = t_oc_alloc[\=i=\] ? w_pt_bar : t_oc_valloc[\=i=\] ? {MW{1'b0}} : q_oc_bar[\=i=\];
      \=u.dffre(MW, `q_oc_bar`+i, `q_oc_bar_ns[`+i+`]`, `{`+MW+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
      assign q_oc_vmidext_ns[\=i=\] = t_oc_alloc[\=i=\] ? w_pt_vmidext : t_oc_valloc[\=i=\] ? {4{1'b0}} : q_oc_vmidext[\=i=\];
      \=u.dffre(4, `q_oc_vmidext`+i, `q_oc_vmidext_ns[`+i+`]`, `{4{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
      assign t_oc_domain[\=i=\] = q_oc_domain[\=i=\];
      assign t_oc_snoop[\=i=\] = q_oc_snoop[\=i=\];
      assign t_oc_bar[\=i=\] = q_oc_bar[\=i=\];
      assign t_oc_vmidext[\=i=\] = q_oc_vmidext[\=i=\];
\js }
\js } else { // axiParams.eDomain
    wire [MW-1:0]	q_oc_domain[OCN-1:0];
    wire [MW-1:0]	q_oc_domain_ns[OCN-1:0];

\js for (let i=0; i<OCN; i=i+1) {
      wire [MW-1:0] q_oc_domain\=i=\;
      assign q_oc_domain[\=i=\] =  q_oc_domain\=i=\;
      assign q_oc_domain_ns[\=i=\] = t_oc_alloc[\=i=\] ? w_pt_domain[MW-1:0] : q_oc_domain[\=i=\];
      \=u.dffre(MW, `q_oc_domain`+i, `q_oc_domain_ns[`+i+`]`, `{`+MW+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
      assign t_oc_domain[\=i=\] = {1'b0,q_oc_domain[\=i=\]};
      assign t_oc_snoop[\=i=\] = 4'b0;
      assign t_oc_bar[\=i=\] = 1'b0;
      assign t_oc_vmidext[\=i=\] = 4'b0;
\js }
\js }


// OWO ENtries
\jsbegin
// No owo on 3.7.0
    if ( owo ) { \jsend
 wire [\=OCN-1=\:0] snp_req_match;

 assign command_sent = (w_cmd_req0_ready & n_cmd_req0_valid) | (w_pt_valid & t_pt_err);

 \js for (let i=0; i<OCN; i=i+1) {
      // These entries are only valid for writes
      wire [1:0] pt_phase\=i=\ = t_oc_phase[q_oc_iptr[\=i=\]];
      wire pt_owned\=i=\ = t_oc_owned[q_oc_iptr[\=i=\]];
      wire pt_oldest\=i=\ = t_oc_oldest[q_oc_iptr[\=i=\]];
      wire pt_valid\=i=\ = q_oc_val[q_oc_iptr[\=i=\]];

      wire              q_oc_owo_wfstp\=i=\;
      wire              q_oc_owo_wfstp_ns\=i=\;
      wire              q_oc_owo_str_req_received_ns\=i=\;
      wire              q_oc_owo_str_req_received\=i=\;
      
      wire [1:0]	q_oc_phase\=i=\;
      wire [1:0]	q_oc_phase_pre\=i=\;
      wire          	q_oc_owned\=i=\;
      wire          	q_oc_oldest\=i=\;
      wire          	q_oc_oldest_pre\=i=\;
      wire          	q_oc_coherent\=i=\;
      wire              q_oc_sent_cmo_stp\=i=\;

      wire [1:0]        q_oc_phase_alt\=i=\;
      wire              q_oc_oldest_alt\=i=\;

      wire [1:0]	q_oc_phase_ns\=i=\;
      wire          	q_oc_owned_ns\=i=\;
      wire          	q_oc_oldest_ns\=i=\;
      wire          	q_oc_coherent_ns\=i=\;
      wire              q_oc_sent_cmo_stp_ns\=i=\;

      wire [1:0]        q_oc_phase_alt_ns\=i=\;
      wire              q_oc_oldest_alt_ns\=i=\;

      // If its non coherent just check to make sure the command is sent,
      // If its coherent you have to make sure that the command sent is the writeback and not the CMO. In this case it will always be a woken up txn
      wire              sending_writeback_alt_\=i=\ = (t_oc_alloc[\=i=\] & ( t_pt_coherent | ~w_pt_write)) ? 1'b0 :
                                               (t_oc_alloc[\=i=\] & ~t_pt_coherent) ? command_sent :
                                               (~q_oc_coherent\=i=\) ? q_oc_val[\=i=\] & command_sent & q_oc_write[\=i=\] &  w_pt_wake & w_pt_kid_oh[\=i=\] :
                                                                       q_oc_val[\=i=\] & command_sent & q_oc_write[\=i=\] & (w_pt_wake & w_pt_kid_oh[\=i=\]) & generated_writeback;

      wire              sending_writeback_\=i=\ = command_sent &
                                              ((t_oc_alloc[\=i=\] & ~t_pt_coherent & w_pt_write) |
                                               (~q_oc_coherent\=i=\ & q_oc_val[\=i=\] & q_oc_write[\=i=\] &  w_pt_wake & w_pt_kid_oh[\=i=\]) |
                                               ( q_oc_coherent\=i=\ & q_oc_val[\=i=\] & q_oc_write[\=i=\] & (w_pt_wake & w_pt_kid_oh[\=i=\]) & generated_writeback));

      wire              dependency_sent_writeback_\=i=\ = q_oc_val[\=i=\] & sent_writeback[q_oc_iptr[\=i=\]] & ~q_oc_iptr_eq[\=i=\]; 
      assign            t_oc_phase_neq_0[\=i=\] = |t_oc_phase[\=i=\];
      wire              hit_sent_writeback\=i=\ = |(q_oc_val & t_oc_ihit & t_oc_phase_neq_0);
      wire              cmo_str_rsp_sent\=i=\ = (n_ocp_ready & w_ocp_valid & (\=i=\ == w_ocp_oid));
      wire              snp_req_match\=i=\ = n_snp_req_ready & w_snp_req_valid & ({w_snp_req_security,w_snp_req_addr[\=AW-1=\:\=CLO=\]} == {q_oc_security[\=i=\],q_oc_addr[\=i=\][\=AW-1=\:\=CLO=\]});
      assign            snp_req_match[\=i=\] = snp_req_match\=i=\;

      assign sending_writeback[\=i=\] = sending_writeback_\=i=\;
      assign sending_writeback_alt[\=i=\] = sending_writeback_alt_\=i=\;
      assign q_oc_owned[\=i=\] = q_oc_owned\=i=\;
      assign q_oc_oldest[\=i=\] = q_oc_oldest\=i=\;
      assign q_oc_oldest_alt[\=i=\] = q_oc_oldest_alt\=i=\;

      // Phases:
      // 0: Need CMO Response
      // 1: Need Writeback to Complete
      // 2: Need UPDReq to Complete
      assign q_oc_phase_alt_ns\=i=\  = (t_oc_alloc[\=i=\] & ( t_pt_coherent | ~w_pt_write)) ? 2'd0 :
      	     			   (t_oc_alloc[\=i=\] & ~t_pt_coherent) ? {1'b0,command_sent} :
				   (sending_writeback_alt_\=i=\ & ~t_pt_err) ? 2'd1 : 
				   (q_oc_phase_alt\=i=\ == 2'd1) ? 2'd2 : // Was the UPDReq Phase
				    q_oc_phase_alt\=i=\;
      	     			       
      assign q_oc_phase_ns\=i=\  = t_oc_alloc[\=i=\] ? 2'd0 :
//                                 (sent_writeback[\=i=\] & t_oc_cmd_sent) ? 2'd2 :
                                   (q_oc_phase\=i=\ == 2'd1) ? 2'd2 : \js // Was the UPDReq Phase
                                    q_oc_phase\=i=\;

      assign q_oc_phase\=i=\ = (sent_writeback[\=i=\] & (t_oc_cmd_sent|t_oc_cmd_error)) ? 2'b01 : q_oc_phase_pre\=i=\;

      assign q_oc_owned_ns\=i=\  = (t_oc_alloc[\=i=\]) ? (t_pt_coherent & w_pt_upgrade) : // On allocation it can possibly upgrade to being owned
      	     			   (q_oc_val[\=i=\] & (q_oc_phase\=i=\ == 2'b0) & ~q_oc_wfstr[\=i=\] & cmo_str_rsp_sent\=i=\) ? 1'b1 : // STRReq comes back in phase 0 it got ownership from DCE
				   (q_oc_owned\=i=\ & snp_req_match\=i=\ & ~q_oc_oldest\=i=\) ? 1'b0 : // Need to lose ownsership if snoop comes in
				    q_oc_owned\=i=\;
      
      assign q_oc_oldest_alt_ns\=i=\ = (t_oc_alloc[\=i=\]) ? (hit_sent_writeback\=i=\ | ~(|t_oc_ihit)):
                                   (sending_writeback_alt_\=i=\) ? 1'b0 : // Lose oldest once you sent the writeback
                                   (q_oc_val[\=i=\] & q_oc_write[\=i=\] & ~(|q_oc_phase_alt\=i=\) & ~(|t_oc_atop[\=i=\]) & ~q_oc_wfa[\=i=\] & q_oc_status[\=i=\][7]) ? 1'b0 : // Lose oldest once you sent the writeback
                                   ((q_oc_val[\=i=\] & q_oc_write[\=i=\] & q_oc_iptr_eq[\=i=\] & ~(|q_oc_phase_alt\=i=\) & ~(|t_oc_atop[\=i=\]) & ~sent_writeback_alt[\=i=\] & ~t_oc_dealloc[\=i=\]) | (dependency_sent_writeback_\=i=\ & ~q_oc_iptr_eq[\=i=\])) ? 1'b1 : // Once what ahead of you sends writeback you become oldest
				    q_oc_oldest_alt\=i=\;

      assign q_oc_oldest_ns\=i=\ = (t_oc_alloc[\=i=\]) ? (hit_sent_writeback\=i=\ | ~(|t_oc_ihit)):
                                   (sent_writeback[\=i=\] & q_oc_val_lat\=i=\) ? 1'b0 : // Lose oldest once you sent the writeback
                                   (q_oc_val[\=i=\] & q_oc_write[\=i=\] & ~(|q_oc_phase\=i=\) & ~(|t_oc_atop[\=i=\]) & ~q_oc_wfa[\=i=\] & q_oc_status[\=i=\][7]) ? 1'b0 : // Lose oldest once you sent the writeback
                                   ((q_oc_val[\=i=\] & q_oc_write[\=i=\] & q_oc_iptr_eq[\=i=\] & ~(|q_oc_phase\=i=\) & ~(|t_oc_atop[\=i=\]) & ~t_oc_dealloc[\=i=\]) | (dependency_sent_writeback_\=i=\ & ~q_oc_iptr_eq[\=i=\])) ? 1'b1 : // Once what ahead of you sends writeback you become oldest
                                    q_oc_oldest\=i=\;

      assign q_oc_oldest\=i=\ = q_oc_oldest_pre\=i=\ & ((q_oc_val\=i=\ & ~q_oc_val_lat\=i=\) | ~sent_writeback[\=i=\]);

      assign q_oc_coherent_ns\=i=\ = (t_oc_alloc[\=i=\]) ? t_pt_coherent : q_oc_coherent\=i=\;

      // Have special bit to keep track of STRRsp for initial CMO.

      assign q_oc_sent_cmo_stp_ns\=i=\ = (t_oc_alloc[\=i=\]|t_oc_update[\=i=\]) ? 1'b0 :
                                         (cmo_str_rsp_sent\=i=\) ? 1'b1 : q_oc_sent_cmo_stp\=i=\;

      assign q_oc_owo_wfstp_ns\=i=\ = (t_oc_alloc[\=i=\]) ? 1'b0 :
                                      (cmo_str_rsp_sent\=i=\ | q_oc_sent_cmo_stp\=i=\) ? 1'b0 :
                                      (q_oc_val[\=i=\] & (q_oc_phase\=i=\ == 2'b0) & ~q_oc_wfstr[\=i=\] & ~(|t_oc_atop[\=i=\]) & ~q_oc_wfresp[\=i=\] & ~q_oc_owned[\=i=\] & q_oc_write[\=i=\] & (q_oc_owo_str_req_received\=i=\ | ~q_oc_status[\=i=\][7])) ? 1'b1 : q_oc_owo_wfstp\=i=\; // If not owned, and not wfstr, then strrsp still needs sending

      assign q_oc_owo_str_req_received_ns\=i=\ = (t_oc_alloc[\=i=\]|t_oc_update[\=i=\]) ? 1'b0 :
                                                 (w_str_req_valid & (w_str_req_rid_bv[\=i=\])) ? 1'b1 : q_oc_owo_str_req_received\=i=\;

      \=u.dffre(1, `q_oc_sent_cmo_stp`+i, `q_oc_sent_cmo_stp_ns`+i  , `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
      \=u.dffre(2, `q_oc_phase_alt`+i, `q_oc_phase_alt_ns`+i, `{`+2+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
      \=u.dffre(2, `q_oc_phase_pre`+i, `q_oc_phase_ns`+i, `{`+2+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
      \=u.dffre(1, `q_oc_owned`+i, `q_oc_owned_ns`+i  , `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
      \=u.dffre(1, `q_oc_oldest_alt`+i, `q_oc_oldest_alt_ns`+i, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
      \=u.dffre(1, `q_oc_oldest_pre`+i, `q_oc_oldest_ns`+i, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
      \=u.dffre(1, `q_oc_coherent`+i, `q_oc_coherent_ns`+i, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
      \=u.dffre(1, `q_oc_owo_wfstp`+i, `q_oc_owo_wfstp_ns`+i, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
      \=u.dffre(1, `q_oc_owo_str_req_received`+i, `q_oc_owo_str_req_received_ns`+i, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\

      assign t_oc_writeback_phase[\=i=\] = (q_oc_phase\=i=\ != 0);
      assign t_oc_phase[\=i=\] = q_oc_phase\=i=\;
      assign t_oc_owned[\=i=\] = q_oc_owned\=i=\;
      assign t_oc_oldest[\=i=\] = q_oc_oldest\=i=\;
      assign t_oc_coh[\=i=\] = q_oc_coherent\=i=\;
      assign t_oc_owo_wfstp[\=i=\] = q_oc_owo_wfstp\=i=\;
 \js }
      \=u.dffre(OCN, `sent_writeback`, `sending_writeback`, OCN+`'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
      \=u.dffre(OCN, `sent_writeback_alt`, `sending_writeback_alt`, OCN+`'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
\js } else {
  \js for (let i=0; i<OCN; i=i+1) {
      assign t_oc_writeback_phase[\=i=\] = 1'b0;
      assign sending_writeback[\=i=\] = 1'b0;
      assign sent_writeback[\=i=\] = 1'b0;
      assign t_oc_phase[\=i=\] = 2'b0;
      assign t_oc_owned[\=i=\] = 1'b0;
      assign t_oc_oldest[\=i=\] = 1'b0;
      assign t_oc_coh[\=i=\] = 1'b0;
      assign t_oc_owo_wfstp[\=i=\] = 1'b0; 
  \js }
\js }


\js if (axiParams.eAtomic) {
    wire [SRCM-1:0]	q_oc_midtwo[OCN-1:0];
    wire [SRCM-1:0]	q_oc_midtwo_ns[OCN-1:0];
    wire [SRCI-1:0]	q_oc_iidtwo[OCN-1:0];
    wire [SRCI-1:0]	q_oc_iidtwo_ns[OCN-1:0];
    wire [5:0]	q_oc_atop[OCN-1:0];
    wire [5:0]	q_oc_atop_ns[OCN-1:0];
    wire [OCN-1:0]      q_oc_atop_persist;
    wire [OCN-1:0]      q_oc_atop_persist_ns;
    wire [OCN-1:0]	q_oc_atop_rw;
    wire [OCN-1:0]	q_oc_atop_rw_ns;
    wire [OCN-1:0]	q_oc_wfatop;
    wire [OCN-1:0]	q_oc_wfatop_ns;
\js for (let i=0;i<OCN;i++) {
    wire q_oc_atop_persist\=i=\;
    assign q_oc_atop_persist[\=i=\] = q_oc_atop_persist\=i=\;
    wire q_oc_atop_rw\=i=\;
    assign q_oc_atop_rw[\=i=\] = q_oc_atop_rw\=i=\;

    wire [SRCM-1:0]     q_oc_midtwo\=i=\;
    wire [SRCI-1:0]     q_oc_iidtwo\=i=\;
    wire [5:0]  q_oc_atop\=i=\;
    wire        q_oc_wfatop\=i=\;
    assign q_oc_midtwo[\=i=\] = q_oc_midtwo\=i=\;
    assign q_oc_iidtwo[\=i=\] = q_oc_iidtwo\=i=\;
    assign q_oc_atop[\=i=\] = q_oc_atop\=i=\;
    assign q_oc_wfatop[\=i=\] = q_oc_wfatop\=i=\;
\js }

\js for (let i=0; i<OCN; i=i+1) {
      assign q_oc_midtwo_ns[\=i=\] = (w_str_req_valid & (w_str_req_rid_bv[\=i=\]) & t_oc_catop[\=i=\]) ? w_str_req_mid : q_oc_midtwo[\=i=\];
      \=u.dffre(SRCM, `q_oc_midtwo`+i, `q_oc_midtwo_ns[`+i+`]`, `{`+SRCM+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
      assign q_oc_iidtwo_ns[\=i=\] = (w_str_req_valid & (w_str_req_rid_bv[\=i=\]) & t_oc_catop[\=i=\]) ? w_str_req_iid : q_oc_iidtwo[\=i=\];
      \=u.dffre(SRCI, `q_oc_iidtwo`+i, `q_oc_iidtwo_ns[`+i+`]`, `{`+SRCI+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
      assign q_oc_atop_persist_ns[\=i=\] = t_oc_alloc[\=i=\] ? (|w_pt_atop) : t_oc_valloc[\=i=\] ? 1'h0 : q_oc_atop_persist[\=i=\];
      \=u.dffre(1, `q_oc_atop_persist`+i, `q_oc_atop_persist_ns[`+i+`]`, `1'd0`, `1'b1`, `clk_i`, `reset_ni`)=\
      assign q_oc_atop_rw_ns[\=i=\] = t_oc_alloc[\=i=\] ? w_pt_atop[5] : t_oc_valloc[\=i=\] ? 1'h0 : q_oc_atop_rw[\=i=\];
      \=u.dffre(1, `q_oc_atop_rw`+i, `q_oc_atop_rw_ns[`+i+`]`, `1'd0`, `1'b1`, `clk_i`, `reset_ni`)=\
      assign q_oc_atop_ns[\=i=\] = t_oc_alloc[\=i=\] ? w_pt_atop : (t_oc_valloc[\=i=\] | (n_odr_lbv[\=i=\] & t_odr_ready)) ? 6'h0 : q_oc_atop[\=i=\];
      \=u.dffre(6, `q_oc_atop`+i, `q_oc_atop_ns[`+i+`]`, `6'd0`, `1'b1`, `clk_i`, `reset_ni`)=\
      assign q_oc_wfatop_ns[\=i=\] = t_oc_alloc[\=i=\] ? t_pt_catop : ((w_str_req_valid & (w_str_req_rid_bv[\=i=\]) & w_str_req_status[7]) | (w_ocp_obv[\=i=\] & n_ocp_ready & q_oc_wfatop[\=i=\])) ? 1'b0 : q_oc_wfatop[\=i=\];
      \=u.dffre(1, `q_oc_wfatop`+i, `q_oc_wfatop_ns[`+i+`]`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
      assign t_oc_mid2[\=i=\] = q_oc_midtwo[\=i=\];
      assign t_oc_iid2[\=i=\] = q_oc_iidtwo[\=i=\];
      assign t_oc_atop[\=i=\] = q_oc_atop[\=i=\];
      assign t_oc_atop_persist[\=i=\] = q_oc_atop_persist[\=i=\];
      assign t_oc_atop_rw[\=i=\] = q_oc_atop_rw[\=i=\];
      assign t_oc_catop[\=i=\] = (| q_oc_atop[\=i=\]) & (| q_oc_cache[\=i=\][3:2]) &
	     ~(~t_oc_bar[\=i=\][0] & (t_oc_snoop[\=i=\]==4'h0) &
	       ((t_oc_domain[\=i=\]==2'h0) |
		(t_oc_domain[\=i=\]==2'h3)));
      assign t_oc_catope[\=i=\] = t_oc_catop[\=i=\] & ~q_oc_wfstr[\=i=\] & ~q_oc_wfresp[\=i=\] &
					~q_oc_status[\=i=\][7] & q_oc_val[\=i=\];
      assign t_oc_wfatop[\=i=\] = q_oc_wfatop[\=i=\];
\js }
\js } else { // axiParams.eAtomic
\js for (let i=0; i<OCN; i=i+1) {
      assign t_oc_mid2[\=i=\] = {SRCM{\=DRST=\}};
      assign t_oc_iid2[\=i=\] = {SRCI{\=DRST=\}};
      assign t_oc_atop[\=i=\] = 6'b0;
\js }
      assign t_oc_atop_persist = {\=OCN=\{1'b0}};
      assign t_oc_atop_rw = {\=OCN=\{1'b0}};
      assign t_oc_catop = {\=OCN=\{1'b0}};
      assign t_oc_catope = {\=OCN=\{1'b0}};
      assign t_oc_wfatop = {\=OCN=\{1'b0}};
\js } // axiParams.eAtomic

\js if (axiParams.eStash) {
    wire [OCN-1:0]	q_oc_stashlpiden;
    wire [OCN-1:0]	q_oc_stashlpiden_ns;
    wire [\=SHLW-1=\:0]	q_oc_stashlpid[OCN-1:0];
    wire [\=SHLW-1=\:0]	q_oc_stashlpid_ns[OCN-1:0];
    wire [OCN-1:0]	q_oc_stashniden;
    wire [OCN-1:0]	q_oc_stashniden_ns;
    wire [FIDW-1:0]	q_oc_stashnid[OCN-1:0];
    wire [FIDW-1:0]	q_oc_stashnid_ns[OCN-1:0];
    wire [1:0]	        q_oc_isize[OCN-1:0];
    wire [1:0]	        q_oc_isize_ns[OCN-1:0];
    wire [FIDW-1:0] w_str_req_mpf1_tmp;
\js for (let i=0;i<OCN;i++) {
    wire                q_oc_stashlpiden\=i=\;
    wire [\=SHLW-1=\:0]     q_oc_stashlpid\=i=\;
    wire                q_oc_stashniden\=i=\;
    wire [FIDW-1:0]     q_oc_stashnid\=i=\;
    wire [1:0]          q_oc_isize\=i=\;
    assign q_oc_stashlpiden[\=i=\] = q_oc_stashlpiden\=i=\;
    assign q_oc_stashlpid[\=i=\] = q_oc_stashlpid\=i=\;
    assign q_oc_stashniden[\=i=\] = q_oc_stashniden\=i=\;
    assign q_oc_stashnid[\=i=\] = q_oc_stashnid\=i=\;
    assign q_oc_isize[\=i=\] = q_oc_isize\=i=\;
\js }

\jsbegin
// wMpf1 is always at least FIDW+1
/* istanbul ignore if env ncore_3p7 */
    if(FIDW>concParams.strReqParams.wMpf1) { \jsend
      assign w_str_req_mpf1_tmp = {{FIDW-SRC1{1'b0}},w_str_req_mpf1};
\js } else {
      assign w_str_req_mpf1_tmp = w_str_req_mpf1[FIDW-1:0];
\js }

    wire [\=SHLW-1=\:0] w_pt_stashlpid_mpf2_tmp;
\jsbegin
// wMpf2 is always at 6 or 12
/* istanbul ignore else env ncore_3p7 */
    if(concParams.strReqParams.wMpf2>5) { \jsend
      assign w_pt_stashlpid_mpf2_tmp = {{\=SHLW-5=\{1'b0}},w_pt_stashlpid};
\js } else {
      assign w_pt_stashlpid_mpf2_tmp = w_pt_stashlpid[\=SHLW-1=\:0];
\js }

\js for (let i=0; i<OCN; i=i+1) {
      assign q_oc_stashlpiden_ns[\=i=\] = t_oc_alloc[\=i=\] ? w_pt_stashlpiden : t_oc_valloc[\=i=\] ? 1'b0 : q_oc_stashlpiden[\=i=\];
      \=u.dffre(1, `q_oc_stashlpiden`+i, `q_oc_stashlpiden_ns[`+i+`]`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
      assign q_oc_stashlpid_ns[\=i=\] = t_oc_alloc[\=i=\] ? w_pt_stashlpid_mpf2_tmp : t_oc_valloc[\=i=\] ? {\=SHLW=\{1'b0}} : (w_str_req_valid & (w_str_req_rid_bv[\=i=\])) ? w_str_req_mpf2 : q_oc_stashlpid[\=i=\];
      \=u.dffre(SHLW, `q_oc_stashlpid`+i, `q_oc_stashlpid_ns[`+i+`]`, `{`+SHLW+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
      assign q_oc_stashniden_ns[\=i=\] = t_oc_alloc[\=i=\] ? w_pt_stashniden : t_oc_valloc[\=i=\] ? 1'b0 : (w_str_req_valid & (w_str_req_rid_bv[\=i=\])) ? w_str_req_status[0] : q_oc_stashniden[\=i=\];
      \=u.dffre(1, `q_oc_stashniden`+i, `q_oc_stashniden_ns[`+i+`]`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
      assign q_oc_stashnid_ns[\=i=\] = t_oc_alloc[\=i=\] ? w_pt_stashnid : t_oc_valloc[\=i=\] ? {FIDW{1'b0}} : (w_str_req_valid & (w_str_req_rid_bv[\=i=\])) ? w_str_req_mpf1_tmp : q_oc_stashnid[\=i=\];
      \=u.dffre(FIDW, `q_oc_stashnid`+i, `q_oc_stashnid_ns[`+i+`]`, `{`+FIDW+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
      assign q_oc_isize_ns[\=i=\] = (w_str_req_valid & (w_str_req_rid_bv[\=i=\])) ? w_str_req_isize : q_oc_isize[\=i=\];
      \=u.dffre(2, `q_oc_isize`+i, `q_oc_isize_ns[`+i+`]`, `2'd0`, `1'b1`, `clk_i`, `reset_ni`)=\
	     
      assign t_oc_stashid[\=i=\] = {q_oc_stashnid[\=i=\], q_oc_stashniden[\=i=\], q_oc_stashlpid[\=i=\][4:0], q_oc_stashlpiden[\=i=\]};
      assign t_oc_stashrid[\=i=\] = q_oc_stashlpid[\=i=\];
      assign t_oc_stashnid[\=i=\] = q_oc_stashnid[\=i=\];
      assign t_oc_stashniden[\=i=\] = q_oc_stashniden[\=i=\];
      assign t_oc_isize[\=i=\] = q_oc_isize[\=i=\];
\js }
\js } else { // axiParams.eStash
\js for (let i=0; i<OCN; i=i+1) {
      assign t_oc_stashid[\=i=\] = {AWSW{1'b0}};
      assign t_oc_stashrid[\=i=\] = {SRC2{1'b0}};
      assign t_oc_stashnid[\=i=\] = {FIDW{1'b0}};
      assign t_oc_stashniden[\=i=\] = 1'b0;
      assign t_oc_isize[\=i=\] = {2{1'b0}};
\js }
\js } // axiParams.eStash

\js if (axiParams.wLoop+axiParams.eTrace>0) {
    wire [AXKW-1:0]	q_oc_track[OCN-1:0];
    wire [AXKW-1:0]	q_oc_track_ns[OCN-1:0];

\js for (let i=0; i<OCN; i=i+1) {
      wire [AXKW-1:0]     q_oc_track\=i=\;
      assign q_oc_track[\=i=\] = q_oc_track\=i=\;
      assign q_oc_track_ns[\=i=\] =  t_oc_alloc[\=i=\] ? w_pt_track : t_oc_valloc[\=i=\] ? w_pt_track : q_oc_track[\=i=\];
      \=u.dffre(AXKW, `q_oc_track`+i, `q_oc_track_ns[`+i+`]`, `{`+AXKW+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
      assign t_oc_track[\=i=\] = q_oc_track[\=i=\];
\js }
\js } else {
\js for (let i=0; i<OCN; i=i+1) {
      assign t_oc_track[\=i=\] = {AXKW{1'b0}};
\js }
\js }

\js for (let id=0; id<OCN; id=id+1) {
\js	for (let ic=0; ic<OCN; ic=ic+1) {
		assign t_od_dbusy[\=id=\][\=ic=\] = t_oc_dbusy[\=ic=\][\=id=\];
\js	}
\js }

assign t_px_dbusy = ({OLN{w_w1_valid}} & (\=OCN=\'b1 << w_w1_dptr)) |
		    ({OLN{w_w2_valid}} & (\=OCN=\'b1 << w_w2_dptr)) |
		    ({OLN{w_p0w_valid}} & (\=OCN=\'b1 << w_p0w_dptr)) |
                    ({OLN{w_rr_guts_valid[2] & w_rr_guts_write[2] & ~w_rr_guts_cmr[2][1] &
                                      ~w_rr_guts_wake[2]}} & (\=OCN=\'b1 << w_rr_guts_kid[2])) |
                    ({OLN{w_rr_guts_valid[1] & w_rr_guts_write[1] & ~w_rr_guts_cmr[1][1] &
                                      ~w_rr_guts_wake[1]}} & (\=OCN=\'b1 << w_rr_guts_kid[1])) |
		    ({OLN{w_rr_valid & w_rr_write & ~w_rr_cmr[1] &
				      ~w_rr_wake}} & (\=OCN=\'b1 << w_rr_kid)) |
		    ({OLN{w_p1_valid & w_p1_write & (P1EN>0) &
				      ~w_p1_wake}} & (\=OCN=\'b1 << w_p1_kid)) |
		    ({OLN{w_p2_valid & w_pt_write & 
				      ~w_pt_wake}} & (\=OCN=\'b1 << w_pt_kid));

wire [OCN-1:0] q_od_val_in;
wire [OCN-1:0] q_od_busy_in;
    assign t_od_dealloc = q_od_val & ~q_od_busy & ~t_px_dbusy & ~t_p1_skid;
\js for (let i=0; i<OCN; i=i+1) {
    assign t_od_alloc[\=i=\] = (w_w1_ready_raw & n_w1_valid & n_w1_dptr_vec[\=i=\]) | (w_pt_valid & w_c2_flush & t_od_eptr_vec[\=i=\]) | (t_od_we & q_od_wptr_vec[\=i=\] & ~w_c2_done);
    assign q_od_val_in[\=i=\] = t_od_alloc[\=i=\] ? 1'b1 : t_od_dealloc[\=i=\] ? 1'b0 : q_od_val[\=i=\];
    assign q_od_busy_in[\=i=\] = t_od_alloc[\=i=\] | t_px_dbusy[\=i=\] | t_p1_skid[\=i=\] | (| t_od_dbusy[\=i=\]);
\js }
    \=u.dffre(OCN, `q_od_val`, `q_od_val_in`, `{`+OCN+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
    \=u.dffre(OCN, `q_od_busy`, `q_od_busy_in`, `{`+OCN+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

\=u.instance({
	moduleName: 'ioaiu_arbiter',
	instanceName: 'odr_arb',
	params: {
                DRST:           DRST,
                DW:             OCN,
                ATOMIC:         (OTEN) ? 0 : 1,
                HP:             `{`+OCN+`{1'b0}}`,
                VAL:            (OTEN)?0:1,
		 assertOn: assertOn
	},
	ports: {
		clk_i:		'clk_i',
		reset_ni:	'reset_ni',
		ready_i:	'w_ocr_ready',
		bv_i:		't_oc_rok',
		lv_i:		'n_ocr_lbv',
		winner_o:	'n_ocr_oid',
		wbv_o:		'n_ocr_obv'
	},
	portsDelimiter: '\n\t'
})=\

\js if (OTEN) {
    wire [129:0]	q_error;

    assign n_ocr_valid = (| t_oc_rok);
    assign n_ocr_lbv = {OCN{1'b1}};
    assign n_ocr_ready = t_odr_ready & w_ocr_valid & n_odr_last;

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'ocr',
	params: {
                depth:          1,
		width:		OCA+OCN,
                pipeForward:    "yes",
                pipeBackward:   "no",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_ocr_ready',
		in_valid:	'n_ocr_valid',
		in_data:	'{n_ocr_oid,n_ocr_obv}',
		out_ready:	'n_ocr_ready',
		out_valid:	'w_ocr_valid',
		out_data:	'{w_ocr_oid,w_ocr_obv}'
	},
	portsDelimiter: '\n\t'
})=\

    assign n_odr_obv = {OCN{w_ocr_valid}} & w_ocr_obv;
    assign n_ocw_valid = (| t_oc_dtw);
    assign n_ocw_lbv = {OCN{1'b1}};
    assign n_ocw_ready = w_odf_ready & w_ocw_valid & n_odf_last;

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'ocw',
	params: {
                depth:          1,
		width:		OCA+OCN,
                pipeForward:    "yes",
                pipeBackward:   "no",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_ocw_ready',
		in_valid:	'n_ocw_valid',
		in_data:	'{n_ocw_oid,n_ocw_obv}',
		out_ready:	'n_ocw_ready',
		out_valid:	'w_ocw_valid',
		out_data:	'{w_ocw_oid,n_odf_obv}'
	},
	portsDelimiter: '\n\t'
})=\

    //assign n_odf_obv = {OCN{w_ocw_valid}} & ({{OCN-1{1'b0}}, 1'b1} << w_ocw_oid);
    assign n_pw0_valid = (| t_oc_wdone);

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'pw0',
	params: {
                depth:          1,
		width:		OCA,
                pipeForward:    "yes",
                pipeBackward:   "no",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_pw0_ready',
		in_valid:	'n_pw0_valid',
		in_data:	'n_pw0_oid',
		out_ready:	'n_pw0_ready',
		out_valid:	'w_pw0_valid',
		out_data:	'w_pw0_oid'
	},
	portsDelimiter: '\n\t'
})=\

    assign w_pw0_obv = {OCN{w_pw0_valid}} & ({{OCN-1{1'b0}}, 1'b1} << w_pw0_oid);
    assign n_ocp_valid = (| t_oc_stp);
    assign n_ocp_ready = w_str_rsp0_ready;

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'ocp',
	params: {
                depth:          1,
		width:		OCA,
                pipeForward:    "yes",
                pipeBackward:   "no",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_ocp_ready',
		in_valid:	'n_ocp_valid',
		in_data:	'n_ocp_oid',
		out_ready:	'n_ocp_ready',
		out_valid:	'w_ocp_valid',
		out_data:	'w_ocp_oid'
	},
	portsDelimiter: '\n\t'
})=\

    assign w_ocp_obv = {OCN{w_ocp_valid}} & ({{OCN-1{1'b0}}, 1'b1} << w_ocp_oid);
    assign n_fkm_valid = (| t_oc_fkm);
    assign n_fkm_lbv = {OCN{1'b1}};
    assign n_fkm_ready = t_fkm_ready & w_fkm_valid & w_fkm_last;

\js if (useCache) {

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'fkm',
	params: {
                depth:          1,
		width:		OCA,
                pipeForward:    "yes",
                pipeBackward:   "no",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_fkm_ready',
		in_valid:	'n_fkm_valid',
		in_data:	'n_fkm_oid',
		out_ready:	'n_fkm_ready',
		out_valid:	'w_fkm_valid',
		out_data:	'w_fkm_oid'
	},
	portsDelimiter: '\n\t'
})=\

\js } else {
      assign w_fkm_ready = n_fkm_ready;
      assign w_fkm_valid = n_fkm_valid;
      assign w_fkm_oid = n_fkm_oid;
\js }

    assign w_fkm_obv = {OCN{w_fkm_valid}} & ({{OCN-1{1'b0}}, 1'b1} << w_fkm_oid);
    wire [130-1:0] q_error_ns = ((| t_uerrs) | (| t_cerrs) | (| q_error[6+3-1:0])) ? {t_cinfo, t_uinfo, t_elog, t_eaddr, t_cerrs, t_uerrs} : q_error;
    \=u.dffre(130, `q_error`, `q_error_ns`, `130'd0`, `1'b1`, `clk_i`, `reset_ni`)=\
    assign {cinfo_o, uinfo_o, elog_o, eaddr_o, cerrs_o, uerrs_o} = q_error;

\js } else { // OTEN
    wire [129:0]	q_error;

    wire [130-1:0] q_error_ns = ((| t_uerrs) | (| t_cerrs) | (| q_error[6+3-1:0])) ? {t_cinfo, t_uinfo, t_elog, t_eaddr, t_cerrs, t_uerrs} : q_error;
    \=u.dffre(130, `q_error`, `q_error_ns`, `130'd0`, `1'b1`, `clk_i`, `reset_ni`)=\
    assign {cinfo_o, uinfo_o, elog_o, eaddr_o, cerrs_o, uerrs_o} = q_error;
    
assign n_ocr_valid = 1'b0;
assign n_ocr_lbv = n_odr_lbv;
assign n_ocr_ready = 1'b0;
assign w_ocr_ready = t_odr_ready;
assign w_ocr_valid = (| t_oc_rok);
assign w_ocr_oid = n_ocr_oid;
assign n_odr_obv = n_ocr_obv;
assign n_ocw_valid = 1'b0;
assign n_ocw_lbv = {OCN{n_odf_last}};
assign n_ocw_ready = 1'b0;
assign w_ocw_ready = w_odf_ready;
assign w_ocw_valid = (| t_oc_dtw);
assign w_ocw_oid = n_ocw_oid;
assign n_odf_obv = n_ocw_obv;
assign n_pw0_valid = 1'b0;
assign w_pw0_ready = n_pw0_ready;
assign w_pw0_valid = (| t_oc_wdone);
assign w_pw0_oid = n_pw0_oid;
assign w_pw0_obv = n_pw0_obv;
assign n_ocp_valid = 1'b0;
assign n_ocp_ready = w_str_rsp0_ready;
assign w_ocp_ready = n_ocp_ready;
assign w_ocp_valid = (| t_oc_stp);
assign w_ocp_oid = n_ocp_oid;
assign w_ocp_obv = n_ocp_obv;
assign n_fkm_valid = 1'b0;
assign n_fkm_lbv = {OCN{w_fkm_last}};
assign n_fkm_ready = t_fkm_ready;
assign w_fkm_ready = t_fkm_ready;
assign w_fkm_valid = (| t_oc_fkm);
assign w_fkm_oid = n_fkm_oid;
assign w_fkm_obv = n_fkm_obv;

\js } // OTEN


assign n_odr_lbv = {OCN{n_odr_last}} & n_odr_obv;

\=u.instance({
	moduleName: 'ioaiu_ror',
	instanceName: 'odr_dptr',
	params: {
		NUM:		OCN,
		DW:		OLA
        },
	ports: {
		vec_i:		't_odr_dptr',
		ror_o:		'w_odr_dptr'
	},
	portsDelimiter: '\n\t'
})=\

\js // Use ao_mux Lookups to help timing. 

\js // Write Bit AO Mux
\jsbegin
var write_ports = {};

for (let i=0; i<OCN ;i++) {
        write_ports['in'+i] = "~q_oc_write["+i+"]";
}

write_ports['sel']   = "n_odr_obv";
write_ports['out']   = "not_write_lookup";
\jsend  
  
wire not_write_lookup;

\=u.instance({
        instanceName: 'u_write_oid',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : OCN,
                        wMux             : 1
        },
        verilogParams: {},
        ports: write_ports
})=\

\js // NOR Beats AO Mux
\js for (let i=0; i<OCN ;i++) {
     wire not_or_beat_\=i=\ = ~| q_oc_beats[\=i=\];
\js }

\jsbegin
var no_beats_ports = {};

for (let i=0; i<OCN ;i++) {
        no_beats_ports['in'+i] = "not_or_beat_"+i;
}

no_beats_ports['sel']   = "n_odr_obv";
no_beats_ports['out']   = "no_beats_lookup";
\jsend  
  
wire no_beats_lookup;

\=u.instance({
        instanceName: 'u_no_beats_oid',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : OCN,
                        wMux             : 1
        },
        verilogParams: {},
        ports: no_beats_ports
})=\

\js // NOR Beats AO Mux
\jsbegin
var beats_ports = {};

for (let i=0; i<OCN ;i++) {
        beats_ports['in'+i] = "q_oc_beats["+i+"]";
}

beats_ports['sel']   = "n_odr_obv";
beats_ports['out']   = "beats_lookup";
\jsend  
  
wire [\=BWL-1=\:0] beats_lookup;

\=u.instance({
        instanceName: 'u_beats_oid',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : OCN,
                        wMux             : BWL
        },
        verilogParams: {},
        ports: beats_ports
})=\

assign n_odr_valid = w_ocr_valid;
assign n_odr_oid = w_ocr_oid;
assign n_odr_raddr = {w_odr_dptr, n_odr_offset[BWL-1:0]};
assign n_odr_track = t_oc_track[n_odr_oid];
assign n_odr_eob = q_oc_eob[n_odr_oid];
assign n_odr_id = q_oc_id[n_odr_oid];
assign n_odr_last = (q_odr_count_p1 == n_odr_beats);
assign n_odr_cmo = ~q_oc_write[n_odr_oid] & ~t_oc_bar[n_odr_oid][0] & (
                    q_oc_null[n_odr_oid] |
		    t_oc_dve[n_odr_oid] | t_oc_dvm[n_odr_oid] |		    //ACE DVM
		    ((t_oc_domain[n_odr_oid] < 2'h3) & 
			((t_oc_snoop[n_odr_oid]==4'h8) |    //CleanShared
			 (t_oc_snoop[n_odr_oid]==4'h9) |    //CleanInvalid
			 (t_oc_snoop[n_odr_oid]==4'ha) |    //CleanSharedPersist
			 (t_oc_snoop[n_odr_oid]==4'hd))) |  //MakeInvalid
		    (((t_oc_domain[n_odr_oid]==2'h1) | 
			  (t_oc_domain[n_odr_oid]==2'h2)) &
			((t_oc_snoop[n_odr_oid]==4'hb) |   //ACE CleanUnique
			 (t_oc_snoop[n_odr_oid]==4'hc)))); //ACE MakeUnique
assign n_odr_csr = (& q_oc_tin[n_odr_oid][TINW+1:TINW]);
assign n_odr_bar = t_oc_bar[n_odr_oid][0];

wire n_odr_first;
wire n_odr_first_ns = (n_odr_valid & n_odr_last) ? 1'b1 : n_odr_valid ? 1'b0 : n_odr_first;
\=u.dffre(1, `n_odr_first`, `n_odr_first_ns`, `1'b1`, `w_odr_ready`, `clk_i`, `reset_ni`)=\

wire top_bit_odr_resp = n_odr_first ? q_oc_status[n_odr_oid][7] : (q_oc_status[n_odr_oid]==8'h84) | q_oc_null[n_odr_oid];

wire [5:0] n_odr_resp_tmp = {t_oc_aresp[n_odr_oid],
		     top_bit_odr_resp,((q_oc_status[n_odr_oid]==8'h84)|(q_oc_status[n_odr_oid]==8'h87)|
						 (q_oc_lock[n_odr_oid] & !top_bit_odr_resp)),
		     n_odr_cmo, n_odr_csr};

assign n_odr_resp = n_odr_resp_tmp[ODPW-1:0] & ~{ODPW{n_odr_bar}};

assign n_odr_beats = {no_beats_lookup, beats_lookup};

assign n_odr_offset = ((q_oc_wrap[n_odr_oid] & ({{\=8-BWL=\{1'b0}},beats_lookup}==8'd2)) ?
			      {{\=CLO-ioaiu_pos(BWL-1)-1=\{1'b0}},q_oc_addr[n_odr_oid][\=AWL+1=\ +: \=ioaiu_pos(BWL-1)=\], (q_oc_addr[n_odr_oid][\=AWL=\ +: 1] + q_odr_count[0+:\=Math.min(1, ioaiu_pos(BWL-1))=\])}:
		       (q_oc_wrap[n_odr_oid] & ({{\=8-BWL=\{1'b0}},beats_lookup}==8'd4)) ?
			      {{\=CLO-ioaiu_pos(BWL-2)-2=\{1'b0}},q_oc_addr[n_odr_oid][\=AWL+2=\ +: \=ioaiu_pos(BWL-2)=\], (q_oc_addr[n_odr_oid][\=AWL=\ +: 2] +
\js if (2>ioaiu_pos(BWL-1)) {
                                                                                                                                                           {1'b0,q_odr_count[0+:\=Math.min(2, ioaiu_pos(BWL-1))=\]})}:
\js } else {
                                                                                                                                                                 q_odr_count[0+:\=Math.min(2, ioaiu_pos(BWL-1))=\])}:
\js }
		       (q_oc_wrap[n_odr_oid] & ({{\=8-BWL=\{1'b0}},beats_lookup}==8'd8)) ?
			      {{\=CLO-ioaiu_pos(BWL-3)-3=\{1'b0}},q_oc_addr[n_odr_oid][\=AWL+3=\ +: \=ioaiu_pos(BWL-3)=\], (q_oc_addr[n_odr_oid][\=AWL=\ +: 3] +
\js // var    64    128    256
\js // CLO     6      6      6
\js // AWL     3      4      5
\js // BWL     3      2      1

\jsbegin
// Would only happen for 32 bit bus or smaller
/* istanbul ignore else env ncore_3p7 */
    if (3>ioaiu_pos(BWL-1)) { \jsend
                                                                                                                                 {{\=3-ioaiu_pos(BWL-1)=\{1'b0}},q_odr_count[0+:\=Math.min(3, ioaiu_pos(BWL-1))=\]})}:
\js } else {
                                                                                                                                                                 q_odr_count[0+:\=Math.min(3, ioaiu_pos(BWL-1))=\])}:
\js }
		      	 ({{\=CLO-BWL=\{1'b0}},q_oc_addr[n_odr_oid][AWL +: BWL]} + {{\=CLO-BWL=\{1'b0}},q_odr_count})) &
		      ({CLO{1'b1}} >> AWL);

assign n_odr_adone = t_odr_ready & n_odr_valid & n_odr_last &
                     not_write_lookup;

assign q_odr_count_next = ((({1'b0,q_odr_count}+1'b1)==n_odr_beats) &
				n_odr_valid & t_odr_ready) ? {BWL{1'b0}} :
			       (n_odr_valid & t_odr_ready) ? q_odr_count + 1'b1:
							     q_odr_count;

\=u.dffre(BWL, `q_odr_count`, `q_odr_count_next`, `{`+BWL+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
wire [BWL+1-1:0] q_odr_count_p1_ns = {1'b0,q_odr_count_next}+1'b1;
\=u.dffre(BWL+1, `q_odr_count_p1`, `q_odr_count_p1_ns`, `{`+(BWL+1)+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

\=u.instance({
	moduleName: 'ioaiu_arbiter',
	instanceName: 'odf_arb',
	params: {
                DRST:           DRST,
                DW:             OCN,
                ATOMIC:         1,
                HP:             `{`+OCN+`{1'b0}}`,
		 assertOn: assertOn
	},
	ports: {
		clk_i:		'clk_i',
		reset_ni:	'reset_ni',
		ready_i:	'w_ocw_ready',
		bv_i:		't_oc_dtw',
		lv_i:		'n_ocw_lbv',
		winner_o:	'n_ocw_oid',
		wbv_o:		'n_ocw_obv'
	},
	portsDelimiter: '\n\t'
})=\

\js // Have to add blank beats for CONC-11485. Chaning q_oc_beats is too dangerous. 
wire [BWL+AWL-1:0] odf_data_accessed = {q_oc_beats[n_odf_oid][BWL-1:0], {AWL{1'b0}}};
wire             odf_single_beat   = (q_oc_beats_adj[n_odf_oid] == 5'd1);

wire             odf_is_incr = !q_oc_wrap[n_odf_oid];
wire             odf_is_excl = q_oc_lock[n_odf_oid];
wire             odf_is_atomic = |t_oc_atop[n_odf_oid];
wire             odf_eligible_to_modify = odf_is_incr & !odf_is_excl & !odf_is_atomic;

wire odf_accessed_16B = (odf_data_accessed <= 16);
wire odf_accessed_32B = (odf_data_accessed <= 32);

reg add_blank_beats;
reg add_double_blank_beats;

always @ (*) begin
      casez({odf_single_beat, odf_accessed_16B, odf_accessed_32B}) 
	3'b011  : begin
                     \js if (DW == 64) {
		     add_double_blank_beats = ((q_oc_addr[n_odf_oid][5:4] == 2'b01) & odf_eligible_to_modify);	     		                   
		     \js } else {
		     add_double_blank_beats = 1'h0;	     		                   		     
		     \js }
	             add_blank_beats = ((|q_oc_addr[n_odf_oid][3:0]) & odf_eligible_to_modify);
		  end
	3'b001  : begin
	             add_blank_beats = ((|q_oc_addr[n_odf_oid][4:0]) & odf_eligible_to_modify);
		     add_double_blank_beats = 1'h0;	     		                   		     		     
		  end
	default : begin
	             add_blank_beats =  1'b0;
		     add_double_blank_beats = 1'h0;	     		                   		     		     
		  end
      endcase
end

assign q_oc_beats_shift =
\js if (DW==64) {
                          (add_double_blank_beats) ? (q_oc_beats[n_odf_oid] << 2) :
\js }
                          ((add_blank_beats)        ? (q_oc_beats[n_odf_oid] << 1) : q_oc_beats[n_odf_oid]);

\js if (DW == 64) {
\js // There are cases where the number of beats needed is not a power of two (transactions to dii), however buffer beats are needed to make the number of outgoing beats a power of two to match smi_size.
\js // For 256b and 128b this can be taken care of by q_oc_line, however for 64b 3 beats needs to go up to 4. 5,6,7 will go up to 8 because of the q_oc_line mechanism

wire end_beat;
wire odd_beat_fill;

assign end_beat = (q_odf_count == 3); // End the 4th beat
assign odd_beat_fill = (q_oc_beats_shift == \=BWL=\'d3);
\js }

assign n_odf_last = (q_oc_line[n_odf_oid] 
		      ) ? (& q_odf_count) :
                    (| t_oc_atop[n_odf_oid]) ? 
			        (q_odf_count == (q_oc_beats[n_odf_oid] - 1'b1)):		      
\js if (DW == 64) {
		    (odd_beat_fill) ? end_beat: // (& q_odf_count) 
\js }
		    (q_odf_count == (q_oc_beats_shift - 1'b1));

\=u.instance({
	moduleName: 'ioaiu_ror',
	instanceName: 'odf_dptr',
	params: {
		NUM:		OCN,
		DW:		OLA
        },
	ports: {
		vec_i:		't_odf_dptr',
		ror_o:		'w_odf_dptr'
	},
	portsDelimiter: '\n\t'
})=\

assign n_odf_valid = w_ocw_valid;
assign n_odf_oid_bv = n_odf_obv;
assign n_odf_oid = w_ocw_oid;
assign n_odf_raddr = {w_odf_dptr, t_odf_count};
wire t_odf_count_carry;
assign {t_odf_count_carry,t_odf_count} = {1'b0,q_odf_count} + {1'b0,q_oc_addr[n_odf_oid][CLO-1:AWL]};
assign n_odf_count = q_odf_count;

   wire [BWL-1:0] q_odf_count_p1;
   wire q_odf_count_carry;
   assign {q_odf_count_carry,q_odf_count_p1} = {1'b0,q_odf_count} + 1'b1;
wire [BWL-1:0] q_odf_count_ns = (n_odf_last & n_odf_valid & w_odf_ready) ? {BWL{1'b0}} : (n_odf_valid & w_odf_ready) ? q_odf_count_p1: q_odf_count;
\=u.dffre(BWL, `q_odf_count`, `q_odf_count_ns`, `{`+BWL+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

assign t_init_valid = ~q_reset_n & ~t_cfg_init;

\=u.instance({
	moduleName: 'ioaiu_buf',
	instanceName: 'od',
	params: {
		 DRST: DRST,
		 XO: XO,
                 halfSpeed: halfSpeedOD,
                 WIE: halfSpeedOD,
		 ODDW: ODDW,
		 BAW: ODAW,
                 BANKS: ODB,
                 DEPTH: ODN,
                 WIDTH: ODDRW,
                 MEMORY: 1,
                 WN: 4,
                 RN: ODRN,
		 QBE:	1,
		 QNE:	1,
		 OD_TIMING_FIX:	enSRAMPipe|halfSpeedOD,
		 EE:	ODEE,
		 EW:	ODEW,
		 EEN:	ODEE?1:0,
                 IES:    ODIES,
                 IWS:    ODIWS,
		 IW:	ODIW,
		 assertOn: assertOn
		 },
	ports: {
	clk_i:		'clk_i',
	clk_i_ng:	'clk_i_ng',
	reset_ni:	'reset_ni',
	wn_ready_o:	'{w_init_ready, n_adw_ready, n_sod_ready, n_co_ready}',
	wn_valid_i:	'{t_init_valid, w_adw_valid, w_sod_valid, w_co_valid}',
	wn_waddr_i:	`{q_init_count, t_adw_waddr, w_sod_waddr, t_co_waddr}`,
	wn_wdata_i:	`{{DWP{1'b0}}, {BW{1'b0}}, {DW{1'b0}}, 
		          t_adw_poison, w_adw_be, t_adw_wdata,
	          	  w_sod_poison, w_sod_be, w_sod_wdata,
		          w_co_poison, w_co_be, w_co_rdata}`, 
	rn_ready_o:	'w_rn_ready',
	rn_valid_i:	'n_rn_valid',
	rn_raddr_i:	'n_rn_raddr',
	rn_info_i:	'n_rn_info',
	rn_ready_i:	'n_rn_ready',
	rn_valid_o:	'w_rn_valid',
	rn_rdata_o:	'w_rn_rdata',
	rn_info_o:	'w_rn_info',
	rn_busy_o:	'',
	od_sram_we_o:	'od_we_o',
	od_sram_waddr_o:	'od_waddr_o',
	od_sram_wdata_o:	'od_wdata_o',
	od_sram_wecc_o:	'od_wecc_o',
	od_sram_re_o:	'od_re_o',
	od_sram_raddr_o:	'od_raddr_o',
	od_sram_rdata_i:	'od_rdata_i',
	od_sram_recc_i:	'od_recc_i',
	error_en_i:	`{1'b1,          1'b1         }`,
	error_o:	`{t_uerrs[0],		t_cerrs[0]}`,
	elog_o:		't_elog'
	},
	portsDelimiter: '\n\t'

})=\
assign n_odf_pad = {ODIW-ODFIW{1'b0}};
assign n_odr_pad = {ODIW-ODRIW{1'b0}};
assign n_odm_pad = {ODIW{1'b0}};
assign n_odw_pad = {ODIW-ODWIW{1'b0}};

assign t_odw_poison = w_odw_poison;
assign t_odf_poison = w_odf_poison;
assign t_odr_poison = w_odr_poison;
assign t_odm_poison = w_odm_poison;

\js if (useCache>0) {
wire		w_rr_ready;
wire		n_rr_valid;
wire [AW-1:0]	n_rr_addr;
wire [7:0]	n_rr_len;
wire [2:0]	n_rr_size;
wire [1:0]	n_rr_burst;
wire		n_rr_lock;
wire [3:0]	n_rr_cache;
wire [2:0]	n_rr_prot;
wire [RW-1:0]	n_rr_region;
wire [QW-1:0]	n_rr_qos;
wire [IW-1:0]	n_rr_id;
wire [MW-1:0]	n_rr_bar;
wire [SW-1:0]	n_rr_snoop;
wire [MW-1:0]	n_rr_domain;
wire [AXUW-1:0] n_rr_user;
wire [AXKW-1:0] n_rr_track;
wire [3:0]      n_rr_vmidext;
wire            n_rr_up;
wire [1:0]      n_rr_upmatch;
wire [AWTW-1:0]	n_rr_atop;
wire [AWSW-1:0]	n_rr_stashid;
wire		n_rr_write;
wire		n_rr_trace;
wire		n_rr_snp;
wire [1:0]	n_rr_cmr;
wire		n_rr_wake;
wire [XTA-1:0]	n_rr_kid;
wire		n_rr_partial;
wire [2:0]	t_rr_sel;
wire [OCN-1:0]	t_oc_cft, t_c1_set_collision, t_oc_ebv;
wire		t_pt_set_collision;
wire [OCA-1:0]	w_cfd_oid;
wire		w_cfd_done;
wire		w_cft_ready;
wire		n_cft_valid;
wire [CSW-1:0]	n_cft_state, n_moesi_state;
wire [OCA-1:0]	w_cft_oid, w_oc_ehid;
wire [OCN-1:0]	w_cft_obv;
wire		w_c2_alloc;
wire [7:0]	t_c2_scmd;
wire [CWW-1:0]	w_c2_way;
wire [WAYS-1:0]	n_c2_cbusy;
wire [OCN-1:0]	t_c1_cbusy[WAYS-1:0];
wire		w_of_ready;
wire		n_of_valid;
wire [BWL-1:0]	n_of_count;
wire		n_of_last;
wire [OCA-1:0]	n_of_oid;
wire [DWP-1:0]	n_of_poison;
wire [DW-1:0]	n_of_rdata;
wire [BW-1:0]	n_of_be;
wire		w_wf_ready,	n_wf_ready;
wire				w_wf_valid;
wire		w_fqm_ready,	n_fq_ready,	w_cfd_ready;
wire		n_fqm_valid,	w_fq_valid,	n_cfd_valid, n_cfd_full;
wire				w_fq_dirty;
wire [OCA-1:0]					n_cfd_oid;
wire [BWL-1:0]			w_fq_count;
wire [BWL-1:0]			w_fq_offset,	n_cfd_offset;
wire [DWP-1:0]			w_fq_poison,	n_cfd_poison;
wire [DW-1:0]			w_fq_rdata,	n_cfd_rdata;
wire [BW-1:0]					n_cfd_be;
wire						n_cfd_last;
wire				t_fq_merge;
wire				t_fq_drop;
wire		n_wq_valid;
wire [CTW-1:0]	w_p0_cset, w_p1_cset, w_pt_cset, w_oc_cset[OCN-1:0];

wire [OCN-1:0]	q_oc_wfcft, q_oc_chit, q_oc_wfupr, q_oc_str_err, q_oc_str_err_in;
wire [OCN-1:0]	q_oc_wfcft_ns, q_oc_chit_ns, q_oc_wfupr_ns;

wire [OCN-1:0]  q_oc_wfcfd, q_oc_evict, q_oc_cmr;
wire [OCN-1:0]  q_oc_wfcfd_ns, q_oc_evict_ns, q_oc_cmr_ns;
wire [OCN-1:0]  q_oc_wfcwd;
wire [OCN-1:0]  q_oc_wfcwd_ns;

wire [CWW-1:0]	q_oc_way [OCN-1:0];
wire [CWW-1:0]	q_oc_way_ns [OCN-1:0];
wire [2:0]	q_oc_dstate[OCN-1:0];
wire [2:0]	q_oc_dstate_ns[OCN-1:0];
\js for (let i=0;i<OCN;i++) {
wire q_oc_wfcfd\=i=\;
assign q_oc_wfcfd[\=i=\] = q_oc_wfcfd\=i=\;
wire q_oc_wfcwd\=i=\;
assign q_oc_wfcwd[\=i=\] = q_oc_wfcwd\=i=\;
wire q_oc_cmr\=i=\;
assign q_oc_cmr[\=i=\] = q_oc_cmr\=i=\;
wire [CWW-1:0] q_oc_way\=i=\;
assign q_oc_way[\=i=\] = q_oc_way\=i=\;
wire q_oc_evict\=i=\;
assign q_oc_evict[\=i=\] = q_oc_evict\=i=\;
wire q_oc_str_err\=i=\;
assign q_oc_str_err[\=i=\] = q_oc_str_err\=i=\;
wire q_oc_wfcft\=i=\;
assign q_oc_wfcft[\=i=\] = q_oc_wfcft\=i=\;
wire q_oc_chit\=i=\;
assign q_oc_chit[\=i=\] = q_oc_chit\=i=\;
wire q_oc_wfupr\=i=\;
assign q_oc_wfupr[\=i=\] = q_oc_wfupr\=i=\;
wire [2:0]	q_oc_dstate\=i=\;
assign q_oc_dstate[\=i=\] = q_oc_dstate\=i=\;
\js }
wire [OCA:0]	q_oc_ecount;
wire [BWL-1:0]	q_cdr_count;
wire [BWL:0]	q_odw_count;
wire [BWL-1:0]	q_odw_offset;
wire [3:0]	q_pvc_count;
wire [WAYS-1:0]	q_c2_cbusy;
wire [BWL-1:0]	q_ce_count;
wire		q_cmr_last;
wire		q_pe_correctable_error,	q_p1_correctable_error,	q_p2_correctable_error;
wire [OCA-1:0]			q_p1_skid;

\=u.instance({
	moduleName: 'ioaiu_mux',
	instanceName: 'of_mux',
	params: {
		NUM:		'2',
		DW:		ODFIW+DW+BW+DWP,
                clkAssertInterface : clkAssertInterface,
				assertOn: assertOn
	},
	verilogParams: {
	},
	ports: {
		ready_o:	'{n_odf_ready,  n_cs_ready}',
		valid_i:	'{w_odf_valid,  w_cs_valid}',
		data_i:		`{{w_odf_oid, w_odf_count, w_odf_last, 
				   t_odf_poison, w_odf_be, w_odf_rdata}, 
				  {{OCA{1'b0}}, w_cs_count, w_cs_last, 
				   w_cs_poison, w_cs_be, w_cs_rdata}}`,
		ready_i:	'w_of_ready',
		valid_o:	'n_of_valid',
		data_o:		`{n_of_oid, n_of_count, n_of_last, 
				  n_of_poison, n_of_be, n_of_rdata}`,
		bvsel_i:	't_of_sel[1:0]'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

\=u.instance({
	moduleName: 'ioaiu_arbiter',
	instanceName: 'of_arb',
	params: {
                DRST:           DRST,
                DW:             2,
                ATOMIC:         1,
                HP:             `2'h1`,
                VAL:            1,
                NO_WINNER_OUT:  1,
		 assertOn: assertOn
	},
	ports: {
		clk_i:		'clk_i',
		reset_ni:	'reset_ni',
		ready_i:	'n_of_ready',
		bv_i:		'{w_odf_valid,  w_cs_valid}',
		lv_i:		'{w_odf_last,   w_cs_last}',
		wbv_o:		't_of_sel[1:0]'
	},
	portsDelimiter: '\n\t'
})=\
assign t_of_sel[2] = 1'b0;

assign w_of_ready = n_of_ready;
assign w_of_valid = n_of_valid;
assign {w_of_oid, w_of_count, w_of_last,
                                  w_of_poison, w_of_be, w_of_rdata} = {n_of_oid, n_of_count, n_of_last,
                                  n_of_poison, n_of_be, n_of_rdata};


assign n_oc_eptr = w_oc_eval ? w_oc_eptr : q_oc_wptr;

\=u.instance({
	moduleName: 'ioaiu_enc',
	instanceName: 'ocefree',
	params: {
                DW:             OCN,
                BE:             1,
                NO_BV_OUT:      1,
                clkAssertInterface : clkAssertInterface,
		assertOn: assertOn
	},
	ports: {
		bv_i:		't_oc_free',
		valid_o:	'w_oc_eval',
		index_o:	'w_oc_eptr'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\
assign t_oc_ebv = q_oc_val & q_oc_evict & q_oc_itail & q_oc_wfdtr;


\=u.instance({
	moduleName: 'ioaiu_enc',
	instanceName: 'ocetail',
	params: {
                DW:             OCN,
                BE:             0,
                NO_BV_OUT:      1,
                clkAssertInterface : clkAssertInterface,
		assertOn: assertOn
	},
	ports: {
		bv_i:		't_oc_ebv',
		valid_o:	'w_oc_ehit',
		index_o:	'w_oc_ehid'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\
assign t_oc_ehid = w_oc_ehit ? w_oc_ehid : n_oc_eptr;

\=u.instance({
	moduleName: 'ioaiu_ohenc',
	instanceName: 'ocehead',
	params: {
                 VW:       OCN,
                BW:        OCA},
	ports: {
		vec_i:		't_oc_ce',
		bin_o:		'w_co_oid'
	},
	portsDelimiter: '\n\t'
})=\
assign w_co_obv = t_oc_ce;


assign t_pvc_throttle = w_pvc_valid & 
			(w_p2_valid ? ((~| t_pvc_count) & ((~| t_cfg_pvc) | 
						     (w_p1_valid & (P1EN>0)))) :
				      ~w_cmd_req0_ready);

\=u.instance({
	moduleName: 'ioaiu_arbiter',
	instanceName: 'ocwakec',
	params: {
                DRST:           DRST,
                DW:             OCN,
                ATOMIC:         0,
                HP:             `{`+OCN+`{1'b0}}`,
                VAL:            1,
		 assertOn: assertOn
		 },
	ports: {
		clk_i:		'clk_i',
		reset_ni:	'reset_ni',
                ready_i:        'w_ppvc_ready',
		bv_i:		't_oc_wfcmd',
		lv_i:		`{OCN{1'b1}}`,
                winner_o:       'n_ppvc_oid',
                wbv_o:          'n_ppvc_obv'
	},
	portsDelimiter: '\n\t'
})=\

/////////////////////////////////////////
wire [OCN*AW-1:0] addr_ports;
wire [OCN-1:0] sec_ports;

\js for (let i=0; i<OCN; i=i+1) {
assign addr_ports[\=i*AW=\ +: AW] = q_oc_addr[\=i=\];
\js }
assign sec_ports = q_oc_security;

\=u.instance({
        moduleName: 'ioaiu_aomux',
	instanceName: 'u_pvc_addr',
        params: {
                clkAssertInterface : clkAssertInterface,
		NUM:      OCN,
                DW:       AW,
		assertOn: assertOn
        },
        ports: {
		data_o:         'n_pvc_addr',
		bvsel_i:        'n_pvc_obv',
		data_i:         'addr_ports'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

\=u.instance({
        moduleName: 'ioaiu_aomux',
	instanceName: 'u_pvc_sec',
        params: {
                clkAssertInterface : clkAssertInterface,
		NUM:      OCN,
                DW:       1,
		assertOn: assertOn
        },
        ports: {
		data_o:         'n_pvc_security',
		bvsel_i:        'n_pvc_obv',
		data_i:         'sec_ports'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

/////////////////////////////////////////
assign n_ppvc_valid = (| t_oc_wfcmd);

\=u.instance({
        moduleName: 'rdy_vld_pipe',
        instanceName: 'ppvc',
        params: {
                depth:          1,
                width:          OCN+OCA,
                pipeForward:    "yes",
                pipeBackward:   "no",
                simplePipe:     "no",
                circular:       "no"
                 },
        verilogParams: {
        },
        ports: {
                clk:          'clk_i',
                reset_n:       'reset_ni',
                in_ready:     'w_ppvc_ready',
                in_valid:     'n_ppvc_valid',
                in_data:     `{n_ppvc_oid,n_ppvc_obv}`,
                out_ready:     'w_pvc_ready & ~w_p1_valid',
                out_valid:     'n_pvc_valid',
                out_data:     `{n_pvc_oid,n_pvc_obv}`
        },
        portsDelimiter: '\n\t'
})=\

assign n_pvc_ready = w_cmd_req0_ready & ~w_p2_valid & t_pt_ok & w_pvc_valid;
\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'pvc',
	params: {
                depth:          1,
		width:		1+AW+OCA,
                pipeForward:    "yes",
                pipeBackward:   "no",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_pvc_ready',
                in_valid:     'n_pvc_valid & ~w_p1_valid',
		in_data:	`{n_pvc_security, n_pvc_addr, n_pvc_oid}`,
		out_ready:	'n_pvc_ready',
		out_valid:	'w_pvc_valid',
		out_data:	`{w_pvc_security, w_pvc_addr, w_pvc_oid}`
	},
	portsDelimiter: '\n\t'
})=\

assign t_oc_cft = q_oc_val & q_oc_wfcft & ~q_oc_wfcfd & ~q_oc_wfstr & 
                                          ~(cft_obv_o & {OCN{cft_valid_o}}) &
					  ~q_oc_wfdtw & ~q_oc_wfdtp;
assign n_cft_state = 
\jsbegin
// 3.7 and prior is always moesi
/* istanbul ignore else env ncore_3p7 */
    if (COH_MOESI) { \jsend
                     n_moesi_state;
\js } else {
                     {CSW{XO}};
\js }
assign n_moesi_state = t_oc_str_err[w_cft_oid] ? CST_IX :
                       q_oc_write[w_cft_oid] ? CST_UD : t_oc_dstate[w_cft_oid];

\=u.instance({
	moduleName: 'ioaiu_enc',
	instanceName: 'cft',
	params: {
                DW:             OCN,
                BE:             0,
                clkAssertInterface : clkAssertInterface,
		assertOn: assertOn
	},
	ports: {
		bv_i:		't_oc_cft',
		valid_o:	'n_cft_valid',
		index_o:	'w_cft_oid',
		bv_o:		'w_cft_obv'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

\jsbegin
// pipe was added on 3.6 for timing */
/* istanbul ignore else env ncore_3p6,ncore_3p7 */
    if (1) { \jsend
\=u.instance({
        moduleName: 'rdy_vld_pipe',
        instanceName: 'cft_pipe',
        params: {
                depth:          1,
                width:          AW+CSW+1+CWW+OCN,
                pipeForward:    "yes",
                pipeBackward:   "no",
                simplePipe:     "no",
                circular:       "no"
                 },
        verilogParams: {
        },
        ports: {
                clk:          'clk_i',
                reset_n:       'reset_ni',
                in_ready:     'cft_ready',
                in_valid:     'cft_valid',
                in_data:     `{cft_addr,cft_state,cft_security,cft_way,w_cft_obv}`,
                out_ready:     'cft_ready_i',
                out_valid:     'cft_valid_o',
                out_data:     `{cft_addr_o,cft_state_o,cft_security_o,cft_way_o,cft_obv_o}`
        },
        portsDelimiter: '\n\t'
})=\
\js } else {
assign {cft_addr_o,cft_state_o,cft_security_o,cft_way_o,cft_obv_o} = {cft_addr,cft_state,cft_security,cft_way,w_cft_obv};
assign cft_valid_o = cft_valid;
assign cft_ready = cft_ready_i;
\js }

\js fqDepth = (BWL==1)?6:(BWL==2)?8:16;
wire [\=fqDepth-1=\:0] fq_valids;
wire w_fq_af = fq_valids[\=fqDepth-Math.pow(2,BWL)=\];

assign n_fq_ready = w_wf_ready;
\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'fq',
	params: {
                depth:          fqDepth,
		width:		1+BWL+1+OCA+BWL+DW+DWP,
                pipeForward:    "yes",
                pipeBackward:   "yes",
                exposeValids:   "true",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
                valids:         'fq_valids',
		in_ready:	'w_fq_ready',
		in_valid:	'n_fq_valid',
		in_data:	`{w_srd_fkm,q_srd_count, t_srd_dirty, w_srd_oid, 
				  t_srd_offset[BWL-1:0], 
				  w_dtr_req_rx_poison, w_dtr_req_rx_data}`,
		out_ready:	'n_fq_ready',
		out_valid:	'w_fq_valid',
		out_data:	`{w_fq_fkm, w_fq_count, w_fq_dirty, w_fq_oid, 
				  w_fq_offset, w_fq_poison, w_fq_rdata}`
	},
	portsDelimiter: '\n\t'
})=\

assign t_fq_merge = w_fq_valid & q_oc_write[w_fq_oid] & ((~| q_oc_beats[w_fq_oid]) |
		    ((q_oc_wrap[w_fq_oid] & (q_oc_beats_adj[w_fq_oid]==5'd2)) ? ((w_fq_offset>>1) == (q_oc_addr[w_fq_oid][AWL+:BWL]>>1)) :
		     (q_oc_wrap[w_fq_oid] & (q_oc_beats_adj[w_fq_oid]==5'd4)) ? ((w_fq_offset>>2) == (q_oc_addr[w_fq_oid][AWL+:BWL]>>2)) :
		     (q_oc_wrap[w_fq_oid] & (q_oc_beats_adj[w_fq_oid]==5'd8)) ? ((w_fq_offset>>3) == (q_oc_addr[w_fq_oid][AWL+:BWL]>>3)) :
		     (q_oc_wrap[w_fq_oid] & (q_oc_beats_adj[w_fq_oid]==5'd16))? ((w_fq_offset>>4) == (q_oc_addr[w_fq_oid][AWL+:BWL]>>4)) :
							 ((w_fq_offset - q_oc_addr[w_fq_oid][AWL +: BWL]) < q_oc_beats[w_fq_oid])));
assign n_odm_ready = w_fqm_ready & t_fq_merge;
assign n_fqm_valid = w_odm_valid | ~t_fq_merge;

\=u.instance({
	moduleName: 'ioaiu_combine',
	instanceName: 'wf',
	params: {
                 clkAssertInterface : clkAssertInterface,
                 DW:             2,
                 assertOn : assertOn
        },
	ports: {
		ready_o:	'{w_fqm_ready, w_wf_ready}',
		valid_i:	'{n_fqm_valid, w_fq_valid}',
		ready_i:	'n_wf_ready',
		valid_o:	'w_wf_valid'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

assign n_wf_ready = w_cfd_ready;
assign n_cfd_valid = w_wf_valid;

assign n_cfd_full = ~(q_oc_write[w_fq_oid] & q_oc_partial[w_fq_oid]);

assign t_fq_drop = w_fq_valid & q_oc_write[w_fq_oid] & 
				(q_oc_dstate[w_fq_oid] == CST_SD);


assign n_cfd_poison = t_fq_merge ? (( t_odm_poison ) | 
				    ( w_fq_poison & ~{DWP{w_fq_fkm}} & ~{DWP{(&w_odm_be)}})) :
				   w_fq_poison;
\js for (let i=0; i<(DW/8); i=i+1) {
assign n_cfd_rdata[\=i=\*8 +: 8] = 
		({8{t_fq_merge & w_odm_be[\=i=\]}} & w_odm_rdata[\=i=\*8 +: 8]) |
		({8{~(t_fq_merge & w_odm_be[\=i=\])}} & w_fq_rdata[\=i=\*8 +: 8]);
\js }
assign n_cfd_be = ~t_fq_drop ? {BW{1'b1}} :
		  t_fq_merge ? w_odm_be :
			       {BW{1'b0}};
assign n_cfd_last = (& w_fq_count);

assign n_cfd_offset = w_fq_offset;
assign n_cfd_oid = w_fq_oid;


\=u.instance({
	moduleName: 'ioaiu_cache',
	instanceName: 'ioaiu_cache',
	params: {
		 DRST: DRST,
		 CTW: CTW,
		 BANKS:	CTB,
		 WAYS:	WAYS,
                 CKB: CKB,
		 DW: DW,
		 WAYS: WAYS,
		 WW: CWW,
		 CSW: CSW,
		 XO: XO,
		 EID: BPL+9,
		 EIW: 1+STA+1+2,
		 CIW: AXKW+OCA+BWL+BWL+IW+ARPW+1,
		 assertOn: assertOn,
		 usePLRU: usePLRU,
		 cmType: cmType,
                 COH_MSI:        COH_MSI,
                 COH_MEI:        COH_MEI,
                 COH_MOESI:      COH_MOESI,
                 CST_IX:         CST_IX,
                 CST_SC:         CST_SC,
                 CST_SD:         CST_SD,
                 CST_UC:         CST_UC,
                 CST_UD:         CST_UD,
		 useOwnerTransfer: useOwnerTransfer
		 },
	verilogParams: {
	},
	ports: {
	clk_i:		'clk_i',
	reset_ni:	'reset_ni',
	cfg_alloc_i:	'cfg_alloc_i',
	ccp_ready_i:	'ccp_ready_i',
	p0_af_o:	'w_c0_af',
	p0_ready_i:	'cp0_ready_i',
	p0_ready_o:	'w_c1_ready',
	p0_valid_i:	't_c0_sel[1]',
	p0_wr_i: 	'n_p1_write',
	p0_pl_i: 	'(n_p1_write & n_p1_partial) | n_p1_snp',	
	p0_valid_o:	'cp0_valid_o',
	p0_index_i:	'w_p0_cset',
	p2_scmd_i:	't_c2_scmd',
	p2_write_i:	'w_pt_write',
	p2_cmr_i:	'w_pt_cmr',
	p2_partial_i:	'(w_pt_write & t_pt_partial) | w_pt_snp',
	p2_rinfo_i:	`{w_pt_track, t_pt_oid, 
			  t_c2_offset,t_c2_drop, t_c2_eob, w_pt_id, t_c2_resp, 1'b0}`,
	p2_cancel_i:	't_c2_cancel',
	p2_cancel_alloc_i: 't_c2_cancel_alloc',
	p2_delay_i:	't_c2_delay',
	p2_lookup_i:	't_c2_lookup',
	p2_nc_i:	'w_amc_nc',
	p2_alloc_o:	'w_c2_alloc',
	p2_rd_o:	'cp2_rd_o',
	p2_wr_o:	'n_wq_valid',
	p2_port_o:	'cp2_port_o',
	p2_lru_o:	'cp2_lru_o',
	p2_update_o:	'cp2_update_o',
	p2_nstate_o:	'cp2_nstate_o',
	p2_valid_o:	'w_c2_valid',
	p2_hit_o:	'w_c2_chit',
	p2_way_o:	'w_c2_way',
	p2_retry_o:	'w_c2_retry',
	p2_cache_o:	'w_c2_room',
	p2_done_o:	'w_c2_done',
	p2_evict_i:	'cp2_evict_i',
	p2_estate_i:	't_c2_estate',
	p2_valid_i:	't_c2_valid',
	p2_cstate_i:	'cp2_cstate_i',
	p2_cnru_i:	'cp2_cnru_i',
        p2_upmatch_i:   't_c2_upmatch_i',
        p2_up_i:        't_c2_up_i',
	p2_hits_i:	'cp2_hits_i',
	p2_ways_i:	'cp2_ways_i',
	p2_nacks_i:	't_c2_nacks',
	p2_nacks_raw_i:	'cp2_nacks_i',	
	p2_evict_o:	'w_c2_evict',
	p2_flush_o:	'w_c2_flush',
	p2_sndtr_o:	'w_c2_sndtr',
	p2_sndtw_o:	'w_c2_sndtw',
	p2_cstate_o:	'w_c2_state',
	p2_sinfo_i:	`{w_pt_track[0], w_pt_kid[STA-1:0], w_pt_security, w_c2_sndtw, w_c2_sndtr}`,
	ce_af_o:	'w_ce_af',
	ce_ready_i:	'w_ce_ready',
	ce_valid_i:	'n_ce_valid',
	ce_last_i:	'n_ce_last',
	ce_info_o:	`{w_cs_trace, w_cs_sid, w_cs_security, w_cs_sndtw, w_cs_sndtr}`,
	ce_evict_o:	'w_ce_evict',
	cd_ready_o:	'ccd_ready_o',
	cd_valid_i:	'ccd_valid_i',
	cd_ready_i:	'n_cdr_ready',
	cd_valid_o:	'w_cdr_valid',
	cd_last_i:	'ccd_last_i',
	cd_info_o:	`{w_cdr_track, w_cdr_oid, w_cdr_offset,
			  w_cdr_drop, w_cdr_eob, w_cdr_id, w_cdr_resp, w_cdr_err}`,
			  
 	pmon_cache_r_hit:	'pmon_cache_r_hit',
	pmon_cache_w_hit:	'pmon_cache_w_hit',
	pmon_cache_s_hit:	'pmon_cache_s_hit',
	pmon_cache_evict:	'pmon_cache_evict',
	pmon_no_ways:		'pmon_no_ways',
	pmon_cache_f_stall:	'pmon_cache_f_stall',
	pmon_cache_r_stall:	'pmon_cache_r_stall',
	pmon_cache_w_stall:	'pmon_cache_w_stall',
	pmon_cache_replay:	'pmon_cache_replay',
	pmon_cache_r_miss:	'pmon_cache_r_miss',
	pmon_cache_w_miss:	'pmon_cache_w_miss',
	pmon_cache_s_miss:	'pmon_cache_s_miss'
	
	},
	portsDelimiter: '\n\t'
})=\
assign cp0_addr_o = w_p0_addr;
assign cp0_security_o = w_p0_prot[1];
assign cp2_len_o = t_c2_len[BWL-1:0];
assign cp2_busy_o = q_c2_cbusy;
assign cp2_setw_o = w_p2_valid & (((& w_pt_cmr) & w_pt_write) | 
				  (w_pt_cmr==2'h2));
assign cp2_wayn_o = w_pt_len[5:0];

\jsbegin
// CTW is log2(nSets), so would never be 2^20
/* istanbul ignore else env ncore_3p7 */
    if(CTW<20) { \jsend
	assign cp2_setn_o = {{20-CTW{1'b0}}, w_pt_cset};
\js } else {
	assign cp2_setn_o = w_pt_cset[19:0];
\js }

wire evict_fifo_ready;

assign cce_ready_o = evict_fifo_ready; //w_ce_ready;

\js // CONC-10121 - This FIFO is used to prevent a deadlock condition where the outgoing Snoop data can be blocked from an incoming DTR.
\js // Needs to hold all data for transactions in evict data info fifo inside ioaiu cache

\=u.instance({
        'portsDelimiter': '\n    ',
        'instanceName': 'u_snp_data_fifo',
        'moduleName':   'rdy_vld_pipe',
        'params': {
                 "pipeForward"  : "no",
                 "pipeBackward" : "no",
                 "simplePipe"   : "no",
                 "circular"     : "no",
                 "width"        : evictDataFifoWidth,
                 "depth"        : evictDataFifoDepth
              },
        'verilogParams': {},
        'ports':{
          clk        : 'clk_i',
          reset_n    : 'reset_ni',
          in_valid   : 'cce_valid_i',
          in_data    : '{cce_last_i, cce_rdata_i, cce_be_i, cce_poison_i}',
          in_ready   : 'evict_fifo_ready',
          out_valid  : 'n_ce_valid',
          out_data   : '{n_ce_last, n_ce_rdata, n_ce_be,n_ce_poison}',
          out_ready  : 'w_ce_ready'
        }
})=\

assign w_ce_ready = (n_ce_valid & w_ce_evict) ? n_co_ready : n_cs_ready;

assign w_co_valid = n_ce_valid & w_ce_evict;
assign {w_co_count, w_co_poison, w_co_last, w_co_be, w_co_rdata} =
       {q_ce_count, n_ce_poison, n_ce_last, n_ce_be, n_ce_rdata};

assign w_cs_valid = n_ce_valid & ~w_ce_evict;
assign {w_cs_count, w_cs_poison, w_cs_last, w_cs_be, w_cs_rdata} =
       {q_ce_count, n_ce_poison, n_ce_last, n_ce_be, n_ce_rdata};

assign t_ce_sel = {2{n_ce_valid}} & {w_ce_evict, ~w_ce_evict};

\=u.instance({
	moduleName: 'ioaiu_ror',
	instanceName: 'co_dptr',
	params: {
		NUM:		OCN,
		DW:		OLA
        },
	ports: {
		vec_i:		't_co_dptr',
		ror_o:		'w_co_dptr'
	},
	portsDelimiter: '\n\t'
})=\
assign t_co_waddr = {w_co_dptr, w_co_count};

assign w_cfd_ready = cfd_ready_i;
assign cfd_valid_o = n_cfd_valid;
assign cfd_full_o = n_cfd_full;
assign cfd_poison_o = n_cfd_poison;
assign cfd_data_o = n_cfd_rdata;
assign cfd_be_o = n_cfd_be;
assign cfd_way_o = q_oc_way[n_cfd_oid];
assign cfd_last_o = n_cfd_last;
assign cfd_beat_o = n_cfd_offset;
assign cfd_addr_o = n_cfd_valid ? q_oc_addr[n_cfd_oid] : {AW{1'b0}}; //CCP Xprop
assign cfd_oid_o = n_cfd_oid;
assign w_cfd_done = cfd_done_i;
assign w_cfd_oid = cfd_nid_i;

assign w_cft_ready = cft_ready;
assign cft_valid = n_cft_valid;
assign cft_state = n_cft_state;
assign cft_addr = q_oc_addr[w_cft_oid];
assign cft_security = q_oc_security[w_cft_oid];
assign cft_way = q_oc_way[w_cft_oid];

assign w_cdr_poison = ccd_poison_i;
assign w_cdr_rdata = ccd_rdata_i;
assign w_cdr_last = ccd_last_i;

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'ccw',
	params: {
                depth:          1,
		width:		BWL+1+DWP+BW+DW,
                pipeForward:    "no",
                pipeBackward:   "yes",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'n_odw_ready',
		in_valid:	'w_odw_valid',
		in_data:	`{w_odw_offset, w_odw_last,
				  t_odw_poison, w_odw_be, w_odw_rdata}`,
		out_ready:	'ccw_ready_i',
		out_valid:	'ccw_valid_o',
		out_data:	`{ccw_offset_o, ccw_last_o, 
				  ccw_poison_o, ccw_be_o, ccw_wdata_o}`
	},
	portsDelimiter: '\n\t'
})=\

assign n_rpt_valid = (w_c2_valid & w_c2_retry & ~t_c2_cancel) |
		     (w_c2_valid & w_pt_cmr[1] & t_c2_cancel) |
		     (w_p1_valid & w_p2_valid & t_pt_correctable_error);
\js if(XTA>OCA) {
	assign n_rpt_kid = (w_pt_wake | (w_pt_snp)) ? w_pt_kid : {{XTA-OCA{1'b0}},q_oc_wptr};
\js } else {
	assign n_rpt_kid = (w_pt_wake | (w_pt_snp)) ? w_pt_kid : q_oc_wptr;
\js }
assign n_rpt_wake = ~(w_pt_snp) & ~w_pt_cmr[1];

assign cmr_done_o = (~| (q_oc_val & t_oc_cmr)) & (q_cmr_last |
						  (w_pt_valid & w_pt_cmr[1] & 
						  ~w_c2_evict & w_pt_lcmr));
assign t_cmr_stall = cmr_valid_i |
		     (w_p1_valid & w_p1_cmr[1]) |
		     (w_p2_valid & w_pt_cmr[1]) |
		     (| (q_oc_val & t_oc_cmr)) |
		     t_pe_correctable_error | t_p1_correctable_error | t_p2_correctable_error;

\js // If retry gets to pt stage need to follow through with the w_pt_trace lookup as wake will equal 1.
\js // However if retry originates from p1 stage wake will not be 1 thus allowing trace tag to be inserted correctly.

\=u.instance({
	moduleName: 'ioaiu_mux',
	instanceName: 'rr_mux',
	params: {
		NUM:		'3',
		DW:		PXW+4+1+4,
                clkAssertInterface : clkAssertInterface,
				assertOn: assertOn
	},
	verilogParams: {
	},
	ports: {
		ready_o:	'{cmr_ready_o,	w_rp1_ready, w_rpt_ready}',
		valid_i:	'{cmr_valid_i,  n_rp1_valid, n_rpt_valid}',
		data_i:		`{3'b0, {{AXKW{1'b0}}, {AXUW{1'b0}}, {MW{1'b0}},
                                  4'b0,
				  {SW{1'b0}}, {MW{1'b0}}, {IW{1'b0}},
				  {QW{1'b0}}, {RW{1'b0}},
				  {cmr_last_i, cmr_security_i, 1'b0},
				  4'h0, 1'b0, 2'h0, 3'h0, {2'h0, cmr_way_i},
				  cmr_addr_i, {AWTW{1'b0}}, {AWSW{1'b0}},
				  {XTA{1'b0}}, 1'b0, 1'b0, {1'b1, cmr_cmd_i}, 1'b0, 1'b0}, 
				  {w_p1_up,w_p1_upmatch,w_p1_track, w_p1_user, t_p1_domain[MW-1:0],
                                   w_p1_vmidext,
				   w_p1_snoop[SW-1:0], w_p1_bar, w_p1_id, w_p1_qos,
				   w_p1_region, w_p1_prot, w_p1_cache,
				   w_p1_lock, w_p1_burst, w_p1_size, w_p1_len,
				   w_p1_addr, w_p1_atop, w_p1_stashid, 
				   w_p1_kid, w_p1_wake, w_p1_partial, 
				   w_p1_cmr, w_p1_write, 1'b0, w_p1_snp},
				  {w_p2_up,w_p2_upmatch,w_pt_track, w_pt_user, w_pt_domain[MW-1:0],
                                   w_p1_vmidext,
				   w_pt_snoop[SW-1:0], w_pt_bar, w_pt_id, w_pt_qos,
				   w_pt_region, w_pt_prot, w_pt_cache,
				   w_pt_lock, w_pt_burst, w_pt_size, w_pt_len,
				   w_pt_addr, w_pt_atop[AWTW-1:0], w_pt_stashid, 
				   n_rpt_kid, n_rpt_wake, w_pt_partial, 
				   w_pt_cmr, w_pt_write, w_pt_trace,w_pt_snp}}`,
		ready_i:	'w_rr_ready',
		valid_o:	'n_rr_valid',
		data_o:		`{n_rr_up, n_rr_upmatch, n_rr_track, n_rr_user, n_rr_domain,
                                  n_rr_vmidext, 
				  n_rr_snoop, n_rr_bar, n_rr_id, n_rr_qos,
				  n_rr_region, n_rr_prot, n_rr_cache,
				  n_rr_lock, n_rr_burst, n_rr_size, n_rr_len,
				  n_rr_addr, n_rr_atop, n_rr_stashid, 
				  n_rr_kid, n_rr_wake, n_rr_partial, 
				  n_rr_cmr, n_rr_write, n_rr_trace,n_rr_snp}`,
		bvsel_i:	't_rr_sel'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

assign t_rr_sel = ((w_p2_valid & t_pt_correctable_error) |
		   (w_p1_valid & t_pe_correctable_error)) ? 3'h2 :
		  (w_p1_valid | w_p2_valid | w_rr_valid) ? 3'h1 :
		  ((| (q_oc_val & ~t_oc_cmr)) | w_rr_valid |
		   (| t_st_wake) | w_poc_valid |
		   ~q_oc_ready | ~q_od_ready |
		   ~w_c1_ready | ~w_p1_ready) ? 3'h0 :
						3'h4;

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'rr',
	params: {
                depth:          3,
		width:		PXW+4+1+4,
                pipeForward:    "yes",
                pipeBackward:   "yes",
                simplePipe:     "no",
                circular:       "no",
                exposeValids:   "true",
                exposeGuts:     "true"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_rr_ready',
		in_valid:	'n_rr_valid',
		in_data:	`{n_rr_up, n_rr_upmatch, n_rr_track, n_rr_user, n_rr_domain,
                                  n_rr_vmidext,
				  n_rr_snoop, n_rr_bar, n_rr_id, n_rr_qos,
				  n_rr_region, n_rr_prot, n_rr_cache,
				  n_rr_lock, n_rr_burst, n_rr_size, n_rr_len,
				  n_rr_addr, n_rr_atop, n_rr_stashid, n_rr_kid,
                                  n_rr_wake, n_rr_partial,
				  n_rr_cmr, n_rr_write, n_rr_trace, n_rr_snp}`,
		out_ready:	'n_rr_ready',
		out_valid:	'w_rr_valid',
                valids:         'w_rr_guts_valid',
                guts:           `{{w_rr_guts_up[2], w_rr_guts_upmatch[2], w_rr_guts_track[2], w_rr_guts_user[2], w_rr_guts_domain[2],
                                   w_rr_guts_vmidext[2],
                                   w_rr_guts_snoop[2], w_rr_guts_bar[2], w_rr_guts_id[2], w_rr_guts_qos[2],
                                   w_rr_guts_region[2], w_rr_guts_prot[2], w_rr_guts_cache[2],
                                   w_rr_guts_lock[2], w_rr_guts_burst[2], w_rr_guts_size[2], w_rr_guts_len[2],
                                   w_rr_guts_addr[2], w_rr_guts_atop[2], w_rr_guts_stashid[2], w_rr_guts_kid[2],
                                   w_rr_guts_wake[2], w_rr_guts_partial[2],
                                   w_rr_guts_cmr[2], w_rr_guts_write[2], w_rr_guts_trace[2], w_rr_guts_snp[2]},
                                  {w_rr_guts_up[1], w_rr_guts_upmatch[1], w_rr_guts_track[1], w_rr_guts_user[1], w_rr_guts_domain[1],
                                   w_rr_guts_vmidext[1],
                                   w_rr_guts_snoop[1], w_rr_guts_bar[1], w_rr_guts_id[1], w_rr_guts_qos[1],
                                   w_rr_guts_region[1], w_rr_guts_prot[1], w_rr_guts_cache[1],
                                   w_rr_guts_lock[1], w_rr_guts_burst[1], w_rr_guts_size[1], w_rr_guts_len[1],
                                   w_rr_guts_addr[1], w_rr_guts_atop[1], w_rr_guts_stashid[1], w_rr_guts_kid[1],
                                   w_rr_guts_wake[1], w_rr_guts_partial[1],
                                   w_rr_guts_cmr[1], w_rr_guts_write[1], w_rr_guts_trace[1], w_rr_guts_snp[1]},
                                  {w_rr_guts_up[0], w_rr_guts_upmatch[0], w_rr_guts_track[0], w_rr_guts_user[0], w_rr_guts_domain[0],
                                   w_rr_guts_vmidext[0],
                                   w_rr_guts_snoop[0], w_rr_guts_bar[0], w_rr_guts_id[0], w_rr_guts_qos[0],
                                   w_rr_guts_region[0], w_rr_guts_prot[0], w_rr_guts_cache[0],
                                   w_rr_guts_lock[0], w_rr_guts_burst[0], w_rr_guts_size[0], w_rr_guts_len[0],
                                   w_rr_guts_addr[0], w_rr_guts_atop[0], w_rr_guts_stashid[0], w_rr_guts_kid[0],
                                   w_rr_guts_wake[0], w_rr_guts_partial[0],
                                   w_rr_guts_cmr[0], w_rr_guts_write[0], w_rr_guts_trace[0], w_rr_guts_snp[0]}}`,
		out_data:	`{w_rr_up, w_rr_upmatch, w_rr_track, w_rr_user, w_rr_domain, 
                                  w_rr_vmidext,
				  w_rr_snoop, w_rr_bar, w_rr_id, w_rr_qos, 
				  w_rr_region, w_rr_prot, w_rr_cache, 
				  w_rr_lock, w_rr_burst, w_rr_size, w_rr_len, 
				  w_rr_addr, w_rr_atop, w_rr_stashid, w_rr_kid, 
				  w_rr_wake, w_rr_partial,
				  w_rr_cmr, w_rr_write, w_rr_trace, w_rr_snp}` 
	},
	portsDelimiter: '\n\t'
})=\

assign t_rr_valid = w_rr_valid & n_cmd_req0_ready & ~t_pe_correctable_error &
			       (~w_rr_cmr[1] | (~w_p1_valid & ~w_p2_valid &
						(t_oc_count < t_p0_limit) &
						(t_oc_ecount < t_cfg_ev_limit) &
						(~| (q_oc_val & ~t_oc_cmr)))) &
			       t_p0_single & t_p0_single_wake & 
			       ~t_pvc_throttle & ~w_cmd_req0_af &
			       ~(t_cfg_evict & n_ce_valid) &
			       (w_rr_write ? ~w_wq_af : 1'b1) &
			       ~w_do_af & ~w_c0_af & ~w_ce_af;

\jsbegin
/* istanbul ignore if env ncore_3p4,ncore_3p6,ncore_3p7 */
if (useSharerPromotion==0) {  \jsend
assign t_ce_dtw = ~t_of_stash[0] &
		 (t_of_sel[1] |
		  (t_of_sel[0] & ((~w_dtr_req_tx1_af & ~w_dtw_req1_af) | (| w_of_count)) &
				w_cs_valid & (((t_st_cmd[w_cs_sid]==SnpVldDtw)|
					       (t_st_cmd[w_cs_sid]==SnpStshShd) |
					       (t_st_cmd[w_cs_sid]==SnpInvDtw)  |
					       (t_st_cmd[w_cs_sid]==SnpUnqStsh) |
					       (t_st_cmd[w_cs_sid]==SnpStshUnq) |
					       (t_st_cmd[w_cs_sid]==SnpNITCCI)) &
					     (t_st_cstate[w_cs_sid]!=CST_UC))));
assign t_ce_dtr = t_of_stash[0] |
		 (t_of_sel[0] & ((~w_dtr_req_tx1_af & ~w_dtw_req1_af) | (| w_of_count))  &
				w_cs_valid & (t_st_cmd[w_cs_sid]!=SnpVldDtw)  &
					     (t_st_cmd[w_cs_sid]!=SnpStshShd) &
					     (t_st_cmd[w_cs_sid]!=SnpInvDtw)  &
					     (t_st_cmd[w_cs_sid]!=SnpUnqStsh) &
					     (t_st_cmd[w_cs_sid]!=SnpStshUnq));

assign t_ce_dtw_stall = ~t_of_stash[0] & ~t_of_sel[1] & ~(|w_of_count) & w_cs_valid & (w_dtr_req_tx1_af | w_dtw_req1_af) & (t_st_cmd[w_cs_sid]!=SnpVldDtw)  &
                                                                                                                (t_st_cmd[w_cs_sid]!=SnpStshShd) &
                                                                                                                (t_st_cmd[w_cs_sid]!=SnpInvDtw)  &
                                                                                                                (t_st_cmd[w_cs_sid]!=SnpUnqStsh) &
                                                                                                                (t_st_cmd[w_cs_sid]!=SnpStshUnq);
\jsbegin
} else { \jsend
 //w_cs_sndtw, w_cs_sndtr
assign t_ce_dtw = ~t_of_stash[0] &
		 (t_of_sel[1] |
		  (t_of_sel[0] & ((~w_dtr_req_tx1_af & ~w_dtw_req1_af) | (| w_of_count)) &
				w_cs_valid & w_cs_sndtw));

assign t_ce_dtr = t_of_stash[0] |
		 (t_of_sel[0] & ((~w_dtr_req_tx1_af & ~w_dtw_req1_af) | (| w_of_count)) &
				w_cs_valid & w_cs_sndtr);

assign t_ce_dtw_stall = ~t_of_stash[0] & ~t_of_sel[1] & ~(|w_of_count) & w_cs_valid & w_cs_sndtw & (w_dtr_req_tx1_af | w_dtw_req1_af);

\jsbegin
} \jsend

assign t_c2_scmd = t_st_cmd[w_pt_kid[STA-1:0]][7:0];
assign t_c2_resp = w_pt_wake ? {(t_pt_err | (q_oc_val[w_pt_kid] & q_oc_status[w_pt_kid][7])), 
				(t_pt_uerr | (q_oc_val[w_pt_kid] & q_oc_status[w_pt_kid]==8'h84))} : 
			        {t_pt_err, t_pt_uerr};
assign t_c2_eob = w_pt_wake ? q_oc_eob[w_pt_kid] : n_oc_eob;

assign t_c2_len = (((w_pt_snp) | w_pt_cmr[1] |
		    ((w_pt_burst==2'h2) & ~w_pt_wake & (w_pt_len<8'd\=BPL=\) & 1'b0 &
						~w_c2_chit) |
		    ((w_pt_burst==2'h2) & ~w_pt_wake &	~w_pt_write &
  			(((n_oc_beats_adj[4:0]==5'd2) & (| w_pt_addr[AWL +: 1])) |
			 ((n_oc_beats_adj[4:0]==5'd4) & (| w_pt_addr[AWL +: 2])) |
			 ((n_oc_beats_adj[4:0]==5'd8) & (| w_pt_addr[AWL +: 3])) |
			 ((n_oc_beats_adj[4:0]==5'd16)& (| w_pt_addr[AWL +: 4])) |
			 (n_oc_beats_adj[4:0]==5'd\=BPL=\))) |
		    (q_oc_wrap[w_pt_kid] & w_pt_wake &	~w_pt_write &
			(((q_oc_beats_adj[w_pt_kid]==5'd2) & (| w_pt_addr[AWL +: 1])) |
			 ((q_oc_beats_adj[w_pt_kid]==5'd4) & (| w_pt_addr[AWL +: 2])) |
			 ((q_oc_beats_adj[w_pt_kid]==5'd8) & (| w_pt_addr[AWL +: 3])) |
			 ((q_oc_beats_adj[w_pt_kid]==5'd16)& (| w_pt_addr[AWL +: 4])) |
			 (~| q_oc_beats[w_pt_kid])))) ? \=BWL+1=\'d\=BPL=\ :
		    w_pt_wake ? {1'b0,q_oc_beats[w_pt_kid][BWL-1:0]} : 
				n_oc_beats) - 1'b1;
				
wire t_c2_drop_carry;
assign {t_c2_drop_carry,t_c2_drop} = (((w_pt_burst==2'h2) & ~w_pt_wake &
		                                (((n_oc_beats_adj==6'd2) & (| w_pt_addr[AWL +: 1])) |
		                                ((n_oc_beats_adj==6'd4) & (| w_pt_addr[AWL +: 2])) |
		                                ((n_oc_beats_adj==6'd8) & (| w_pt_addr[AWL +: 3])) |
		                                ((n_oc_beats_adj==6'd16)& (| w_pt_addr[AWL +: 4])))) ?
						    \=BWL+1=\'d\=BPL=\ - n_oc_beats :
		                                (q_oc_wrap[w_pt_kid] & w_pt_wake &
		                                 (((q_oc_beats_adj[w_pt_kid]==5'd2) & (| w_pt_addr[AWL +: 1])) |
		                                  ((q_oc_beats_adj[w_pt_kid]==5'd4) & (| w_pt_addr[AWL +: 2])) |
		                                  ((q_oc_beats_adj[w_pt_kid]==5'd8) & (| w_pt_addr[AWL +: 3])) |
		                                  ((q_oc_beats_adj[w_pt_kid]==5'd16)& (| w_pt_addr[AWL +: 4])))) ?
						    \=BWL+1=\'d\=BPL=\ - q_oc_beats[w_pt_kid] :
						                      {BWL+1{1'b0}});
assign t_c2_offset = w_pt_addr[AWL +: BWL];
assign t_c2_valid = cp2_valid_i;
assign t_c2_estate = ((w_pt_cmr==2'h3) & ~w_pt_write) ? cp2_cstate_i : 
							cp2_estate_i;
assign t_c2_nacks = cp2_nacks_i | {2'h0, (t_pt_dii & ~w_amc_nc | ~n_cmd_req0_ac_int | t_pt_err) , 1'b0};
assign t_c2_delay = t_pt_snp & (| t_oc_ahite);
assign t_c2_cancel = ~w_pt_snp & ((| t_oc_ahit) | ~t_pt_ok);
assign t_c2_cancel_alloc = ~w_pt_snp & ((| t_oc_ahit) | ~t_pt_ok_maybe);
assign t_c2_lookup = ~w_pt_snp & (w_pt_wake ? (pt_iptr != w_pt_kid):
					      (| t_oc_ihit));
assign t_co_fdone = w_co_valid & n_co_ready & w_co_last;

assign cp2_wr_o = n_wq_valid;
assign cp2_alloc_o = w_c2_alloc;

assign n_wq_oid = w_pt_wake ? w_pt_kid[OCA-1:0] : q_oc_wptr;

assign n_wq_ready = w_wq_valid & n_odw_last & w_odw_ready;

\js // Get almost-full functionality by exposing the valids, and seeing how full the fifo is.
wire [9:0] wq_valids;
assign w_wq_af = wq_valids[5];
\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'wq',
	params: {
                depth:          10,
		width:		OCA,
                pipeForward:    "yes",
                pipeBackward:   "yes",
                simplePipe:     "no",
                circular:       "no",
                exposeValids:   "true"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		valids:		'wq_valids',
		in_ready:	'w_wq_ready',
		in_valid:	'n_wq_valid',
		in_data:	'n_wq_oid',
		out_ready:	'n_wq_ready',
		out_valid:	'w_wq_valid',
		out_data:	'w_wq_oid'
	},
	portsDelimiter: '\n\t'
})=\

assign n_odw_valid = w_wq_valid;
assign n_odw_raddr = {q_oc_dptr[w_wq_oid],
			   ((~| q_odw_count) ? q_oc_addr[w_wq_oid][AWL +: BWL] :
					       q_odw_offset)};
assign n_odw_oid = w_wq_oid;
assign n_odw_offset = ((q_oc_wrap[w_wq_oid] & (q_oc_beats_adj[w_wq_oid]==5'd2)) ?
                              {{\=CLO-ioaiu_pos(BWL-1)-1=\{1'b0}},q_oc_addr[w_wq_oid][AWL+1 +: \=ioaiu_pos(BWL-1)=\], (q_oc_addr[w_wq_oid][AWL +: 1] + q_odw_count[0+:\=Math.min(1, ioaiu_pos(BWL-1))=\])}:
                       (q_oc_wrap[w_wq_oid] & (q_oc_beats_adj[w_wq_oid]==5'd4)) ?
                              {{\=CLO-ioaiu_pos(BWL-2)-2=\{1'b0}},q_oc_addr[w_wq_oid][AWL+2 +: \=ioaiu_pos(BWL-2)=\], (q_oc_addr[w_wq_oid][AWL +: 2] + 
\js if (2>ioaiu_pos(BWL-1)) {
                                                                                                                                                 {1'b0,q_odw_count[0+:\=Math.min(2, ioaiu_pos(BWL-1))=\]})}:
\js } else {
                                                                                                                                                       q_odw_count[0+:\=Math.min(2, ioaiu_pos(BWL-1))=\])}:
\js }
                       (q_oc_wrap[w_wq_oid] & (q_oc_beats_adj[w_wq_oid]==5'd8)) ?
                              {{\=CLO-ioaiu_pos(BWL-3)-3=\{1'b0}},q_oc_addr[w_wq_oid][AWL+3 +: \=ioaiu_pos(BWL-3)=\], (q_oc_addr[w_wq_oid][AWL +: 3] + 
\jsbegin
// Would only happen for 32 bit bus or smaller
/* istanbul ignore else env ncore_3p7 */
    if (3>ioaiu_pos(BWL-1)) { \jsend
                                                                                                                       {{\=3-ioaiu_pos(BWL-1)=\{1'b0}},q_odw_count[0+:\=Math.min(3, ioaiu_pos(BWL-1))=\]})}:
\js } else {
                                                                                                                                                       q_odw_count[0+:\=Math.min(3, ioaiu_pos(BWL-1))=\])}:
\js }
                         ({{\=CLO-BWL=\{1'b0}},q_oc_addr[w_wq_oid][AWL +: BWL]} + {{\=CLO-BWL-1=\{1'b0}},q_odw_count})) &
                      ({CLO{1'b1}} >> AWL);

assign n_odw_last = ({(~| q_oc_beats[w_wq_oid]), 
			  q_oc_beats[w_wq_oid]} == (q_odw_count + 1'b1));


\=u.instance({
	moduleName: 'ioaiu_enc',
	instanceName: 'evdec0',
	params: {
                DW:             OCN,
                BE:             0,
                NO_INDEX_OUT:   1,
                clkAssertInterface : clkAssertInterface,
		assertOn: assertOn
	},
	ports: {
		bv_i:		't_oc_edealloc',
		valid_o:	'w_oc_edec',
		bv_o:		'w_oc_edbv0'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\
\=u.instance({
	moduleName: 'ioaiu_enc',
	instanceName: 'evdec1',
	params: {
                DW:             OCN,
                BE:             1,
                NO_VALID_OUT:   1,
                NO_INDEX_OUT:   1,
                clkAssertInterface : clkAssertInterface,
		assertOn: assertOn
	},
	ports: {
		bv_i:		't_oc_edealloc',
		bv_o:		'w_oc_edbv1'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

wire t_oc_einc_next = w_p2_valid & w_c2_evict;
\=u.dffre(1, `t_oc_einc`, `t_oc_einc_next`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
assign t_oc_edec = ~w_oc_edec ? 2'h0 :
		   (| (w_oc_edbv0 & w_oc_edbv1)) ? 2'h1 :
						   2'h3;

assign q_oc_ecount_next = (t_oc_einc & (~|t_oc_edec)) ? q_oc_ecount + \=OCA+1=\'b1:
			      (~t_oc_einc & (& t_oc_edec)) ? q_oc_ecount - \=OCA+1=\'h2:
			      ((~t_oc_einc & (| t_oc_edec)) |
			       (t_oc_einc & (& t_oc_edec)))? q_oc_ecount - \=OCA+1=\'b1:
							     q_oc_ecount;

\=u.dffre(OCA+1, `q_oc_ecount`, `q_oc_ecount_next`, `{`+(OCA+1)+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
wire [OCA-1:0] q_p1_skid_ns = q_pe_correctable_error ? w_p1_kid[OCA-1:0] : q_p1_skid;
\=u.dffre(OCA, `q_p1_skid`, `q_p1_skid_ns`, OCA+`'b0`, `1'b1`, `clk_i`, `reset_ni`)=\

   wire [BWL:0] q_odw_count_p1;
   wire q_odw_count_carry;
   assign {q_odw_count_carry,q_odw_count_p1} = {1'b0,q_odw_count} + 1'b1;
wire [BWL+1-1:0] q_odw_count_ns = (~w_odw_ready | ~w_wq_valid) ? q_odw_count : n_odw_last ? {BWL+1{1'b0}} : q_odw_count_p1;
\=u.dffre(BWL+1, `q_odw_count`, `q_odw_count_ns`, `{`+(BWL+1)+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
   wire [BWL-1:0] q_cdr_count_p1;
   wire q_cdr_count_carry;
   assign {q_cdr_count_carry,q_cdr_count_p1} = {1'b0,q_cdr_count} + 1'b1;
wire [BWL-1:0] q_cdr_count_ns = (w_cdr_valid & n_cdr_ready & w_cdr_last) ? {BWL{1'b0}} : (w_cdr_valid & n_cdr_ready) ? q_cdr_count_p1: q_cdr_count;
\=u.dffre(BWL, `q_cdr_count`, `q_cdr_count_ns`, `{`+BWL+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
   wire [3:0] q_pvc_count_m1;
   wire q_pvc_count_underflow;
   assign {q_pvc_count_underflow,q_pvc_count_m1} = {1'b0,q_pvc_count} - 1'b1;
wire [4-1:0] q_pvc_count_ns = (w_pvc_ready & ~w_p1_valid & (t_cfg_pvc != q_pvc_count)) ? t_cfg_pvc : (n_pvc_valid & (| q_pvc_count)) ? q_pvc_count_m1 : q_pvc_count;
\=u.dffre(4, `q_pvc_count`, `q_pvc_count_ns`, `{4{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
   wire [BWL-1:0] q_odw_offset_p1;
   wire q_odw_offset_carry;
   assign {q_odw_offset_carry,q_odw_offset_p1} = {1'b0,q_odw_offset} + 1'b1;
   wire [BWL-1:0] q_oc_addr_odw_p1;
   wire q_oc_addr_odw_carry;
   assign {q_oc_addr_odw_carry,q_oc_addr_odw_p1} = {1'b0,q_oc_addr[w_wq_oid][AWL+:BWL]} + 1'b1;
wire [BWL-1:0] q_odw_offset_ns = (~w_wq_valid | ~w_odw_ready) ? q_odw_offset : (~| q_odw_count) ? q_oc_addr_odw_p1 : q_odw_offset_p1;
\=u.dffre(BWL, `q_odw_offset`, `q_odw_offset_ns`, `{`+BWL+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
wire [WAYS-1:0] q_c2_cbusy_ns = (t_pt_correctable_error | t_pe_correctable_error | ~w_p1_valid | ~n_p1_ready) ? q_c2_cbusy : n_c2_cbusy | {WAYS{t_pt_set_collision}} & ({{WAYS-1{1'b0}}, 1'b1} << w_c2_way);
\=u.dffre(WAYS, `q_c2_cbusy`, `q_c2_cbusy_ns`, `{`+WAYS+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
   wire [BWL-1:0] q_ce_count_p1;
   wire q_ce_count_carry;
   assign {q_ce_count_carry,q_ce_count_p1} = {1'b0,q_ce_count} + 1'b1;
wire [BWL-1:0] q_ce_count_ns = (w_ce_ready & n_ce_valid) ? q_ce_count_p1 : q_ce_count;
\=u.dffre(BWL, `q_ce_count`, `q_ce_count_ns`, `{`+BWL+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
wire q_cmr_last_ns = q_cmr_last ? (| (q_oc_val & t_oc_cmr)) : w_pt_valid & w_pt_cmr[1] & w_pt_lcmr & (w_c2_evict | (| (q_oc_val & t_oc_cmr)));
\=u.dffre(1, `q_cmr_last`, `q_cmr_last_ns`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
wire q_pe_correctable_error_ns = q_pe_correctable_error ? 1'b0 : w_p2_valid & t_pt_correctable_error;
\=u.dffre(1, `q_pe_correctable_error`, `q_pe_correctable_error_ns`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
wire q_p1_correctable_error_ns = (q_pe_correctable_error | q_p1_correctable_error) ? q_pe_correctable_error & w_p1_valid : q_p1_correctable_error;
\=u.dffre(1, `q_p1_correctable_error`, `q_p1_correctable_error_ns`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
wire q_p2_correctable_error_ns = q_p1_correctable_error | (q_p2_correctable_error & ~n_rr_ready & w_rr_valid);
\=u.dffre(1, `q_p2_correctable_error`, `q_p2_correctable_error_ns`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\

assign t_pe_correctable_error = q_pe_correctable_error;
assign t_p1_correctable_error = q_p1_correctable_error;
assign t_p2_correctable_error = q_p2_correctable_error;
assign t_p1_skid = {OCN{q_p1_correctable_error | q_p2_correctable_error}} & ({OCN{1'b1}} << q_p1_skid);

\js for (let i=0; i<WAYS; i=i+1) {
assign n_c2_cbusy[\=i=\] = (| t_c1_cbusy[\=i=\]);
\js }

assign w_p0_cset = \=set_select(sselParams,"w_p0_addr")=\;
assign w_p1_cset = \=set_select(sselParams,"w_p1_addr")=\;
assign w_pt_cset = \=set_select(sselParams,"w_pt_addr")=\;

assign t_pt_set_collision = w_p2_valid & ~(w_pt_snp) & w_c2_room & 
				~t_c2_cancel & ~w_c2_retry & ~w_c2_chit & 
				(~| t_oc_ahitr) & (~| t_oc_ahite) &
				~(w_p1_snp &
			 ((w_pt_addr[AW-1:CLO] == w_p1_addr[AW-1:CLO]) &
			  (w_pt_prot[1] == w_p1_prot[1]))) &
				(w_pt_cset == w_p1_cset);

\js for (let i=0; i<OCN; i=i+1) {
  assign t_oc_ce[\=i=\] = q_oc_val[\=i=\] & q_oc_evict[\=i=\] & (q_oc_iptr[\=i=\]==\=OCA=\'d\=i=\) & q_oc_wfdtw[\=i=\] & q_oc_wfdtr[\=i=\];
  assign t_c1_set_collision[\=i=\] = q_oc_val[\=i=\] & (q_oc_wfcft[\=i=\] | q_oc_wfcwd[\=i=\]) & ~(cft_valid_o & cft_ready_i & cft_obv_o[\=i=\]) & ~t_oc_chit[\=i=\] & ~q_oc_wake[\=i=\] &
				(q_oc_aptr[\=i=\] == \=OCA=\'d\=i=\) & (w_p1_wake ? (w_p1_kid != \=XTA=\'d\=i=\) : 1'b1) & ~(w_p1_valid & w_p1_snp & ((q_oc_addr[\=i=\][AW-1:CLO] == w_p1_addr[AW-1:CLO]) & (q_oc_security[\=i=\] == w_p1_prot[1]))) & (w_oc_cset[\=i=\] == w_p1_cset);

  assign w_oc_cset[\=i=\] = \=set_select(sselParams,"q_oc_addr["+i+"]")=\;

\js	for (let ix=0; ix<WAYS; ix=ix+1) { 
        assign t_c1_cbusy[\=ix=\][\=i=\] = t_c1_set_collision[\=i=\] & (q_oc_way[\=i=\]==\=ioaiu_pos(log2ceil(WAYS))=\'d\=ix=\); 
\js     }

  assign q_oc_wfcwd_ns[\=i=\] = (t_oc_alloc[\=i=\] | t_oc_update[\=i=\]) & (w_amc_nc & t_pt_WriteNoSnoop & ~t_pt_partial & w_c2_chit & ~t_c2_lookup & ~t_c2_cancel & ~w_c2_retry) ? 1'b1 : (t_oc_valloc[\=i=\] | (w_wq_valid & n_wq_ready & (w_wq_oid==\=OCA=\'d\=i=\))) ? 1'b0 : q_oc_wfcwd[\=i=\];
  \=u.dffre(1, `q_oc_wfcwd`+i, `q_oc_wfcwd_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
  assign q_oc_wfcfd_ns[\=i=\] = (t_oc_alloc[\=i=\] | t_oc_update[\=i=\]) ? (w_c2_room & ~(w_amc_nc & t_pt_ReadNoSnoop & t_pt_partial) & ~(w_amc_nc & t_pt_WriteNoSnoop & (t_pt_partial | ~w_pt_cache[3]))) : (t_oc_valloc[\=i=\] | (w_str_req_valid & (w_str_req_rid_bv[\=i=\]) & w_str_req_status[7]) | (w_cfd_done & (w_cfd_oid==\=OCA=\'d\=i=\))) ? 1'b0 : q_oc_wfcfd[\=i=\];
  \=u.dffre(1, `q_oc_wfcfd`+i, `q_oc_wfcfd_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
  assign q_oc_cmr_ns[\=i=\] = t_oc_alloc[\=i=\] ? 1'b0 : t_oc_valloc[\=i=\] ? w_pt_cmr[1] : q_oc_cmr[\=i=\];
  \=u.dffre(1, `q_oc_cmr`+i, `q_oc_cmr_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
  assign q_oc_way_ns[\=i=\] = (t_oc_alloc[\=i=\] | t_oc_valloc[\=i=\] | t_oc_update[\=i=\]) ? w_c2_way : q_oc_way[\=i=\];
  \=u.dffre(CWW, `q_oc_way`+i, `q_oc_way_ns[`+i+`]`, `{`+CWW+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
  assign q_oc_evict_ns[\=i=\] = t_oc_alloc[\=i=\] ? 1'b0 : t_oc_valloc[\=i=\] ? 1'b1 : q_oc_evict[\=i=\];
  \=u.dffre(1, `q_oc_evict`+i, `q_oc_evict_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_str_err_in[\=i=\] = t_oc_alloc[\=i=\] ? 1'b0 :
                              t_oc_valloc[\=i=\] ? 1'b0 :
			       q_oc_str_err[\=i=\] ? 1'b1 : (w_str_req_valid & (w_str_req_rid_bv[\=i=\]) & w_str_req_status[7]);

  \=u.dffre(1, `q_oc_str_err`+i, `q_oc_str_err_in[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_wfcft_ns[\=i=\] = ((t_oc_update[\=i=\] & ~q_oc_evict[\=i=\]) | t_oc_alloc[\=i=\]) ? w_c2_room & ~t_c2_cancel & ~(w_amc_nc & t_pt_ReadNoSnoop & t_pt_partial) & ~(w_amc_nc & t_pt_WriteNoSnoop & (t_pt_partial | ~w_pt_cache[3])) & ~w_c2_retry & ~w_c2_chit : (t_oc_valloc[\=i=\] | (cft_valid_o & cft_ready_i & cft_obv_o[\=i=\])) ? 1'b0 : q_oc_wfcft[\=i=\];
  \=u.dffre(1, `q_oc_wfcft`+i, `q_oc_wfcft_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_chit_ns[\=i=\] = (t_oc_alloc[\=i=\] | t_oc_update[\=i=\] | t_oc_valloc[\=i=\]) ? w_c2_chit : ((q_oc_val[\=i=\] & q_oc_wake[\=i=\]) | (q_oc_val[\=i=\] & (q_oc_iptr[\=i=\] == \=OCA=\'d\=i=\) & ~q_oc_write[\=i=\] & t_oc_chit[\=i=\] & (q_oc_aptr[\=i=\] == \=OCA=\'d\=i=\))) ? 1'b0 : q_oc_chit[\=i=\];
  \=u.dffre(1, `q_oc_chit`+i, `q_oc_chit_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_wfupr_ns[\=i=\] = t_oc_alloc[\=i=\] ? 1'b0 : t_oc_valloc[\=i=\] ? 1'b1 : q_oc_wfupr[\=i=\];
  \=u.dffre(1, `q_oc_wfupr`+i, `q_oc_wfupr_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_oc_dstate_ns[\=i=\] = (t_oc_alloc[\=i=\] | t_oc_update[\=i=\] | t_oc_valloc[\=i=\]) ? w_c2_state : (t_pt_snp & (w_pt_security == q_oc_security[\=i=\]) & (w_pt_addr[AW-1:CLO]==q_oc_addr[\=i=\][AW-1:CLO]) & cp2_update_o & (~| cp2_nstate_o)) ? CST_IX : (q_oc_val[\=i=\] & (q_oc_write[\=i=\] & (q_oc_dstate[\=i=\] == CST_SD)) | ~((n_dtr_req_rx_ready & w_dtr_req_rx_valid & q_oc_wfdtr[w_srd_oid] & (w_srd_oid==\=OCA=\'d\=i=\) & w_dtr_req_rx_last))) ? q_oc_dstate[\=i=\] : ((w_dtr_req_rx_cmd == DtrDataInv) & ~q_oc_nc[\=i=\]) ? CST_IX : ((w_dtr_req_rx_cmd == DtrDataInv) & q_oc_nc[\=i=\]) ? CST_UC : (w_dtr_req_rx_cmd == DtrDataSCln) ? CST_SC : (w_dtr_req_rx_cmd == DtrDataSDty) ? CST_SD : (w_dtr_req_rx_cmd == DtrDataUCln) ? CST_UC : (w_dtr_req_rx_cmd == DtrDataUDty) ? CST_UD : CST_IX;
  \=u.dffre(3, `q_oc_dstate`+i, `q_oc_dstate_ns[`+i+`]`, `{3{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

\js } // for (let i=0; i<OCN; i=i+1)

assign t_cdr_count = q_cdr_count;
assign t_oc_wfcfd = q_oc_wfcfd;
assign t_oc_wfcft = q_oc_wfcft;
assign t_oc_str_err = q_oc_str_err;
assign t_oc_wfcwd = q_oc_wfcwd;
assign t_oc_chit = q_oc_chit;
assign t_oc_wfupr =  q_oc_wfupr;
assign t_oc_evict =  q_oc_evict;
assign t_oc_ecount = q_oc_ecount;
assign t_oc_cmr = q_oc_cmr;

assign {w_odw_ready, w_odf_ready, w_odr_ready, w_odm_ready} = w_rn_ready;
assign n_rn_valid = {n_odw_valid, n_odf_valid, n_odr_valid, n_odm_valid};
assign n_rn_raddr = {n_odw_raddr, n_odf_raddr, n_odr_raddr, n_odm_raddr};
assign n_rn_info = {n_odw_pad, n_odw_oid, n_odw_offset[BWL-1:0], n_odw_last,
		    n_odf_pad, n_odf_oid, n_odf_count, n_odf_last, 
		    n_odr_pad, n_odr_bar, n_odr_track, n_odr_oid, n_odr_eob, n_odr_id, 
						       n_odr_resp, n_odr_last,
		    n_odm_pad};

assign n_rn_ready = {n_odw_ready, n_odf_ready, n_odr_ready, n_odm_ready};
assign {w_odw_valid, w_odf_valid, w_odr_valid, w_odm_valid} = w_rn_valid;
assign {w_odw_poison, w_odw_be, w_odw_rdata,
	w_odf_poison, w_odf_be, w_odf_rdata,	
	w_odr_poison, w_odr_be, w_odr_rdata,
	w_odm_poison, w_odm_be, w_odm_rdata} = w_rn_rdata;
assign {w_odw_pad, w_odw_oid, w_odw_offset, w_odw_last,
	w_odf_pad, w_odf_oid, w_odf_count, w_odf_last, 
	w_odr_pad, w_odr_bar, w_odr_track, w_odr_oid,
				w_odr_eob, w_odr_id, w_odr_response, w_odr_last,
	w_odm_pad} = w_rn_info;
assign {w_odr_resp[ARPW-1:0], w_odr_cmo, w_odr_csr} = w_odr_response;

assign t_pvc_count = q_pvc_count;
\js for (let i=0; i<OCN; i=i+1) {
assign t_oc_dstate[\=i=\] = q_oc_dstate[\=i=\];
assign t_oc_way[\=i=\] = q_oc_way[\=i=\];
\js }
assign n_dtv_ready = 1'b0;
assign n_cd_ready = 1'b0;
assign n_ace_dtr = 8'b0;

\js } else { // useCache

assign	pmon_cache_r_hit = 1'h0;
assign	pmon_cache_w_hit = 1'h0;
assign	pmon_cache_s_hit = 1'h0;
assign	pmon_cache_evict = 1'h0;
assign	pmon_no_ways = 1'h0;
assign	pmon_cache_f_stall = 1'h0;
assign	pmon_cache_r_stall = 1'h0;
assign	pmon_cache_w_stall = 1'h0;
assign	pmon_cache_replay = 1'h0;
assign	pmon_cache_r_miss = 1'h0;
assign	pmon_cache_w_miss = 1'h0;
assign	pmon_cache_s_miss = 1'h0;

wire [BWL-1:0]	q_cd_count;
\js if (axiParams.wCdData) {
   wire [BWL-1:0] q_cd_count_p1;
   wire q_cd_count_carry;
   assign {q_cd_count_carry,q_cd_count_p1} = {1'b0,q_cd_count} + 1'b1;
wire [BWL-1:0] q_cd_count_ns = (n_cd_ready & w_cd_valid) ? q_cd_count_p1 : q_cd_count;
\=u.dffre(BWL, `q_cd_count`, `q_cd_count_ns`, `{`+BWL+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
\js } else {
assign q_cd_count = {BWL{1'b0}};
\js }

\js if (isDvmAgent) {
wire [63:0] t_dve_addr_2nd;
wire [63:0] t_dve_addr_1st;
wire t_dve_onepartcmd  = q_oc_wfdtr[w_dtv_oid];
wire t_dve_pici        = (t_dve_addr_1st[14:12] == 3'b010);
\jsbegin
// Maximum address width with dvms is 48 bits
/* istanbul ignore else env ncore_3p7 */
    if(AW<64) { \jsend
	assign t_dve_addr_2nd = t_dve_onepartcmd ? {64{1'b0}}                           : {{64-AW{1'b0}},q_oc_addr[w_dtv_oid]};
	assign t_dve_addr_1st = t_dve_onepartcmd ? {{64-AW{1'b0}},q_oc_addr[w_dtv_oid]} : {{64-AW{1'b0}},q_oc_addr[q_oc_iptr[w_dtv_oid]]};
\js } else {
	assign t_dve_addr_2nd = t_dve_onepartcmd ? {AW{1'b0}}                 : q_oc_addr[w_dtv_oid][63:0];
	assign t_dve_addr_1st = t_dve_onepartcmd ? q_oc_addr[w_dtv_oid][63:0] : q_oc_addr[q_oc_iptr[w_dtv_oid]][63:0];
\js }
wire [3:0] t_dve_vmidext_2nd = t_dve_onepartcmd ? 4'b0                    : t_oc_vmidext[w_dtv_oid];
wire [3:0] t_dve_vmidext_1st = t_dve_onepartcmd ? t_oc_vmidext[w_dtv_oid] : t_oc_vmidext[q_oc_iptr[w_dtv_oid]];
wire [63:0] t_dve_wdata_tmp = {
             t_dve_onepartcmd ? t_dve_addr_1st[43:40]        // [63:60] VMID[15:12]
                              : t_dve_vmidext_2nd[3:0],      // 
                                t_dve_vmidext_1st[3:0],      // [59:56] VMID[11:8]
				t_dve_addr_2nd[5],           // [55:55] NUM[4]/PA[5]/VA[5]
				t_dve_addr_1st[47:44],       // [54:51] VA[56:53]
                                t_dve_addr_2nd[47:44],       // [50:47] VA[52:49]/PA[52:49]
                   t_dve_pici ? {1'b0,t_dve_addr_2nd[47:45]} // [46:43] PA[48:45]
                              : t_dve_addr_1st[43:40],       //         VA[48:45]
                   t_dve_pici ? t_dve_addr_2nd[44:41]        // [42:39] PA[44:41]
                              : t_dve_addr_2nd[43:40],       //         VA[44:41]
		   t_dve_pici ? t_dve_addr_2nd[40]           // [38:38] PA[40]
                              : t_dve_addr_2nd[3],           //         VA[40]
				t_dve_addr_2nd[39:12],       // [37:10] VA[39:12]/PA[39:12]
				t_dve_addr_2nd[11:10],       // [ 9: 8] TG[1:0]/VA[11:10]/PA[11:10]
				t_dve_addr_2nd[9:8],	   // [ 7: 6] TTL[1:0]/VA[9:8]/PA[9:8]
				t_dve_addr_2nd[7:6],         // [ 5: 4] Scale[1:0]/VA[7:6]/PA[7:6]
                                t_dve_addr_2nd[4],           // [ 3: 3] NUM[3] 
                                t_dve_addr_2nd[2],           // [ 2: 2] NUM[2] 
                                t_dve_addr_2nd[1],           // [ 1: 1] NUM[1] 
				t_dve_addr_2nd[0]};          // [ 0: 0] NUM[0]
wire [DW-1:0]	t_dve_wdata;
\js if(DW>64) {
	assign t_dve_wdata = {{\=DW-64=\{1'b0}},(64'hf000000000000000 | {64{~t_dve_onepartcmd}})} & {{\=DW-64=\{1'b0}},t_dve_wdata_tmp};
\js } else {
	assign t_dve_wdata = (64'hf000000000000000 | {64{~t_dve_onepartcmd}}) & t_dve_wdata_tmp[DW-1:0];
\js}

////////////////////////////////////////
wire [\=wOCN-1=\:0] dtv_iptr;
wire [\=OCN*wOCN-1=\:0] dtv_iptr_i;

\js for (let i=0; i<OCN; i=i+1) {
assign dtv_iptr_i[\=i*wOCN=\ +: \=wOCN=\] = q_oc_iptr[\=i=\];
\js }

\=u.instance({
        moduleName: 'ioaiu_aomux',
	instanceName: 'u_dtv_arb_oid',
        params: {
                clkAssertInterface : clkAssertInterface,
		NUM:      OCN,
                DW:       wOCN,
		assertOn: assertOn
        },
        ports: {
		data_o:         'dtv_iptr',
		bvsel_i:        'w_dtv_obv',
		data_i:         'dtv_iptr_i'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

wire [OCA-1:0]	t_dve_oid = |(w_dtv_obv & q_oc_wfdtr) ? w_dtv_oid : dtv_iptr;
////////////////////////////////////////

wire [DW-1:0] w_cd_data_qual;
\js if (axiParams.wCdData) {
assign w_cd_data_qual = w_cd_data;
assign w_cd_poison_qual = w_cd_poison;
\js } else {
assign w_cd_data_qual = {DW{1'b0}};
assign w_cd_poison_qual = {DWP{1'b0}};
\js }
\=u.instance({
	moduleName: 'ioaiu_mux',
	instanceName: 'of_mux',
	params: {
		NUM:		'3',
		DW:		ODFIW+DW+BW+DWP,
                clkAssertInterface : clkAssertInterface,
				assertOn: assertOn
	},
	verilogParams: {
	},
	ports: {
		ready_o:	'{n_dtv_ready, n_odf_ready,  n_cd_ready}',
		valid_i:	'{w_dtv_valid, w_odf_valid,  w_cd_valid}',
		data_i:		`{{t_dve_oid, {BWL{1'b0}}, 1'b1, 
				   {DWP{q_oc_status[w_dtv_oid][7]}}, {BW{1'b1}}, 
				   t_dve_wdata},
				  {w_odf_oid, w_odf_count, w_odf_last, 
				   t_odf_poison, w_odf_be, w_odf_rdata}, 
				  {t_cdq_sid, q_cd_count, w_cd_last, 
				   t_cdq_poison, {BW{1'b1}}, w_cd_data_qual}}`,
		ready_i:	'n_of_ready',
		valid_o:	'w_of_valid',
		data_o:		`{w_of_oid, w_of_count, w_of_last, 
				  w_of_poison, w_of_be, w_of_rdata}`,
		bvsel_i:	't_of_sel'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\
\js }

\js if (axiParams.wCdData || isDvmAgent) {
\=u.instance({
	moduleName: 'ioaiu_arbiter',
	instanceName: 'of_arb',
	params: {
                DRST:           DRST,
                DW:             3,
                ATOMIC:         1,
                HP:             `3'h0`,
                VAL:            1,
                NO_WINNER_OUT:  1,
		 assertOn: assertOn
		 },
	ports: {
		clk_i:		'clk_i',
		reset_ni:	'reset_ni',
		ready_i:	'n_of_ready',
		bv_i:		'{w_dtv_valid,	w_odf_valid,  t_cd_valid}',
		lv_i:		`{1'b1,		w_odf_last,   w_cd_last}`,
		wbv_o:		't_of_sel'
	},
	portsDelimiter: '\n\t'
})=\
\js }

\js if (axiParams.wCdData) {
\js //////////////////////////////////////////////////////
\js // ACE Snoop Responses
\js //////////////////////////////////////////////////////
wire t_ce_dtr_case;
wire t_ce_dtw_case;

\=u.instance({
	moduleName: 'ioaiu_control_ace_dtrw_snoopresponse',
	instanceName: 'ace_dtrw_response',
	params: {assertOn: assertOn,
                 SRNF:SRNF,
                 cmType:cmType
		 },
	ports: {
                SnpCmd:    `t_st_cmd[w_cdq_sid]`,
		WU:	   `t_st_wu[w_cdq_sid]`,
		DT:	   `t_st_dt[w_cdq_sid]`,
		PD:	   `t_st_pd[w_cdq_sid]`,
		IS:	   `t_st_is[w_cdq_sid]`,
                UP01:      `(t_st_up[w_cdq_sid]==2'b01)`,
                UPMATCH:   `upmatch[w_cdq_sid]`,
                TOF:       `t_st_tof[w_cdq_sid]`,
                dtr_valid: 't_ce_dtr_case',
                dtr_cmd:   'n_ace_dtr',
                dtw_valid: 't_ce_dtw_case',
                dtw_cmd:   'n_ace_dtw'   // need to hook this up.
	},
	portsDelimiter: '\n\t'
})=\

\=u.instance({
	moduleName: 'ioaiu_control_ace_snoopresponse',
	instanceName: 'ace_snoopresponse',
	params: {assertOn: assertOn,
                 SRNF:SRNF,
                 cmType:cmType
		 },
	ports: {
                SnpCmd:    `t_st_cmd[w_st_nid]`,
		WU:	   `t_st_wu[w_st_nid]`,
		DT:	   `t_st_dt[w_st_nid]`,
		PD:	   `t_st_pd[w_st_nid]`,
		IS:	   `t_st_is[w_st_nid]`,
                UP01:      `(t_st_up[w_st_nid]==2'b01)`,
                UPMATCH:   `upmatch[w_st_nid]`,
                TOF:       `t_st_tof[w_st_nid]`,
		rv:        'n_snp_rsp0_rv',
                rs:        'n_snp_rsp0_rs',
                dc:        'n_snp_rsp0_dc',
                dt1:       'n_snp_rsp0_dt1',
                dt0:       'n_snp_rsp0_dt0'
	},
	portsDelimiter: '\n\t'
})=\

////////////////////////////////////////

assign t_ce_dtw_stall = ~t_of_stash[0] & ~(| t_of_sel[2:1]) & ~(|w_of_count) & w_cdq_valid & t_ce_dtw_case  & (w_dtr_req_tx1_af | w_dtw_req1_af);
assign t_ce_dtw = ~t_of_stash[0] & ((| t_of_sel[2:1]) | ((~w_dtr_req_tx1_af & ~w_dtw_req1_af) | (|w_of_count)) & w_cdq_valid & t_ce_dtw_case);
assign t_ce_dtr = t_of_stash[0] | (t_of_sel[0] & ((~w_dtr_req_tx1_af & ~w_dtw_req1_af) | (| w_of_count)) & w_cdq_valid & t_ce_dtr_case); 

\js } else {
  assign n_snp_rsp0_rv = 1'b0;
  assign n_snp_rsp0_rs = 1'b0;
  assign n_snp_rsp0_dc = 1'b0;
  assign n_snp_rsp0_dt1 = 1'b0;
  assign n_snp_rsp0_dt0 = 1'b0;
assign n_ace_dtr = 8'b0;

\js if (!isDvmAgent) {
  assign n_dtv_ready = 1'b0;
assign n_odf_ready = n_of_ready;	//w_dtw_req0_ready;
assign w_of_valid = w_odf_valid;
assign {w_of_oid, w_of_count, w_of_last, w_of_poison, w_of_be, w_of_rdata} =
       {w_odf_oid,w_odf_count, w_odf_last, t_odf_poison, w_odf_be, w_odf_rdata};
assign t_of_sel = 3'h0;
\js }
assign t_ce_dtw = ~t_of_stash[0];
assign t_ce_dtr = t_of_stash[0];
assign t_ce_dtw_stall = 1'b0;
\js }
assign n_ce_valid = 1'b0;
assign n_pvc_ready = 1'b0;
assign n_pvc_valid = 1'b0;
assign n_pvc_addr = {AW{1'b0}};
assign n_pvc_security = 1'b0;
assign w_pvc_valid = 1'b0;
assign w_pvc_oid = {OCA{1'b0}};
assign w_pvc_addr = {AW{1'b0}};
assign w_pvc_security = 1'b0;
assign w_ppvc_ready = 1'b0;
	assign n_pvc_oid = {OCA{1'b0}};
	assign n_pvc_obv = {OCN{1'b0}};
        assign n_ppvc_obv = {OCN{1'b0}};
assign w_c0_af = 1'b0;
assign w_wq_af = 1'b0;
assign t_cdr_count = {BWL{1'b0}};
assign w_cdr_resp = {ARPW{1'b0}};
assign w_cdr_err = 1'b0;
assign w_cdr_drop = {BWL{1'b0}};
assign w_cdr_offset = {BWL{1'b0}};
assign t_oc_wfcfd = {OCN{1'b0}};
assign t_oc_wfcft = {OCN{1'b0}};
assign t_oc_str_err = {OCN{1'b0}};
assign t_oc_wfcwd = {OCN{1'b0}};
assign t_oc_chit = {OCN{1'b0}};
assign t_oc_wfupr =  {OCN{1'b0}};
assign t_oc_evict =  {OCN{1'b0}};
assign t_oc_cmr = {OCN{1'b0}};
assign t_oc_ce =  {OCN{1'b0}};
assign t_oc_ehid = {OCA{1'b0}};
assign w_oc_ehit = 1'b0;
assign n_oc_eptr = {OCA{1'b0}};
assign w_oc_edbv0 = {OCN{1'b0}};
assign w_oc_edbv1 = {OCN{1'b0}};
assign cp0_valid_o = {CTB{1'b0}};
assign cp0_addr_o = {AW{1'b0}};
assign cp0_security_o = 1'b0;
assign cp2_alloc_o = 1'b0;
assign cp2_rd_o = 1'b0;
assign cp2_port_o = 1'b0;
assign cp2_lru_o = 1'b0;
assign cp2_update_o = 1'b0;
assign cp2_nstate_o = {CSW{1'b0}};
assign cp2_len_o = {BWL{1'b0}};
assign cp2_setw_o = 1'b0;
assign cp2_setn_o = 20'h0;
assign cp2_wayn_o = 6'h0;
assign cp2_busy_o = {WAYS{1'b0}};
assign cfd_valid_o = 1'b0;
assign cfd_poison_o = {DWP{1'b0}};
assign cfd_full_o = 1'b0;
assign cfd_data_o = {DW{1'b0}};
assign cfd_be_o = {BW{1'b0}};
assign cfd_way_o = {CWW{1'b0}};
assign cfd_last_o = 1'b0;
assign cfd_beat_o = {BWL{1'b0}};
assign cfd_addr_o = {AW{1'b0}};
assign cfd_oid_o = {OCA{1'b0}};
assign cft_valid_o = 1'b0;
assign cft_state_o = {CSW{1'b0}};
assign cft_addr_o = {AW{1'b0}};
assign cft_security_o = 1'b0;
assign cft_way_o = {CWW{1'b0}};
assign ccd_ready_o = 1'b0;
assign ccw_valid_o = 1'b0;
assign ccw_poison_o = {DWP{1'b0}};
assign ccw_wdata_o = {DW{1'b0}};
assign ccw_be_o = {BW{1'b0}};
assign ccw_offset_o = {BWL{1'b0}};
assign ccw_last_o = 1'b0;
assign cce_ready_o = 1'b0;
assign w_c1_ready = 1'b1;
assign w_c2_valid = 1'b1;
assign w_c2_chit = 1'b0;
assign w_c2_retry = 1'b0;
assign w_c2_evict = 1'b0;
assign w_c2_room = 1'b0;
assign w_c2_flush = 1'b0;
assign w_c2_sndtr = 1'b0;
assign w_c2_sndtw = 1'b0;
assign w_c2_state = {CSW{1'b0}};
assign t_c2_lookup = 1'b0;
assign w_ce_ready = 1'b0;
assign w_ce_evict = 1'b0;
assign w_ce_af = 1'b0;
assign w_cs_valid = 1'b0;
assign w_cs_poison = {DWP{1'b0}};
assign w_cs_rdata =  {DW{1'b0}};
assign w_cs_be = {BW{1'b0}};
assign w_cs_last = 1'b0;
assign w_cs_count = {BWL{1'b0}};
assign w_cs_security = 1'b0;
assign w_cs_sndtw = 1'b0;
assign w_cs_sndtr = 1'b0;
\js if (!axiParams.wCdData) {
assign w_cs_sid = {STA{1'b0}};
assign w_cs_trace = 1'b0;
\js }
assign t_pvc_throttle = 1'b0;
assign t_pvc_count = 4'h0;
assign w_pvc_ready = 1'b0;
assign w_fq_ready = 1'b1;
assign w_c2_done = 1'b0;
assign cp2_wr_o = 1'b0;
assign w_cdr_valid = 1'b0;
assign w_cdr_last = 1'b0;
assign w_cdr_rdata = {DW{1'b0}};
assign w_cdr_id = {IW{1'b0}};
assign w_cdr_oid = {OCA{1'b0}};
assign w_cdr_eob = 1'b0;
assign w_cdr_track = {AXKW{1'b0}};
assign w_cdr_poison = {DWP{1'b0}};
assign t_pe_correctable_error = 1'b0;
assign t_p1_correctable_error = 1'b0;
assign t_p2_correctable_error = 1'b0;
assign t_p1_skid = {OCN{1'b0}};
assign t_c2_cancel = 1'b0;
assign t_oc_ecount = {OCA+1{1'b0}};
assign t_oc_einc = 1'b0;
assign t_oc_edec = 2'b0;
assign q_oc_ecount_next = {OCA+1{1'h0}};
assign cmr_ready_o = 1'b1;
assign cmr_done_o = w_pt_valid & w_pt_cmr[1] & w_pt_lcmr;
assign t_cmr_stall = 1'b0;
assign t_rr_valid = 1'b0;
assign w_rpt_ready = 1'b1;
assign n_rpt_valid = 1'b0;
assign w_rr_valid = 1'b0;
assign w_rr_addr = {AW{1'b0}};
assign w_rr_len = 8'h0;
assign w_rr_size = 3'h0;
assign w_rr_burst = 2'h0;
assign w_rr_lock = 1'b0;
assign w_rr_cache = 4'h0;
assign w_rr_prot = 3'h0;
assign w_rr_region = {RW{1'b0}};
assign w_rr_qos = {QW{1'b0}};
assign w_rr_id = {IW{1'b0}};
assign w_rr_bar = {MW{1'b0}};
assign w_rr_snoop = {SW{1'b0}};
assign w_rr_vmidext = 4'b0;
assign w_rr_domain = {MW{1'b0}};
assign w_rr_user = {AXUW{1'b0}};
assign w_rr_track = {AXKW{1'b0}};
assign w_rr_atop = {AWTW{1'b0}};
assign w_rr_stashid = {AWSW{1'b0}};
assign w_rr_upmatch = 1'b0;
assign w_rr_up = 2'b0;
assign w_rr_snp = 1'b0;
assign w_rr_write = 1'b0;
assign w_rr_trace = 1'b0;
assign w_rr_wake = 1'b0;
assign w_rr_kid = {XTA{1'b0}};
assign w_rr_partial = 1'b0;
assign w_rr_cmr = 2'h0;
\js for (let i=0;i<3;i++) {
assign w_rr_guts_valid[\=i=\] = 1'b0;
assign w_rr_guts_addr[\=i=\] = {AW{1'b0}};
assign w_rr_guts_len[\=i=\] = 8'h0;
assign w_rr_guts_size[\=i=\] = 3'h0;
assign w_rr_guts_burst[\=i=\] = 2'h0;
assign w_rr_guts_lock[\=i=\] = 1'b0;
assign w_rr_guts_cache[\=i=\] = 4'h0;
assign w_rr_guts_prot[\=i=\] = 3'h0;
assign w_rr_guts_region[\=i=\] = {RW{1'b0}};
assign w_rr_guts_qos[\=i=\] = {QW{1'b0}};
assign w_rr_guts_id[\=i=\] = {IW{1'b0}};
assign w_rr_guts_bar[\=i=\] = {MW{1'b0}};
assign w_rr_guts_snoop[\=i=\] = {SW{1'b0}};
assign w_rr_guts_vmidext[\=i=\] = 4'b0;
assign w_rr_guts_domain[\=i=\] = {MW{1'b0}};
assign w_rr_guts_user[\=i=\] = {AXUW{1'b0}};
assign w_rr_guts_track[\=i=\] = {AXKW{1'b0}};
assign w_rr_guts_atop[\=i=\] = {AWTW{1'b0}};
assign w_rr_guts_stashid[\=i=\] = {AWSW{1'b0}};
assign w_rr_guts_upmatch[\=i=\] = 1'b0;
assign w_rr_guts_up[\=i=\] = 2'b0;
assign w_rr_guts_snp[\=i=\] = 1'b0;
assign w_rr_guts_write[\=i=\] = 1'b0;
assign w_rr_guts_trace[\=i=\] = 1'b0;
assign w_rr_guts_wake[\=i=\] = 1'b0;
assign w_rr_guts_kid[\=i=\] = {XTA{1'b0}};
assign w_rr_guts_partial[\=i=\] = 1'b0;
assign w_rr_guts_cmr[\=i=\] = 2'h0;
\js }
assign n_wq_ready = 1'b0;
assign w_wq_ready = 1'b1;
assign w_wq_valid = 1'b0;
assign w_wq_oid = {OCA{1'b0}};
assign n_wq_oid = {OCA{1'b0}};

assign w_co_valid = 1'b0;
assign t_co_waddr = {ODA{1'b0}};
assign w_co_rdata = {DW{1'b0}};
assign w_co_be = {BW{1'b0}};
assign w_co_poison = {DWP{1'b0}};
assign w_co_oid = {OCA{1'b0}};
assign w_co_obv = {OCN{1'b0}};
assign t_co_fdone = 1'b0;
assign n_odw_valid = 1'b0;
assign {w_odf_ready, w_odr_ready} = w_rn_ready;
assign w_odm_ready = 1'b1;
assign w_odw_ready = 1'b1;
assign n_rn_valid = {n_odf_valid, n_odr_valid};
assign n_rn_raddr = {n_odf_raddr, n_odr_raddr};
assign n_rn_info = {n_odf_pad, n_odf_oid, n_odf_count, n_odf_last, 
		    n_odr_pad, n_odr_bar, n_odr_track, n_odr_oid, n_odr_eob, n_odr_id, 
						       n_odr_resp, n_odr_last};

assign n_rn_ready = {n_odf_ready, n_odr_ready};
assign {w_odf_valid, w_odr_valid} = w_rn_valid;
assign w_odm_valid = 1'b0;
assign n_odw_ready = 1'b0;
assign w_odw_valid = 1'b0;
assign w_odw_last = 1'b0;
assign w_odw_oid = {OCA{1'b0}};
assign {w_odf_poison, w_odf_be, w_odf_rdata,	
	w_odr_poison, w_odr_be, w_odr_rdata} = w_rn_rdata;
assign {w_odm_poison, w_odm_be, w_odm_rdata} = {{DWP{1'b0}}, {BW{1'b0}}, {DW{1'b0}}};
assign {w_odw_poison, w_odw_be, w_odw_rdata} = {{DWP{1'b0}}, {BW{1'b0}}, {DW{1'b0}}};
assign {w_odf_pad, w_odf_oid, w_odf_count, w_odf_last, 
	w_odr_pad, w_odr_bar, w_odr_track, w_odr_oid, w_odr_eob, w_odr_id, w_odr_response, 
						      w_odr_last} = w_rn_info;
assign {w_odr_resp[ARPW-1:0], w_odr_cmo, w_odr_csr} = w_odr_response;
assign w_odm_pad = {ODIW{1'b0}};
assign w_odw_pad = {ODIW-ODWIW{1'b0}};
\js for (let i=0; i<OCN; i=i+1) {
assign t_oc_dstate[\=i=\] = 3'h0;
assign t_oc_way[\=i=\] = {CWW{1'b0}};
\js }

\js } // !useCache

\=u.instance({
	moduleName: 'ioaiu_demux',
	instanceName: 'dt_split',
	params: {
		 NUM:		3,
		 DW:		1,
                 NO_DATA_OUT:   1,
                 clkAssertInterface : clkAssertInterface,
                 assertOn : assertOn
        },
	verilogParams: {
	},
	ports: {
		ready_o:	'n_of_ready',
		valid_i:	'w_of_valid',
		data_i:		`1'b0`,
		ready_i:	`{1'b1,		w_dtw_req0_ready,  w_dtr_req_tx0_ready}`,
		valid_o:	'{w_ce_dropped,	n_dtw_req0_valid,  n_dtr_req_tx0_valid}',
		bvsel_i:	'{t_ce_drop & ~t_ce_dtw_stall, t_ce_dtw, t_ce_dtr}'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\
assign t_of_stash = {2{(AWSE>0) & w_of_valid & q_oc_val[w_of_oid] & 
				  q_oc_write[w_of_oid] &
				  ~t_oc_bar[w_of_oid][0] &
				  ((t_oc_domain[w_of_oid]==2'h1) |
				   (t_oc_domain[w_of_oid]==2'h2)) &
				  q_oc_cache[w_of_oid][1] &
				  t_oc_stashniden[w_of_oid]}} &
		    {(t_oc_snoop[w_of_oid]==4'h8), \js //WriteUniquePtlStash: Mrg
                     (t_oc_snoop[w_of_oid]==4'h9)}; \js //WriteUniqueFullStash: DTR

\js if (STE) {
\js for (let g=0; g<STN; g=g+1) {
\jsbegin
/* istanbul ignore else env ncore_3p4,ncore_3p6,ncore_3p7 */
if (useOwnerTransfer>0) { \jsend
    assign upmatch[\=g=\] = (t_st_up[\=g=\]==2'b11) && (t_st_mpf3[\=g=\][MRCI-PIDW-1:0]==myid_i[MRCI-1:PIDW]) || (t_st_up[\=g=\]==2'b01);
\jsbegin
} else { \jsend
    assign upmatch[\=g=\] = 1'b0;
\jsbegin
} \jsend
\js }
\js }

\js if (STE) {
    wire [STN-1:0]	t_st_delay;
    wire [1:0]	t_st_inc;
    wire		t_st_dec;
    wire [STN-1:0]	w_st_sbv, w_st_fbv;

    wire [STN-1:0]	q_st_val_ns;
    wire [STN-1:0]  q_st_wfdrp, q_st_wfdwp; 
    wire [STN-1:0]  q_st_wfdrp_ns, q_st_wfdwp_ns; 
    wire [STN-1:0]   q_st_chit, q_st_sleep, q_st_wake, q_st_trace, q_st_security;
    wire [STN-1:0]   q_st_chit_ns, q_st_sleep_ns, q_st_wake_ns, q_st_trace_ns, q_st_security_ns;
\jsbegin
// always enabled on 3.6
/* istanbul ignore else env ncore_3p6,ncore_3p7 */
    if (useEarlyDtr) { \jsend
    wire [STN-1:0]	t_st_zomb;
    wire [STN-1:0]   q_st_wfsnp;
    wire [STN-1:0]   q_st_wfsnp_ns;
    wire [STN-1:0]   q_st_wfdtr;
    wire [STN-1:0]   q_st_wfdtr_ns;
\js } // useEarlyDtr
\js if (BSE) {
    wire [SRCB-1:0]	q_st_isize[STN-1:0];
    wire [SRCB-1:0]	q_st_isize_ns[STN-1:0];
\js }
    wire [AW-1:0]	q_st_addr_ns[STN-1:0];
    wire [4:0]	q_st_cmd[STN-1:0];
    wire [4:0]	q_st_cmd_ns[STN-1:0];
    wire [SRCI-1:0]	q_st_iid[STN-1:0];
    wire [SRCI-1:0]	q_st_iid_ns[STN-1:0];
    wire [SRNP-1:0]	q_st_pri[STN-1:0];
    wire [SRNP-1:0]	q_st_pri_ns[STN-1:0];
    wire [SRCM-1:0]	q_st_mid[STN-1:0];
    wire [SRCM-1:0]	q_st_mid_ns[STN-1:0];
    wire [SRCB-1:0]	q_st_bid[STN-1:0];
    wire [SRCB-1:0]	q_st_bid_ns[STN-1:0];
    wire [SRNF-1:0]	q_st_tof[STN-1:0];
    wire [SRNF-1:0]	q_st_tof_ns[STN-1:0];
    wire [SRN1-1:0]	q_st_mpf1[STN-1:0];
    wire [SRN1-1:0]	q_st_mpf1_ns[STN-1:0];
    wire [SRN2-1:0]	q_st_stid[STN-1:0];
    wire [SRN2-1:0]	q_st_stid_ns[STN-1:0];
    wire [SRN3-1:0]	q_st_mpf3[STN-1:0];
    wire [SRN3-1:0]	q_st_mpf3_ns[STN-1:0];
    wire [SRND-1:0]	q_st_sdid[STN-1:0];
    wire [SRND-1:0]	q_st_sdid_ns[STN-1:0];
    wire [CSW-1:0]	q_st_cstate[STN-1:0];
    wire [CSW-1:0]	q_st_cstate_ns[STN-1:0];
    wire [STN-1:0]	q_st_tag_uce;
    wire [STN-1:0]	q_st_tag_uce_ns;
    wire [STN-1:0]	q_st_status;
    wire [STN-1:0]	q_st_status_ns;
    wire [STA:0]	q_st_count;
\js for (let i=0;i<STN;i++) {
    wire q_st_val\=i=\;
    assign q_st_val[\=i=\] = q_st_val\=i=\;
    wire q_st_wfdrp\=i=\, q_st_wfdwp\=i=\;
    assign q_st_wfdrp[\=i=\] = q_st_wfdrp\=i=\;
    assign q_st_wfdwp[\=i=\] = q_st_wfdwp\=i=\;
    wire q_st_chit\=i=\, q_st_sleep\=i=\, q_st_wake\=i=\, q_st_trace\=i=\, q_st_security\=i=\;
    assign q_st_chit[\=i=\] = q_st_chit\=i=\;
    assign q_st_sleep[\=i=\] = q_st_sleep\=i=\;
    assign q_st_wake[\=i=\] = q_st_wake\=i=\;
    assign q_st_trace[\=i=\] = q_st_trace\=i=\;
    assign q_st_security[\=i=\] = q_st_security\=i=\;
\jsbegin
// always enabled on 3.6
/* istanbul ignore else env ncore_3p6,ncore_3p7 */
    if (useEarlyDtr) { \jsend
    wire q_st_wfsnp\=i=\;
    assign q_st_wfsnp[\=i=\] = q_st_wfsnp\=i=\;
    wire q_st_wfdtr\=i=\;
    assign q_st_wfdtr[\=i=\] = q_st_wfdtr\=i=\;
\js } // useEarlyDtr
\js if (BSE) {
    wire [SRCB-1:0]     q_st_isize\=i=\;
    assign q_st_isize[\=i=\] = q_st_isize\=i=\;
\js }
    wire [AW-1:0]       q_st_addr\=i=\;
    assign q_st_addr[\=i=\] = q_st_addr\=i=\;
    wire [4:0]  q_st_cmd\=i=\;
    assign q_st_cmd[\=i=\] = q_st_cmd\=i=\;
    wire [SRCI-1:0]     q_st_iid\=i=\;
    assign q_st_iid[\=i=\] = q_st_iid\=i=\;
    wire [SRNP-1:0]     q_st_pri\=i=\;
    assign q_st_pri[\=i=\] = q_st_pri\=i=\;
    wire [SRCM-1:0]     q_st_mid\=i=\;
    assign q_st_mid[\=i=\] = q_st_mid\=i=\;
    wire [SRCB-1:0]     q_st_bid\=i=\;
    assign q_st_bid[\=i=\] = q_st_bid\=i=\;
    wire [SRNF-1:0]     q_st_tof\=i=\;
    assign q_st_tof[\=i=\] = q_st_tof\=i=\;
    wire [SRN1-1:0]     q_st_mpf1\=i=\;
    assign q_st_mpf1[\=i=\] = q_st_mpf1\=i=\;
    wire [SRN2-1:0]     q_st_stid\=i=\;
    assign q_st_stid[\=i=\] = q_st_stid\=i=\;
    wire [SRN3-1:0]     q_st_mpf3\=i=\;
    assign q_st_mpf3[\=i=\] = q_st_mpf3\=i=\;
    wire [SRND-1:0]     q_st_sdid\=i=\;
    assign q_st_sdid[\=i=\] = q_st_sdid\=i=\;
    wire [CSW-1:0]      q_st_cstate\=i=\;
    assign q_st_cstate[\=i=\] = q_st_cstate\=i=\;
    wire q_st_tag_uce\=i=\;
    assign q_st_tag_uce[\=i=\] = q_st_tag_uce\=i=\;
    wire q_st_status\=i=\;
    assign q_st_status[\=i=\] = q_st_status\=i=\;
\js }

    assign t_st_inc = {(w_snp_req_valid & n_snp_req_ready & w_snp_req_as & (ACE==0)), (n_srs_valid & w_srs_ready) | ((| t_st_ac) & w_ac_ready)};
    assign t_st_dec = (ACE>0) ? t_crs_valid : (w_snp_rsp0_ready & n_snp_rsp0_valid);

   wire [STA:0] q_st_count_p2;
   wire q_st_count_carry2;
   assign {q_st_count_carry2,q_st_count_p2} = {1'b0,q_st_count} + \=STA+1=\'h2;
   wire [STA:0] q_st_count_p1;
   wire q_st_count_carry;
   assign {q_st_count_carry,q_st_count_p1} = {1'b0,q_st_count} + \=STA+1=\'b1;
   wire [STA:0] q_st_count_m1;
   wire q_st_count_underflow;
   assign {q_st_count_underflow,q_st_count_m1} = {1'b0,q_st_count} - 1'b1;
    wire [STA+1-1:0] q_st_count_ns = ((& t_st_inc) & ~t_st_dec) ? q_st_count_p2 : (((| t_st_inc) & ~t_st_dec) | ((& t_st_inc) & t_st_dec)) ? q_st_count_p1 : ((~| t_st_inc) & t_st_dec) ? q_st_count_m1 : q_st_count;
    \=u.dffre(STA+1, `q_st_count`, `q_st_count_ns`, `{`+(STA+1)+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

    \=u.instance({
	moduleName: 'ioaiu_enc',
	instanceName: 'stfree',
	params: {
                DW:             STN,
                BE:             0,
                clkAssertInterface : clkAssertInterface,
		assertOn: assertOn
	},
	ports: {
		bv_i:		'~q_st_val',
		valid_o:	'w_st_ready',
		index_o:	'w_st_fid',
		bv_o:		'w_st_fbv'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
    })=\

\jsbegin
// STN is never reater than 16 for 3.7
/* istanbul ignore if env ncore_3p7 */
    if (STN>32) { \jsend
      \=u.instance({
	moduleName: 'ioaiu_arbiter',
	instanceName: 'stwake',
	params: {
                DRST:           DRST,
                DW:             STN,
                ATOMIC:         0,
                HP:             `{`+STN+`{1'b0}}`,
                VAL:            1,
		 assertOn: assertOn
		 },
	ports: {
		clk_i:		'clk_i',
		reset_ni:	'reset_ni',
		ready_i:	'w_srs_ready',
		bv_i:		't_st_wake',
		lv_i:		`{STN{1'b1}}`,
		winner_o:	'w_st_sid',
		wbv_o:		'w_st_sbv'
	},
	portsDelimiter: '\n\t'
})=\
\js }

wire [SRN2-1:0] w_oc_ahide_tmp;

\js if (concParams.snpReqParams.wMpf2>OCA) {
        assign w_oc_ahide_tmp = {{SRN2-OCA{1'b0}},w_oc_ahide};
\js } else {
        assign w_oc_ahide_tmp = w_oc_ahide[SRN2-1:0];
\js }

\js for (let i=0; i<STN; i=i+1) {

assign t_st_alloc[\=i=\] = w_snp_req_valid & w_st_ready & w_st_fbv[\=i=\];

\jsbegin
// always enabled on 3.7
/* istanbul ignore else env ncore_3p7 */
    if (useEarlyDtr) { \jsend
assign q_st_val_ns[\=i=\] = t_st_alloc[\=i=\] ? 1'b1 : ((t_crs_valid & (w_crq_sid==\=STA=\'d\=i=\) & ~q_st_wfdwp[\=i=\]) | (t_st_fini[\=i=\] )) ? 1'b0 : q_st_val[\=i=\];
\=u.dffre(1, `q_st_val`+i, `q_st_val_ns[`+i+`]`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
\js } else {
assign q_st_val_ns[\=i=\] = t_st_alloc[\=i=\] ? 1'b1 : ((t_crs_valid & (w_crq_sid==\=STA=\'d\=i=\) & ~q_st_wfdwp[\=i=\]) | (w_snp_rsp0_ready & n_snp_rsp0_valid & w_st_dbv[\=i=\])) ? 1'b0 : q_st_val[\=i=\];
\=u.dffre(1, `q_st_val`+i, `q_st_val_ns[`+i+`]`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
\js }

assign t_st_delay[\=i=\] = t_pt_snp & w_pt_kid_oh[\=i=\] & (| t_oc_ahite);
\jsbegin
// always enabled on 3.6
/* istanbul ignore else env ncore_3p6,ncore_3p7 */
    if (useEarlyDtr) { \jsend
assign t_st_done[\=i=\] = q_st_val[\=i=\] & ~q_st_wfdtr[\=i=\] & ~q_st_wfdwp[\=i=\] & 
\js } else {
assign t_st_done[\=i=\] = q_st_val[\=i=\] & ~q_st_wfdrp[\=i=\] & ~q_st_wfdwp[\=i=\] & 
\js }
			            ~q_st_sleep[\=i=\] & (t_cfg_sync_cr_to_snp_rsp ? q_st_wfsnp[\=i=\] : ~t_st_wfcmp[\=i=\]);
\jsbegin
// always enabled on 3.6
/* istanbul ignore else env ncore_3p6,ncore_3p7 */
    if (useEarlyDtr) { \jsend
assign t_st_zomb[\=i=\] = q_st_val[\=i=\] & ~q_st_wfsnp[\=i=\] & (t_cfg_sync_cr_to_snp_rsp ? ~t_st_wfcmp[\=i=\] : 1'b1);
assign t_st_fini[\=i=\] = t_st_zomb[\=i=\];
\js }

\jsbegin
// always enabled on 3.6
/* istanbul ignore else env ncore_3p6,ncore_3p7 */
    if (useEarlyDtr) { \jsend
assign q_st_wfdtr_ns[\=i=\] = t_st_alloc[\=i=\] ? ~w_snp_req_as : ((t_pt_snp & ~w_c2_sndtr & ~w_c2_retry & w_pt_kid_oh[\=i=\]) | (t_crs_valid & (w_crq_sid==\=STA=\'d\=i=\) & ~w_cr_dt & ((w_cdq_sid==\=STA=\'d\=i=\) | (CDW==1) | (t_st_cmd[\=i=\]==SnpDvmMsg))) | (t_crs_valid & (~q_st_wfdwp[w_crq_sid] & (t_st_ptr[w_crq_sid]==\=STA=\'d\=i=\) & ~q_st_addr[w_crq_sid][4]) & ~w_cr_dt) | (w_cdq_valid & (w_cdq_sid==\=STA=\'d\=i=\) & ~t_st_wfcr[\=i=\] & ~t_st_dt[\=i=\]) | (n_cd_ready & w_cd_valid & (w_cdq_sid==\=STA=\'d\=i=\) & ~t_ce_dtr & w_cd_last) | (n_dtr_req_tx0_valid & w_dtr_req_tx0_ready & n_dtr_req_tx0_last & (w_cs_sid==\=STA=\'d\=i=\) & ~t_of_stash[0])) ? 1'b0 : q_st_wfdtr[\=i=\];
\=u.dffre(1, `q_st_wfdtr`+i, `q_st_wfdtr_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
assign q_st_wfsnp_ns[\=i=\] = t_st_alloc[\=i=\] ? 1'b1 : (w_snp_rsp0_ready & n_snp_rsp0_valid & w_st_dbv[\=i=\]) ? 1'b0 : q_st_wfsnp[\=i=\];
\=u.dffre(1, `q_st_wfsnp`+i, `q_st_wfsnp_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
\js }

\jsbegin
// always enabled on 3.7
/* istanbul ignore else env ncore_3p7 */
    if (useEarlyDtr) { \jsend
assign q_st_wfdrp_ns[\=i=\] = t_st_alloc[\=i=\] ? ~w_snp_req_as : ((t_pt_snp & ~w_c2_sndtr & ~w_c2_retry & w_pt_kid_oh[\=i=\]) | (t_crs_valid & (w_crq_sid==\=STA=\'d\=i=\) & ~w_cr_dt & ((w_cdq_sid==\=STA=\'d\=i=\) | (CDW==1) | (t_st_cmd[\=i=\]==SnpDvmMsg))) | (t_crs_valid & (~q_st_wfdwp[w_crq_sid] & (t_st_ptr[w_crq_sid]==\=STA=\'d\=i=\) & ~q_st_addr[w_crq_sid][4]) & ~w_cr_dt) | (w_cdq_valid & (w_cdq_sid==\=STA=\'d\=i=\) & ~t_st_wfcr[\=i=\] & ~t_st_dt[\=i=\]) | (n_cd_ready & w_cd_valid & (w_cdq_sid==\=STA=\'d\=i=\) & ~t_ce_dtr & w_cd_last)| 1'b0 ) ? 1'b0 : q_st_wfdrp[\=i=\];
\=u.dffre(1, `q_st_wfdrp`+i, `q_st_wfdrp_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
\js } else {
assign q_st_wfdrp_ns[\=i=\] = t_st_alloc[\=i=\] ? ~w_snp_req_as : ((t_pt_snp & ~w_c2_sndtr & ~w_c2_retry & w_pt_kid_oh[\=i=\]) | (t_crs_valid & (w_crq_sid==\=STA=\'d\=i=\) & ~w_cr_dt & ((w_cdq_sid==\=STA=\'d\=i=\) | (CDW==1) | (t_st_cmd[\=i=\]==SnpDvmMsg))) | (t_crs_valid & (~q_st_wfdwp[w_crq_sid] & (t_st_ptr[w_crq_sid]==\=STA=\'d\=i=\) & ~q_st_addr[w_crq_sid][4]) & ~w_cr_dt) | (w_cdq_valid & (w_cdq_sid==\=STA=\'d\=i=\) & ~t_st_wfcr[\=i=\] & ~t_st_dt[\=i=\]) | (n_cd_ready & w_cd_valid & (w_cdq_sid==\=STA=\'d\=i=\) & ~t_ce_dtr & w_cd_last)| (t_dtr_req_tx_dec & ~w_dtr_rsp_rx_mid[\=Math.max(OCA, STA)=\] & (w_dtr_rsp_rx_mid[STA-1:0]==\=STA=\'d\=i=\))) ? 1'b0 : q_st_wfdrp[\=i=\];
\=u.dffre(1, `q_st_wfdrp`+i, `q_st_wfdrp_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
\js }

assign q_st_wfdwp_ns[\=i=\] = t_st_alloc[\=i=\] ? ~w_snp_req_as : ((t_pt_snp & ~w_c2_sndtw & ~w_c2_retry & w_pt_kid_oh[\=i=\]) | (w_snp_req_valid & w_st_ready & (w_snp_req_cmd==SnpDvmMsg) & t_st_hits[\=i=\]) | (t_crs_valid & ((~q_st_wfdwp[w_crq_sid] & (t_st_ptr[w_crq_sid]==\=STA=\'d\=i=\) & ~q_st_addr[w_crq_sid][4]) | (w_crq_sid==\=STA=\'d\=i=\)) & ~w_cr_dt) | (n_cd_ready & w_cd_valid & (w_cdq_sid==\=STA=\'d\=i=\) & ~t_ce_dtw & w_cd_last) | (t_dtw_req_dec & w_dtw_rsp_mid[\=Math.max(STA, OCA)=\] & (w_dtw_rsp_mid[STA-1:0]==\=STA=\'d\=i=\))) ? 1'b0 : q_st_wfdwp[\=i=\];
\=u.dffre(1, `q_st_wfdwp`+i, `q_st_wfdwp_ns[`+i+`]`, `{{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

assign q_st_trace_ns[\=i=\] =  t_st_alloc[\=i=\] ? w_snp_req_trace : q_st_trace[\=i=\] ;
\=u.dffre(1, `q_st_trace`+i, `q_st_trace_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
assign q_st_security_ns[\=i=\] =  t_st_alloc[\=i=\] ? w_snp_req_security : q_st_security[\=i=\] ;
\=u.dffre(1, `q_st_security`+i, `q_st_security_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
assign q_st_addr_ns[\=i=\] =  t_st_alloc[\=i=\] ? t_snp_req_addr : q_st_addr[\=i=\] ;
\=u.dffre(AW, `q_st_addr`+i, `q_st_addr_ns[`+i+`]`, `{`+AW+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
assign q_st_cmd_ns[\=i=\] =  t_st_alloc[\=i=\] ? w_snp_req_cmd[4:0] : q_st_cmd[\=i=\] ;
\=u.dffre(5, `q_st_cmd`+i, `q_st_cmd_ns[`+i+`]`, `{5{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
assign q_st_iid_ns[\=i=\] =  t_st_alloc[\=i=\] ? w_snp_req_iid : q_st_iid[\=i=\] ;
\=u.dffre(SRCI, `q_st_iid`+i, `q_st_iid_ns[`+i+`]`, `{`+SRCI+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
assign q_st_pri_ns[\=i=\] =  t_st_alloc[\=i=\] ? w_snp_req_pri : q_st_pri[\=i=\] ;
\=u.dffre(SRNP, `q_st_pri`+i, `q_st_pri_ns[`+i+`]`, `{`+SRNP+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
assign q_st_mid_ns[\=i=\] =  t_st_alloc[\=i=\] ? w_snp_req_mid : q_st_mid[\=i=\] ;
\=u.dffre(SRCM, `q_st_mid`+i, `q_st_mid_ns[`+i+`]`, `{`+SRCM+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
assign q_st_bid_ns[\=i=\] =  t_st_alloc[\=i=\] ? w_snp_req_bid : q_st_bid[\=i=\] ;
\=u.dffre(SRCB, `q_st_bid`+i, `q_st_bid_ns[`+i+`]`, `{`+SRCB+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
assign q_st_tof_ns[\=i=\] =  t_st_alloc[\=i=\] ? w_snp_req_tof : q_st_tof[\=i=\] ;
\=u.dffre(SRNF, `q_st_tof`+i, `q_st_tof_ns[`+i+`]`, `{`+SRNF+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
assign q_st_sdid_ns[\=i=\] =  t_st_alloc[\=i=\] ? w_snp_req_did : q_st_sdid[\=i=\] ;
\=u.dffre(SRND, `q_st_sdid`+i, `q_st_sdid_ns[`+i+`]`, `{`+SRND+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
assign q_st_mpf1_ns[\=i=\] =  t_st_alloc[\=i=\] ? w_snp_req_mpf1 : q_st_mpf1[\=i=\] ;
\=u.dffre(SRN1, `q_st_mpf1`+i, `q_st_mpf1_ns[`+i+`]`, `{`+SRN1+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
assign q_st_stid_ns[\=i=\] =  t_st_alloc[\=i=\] ? w_snp_req_mpf2 : t_st_delay[\=i=\] ? w_oc_ahide_tmp : q_st_stid[\=i=\] ;
\=u.dffre(SRN2, `q_st_stid`+i, `q_st_stid_ns[`+i+`]`, `{`+SRN2+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
assign q_st_mpf3_ns[\=i=\] =  t_st_alloc[\=i=\] ? w_snp_req_mpf3 : q_st_mpf3[\=i=\] ;
\=u.dffre(SRN3, `q_st_mpf3`+i, `q_st_mpf3_ns[`+i+`]`, `{`+SRN3+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
assign q_st_chit_ns[\=i=\] =  (t_st_alloc[\=i=\] & w_snp_req_as) ? 1'b0 : (t_pt_snp & w_pt_kid_oh[\=i=\]) ? w_c2_chit : q_st_chit[\=i=\] ;
\=u.dffre(1, `q_st_chit`+i, `q_st_chit_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
assign q_st_cstate_ns[\=i=\] =  (t_st_alloc[\=i=\] & w_snp_req_as) ? {CSW{1'b0}} : (t_pt_snp & w_pt_kid_oh[\=i=\])? w_c2_state : q_st_cstate[\=i=\] ;
\=u.dffre(CSW, `q_st_cstate`+i, `q_st_cstate_ns[`+i+`]`, `{`+CSW+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
assign q_st_tag_uce_ns[\=i=\] =  (t_st_alloc[\=i=\] & w_snp_req_as) ? 1'b0 : (t_pt_snp & w_pt_kid_oh[\=i=\]) ? cp2_nacks_i[3] : q_st_tag_uce[\=i=\] ;
\=u.dffre(1, `q_st_tag_uce`+i, `q_st_tag_uce_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
assign q_st_status_ns[\=i=\] =  t_st_alloc[\=i=\] ? 1'b0 : (t_pt_snp & w_pt_kid_oh[\=i=\]) ? t_pt_err : q_st_status[\=i=\] ;
\=u.dffre(1, `q_st_status`+i, `q_st_status_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
assign q_st_sleep_ns[\=i=\] =  (t_st_alloc[\=i=\] | (q_st_sleep[\=i=\] & ~q_oc_val[q_st_stid[\=i=\][\=wOCN-1=\:0]])) ? 1'b0 : t_st_delay[\=i=\] ? 1'b1 : q_st_sleep[\=i=\] ;
\=u.dffre(1, `q_st_sleep`+i, `q_st_sleep_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
assign q_st_wake_ns[\=i=\] =  ACE ? 1'b0 : t_st_alloc[\=i=\] ? ~w_snp_req_as & (w_snp_req_cmd != SnpDvmMsg): (n_srs_valid & w_srs_ready & w_st_sbv[\=i=\]) ? 1'b0 : q_st_wake[\=i=\] ;
\=u.dffre(1, `q_st_wake`+i, `q_st_wake_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

\js if (STE && concParams.dtrReqParams.wData>64) {
    assign q_st_isize_ns[\=i=\] = t_st_alloc[\=i=\] ? {{SRCB-2{1'b0}},w_snp_req_isize} : q_st_isize[\=i=\];
    \=u.dffre(SRCB, `q_st_isize`+i, `q_st_isize_ns[`+i+`]`, `{`+SRCB+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
\js }
\js } // for (let i=0; i<STN; i=i+1)

assign t_st_wake = q_st_val & q_st_wake;

\jsbegin
// always enabled on 3.6
/* istanbul ignore else env ncore_3p6,ncore_3p7 */
    if (useEarlyDtr) { \jsend
  assign t_st_done_qual = t_st_done & ~t_st_zomb;
\js } else {
  assign t_st_done_qual = t_st_done;
\js }

\jsbegin
// STN is never reater than 16 for 3.7
/* istanbul ignore if env ncore_3p7 */
    if (STN>32) { \jsend
    \=u.instance({
	moduleName: 'ioaiu_arbiter',
	instanceName: 'stresp',
	params: {
                DRST:           DRST,
                DW:             STN,
                ATOMIC:         0,
                HP:             `{`+OCN+`{1'b0}}`,
		 assertOn: assertOn
		 },
	ports: {
		clk_i:		'clk_i',
		reset_ni:	'reset_ni',
		ready_i:	'w_snp_rsp0_ready',
		bv_i:		't_st_done_qual',
		lv_i:		`{STN{1'b1}}`,
		winner_o:	'w_st_nid',
		wbv_o:		'w_st_dbv'
	},
	portsDelimiter: '\n\t'
    })=\

\js } else {

    \=u.instance({
	moduleName: 'ioaiu_age',
	instanceName: 'stage',
	params: {
                 DRST:           DRST,
                 ARB:            3,
                 NUM:            STN,
                 ATOMIC:         0,
                 HP:             `{`+STN+`{1'b0}}`,
                 VAL:            1,
		 assertOn: assertOn
		 },
	ports: {
		clk_i:		'clk_i',
		reset_ni:	'reset_ni',
		alloc_i:	't_st_alloc',
		ready_i:	`{w_ac_ready,	w_srs_ready,	w_snp_rsp0_ready}`,
		bv_i:		`{t_st_ac,	t_st_wake,	t_st_done_qual}`,
		lv_i:		`{{STN{1'b1}},	{STN{1'b1}},	{STN{1'b1}}}`,
		winner_o:	`{n_ac_sid,	w_st_sid,	w_st_nid}`,
		wbv_o:		`{n_ac_sbv,	w_st_sbv,	w_st_dbv}`
	},
	portsDelimiter: '\n\t'
    })=\

\js }

  assign n_snp_rsp0_valid = (| t_st_done_qual);

  assign n_snp_rsp0_pri = q_st_pri[w_st_nid];
  assign n_snp_rsp0_mid = q_st_mid[w_st_nid];
  assign n_snp_rsp0_tid = q_st_iid[w_st_nid];

  assign n_snp_rsp0_trace = q_st_trace[w_st_nid];

\js // For ACE.
reg t_ce_drop_reg;
\jsbegin
/* istanbul ignore if env ncore_3p4,ncore_3p6,ncore_3p7 */
if (useSharerPromotion==0) {  \jsend
always @(*) begin
  casez (t_st_cmd[w_cdq_sid])
    SnpNITC   : t_ce_drop_reg = t_of_sel[0] && w_cdq_valid && ~t_st_wu[w_cdq_sid] && t_st_dt[w_cdq_sid] && ~t_st_pd[w_cdq_sid] && ~t_st_is[w_cdq_sid] && ~(t_st_up[w_cdq_sid]==2'h1); 
    SnpClnDtr : t_ce_drop_reg = t_of_sel[0] && w_cdq_valid && ~t_st_wu[w_cdq_sid] && t_st_dt[w_cdq_sid] && ~t_st_pd[w_cdq_sid] && ~t_st_is[w_cdq_sid] && ~(t_st_up[w_cdq_sid]==2'h1);
    SnpVldDtr : t_ce_drop_reg = t_of_sel[0] && w_cdq_valid && ~t_st_wu[w_cdq_sid] && t_st_dt[w_cdq_sid] && ~t_st_pd[w_cdq_sid] && ~t_st_is[w_cdq_sid] && ~(t_st_up[w_cdq_sid]==2'h1);
    SnpNoSDInt: t_ce_drop_reg = t_of_sel[0] && w_cdq_valid && ~t_st_wu[w_cdq_sid] && t_st_dt[w_cdq_sid] && ~t_st_pd[w_cdq_sid] && ~t_st_is[w_cdq_sid] && ~(t_st_up[w_cdq_sid]==2'h1);
    SnpInvDtr : t_ce_drop_reg = t_of_sel[0] && w_cdq_valid && ~t_st_wu[w_cdq_sid] && t_st_dt[w_cdq_sid] && ~t_st_pd[w_cdq_sid] && ~t_st_is[w_cdq_sid] && ~upmatch[w_cdq_sid];
    SnpVldDtw : t_ce_drop_reg = t_of_sel[0] && w_cdq_valid && t_st_dt[w_cdq_sid] && ~t_st_pd[w_cdq_sid];
    SnpInvDtw : t_ce_drop_reg = t_of_sel[0] && w_cdq_valid && t_st_dt[w_cdq_sid] && ~t_st_pd[w_cdq_sid];
    SnpUnqStsh: t_ce_drop_reg = t_of_sel[0] && w_cdq_valid && t_st_dt[w_cdq_sid] && ~t_st_pd[w_cdq_sid];
    SnpStshShd: t_ce_drop_reg = t_of_sel[0] && w_cdq_valid && t_st_dt[w_cdq_sid] && ~t_st_pd[w_cdq_sid];
    SnpStshUnq: t_ce_drop_reg = t_of_sel[0] && w_cdq_valid && t_st_dt[w_cdq_sid] && ~t_st_pd[w_cdq_sid];
    SnpInv    : t_ce_drop_reg = t_of_sel[0] && w_cdq_valid;
    SnpInvStsh: t_ce_drop_reg = t_of_sel[0] && w_cdq_valid;
    SnpNITCCI : t_ce_drop_reg = t_of_sel[0] && w_cdq_valid && t_st_dt[w_cdq_sid] && ~t_st_pd[w_cdq_sid] && ~t_st_is[w_cdq_sid];
    SnpNITCMI : t_ce_drop_reg = t_of_sel[0] && w_cdq_valid && t_st_dt[w_cdq_sid] && ~t_st_pd[w_cdq_sid] && ~t_st_is[w_cdq_sid];
    default   : t_ce_drop_reg = 1'b0;
  endcase
end

\jsbegin
} else { \jsend

always @(*) begin
  casez (t_st_cmd[w_cdq_sid])
    SnpNITC   : t_ce_drop_reg = t_of_sel[0] && w_cdq_valid && ~t_st_wu[w_cdq_sid] && t_st_dt[w_cdq_sid] && ~t_st_pd[w_cdq_sid] && ~t_st_is[w_cdq_sid] && ~(t_st_up[w_cdq_sid]==2'h1) && ~(upmatch[w_cdq_sid] && t_st_dt[w_cdq_sid]); 
    SnpClnDtr : t_ce_drop_reg = t_of_sel[0] && w_cdq_valid && ~t_st_wu[w_cdq_sid] && t_st_dt[w_cdq_sid] && ~t_st_pd[w_cdq_sid] && ~t_st_is[w_cdq_sid] && ~(t_st_up[w_cdq_sid]==2'h1) && ~(upmatch[w_cdq_sid] && t_st_dt[w_cdq_sid]);
    SnpVldDtr : t_ce_drop_reg = t_of_sel[0] && w_cdq_valid && ~t_st_wu[w_cdq_sid] && t_st_dt[w_cdq_sid] && ~t_st_pd[w_cdq_sid] && ~t_st_is[w_cdq_sid] && ~(t_st_up[w_cdq_sid]==2'h1) && ~(upmatch[w_cdq_sid] && t_st_dt[w_cdq_sid]);
    SnpNoSDInt: t_ce_drop_reg = t_of_sel[0] && w_cdq_valid && ~t_st_wu[w_cdq_sid] && t_st_dt[w_cdq_sid] && ~t_st_pd[w_cdq_sid] && ~t_st_is[w_cdq_sid] && ~(t_st_up[w_cdq_sid]==2'h1) && ~(upmatch[w_cdq_sid] && t_st_dt[w_cdq_sid]);
    SnpInvDtr : t_ce_drop_reg = t_of_sel[0] && w_cdq_valid && ~t_st_wu[w_cdq_sid] && t_st_dt[w_cdq_sid] && ~t_st_is[w_cdq_sid] && ~upmatch[w_cdq_sid];
    SnpVldDtw : t_ce_drop_reg = t_of_sel[0] && w_cdq_valid && ~t_st_pd[w_cdq_sid] && t_st_dt[w_cdq_sid] && ~t_st_pd[w_cdq_sid];
    SnpInvDtw : t_ce_drop_reg = t_of_sel[0] && w_cdq_valid && t_st_dt[w_cdq_sid] && ~t_st_pd[w_cdq_sid];
    SnpUnqStsh: t_ce_drop_reg = t_of_sel[0] && w_cdq_valid && t_st_dt[w_cdq_sid] && ~t_st_pd[w_cdq_sid];
    SnpStshShd: t_ce_drop_reg = t_of_sel[0] && w_cdq_valid && t_st_dt[w_cdq_sid] && ~t_st_pd[w_cdq_sid];
    SnpStshUnq: t_ce_drop_reg = t_of_sel[0] && w_cdq_valid && t_st_dt[w_cdq_sid] && ~t_st_pd[w_cdq_sid];
    SnpInv    : t_ce_drop_reg = t_of_sel[0] && w_cdq_valid;
    SnpInvStsh: t_ce_drop_reg = t_of_sel[0] && w_cdq_valid;
    SnpNITCCI : t_ce_drop_reg = t_of_sel[0] && w_cdq_valid && ~(upmatch[w_cdq_sid] && t_st_dt[w_cdq_sid] && t_st_pd[w_cdq_sid] & ~t_st_is[w_cdq_sid]);
    SnpNITCMI : t_ce_drop_reg = t_of_sel[0] && w_cdq_valid && ~(upmatch[w_cdq_sid] && t_st_dt[w_cdq_sid] && t_st_pd[w_cdq_sid] & ~t_st_is[w_cdq_sid]);
    default   : t_ce_drop_reg = 1'b0;
  endcase
end

\jsbegin
} \jsend

assign t_ce_drop = t_ce_drop_reg;

\js // For AXI with proxy cache
\jsbegin
/* istanbul ignore if env ncore_3p4,ncore_3p6,ncore_3p7 */
if (useSharerPromotion==0) {  \jsend
  assign t_c2_upmatch_i = 1'b0;
  assign t_c2_up_i = 2'd0;
\jsbegin
} else { \jsend
  assign t_c2_upmatch_i = w_p2_upmatch;
  assign t_c2_up_i = w_p2_up; 
\jsbegin
} \jsend

\js if (cfgACE==0) {
reg n_snp_rsp0_rv_case;
always @(*) begin
  casez (t_st_cmd[w_st_nid])
    SnpClnDtr : n_snp_rsp0_rv_case = (t_st_cstate[w_st_nid]==CST_SC) || upmatch[w_st_nid] && ((t_st_cstate[w_st_nid]==CST_SD) || (t_st_cstate[w_st_nid]==CST_UC) || (t_st_cstate[w_st_nid]==CST_UD));
    SnpNoSDInt: n_snp_rsp0_rv_case = (t_st_cstate[w_st_nid]==CST_SC) || upmatch[w_st_nid] && ((t_st_cstate[w_st_nid]==CST_SD) || (t_st_cstate[w_st_nid]==CST_UC) || (t_st_cstate[w_st_nid]==CST_UD));
    SnpVldDtr:  n_snp_rsp0_rv_case = (t_st_cstate[w_st_nid]==CST_SC) || upmatch[w_st_nid] && ((t_st_cstate[w_st_nid]==CST_SD) || (t_st_cstate[w_st_nid]==CST_UC) || (t_st_cstate[w_st_nid]==CST_UD));
    SnpNITC:    n_snp_rsp0_rv_case = (t_st_cstate[w_st_nid]==CST_SC) || upmatch[w_st_nid] && ((t_st_cstate[w_st_nid]==CST_SD) || (t_st_cstate[w_st_nid]==CST_UC) || (t_st_cstate[w_st_nid]==CST_UD));
    SnpVldDtw:  n_snp_rsp0_rv_case = (t_st_cstate[w_st_nid]==CST_SC) || (t_st_cstate[w_st_nid]==CST_SD) || (t_st_cstate[w_st_nid]==CST_UC) || (t_st_cstate[w_st_nid]==CST_UD);
    SnpStshShd: n_snp_rsp0_rv_case = (t_st_cstate[w_st_nid]==CST_SC) || (t_st_cstate[w_st_nid]==CST_SD) || (t_st_cstate[w_st_nid]==CST_UC) || (t_st_cstate[w_st_nid]==CST_UD);
    default : n_snp_rsp0_rv_case = 1'b0;
  endcase
end
assign n_snp_rsp0_rv = n_snp_rsp0_rv_case;

reg n_snp_rsp0_rs_case;
always @(*) begin
  casez (t_st_cmd[w_st_nid])
    SnpClnDtr : n_snp_rsp0_rs_case = (t_st_cstate[w_st_nid]==CST_SC) || upmatch[w_st_nid] && (t_st_cstate[w_st_nid]==CST_UC);
    SnpNoSDInt: n_snp_rsp0_rs_case = (t_st_cstate[w_st_nid]==CST_SC) || upmatch[w_st_nid] && (t_st_cstate[w_st_nid]==CST_UC);
    SnpVldDtr:  n_snp_rsp0_rs_case = (t_st_cstate[w_st_nid]==CST_SC) || upmatch[w_st_nid] && ((t_st_cstate[w_st_nid]==CST_SD) || (t_st_cstate[w_st_nid]==CST_UC) || (t_st_cstate[w_st_nid]==CST_UD));
    SnpNITC:    n_snp_rsp0_rs_case = (t_st_cstate[w_st_nid]==CST_SC);
    SnpVldDtw:  n_snp_rsp0_rs_case = (t_st_cstate[w_st_nid]==CST_SC) || (t_st_cstate[w_st_nid]==CST_SD);
    SnpStshShd: n_snp_rsp0_rs_case = (t_st_cstate[w_st_nid]==CST_SC) || (t_st_cstate[w_st_nid]==CST_UC);
    default : n_snp_rsp0_rs_case = 1'b0;
  endcase
end
assign n_snp_rsp0_rs = n_snp_rsp0_rs_case;

wire uc_or_ud_state = ((t_st_cstate[w_st_nid]==CST_UC) || (t_st_cstate[w_st_nid]==CST_UD));
wire sc_or_sd_state = ((t_st_cstate[w_st_nid]==CST_SC) || (t_st_cstate[w_st_nid]==CST_SD));

assign n_snp_rsp0_dc =
         upmatch[w_st_nid] ? 
	    (((t_st_cmd[w_st_nid]==SnpVldDtr) && ((t_st_cstate[w_st_nid]==CST_SD) || (t_st_cstate[w_st_nid]==CST_UC) || (t_st_cstate[w_st_nid]==CST_UD))) ||
             ((t_st_cmd[w_st_nid]==SnpInvDtr) && ((sc_or_sd_state && t_st_up[w_st_nid] == 2'b01) || uc_or_ud_state))
            ) : 1'b0;

wire allstate;
assign allstate = (t_st_cstate[w_st_nid]==CST_SC) || (t_st_cstate[w_st_nid]==CST_SD) || (t_st_cstate[w_st_nid]==CST_UC) || (t_st_cstate[w_st_nid]==CST_UD);

assign n_snp_rsp0_dt1 =
         upmatch[w_st_nid] ? 
                 (((t_st_cmd[w_st_nid]==SnpClnDtr)  && allstate) ||
	          ((t_st_cmd[w_st_nid]==SnpNoSDInt) && allstate) ||
		  ((t_st_cmd[w_st_nid]==SnpVldDtr)  && allstate) ||
		  ((t_st_cmd[w_st_nid]==SnpInvDtr)  && ((sc_or_sd_state && t_st_up[w_st_nid] == 2'b01) || uc_or_ud_state)) ||
		  ((t_st_cmd[w_st_nid]==SnpNITC)    && allstate) ||
		  ((t_st_cmd[w_st_nid]==SnpNITCCI)  && allstate) ||
		  ((t_st_cmd[w_st_nid]==SnpNITCMI)  && allstate)
                 ): 1'b0;

assign n_snp_rsp0_dt0 =
                  ((t_st_up[w_st_nid]==2'b11) && (t_st_mpf3[w_st_nid][MRCI-PIDW-1:0]==myid_i[MRCI-1:PIDW]) && (t_st_cmd[w_st_nid]==SnpInvDtr) && sc_or_sd_state) ||
                  (upmatch[w_st_nid] && (t_st_cmd[w_st_nid]==SnpNITCCI) && ((t_st_cstate[w_st_nid]==CST_SD) || (t_st_cstate[w_st_nid]==CST_UD))) ||
                  (t_st_cmd[w_st_nid]==SnpVldDtw) && ((t_st_cstate[w_st_nid]==CST_SD) || (t_st_cstate[w_st_nid]==CST_UD)) || // SnpClnDtw
		  (t_st_cmd[w_st_nid]==SnpInvDtw) && ((t_st_cstate[w_st_nid]==CST_SD) || (t_st_cstate[w_st_nid]==CST_UD)) ||
                  (t_st_cmd[w_st_nid]==SnpUnqStsh) && ((t_st_cstate[w_st_nid]==CST_SD) || (t_st_cstate[w_st_nid]==CST_UD)) ||
                  (t_st_cmd[w_st_nid]==SnpStshUnq) && ((t_st_cstate[w_st_nid]==CST_SD) || (t_st_cstate[w_st_nid]==CST_UD)) ||
                  (t_st_cmd[w_st_nid]==SnpStshShd) && ((t_st_cstate[w_st_nid]==CST_SD) || (t_st_cstate[w_st_nid]==CST_UD));
\js }

wire [4:0] smi_status;
  assign smi_status = {n_snp_rsp0_rv, n_snp_rsp0_rs, n_snp_rsp0_dc, n_snp_rsp0_dt1, n_snp_rsp0_dt0};

  assign n_snp_rsp0_status = (t_st_status[w_st_nid] || t_st_tag_uce[w_st_nid])       ? 8'h84 :
		        ((t_st_cmd[w_st_nid]==SnpDvmMsg) & t_st_error[w_st_nid]) ? 8'h84 :
		         (t_st_error[w_st_nid] & !t_st_dt[w_st_nid])             ? 8'h84 : // If its a data error the error will propogate on the DTW/DTR
		         (t_st_cmd[w_st_nid]==SnpDvmMsg)                         ? 8'h0  : {1'b0, 1'b0, smi_status, 1'b0};		

  \=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'snp_rsp0',
	params: {
                depth:          1,
		width:		SPNW+1,
                pipeForward:    "yes",
                pipeBackward:   "no",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_snp_rsp0_ready',
		in_valid:	'n_snp_rsp0_valid',
		in_data:	`{n_snp_rsp0_trace, n_snp_rsp0_status, 
				  n_snp_rsp0_pri, n_snp_rsp0_mid, n_snp_rsp0_tid}`,
		out_ready:	'n_snp_rsp0_ready',
		out_valid:	'w_snp_rsp0_valid',
		out_data:	`{w_snp_rsp0_trace, w_snp_rsp0_status, 
				  w_snp_rsp0_pri, w_snp_rsp0_mid, w_snp_rsp0_tid}`
	},
	portsDelimiter: '\n\t'
  })=\

  \=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'snp_rsp1',
	params: {
                depth:          1,
		width:		SPNW+1,
                pipeForward:    "no",
                pipeBackward:   "yes",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'n_snp_rsp0_ready',
		in_valid:	'w_snp_rsp0_valid',
		in_data:	`{w_snp_rsp0_trace, w_snp_rsp0_status, 
				  w_snp_rsp0_pri, w_snp_rsp0_mid, w_snp_rsp0_tid}`,
		out_ready:	'n_snp_rsp1_ready',
		out_valid:	'w_snp_rsp1_valid',
		out_data:	`{w_snp_rsp1_trace, w_snp_rsp1_status, 
				  w_snp_rsp1_pri, w_snp_rsp1_mid, w_snp_rsp1_tid}`
	},
	portsDelimiter: '\n\t'
  })=\
	  
  assign n_snp_rsp1_ready = snp_rsp_ready_i;
  assign snp_rsp_valid_o = w_snp_rsp1_valid;
  assign snp_rsp_trace_o = w_snp_rsp1_trace;
  assign snp_rsp_cmd_o = SnpRsp;
  assign snp_rsp_status_o = w_snp_rsp1_status;
  assign snp_rsp_mpf1_o = {SPN1{1'b0}};
  assign snp_rsp_mid_o = {SRNM{1'b0}};
  assign snp_rsp_rid_o = w_snp_rsp1_mid;
  assign snp_rsp_iid_o = cmd_req_iid_o;
  assign snp_rsp_tid_o = w_snp_rsp1_tid;
  assign snp_rsp_pri_o = w_snp_rsp1_pri;
  assign snp_rsp_ql_o = {SPNL{1'b0}};
  assign t_st_count = q_st_count;
  assign t_st_val = q_st_val;
  assign t_st_wfdrp = q_st_wfdrp;
  assign t_st_wfdwp = q_st_wfdwp;
  assign t_st_chit = q_st_chit;
  assign t_st_sleep = q_st_sleep;
  assign t_st_security = q_st_security;
  assign t_st_trace = q_st_trace;
	  
\js for (let i=0; i<STN; i=i+1) {
    assign t_st_isize[\=i=\] =
\js   if (BSE) {
                               q_st_isize[\=i=\][1:0];
\js } else {
                               2'h0;
\js }
    assign t_st_addr[\=i=\] = q_st_addr[\=i=\];
    assign t_st_cmd[\=i=\] = {3'h2, q_st_cmd[\=i=\]};
    assign t_st_iid[\=i=\] = q_st_iid[\=i=\];
    assign t_st_pri[\=i=\] = q_st_pri[\=i=\];
    assign t_st_mid[\=i=\] = q_st_mid[\=i=\];
    assign t_st_bid[\=i=\] = q_st_bid[\=i=\];
    assign t_st_tof[\=i=\] = q_st_tof[\=i=\];
    assign t_st_sdid[\=i=\] = q_st_sdid[\=i=\];
    assign t_st_mpf1[\=i=\] = q_st_mpf1[\=i=\];
    assign t_st_stid[\=i=\] = q_st_stid[\=i=\];
    assign t_st_mpf3[\=i=\] = q_st_mpf3[\=i=\];
\js if (3>CSW) {
    assign t_st_cstate[\=i=\] = {{\=3-CSW=\{1'b0}},q_st_cstate[\=i=\]};
\js } else {
    assign t_st_cstate[\=i=\] = q_st_cstate[\=i=\];
\js }
    assign t_st_tag_uce[\=i=\] = q_st_tag_uce[\=i=\];
    assign t_st_status[\=i=\] = q_st_status[\=i=\];	  
\js }
\js } else { // STE
  // Need for Idle and Other Snoop Logic
  assign w_snp_rsp0_valid = 1'b0; 
  assign w_snp_rsp1_valid = 1'b0;
  assign t_ce_drop = 1'b0;
\js } // STE

\js if (STE) {
  wire [1:0] q_st_up[STN-1:0];
  wire [1:0] q_st_up_ns[STN-1:0];
\js for (let i=0; i<STN; i=i+1) {
    wire [1:0] q_st_up\=i=\;
    assign q_st_up[\=i=\] = q_st_up\=i=\;
    assign q_st_up_ns[\=i=\] = t_st_alloc[\=i=\] ? w_snp_req_up : q_st_up[\=i=\];
    \=u.dffre(2, `q_st_up`+i, `q_st_up_ns[`+i+`]`, `2'd0`, `1'b1`, `clk_i`, `reset_ni`)=\
\js }
\js }

\js if (ACE) {
    wire		n_rkq_ready,	n_wkq_ready;
    wire [OCA-1:0]	w_rkq_oid,	w_wkq_oid;
    wire [STN-1:0]	t_st_dvm;
    wire [STN-1:0]	t_st_dvm_alt;
    wire [STA-1:0]	w_st_hid;
    wire		w_st_hit;
wire [3:0]	t_ac_sel;
wire		w_ac0_ready,	n_ac0_ready;
wire		n_ac0_valid,	w_ac0_valid;
wire [3:0]	n_ac0_cmd,	w_ac0_cmd;
wire     	n_ac0_track,	w_ac0_track;
wire [3:0]      n_ac0_vmidext,	w_ac0_vmidext;
wire		n_ac0_pr,	w_ac0_pr,	w_ac1_pr;
wire		n_ac0_ns,	w_ac0_ns,	w_ac1_ns;
wire [AW-1:0]	n_ac0_addr,	w_ac0_addr;
wire		w_crq_ready,	n_crq_ready;
wire		n_crq_valid,	w_crq_valid;
wire [XTA:0]	n_crq_data,	w_crq_data;
wire		n_cdq_valid;
wire		w_cmq_ready;
wire		n_cmq_valid;
wire [STA-1:0]	n_cmq_sid;
wire		w_cr_valid;
wire [4:0]	w_cr_resp;

wire [STN-1:0]	q_st_pr, q_st_wfac, q_st_wfcr, q_st_wfcmp;
wire [STN-1:0]	q_st_pr_ns, q_st_wfac_ns, q_st_wfcr_ns, q_st_wfcmp_rsp_ns;
wire [4:0]	q_st_cresp[STN-1:0];
wire [4:0]	q_st_cresp_ns[STN-1:0];
wire [STA-1:0]	q_st_ptr[STN-1:0];
wire [STA-1:0]	q_st_ptr_ns[STN-1:0];
wire [STA-1:0]	q_st_sid;
wire [STA-1:0]	q_st_sidp;
wire [STN-1:0]	q_st_2nd;
wire [STN-1:0]	q_st_2nd_ns;
wire		q_dvm_state;

\=u.instance({
	moduleName: 'ioaiu_enc',
	instanceName: 'sthit',
	params: {
                DW:             STN,
                BE:             0,
                NO_BV_OUT:      1,
                clkAssertInterface : clkAssertInterface,
		assertOn: assertOn
	},
	ports: {
		bv_i:		't_st_hits',
		valid_o:	'w_st_hit',
		index_o:	'w_st_hid'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

\js for (let i=0; i<STN; i=i+1) {
  wire [4:0] q_st_cresp\=i=\;
  assign q_st_cresp[\=i=\] = q_st_cresp\=i=\;
  wire [STA-1:0] q_st_ptr\=i=\;
  assign q_st_ptr[\=i=\] = q_st_ptr\=i=\;
  wire q_st_pr\=i=\;
  assign q_st_pr[\=i=\] = q_st_pr\=i=\;
  wire q_st_wfac\=i=\;
  assign q_st_wfac[\=i=\] = q_st_wfac\=i=\;
  wire q_st_2nd\=i=\;
  assign q_st_2nd[\=i=\] = q_st_2nd\=i=\;
  wire q_st_wfcr\=i=\;
  assign q_st_wfcr[\=i=\] = q_st_wfcr\=i=\;
  wire q_st_wfcmp\=i=\;
  assign q_st_wfcmp[\=i=\] = q_st_wfcmp\=i=\;
\js }

\js for (let i=0; i<STN; i=i+1) {
  assign t_st_hits[\=i=\] = t_st_val[\=i=\] & (t_st_cmd[\=i=\]==SnpDvmMsg) & (q_st_ptr[\=i=\]==\=STA=\'d\=i=\);

  assign q_st_wfac_ns[\=i=\] = t_st_alloc[\=i=\] ? ~(w_snp_req_as | (w_snp_req_valid & w_st_ready & w_st_hit & (w_snp_req_cmd==SnpDvmMsg) & ~t_st_addr[w_st_hid][4])) : (n_ac_sbv[\=i=\] & w_ac_ready) ? 1'b0 : q_st_wfac[\=i=\];
  \=u.dffre(1, `q_st_wfac`+i, `q_st_wfac_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_st_wfcr_ns[\=i=\] = t_st_alloc[\=i=\] ? ~(w_snp_req_as | (w_snp_req_valid & w_st_ready & w_st_hit & (w_snp_req_cmd==SnpDvmMsg) & ~t_st_addr[w_st_hid][4])) : (t_crs_valid & (w_crq_sid==\=STA=\'d\=i=\)) ? 1'b0 : q_st_wfcr[\=i=\];
  \=u.dffre(1, `q_st_wfcr`+i, `q_st_wfcr_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_st_2nd_ns[\=i=\] = t_st_alloc[\=i=\] ? (w_snp_req_valid & w_st_ready & w_st_hit & (w_snp_req_cmd==SnpDvmMsg) & t_st_addr[w_st_hid][4]) : q_st_2nd[\=i=\];
  \=u.dffre(1, `q_st_2nd`+i, `q_st_2nd_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_st_wfcmp_rsp_ns[\=i=\] = ((n_cmq_ready & w_cmq_valid & (w_cmq_sid==\=STA=\'d\=i=\)) | t_st_alloc[\=i=\]) ? 1'b0 : (w_cmq_ready & n_cmq_valid & (n_cmq_sid==\=STA=\'d\=i=\)) ? 1'b1 : q_st_wfcmp[\=i=\];
  \=u.dffre(1, `q_st_wfcmp`+i, `q_st_wfcmp_rsp_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_st_cresp_ns[\=i=\] = t_st_alloc[\=i=\] ? {5{\=DRST=\}} : (t_crs_valid & (((t_st_cmd[\=i=\]==SnpDvmMsg) & (q_st_ptr[w_crq_sid]==\=STA=\'d\=i=\) & (w_crq_sid==q_st_ptr[\=i=\])) | (w_crq_sid==\=STA=\'d\=i=\))) ? w_cr_resp : (w_cd_valid & n_cd_ready & w_cd_last & (w_cdq_sid==\=STA=\'d\=i=\) & t_st_error[\=i=\] & ~t_ce_drop) ? q_st_cresp[\=i=\] & 5'h1d : q_st_cresp[\=i=\];
  \=u.dffre(5, `q_st_cresp`+i, `q_st_cresp_ns[`+i+`]`, `{5{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_st_ptr_ns[\=i=\] = (t_st_alloc[\=i=\] & w_st_hit & (w_snp_req_cmd==SnpDvmMsg)) ? w_st_hid : t_st_alloc[\=i=\] ? \=STA=\'d\=i=\ : (w_snp_req_valid & w_st_ready & (w_snp_req_cmd==SnpDvmMsg) & t_st_hits[\=i=\]) ? w_st_fid : q_st_ptr[\=i=\];
  \=u.dffre(STA, `q_st_ptr`+i, `q_st_ptr_ns[`+i+`]`, `{`+STA+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign q_st_pr_ns[\=i=\] = t_st_alloc[\=i=\] ? w_snp_req_pr : q_st_pr[\=i=\];
  \=u.dffre(1, `q_st_pr`+i, `q_st_pr_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

  assign {t_st_wu[\=i=\], t_st_is[\=i=\], t_st_pd[\=i=\], t_st_error[\=i=\], t_st_dt[\=i=\]} = q_st_cresp[\=i=\];
  assign t_st_dvm_alt[\=i=\] = t_st_val[\=i=\] & (t_st_cmd[\=i=\]==SnpDvmMsg) & q_st_wfac[\=i=\] & n_ac_sbv[\=i=\] & (q_dvm_state ? (q_st_ptr[q_st_sid]==\=STA=\'d\=i=\) : ~t_st_wfdwp[\=i=\]);  
  assign t_st_ac_alt[\=i=\] = t_st_val[\=i=\] & q_st_wfac[\=i=\] & t_st_wfdrp[\=i=\] & (q_dvm_state ? (q_st_ptr[q_st_sid]==\=STA=\'d\=i=\) : w_cmp_rsp_valid ? 1'b0 : (t_st_cmd[\=i=\]!=SnpDvmMsg) ? 1'b1 : ~t_st_wfdwp[\=i=\]);
  assign t_st_dvm[\=i=\] = t_st_val[\=i=\] & (t_st_cmd[\=i=\]==SnpDvmMsg) & q_st_wfac[\=i=\] & n_ac_sbv[\=i=\] & (q_dvm_state ? (q_st_sidp==\=STA=\'d\=i=\) : ~t_st_wfdwp[\=i=\]);
  assign t_st_ac[\=i=\] = t_st_val[\=i=\] & q_st_wfac[\=i=\] & t_st_wfdrp[\=i=\] & (q_dvm_state ? (q_st_sidp==\=STA=\'d\=i=\) : w_cmp_rsp_valid ? 1'b0 : (t_st_cmd[\=i=\]!=SnpDvmMsg) ? 1'b1 : ~t_st_wfdwp[\=i=\]);

\js } // (let i=0; i<STN; i=i+1)

wire q_dvm_state_ns = q_dvm_state ? ~((| t_st_dvm) & w_ac_ready) : (| t_st_dvm) & w_ac_ready & t_st_addr[n_ac_sid][4];
\=u.dffre(1, `q_dvm_state`, `q_dvm_state_ns`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
wire [STA-1:0] q_st_sid_ns = (~q_dvm_state & (| t_st_dvm) & w_ac_ready) ? n_ac_sid : q_st_sid;
\=u.dffre(STA, `q_st_sid`, `q_st_sid_ns`, `{`+STA+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
wire [STA-1:0] q_st_sidp_ns = (~q_dvm_state & (| t_st_dvm) & w_ac_ready) ? t_st_ptr[n_ac_sid] : q_st_sidp;
\=u.dffre(STA, `q_st_sidp`, `q_st_sidp_ns`, `{`+STA+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

\jsbegin
// STN is never reater than 16 for 3.7
/* istanbul ignore if env ncore_3p7 */
    if (STN>32) { \jsend
  \=u.instance({
	moduleName: 'ioaiu_arbiter',
	instanceName: 'stac',
	params: {
                DRST:           DRST,
                DW:             STN,
                ATOMIC:         0,
                HP:             `{`+STN+`{1'b0}}`,
                VAL:            1,
		 assertOn: assertOn
		 },
	ports: {
		clk_i:		'clk_i',
		reset_ni:	'reset_ni',
		ready_i:	'w_ac_ready',
		bv_i:		't_st_ac',
		lv_i:		`{STN{1'b1}}`,
		winner_o:	'n_ac_sid',
		wbv_o:		'n_ac_sbv'
	},
	portsDelimiter: '\n\t'
  })=\
\js }

assign n_ac_valid = (| t_st_ac) | w_cmp_rsp_valid;

\=u.instance({
	moduleName: 'ioaiu_demux',
	instanceName: 'ac_split',
	params: {
		 NUM:		4,
		 DW:		1,
                 NO_DATA_OUT:   1,
                 clkAssertInterface : clkAssertInterface,
                 assertOn : assertOn
        },
	verilogParams: {
	},
	ports: {
		ready_o:	'w_ac_ready',
		valid_i:	'n_ac_valid',
		data_i:		`1'b0`,
		ready_i:	`{w_cmq_ready, 
				  w_cdq_ready, w_crq_ready, w_ac0_ready}`,
		valid_o:	`{n_cmq_valid, 
				  n_cdq_valid, n_crq_valid, n_ac0_valid}`,
		bvsel_i:	't_ac_sel'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

assign t_ac_sel = ((~q_dvm_state & (| t_st_dvm) &
			 ~t_st_addr[n_ac_sid][4] &
			 (t_st_addr[n_ac_sid][13:11]==3'h4)) |
		   (q_dvm_state & (| t_st_dvm) &
			 (t_st_addr[q_st_ptr[n_ac_sid]][13:11]==3'h4))) ? 4'hb :
		   (t_st_count >= t_cfg_st_limit) ? 4'h0 :
		   (//(~q_dvm_state & (| t_st_dvm) & t_st_addr[n_ac_sid][4]) |
		    (| t_st_dvm) | w_cmp_rsp_valid) ? 4'h3 :
						  4'h7;

assign n_cmq_sid = q_dvm_state ? n_ac_sid : q_st_ptr[n_ac_sid];
assign n_cmq_ready = t_pt_dvm;

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'cmq',
	params: {
                depth:          (STN<=16)?STN:/* istanbul ignore next env ncore_3p7 */16,
		width:		STA,
                pipeForward:    "yes",
                pipeBackward:   "yes",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_cmq_ready',
		in_valid:	'n_cmq_valid',
		in_data:	'n_cmq_sid',
		out_ready:	'n_cmq_ready',
		out_valid:	'w_cmq_valid',
		out_data:	'w_cmq_sid'
	},
	portsDelimiter: '\n\t'
})=\

wire [\=XTA-1=\:0] w_cmp_rsp_mid_tmp =
\js if (XTA>OCA) {
                                   {{\=XTA-OCA=\{1'b0}},w_cmp_rsp_mid[OCA-1:0]};
\js } else {
                                                        w_cmp_rsp_mid[OCA-1:0];
\js }
wire [\=XTA-1=\:0] n_ac_sid_tmp =
\js if (XTA>STA) {
                                   {{\=XTA-STA=\{1'b0}},n_ac_sid[STA-1:0]};
\js } else {
                                                        n_ac_sid[STA-1:0];
\js }

assign n_crq_data = w_cmp_rsp_valid ? {1'b1, w_cmp_rsp_mid_tmp} :
				  {1'b0, n_ac_sid_tmp};

assign n_crq_ready = w_cr_valid;

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'acq',
	params: {
                depth:          (STN<=16)?STN:/* istanbul ignore next env ncore_3p7 */16,
		width:		1+XTA,
                pipeForward:    "yes",
                pipeBackward:   "yes",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_crq_ready',
		in_valid:	'n_crq_valid',
		in_data:	'n_crq_data',
		out_ready:	'n_crq_ready',
		out_valid:	'w_crq_valid',
		out_data:	'w_crq_data'
	},
	portsDelimiter: '\n\t'
})=\

assign t_crq_valid = w_crq_valid;

assign w_crq_sid = w_crq_data[STA-1:0];
assign w_crq_oid = w_crq_data[OCA-1:0];

assign n_ac0_track = t_st_trace[n_ac_sid];

wire [3:0] ac0_st_cmd;
reg [3:0] ac0_st_cmd_case;
always @(*) begin
  case (t_st_cmd[n_ac_sid])
    SnpVldDtr   : ac0_st_cmd_case = 4'h1;
    SnpClnDtr   : ac0_st_cmd_case = 4'h2;
    SnpNITC     : ac0_st_cmd_case = 4'h0;
    SnpInvDtr   : ac0_st_cmd_case = 4'h7;
    SnpVldDtw   : ac0_st_cmd_case = 4'h8;
    SnpInvDtw   ,
    SnpUnqStsh  ,
    SnpStshShd  ,
    SnpStshUnq  ,
    SnpNITCCI   ,
    SnpNITCMI   : ac0_st_cmd_case = 4'h9;
    SnpInv      ,
    SnpInvStsh  : ac0_st_cmd_case = 4'hd;
    SnpDvmMsg   : ac0_st_cmd_case = 4'hf;
    SnpNoSDInt  : ac0_st_cmd_case = 4'h3;
    default     : ac0_st_cmd_case = 4'h0;
  endcase
end

assign ac0_st_cmd = ac0_st_cmd_case;

assign n_ac0_cmd = w_cmp_rsp_valid ? 4'he : ac0_st_cmd;

assign {n_ac0_pr, n_ac0_ns} = (w_cmp_rsp_valid |
			       (t_st_cmd[n_ac_sid]==SnpDvmMsg)) ? 2'h0 :
						     {t_st_pr[n_ac_sid],
						      t_st_security[n_ac_sid]};

\jsbegin
// FIXME: Should have a dvm config with AW=48; No ACE configs have AW>48
/* istanbul ignore else env ncore_3p6 */
    if(AW<48) { \jsend
wire [47:0]	t_dvm_addr_0 = {{48-AW{1'b0}},t_st_addr[n_ac_sid]};
wire [47:0]	t_dvm_addr_1 = {{48-AW{1'b0}},t_st_addr[q_st_ptr[n_ac_sid]]};
\js } else {
wire [47:0]	t_dvm_addr_0 = t_st_addr[n_ac_sid][47:0];
wire [47:0]	t_dvm_addr_1 = t_st_addr[q_st_ptr[n_ac_sid]][47:0];
\js }
wire [SRN1-1:0] t_dvm_mpf1_0 = t_st_mpf1[n_ac_sid][SRN1-1:0];
wire [SRN1-1:0] t_dvm_mpf1_1 = t_st_mpf1[q_st_ptr[n_ac_sid]][SRN1-1:0];

wire [SRN3-1:0] t_dvm_mpf3_0 = t_st_mpf3[n_ac_sid][SRN3-1:0];
wire [SRN3-1:0] t_dvm_mpf3_1 = t_st_mpf3[q_st_ptr[n_ac_sid]][SRN3-1:0];

wire t_dvm_range_bit_set = t_dvm_mpf3_0[1];
wire t_dvm_pici        = (t_dvm_addr_1[13:11] == 3'b010);
wire t_dvm_onepart     = (t_dvm_addr_0[4] == 1'b0);
wire [47:0] n_ac0_addr_2nd  = { 
                  t_dvm_pici ?  t_dvm_addr_0[45]           // [47:47] PA[47]
                             :  t_dvm_addr_1[45],          //         VA[52]

                  t_dvm_pici ? {t_dvm_addr_0[44],          // [46:46] PA[46]
                                t_dvm_addr_0[43],          // [45:45] PA[45]
                                t_dvm_addr_0[42:39],       // [44:41] PA[44:41]
                                t_dvm_addr_0[38]}          // [40:40] PA[40]

                             : {t_dvm_addr_0[45],          // [46:46] VA[51]
                                t_dvm_addr_1[44],          // [45:45] VA[50]
                                t_dvm_addr_0[44],          // [44:44] VA[49]
                                t_dvm_addr_0[42:39]},      // [43:40] VA[44:41]

				t_dvm_addr_0[37:10],	   // [39:12] VA[39:12]/PA[39:12]
				t_dvm_addr_0[9:8],	   // [11:10] TG[1:0]/VA[11:10]/PA[11:10]
				t_dvm_addr_0[7:6],	   // [ 9: 8] TTL[1:0]/VA[9:8]/PA[9:8]
				t_dvm_addr_0[5:4],	   // [ 7: 6] Scale[1:0]/VA[7:6]/PA[7:6]
	                        t_dvm_mpf3_0[5:4],	   // [ 5: 4] Num[4:3]/VA[5:4]/PA[5:4]

                  t_dvm_pici ?  1'b0                       // Reserved
                             :  t_dvm_addr_0[38],          // [ 3: 3] VA[40]

				t_dvm_mpf3_0[3],	   // [ 2: 2] NUM[2]
				t_dvm_mpf3_0[2],	   // [ 1: 1] NUM[1]
				t_dvm_mpf3_0[1]};	   // [ 0: 0] NUM[0]

wire [47:0] n_ac0_addr_1st  = { t_dvm_mpf1_1[3:0],         // [47:44] VA[56:53]

               t_dvm_onepart ?  t_dvm_mpf1_0[7:4]          // [43:40] VA[48:45] or VMID[15:12]

                             : {t_dvm_addr_0[43:41],
                                t_dvm_addr_1[43]},

				t_dvm_addr_0[37:30],	   // [39:32] ASID[15:8]
				t_dvm_addr_0[21:14],	   // [31:24] VMID[7:0] or VA[27:20]
				t_dvm_addr_0[29:22],	   // [23:16] ASID[7:0] or VA[19:12]
			       (t_dvm_addr_0[13:11]==3'h4),// [15:15] CompletionRequired
			  	t_dvm_addr_0[13:11],	   // [14:12] DVMOp Type
				t_dvm_addr_0[10:9],	   // [11:10] Exception Level (Guest/Hypervisor)
				t_dvm_addr_0[8:7],	   // [ 9: 8] Security
				t_dvm_mpf3_0[1],	   // [ 7: 7] Range
				t_dvm_addr_0[5],	   // [ 6: 6] VMID_valid
				t_dvm_addr_0[6],	   // [ 5: 5] ASID_valid
				t_dvm_addr_0[40],	   // [ 4: 4] LeafEntry Invalidation
				t_dvm_addr_0[39:38],	   // [ 3: 2] Staged Invalidation
				1'b0,			   // [ 1: 1] Reserved
				t_dvm_addr_0[4]};          // [ 0: 0] Single/two part
\jsbegin
// No ACE configs have AW>48
/* istanbul ignore if env ncore_3p6,ncore_3p7 */
    if(AW>48) { \jsend
	assign n_ac0_addr = w_cmp_rsp_valid ? {AW{1'b0}} :
		    		q_dvm_state ? {{AW-48{1'b0}},n_ac0_addr_2nd } :		
		    		(t_st_cmd[n_ac_sid]==SnpDvmMsg) ? {{AW-48{1'b0}},n_ac0_addr_1st } :	//2-part message
													t_st_addr[n_ac_sid] & ({AW{1'b1}}<<AWL);
\js } else {
	assign n_ac0_addr = w_cmp_rsp_valid ? {AW{1'b0}} :
		    		q_dvm_state ? n_ac0_addr_2nd [AW-1:0] :		
		    		(t_st_cmd[n_ac_sid]==SnpDvmMsg) ? n_ac0_addr_1st [AW-1:0] :	//2-part message
													t_st_addr[n_ac_sid] & ({AW{1'b1}}<<AWL);
\js }
        assign n_ac0_vmidext[3:0] = q_dvm_state ? t_dvm_mpf1_1[7:4] :
                                    (t_st_cmd[n_ac_sid]==SnpDvmMsg) ? t_dvm_mpf1_0[3:0] : //2-part message
                                                                                          4'b0;
\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'ac0',
	params: {
                depth:          1,
		width:		4+2+AW+1+4,
                pipeForward:    "yes",
                pipeBackward:   "no",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_ac0_ready',
		in_valid:	'n_ac0_valid',
		in_data:	`{n_ac0_vmidext,n_ac0_track, n_ac0_cmd, n_ac0_pr, n_ac0_ns, n_ac0_addr}`,
		out_ready:	'n_ac0_ready',
		out_valid:	'w_ac0_valid',
		out_data:	`{w_ac0_vmidext,w_ac0_track, w_ac0_cmd, w_ac0_pr, w_ac0_ns, w_ac0_addr}`
	},
	portsDelimiter: '\n\t'
})=\

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'ac1',
	params: {
                depth:          2,
		width:		4+2+AW+1+4,
                pipeForward:    "yes",
                pipeBackward:   "yes",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'n_ac0_ready',
		in_valid:	'w_ac0_valid',
		in_data:	`{w_ac0_vmidext,w_ac0_track, w_ac0_cmd, w_ac0_pr, w_ac0_ns, w_ac0_addr}`,
		out_ready:	'ac_ready_i',
		out_valid:	'ac_valid_o',
		out_data:	`{ac_vmidext_o,ac_track_o, ac_snoop_o, w_ac1_pr, w_ac1_ns, ac_addr_o}`
	},
	portsDelimiter: '\n\t'
})=\

assign ac_prot_o = {1'b0, w_ac1_ns, w_ac1_pr};

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'cr',
	params: {
                depth:          2,
		width:		5,
                pipeForward:    "yes",
                pipeBackward:   "yes",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'cr_ready_o',
		in_valid:	'cr_valid_i',
		in_data:	'cr_resp_i',
		out_ready:	`1'b1`,
		out_valid:	'w_cr_valid',
		out_data:	'w_cr_resp'
	},
	portsDelimiter: '\n\t'
})=\

assign t_cro_valid = w_cr_valid & w_crq_data[XTA];
assign t_crs_valid = w_cr_valid & ~w_crq_data[XTA];
assign {w_cr_wu, w_cr_is, w_cr_pd, w_cr_error, w_cr_dt} = w_cr_resp;
assign t_cr_resp = w_cr_resp;

wire [OCN-1:0]	q_oc_wfack;
wire [OCN-1:0]	q_oc_wfack_ns;

\js for (let i=0; i<OCN; i=i+1) {
wire q_oc_wfack\=i=\;
assign q_oc_wfack[\=i=\] = q_oc_wfack\=i=\;

\js if (isDvmAgent && !axiParams.wCdData) {
assign t_oc_wfack_stp[\=i=\] = 1'b0;
assign q_oc_wfack_ns[\=i=\] = t_oc_alloc[\=i=\] ? n_oc_eob : ((t_oc_rack[\=i=\] & (~q_oc_write[\=i=\] | t_oc_atop_rw[\=i=\])) | (t_oc_wack[\=i=\] & q_oc_write[\=i=\] & ~t_oc_atop_rw[\=i=\])) ? 1'b0 : q_oc_wfack[\=i=\];
\=u.dffre(1, `q_oc_wfack`+i, `q_oc_wfack_ns[`+i+`]`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
\js } else {
assign t_oc_wfack_stp[\=i=\] = q_oc_wfack[\=i=\];
assign q_oc_wfack_ns[\=i=\] = t_oc_alloc[\=i=\] ? n_oc_eob : ((t_oc_rack[\=i=\] & ~q_oc_write[\=i=\]) | (t_oc_wack[\=i=\] & q_oc_write[\=i=\])) ? 1'b0 : q_oc_wfack[\=i=\];
\=u.dffre(1, `q_oc_wfack`+i, `q_oc_wfack_ns[`+i+`]`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
\js }

assign t_oc_wfack[\=i=\] = q_oc_wfack[\=i=\];
\js } // (let i=0; i<OCN; i=i+1)

wire rack_int;
wire wack_int;
\js if (axiParams.wCdData) {
assign rack_int = rack_i;
assign wack_int = wack_i;
\js } else {
\=u.dffre(1, `rack_int`, `dr_valid_o & dr_ready_i & dr_last_o`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
\=u.dffre(1, `wack_int`, `pw_valid_o & pw_ready_i`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
\js }

assign n_rkq_ready = rack_int;

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'rkq',
	params: {
                depth:          Math.ceil(OCN/4),
		width:		OCA,
                pipeForward:    "yes",
                pipeBackward:   "yes",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_rkq_ready',
		in_valid:	't_rkq_valid',
		in_data:	'w_drx_oid',
		out_ready:	'n_rkq_ready',
		out_valid:	'w_rkq_valid',
		out_data:	'w_rkq_oid'
	},
	portsDelimiter: '\n\t'
  })=\

  assign t_oc_rack = {OCN{w_rkq_valid & rack_int}} & ({{OCN-1{1'b0}}, 1'b1} << w_rkq_oid);

  assign n_wkq_ready = wack_int;

  \=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'wkq',
	params: {
                depth:          Math.ceil(OCN/4),
		width:		OCA,
                pipeForward:    "yes",
                pipeBackward:   "yes",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_wkq_ready',
		in_valid:	'n_wkq_valid',
		in_data:	'n_pw_oid',
		out_ready:	'n_wkq_ready',
		out_valid:	'w_wkq_valid',
		out_data:	'w_wkq_oid'
	},
	portsDelimiter: '\n\t'
  })=\

  assign t_oc_wack = {OCN{w_wkq_valid & wack_int}} & ({{OCN-1{1'b0}}, 1'b1} << w_wkq_oid);

\jsbegin
// FIXME: Need to add aceLiteDvm config
/* istanbul ignore else env ncore_3p6 */
    if (axiParams.wCdData) { \jsend
wire [1:0]      q_oc_aresp[OCN-1:0];    //{IsShares, PassDirty}
wire [1:0]      q_oc_aresp_ns[OCN-1:0];    //{IsShares, PassDirty}

\js for (let i=0; i<OCN; i=i+1) {
wire [1:0]      q_oc_aresp\=i=\;
assign q_oc_aresp[\=i=\] = q_oc_aresp\=i=\;
assign q_oc_aresp_ns[\=i=\] = t_oc_alloc[\=i=\] ? 2'h0 : ((n_dtr_req_rx_ready & w_dtr_req_rx_valid & q_oc_wfdtr[w_srd_oid] & (w_srd_oid==\=OCA=\'d\=i=\) & w_dtr_req_rx_last)) ? w_dtr_req_rx_aresp : (((~q_oc_write[w_str_req_rid] & ((t_oc_domain[w_str_req_rid]==2'h1) | (t_oc_domain[w_str_req_rid]==2'h2)) & ((t_oc_snoop[w_str_req_rid]==4'hb) | (t_oc_snoop[w_str_req_rid]==4'hc))) | (~q_oc_write[w_str_req_rid] & (t_oc_domain[w_str_req_rid] < 2'h3) & ((t_oc_snoop[w_str_req_rid]==4'h8) | (t_oc_snoop[w_str_req_rid]==4'h9) | (t_oc_snoop[w_str_req_rid]==4'ha) | (t_oc_snoop[w_str_req_rid]==4'hd)))) & ((w_str_req_status[3:1]==3'h2) | (w_str_req_status[3:1]==3'h3)) & ~w_str_req_status[7] & w_str_req_valid & (w_str_req_rid_bv[\=i=\])) ? 2'h2 : q_oc_aresp[\=i=\];
\=u.dffre(2, `q_oc_aresp`+i, `q_oc_aresp_ns[`+i+`]`, `2'd0`, `1'b1`, `clk_i`, `reset_ni`)=\

assign t_oc_aresp[\=i=\] = q_oc_aresp[\=i=\];
\js } // (let i=0; i<OCN; i=i+1)

  assign n_cdq_ready = (n_cd_ready & w_cd_valid & w_cd_last) | (w_cdq_valid & ~t_st_wfcr[w_cdq_sid] & 
				    ~t_st_dt[w_cdq_sid]) | (t_crs_valid & ~w_cr_dt & w_cdq_valid & (w_crq_sid==w_cdq_sid));

\=u.instance({
        'portsDelimiter': '\n    ',
        'instanceName': 'cdq',
        'moduleName':   'rdy_vld_pipe',
        'params': {
                 "pipeForward"  : "yes",
                 "pipeBackward" : "no",
                 "simplePipe"   : "no",
                 "circular"     : "no",
                 "width"        : STA,
                 "depth"        : (STN>16)?/* istanbul ignore next env ncore_3p7 */16:STN
              },
        'verilogParams': {},
        'ports':{
          clk        : 'clk_i',
          reset_n    : 'reset_ni',
          in_valid   : 'n_cdq_valid',
          in_data    : 'n_ac_sid',
          in_ready   : 'w_cdq_ready',
          out_valid  : 'w_cdq_valid',
          out_data   : 'w_cdq_sid',
          out_ready  : 'n_cdq_ready'
        }
})=\


\js if (OCA>STA) {
    assign t_cdq_sid = {{OCA-STA{1'b0}},w_cdq_sid};
\js } else {
    assign t_cdq_sid = w_cdq_sid[OCA-1:0];
\js }
  assign t_cdq_poison = {DWP{t_st_error[w_cdq_sid]}} | w_cd_poison_qual;

  \=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'cd',
	params: {
                depth:          2,
		width:		1+ioaiu_pos(CDWP)+ioaiu_pos(CDW),
                pipeForward:    "yes",
                pipeBackward:   "yes",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'cd_ready_o',
		in_valid:	'cd_valid_i',
		in_data:	`{cd_last_i, cd_data_i, cd_poison_i}`,
		out_ready:	'n_cd_ready',
		out_valid:	'w_cd_valid',
		out_data:	`{w_cd_last, w_cd_data, w_cd_poison}`
	},
	portsDelimiter: '\n\t'
  })=\
  assign t_cd_valid = w_cd_valid & ~q_st_wfcr[w_cdq_sid] & t_st_dt[w_cdq_sid];
  assign w_cs_sid = w_cdq_sid;
  assign w_cs_trace = t_st_trace[w_cdq_sid];

\js } else { // CDW
assign cd_ready_o = 1'b0;
assign w_cd_valid = 1'b0;
assign t_cd_valid = 1'b0;
assign w_cd_last = 1'b0;
assign w_cd_data = {CDW{1'b0}};
assign w_cd_poison = {CDWP{1'b0}};
assign w_cdq_ready = 1'b1;
assign n_cdq_ready = 1'b0;
assign w_cdq_valid = 1'b0;
assign w_cdq_sid = {STA{1'b0}};
assign t_cdq_sid = {OCA{1'b0}};
assign t_cdq_poison = {DWP{1'b0}};
\js for (let i=0; i<OCN; i=i+1) {
assign t_oc_aresp[\=i=\] = 2'h0;
\js }
\js } // CDW
assign t_dvm_state = q_dvm_state;
assign t_st_wfac = q_st_wfac;
assign t_st_wfcr = q_st_wfcr;
assign t_st_wfcmp = q_st_wfcmp;
\js for (let i=0; i<STN; i=i+1) {
assign t_st_up[\=i=\] = q_st_up[\=i=\];
assign t_st_ptr[\=i=\] = q_st_ptr[\=i=\];
\js }
assign t_st_pr = q_st_pr;

\js } else { // ACE
\js if (STE) {
assign w_crq_sid = {STA{1'b0}};
assign n_cmq_ready = 1'b0;
assign w_cmq_valid = 1'b0;
assign w_cmq_sid = {STA{1'b0}};
assign w_cdq_ready = 1'b0;
assign n_cdq_ready = 1'b0;
assign w_cdq_valid = 1'b0;
assign w_cdq_sid = {STA{1'b0}};
assign t_cdq_sid = {OCA{1'b0}};
assign t_cdq_poison = {DWP{1'b0}};
assign w_ac_ready = 1'b0;
assign n_ac_valid = 1'b0;
assign t_st_ac = {STN{1'b0}};
\js } // STE
assign ac_valid_o = 1'b0;
assign ac_addr_o = {AW{1'b0}};
assign ac_snoop_o = 4'h0;
assign ac_track_o = 1'h0;
assign ac_prot_o = 3'h0;
assign ac_vmidext_o = 4'h0;
assign cr_ready_o = 1'b0;
\js if (STE) {
assign t_cr_resp = 5'h0;
assign t_crs_valid = 1'b0;
assign t_cro_valid = 1'b0;
assign w_crq_oid = {OCA{1'b0}};
assign {w_cr_wu, w_cr_is, w_cr_pd, w_cr_error, w_cr_dt} = 5'h0;
assign w_cd_valid = 1'b0;
assign w_cd_last = 1'b0;
\js } // STE
assign cd_ready_o = 1'b0;
assign w_rkq_ready = 1'b1;
assign w_rkq_valid = 1'b1;
assign w_wkq_ready = 1'b1;
assign w_wkq_valid = 1'b1;
assign t_oc_rack = {OCN{1'b1}};
assign t_oc_wack = {OCN{1'b1}};
\js if (STE) {
assign t_dvm_state = 1'b0;
assign t_st_wfac = {STN{1'b0}};
assign t_st_wfcr = {STN{1'b0}};
assign t_st_wfcmp = {STN{1'b0}};
assign t_st_pr = {STN{1'b0}};
assign t_st_hits = {STN{1'b0}};
\js } // STE
\js for (let i=0; i<OCN; i=i+1) {
assign t_oc_aresp[\=i=\] = 2'h0;
\js }
assign t_oc_wfack = {OCN{1'b0}};
assign t_oc_wfack_stp = {OCN{1'b0}};
\js if (STE) {
\js for (let i=0; i<STN; i=i+1) {
assign {t_st_wu[\=i=\], t_st_is[\=i=\], t_st_pd[\=i=\], t_st_error[\=i=\], t_st_dt[\=i=\]} = 5'h0;

\jsbegin
/* istanbul ignore else env ncore_3p4,ncore_3p6,ncore_3p7 */
if (useOwnerTransfer>0) { \jsend
  assign t_st_up[\=i=\] = q_st_up[\=i=\];
\jsbegin
} else { \jsend
  assign t_st_up[\=i=\] = 2'h0;
\jsbegin
} \jsend

assign t_st_ptr[\=i=\] = {STA{1'b0}};
\js } // (let i=0; i<STN; i=i+1)
\js } // STE
\js } // ACE

assign str_req_ready_o = w_str_req_ready & q_reset_n;
assign n_str_req_valid = str_req_valid_i & q_reset_n & (str_req_tid_i == myid_i) & ~str_req_uce_i;

assign n_str_req_ready = 1'b1;

wire [\=OCN-1=\:0] str_req_rid_bv = {OCN{n_str_req_valid}} & ({{OCN-1{1'b0}}, 1'b1} << str_req_rid_i[OCA-1:0]);

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'str_req',
	params: {
                depth:          2,
		width:		10+SRC1+SRC2+SRCB+OCA+SRCM+SRCI+OCN,
                pipeForward:    "yes",
                pipeBackward:   "yes",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_str_req_ready',
		in_valid:	'n_str_req_valid',
		in_data:	`{str_req_mpf1_i, str_req_mpf2_i,
				  str_req_isize_i, str_req_status_i, str_req_bid_i,
				  str_req_rid_i[OCA-1:0], str_req_mid_i, str_req_iid_i,str_req_rid_bv}`,
		out_ready:	'n_str_req_ready',
		out_valid:	'w_str_req_valid',
		out_data:	`{w_str_req_mpf1, w_str_req_mpf2,
				  w_str_req_isize, w_str_req_status, w_str_req_bid,
				  w_str_req_rid, w_str_req_mid, w_str_req_iid,w_str_req_rid_bv}`
	},
	portsDelimiter: '\n\t'
})=\

/////////////////////////////////////////////////////////
//
//	Concerto Snoop Handling
//

assign snp_req_ready_o = w_snp_req_ready & q_reset_n;
assign n_snp_req_valid = snp_req_valid_i & q_reset_n & (snp_req_tid_i == myid_i) & ~snp_req_uce_i;
assign {n_snp_req_tr, n_snp_req_rl, n_snp_req_up, n_snp_req_pr,
	n_snp_req_ns, n_snp_req_ca, n_snp_req_ac, n_snp_req_vz} = snp_req_attr_i;

// Use normal STT logic
\js if (STE) {
assign n_snp_req_ready = w_st_ready;
\js } else { // STE
// Use new STT Block
// Need to move ACE/Proxy Cache STT to this Block

wire stt_idle; \js // TODO: Connect to top.

\jsbegin
// No owo on 3.7.0
    if (owo) { \jsend
wire [\=OCN=\-1:0] ott_outstanding = q_oc_val & q_oc_write & q_oc_owned & ~t_oc_atop_persist & ~t_oc_fini & ((t_oc_writeback_phase & (q_oc_wfdtw|(~t_oc_dtp_received&q_oc_wfdtp))) | (~t_oc_writeback_phase & q_oc_oldest));
\js }

\jsbegin
let stt_ports = {
          clk_i:		  'clk_i',
          reset_ni:	  	  'reset_ni',
	  idle_o:		  'stt_idle',
	  myid_i:                 'myid_i',
          snp_rsp_ready_i:	  'snp_rsp_ready_i',
          snp_rsp_valid_o:	  'snp_rsp_valid_o',
          snp_rsp_trace_o:	  'snp_rsp_trace_o',
          snp_rsp_tid_o:	  'snp_rsp_tid_o',
          snp_rsp_iid_o:	  'snp_rsp_iid_o',
          snp_rsp_mid_o:	  'snp_rsp_mid_o',
          snp_rsp_rid_o:	  'snp_rsp_rid_o',
          snp_rsp_pri_o:	  'snp_rsp_pri_o',
          snp_rsp_ql_o:	  	  'snp_rsp_ql_o',
          snp_rsp_cmd_o:	  'snp_rsp_cmd_o',
          snp_rsp_status_o:	  'snp_rsp_status_o',
          snp_rsp_mpf1_o:	  'snp_rsp_mpf1_o',
          snp_req_ready_o:	  'n_snp_req_ready',
          snp_req_valid_i:	  'w_snp_req_valid',
          snp_req_cmd_i:	  'w_snp_req_cmd',
          snp_req_status_i:	  'w_snp_req_status',
          snp_req_pri_i:	  'w_snp_req_pri',
          snp_req_mid_i:	  'w_snp_req_mid',
          snp_req_bid_i:	  'w_snp_req_bid',
          snp_req_iid_i:	  'w_snp_req_iid',
          snp_req_tid_i:	  "{"+CMHT+"{1'b0}}",
          snp_req_addr_i:	  'w_snp_req_addr',	
          snp_req_tr_i:	  	  'w_snp_req_trace',
          snp_req_rl_i:	  	  "{2{1'b0}}",
          snp_req_up_i:	  	  'w_snp_req_up',
          snp_req_pr_i:	  	  'w_snp_req_pr',
          snp_req_ns_i:	  	  'w_snp_req_security',
	  snp_req_ca_i:	  	  "1'b0",
	  snp_req_ac_i:	  	  "1'b0",
	  snp_req_vz_i:	  	  "1'b0",
          snp_req_isize_i:	  'w_snp_req_isize',
          snp_req_mpf1_i:	  'w_snp_req_mpf1',
          snp_req_mpf2_i:	  'w_snp_req_mpf2',
          snp_req_mpf3_i:	  'w_snp_req_mpf3',
          snp_req_did_i:	  'w_snp_req_did',
          snp_req_tof_i:	  'w_snp_req_tof'
        };

// No owo on 3.7.0
if (owo) {
   for ( let i = 0; i < OCN; i++) {
    stt_ports['ott_outstanding_'+i] = "ott_outstanding["+i+"]";
    stt_ports['ott_addr_'+i] = "q_oc_addr["+i+"]";    
    stt_ports['ott_security_'+i] = "q_oc_security["+i+"]";    
    }

   for ( let i = 0; i < STN; i++) {
    stt_ports['stt_val_'+i] = "q_st_val["+i+"]";
    stt_ports['stt_addr_'+i] = "q_st_addr["+i+"]";
    stt_ports['stt_ns_'+i] = "q_st_ns["+i+"]";        
    }

    // TODO: Can make more efficient through just storing the ID for the match 
    stt_ports['ott_clear_collision'] = "dtp_clear_collision";
}

\jsend

\=u.instance({
        moduleName: 'ioaiu_stt',
        instanceName: 'stt',
        params: {
	        CLO  : CLO,
	        nOtt : OCN,
		nStt : STN,
	        owo  : owo,
		SPNT : SPNT,
		SPNI : SPNI,
		SPNR : SPNR,
		SPNP : ioaiu_pos(CMHP),
		SPNL : ioaiu_pos(CMHL),
		SPN1 : SPN1,
		SRNP : SRNP,
		SRNM : SRNM,
		SRNB : SRNB,
		SRNI : SRNI,
		SRNT : CMHT,
		SRNA : SRNA,
		SRN1 : SRN1,
		SRN2 : SRN2,
		SRN3 : SRN3,
		SRND : SRND,
		SRNF : SRNF
	},
        verilogParams: {
        },
        ports: stt_ports,
        portsDelimiter: '\n\t'

})=\

\js } // STE

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'snp_req',
	params: {
                depth:          STP,
		width:		SRNA+7+SRN1+SRN2+SRN3+SRNI+SRND+SRNP+
				SRNF+16+SRNM+SRNB,
                pipeForward:    "yes",
                pipeBackward:   "yes",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_snp_req_ready',
		in_valid:	'n_snp_req_valid',
		in_data:	`{snp_req_addr_i, snp_req_isize_i, snp_req_pri_i,
				  n_snp_req_up, n_snp_req_pr, n_snp_req_ns, 
				  n_snp_req_tr, snp_req_mpf1_i, snp_req_mpf2_i, snp_req_mpf3_i,
				  snp_req_did_i, snp_req_iid_i, snp_req_cmd_i, snp_req_mid_i, 
				  snp_req_bid_i, snp_req_tof_i, snp_req_status_i}`,
		out_ready:	'n_snp_req_ready',
		out_valid:	'w_snp_req_valid',
		out_data:	`{w_snp_req_addr, w_snp_req_isize, w_snp_req_pri,
				  w_snp_req_up, w_snp_req_pr, w_snp_req_security, 
				  w_snp_req_trace, w_snp_req_mpf1, w_snp_req_mpf2, 
				  w_snp_req_mpf3,
				  w_snp_req_did, w_snp_req_iid, w_snp_req_cmd, w_snp_req_mid, 
				  w_snp_req_bid, w_snp_req_tof, w_snp_req_status}`
	},
	portsDelimiter: '\n\t'
})=\

assign w_snp_req_as = (| (w_snp_req_addr>>AW)) & (w_snp_req_cmd != SnpDvmMsg);
assign t_snp_req_addr = w_snp_req_addr[AW-1:0] & t_snp_req_mask;
assign t_snp_req_mask = ((w_snp_req_cmd == SnpDvmMsg) |
		     ({{30{1'b0}},w_snp_req_isize} <= 32'd\=(AWL-3)=\)) ? {AW{1'b1}} :
				    ({AW{1'b1}} << (3'h3 + w_snp_req_isize));

assign t_str_req_mask = ({{30{1'b0}},w_str_req_isize} <= 32'd\=(AWL-3)=\) ? {AW{1'b1}} :
			    ({AW{1'b1}} << (3'h3 + w_str_req_isize));

assign n_srs_valid = 
\js if (STE) {
                     (| t_st_wake) &
		   (n_cmd_req0_ready & n_dtr_req_tx0_ready & n_dtw_req0_ready &
		    ~w_do_af & ~w_c0_af & (~w_rr_valid) & 
		    ~t_pvc_throttle & ~(t_cfg_evict & n_ce_valid) &
		    (t_st_count < t_cfg_st_limit) &
		    t_p0_single & ~w_ce_af);
\js } else { // STE
                     1'b0;
\js }

assign dtr_req_rx_ready_o = q_reset_n & (w_dtr_req_rx_ready | 
				  dtr_req_rx_valid_i & ((dtr_req_rx_tid_i != myid_i) | dtr_req_rx_uce_i));
assign n_dtr_req_rx_valid = dtr_req_rx_valid_i & q_reset_n & (dtr_req_rx_tid_i == myid_i) & ~dtr_req_rx_uce_i;
assign t_uerrs[1] =                 q_reset_n &
                    ((w_cmd_rsp_ready   & cmd_rsp_valid_i   & ((cmd_rsp_tid_i   != myid_i)|cmd_rsp_uce_i)) |
                     (w_dtr_rsp_rx_ready   & dtr_rsp_rx_valid_i   & ((dtr_rsp_rx_tid_i   != myid_i)|dtr_rsp_rx_uce_i)) |
                     (w_dtw_rsp_ready   & dtw_rsp_valid_i   & ((dtw_rsp_tid_i   != myid_i)|dtw_rsp_uce_i)) |
                     (w_upd_rsp_ready   & upd_rsp_valid_i   & ((upd_rsp_tid_i   != myid_i)|upd_rsp_uce_i)) |
                     (w_str_req_ready   & str_req_valid_i   & ((str_req_tid_i   != myid_i)|str_req_uce_i)) |
                     (dtr_req_rx_ready_o   & dtr_req_rx_valid_i   & ((dtr_req_rx_tid_i   != myid_i)|dtr_req_rx_uce_i)) |
                     (sysrq_ready_i & sysrq_valid_i & ((sysrq_tid_i != myid_i)|sysrq_uce_i)) |
                     (sysrp_ready_i & sysrp_valid_i & ((sysrp_tid_i != myid_i)|sysrp_uce_i)) |
                     (dtw_dbg_rsp_ready_i & dtw_dbg_rsp_valid_i & ((dtw_dbg_rsp_tid_i != myid_i)|dtw_dbg_rsp_uce_i)) |
                     (w_snp_req_ready   & snp_req_valid_i   & ((snp_req_tid_i   != myid_i)|snp_req_uce_i)) |
                     (cmp_rsp_ready_o   & cmp_rsp_valid_i   & ((cmp_rsp_tid_i   != myid_i)|cmp_rsp_uce_i)));

assign t_cerrs[1] =                 q_reset_n &
                    ((w_cmd_rsp_ready   & cmd_rsp_valid_i   & cmd_rsp_ce_i) |
                     (w_dtr_rsp_rx_ready   & dtr_rsp_rx_valid_i   & dtr_rsp_rx_ce_i) |
                     (w_dtw_rsp_ready   & dtw_rsp_valid_i   & dtw_rsp_ce_i) |
                     (w_upd_rsp_ready   & upd_rsp_valid_i   & upd_rsp_ce_i) |
                     (w_str_req_ready   & str_req_valid_i   & str_req_ce_i) |
                     (dtr_req_rx_ready_o   & dtr_req_rx_valid_i   & dtr_req_rx_ce_i) |
                     (sysrq_ready_i & sysrq_valid_i & sysrq_ce_i) |
                     (sysrp_ready_i & sysrp_valid_i & sysrp_ce_i) |
                     (dtw_dbg_rsp_ready_i & dtw_dbg_rsp_valid_i & dtw_dbg_rsp_ce_i) |
                     (w_snp_req_ready   & snp_req_valid_i   & snp_req_ce_i) |
                     (cmp_rsp_ready_o   & cmp_rsp_valid_i   & cmp_rsp_ce_i));

assign t_uerrs[5] = t_pt_uerr_config;
assign t_uerrs[2] = t_pt_uerr_dec;
assign t_cerrs[2] = 1'b0;

wire [11:0] w_pt_id_tmp;
wire [11:0] t_sv_id_tmp;
wire [9:0] cmd_rsp_iid_tmp;
wire [9:0] dtr_rsp_rx_iid_tmp;
wire [9:0] dtw_rsp_iid_tmp;
wire [9:0] upd_rsp_iid_tmp;
wire [9:0] str_req_iid_tmp;
wire [9:0] dtr_req_rx_iid_tmp;
wire [9:0] snp_req_iid_tmp;
wire [9:0] cmp_rsp_iid_tmp;
wire [9:0] sysrq_iid_tmp;
wire [9:0] sysrp_iid_tmp;
wire [9:0] dtw_dbg_rsp_iid_tmp;
\js if (Math.max(axiParams.wArId,axiParams.wAwId)>=12) {
    assign w_pt_id_tmp = w_pt_id[11:0];
    assign t_sv_id_tmp = t_sv_id[11:0];
\js } else {
    assign w_pt_id_tmp = {{12-IW{1'b0}},w_pt_id};
    assign t_sv_id_tmp = {{12-IW{1'b0}},t_sv_id};
\js }
\js if (concParams.hdrParams.wInitiatorId-PIDW>=10) {
    assign cmd_rsp_iid_tmp = cmd_rsp_iid_i[9+PIDW:PIDW];
    assign dtr_rsp_rx_iid_tmp = dtr_rsp_rx_iid_i[9+PIDW:PIDW];
    assign dtw_rsp_iid_tmp = dtw_rsp_iid_i[9+PIDW:PIDW];
    assign upd_rsp_iid_tmp = upd_rsp_iid_i[9+PIDW:PIDW];
    assign str_req_iid_tmp = str_req_iid_i[9+PIDW:PIDW];
    assign dtr_req_rx_iid_tmp = dtr_req_rx_iid_i[9+PIDW:PIDW];
    assign snp_req_iid_tmp = snp_req_iid_i[9+PIDW:PIDW];
    assign cmp_rsp_iid_tmp = cmp_rsp_iid_i[9+PIDW:PIDW];
    assign sysrq_iid_tmp = sysrq_iid_i[9+PIDW:PIDW];
    assign sysrp_iid_tmp = sysrp_iid_i[9+PIDW:PIDW];
    assign dtw_dbg_rsp_iid_tmp = dtw_dbg_rsp_iid_i[9+PIDW:PIDW];
\js } else {
    assign cmd_rsp_iid_tmp = {{10+PIDW-MRCI{1'b0}},cmd_rsp_iid_i[MRCI-1:PIDW]};
    assign dtr_rsp_rx_iid_tmp = {{10+PIDW-MRCI{1'b0}},dtr_rsp_rx_iid_i[MRCI-1:PIDW]};
    assign dtw_rsp_iid_tmp = {{10+PIDW-MRCI{1'b0}},dtw_rsp_iid_i[MRCI-1:PIDW]};
    assign upd_rsp_iid_tmp = {{10+PIDW-MRCI{1'b0}},upd_rsp_iid_i[MRCI-1:PIDW]};
    assign str_req_iid_tmp = {{10+PIDW-MRCI{1'b0}},str_req_iid_i[MRCI-1:PIDW]};
    assign dtr_req_rx_iid_tmp = {{10+PIDW-MRCI{1'b0}},dtr_req_rx_iid_i[MRCI-1:PIDW]};
    assign snp_req_iid_tmp = {{10+PIDW-MRCI{1'b0}},snp_req_iid_i[MRCI-1:PIDW]};
    assign cmp_rsp_iid_tmp = {{10+PIDW-MRCI{1'b0}},cmp_rsp_iid_i[MRCI-1:PIDW]};
    assign sysrq_iid_tmp = {{10+PIDW-MRCI{1'b0}},sysrq_iid_i[MRCI-1:PIDW]};
    assign sysrp_iid_tmp = {{10+PIDW-MRCI{1'b0}},sysrp_iid_i[MRCI-1:PIDW]};
    assign dtw_dbg_rsp_iid_tmp = {{10+PIDW-MRCI{1'b0}},dtw_dbg_rsp_iid_i[MRCI-1:PIDW]};
\js }

    assign t_uinfo = 
\js if (ACE) {
                     (t_uerrs[4]) ? {18'd0, t_cr_resp[1:0]} :
\js } // ACE
		 			 t_uerrs[3] ? {t_sv_id_tmp[11:0], 5'h0, t_sv_eaddr[64], t_sv_type[1:0]} :
		 			 t_pt_uerr_dec ? {w_pt_id_tmp[11:0], 2'b0,1'b0, w_pt_write,
			      				 (w_amc_errs[0]                ? 4'h0 :
			       				  w_amc_errs[1]                ? 4'h1 :
			       				  w_amc_errs[2]                ? 4'h0 :	
			       				  w_amc_errs[3]                ? 4'h4 :	
                                                          t_pt_illegal_csr_access_format ? 4'h2 :
                                                          t_pt_illegal_dii_access_type   ? 4'h3 : 4'h3)} :
                                         t_pt_uerr_config ? {2'b0,10'b0, 3'b0, 1'b0,
                                  w_amc_unconnected_dmi_access ? 4'h2 :
                                  w_amc_unconnected_dii_access ? 4'h3 :
                                  (t_pt_dce & w_amc_unconnected_dce_access) ? 4'h5 :
                                          no_credit_access ? 4'h1 : 4'h6} :
					(cmd_rsp_valid_i & ((cmd_rsp_tid_i != myid_i)|cmd_rsp_uce_i)) ? {2'b0,cmd_rsp_iid_tmp,7'h0,cmd_rsp_uce_i}: 
                	(sysrq_valid_i & ((sysrq_tid_i != myid_i)|sysrq_uce_i)) ? {2'b0,sysrq_iid_tmp,7'h0,sysrq_uce_i}:
                	(sysrp_valid_i & ((sysrp_tid_i != myid_i)|sysrp_uce_i)) ? {2'b0,sysrp_iid_tmp,7'h0,sysrp_uce_i}:
                	(dtw_dbg_rsp_valid_i & ((dtw_dbg_rsp_tid_i != myid_i)|dtw_dbg_rsp_uce_i)) ? {2'b0,dtw_dbg_rsp_iid_tmp,7'h0,dtw_dbg_rsp_uce_i}:
					(dtr_rsp_rx_valid_i   & ((dtr_rsp_rx_tid_i   != myid_i)|dtr_rsp_rx_uce_i)) ? {2'b0,dtr_rsp_rx_iid_tmp,7'h0,dtr_rsp_rx_uce_i}:
					(dtw_rsp_valid_i   & ((dtw_rsp_tid_i   != myid_i)|dtw_rsp_uce_i)) ? {2'b0,dtw_rsp_iid_tmp,7'h0,dtw_rsp_uce_i}:
					(upd_rsp_valid_i   & ((upd_rsp_tid_i   != myid_i)|upd_rsp_uce_i)) ? {2'b0,upd_rsp_iid_tmp,7'h0,upd_rsp_uce_i}:
					(str_req_valid_i   & ((str_req_tid_i   != myid_i)|str_req_uce_i)) ? {2'b0,str_req_iid_tmp,7'h0,str_req_uce_i}:
					(dtr_req_rx_valid_i   & ((dtr_req_rx_tid_i   != myid_i)|dtr_req_rx_uce_i)) ? {2'b0,dtr_req_rx_iid_tmp,7'h0,dtr_req_rx_uce_i}:
					(snp_req_valid_i   & ((snp_req_tid_i   != myid_i)|snp_req_uce_i)) ? {2'b0,snp_req_iid_tmp,7'h0,snp_req_uce_i}:
					(cmp_rsp_valid_i   & ((cmp_rsp_tid_i   != myid_i)|cmp_rsp_uce_i)) ? {2'b0,cmp_rsp_iid_tmp,7'h0,cmp_rsp_uce_i}:
					20'h0;

    assign t_cinfo = (cmd_rsp_valid_i   & cmd_rsp_ce_i) ? cmd_rsp_iid_tmp:
                     (sysrq_valid_i & sysrq_ce_i) ? sysrq_iid_tmp:
                     (sysrp_valid_i & sysrp_ce_i) ? sysrp_iid_tmp:
                     (dtw_dbg_rsp_valid_i & dtw_dbg_rsp_ce_i) ? dtw_dbg_rsp_iid_tmp:
                     (dtr_rsp_rx_valid_i   & dtr_rsp_rx_ce_i) ? dtr_rsp_rx_iid_tmp:
                     (dtw_rsp_valid_i   & dtw_rsp_ce_i) ? dtw_rsp_iid_tmp:
                     (upd_rsp_valid_i   & upd_rsp_ce_i) ? upd_rsp_iid_tmp:
                     (str_req_valid_i   & str_req_ce_i) ? str_req_iid_tmp:
                     (dtr_req_rx_valid_i   & dtr_req_rx_ce_i) ? dtr_req_rx_iid_tmp:
                     (snp_req_valid_i   & snp_req_ce_i) ? snp_req_iid_tmp:
                     (cmp_rsp_valid_i   & cmp_rsp_ce_i) ? cmp_rsp_iid_tmp:
                     10'h0;

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'dtr_req_rx',
	params: {
                depth:          2,
		width:		18+SRRP+SRRB+SRRZ+SRRD+SRRR+SRRM+SRRI,
                pipeForward:    "yes",
                pipeBackward:   "yes",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
                clk:            'clk_i',
                reset_n:        'reset_ni',
		in_ready:	'w_dtr_req_rx_ready',
		in_valid:	'n_dtr_req_rx_valid',
		in_data:	`{dtr_req_rx_attr_i[2], dtr_req_rx_pri_i, 
				  dtr_req_rx_be_i, dtr_req_rx_data_i, 
				  dtr_req_rx_dbad_i, dtr_req_rx_last_i, dtr_req_rx_rid_i, dtr_req_rx_iid_i, 
				  dtr_req_rx_mid_i, dtr_req_rx_cmd_i, dtr_req_rx_status_i}`,
		out_ready:	'n_dtr_req_rx_ready',
		out_valid:	'w_dtr_req_rx_valid',
		out_data:	`{w_dtr_req_rx_trace, w_dtr_req_rx_pri, w_dtr_req_rx_be, w_dtr_req_rx_data, 
				  w_dtr_req_rx_dbad, w_dtr_req_rx_last, w_dtr_req_rx_rid, w_dtr_req_rx_iid, 
				  w_dtr_req_rx_mid, w_dtr_req_rx_cmd, w_dtr_req_rx_status}`
	},
	portsDelimiter: '\n\t'
})=\

assign w_dtr_req_rx_obv = ({{OCN-1{1'b0}}, w_dtr_req_rx_valid} << w_dtr_req_rx_rid);

wire w_dtr_req_rx_first;
wire w_dtr_req_rx_first_ns = (w_dtr_req_rx_valid & w_dtr_req_rx_last) ? 1'b1 : w_dtr_req_rx_valid ? 1'b0 : w_dtr_req_rx_first;
\=u.dffre(1, `w_dtr_req_rx_first`, `w_dtr_req_rx_first_ns`, `1'b1`, `n_dtr_req_rx_ready`, `clk_i`, `reset_ni`)=\

\jsbegin
// Poison not enabled on 3.7
/* istanbul ignore if env ncore_3p7 */
    if (enPoison) { \jsend
assign w_dtr_req_rx_poison = {DWP{w_dtr_req_rx_valid}} & ({DWP{(w_dtr_req_rx_first ? w_dtr_req_rx_status[7] : (w_dtr_req_rx_status==8'h84))}} | w_dtr_req_rx_dbad);
\js } else {
assign w_dtr_req_rx_poison = w_dtr_req_rx_valid & ((w_dtr_req_rx_first ? w_dtr_req_rx_status[7] : (w_dtr_req_rx_status==8'h84)) | (| w_dtr_req_rx_dbad));
\js }
assign w_dtr_req_rx_aresp = (w_dtr_req_rx_cmd == DtrDataInv)       ? 2'h0 :
		     (w_dtr_req_rx_cmd == DtrDataSCln)      ? 2'h2 :
		     (w_dtr_req_rx_cmd == DtrDataSDty)      ? 2'h3 :
		     (w_dtr_req_rx_cmd == DtrDataUCln)      ? 2'h0 :
		     (w_dtr_req_rx_cmd == DtrDataUDty)      ? 2'h1 : {2{XO}};

\js if (useCache) {
\=u.instance({
	moduleName: 'ioaiu_arbiter',
	instanceName: 'ocfkm',
	params: {
                DRST:           DRST,
                DW:             OCN,
                ATOMIC:         1,
                HP:             `{`+OCN+`{1'b0}}`,
                VAL:            1,
		 assertOn: assertOn
		 },
	ports: {
		clk_i:		'clk_i',
		reset_ni:	'reset_ni',
		ready_i:	'w_fkm_ready',
		bv_i:		't_oc_fkm',
		lv_i:		'n_fkm_lbv',
		winner_o:	'n_fkm_oid',
		wbv_o:		'n_fkm_obv'
	},
	portsDelimiter: '\n\t'
})=\
\js } else {
assign n_fkm_oid = {OCA{1'b0}};
assign n_fkm_obv = {OCN{1'b0}};
\js }

\js if (useCache) {
\jsbegin
// wMsgId always sized to fit OCA
/* istanbul ignore else env ncore_3p7 */
    if (concParams.dtrReqParams.wMsgId>OCA) { \jsend
      assign w_fkm_rid = {{SRRR-OCA{1'b0}},w_fkm_oid};
\js } else {
      assign w_fkm_rid = w_fkm_oid[SRRR-1:0];
\js }

\=u.instance({
	moduleName: 'ioaiu_mux',
	instanceName: 'srm_mux',
	params: {
		NUM:		'2',
		DW:		SRRR+OCN,
                clkAssertInterface : clkAssertInterface,
				assertOn: assertOn
	},
	verilogParams: {
	},
	ports: {
		ready_o:	'{t_fkm_ready,  	 n_dtr_req_rx_ready}',
		valid_i:	`{1'b1, 		 1'b1}`,
		data_i:		`{w_fkm_obv, w_fkm_rid,	 w_dtr_req_rx_obv, w_dtr_req_rx_rid}`,
		ready_i:	'n_srm_ready',
		valid_o:	'w_srm_valid',
		data_o:		`{w_srm_obv, w_srm_rid}`,
		bvsel_i:	'w_srm_wbv'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

assign w_fkm_last = (& q_srd_count);

\=u.instance({
	moduleName: 'ioaiu_arbiter',
	instanceName: 'srm_arb',
	params: {
                DRST:           DRST,
                DW:             2,
                ATOMIC:         1,
                HP:             `2'h0`,
                VAL:            1,
                NO_WINNER_OUT:  1,
		 assertOn: assertOn
		 },
	ports: {
		clk_i:		'clk_i',
		reset_ni:	'reset_ni',
		ready_i:	'n_srm_ready',
		bv_i:		'{w_fkm_valid,	w_dtr_req_rx_valid}',
		lv_i:		'{w_fkm_last,	w_dtr_req_rx_last}',
		wbv_o:		'w_srm_wbv'
	},
	portsDelimiter: '\n\t'
})=\
\js } else {
assign t_fkm_ready = 1'b0;
assign w_fkm_last = 1'b0;
assign n_dtr_req_rx_ready = n_srm_ready;
assign w_srm_valid = w_dtr_req_rx_valid;
assign w_srm_rid = w_dtr_req_rx_rid;
assign w_srm_obv = w_dtr_req_rx_obv;
assign w_srm_wbv = {1'b0, w_dtr_req_rx_valid};
\js }

\jsbegin
// wMsgId must be big enough to hold OCA
/* istanbul ignore if env ncore_3p7 */
    if (OCA>concParams.dtrReqParams.wMsgId) { \jsend
	assign w_srd_oid = {{OCA-SRRR{1'b0}},w_srm_rid};
\js } else {
	assign w_srd_oid = w_srm_rid[OCA-1:0];
\js }
assign w_srd_obv = w_srm_obv;
assign w_srd_fkm = w_srm_wbv[1] & t_srd_sel[1];

assign t_srd_dtr = w_dtr_req_rx_valid & q_oc_wfdtr[w_srd_oid] &
				 ((w_dtr_req_rx_cmd==DtrDataInv) |
				  (w_dtr_req_rx_cmd==DtrDataSCln) |
				  (w_dtr_req_rx_cmd==DtrDataSDty) |
				  (w_dtr_req_rx_cmd==DtrDataUCln) |
				  (w_dtr_req_rx_cmd==DtrDataUDty));
assign t_srd_beats = {(~| q_oc_beats[w_srd_oid]), q_oc_beats[w_srd_oid]};
assign t_srd_ihead = q_oc_iptr_eq[w_srd_oid];//(q_oc_iptr[w_srd_oid] == w_srd_oid);
assign t_srd_dirty = ~q_oc_write[w_srd_oid] &	//no handbacks on writes!?
	     (q_oc_wfdtw[w_srd_oid] | q_oc_wfstr[w_srd_oid]);
assign t_srd_adone = n_dtr_req_rx_ready & w_dtr_req_rx_valid & w_dtr_req_rx_last &
	     (t_srd_bypass | q_srd_bypass);
\js if (useCache) {
wire t_srd_bypass_cancel = w_fq_af & q_oc_wfcfd[w_srd_oid];
\js } else {
wire t_srd_bypass_cancel = 1'b0;
\js }
assign t_srd_bypass = ~t_cfg_bypass & 
		t_srd_ihead & t_srd_dtr & (~| q_srd_count) &
		~w_do_valid & ~q_oc_write[w_srd_oid] &
		~(q_oc_wrap[w_srd_oid] & (| q_oc_beats[w_srd_oid])) &
	(q_oc_eob[w_srd_oid] ? ~q_oc_wfdtp[w_srd_oid] & 
			       ~q_oc_wfdtw[w_srd_oid] & 
			       ~q_oc_wfstr[w_srd_oid]:
			1'b1) &
			     ~w_dr0_af & ~t_srd_bypass_cancel;

wire full_mask = (q_oc_line[w_srd_oid] | ~q_oc_wrap[w_srd_oid] |
		 t_oc_wfcfd[w_srd_oid] |
		 (q_oc_beats_adj[w_srd_oid]<5'h2));			

assign t_srd_pre_offset = (({1'b0,q_srd_count} + {1'b0,q_oc_addr[w_srd_oid][AWL +: BWL]}) & 
		        ((full_mask) ? {BWL+1{1'b1}} : 
			((q_oc_beats_adj[w_srd_oid]==5'h1)|(q_oc_beats_adj[w_srd_oid]==5'h2)) ? \=BWL+1=\'h1 :
			((q_oc_beats_adj[w_srd_oid]==5'h3)|(q_oc_beats_adj[w_srd_oid]==5'h4)) ? \=BWL+1=\'h3 :
\js if (BWL>1) {
			((q_oc_beats_adj[w_srd_oid]==5'h5)|(q_oc_beats_adj[w_srd_oid]==5'h6)|(q_oc_beats_adj[w_srd_oid]==5'h7)|(q_oc_beats_adj[w_srd_oid]==5'h8)) ? \=BWL+1=\'h7 :
\js }
							{BWL+1{XO}})) |
		      ({1'b0,q_oc_addr[w_srd_oid][AWL +: BWL]} & (
			((full_mask) ? {BWL+1{1'b0}} :
			((q_oc_beats_adj[w_srd_oid]==5'h1)|(q_oc_beats_adj[w_srd_oid]==5'h2)) ? ({1'b0,{BWL{1'b1}}}<<1) :
			((q_oc_beats_adj[w_srd_oid]==5'h3)|(q_oc_beats_adj[w_srd_oid]==5'h4)) ? ({1'b0,{BWL{1'b1}}}<<2) :
			((q_oc_beats_adj[w_srd_oid]==5'h5)|(q_oc_beats_adj[w_srd_oid]==5'h6)|(q_oc_beats_adj[w_srd_oid]==5'h7)|(q_oc_beats_adj[w_srd_oid]==5'h8)) ? ({1'b0,{BWL{1'b1}}}<<3) :
							({BWL+1{1'b0}}))));

\js // For full line keep the same full mask. Else if more beats are recieved than needed they must be placed on opposite side of buffer.
\js if (BWL > 1) {
assign t_srd_offset = (full_mask | (q_srd_count < q_oc_beats[w_srd_oid])) ? t_srd_pre_offset : {1'b0, ~t_srd_pre_offset[BWL-1], t_srd_pre_offset[BWL-2:0]};
\js } else {
assign t_srd_offset = t_srd_pre_offset;
\js }

wire [BWL-1:0] q_srd_count_p1;
wire q_srd_count_carry;
assign {q_srd_count_carry,q_srd_count_p1} = {1'b0,q_srd_count} + 1'b1;
wire [BWL-1:0] q_srd_count_ns = (((w_srm_wbv[0] & w_dtr_req_rx_last) | (w_srm_wbv[1] & w_fkm_last)) & w_srm_valid & n_srm_ready) ? {BWL{1'b0}} : (w_srm_valid & n_srm_ready) ? q_srd_count_p1 : q_srd_count;
\=u.dffre(BWL, `q_srd_count`, `q_srd_count_ns`, `{`+BWL+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
wire q_srd_bypass_ns = q_srd_bypass ? ~(n_dtr_req_rx_ready & w_dtr_req_rx_valid & w_dtr_req_rx_last) : t_srd_bypass & ~w_dtr_req_rx_last;
\=u.dffre(1, `q_srd_bypass`, `q_srd_bypass_ns`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
wire [2-1:0] q_do_last_ns = ~w_dr0_ready ? q_do_last : (((q_do_last==2'h1) & w_cdr_valid & w_cdr_last) | ((q_do_last==2'h2) & w_odr_valid & w_odr_last)) ? 2'h0: (w_do_valid & (w_do_data==2'h3) & t_drx_sel[1] & (~| q_do_last) & w_odr_valid & w_odr_last) ? 2'h1: (w_do_valid & (w_do_data==2'h3) & t_drx_sel[2] & (~| q_do_last) & w_cdr_valid & w_cdr_last) ? 2'h2: q_do_last;
\=u.dffre(2, `q_do_last`, `q_do_last_ns`, `2'd0`, `1'b1`, `clk_i`, `reset_ni`)=\



wire [OCA-1:0] q_srd_oid_ns = t_srd_bypass ? w_srd_oid : q_srd_oid;
\=u.dffre(OCA, `q_srd_oid`, `q_srd_oid_ns`, `{`+OCA+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

\=u.instance({
moduleName: 'ioaiu_demux',
instanceName: 'srd_split',
params: {
	 NUM:		6,
	 DW:		1,
         NO_DATA_OUT:   1,
         clkAssertInterface : clkAssertInterface,
         assertOn : assertOn
},
verilogParams: {
},
ports: {
	ready_o:	'n_srm_ready',
	valid_i:	'w_srm_valid',
	data_i:		`1'b0`,
	ready_i:	`{w_dtr_rsp_tx_ready, 1'b1, w_sod_ready, 
			  w_oms_ready, w_fq_ready, n_sdr_ready}`,
	valid_o:	`{n_dtr_rsp_tx_valid, n_dd_valid, n_sod_valid, 
			  n_oms_valid, n_fq_valid, w_sdr_valid}`,
	bvsel_i:	't_srd_sel'
},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
portsDelimiter: '\n\t'
})=\

assign t_srd_sel[5] = w_dtr_req_rx_valid & w_dtr_req_rx_last & w_srm_wbv[0];
assign t_srd_sel[4] = 1'b1;
assign t_srd_sel[3] = t_srd_dtr & (~q_oc_write[w_srd_oid] |
			   (| (t_oc_atop[w_srd_oid] & 6'h20))) &
			 (t_srd_dirty | ~(t_srd_bypass | q_srd_bypass));
assign t_srd_sel[2] = w_srm_valid & (({1'b0,q_srd_count} < t_srd_beats)) &
				  t_oc_wfcfd[w_srd_oid] & q_oc_write[w_srd_oid];
assign t_srd_sel[1] = w_srm_valid & t_oc_wfcfd[w_srd_oid];
assign t_srd_sel[0] = w_dtr_req_rx_valid & ({1'b0,q_srd_count}<t_srd_beats) & (t_srd_bypass |
								 q_srd_bypass);

\jsbegin
// OD banks == 4 for 3.7
/* istanbul ignore else env ncore_3p7 */
    if (ODB>1) { \jsend
\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'oms',
	params: {
                depth:          3,
		width:		ODA,
                pipeForward:    "yes",
                pipeBackward:   "yes",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_oms_ready',
		in_valid:	'n_oms_valid',
		in_data:	'n_oms_raddr',
		out_ready:	'w_odm_ready',
		out_valid:	'n_odm_valid',
		out_data:	'n_odm_raddr'
	},
	portsDelimiter: '\n\t'
})=\
\js } else {
assign w_oms_ready = w_odm_ready;
assign n_odm_valid = n_oms_valid;
assign n_odm_raddr = n_oms_raddr;
\js }

\js // We only want the trace to propogate back if this transaction is being tracked as indicated by a native layer track.
\js // The trace coming back only deals with capturing for internal debug. Track keeps track of the Native Layer protocol. 
assign w_sdr_track = t_oc_track[w_srd_oid]; // | w_dtr_req_rx_trace;
assign w_sdr_oid = w_srd_oid;
assign w_sdr_eob = q_oc_eob[w_srd_oid];
assign w_sdr_id = q_oc_id[w_srd_oid];
assign w_sdr_last = (({1'b0,q_srd_count}+1'b1) == t_srd_beats);

wire exclusive_sdr_resp = (q_oc_lock[w_srd_oid] &	//exclusive
				    ((((t_oc_domain[w_srd_oid]==2'h0) | 
				       (t_oc_domain[w_srd_oid]==2'h3)) &
				      (t_oc_snoop[w_srd_oid]==4'h0)) ? 
					      w_dtr_req_rx_status[0] ://non-coherent ex
					      1'b1));

wire top_bit_sdr_resp = (w_dtr_req_rx_poison | (w_dtr_req_rx_first ? q_oc_status[w_srd_oid][7] : (q_oc_status[w_srd_oid]==8'h84)));

\js if (axiParams.wResp>2) {
assign w_sdr_resp = {w_dtr_req_rx_aresp, top_bit_sdr_resp, 
				  ((w_dtr_req_rx_status==8'h84) |
				   (q_oc_status[w_srd_oid]==8'h84) |
				    (exclusive_sdr_resp & !top_bit_sdr_resp))};	       //coherent ex
\js } else {
assign w_sdr_resp = {             top_bit_sdr_resp,
                                  ((w_dtr_req_rx_status==8'h84) |
                                   (q_oc_status[w_srd_oid]==8'h84) |
                                    (exclusive_sdr_resp & !top_bit_sdr_resp))};        //coherent ex
\js }

assign w_sdr_rdata = w_dtr_req_rx_data;
assign w_sdr_poison = w_dtr_req_rx_poison;

\=u.instance({
	moduleName: 'ioaiu_ror',
	instanceName: 'srd_dptr',
	params: {
		NUM:		OCN,
		DW:		OLA
        },
	ports: {
		vec_i:		't_srd_dptr',
		ror_o:		'w_srd_dptr'
	},
	portsDelimiter: '\n\t'
})=\

assign n_oms_raddr = n_sod_waddr;
assign n_sod_oid = w_srd_oid;
assign n_sod_oid_bv = w_srd_obv;
assign n_sod_waddr = {w_srd_dptr, t_srd_offset[BWL-1:0]};
assign n_sod_wdata = w_dtr_req_rx_data;
assign n_sod_be = w_dtr_req_rx_be;
assign n_sod_poison = w_dtr_req_rx_poison;

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'sod',
	params: {
                depth:          1,
		width:		OCA+ODA+DWP+BW+DW+OCN,
                pipeForward:    "yes",
                pipeBackward:   "no",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_sod_ready',
		in_valid:	'n_sod_valid',
		in_data:	`{n_sod_oid_bv, n_sod_oid, n_sod_waddr, 
				  n_sod_poison, n_sod_be, n_sod_wdata}`,
		out_ready:	'n_sod_ready',
		out_valid:	'w_sod_valid',
		out_data:	`{w_sod_oid_bv, w_sod_oid, w_sod_waddr,
				  w_sod_poison, w_sod_be, w_sod_wdata}`
	},
	portsDelimiter: '\n\t'
})=\

wire [BWL:0]	t_cdr_sum = {1'b0,w_cdr_drop} + ((\=BWL+1=\'d\=BPL=\>>1) - 
					  {1'b0,(w_cdr_offset & ({BWL{1'b1}}>>1))});
\js if (BPL==8) {
wire [\=BWL=\:0] w_cdr_keep = \=BWL+1=\'d\=BPL=\ - {1'b0,w_cdr_drop};
\js }

assign t_cdr_valid = w_cdr_valid  & ~w_cdr_err & ((~| w_cdr_drop) |
                                        (
\js if (BPL==8) {
                                         ((w_cdr_keep == \=BWL+1=\'d2) & (w_cdr_offset[1:0]==2'b1)) ? 
                                                ({1'b0,t_cdr_count} >= \=BWL+1=\'d\=BPL-1=\) |
                                                (t_cdr_count==\=BWL=\'h0)
                                                                                              : 
\js }
				                 ({1'b0,t_cdr_count} >= t_cdr_sum) |
				                 (({\=8-BWL=\'b0,t_cdr_count} + {\=8-BWL=\'b0,w_cdr_offset}) < 
				                  (w_cdr_offset[BWL-1] ? 8'd\=BPL=\ : (8'd\=BPL=\>>1)))));

\jsbegin
// Interleaving on the native axi interface can be limited to 64byte boundaries with the
// noCacheLineInterleave parameter in 3.4. This is accomplished by not allowing other return
// data to interleave with the cdr cache return data.
// If interleaving is ok, then 'cdr in progress' is not tracked.
\jsend
assign t_cdr_in_progress_in = 
\jsbegin
/* istanbul ignore if env ncore_3p4,ncore_3p6,ncore_3p7 */
if (!noCacheLineInterleave) { \jsend
                              1'b0;
\jsbegin
} else { \jsend
                              ((~t_cdr_in_progress & w_cdr_valid & ~w_cdr_last & n_cdr_ready) |
                               ( t_cdr_in_progress &              ~(w_cdr_last & n_cdr_ready & w_cdr_valid)));
\jsbegin
} \jsend

\=u.dffre(1, `t_cdr_in_progress`, `t_cdr_in_progress_in`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\

assign t_odr_rdata = w_odr_bar ? {DW{1'b0}} : w_odr_csr ? {{DW-32{1'b0}},csr_id_i} : w_odr_rdata & {DW{~w_odr_cmo}};

\js if (axiParams.wResp>2) {
    assign t_odr_resp = {w_odr_resp[ARPW-1:2],(w_odr_resp[1:0] & ~{2{(|t_odr_poison) & ~w_odr_cmo & (w_odr_resp[1:0]==2'b01)}}) | {((|t_odr_poison) & ~w_odr_cmo), 1'b0}};
    assign t_cdr_resp = {w_cdr_resp[ARPW-1:2],(w_cdr_resp[1:0] & ~{2{(|w_cdr_poison)              & (w_cdr_resp[1:0]==2'b01)}}) |  {(|w_cdr_poison)              , 1'b0}};
\js } else {
    assign t_odr_resp = (w_odr_resp & ~{ARPW{(|t_odr_poison) & ~w_odr_csr 
                                                             & ~w_odr_cmo & (w_odr_resp==2'b01)}}) | {((|t_odr_poison) & ~w_odr_csr 
                                                                                                                       & ~w_odr_cmo), 1'b0};
    assign t_cdr_resp = (w_cdr_resp & ~{ARPW{(|w_cdr_poison)              & (w_cdr_resp==2'b01)}}) |  {(|w_cdr_poison)              , 1'b0};
\js }

\=u.instance({
	moduleName: 'ioaiu_mux',
	instanceName: 'dr_mux',
	params: {
		NUM:		'3',
		DW:		(AXKW+OCA+1+IW+ARPW+1+DW+DWP),
                clkAssertInterface : clkAssertInterface,
				assertOn: assertOn
	},
	verilogParams: {
	},
	ports: {
		ready_o:	'{n_cdr_ready,  n_odr_ready,    n_sdr_ready}',
		valid_i:	'{t_cdr_valid,  w_odr_valid,    w_sdr_valid}',
		data_i:		`{{w_cdr_track, w_cdr_oid, w_cdr_eob, w_cdr_id, 
				   t_cdr_resp, w_cdr_last, w_cdr_rdata, w_cdr_poison}, 
				  {w_odr_track, w_odr_oid, w_odr_eob, w_odr_id, 
				   t_odr_resp, w_odr_last, t_odr_rdata, t_odr_poison}, 
				  {w_sdr_track, w_sdr_oid, w_sdr_eob, w_sdr_id, 
				   w_sdr_resp, w_sdr_last, w_sdr_rdata, w_sdr_poison}}`,
		ready_i:	'n_drx_ready',
		valid_o:	'w_drx_valid',
		data_o:		`{w_drx_track, w_drx_oid, w_drx_eob, w_drx_id, 
				  w_drx_resp, w_drx_last, w_drx_rdata, w_drx_poison}`,
		bvsel_i:	't_drx_sel'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

\=u.instance({
	moduleName: 'ioaiu_demux',
	instanceName: 'dr_split',
	params: {
		 NUM:		2,
		 DW:		1,
                 NO_DATA_OUT:   1,
                 clkAssertInterface : clkAssertInterface,
                 assertOn : assertOn
        },
	verilogParams: {
	},
	ports: {
		ready_o:	'n_drx_ready',
		valid_i:	'w_drx_valid',
		data_i:		`1'b0`,
		ready_i:	'{w_rkq_ready,  w_dr0_ready}',
		valid_o:	'{n_rkq_valid,  n_dr0_valid}',
		bvsel_i:	`2'h3`
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

assign t_rkq_valid = n_rkq_valid & n_dr0_last;

assign t_odr_ready = w_odr_ready & w_do_ready;

assign n_do_valid = (| n_do_data);
assign n_do_data = {(w_c2_done & ~w_pt_write & ~w_pt_snp), 
		    (n_odr_valid & (~|q_odr_count) & w_odr_ready)};

assign n_do_ready = (~w_do_valid | ~n_drx_ready | q_srd_bypass) ? 1'b0 :
		    (w_do_data==2'h1) ? (w_odr_valid & w_odr_last) :
		    (w_do_data==2'h2) ? (w_cdr_valid & w_cdr_last) :
				(w_cdr_valid & w_cdr_last & (q_do_last==2'h1)) |
				(w_odr_valid & w_odr_last & (q_do_last==2'h2));

\js // Get almost-full functionality by exposing the valids, and seeing how full the fifo is.
wire [15:0] rdo_valids;
assign w_do_af = rdo_valids[5];
\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'rdo',
	params: {
                depth:          16,
		width:		2,
                pipeForward:    "yes",
                pipeBackward:   "yes",
                simplePipe:     "no",
                circular:       "no",
                exposeValids:   "true"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		valids:		'rdo_valids',
		in_ready:	'w_do_ready',
		in_valid:	'n_do_valid',
		in_data:	'n_do_data',
		out_ready:	'n_do_ready',
		out_valid:	'w_do_valid',
		out_data:	'w_do_data'
	},
	portsDelimiter: '\n\t'
})=\

assign t_odr_in_progress_in = ((~t_odr_in_progress & w_odr_valid & ~w_odr_last & n_odr_ready) |
                               ( t_odr_in_progress &              ~(w_odr_last & n_odr_ready & w_odr_valid)));

\=u.dffre(1, `t_odr_in_progress`, `t_odr_in_progress_in`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\

wire paused = (w_do_valid | w_dtr_req_rx_valid) & ~|t_drx_sel;
assign t_drx_sel = (~t_cdr_in_progress & ~t_odr_in_progress & (~w_do_valid | q_srd_bypass)) ? 
                                {2'h0, (w_dtr_req_rx_valid & ~q_oc_write[w_srd_oid])} :
                   (~t_cdr_in_progress & (((w_do_data==2'h3) & (q_do_last==2'h0) & w_odr_valid) |
                     (w_do_data==2'h1) | (q_do_last==2'h2))) ? 3'h2 :
                    ~t_odr_in_progress                       ? 3'h4 :
                                                               3'h0;


assign n_dr0_track = w_drx_track;
assign n_dr0_id = w_drx_id;
assign n_dr0_resp = w_drx_resp;
assign n_dr0_last = w_drx_last & w_drx_eob;
assign n_dr0_rdata = w_drx_rdata;
assign n_dr0_poison = w_drx_poison;

\js // Get almost-full functionality by exposing the valids, and seeing how full the fifo is.
wire [\=BPL+1-1=\:0] dr0_valids;
assign w_dr0_af = dr0_valids[1];
\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'dr0',
	params: {
                depth:          BPL+1,
		width:		DRW,
                pipeForward:    "yes",
                pipeBackward:   "yes",
                simplePipe:     "no",
                circular:       "no",
                exposeValids:   "true"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		valids:		'dr0_valids',
		in_ready:	'w_dr0_ready',
		in_valid:	'n_dr0_valid',
		in_data:	`{n_dr0_track, n_dr0_id, n_dr0_resp, 
				  n_dr0_last, n_dr0_rdata, n_dr0_poison}`,
		out_ready:	'n_dr0_ready',
		out_valid:	'w_dr0_valid',
		out_data:	`{w_dr0_track, w_dr0_id, w_dr0_resp, 
				  w_dr0_last, w_dr0_rdata, w_dr0_poison}`
	},
	portsDelimiter: '\n\t'
})=\

assign n_dr1_ready = dr_ready_i;

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'dr1',
	params: {
                depth:          2,
		width:		DRW,
                pipeForward:    "yes",
                pipeBackward:   "yes",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'n_dr0_ready',
		in_valid:	'w_dr0_valid',
		in_data:	`{w_dr0_track, w_dr0_id, w_dr0_resp, 
				  w_dr0_last, w_dr0_rdata, w_dr0_poison}`,
		out_ready:	'n_dr1_ready',
		out_valid:	'w_dr1_valid',
		out_data:	`{w_dr1_track, w_dr1_id, w_dr1_resp, 
				  w_dr1_last, w_dr1_rdata, w_dr1_poison}`
	},
	portsDelimiter: '\n\t'
})=\

assign dr_valid_o = w_dr1_valid;
assign dr_rdata_o = w_dr1_rdata;
assign dr_poison_o = w_dr1_poison;
assign dr_last_o = w_dr1_last;
assign dr_resp_o = w_dr1_resp;
assign dr_id_o = w_dr1_id;
assign dr_user_o = {RUW{1'b0}};
assign dr_track_o = w_dr1_track;

\js if (ACE) {
wire [\=OCN-1=\:0] interleaved_valid, interleaved_valid_in;
wire [\=OCN-1=\:0] interleaved_sel;
wire [\=OCN-1=\:0] interleaved_match;
wire interleaved_count_en;
wire [\=wOCN=\:0] interleaved_count, interleaved_count_in, interleaved_count_adj;
wire [7:0] interleaved_count_adj_tmp;

\=u.instance({
        moduleName: 'ioaiu_enc',
        instanceName: 'interleaved',
        params: {
                DW:             OCN,
                BE:             0,
                NO_VALID_OUT:   1,
                NO_INDEX_OUT:   1,
                clkAssertInterface : clkAssertInterface,
                assertOn: assertOn
        },
        ports: {
                bv_i:           '~interleaved_valid',
                bv_o:           'interleaved_sel'
        },
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
        portsDelimiter: '\n\t'
})=\

\js for (let i=0;i<OCN;i++) {

wire [IW-1:0] interleaved_id\=i=\, interleaved_id\=i=\_in;

assign interleaved_match[\=i=\] = interleaved_valid[\=i=\] & (w_dr0_id == interleaved_id\=i=\);

assign interleaved_valid_in[\=i=\] = (w_dr0_valid & n_dr0_ready & interleaved_match[\=i=\] & w_dr0_last) ? 1'b0 :
                                     (w_dr0_valid & n_dr0_ready & ~|interleaved_match & interleaved_sel[\=i=\] & ~w_dr0_last) ? 1'b1 :
                                     (interleaved_valid[\=i=\]); 

assign interleaved_id\=i=\_in = w_dr0_valid & n_dr0_ready & interleaved_sel[\=i=\] & ~|interleaved_match & ~w_dr0_last ? w_dr0_id : interleaved_id\=i=\;

\=u.dffre(IW, `interleaved_id`+i, `interleaved_id`+i+`_in`, `{`+IW+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
\js }
\=u.dffre(OCN, `interleaved_valid`, `interleaved_valid_in`, `{`+OCN+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
wire interleaved_count_inc, interleaved_count_dec, interleaved_count_single_inc, interleaved_count_single_dec;
assign interleaved_count_inc = w_dr0_valid & n_dr0_ready & ~|interleaved_match & ~w_dr0_last;
assign interleaved_count_dec = w_dr0_valid & n_dr0_ready &  |interleaved_match & w_dr0_last;
assign interleaved_count_single_inc = w_dr0_valid & n_dr0_ready & ~|interleaved_match & w_dr0_last;
\=u.dffre(1, `interleaved_count_single_dec`, `interleaved_count_single_inc`, `1'b0`, `1'b1`, `clk_i`, `reset_ni`)=\
assign interleaved_count_in = ( (interleaved_count_inc | interleaved_count_single_inc ) & ~interleaved_count_single_dec) ? (interleaved_count + \=wOCN+1=\'h1) :
                              (  interleaved_count_dec                                  &  interleaved_count_single_dec) ? (interleaved_count - \=wOCN+1=\'h2) :
                                                                                                                           (interleaved_count - \=wOCN+1=\'h1);
assign interleaved_count_en = ( (interleaved_count_inc | interleaved_count_single_inc ) & ~interleaved_count_single_dec) |
                              (~(interleaved_count_inc | interleaved_count_single_inc ) &  interleaved_count_single_dec) |
                              (  interleaved_count_dec                                                                 );
\=u.dffre(wOCN+1, `interleaved_count`, `interleaved_count_in`, `{`+(wOCN+1)+`{1'b0}}`, `interleaved_count_en`, `clk_i`, `reset_ni`)=\

assign interleaved_count_adj = (interleaved_count == \=wOCN+1=\'h0) ? \=wOCN+1=\'h0 : interleaved_count - \=wOCN+1=\'h1;
\jsbegin
// 3.7 OTT max entries is 128
/* istanbul ignore else env ncore_3p7 */
    if (wOCN<8) { \jsend
assign interleaved_count_adj_tmp[7:0] = {{\=8-wOCN=\{1'b0}},interleaved_count_adj[\=wOCN-1=\:0]};
\js } else {
assign interleaved_count_adj_tmp[7:0] = interleaved_count_adj[7:0];
\js }
\=u.dffre(8, `interleaved_count_o`, `interleaved_count_adj_tmp`, `8'b0`, `1'b1`, `clk_i`, `reset_ni`)=\

\js } else {
assign interleaved_count_o[7:0] = 8'b0;
\js }

\js ////////////////////////////////////////////////////////////////////
\js // Slave control response generation: SnoopResp and STR-resp
\js ////////////////////////////////////////////////////////////////////
\=u.instance({
	moduleName: 'ioaiu_arbiter',
	instanceName: 'stp_arb',
	params: {
                DRST:           DRST,
                DW:             OCN,
                ATOMIC:         0,
                HP:             `{`+OCN+`{1'b0}}`,
                VAL:            1,
		 assertOn: assertOn
		 },
	ports: {
		clk_i:		'clk_i',
		reset_ni:	'reset_ni',
		ready_i:	'w_ocp_ready',
		bv_i:		't_oc_stp',
		lv_i:		`{OCN{1'b1}}`,
		winner_o:	'n_ocp_oid',
		wbv_o:		'n_ocp_obv'
	},
	portsDelimiter: '\n\t'
})=\

assign n_str_rsp0_cancel = q_oc_nc[w_ocp_oid] & q_oc_write[w_ocp_oid] & ~q_oc_partial[w_ocp_oid] & q_oc_cache[w_ocp_oid][3] & ~q_oc_ext[w_ocp_oid];
assign n_str_rsp0_valid  = w_ocp_valid & ~n_str_rsp0_cancel;
assign n_str_rsp0_status = 8'b0;
assign n_str_rsp0_rid   = q_oc_mid[w_ocp_oid];
assign n_str_rsp0_tid   = q_oc_iid[w_ocp_oid];
assign n_str_rsp0_trace = q_oc_trace[w_ocp_oid];
assign n_str_rsp0_qin   = w_oc_qin[w_ocp_oid];

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'str_rsp0',
	params: {
                depth:          1,
		width:		SPCW+1,
                pipeForward:    "yes",
                pipeBackward:   "no",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_str_rsp0_ready',
		in_valid:	'n_str_rsp0_valid',
		in_data:	`{n_str_rsp0_status, n_str_rsp0_trace,
				  n_str_rsp0_qin, n_str_rsp0_rid, n_str_rsp0_tid}`,
		out_ready:	'n_str_rsp0_ready',
		out_valid:	'w_str_rsp0_valid',
		out_data:	`{w_str_rsp0_status, w_str_rsp0_trace,
				  w_str_rsp0_qin, w_str_rsp0_rid, w_str_rsp0_tid}`
	},
	portsDelimiter: '\n\t'
})=\

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'str_rsp1',
	params: {
                depth:          1,
		width:		SPCW+1,
                pipeForward:    "no",
                pipeBackward:   "yes",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'n_str_rsp0_ready',
		in_valid:	'w_str_rsp0_valid',
		in_data:	`{w_str_rsp0_status, w_str_rsp0_trace, 
				  w_str_rsp0_qin, w_str_rsp0_rid, w_str_rsp0_tid}`,
		out_ready:	'n_str_rsp1_ready',
		out_valid:	'w_str_rsp1_valid',
		out_data:	`{w_str_rsp1_status, w_str_rsp1_trace, 
				  w_str_rsp1_qin, w_str_rsp1_rid, w_str_rsp1_tid}`
	},
	portsDelimiter: '\n\t'
})=\

assign n_str_rsp1_ready = str_rsp_ready_i;
assign str_rsp_valid_o = w_str_rsp1_valid;
assign str_rsp_status_o =  w_str_rsp1_status;
assign str_rsp_mid_o = {SRCM{1'b0}};
assign str_rsp_trace_o = w_str_rsp1_trace;
assign str_rsp_rid_o = w_str_rsp1_rid;
assign str_rsp_iid_o = cmd_req_iid_o;
assign str_rsp_tid_o = w_str_rsp1_tid;

wire [SPCP-1:0] w_str_rsp1_qin_tmp;

\jsbegin
// wPriority = 3/0, QOSW = 3/1, so wPriority is never greater
/* istanbul ignore if env ncore_3p7 */
    if (concParams.hdrParams.wPriority>QOSW) { \jsend
    assign w_str_rsp1_qin_tmp = {{SPCP-QOSW{1'b0}},w_str_rsp1_qin};
\js } else {
    assign w_str_rsp1_qin_tmp = w_str_rsp1_qin[SPCP-1:0];
\js }

assign str_rsp_pri_o = w_str_rsp1_qin_tmp;
assign str_rsp_ql_o = {SPCL{1'b0}};



assign n_dtr_rsp_tx_status = 8'h0;
assign n_dtr_rsp_tx_trace = w_dtr_req_rx_trace;
assign n_dtr_rsp_tx_pri = w_dtr_req_rx_pri;
assign n_dtr_rsp_tx_mid = w_dtr_req_rx_mid;
assign n_dtr_rsp_tx_tid = w_dtr_req_rx_iid;

\=u.instance({
	moduleName: 'rdy_vld_pipe',
	instanceName: 'dtr_rsp_tx0',
	params: {
                depth:          1,
		width:		SPRW+1,
                pipeForward:    "yes",
                pipeBackward:   "no",
                simplePipe:     "no",
                circular:       "no"
		 },
	verilogParams: {
	},
	ports: {
		clk:		'clk_i',
		reset_n:	'reset_ni',
		in_ready:	'w_dtr_rsp_tx_ready',
		in_valid:	'n_dtr_rsp_tx_valid',
		in_data:	`{n_dtr_rsp_tx_status, n_dtr_rsp_tx_trace, 
				  n_dtr_rsp_tx_pri, n_dtr_rsp_tx_mid, n_dtr_rsp_tx_tid}`,
		out_ready:	'n_dtr_rsp_tx_ready',
		out_valid:	'w_dtr_rsp_tx_valid',
		out_data:	`{w_dtr_rsp_tx_status, w_dtr_rsp_tx_trace, 
				  w_dtr_rsp_tx_pri, w_dtr_rsp_tx_mid, w_dtr_rsp_tx_tid}`
	},
	portsDelimiter: '\n\t'
})=\

\js // CONC-11831 - This FIFO is used to decouple the Command Network 1 and Data Network 0. Previously CN1 can backpressure the dtr_rsp_tx which backpressures data coming in. 
\js // Needs to hold all possible generated responces

\=u.instance({
        'portsDelimiter': '\n    ',
        'instanceName': 'dtr_rsp_tx1',
        'moduleName':   'rdy_vld_pipe',
        'params': {
                 "pipeForward"  : "yes",
                 "pipeBackward" : "no",
                 "simplePipe"   : "no",
                 "circular"     : "no",
                 "width"        : SPRW+1,
                 "depth"        : OCN
              },
        'verilogParams': {},
        'ports':{
          clk        : 'clk_i',
          reset_n    : 'reset_ni',
          in_valid   : 'w_dtr_rsp_tx_valid',
          in_data    : '{w_dtr_rsp_tx_status, w_dtr_rsp_tx_trace, w_dtr_rsp_tx_pri, w_dtr_rsp_tx_mid, w_dtr_rsp_tx_tid}',
          in_ready   : 'n_dtr_rsp_tx_ready',
          out_valid  : 'w_dtr_rsp_tx1_valid',
          out_data   : '{w_dtr_rsp_tx1_status, w_dtr_rsp_tx1_trace, w_dtr_rsp_tx1_pri, w_dtr_rsp_tx1_mid, w_dtr_rsp_tx1_tid}',
          out_ready  : 'n_dtr_rsp_tx1_ready'
        }
})=\

assign n_dtr_rsp_tx1_ready = dtr_rsp_tx_ready_i;
assign dtr_rsp_tx_valid_o = w_dtr_rsp_tx1_valid;
assign dtr_rsp_tx_cmd_o = DtrRsp;
assign dtr_rsp_tx_status_o = w_dtr_rsp_tx1_status;	
assign dtr_rsp_tx_mid_o = {SRRM{1'b0}};
assign dtr_rsp_tx_rid_o = w_dtr_rsp_tx1_mid;
assign dtr_rsp_tx_iid_o = cmd_req_iid_o;
assign dtr_rsp_tx_tid_o = w_dtr_rsp_tx1_tid;
assign dtr_rsp_tx_pri_o = w_dtr_rsp_tx1_pri;
assign dtr_rsp_tx_trace_o = w_dtr_rsp_tx1_trace;
assign dtr_rsp_tx_ql_o = {SPRL{1'b0}};

\jsbegin
////////////////////////////////////////////////////////////////////////////
/* istanbul ignore else env ncore_3p7 */
    if (assertOn) { \jsend
`ifdef OVL_ASSERT_ON
// pragma synthesis_off
// synthesis_off
// coverage off

reg a_error_test, a_unit_level;
initial begin
	if ($test$plusargs("error_test")) begin
		a_error_test = 1'b1;
	end else begin
		a_error_test = 1'b0;
	end
	if ($test$plusargs("ioaiu_tb_arg")) begin
		a_unit_level = 1'b1;
	end else begin
		a_unit_level = 1'b0;
	end

end

function automatic integer ioaiu_sum (input [1023:0] num);
begin: func_ioaiu_sum
        for (ioaiu_sum=(num%2); num>0; ioaiu_sum=ioaiu_sum+(num%2)) begin
                num = (num >> 1);
        end
end
endfunction

function automatic integer ioaiu_add (input [31:0] nums[], input integer num);
begin: func_ioaiu_add
integer i;
        ioaiu_add = 0;
        for (i=0; i<num; i=i+1) begin
                ioaiu_add = ioaiu_add + nums[i];
        end
end
endfunction

wire [12:0] assert_dtr_expr;

\jsbegin
// config_ace_small_ott (eAc==1) does not have asserts enabled
/* istanbul ignore if env ncore_3p6,ncore_3p7 */
    if (ACE) { \jsend
\js if (axiParams.wCdData) {
wire [11:0] assert_ace_vec;
assign assert_ace_vec[11] = (rack_int & ~w_rkq_valid & ~a_error_test) ;
assign assert_ace_vec[10] = (wack_int & ~w_wkq_valid & ~a_error_test) ;
assign assert_ace_vec[9] =  (w_crq_valid & t_crs_valid & (~t_st_val[w_crq_sid] |
                                                          ~q_st_wfcr[w_crq_sid])) ;
assign assert_ace_vec[8] =  (q_dvm_state & (ioaiu_sum(t_st_ac) != 1)) ;
assign assert_ace_vec[7] =  (q_dvm_state & w_cmp_rsp_valid) ;
assign assert_ace_vec[6] =  (w_cr_valid & ~w_crq_valid & ~a_error_test) ;
assign assert_ace_vec[5] =  (t_crs_valid & ((~w_cdq_valid &
                                             (t_st_cmd[w_crq_sid]!=SnpDvmMsg)) |
                                            ~t_st_val[w_crq_sid] |
                                            q_st_wfac[w_crq_sid] |
                                            ~t_st_wfcr[w_crq_sid]) & ~a_error_test) ;
assign assert_ace_vec[4] =  (t_cd_valid & (~w_cd_valid | ~w_cdq_valid |
                                           (w_crq_valid & ~w_crq_data[XTA] &
                                                          (w_cdq_sid==w_crq_sid)) |
                                           ~t_st_val[w_cdq_sid] |
                                           q_st_wfac[w_cdq_sid] |
                                           t_st_wfcr[w_cdq_sid])) ;
assign assert_ace_vec[3] =  (n_cdq_valid & (t_st_cmd[n_ac_sid]==SnpDvmMsg)) ;
assign assert_ace_vec[2] =  (w_pt_valid & w_pt_write & ~w_pt_bar[0] &
                                           (w_pt_snoop==4'h2) &    //ACE WriteClean
                                           t_pt_unique) ;
assign assert_ace_vec[1] =  (n_srs_valid & (ACE>0)) ;
assign assert_ace_vec[0] =  ((|(t_st_val & t_st_wfcr& ~t_st_wfac)) & ~w_crq_valid);

assert_never #(0) assert_ace(
        .clk            (clk_i),
        .reset_n        (reset_ni),
        .test_expr      (|assert_ace_vec)
);

wire [5:0] assert_dve_vec;
assign assert_dve_vec[5] =  (| (t_oc_dve & t_oc_catop)) ;
assign assert_dve_vec[4] =  ((CDW<=1) &
                             w_p2_valid & ~w_pt_write & (w_pt_snoop==4'hf)) ;
assign assert_dve_vec[3] =  (w_cm0_valid & (w_cm0_status==8'h84) &
                                           ~a_error_test) ;
assign assert_dve_vec[2] =  (n_odr_valid & t_oc_dve[n_odr_oid] &
                                           ((q_oc_status[n_odr_oid]==8'h84) |
                                             q_oc_lock[n_odr_oid])) ;
assign assert_dve_vec[1] =  (w_cmp_rsp_valid & ~q_oc_val[w_cmp_rsp_mid[\=wOCN-1=\:0]] & ~a_error_test) ;
                            // RRESP is now sent before completion messages. (w_cm0_valid & ~q_oc_wfdtr[w_cm0_mid[\=wOCN-1=\:0]] & ~a_error_test) ;
assign assert_dve_vec[0] =  (| (t_oc_dve & ~q_oc_wfdtr & q_oc_wfdtw & q_oc_wfstr)) & ~a_error_test;

assert_never #(0) assert_dve(
        .clk            (clk_i),
        .reset_n        (reset_ni),
        .test_expr      (|assert_dve_vec)
);

\js   }
\js }

wire [44:0] assert_param_vec;
assign assert_param_vec[44] = ((CACHE>0) & (OCN<4)) | (OLA>OCA) ;
assign assert_param_vec[43] = ((\=axiParams.eDomain?axiParams.eDomain:0=\>0) & (CACHE>0)) ;
assign assert_param_vec[42] = ((CDW>1) & (ACE==0)) ;
assign assert_param_vec[41] = (MRRD < 64) ;
assign assert_param_vec[40] = (MPCI != MRCT) ;
assign assert_param_vec[39] = (MRC1 < 7) ;
assign assert_param_vec[38] = (IW < LIDW) ;
                              //CONC-5549: ((IE>0) & (MRC2<(IW+1))) |
assign assert_param_vec[37] = ((CDW>1) & (CDW!=DW)) ;
assign assert_param_vec[36] = (AWL < 3) ;
assign assert_param_vec[35] = (BWL != CLO-AWL) ;
assign assert_param_vec[34] = ((CACHE>0) & (\=COH_MSI=\==0) & (\=COH_MOESI=\==0)) ;
assign assert_param_vec[33] = ((CACHE>0) & (CST_IX>0)) ;
assign assert_param_vec[32] = ((CACHE>0) & (CST_SC==0)) ;
assign assert_param_vec[31] = ((CACHE>0) & (CST_SD==0) & (\=COH_MOESI=\>0)) ;
assign assert_param_vec[30] = ((CACHE>0) & (CST_UC==0)) ;
assign assert_param_vec[29] = ((CACHE>0) & (CST_UD==0)) ;
assign assert_param_vec[28] = ((CST_SD>0) & (\=COH_MOESI=\==0)) ;
assign assert_param_vec[27] = ((\=COH_MOESI=\>0) & ((CST_SC==CST_SD) |
                                                (CST_SC==CST_UC) |
                                                (CST_SC==CST_UD) |
                                                (CST_SD==CST_UC) |
                                                (CST_SD==CST_UD) |
                                                (CST_UC==CST_UD))) ;
assign assert_param_vec[26] = ((CACHE>0) & (\=COH_MSI=\+\=COH_MEI=\+\=COH_MOSI=\+\=COH_MOESI=\)!=1) ;
assign assert_param_vec[25] = ((\=COH_MOESI=\>0) & (CSW!=3)) ;
assign assert_param_vec[24] = ((\=COH_MSI=\>0) & (CSW!=2)) ;
assign assert_param_vec[23] = ((\=COH_MEI=\>0) & (CSW!=2)) ;
assign assert_param_vec[22] = ((\=COH_MOSI=\>0) & (CSW!=2)) ;
assign assert_param_vec[21] = (OCA != \=log2ceil(OCN)=\) ;
assign assert_param_vec[20] = (CWW != \=ioaiu_pos(log2ceil(WAYS))=\) ;
assign assert_param_vec[19] = (STA > XTA) | (OCA > XTA) ;
assign assert_param_vec[18] = (TINW > 5) ;
assign assert_param_vec[17] = (MRUP < QOSW) | (MRCP < QOSW) ;
assign assert_param_vec[16] = (MRRP < QOSW) | (MRWP < QOSW) ;
assign assert_param_vec[15] = (MRCM<OCA) | (MRUM<OCA) ;
assign assert_param_vec[14] = (MRCA !=AW) ;
assign assert_param_vec[13] = (MRWM < (OCA+CACHE)) ;
assign assert_param_vec[12] = (MRWM < (STA+CACHE)) ;
assign assert_param_vec[11] = (SRNA < AW) ;
assign assert_param_vec[10] = (MRRR > SRN2) ;
assign assert_param_vec[9]  = (SPRT != SRRI) ;
assign assert_param_vec[8]  = (MRCI != MRUI) | (MRCI != MRRI) | (MRCI != MRWI) ;
assign assert_param_vec[7]  = (MRCI != SPRI) | (SPRR != SRRM) ;
assign assert_param_vec[6]  = (MRRR != MRRM) ;
assign assert_param_vec[5]  = (SRCR != SRCM) | (SRRR != SRRM) ;
assign assert_param_vec[4]  = (SRCB != MRWV) | (OCA >= MRRM) ;
assign assert_param_vec[3]  = (SRCM != SPNR) | (SRCM != SPCR) | (STA >= MRRM) ;
assign assert_param_vec[2]  = ((OTEN>0) & (OCN<8)) ;
assign assert_param_vec[1]  = ((STN>1) & (CACHE==0) & (ACE==0) & (\=owo?1:0=\==0)) ;
assign assert_param_vec[0]  = ((ODWIW>ODFIW) & (ODWIW>ODRIW));

assert_never #(0) assert_param(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	(|assert_param_vec)
);

wire clk_ptr_used = q_od_val[q_od_wptr] & ~(&q_od_val) & ~(~q_od_ready & n_od_ready);

assert_never #(0) assert_clocked_ptr_used(
	.clk		(clk_i),
	.reset_n	(reset_ni & q_reset_n),
	.test_expr	(clk_ptr_used)
);

wire [6:0] assert_deadlock_vec;
                               //((~| q_oc_val) & (~w_dce_idle | ~w_dmi_idle |
                               //                ~w_dii_idle | ~w_dve_idle |
                               //                ~w_qos_idle)) ;
assign assert_deadlock_vec[6] =(~w_qos_idle & 
                                 w_dce_idle & w_dmi_idle & w_dii_idle & w_dve_idle) ;
assign assert_deadlock_vec[5] =(cmd_rsp_valid_i & ~cmd_rsp_ready_o) ;
assign assert_deadlock_vec[4] =(dtr_rsp_rx_valid_i & ~dtr_rsp_rx_ready_o) ;
assign assert_deadlock_vec[3] =(dtw_rsp_valid_i & ~dtw_rsp_ready_o) ;
assign assert_deadlock_vec[2] =(upd_rsp_valid_i & ~upd_rsp_ready_o) ;
assign assert_deadlock_vec[1] =(str_req_valid_i & ~str_req_ready_o) ;
assign assert_deadlock_vec[0] =(dtr_req_rx_valid_i & ~dtr_req_rx_ready_o & 1'b0) ;
//                             (snp_req_valid_i & ~snp_req_ready_o & q_reset_n);

assert_never #(0) assert_deadlock(
	.clk		(clk_i),
	.reset_n	(reset_ni & q_reset_n),
	.test_expr	(|assert_deadlock_vec)
);

wire [17:0] assert_oc_vec;
assign assert_oc_vec[17] =     (t_srd_adone & (n_odr_oid == w_srd_oid) & n_odr_adone);
assign assert_oc_vec[16] =     (n_odr_valid & (n_odr_oid != q_oc_iptr[n_odr_oid]) &
                                              (| q_odr_count)) ;
assign assert_oc_vec[15] =     (t_oc_count > OCN) ;
assign assert_oc_vec[14] =     (q_oc_rcount > OCN) | (q_oc_wcount > OCN) ;
assign assert_oc_vec[13] =     ((| t_oc_coal) & ~t_cfg_coal) ; 
assign assert_oc_vec[12] =     ((~| q_oc_val) & (| q_od_val) & ~w_w1_valid &
                                              ~w_p0w_valid &
                                              ~(w_p0_valid & w_p0_write) &
                                              ~(w_p1_valid & w_p1_write) &
                                              ~(w_p2_valid & w_pt_write)) ;
assign assert_oc_vec[11] =     (q_oc_ready & (q_oc_wptr > (OCN-1))) ;
assign assert_oc_vec[10] =     (q_od_ready & (q_od_wptr > (OLN-1))) ;
assign assert_oc_vec[9]  =     (w_p2_valid & t_pt_snp & w_pt_wake) ;
assign assert_oc_vec[8]  =     (w_p2_valid & ~w_pt_wake & ~t_pt_snp & (& q_oc_val)) ;
//                             (w_p2_valid & w_pt_wake & 
//                                (| (t_oc_lhit & ~({{OCN{1'b0}}, 1'b1}<<w_pt_kid))));
assign assert_oc_vec[7]  =     1'b0;
assign assert_oc_vec[6]  =     1'b0;
assign assert_oc_vec[5]  =     (t_oc_count > t_cfg_oc_limit) ;
assign assert_oc_vec[4]  =     (q_oc_rcount > t_cfg_rd_limit) ;
assign assert_oc_vec[3]  =     (q_oc_wcount > t_cfg_wr_limit) ;
assign assert_oc_vec[2]  =     1'b0;
assign assert_oc_vec[1]  =     1'b0;
assign assert_oc_vec[0]  =     (t_oc_we & (n_oc_beats > \=BPL=\));

assert_never #(0) assert_oc(
	.clk		(clk_i),
	.reset_n	(reset_ni & ~a_error_test),
	.test_expr	(|assert_oc_vec)
);

wire [5:0] assert_list_vec;
assign assert_list_vec[5] =    (w_pt_valid & w_pt_wake & (| t_oc_ahitr)) ;
assign assert_list_vec[4] =    (w_pt_valid & w_pt_wake & (| t_oc_ihit)) ;
assign assert_list_vec[3] =    (w_pt_valid & w_pt_wake & t_oc_evict[w_pt_kid] &
                                                         (| t_oc_ahit)) ;
                               // (ioaiu_sum(t_oc_ihit) > 1) ; Checked by: assert_ocihit. Needs valid qualification.
assign assert_list_vec[2] =    (ioaiu_sum(t_oc_ahit) > 2) ;
assign assert_list_vec[1] =    (ioaiu_sum(t_oc_ahitr) > 1) ;
assign assert_list_vec[0] =    (ioaiu_sum(t_oc_ahite) > 1);

assert_never #(0) assert_list(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	(|assert_list_vec)
);

wire [\=(STE>0)?7:6=\:0] assert_sums_vec;
\js if (STE) {
assign assert_sums_vec[7] =    (ioaiu_sum(t_st_val & ~t_st_wake) < t_st_count) ;
\js } // STE             
assign assert_sums_vec[6] =    (ioaiu_sum(q_od_val) > (ioaiu_sum(q_oc_val) + 3 +
                                                    w_w1_valid + w_p0w_valid +
                                                    (t_pe_correctable_error & w_rr_write) +
                                                    (t_p1_correctable_error & w_p1_write) +
                                                    (w_p0_valid & w_p0_write) + 
                                                    (w_p1_valid & w_p1_write) + 
                                                    (w_p2_valid & w_pt_write))) ;
assign assert_sums_vec[5] =    (ioaiu_sum(t_oc_edealloc & (w_oc_edbv0|w_oc_edbv1))>2);
assign assert_sums_vec[4] =    (ioaiu_sum(t_oc_rdealloc & (w_oc_rdbv0|w_oc_rdbv1))>2);
assign assert_sums_vec[3] =    (ioaiu_sum(t_oc_wdealloc & (w_oc_wdbv0|w_oc_wdbv1))>2);
assign assert_sums_vec[2] =    (ioaiu_sum(t_oc_dealloc & t_oc_evict) > 3) ;
assign assert_sums_vec[1] =    (ioaiu_sum(q_oc_val & t_oc_evict & q_oc_itail) > 1) ;
//                             ((| (q_oc_val & t_oc_evict & q_oc_wfdtw)) & 
//                              (~| (q_oc_val & t_oc_evict & q_oc_itail))) ;
assign assert_sums_vec[0] =    (t_oc_count != (q_oc_rcount + q_oc_wcount + 
                                                             t_oc_ecount));

assert_never #(0) assert_sums(
	.clk		(clk_i),
	.reset_n	(reset_ni & ~a_error_test),
	.test_expr	(|assert_sums_vec)
);

wire [10:0] assert_amap_vec;
assign assert_amap_vec[10] =   (w_pt_valid & (ioaiu_sum(w_amc_vals[2:1])>1)) ;
assign assert_amap_vec[9]  =   (w_pt_valid & t_pt_dce & ~w_amc_vals[0] & 
                                               n_cmd_req0_valid & (n_cmd_req0_cmd != DVMOp)) ;
assign assert_amap_vec[8]  =   (w_pt_valid & (& w_amc_errs) & (n_cmd_req0_cmd != DVMOp)) ;
assign assert_amap_vec[7]  =   (amc_vals_i[0] & (amc_fids_i[0*FIDW +: FIDW] != 
                                       dce_ids_i[amc_tins_i[0*5 +: 5]*FIDW +: FIDW]));
assign assert_amap_vec[6]  =   (amc_vals_i[1] & (amc_fids_i[1*FIDW +: FIDW] != 
                                       dmi_ids_i[amc_tins_i[1*5 +: 5]*FIDW +: FIDW]));
assign assert_amap_vec[5]  =   (amc_vals_i[2] & (amc_fids_i[2*FIDW +: FIDW] != 
                                       dii_ids_i[amc_tins_i[2*5 +: 5]*FIDW +: FIDW]));
assign assert_amap_vec[4]  =   (amc_vals_i[0] & (amc_tins_i[0*5 +: 5]>DCEN)) ;
assign assert_amap_vec[3]  =   (amc_vals_i[1] & (amc_tins_i[1*5 +: 5]>DMIN)) ;
assign assert_amap_vec[2]  =   (amc_vals_i[2] & (amc_tins_i[2*5 +: 5]>DIIN)) ;
assign assert_amap_vec[1]  =   (n_cmd_req0_valid & 1'b0 &
                                w_pt_valid & t_pt_dii & (| w_pt_cache[3:1])) ;
assign assert_amap_vec[0]  =   (DCEN>32) | (DMIN>32) | (DIIN>32);

assert_never #(0) assert_amap(
	.clk		(clk_i),
	.reset_n	(reset_ni & ~a_error_test),
	.test_expr	(|assert_amap_vec)
);

wire [\=(STE>0)?8:7=\:0] assert_retry_vec;
\js if (STE) {           
assign assert_retry_vec[8]  =  (w_rr_valid & w_rr_snp &
                                                   ~t_st_val[w_rr_kid]) ;
\js } // STE             
assign assert_retry_vec[7]  =  (w_c2_valid & ~w_rpt_ready & ~w_pt_wake & ~t_pt_correctable_error);
assign assert_retry_vec[6]  =  (w_p1_valid & t_pt_correctable_error & ~w_rp1_ready) ;
assign assert_retry_vec[5]  =  (w_p1_valid & t_pe_correctable_error & ~w_rp1_ready) ;
assign assert_retry_vec[4]  =  (w_pt_valid & (t_pt_correctable_error | t_pe_correctable_error)) ;
assign assert_retry_vec[3]  =  (w_p2_valid & (t_pt_correctable_error | t_pe_correctable_error) & n_p2_ready) ;
assign assert_retry_vec[2]  =  (w_rr_valid & w_rr_cmr[1] & ~n_rr_ready & 
                                              ((w_p1_valid & (CACHE>0)) |
                                               w_p2_valid |
                                               n_srs_valid |
                                               t_poc_valid | 
                                               t_prb_valid | 
                                               t_p0w_valid | 
                                               t_p0r_valid)) ;
assign assert_retry_vec[1]  =  (w_rr_valid & w_rr_cmr[1] & w_rr_wake) ;
assign assert_retry_vec[0]  =  (w_rr_valid & ~w_rr_snp &
                                              (~t_pe_correctable_error & ~w_p1_valid) & 1'b0 &
                                             ~w_rr_cmr[1] & 
                                             (~q_oc_val[w_rr_kid] |
                                              q_oc_wake[w_rr_kid]));

assert_never #(0) assert_retry(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	(|assert_retry_vec)
);

wire [20:0] assert_order_vec;
assign assert_order_vec[20] =  (w_p2_valid & w_pt_write & ~w_pt_wake & ~w_pt_cmr[1] &
                                             ~q_od_val[w_pt_kid]) ; 
assign assert_order_vec[19] =  (w_p2_valid & w_pt_write & w_pt_wake & ~t_pt_evict &
                                             ~q_oc_status[w_pt_kid][7] &
                                             ~q_od_val[q_oc_dptr[w_pt_kid]]) ;
assign assert_order_vec[18] =  (w_p2_valid & ~w_cmd_req0_ready &
                                             ~(w_pt_snp)) ;
assign assert_order_vec[17] =  (w_p2_valid & ~w_c2_valid & ~t_pt_correctable_error & ~t_pe_correctable_error &
                                             cfg_cache_i & 
                                             ~(w_pt_wake & t_oc_evict[w_pt_kid]) & ~a_error_test) ;
assign assert_order_vec[16] =  ((CACHE==0) & w_p1_valid & t_pe_correctable_error) ;
assign assert_order_vec[15] =  ((CACHE==0) & w_p2_valid & t_pt_correctable_error) ;
assign assert_order_vec[14] =  (w_p2_valid & t_pe_correctable_error & cp2_valid_i) ;
assign assert_order_vec[13] =  ~w_do_ready ; 
assign assert_order_vec[12] =  ((w_cdr_valid | w_odr_valid) & ~w_do_valid) ;
assign assert_order_vec[11] =  (t_pe_correctable_error & cp2_valid_i) ;
assign assert_order_vec[10] =  (w_p2_valid & w_pt_wake & t_oc_evict[w_pt_kid]) ;
assign assert_order_vec[9]  =  (w_p2_valid & w_pt_wake & ~q_oc_val[w_pt_kid]) ;
assign assert_order_vec[8]  =  ((| q_do_last) & (~& w_do_data)) ;
assign assert_order_vec[7]  =  (w_do_valid & (~| w_do_data)) ;
assign assert_order_vec[6]  =  (t_srd_bypass & (w_cdr_valid | w_odr_valid)) ;
assign assert_order_vec[5]  =  (t_p0w_valid & ~q_od_val[w_p0w_dptr]) ;
assign assert_order_vec[4]  =  ((CACHE>0) & w_c2_valid & ~w_p2_valid) ;
assign assert_order_vec[3]  =  ((CACHE>0) & w_c2_valid & ~w_pt_valid & ~t_pt_correctable_error &
                                                                       ~t_pe_correctable_error) ;
assign assert_order_vec[2]  =  ~w_wq_ready ; 
assign assert_order_vec[1]  =  (& q_do_last) ; 
assign assert_order_vec[0]  =  ((| q_w1_beats) & ~w_w1_valid);

assert_never #(0) assert_order(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	(|assert_order_vec)
);

assert_never #(2) assert_performance(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	((w_snp_req_valid & w_ce_af))
);

\js if (STE) {
wire [1:0] assert_snoop_vec;
assign assert_snoop_vec[1] =   (w_p2_valid & w_pt_snp & 
                                              ~t_st_val[w_pt_kid]) ;
//                             (n_snp_req_valid & ~w_snp_req_ready & ~a_unit_level) ;
//                             (~w_snp_req_ready & ~a_unit_level) ;
assign assert_snoop_vec[0] =   (n_dtw_req0_valid & w_cs_valid & 1'b0 &
                                              (n_dtw_req0_tid!=t_st_sdid[w_cs_sid]));
assert_never #(0) assert_snoop(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	(|assert_snoop_vec)
);
\js } // STE

wire [3:0] assert_burst_vec;
assign assert_burst_vec[3] =   (n_p0_sel[0] & n_p0r_ready & (p0r_burst_modified != p0r_burst_modified_alt));
assign assert_burst_vec[2] =   (n_rb_ready & (| w_rb_addr[CLO-1:0])) ;
assign assert_burst_vec[1] =   (w_pt_valid & (| w_pt_len) & 1'b0 &
                                             (((DW==64)  & (w_pt_size < 3)) | 
                                              ((DW==128) & (w_pt_size < 4)) | 
                                              ((DW==256) & (w_pt_size < 5)))) ;
assign assert_burst_vec[0] =   (w_rb_valid & w_rb_size != ((DW==8) ? 0 :
                                                           (DW==16) ? 1 :
                                                           (DW==32) ? 2 :
                                                           (DW==64) ? 3 :
                                                           (DW==128) ? 4 : 
                                                           (DW==256) ? 5 : 
                                                           (DW==512) ? 6 : 7));
assert_never #(0) assert_burst(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	(|assert_burst_vec)
);

wire [14:0] assert_mr_vec;
assign assert_mr_vec[14] =     ((q_cmd_req_count >= {(~| cfg_cmd_req_max_i),
                                                     cfg_cmd_req_max_i}) & t_cmd_req_inc) ;
assign assert_mr_vec[13] =     ((q_upd_req_count >= {(~| cfg_upd_req_max_i),
                                                     cfg_upd_req_max_i}) & t_upd_req_inc) ;
assign assert_mr_vec[12] =     ((& q_cmd_req_count) & t_cmd_req_inc) ;
assign assert_mr_vec[11] =     (upd_req_valid_o & upd_req_cmd_o[7]) ; 
assign assert_mr_vec[10] =     (cmd_req_valid_o & cmd_req_cmd_o[7]) ; 
assign assert_mr_vec[9]  =     ((~| q_cmd_req_count) & t_cmd_req_dec) ;
assign assert_mr_vec[8]  =     ((& q_upd_req_count) & t_upd_req_inc) ;
assign assert_mr_vec[7]  =     ((~| q_upd_req_count) & t_upd_req_dec) ;
assign assert_mr_vec[6]  =     (w_dtr_req_tx0_valid & (~& w_dtr_req_tx0_be)) ;
assign assert_mr_vec[5]  =     ((q_dtr_req_tx_count >= {(~| cfg_dtr_req_tx_max_i),
                                                     cfg_dtr_req_tx_max_i}) & t_dtr_req_tx_inc) ;
assign assert_mr_vec[4]  =     ((q_dtw_req_count >= {(~| cfg_dtw_req_max_i),
                                                     cfg_dtw_req_max_i}) & t_dtw_req_inc) ;
assign assert_mr_vec[3]  =     ((& q_dtr_req_tx_count) & t_dtr_req_tx_inc) ;
assign assert_mr_vec[2]  =     ((& q_dtw_req_count) & t_dtw_req_inc) ;
assign assert_mr_vec[1]  =     ((~| q_dtr_req_tx_count) & t_dtr_req_tx_dec) ;
assign assert_mr_vec[0]  =     ((~| q_dtw_req_count) & t_dtw_req_dec);

assert_never #(0) assert_mr(
	.clk		(clk_i),
	.reset_n	(reset_ni & ~a_error_test),
	.test_expr	(|assert_mr_vec)
);

wire [3:0] assert_sr_vec;
                               // (w_str_req_valid & (w_str_req_addr[12 +: 3] != myid_i)) |
assign assert_sr_vec[3] =      (str_req_valid_i & (str_req_cmd_i != STRreq) & ~a_error_test) ;
assign assert_sr_vec[2] =      (w_str_req_valid & ~q_oc_wfstr[w_str_req_rid] & ~a_error_test) ;
assign assert_sr_vec[1] =      (w_snp_req_valid & (w_snp_req_cmd[7:5]!=3'h2)) ;
assign assert_sr_vec[0] =      (w_snp_req_valid & ~((w_snp_req_cmd >= 7'h41) |
                                                (w_snp_req_cmd <= 7'h51)) &
                                      ((w_snp_req_addr[6 +: 6] > OCN) |
                                       ~q_oc_val[w_snp_req_mpf2]));

assert_never #(0) assert_sr(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	(|assert_sr_vec)
);

wire [12:0] assert_dtr_vec;
assign assert_dtr_vec[12] = (w_odr_valid & ~w_odr_cmo & ~a_error_test &
                                           ~w_odr_csr & ~w_odr_bar & ~(|w_odr_be)) ;
assign assert_dtr_vec[11] = (w_dtr_req_tx1_valid & (~& w_dtr_req_tx1_be)) ;
assign assert_dtr_vec[10] = (w_adw_valid & ~q_od_val[w_w1_dptr]) ;
assign assert_dtr_vec[9]  = (w_w2_valid & ~q_od_val[w_w2_dptr]) ;
assign assert_dtr_vec[8]  = (n_sod_valid & ~q_od_val[q_oc_dptr[w_srd_oid]]) ;
assign assert_dtr_vec[7]  = (n_odf_valid & ~q_od_val[q_oc_dptr[n_odf_oid]]) ;
assign assert_dtr_vec[6]  = (n_odr_valid & ~q_od_val[q_oc_dptr[n_odr_oid]]) ;
assign assert_dtr_vec[5]  = (n_fq_valid & t_srd_dirty & (~& w_dtr_req_rx_be)) ;
assign assert_dtr_vec[4]  = (1'b0 & w_dtr_req_rx_valid & (w_dtr_req_rx_cmd==DtrDataInv) & w_srm_wbv[0] &
                                           t_oc_wfcft[w_srd_oid]) ;
assign assert_dtr_vec[3]  = (t_srd_dtr & t_oc_chit[w_srd_oid]) ;
assign assert_dtr_vec[2]  = (w_dtr_req_rx_valid & ~q_oc_wfdtr[w_srd_oid]) ;
assign assert_dtr_vec[1]  = (q_oc_line[w_srd_oid] & (~| t_oc_atop[w_srd_oid]) &
                             w_dtr_req_rx_valid & w_dtr_req_rx_last & w_srm_wbv[0] & (~& q_srd_count)) ;
//                          (~| srx_ready_o) | (~| mpx_ready_o) |
assign assert_dtr_vec[0]  = (t_srd_sel[0] & ~w_dr0_ready);

assert_never #(0) assert_dtr(
 	.clk		(clk_i),
 	.reset_n	(q_reset_n  & ~a_error_test),
	.test_expr	(|assert_dtr_vec)
 );

wire [5:0] assert_evict_vec;
assign assert_evict_vec[5] =   (cce_valid_i & (~& cce_be_i)) ;
assign assert_evict_vec[4] =   (n_ce_valid & n_ce_last & (~& w_co_count)) ;
assign assert_evict_vec[3] =   (| (q_oc_val & q_oc_wake & t_oc_evict)) ;
assign assert_evict_vec[2] =   (| (q_oc_val & t_oc_evict & q_oc_wrap & ~q_oc_wfresp));
assign assert_evict_vec[1] =   (| (q_oc_val & t_oc_evict & ~q_oc_line)) ;
assign assert_evict_vec[0] =   (n_upd_req0_valid & q_oc_wfresp[n_upd_req0_mid]);

assert_never #(0) assert_evict(
	.clk		(clk_i),
	.reset_n	(q_reset_n),
	.test_expr	(|assert_evict_vec)
);

wire [3:0] assert_atomic_vec;
assign assert_atomic_vec[3] =  (w_pt_valid & (\=axiParams.eAtomic?1:0=\==0) & (| w_pt_atop)) ;
assign assert_atomic_vec[2] =  (w_pt_valid & (| w_pt_atop) & ~n_oc_eob) ;
assign assert_atomic_vec[1] =  (w_pt_valid & (| (w_pt_atop & 6'h8))) ;
assign assert_atomic_vec[0] =  (w_pt_valid & ~(w_pt_atop==6'h0) &
                                             ~((w_pt_atop>>3)==3'h2) &
                                             ~((w_pt_atop>>3)==3'h4) &
                                             ~(w_pt_atop==6'h30) &
                                             ~(w_pt_atop==6'h31));

assert_never #(0) assert_atomic(
	.clk		(clk_i),
	.reset_n	(q_reset_n),
	.test_expr	(|assert_atomic_vec)
);

wire [6:0] assert_stash_vec;
assign assert_stash_vec[6] =   (w_pt_valid & ((w_pt_snoop==4'h8) | (w_pt_snoop==4'h9)|
                                              (w_pt_snoop==4'hc) |
                                              (w_pt_snoop==4'hd)) & ((CACHE>0) |
                                                                     (| w_pt_atop))) ;
assign assert_stash_vec[5] =   (w_pt_valid & w_pt_write & (w_pt_snoop==4'he) & 
                                                      ((CACHE>0) | (| w_pt_atop))) ;
assign assert_stash_vec[4] =   (n_wb_valid & ((n_wb_snoop==4'h8)|(n_wb_snoop==4'h9)|
                                              (n_wb_snoop==4'hc)|(n_wb_snoop==4'hd)|
                                              (n_wb_snoop==4'he))) ;
assign assert_stash_vec[3] =   (w_str_req_valid & q_oc_val[w_str_req_rid] &
                                              q_oc_write[w_str_req_rid] &
                                              ((t_oc_snoop[w_str_req_rid]==4'h8) |
                                               (t_oc_snoop[w_str_req_rid]==4'h9)) &
                                              (| (w_str_req_mpf1>>FIDW)));
//                             (w_str_req_valid & w_str_req_status[0] & 
//                                            q_oc_val[w_str_req_rid] & 
//                                            q_oc_write[w_str_req_rid] &
//                                            ((t_oc_snoop[w_str_req_rid]==4'h8) |
//                                             (t_oc_snoop[w_str_req_rid]==4'h9)) &
//                                            ~t_oc_stashniden[w_str_req_rid]) ;
assign assert_stash_vec[2] =   (w_pt_valid & w_pt_write & (w_pt_snoop==4'he)) ;
assign assert_stash_vec[1] =   ((ACE==0) & 
                                w_pt_valid & ~w_pt_write & (w_pt_snoop==4'he)) ;
assign assert_stash_vec[0] =   (w_pt_valid & w_pt_write & (w_pt_snoop==4'h9) &
                                             t_pt_partial);

assert_never #(0) assert_stash(
	.clk		(clk_i),
	.reset_n	(q_reset_n),
	.test_expr	(|assert_stash_vec)
);

wire [19:0] assert_od_vec;
assign assert_od_vec[19] =     (q_init_count > ODN) ;
assign assert_od_vec[18] =     (w_p0_valid & (~q_reset_n |
                                           ({(~|q_init_count), q_init_count}!=ODN))) ;
assign assert_od_vec[17] =     (w_co_valid & ~q_od_val[t_co_waddr>>BWL]) ; 
assign assert_od_vec[16] =     (n_sod_valid & ~q_od_val[n_sod_waddr>>BWL]) ;
assign assert_od_vec[15] =     (w_adw_valid & ~q_od_val[t_adw_waddr>>BWL]) ;
assign assert_od_vec[14] =     (n_odm_valid & ~q_od_val[n_odm_raddr>>BWL]) ;
assign assert_od_vec[13] =     (n_odr_valid & ~q_od_val[n_odr_raddr>>BWL] &
                                              ~n_odr_cmo) ;
assign assert_od_vec[12] =     (n_odf_valid & ~q_od_val[n_odf_raddr>>BWL]) ;
assign assert_od_vec[11] =     (cp2_wr_o & ~(q_od_val[q_oc_dptr[n_wq_oid]] |
                                             q_od_val[n_oc_dptr])) ;
assign assert_od_vec[10] =     ((CACHE>0) & w_pt_valid & ~w_pt_wake & ~t_pt_snp & 
                                            ~w_pt_write & ~n_od_ready & ~q_od_ready) ;
assign assert_od_vec[9]  =     ((CACHE>0) & w_pt_valid & ~t_pt_snp & (~| t_od_efree) &
                                                          ~n_od_ready & ~q_od_ready) ;
assign assert_od_vec[8]  =     (t_od_we & ~q_od_ready) ;
assign assert_od_vec[7]  =     ((| t_oc_alloc) & ((| t_oc_valloc) & w_c2_flush) &
                                                      (n_oc_dptr == t_od_eptr)) ;
assign assert_od_vec[6]  =     ((& q_od_val) & q_od_ready) ;
assign assert_od_vec[5]  =     (w_co_valid & ~q_oc_val[w_co_oid]) ;
assign assert_od_vec[4]  =     (n_sod_valid & ~q_oc_val[w_srd_oid]) ;
assign assert_od_vec[3]  =     (n_oms_valid & ~q_oc_val[w_srd_oid]) ;
assign assert_od_vec[2]  =     (n_odr_valid & ~q_oc_val[n_odr_oid]) ;
assign assert_od_vec[1]  =     (n_odf_valid & ~q_oc_val[n_odf_oid]) ;
assign assert_od_vec[0]  =     (cp2_wr_o & ~(q_oc_val[n_wq_oid] | 
                                             t_oc_alloc[n_wq_oid]));

assert_never #(0) assert_od(
	.clk		(clk_i),
	.reset_n	(q_reset_n),
	.test_expr	(|assert_od_vec)
);

assert_never_unknown #(0, MRCI+(DCEN+DMIN+DIIN+DVEN)*FIDW+
			  68+(3*(OCA+1))+STN+\=STE?(STA+1+1):0=\+ODA+1\=+2*cfgACE=\)assert_unknown_control(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.qualifier	(reset_ni),
	.test_expr	({ar_ready_o, aw_ready_o, dw_ready_o,
			  ar_valid_i, aw_valid_i, dw_valid_i,
			  dr_ready_i, pw_ready_i,
			  dr_valid_o, pw_valid_o,
			  ac_ready_i, cr_ready_o, cd_ready_o,
			  ac_valid_o, cr_valid_i, cd_valid_i,
\js if (cfgACE) {
			  rack_int, wack_int,
\js }
			  myid_i, dce_ids_i, dmi_ids_i, dii_ids_i, dve_ids_i,
			  amc_vals_i,
			  cmd_req_ready_i, dtr_req_tx_ready_i, dtw_req_ready_i, upd_req_ready_i,
			  cmd_req_valid_o, dtr_req_tx_valid_o, dtw_req_valid_o, upd_req_valid_o,
			  cmd_rsp_ready_o, dtr_rsp_rx_ready_o, dtw_rsp_ready_o, upd_rsp_ready_o,
			  cmd_rsp_valid_i, dtr_rsp_rx_valid_i, dtw_rsp_valid_i, upd_rsp_valid_i,
			  str_req_ready_o, dtr_req_rx_ready_o, snp_req_ready_o, cmp_rsp_ready_o,
			  str_req_valid_i, dtr_req_rx_valid_i, snp_req_valid_i, cmp_rsp_valid_i,
			  str_rsp_ready_i, dtr_rsp_tx_ready_i, snp_rsp_ready_i,
			  str_rsp_valid_o, dtr_rsp_tx_valid_o, snp_rsp_valid_o,
			  cfd_ready_i, cft_ready_i, ccd_ready_o, ccw_ready_i,
			  cfd_valid_o, cft_valid_o, ccd_valid_i, ccw_valid_o,
			  cce_ready_o,
			  cce_valid_i, 
			  cmr_init_i, cmr_ready_o, cmr_valid_i, cmr_done_o,
			  t_sv_starve,
			  t_ag_count, q_oc_rcount, q_oc_wcount, 
\js if (STE) {
			  t_st_val, t_st_count,
\js } // STE
			  t_pvc_count, q_init_count,t_ce_dtw_stall})
);

assert_never_unknown #(0, 24+(3*FIDW)) assert_unknown_amap(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.qualifier	(| amc_vals_i),
	.test_expr	({amc_fids_i, amc_tins_i, amc_errs_i, amc_order_i})
);

assert_never_unknown #(0, 20+(2*CTB)+WAYS) assert_cache_control(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.qualifier	(reset_ni),
	.test_expr	({ccp_init_o, ccp_ready_i, cp0_ready_i, cp0_valid_o,
			  cp2_rd_o, cp2_wr_o, cp2_update_o, cp2_busy_o,
			  cp2_nacks_i, cp2_valid_i, cfd_ready_i, cfd_valid_o,
			  cft_ready_i, cft_valid_o, ccd_ready_o, ccd_valid_i,
			  ccw_ready_i, ccw_valid_o, cce_ready_o, cce_valid_i})
);

wire [\=(STE>0)?15:14=\:0] assert_response_vec;
\js if (STE) {
assign assert_response_vec[15] =(dtw_rsp_valid_i & dtw_rsp_mid_i[\=Math.max(STA, OCA)=\] &
                                               ~t_st_val[(dtw_rsp_valid_i ? dtw_rsp_mid_i[0 +: STA] : \=STA=\'b0)]) ;
//                              (dtr_rsp_rx_valid_i & ~dtr_rsp_rx_mid_i[\=Math.max(OCA, STA)=\] &
//                                             ~t_st_val[(dtr_rsp_rx_valid_i ? dtr_rsp_rx_mid_i : \=MRRM=\'b0)]) ;
\js } // STE
assign assert_response_vec[14] =((CDW>1)&(| (t_oc_rack & ~(q_oc_val & ~q_oc_write)))) ;
assign assert_response_vec[13] =((CDW>1)&(| (t_oc_wack & ~(q_oc_val &  q_oc_write)))) ;
assign assert_response_vec[12] =((CDW>1)&(| ((t_oc_rack | t_oc_wack) & t_oc_evict))) ;
assign assert_response_vec[11] =(cmd_rsp_valid_i & ~q_oc_val[(cmd_rsp_valid_i ? cmd_rsp_mid_i : \=MRCM=\'b0)]) ;
assign assert_response_vec[10] =(dtr_rsp_rx_valid_i & dtr_rsp_rx_mid_i[\=Math.max(OCA, STA)=\] &
                                               ~q_oc_val[(dtr_rsp_rx_valid_i ? dtr_rsp_rx_mid_i[OCA-1:0] : \=MRRM=\'b0)]) ;
assign assert_response_vec[9]  =(dtw_rsp_valid_i & ~dtw_rsp_mid_i[\=Math.max(STA, OCA)=\] &
                                               ~q_oc_val[(dtw_rsp_valid_i ? dtw_rsp_mid_i[0 +: OCA] : \=MRWM=\'b0)]) ;
assign assert_response_vec[8]  =(upd_rsp_valid_i & ~q_oc_val[(upd_rsp_valid_i ? upd_rsp_mid_i : \=MRUM=\'b0)]) ;
assign assert_response_vec[7]  =(cmd_rsp_valid_i & ~q_oc_wfresp[(cmd_rsp_valid_i ? cmd_rsp_mid_i : \=MRCM=\'b0)]) ;
assign assert_response_vec[6]  =(upd_rsp_valid_i & ~q_oc_wfresp[(upd_rsp_valid_i ? upd_rsp_mid_i : \=MRUM=\'b0)]) ;
//                              (cmd_rsp_valid_i & t_oc_evict[(cmd_rsp_valid_i ? cmd_rsp_mid_i : \=MRCM=\'b0)]) ;
assign assert_response_vec[5]  =(upd_rsp_valid_i & ~t_oc_evict[(upd_rsp_valid_i ? upd_rsp_mid_i : \=MRUM=\'b0)] &
                                               ~t_oc_wrbk[(upd_rsp_valid_i ? upd_rsp_mid_i : \=MRUM=\'b0)]) ;
assign assert_response_vec[4]  =(cmd_rsp_valid_i & (cmd_rsp_mid_i>OCN)) ;
//                              (dtr_rsp_rx_valid_i & ~dtr_rsp_rx_mid_i[\=Math.max(OCA, STA)=\] &
//                                             (dtr_rsp_rx_mid_i>STN)) ;
assign assert_response_vec[3]  =(dtr_rsp_rx_valid_i & dtr_rsp_rx_mid_i[\=Math.max(OCA, STA)=\] &
                                              (dtr_rsp_rx_mid_i[0+:\=Math.max(OCA, STA)=\]>OCN));
assign assert_response_vec[2]  =(upd_rsp_valid_i & (upd_rsp_mid_i>OCN)) ;
//                              (cmd_rsp_valid_i & (cmd_rsp_mid_i[MRCM-1:3]>3'h3)) ;
//                              (dtr_rsp_rx_valid_i & (dtr_rsp_rx_mid_i[MRRM-1:3]!=3'h6)) ;
//                              (dtw_rsp_valid_i & ((dtw_rsp_mid_i[MRWM-1:3]!=3'h5) |
//                                              (dtw_rsp_mid_i[MRWM-1:3]!=3'h4))) ;
//                              (upd_rsp_valid_i & (upd_rsp_mid_i[MRUM-1:3]>3'h3)) ;
assign assert_response_vec[1]  =(dtw_rsp_valid_i & ~dtw_rsp_mid_i[\=Math.max(STA, OCA)=\] &
                                               (dtw_rsp_mid_i > OCN)) ;
assign assert_response_vec[0]  =(dtw_rsp_valid_i & dtw_rsp_mid_i[\=Math.max(STA, OCA)=\] &
                                              (dtw_rsp_mid_i[0+:\=Math.max(STA, OCA)=\]>STN));

assert_never #(0) assert_response(
	.clk		(clk_i & ~a_error_test),
	.reset_n	(reset_ni),
	.test_expr	(|assert_response_vec)
);

assert_never_unknown #(0, (AXKW+RUW+IW+ARPW+1+DW)) assert_unknown_resp(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.qualifier	(dr_valid_o),
	.test_expr	({dr_track_o, dr_user_o, dr_id_o, dr_resp_o, 
			  dr_last_o, dr_rdata_o})
);
assert_never_unknown #(0, (8+MRCM)) assert_unknown_cmd_rsp(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.qualifier	(cmd_rsp_valid_i),
	.test_expr	(cmd_rsp_valid_i ? {cmd_rsp_status_i, cmd_rsp_mid_i} : \=8+MRCM=\'b0)
);
assert_never_unknown #(0, (24+MRRM)) assert_unknown_dtr_rsp_rx(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.qualifier	(dtr_rsp_rx_valid_i),
	.test_expr	(dtr_rsp_rx_valid_i ? {dtr_rsp_rx_status_i, dtr_rsp_rx_mid_i, dtr_rsp_rx_attr_i} : \=24+MRRM=\'b0)
);
assert_never_unknown #(0, (24+MRWM)) assert_unknown_dtw_rsp(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.qualifier	(dtw_rsp_valid_i),
	.test_expr	(dtw_rsp_valid_i ? {dtw_rsp_status_i, dtw_rsp_mid_i, dtw_rsp_attr_i} : \=24+MRWM=\'b0)
);
assert_never_unknown #(0, (8+MRUM)) assert_unknown_upd_rsp(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.qualifier	(upd_rsp_valid_i),
	.test_expr	(upd_rsp_valid_i ? {upd_rsp_status_i, upd_rsp_mid_i} : \=8+MRUM=\'b0)
);
assert_never_unknown #(0, 18+SRCI+SRCM+SRCR+SRCB+SRC1+SRC2) assert_unknown_str_req(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.qualifier	(str_req_valid_i),
	.test_expr	(str_req_valid_i ? {str_req_iid_i, str_req_mid_i, str_req_rid_i, str_req_isize_i,
			  str_req_bid_i, str_req_cmd_i, str_req_status_i, 
			  str_req_mpf1_i, str_req_mpf2_i} : \=18+SRCI+SRCM+SRCR+SRCB+SRC1+SRC2=\'b0)
);
assert_never_unknown #(0, 25+SRRP+SRRI+SRRM+
			     SRRR+SRRD+SRRB+SRRZ) assert_unknown_dtr_req_rx(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.qualifier	(dtr_req_rx_valid_i),
	.test_expr	(dtr_req_rx_valid_i ? {dtr_req_rx_last_i, dtr_req_rx_cmd_i, dtr_req_rx_iid_i, dtr_req_rx_mid_i,
			  dtr_req_rx_rid_i, dtr_req_rx_dbad_i, dtr_req_rx_data_i, dtr_req_rx_be_i, 
			  dtr_req_rx_pri_i, dtr_req_rx_attr_i} : \=25+SRRP+SRRI+SRRM+SRRR+SRRD+SRRB+SRRZ=\'b0)
);
assert_never_unknown #(0, 18+SRNM+SRNI+SRNA+SRN1+SRN2+SRN3+
			  SRND+SRNF) assert_unknown_snp_req(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.qualifier	(snp_req_valid_i),
	.test_expr	(snp_req_valid_i ? {snp_req_cmd_i, snp_req_mid_i, snp_req_iid_i, snp_req_addr_i, 
			  snp_req_attr_i, snp_req_mpf1_i, snp_req_mpf2_i, snp_req_mpf3_i,
			  snp_req_did_i, snp_req_tof_i} : \=18+SRNM+SRNI+SRNA+SRN1+SRN2+SRN3+SRND+SRNF=\'b0)
);

assert_never_unknown #(0, OCA) assert_unknown_ocptr(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.qualifier	(q_oc_ready),
	.test_expr	(q_oc_wptr)
);
assert_never_unknown #(0, OLA) assert_unknown_olptr(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.qualifier	(q_od_ready),
	.test_expr	(q_od_wptr)
);

wire [OCN-1:0] q_oc_wake_alt;
wire [OCN-1:0] q_oc_wake_alt_ns;

assert_never #(0) assert_wake(
        .clk            (clk_i),
        .reset_n        (reset_ni & ~a_error_test),
        .test_expr      (q_oc_wake!=q_oc_wake_alt)
);

wire [OCA:0] q_oc_count_alt;
wire [OCA:0] q_oc_count_alt_ns = q_oc_rcount_next + q_oc_wcount_next + q_oc_ecount_next;
\=u.dffre(OCA+1, `q_oc_count_alt`, `q_oc_count_alt_ns`, `{`+(OCA+1)+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\
assert_never #(0) assert_count(
        .clk            (clk_i),
        .reset_n        (reset_ni),
        .test_expr      (q_oc_count!=q_oc_count_alt)
);

wire [OCN-1:0]	g_oc_ablock, g_oc_iblock, g_oc_stash;
wire [OCN-1:0] q_oc_iptr_eq_alt;
wire [OCN-1:0] q_oc_iptr_eq_alt_ns;

assert_never #(0) assert_iptr_eq(
        .clk            (clk_i),
        .reset_n        (reset_ni & ~a_error_test),
        .test_expr      ((q_oc_iptr_eq&q_oc_val)!=(q_oc_iptr_eq_alt&q_oc_val))
);

\js for (let i=0; i<OCN; i=i+1) {

\js if (owo) {

wire [6:0] assert_owo_vec\=i=\;
assign assert_owo_vec\=i=\[6]  = (q_oc_tin_ns[\=i=\] != q_oc_tin_ns_alt[\=i=\]) & 1'b0;
assign assert_owo_vec\=i=\[5]  = (same_dii\=i=\ != same_dii_alt\=i=\) & (|t_oc_ihit);
assign assert_owo_vec\=i=\[4]  = (differant_dii\=i=\ != differant_dii_alt\=i=\) & (|t_oc_ihit);
assign assert_owo_vec\=i=\[3]  = (q_oc_wake_persist[\=i=\] != q_oc_wake_persist_alt\=i=\);
assign assert_owo_vec\=i=\[2]  = (sending_writeback_\=i=\ != sending_writeback_alt_\=i=\);
assign assert_owo_vec\=i=\[1]  = (q_oc_phase\=i=\ != q_oc_phase_alt\=i=\);
assign assert_owo_vec\=i=\[0]  = (q_oc_oldest\=i=\ != q_oc_oldest_alt\=i=\);

assert_never #(0) assert_owo\=i=\(
        .clk            (clk_i),
        .reset_n        (reset_ni),
        .test_expr      (|assert_owo_vec\=i=\)
);

\js }

assign g_oc_ablock[\=i=\] = q_oc_val[\=i=\] & (q_oc_aptr[\=i=\]!=\=OCA=\'d\=i=\);
assign g_oc_iblock[\=i=\] = q_oc_val[\=i=\] & (q_oc_iptr[\=i=\]!=\=OCA=\'d\=i=\);
assign g_oc_stash[\=i=\] = q_oc_val[\=i=\] & q_oc_write[\=i=\] & ((t_oc_snoop[\=i=\]==4'h8)|
						      (t_oc_snoop[\=i=\]==4'h9));

  wire q_oc_wake_alt\=i=\;
  assign q_oc_wake_alt[\=i=\] = q_oc_wake_alt\=i=\;
  assign q_oc_wake_alt_ns[\=i=\] = t_oc_alloc[\=i=\] ? 1'b0 & w_c2_retry & ~t_c2_cancel : (t_oc_alloc[\=i=\] | t_oc_valloc[\=i=\] | (w_upd_req_obv[\=i=\] & w_upd_req0_ready) | (q_oc_val[\=i=\] & q_oc_wake[\=i=\] & n_poc_valid & w_poc_ready & (n_poc_obv[\=i=\]))) ? 1'b0 : (((q_oc_val[\=i=\] & ~t_oc_dealloc[\=i=\] & (q_oc_iptr[\=i=\]==\=OCA=\'d\=i=\) & (q_oc_write[\=i=\] ? q_oc_wfstp[\=i=\] : 1'b1) & t_oc_chit[\=i=\] & (q_oc_aptr[\=i=\] == \=OCA=\'d\=i=\)) | (q_oc_val[\=i=\] & ~t_oc_dealloc[\=i=\] & t_oc_skid[\=i=\] & t_oc_kok_in[\=i=\]) | t_oc_catope[\=i=\] | (q_oc_val[\=i=\] & ~t_oc_dealloc[\=i=\] & t_oc_dve[\=i=\] & (q_oc_aptr[\=i=\] != \=OCA=\'d\=i=\) & ~q_oc_wrap[q_oc_aptr[\=i=\]]) | (q_oc_val[\=i=\] & ~t_oc_dealloc[\=i=\] & ~q_oc_wfstp[q_oc_aptr[\=i=\]] & ~t_oc_wfcwd[q_oc_aptr[\=i=\]] & (~t_oc_evict[q_oc_aptr[\=i=\]] | ~q_oc_wfresp[q_oc_aptr[\=i=\]]) & (q_oc_aptr[\=i=\] != \=OCA=\'d\=i=\)))) ? 1'b1 : q_oc_wake[\=i=\];
  \=u.dffre(1, `q_oc_wake_alt`+i, `q_oc_wake_alt_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

wire q_oc_iptr_eq_alt\=i=\;
assign q_oc_iptr_eq_alt[\=i=\] = q_oc_iptr_eq_alt\=i=\;
assign q_oc_iptr_eq_alt_ns[\=i=\] = (q_oc_iptr_next[\=i=\] == \=OCA=\'d\=i=\);
\=u.dffre(1, `q_oc_iptr_eq_alt`+i, `q_oc_iptr_eq_alt_ns[`+i+`]`, `{1{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

wire [29:0] assert_oclist_vec\=i=\;
assign assert_oclist_vec\=i=\[29] = (t_oc_alloc[\=i=\] & q_oc_val[\=i=\]) ;
assign assert_oclist_vec\=i=\[28] = (t_od_alloc[\=i=\] & q_od_val[\=i=\]) ;
assign assert_oclist_vec\=i=\[27] = (t_oc_dealloc[\=i=\] & ~q_oc_val[\=i=\]) ;
assign assert_oclist_vec\=i=\[26] = (t_oc_dealloc[\=i=\] & t_oc_wfcwd[\=i=\]) ;
assign assert_oclist_vec\=i=\[25] = (t_oc_dealloc[\=i=\] & q_oc_wfodr[\=i=\]) ;
assign assert_oclist_vec\=i=\[24] = (t_od_dealloc[\=i=\] & ~q_od_val[\=i=\]) ;
assign assert_oclist_vec\=i=\[23] = (t_oc_dealloc[\=i=\] & q_oc_dval[\=i=\]) ;
assign assert_oclist_vec\=i=\[22] = (q_oc_val[\=i=\] & q_oc_dval[\=i=\] & ~q_od_val[q_oc_dptr[\=i=\]]);
assign assert_oclist_vec\=i=\[21] = (q_oc_val[\=i=\] & ~q_oc_write[\=i=\] & t_oc_wfcwd[\=i=\]);
assign assert_oclist_vec\=i=\[20] = (q_oc_val[\=i=\] & ~q_oc_val[q_oc_aptr[\=i=\]]);
assign assert_oclist_vec\=i=\[19] = (q_oc_val[\=i=\] & t_oc_cmr[\=i=\] & ~t_oc_evict[\=i=\]);
assign assert_oclist_vec\=i=\[18] = (~t_cfg_ahit & ~t_oc_dve[\=i=\] & ~t_oc_dvm[\=i=\] & q_oc_val[\=i=\] & (q_oc_addr[q_oc_aptr[\=i=\]][AW-1:CLO] != q_oc_addr[\=i=\][AW-1:CLO]));
assign assert_oclist_vec\=i=\[17] = (q_oc_val[\=i=\] & ~q_oc_val[q_oc_iptr[\=i=\]]);
assign assert_oclist_vec\=i=\[16] = (~t_cfg_ihit & ~t_oc_evict[\=i=\] & ~t_oc_dve[\=i=\] & ~t_oc_dvm[\=i=\] & q_oc_val[\=i=\] & (q_oc_id[q_oc_iptr[\=i=\]] != q_oc_id[\=i=\]));
assign assert_oclist_vec\=i=\[15] = (q_oc_val[\=i=\] & (t_oc_evict[\=i=\] ^ t_oc_evict[q_oc_iptr[\=i=\]]));
assign assert_oclist_vec\=i=\[14] = (q_oc_val[\=i=\] & ~q_od_val[q_oc_dptr[\=i=\]] & (q_oc_aptr[\=i=\] != \=OCA=\'d\=i=\) & ~a_error_test);
assign assert_oclist_vec\=i=\[13] = (q_oc_val[\=i=\] & ~q_od_val[q_oc_dptr[\=i=\]] & ~t_oc_evict[\=i=\] & ((q_oc_wfa[\=i=\] & ~q_oc_write[\=i=\]) | q_oc_wfstr[\=i=\]));
assign assert_oclist_vec\=i=\[12] = (q_oc_val[\=i=\] & ~q_oc_write[\=i=\] & q_oc_wfadw[\=i=\]);
assign assert_oclist_vec\=i=\[11] = (n_odr_adone & n_odr_obv[\=i=\] & (q_oc_iptr[\=i=\] != \=OCA=\'d\=i=\));
assign assert_oclist_vec\=i=\[10] = (w_upd_req_obv[\=i=\] & ~(q_oc_val[\=i=\] & (t_oc_evict[\=i=\] | t_oc_wrbk[\=i=\]) & q_oc_wfa[\=i=\] & ~q_oc_wfresp[\=i=\] & ~q_oc_wfdtw[\=i=\] & ~q_oc_wfdtp[\=i=\]));
assign assert_oclist_vec\=i=\[9]  = (n_ppvc_obv[\=i=\] & (~q_oc_val[\=i=\] | ~t_oc_evict[\=i=\] | ~q_oc_wrap[\=i=\]));
assign assert_oclist_vec\=i=\[8]  = (q_oc_val[\=i=\] & q_oc_wfdtw[\=i=\] & q_oc_wfadw[\=i=\]);
assign assert_oclist_vec\=i=\[7]  = (q_oc_val[\=i=\] & (q_oc_aptr[\=i=\] != \=OCA=\'d\=i=\) & ~t_oc_evict[q_oc_aptr[\=i=\]] & q_oc_atail[q_oc_aptr[\=i=\]]) ;
assign assert_oclist_vec\=i=\[6]  = (q_oc_val[\=i=\] & (q_oc_iptr[\=i=\] != \=OCA=\'d\=i=\) & ~t_oc_evict[q_oc_iptr[\=i=\]] & q_oc_itail[q_oc_iptr[\=i=\]]) ;
//			            (q_oc_val[\=i=\] & t_oc_evict[\=i=\] & (q_oc_aptr[\=i=\]!=\=OCA=\'d\=i=\)) ;
//			            (t_oc_dve[\=i=\] & ~t_oc_dve[q_oc_aptr[\=i=\]] & ~t_oc_dvm[q_oc_aptr[\=i=\]]) ; // Not Using APTR anymore for DVE
assign assert_oclist_vec\=i=\[5]  = (t_oc_dve[\=i=\] & q_oc_partial[\=i=\] & ~t_oc_dve[q_oc_iptr[\=i=\]] & ~t_oc_dvm[q_oc_iptr[\=i=\]]) ;
//			            (q_oc_val[\=i=\] & ~t_oc_dve[\=i=\] & ~t_oc_dvm[\=i=\] & t_oc_dve[q_oc_aptr[\=i=\]]) ; // Not Using APTR anymore for DVE
assign assert_oclist_vec\=i=\[4]  = (w_dtr_rsp_rx_valid_mod & w_dtr_rsp_rx_mid[\=Math.max(OCA, STA)=\] & ~a_error_test & (w_dtr_rsp_rx_mid[OCA-1:0]==\=OCA=\'d\=i=\) & (~q_oc_val[\=i=\] | ~q_oc_wfdtp[\=i=\])) ;
assign assert_oclist_vec\=i=\[3]  = (w_dtw_rsp_valid & ~w_dtw_rsp_mid[\=Math.max(OCA, STA)=\] & ~a_error_test & (w_dtw_rsp_mid[OCA-1:0]==\=OCA=\'d\=i=\) & (~q_oc_val[\=i=\] | ~q_oc_wfdtp[\=i=\]));
assign assert_oclist_vec\=i=\[2]  = (w_dtw_rsp_valid & ~w_dtw_rsp_mid[\=Math.max(OCA, STA)=\] & (w_dtw_rsp_mid[OCA-1:0]==\=OCA=\'d\=i=\) & w_dtr_rsp_rx_valid_mod & w_dtr_rsp_rx_mid[\=Math.max(OCA, STA)=\] & ~a_error_test &
					(w_dtr_rsp_rx_mid[OCA-1:0]==\=OCA=\'d\=i=\)) ;
assign assert_oclist_vec\=i=\[1]  = (q_oc_val[\=i=\] & q_oc_wfa[\=i=\] & ~q_oc_write[\=i=\] & ~t_oc_evict[\=i=\] & ~q_od_val[q_oc_dptr[\=i=\]]) ;
assign assert_oclist_vec\=i=\[0]  = (~t_cfg_ihit & ~t_oc_evict[\=i=\] & ~t_oc_dve[\=i=\] & ~t_oc_dvm[\=i=\] & q_oc_val[\=i=\] & (q_oc_id[q_oc_iptr[\=i=\]] != q_oc_id[\=i=\]));

assert_never #(0) assert_oclist\=i=\(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	(|assert_oclist_vec\=i=\)
);

wire [8:0] assert_cache_vec\=i=\;
assign assert_cache_vec\=i=\[8] =   (t_oc_valloc[\=i=\] & q_oc_val[\=i=\]) ;
assign assert_cache_vec\=i=\[7] =   (w_c2_done & (q_oc_iptr[\=i=\] != \=OCA=\'d\=i=\) & 
                                           (w_pt_wake ? (w_pt_kid==\=XTA=\'d\=i=\) : (| t_oc_ihit))) ;
assign assert_cache_vec\=i=\[6] =   ((& cp2_busy_o) & w_c2_chit) ;
assign assert_cache_vec\=i=\[5] =   (w_c2_flush & (t_od_eptr==w_od_dptr) & w_od_wready &  
                                                                (w_od_dptr != n_od_wptr)) ;
assign assert_cache_vec\=i=\[4] =   (w_c2_flush & (t_od_eptr==q_od_wptr) & q_od_ready & 
                                                              ~w_pt_write & ~w_pt_wake) ; 
assign assert_cache_vec\=i=\[3] =   (w_c2_flush & ~w_pt_write & ~w_pt_wake & ~w_pt_cmr[1] &
                                                               (ioaiu_sum(t_od_alloc)<2));
assign assert_cache_vec\=i=\[2] =   (w_c2_flush & ~w_pt_write & w_pt_wake &
                                                               (ioaiu_sum(t_od_alloc)<1));
assign assert_cache_vec\=i=\[1] =   (w_c2_flush & w_pt_write & (ioaiu_sum(t_od_alloc)<1)) ;
assign assert_cache_vec\=i=\[0] =   (q_oc_val[\=i=\] & t_oc_evict[\=i=\] & ~q_oc_wfdtw[\=i=\] & 
                                                   ~q_oc_wfdtp[\=i=\] & (q_oc_iptr[\=i=\] != \=OCA=\'d\=i=\));

assert_never #(0) assert_cache\=i=\(
	.clk		(clk_i & ~a_error_test),
	.reset_n	(reset_ni),
	.test_expr	(|assert_cache_vec\=i=\)
);

assert_never_unknown #(0, 3) assert_unknown_ocval\=i=\(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.qualifier	(reset_ni),
	.test_expr	({q_oc_val[\=i=\], q_oc_ready, q_od_ready})
);
assert_never_unknown #(0, SRCB+41+IW+SRCM+SRCI+(2*OCA)+MW+SW+MW+AWTW+TINW+3+
			  BWL+AW+OLA+2+5) assert_unknown_ocstate\=i=\(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.qualifier	(q_oc_val[\=i=\]),
	.test_expr	({q_oc_bid[\=i=\], q_oc_dval[\=i=\], q_oc_order[\=i=\],
			  q_oc_status[\=i=\], q_oc_size[\=i=\], q_oc_cache[\=i=\], 
			  q_oc_eob[\=i=\], q_oc_itail[\=i=\], q_oc_dce[\=i=\],
			  q_oc_atail[\=i=\], q_oc_wfresp[\=i=\], q_oc_wfstr[\=i=\], 
			  q_oc_wfdtr[\=i=\], q_oc_wfstp[\=i=\], q_oc_wfa[\=i=\], 
			  q_oc_wfdtw[\=i=\], q_oc_line[\=i=\], t_oc_svok[\=i=\],
			  q_oc_partial[\=i=\], t_oc_wfcfd[\=i=\], t_oc_wfcft[\=i=\],
			  q_oc_wfdtp[\=i=\], q_oc_wake[\=i=\], //q_oc_coal[\=i=\], 
			  q_oc_wrap[\=i=\], q_oc_write[\=i=\], q_oc_wfadw[\=i=\],
			  t_oc_wfcwd[\=i=\], t_oc_skid[\=i=\], t_oc_kok[\=i=\], 
			  q_oc_id[\=i=\], q_oc_mid[\=i=\], q_oc_iid[\=i=\], q_oc_wfodr[\=i=\],
			  q_oc_iptr[\=i=\], q_oc_aptr[\=i=\],
			  t_oc_domain[\=i=\][MW-1:0], t_oc_snoop[\=i=\][SW-1:0], t_oc_bar[\=i=\], 
			  t_oc_atop[\=i=\], q_oc_tin[\=i=\], q_oc_beats[\=i=\], 
			  q_oc_addr[\=i=\], q_oc_dptr[\=i=\], t_oc_aresp[\=i=\]})
);

wire [2:0] assert_ocskid_vec\=i=\;
assign assert_ocskid_vec\=i=\[2] = (q_oc_val[\=i=\] & q_oc_wake[\=i=\] & (q_oc_aptr[\=i=\] != \=OCA=\'d\=i=\)) ;
assign assert_ocskid_vec\=i=\[1] = (q_oc_val[\=i=\] & t_oc_skid[\=i=\] & t_oc_evict[\=i=\]);

\jsbegin
// No owo on 3.7.0
    if (owo) { \jsend
assign assert_ocskid_vec\=i=\[0] = 1'b0;
\js } else {
assign assert_ocskid_vec\=i=\[0] = (q_oc_val[\=i=\] & q_oc_wake[\=i=\] & t_oc_skid[\=i=\]);
\js }

assert_never #(0) assert_ocskid\=i=\(
	.clk		(clk_i),
	.reset_n	(q_reset_n),
	.test_expr	(|assert_ocskid_vec\=i=\)
);

\js }

wire [\=(STE>0)?15:11=\:0] assert_state_vec;
\js if (STE) {
assign assert_state_vec[15] = (t_ce_dtr & t_ce_dtw & (CDW<=1) & 
                                         (t_st_cmd[w_cs_sid] != SnpNITCCI)) ;
assign assert_state_vec[14] = (w_p2_valid & (~| t_oc_count) & (~| t_st_count) &
                                                              ~w_pt_cmr[1]) ;
assign assert_state_vec[13] = ((~| q_oc_val) & (~| t_st_val) & (| q_dtw_req_count)) ;
//                            ((| q_dtr_req_tx_count) & (~| t_st_val) & (~| g_oc_stash)) ;
assign assert_state_vec[12] = ((| q_dtw_req_count) & (~| t_oc_count) & (~| t_st_val));
\js } // STE
assign assert_state_vec[11] = ((| t_oc_count) & (~| q_oc_val) & ~w_rr_valid &
                                                ~w_p1_valid & ~w_p2_valid) ;
assign assert_state_vec[10] = ((~| t_oc_count & ~t_oc_einc) & (| q_oc_val)) ;
//                            (~w_p0_valid & ~w_p1_valid & ~w_p2_valid &
//                                           ~w_rr_valid &
//                               ((t_oc_count != ioaiu_sum(q_oc_val)) |
//                                (t_oc_ecount != ioaiu_sum(q_oc_val & t_oc_evict)) |
//                                (q_oc_rcount != ioaiu_sum(q_oc_val & ~q_oc_write &
//                                                                  ~t_oc_evict)) |
//                                (q_oc_wcount != ioaiu_sum(q_oc_val & q_oc_write &
//                                                                  ~t_oc_evict)))) ;
assign assert_state_vec[9] = ((~| q_oc_val) & ((| q_cmd_req_count) | (| q_upd_req_count) |
                                                (| q_srd_count) | (| q_odr_count) |
                                                (| q_odf_count) | q_srd_bypass)) ;
assign assert_state_vec[8]  = ((| g_oc_stash) & (AWSE==0)) ;
assign assert_state_vec[7]  = (w_c2_evict & (t_oc_count == OCN)) ;
assign assert_state_vec[6]  = (w_c2_evict & (n_oc_eptr == q_oc_wptr) &
                                            (t_oc_count != (OCN-1))) ;
assign assert_state_vec[5]  = (n_ce_valid & w_ce_evict & (~| t_oc_ce)) ;
assign assert_state_vec[4]  = (| (t_oc_valloc & t_oc_alloc)) ;
assign assert_state_vec[3]  = (| (t_oc_valloc & t_oc_update)) ;
assign assert_state_vec[2]  = (| (t_oc_alloc & t_oc_update)) ;
assign assert_state_vec[1]  = ((| q_cmd_req_count) & (~| t_oc_count)) ;
assign assert_state_vec[0]  = ((| q_upd_req_count) & (~| t_oc_count)) ;

assert_never #(0) assert_state(
	.clk		(clk_i),
	.reset_n	(reset_ni & ~a_error_test),
	.test_expr	(|assert_state_vec)
);

// CONC-8789 Evictions without flush arent considered in the itail chain. (q_oc_evict & q_oc_val). But does have to happen in flush case which is a hole for this assert.
wire [6:0] assert_skid_vec;
assign assert_skid_vec[6] = (w_pt_valid & ~w_pt_wake & ~t_pt_snp & (~|t_oc_alloc) &
                                                                   ~w_pt_cmr[1]) ;
assign assert_skid_vec[5] = ((| (q_oc_val & ~t_oc_evict)) & ((~| q_oc_itail) | (~| q_oc_atail))) ;
assign assert_skid_vec[4] = (w_pt_valid & w_pt_wake & t_oc_skid[w_pt_kid]) ;
assign assert_skid_vec[3] = (w_poc_valid & t_oc_skid[w_poc_oid]) ;
assign assert_skid_vec[2] = (ioaiu_sum(n_cmd_req0_incs) > 1) ;
//                          (n_dtw_req0_valid & (q_oc_tid[w_of_oid] !=
//                                 (q_oc_tin[w_of_oid][TINW+1] ?
//                             dii_ids_i[q_oc_tin[w_of_oid][0+:TINW]*FIDW +: FIDW] :
//                             dmi_ids_i[q_oc_tin[w_of_oid][0+:TINW]*FIDW +: FIDW])));
assign assert_skid_vec[1] = (| (q_oc_val & t_oc_evict & t_oc_skid)) ;
// Bug 10128                ((| t_oc_alloc) & t_pt_skid & ~t_pt_dce & ~t_pt_dmi & ~t_pt_dii & ~t_pt_dve) |
//                          (w_pt_valid & ~n_pt_ready) ;
assign assert_skid_vec[0] = (n_cmd_req0_valid & ~t_pt_ok);

assert_never #(0) assert_skid(
	.clk		(clk_i),
	.reset_n	(q_reset_n),
	.test_expr	(|assert_skid_vec)
);

\js if (STE) {
wire [4:0] assert_dvm_vec;
assign assert_dvm_vec[4]=(ioaiu_sum(t_st_hits)>1) ;
assign assert_dvm_vec[3]=(w_cmq_valid & (~t_st_val[w_cmq_sid] |
                                         (t_st_cmd[w_cmq_sid] != SnpDvmMsg))) ;
assign assert_dvm_vec[2]=(w_cdq_valid & (t_st_cmd[w_cdq_sid]==SnpDvmMsg)) ;
assign assert_dvm_vec[1]=(t_pt_dvm & ~w_cmq_valid) ;
assign assert_dvm_vec[0]=(t_pt_dvm & w_pt_wake);

assert_never #(0) assert_dvm(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	(|assert_dvm_vec)
);

\js for (let i=0; i<STN; i=i+1) {
assert_never_unknown #(0, AW+SRCI+SRCM+SRCB+SRNP+STA+24) assert_unknown_st\=i=\(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.qualifier	(t_st_val[\=i=\]),
	.test_expr	({t_st_cmd[\=i=\], t_st_pri[\=i=\], t_st_mid[\=i=\], 
			  t_st_bid[\=i=\], t_st_isize[\=i=\], t_st_ptr[\=i=\],
			  t_st_wfdrp[\=i=\], t_st_wfdwp[\=i=\], t_st_chit[\=i=\], 
			  t_st_iid[\=i=\], t_st_sleep[\=i=\], t_st_wfac[\=i=\], 
			  t_st_wfcr[\=i=\], t_st_wfcmp[\=i=\], t_st_up[\=i=\],
			  t_st_addr[\=i=\], t_st_pr[\=i=\], t_st_security[\=i=\], 
			  t_st_trace[\=i=\], t_st_wake[\=i=\], w_st_ready})
);
\js }
\js } // STE

assert_zero_one_hot #(0, OCN) assert_oce(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	(t_oc_ce)
);
assert_zero_one_hot #(0, OCN) assert_ocihit(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	({OCN{w_p2_valid}} & t_oc_ihit)
);
assert_zero_one_hot #(0, OCN) assert_ocahitr(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	({OCN{w_p2_valid}} & t_oc_ahitr)
);
assert_zero_one_hot #(0, OCN) assert_ocahite(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	({OCN{w_p2_valid}} & t_oc_ahite)
);
//assert_zero_one_hot #(0, OCN) assert_oclhit(
//	.clk		(clk_i),
//	.reset_n	(reset_ni),
//	.test_expr	(t_oc_lhit)
//);
assert_zero_one_hot #(0, WAYS) assert_cachehit(
	.clk		(clk_i),
	.reset_n	(reset_ni & ~w_pt_cmr[1] & ~t_pt_err),
	.test_expr	({WAYS{cp2_valid_i & (~| cp2_nacks_i[3:2])}} & 
			 cp2_hits_i)
);

assert_no_overflow #(0, 8) assert_over_interleaved_count(
        .clk            (clk_i),
        .reset_n        (reset_ni & ~a_error_test ),
        .test_expr      (interleaved_count_o)
);
assert_no_underflow #(0,8) assert_under_interleaved_count(
        .clk            (clk_i),
        .reset_n        (reset_ni & ~a_error_test),
        .test_expr      (interleaved_count_o)
);
\js if (STE) {
assert_no_overflow #(0, STA+1) assert_over_st_count(
	.clk		(clk_i),
	.reset_n	(reset_ni & ~a_error_test ),
	.test_expr	(t_st_count)
);
assert_no_underflow #(0, STA+1) assert_under_st_count(
	.clk		(clk_i),
	.reset_n	(reset_ni & ~a_error_test),
	.test_expr	(t_st_count)
);
\js } // STE
assert_no_overflow #(0, 8) assert_over_cmd_req_count(
	.clk		(clk_i),
	.reset_n	(reset_ni & ~a_error_test),
	.test_expr	(q_cmd_req_count)
);
assert_no_underflow #(0, 8) assert_under_cmd_req_count(
	.clk		(clk_i),
	.reset_n	(reset_ni & ~a_error_test),
	.test_expr	(q_cmd_req_count)
);
assert_no_overflow #(0, 8) assert_over_dtr_req_tx_count(
	.clk		(clk_i),
	.reset_n	(reset_ni & ~a_error_test),
	.test_expr	(q_dtr_req_tx_count)
);
assert_no_underflow #(0, 8) assert_under_dtr_req_tx_count(
	.clk		(clk_i),
	.reset_n	(reset_ni & ~a_error_test),
	.test_expr	(q_dtr_req_tx_count)
);
assert_no_overflow #(0, 8) assert_over_dtw_req_count(
	.clk		(clk_i),
	.reset_n	(reset_ni & ~a_error_test),
	.test_expr	(q_dtw_req_count)
);
assert_no_underflow #(0, 8) assert_under_dtw_req_count(
	.clk		(clk_i),
	.reset_n	(reset_ni & ~a_error_test),
	.test_expr	(q_dtw_req_count)
);
assert_no_overflow #(0, 8) assert_over_upd_req_count(
	.clk		(clk_i),
	.reset_n	(reset_ni & ~a_error_test),
	.test_expr	(q_upd_req_count)
);
assert_no_underflow #(0, 8) assert_under_upd_req_count(
	.clk		(clk_i),
	.reset_n	(reset_ni & ~a_error_test),
	.test_expr	(q_upd_req_count)
);
assert_no_overflow #(0, OCA+1) assert_over_oc_rcount(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	(q_oc_rcount)
);
assert_no_underflow #(0, OCA+1) assert_under_oc_rcount(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	(q_oc_rcount)
);
assert_no_overflow #(0, OCA+1) assert_over_oc_wcount(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	(q_oc_wcount)
);
assert_no_underflow #(0, OCA+1) assert_under_oc_wcount(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	(q_oc_wcount)
);

assert_never #(0) assert_write_4439(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	(w_c2_valid & cp2_wr_o & (cp2_cstate_i != CST_UC) &
						 (cp2_cstate_i != CST_UD) &
                                                ~w_amc_nc &
				(w_pt_wake ? q_oc_wfstr[w_pt_kid] : 1'b1))
);

wire [8:0] assert_error_vec;
assign assert_error_vec[8] = t_pt_uerr ;
assign assert_error_vec[7] = (w_cmd_rsp_ready & cmd_rsp_valid_i & q_reset_n &
                                            (cmd_rsp_tid_i!=myid_i)) ;
assign assert_error_vec[6] = (w_dtr_rsp_rx_ready & dtr_rsp_rx_valid_i & q_reset_n &
                                            (dtr_rsp_rx_tid_i!=myid_i)) ;
assign assert_error_vec[5] = (w_dtw_rsp_ready & dtw_rsp_valid_i & q_reset_n &
                                            (dtw_rsp_tid_i!=myid_i)) ;
assign assert_error_vec[4] = (w_upd_rsp_ready & upd_rsp_valid_i & q_reset_n &
                                            (upd_rsp_tid_i!=myid_i)) ;
assign assert_error_vec[3] = (w_str_req_ready & str_req_valid_i & q_reset_n &
                                            (str_req_tid_i!=myid_i)) ;
assign assert_error_vec[2] = (w_dtr_req_rx_ready & dtr_req_rx_valid_i & q_reset_n &
                                            (dtr_req_rx_tid_i!=myid_i)) ;
assign assert_error_vec[1] = (w_snp_req_ready & snp_req_valid_i & q_reset_n &
                                            (snp_req_tid_i!=myid_i)) ;
assign assert_error_vec[0] = (w_pt_valid & (((|w_amc_errs) & (|w_amc_vals)) | (t_pt_dce & w_amc_unconnected_dce_access) | w_amc_unconnected_dmi_access | w_amc_unconnected_dii_access | no_credit_access ));

assert_never #(0) assert_error(
	.clk		(clk_i),
	.reset_n	(reset_ni & ~a_error_test),
	.test_expr	(|assert_error_vec)
);


\js if (useCache) {
wire [OCN-1:0]	t_oc_set_collision;
wire [OCN-1:0]	t_oc_cbusy[WAYS-1:0];
wire [WAYS-1:0]	t_c2_cbusy;

\js for (let i=0; i<OCN; i=i+1) {
assign t_oc_set_collision[\=i=\] = q_oc_val[\=i=\] & (t_oc_wfcft[\=i=\] | t_oc_wfcwd[\=i=\]) &
				(q_oc_aptr[\=i=\] == \=OCA=\'d\=i=\) &
		      		(w_pt_wake ? (w_pt_kid != \=XTA=\'d\=i=\) : 1'b1) &
				~(t_pt_snp & 
			 ((q_oc_addr[\=i=\][AW-1:CLO] == w_pt_addr[AW-1:CLO]) &
			  (q_oc_security[\=i=\] == w_pt_security))) &
				(w_oc_cset[\=i=\] == w_pt_cset);

\js for (let iw=0; iw<WAYS; iw=iw+1) {
	assign t_oc_cbusy[\=iw=\][\=i=\] = t_oc_set_collision[\=i=\] & ~t_oc_chit[\=i=\] & ~q_oc_wake[\=i=\] &
			    (q_oc_aptr[\=i=\]==\=OCA=\'d\=i=\) & (t_oc_way[\=i=\]==\=log2ceil(WAYS)=\'d\=iw=\);
\js }
\js }

\js for (let i=0; i<WAYS; i=i+1) {
assign t_c2_cbusy[\=i=\] = (| t_oc_cbusy[\=i=\]);
\js }

assert_never #(0) assert_busy(
	.clk		(clk_i),
	.reset_n	(1'b0 & reset_ni & ~a_error_test),
	.test_expr	(w_pt_valid & (cp2_busy_o != t_c2_cbusy))
);

\js } // useCache
//coverage on
//pragma synthesis_on
`endif

\js }

endmodule
