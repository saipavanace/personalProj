\jsbegin
//=============================================================================
// Copyright (C) 2017 Arteris, Inc.
// All rights reserved.
//=============================================================================
//
// NAME: dce_rbid
//
// AUTHOR : Mohammed Khaleeluddin 
//
// DESCRIPTION:
// rbid for DCE
//
//=============================================================================
//
// Variables
//
var u = obj.lib;
var m = obj.userLib;
const vlogGen			= m.vlogGen();
const vlogSignal		= vlogGen.vlogSignal;
//
// Params
//
let ASSERT_ON = m.ParamDefaultGet(u, 'assertOn', 'int', 0);

let N_ATT = m.ParamDefaultGet(u, 'nAttEntries', 'int', 32);
let W_D_ID = m.ParamDefaultGet(u, 'wDid', 'int', 8);
let W_RB_ID = m.ParamDefaultGet(u, 'wRbId', 'int', 8);
let N_CONNECTED_DMIS = m.ParamDefaultGet(u, 'nConnectedDmis', 'int', 4);
let N_RBS = m.ParamDefaultGet(u, 'nRbsPerDmi', 'int', 8);
let W_FUNIT_ID = m.ParamDefaultGet(u, 'wFUnitId', 'int', 4);
let W_N_RBS = Math.max(m.log2ceil(N_RBS), 1);
let W_DMIS = Math.max(m.log2ceil(N_CONNECTED_DMIS), 1);
//
// Ports
//

u.port('input', 'clk', 1);
u.port('input', 'reset_n', 1);

u.port('output', 'rbid_busy', 1);

u.port('input', 'hexDceConnectedDmiRbOffset', N_CONNECTED_DMIS*W_RB_ID);
u.port('input', 'connected_dmi_f_unit_id',  N_CONNECTED_DMIS*W_FUNIT_ID);

u.port('input', 'att_rb_id_req', N_ATT);
u.port('input', 'att_rb_id_d_id_vec', N_ATT*N_CONNECTED_DMIS);
u.port('input', 'att_rb_id_d_id', N_ATT*W_D_ID);

u.port('output', 'att_rb_id_grant', N_ATT);
u.port('output', 'att_rb_id_out', N_ATT*W_RB_ID);
u.port('output', 'att_rb_id_out_gid', N_ATT);

u.port('input', 'att_rb_id_void_valid', N_ATT);
u.port('input', 'att_rb_id_in', N_ATT*W_RB_ID)
u.port('input', 'att_rb_id_in_gid', N_ATT)
u.port('input', 'att_entry_req_rbr_reserve_sent', N_ATT)

u.port('input', 'rbr_rsp_valid', 1)
u.port('input', 'rbr_rsp_d_id', W_D_ID)
u.port('input', 'rbr_rsp_rb_id', W_RB_ID)
u.port('input', 'rbr_rsp_gid', 1)

//
// Module
//

\jsend

module \=u.getModuleName()=\
         (\=u.getPorts()=\
          );
   
\jsbegin
//
// verilog params
//
\jsend

localparam
  N_ATT = \=N_ATT=\,
  N_CONNECTED_DMIS = \=N_CONNECTED_DMIS=\, W_DMIS = \=W_DMIS=\,
  W_D_ID = \=W_D_ID=\,
  W_RB_ID = \=W_RB_ID=\,
  N_RBS = \=W_RB_ID=\'d\=N_RBS=\,
  W_N_RBS = \=W_N_RBS=\,
  W_FUNIT_ID = \=W_FUNIT_ID=\;
 


wire dff_enable = 1'b1;
wire [N_ATT*N_CONNECTED_DMIS-1:0] did_sel_req, did_sel_mask, did_sel_ready, did_sel_grant;
wire [N_CONNECTED_DMIS-1:0] did_req_valid, did_req_ready, void_req_rb_id_vec_valid, flm_all_free, did_req_source_last, allocate_ack_dmi;
wire [N_CONNECTED_DMIS-1:0] att_gid_alloc;
wire [N_CONNECTED_DMIS*W_RB_ID-1:0] att_rb_id_alloc;
wire [N_CONNECTED_DMIS*N_RBS-1:0] att_rb_id_vec_in;  
wire [N_CONNECTED_DMIS*N_RBS-1:0] allocate_vec_dmi;
wire [N_CONNECTED_DMIS*N_RBS-1:0] void_req_rb_id_vec_dmi;
wire [N_CONNECTED_DMIS*N_RBS-1:0] void_rsp_gid_0_rb_id_vec_dmi, void_rsp_gid_1_rb_id_vec_dmi;
wire [N_CONNECTED_DMIS*N_RBS-1:0] void_voi_gid_0_rb_id_vec_dmi, void_voi_gid_1_rb_id_vec_dmi;
wire [N_CONNECTED_DMIS*N_RBS-1:0] void_voi_rb_id_vec_dmi;
wire [N_CONNECTED_DMIS*N_RBS-1:0] void_rel_rb_id_vec_dmi;
wire rb_id_all_free;

wire [N_CONNECTED_DMIS*N_RBS-1:0] RBID_Valid, RBID_Valid_set, RBID_Valid_clr, RBID_Valid_en, RBID_Valid_in, RBID_Valid_ret;
wire [N_CONNECTED_DMIS*N_RBS-1:0] GID_0_Valid, GID_0_Valid_set, GID_0_Valid_clr, GID_0_Valid_en, GID_0_Valid_in;
wire [N_CONNECTED_DMIS*N_RBS-1:0] GID_1_Valid, GID_1_Valid_set, GID_1_Valid_clr, GID_1_Valid_en, GID_1_Valid_in;



\js for(var gi=0; gi< N_ATT; gi++) {

    \js for(let i=0; i< N_CONNECTED_DMIS; i++) { 
assign did_sel_mask[N_ATT*\=i=\ + \=gi=\] = att_rb_id_d_id_vec[\=i=\+(N_CONNECTED_DMIS*\=gi=\)];  
    \js } 

\js }

\js for(var gi=0; gi< N_CONNECTED_DMIS; gi++) {

assign did_sel_req[\=gi=\*N_ATT +: N_ATT] = did_sel_mask[\=gi=\*N_ATT +: N_ATT] & att_rb_id_req;

        // ARB
        \=u.instance ({
                       instanceName: 'rbid_rr_arb'+gi,
                       moduleName: 'rr_arb_comb_mux_therm',
                       params: {
                                num_inputs: N_ATT, useNruPolicy: 1,
                                interleave_mode : 1
                                },
                       verilogParams: {},
                       ports: {
                               'clk' : 'clk',
                               'reset_n' : 'reset_n',
                               'sink_valid':'did_sel_req['+gi+'*N_ATT +: N_ATT]',
                               'sink_last': "{N_ATT{1'b1}}",
                               'sink_ready': 'did_sel_ready['+gi+'*N_ATT +: N_ATT]',
                               'sink_grant': 'did_sel_grant['+gi+'*N_ATT +: N_ATT]',
                               'source_valid': 'did_req_valid['+gi+']',
                               'source_ready': 'did_req_ready['+gi+']',
                               'source_last' : 'did_req_source_last['+gi+']'
                               }
                       })=\
        // FLM
        wire [N_RBS-1:0] free_vec\=gi=\;
        wire [N_RBS-1:0] allocate_vec\=gi=\;
        wire [W_N_RBS-1:0] allocate_bin\=gi=\;

        assign allocate_ack_dmi[\=gi=\] = did_req_valid[\=gi=\] & did_req_ready[\=gi=\];

    \=u.instance({
        instanceName: 'rbid_flm'+gi,
        moduleName: 'find_first_one',
        params: { width : N_RBS },
        verilogParams: { WIDTH : N_RBS },
        ports: {
            invec : 'free_vec'+gi, outvec : 'allocate_vec'+gi
        }
    })=\

assign free_vec\=gi=\ = RBID_Valid[N_RBS*\=gi=\ +: N_RBS] & (GID_0_Valid[N_RBS*\=gi=\ +: N_RBS] | GID_1_Valid[N_RBS*\=gi=\ +: N_RBS]);

assign flm_all_free[\=gi=\] = {&{free_vec\=gi=\}};

assign did_req_ready[\=gi=\] = {|{free_vec\=gi=\}};

assign allocate_vec_dmi[N_RBS*\=gi=\ +: N_RBS] = allocate_vec\=gi=\;

    \=u.instance({
        instanceName: 'rbid_onehot_bin'+gi,
        moduleName: 'encoder',
        params: {
            width: N_RBS
        },
        ports: {
            invector: 'allocate_vec'+gi,
            outdecode: 'allocate_bin'+gi
        }
    })=\

    wire [W_RB_ID-1:0] rb_id_offset_for_att_alloc\=gi=\ = hexDceConnectedDmiRbOffset[W_RB_ID*\=gi=\ +: W_RB_ID];

assign att_rb_id_alloc[W_RB_ID*\=gi=\ +: W_RB_ID] = \=vlogSignal(W_N_RBS, "allocate_bin"+gi).extend0(W_RB_ID)=\ + rb_id_offset_for_att_alloc\=gi=\;

assign att_gid_alloc[\=gi=\] = {|{GID_0_Valid[N_RBS*\=gi=\ +: N_RBS] & allocate_vec_dmi[N_RBS*\=gi=\ +: N_RBS]}} ? 1'b0 : 1'b1;


assign RBID_Valid_clr[N_RBS*\=gi=\ +: N_RBS] = allocate_vec_dmi[N_RBS*\=gi=\ +: N_RBS] & {N_RBS{allocate_ack_dmi[\=gi=\]}};

assign RBID_Valid_set[N_RBS*\=gi=\ +: N_RBS] = RBID_Valid_ret[N_RBS*\=gi=\ +: N_RBS]
                                         | (void_voi_rb_id_vec_dmi[N_RBS*\=gi=\ +: N_RBS] & {N_RBS{void_req_rb_id_vec_valid[\=gi=\]}})
                                         | (void_rel_rb_id_vec_dmi[N_RBS*\=gi=\ +: N_RBS] & {N_RBS{void_req_rb_id_vec_valid[\=gi=\]}})
                                         ;

assign GID_0_Valid_set[N_RBS*\=gi=\ +: N_RBS] = (void_rsp_gid_0_rb_id_vec_dmi[N_RBS*\=gi=\ +: N_RBS] & {N_RBS{void_req_rb_id_vec_valid[\=gi=\]}})
                                              | (void_voi_gid_0_rb_id_vec_dmi[N_RBS*\=gi=\ +: N_RBS] & {N_RBS{void_req_rb_id_vec_valid[\=gi=\]}})
                                              ;

assign GID_1_Valid_set[N_RBS*\=gi=\ +: N_RBS] = (void_rsp_gid_1_rb_id_vec_dmi[N_RBS*\=gi=\ +: N_RBS] & {N_RBS{void_req_rb_id_vec_valid[\=gi=\]}})
                                              | (void_voi_gid_1_rb_id_vec_dmi[N_RBS*\=gi=\ +: N_RBS] & {N_RBS{void_req_rb_id_vec_valid[\=gi=\]}})
                                              ;

\js }

\js for(var gi=0; gi< N_ATT; gi++) {

assign att_rb_id_out[W_RB_ID*\=gi=\ +: W_RB_ID] = (
    \js     for (let i=0; i< N_CONNECTED_DMIS; i++) {
          ({W_RB_ID{did_sel_grant[N_ATT*\=i=\ + \=gi=\]}} & att_rb_id_alloc[W_RB_ID*\=i=\ +: W_RB_ID]) |
    \js      }
          {W_RB_ID{1'b0}});                 

assign att_rb_id_out_gid[\=gi=\] = (
    \js     for (let i=0; i< N_CONNECTED_DMIS; i++) {
          (did_sel_grant[N_ATT*\=i=\ + \=gi=\] & att_gid_alloc[\=i=\]) |
    \js      }
          1'b0);

\js }

assign RBID_Valid_ret = ~RBID_Valid & GID_0_Valid & GID_1_Valid;

assign RBID_Valid_en = RBID_Valid_set | RBID_Valid_clr;
assign RBID_Valid_in = RBID_Valid_set;

assign GID_0_Valid_en = GID_0_Valid_set | GID_0_Valid_clr;
assign GID_0_Valid_in = GID_0_Valid_set;

assign GID_1_Valid_en = GID_1_Valid_set | GID_1_Valid_clr;
assign GID_1_Valid_in = GID_1_Valid_set;

assign GID_0_Valid_clr = GID_0_Valid & RBID_Valid_clr;
   
assign GID_1_Valid_clr = ~GID_0_Valid & GID_1_Valid & RBID_Valid_clr;

assign att_rb_id_grant = (
\js     for (let i=0; i< N_CONNECTED_DMIS; i++) {
          did_sel_ready[N_ATT*\=i=\ +: N_ATT] |     
\js      }
          {N_ATT{1'b0}});                           

assign rb_id_all_free = & flm_all_free;   

assign rbid_busy = ~rb_id_all_free;

//   
// Void logic with RB use
//

wire [N_ATT-1:0] void_voi_valid, void_voi_gid_0_valid, void_voi_gid_1_valid;
wire [N_ATT-1:0] void_rel_valid;
wire             void_rsp_valid, void_rsp_gid_0_valid, void_rsp_gid_1_valid;
wire [N_ATT:0] void_req_valid;
wire [((N_ATT+1)*W_D_ID)-1:0] void_req_d_id;
wire [((N_ATT+1)*W_RB_ID)-1:0] void_req_rb_id;
wire [(N_ATT+1)-1:0] void_req_gid;

assign void_voi_valid = att_rb_id_void_valid & ~att_entry_req_rbr_reserve_sent;
assign void_rel_valid = att_rb_id_void_valid &  att_entry_req_rbr_reserve_sent;
assign void_rsp_valid = rbr_rsp_valid;

assign void_req_valid = {rbr_rsp_valid, att_rb_id_void_valid};
assign void_req_d_id = {rbr_rsp_d_id, att_rb_id_d_id};
assign void_req_rb_id = {rbr_rsp_rb_id, att_rb_id_in};
assign void_req_gid = {rbr_rsp_gid, att_rb_id_in_gid};

assign void_rsp_gid_0_valid = rbr_rsp_valid & ~rbr_rsp_gid;
assign void_rsp_gid_1_valid = rbr_rsp_valid &  rbr_rsp_gid;

assign void_voi_gid_0_valid = void_voi_valid & ~att_rb_id_in_gid;
assign void_voi_gid_1_valid = void_voi_valid &  att_rb_id_in_gid;

\js for (let i=0; i<N_ATT+1; i++) { 
wire [W_D_ID-1:0] void_req_d_id\=i=\ = void_req_d_id[W_D_ID*\=i=\ +: W_D_ID];
\js }                         

\js for (let i=0; i<N_ATT+1; i++) {
wire [W_RB_ID-1:0] void_req_rb_id\=i=\ = void_req_rb_id[W_RB_ID*\=i=\ +: W_RB_ID];
\js }

\js for (let d=0; d<N_CONNECTED_DMIS; d++) { 
wire [N_ATT:0]           void_d_id_match_vec\=d=\;
wire [N_ATT:0]       void_req_d_id_match_vec\=d=\;
wire             void_rsp_gid_0_d_id_match_vec\=d=\, void_rsp_gid_1_d_id_match_vec\=d=\;
wire [N_ATT-1:0] void_voi_gid_0_d_id_match_vec\=d=\, void_voi_gid_1_d_id_match_vec\=d=\;
wire [N_ATT-1:0] void_voi_d_id_match_vec\=d=\;
wire [N_ATT-1:0] void_rel_d_id_match_vec\=d=\;
\js }                         

\js for (let d=0; d<N_CONNECTED_DMIS; d++) { 
    \js for (let i=0; i<N_ATT+1; i++) {
assign           void_d_id_match_vec\=d=\[\=i=\] = (void_req_d_id\=i=\[W_FUNIT_ID-1:0] == connected_dmi_f_unit_id[\=d=\*W_FUNIT_ID +: W_FUNIT_ID]);
assign       void_req_d_id_match_vec\=d=\[\=i=\] =       void_req_valid[\=i=\] & void_d_id_match_vec\=d=\[\=i=\];
    \js } 
\js }
\js for (let d=0; d<N_CONNECTED_DMIS; d++) { 
assign void_rsp_gid_0_d_id_match_vec\=d=\ = void_rsp_gid_0_valid & void_d_id_match_vec\=d=\[\=N_ATT=\];
assign void_rsp_gid_1_d_id_match_vec\=d=\ = void_rsp_gid_1_valid & void_d_id_match_vec\=d=\[\=N_ATT=\];
\js }
\js for (let d=0; d<N_CONNECTED_DMIS; d++) { 
    \js for (let i=0; i<N_ATT; i++) {
assign void_voi_gid_0_d_id_match_vec\=d=\[\=i=\] = void_voi_gid_0_valid[\=i=\] & void_d_id_match_vec\=d=\[\=i=\];
assign void_voi_gid_1_d_id_match_vec\=d=\[\=i=\] = void_voi_gid_1_valid[\=i=\] & void_d_id_match_vec\=d=\[\=i=\];
    \js } 
\js }
\js for (let d=0; d<N_CONNECTED_DMIS; d++) { 
    \js for (let i=0; i<N_ATT; i++) {
assign void_voi_d_id_match_vec\=d=\[\=i=\] = void_voi_valid[\=i=\] & void_d_id_match_vec\=d=\[\=i=\];
assign void_rel_d_id_match_vec\=d=\[\=i=\] = void_rel_valid[\=i=\] & void_d_id_match_vec\=d=\[\=i=\];
    \js } 
\js }

\js for (let i=0; i<N_ATT+1; i++) { 
wire [W_RB_ID-1:0] rb_id_offset_for_void_req\=i=\ = {W_RB_ID{1'b0}} 
    \js for (let d=0; d<N_CONNECTED_DMIS; d++) { 
  | ({W_RB_ID{void_req_d_id_match_vec\=d=\[\=i=\]}} & hexDceConnectedDmiRbOffset[W_RB_ID*\=d=\ +: W_RB_ID])
    \js }
  ;
\js }                         

\js for (let i=0; i<N_ATT+1; i++) { 
wire [W_RB_ID-1:0] void_req_rb_id_minus_offset\=i=\ = void_req_rb_id\=i=\ - rb_id_offset_for_void_req\=i=\;                  
\js }                         

\js for (let i=0; i<N_ATT+1; i++) { 
wire [N_RBS-1:0] void_req_rb_id_vec\=i=\ = (\=N_RBS=\'b1 << void_req_rb_id_minus_offset\=i=\[\=W_RB_ID-1=\:0]);
\js } 

\js for(let d=0; d<N_CONNECTED_DMIS; d++) { 
wire [N_RBS-1:0] void_req_rb_id_vec_dmi\=d=\;
wire [N_RBS-1:0] void_rsp_gid_0_rb_id_vec_dmi\=d=\;
wire [N_RBS-1:0] void_rsp_gid_1_rb_id_vec_dmi\=d=\;
wire [N_RBS-1:0] void_voi_gid_0_rb_id_vec_dmi\=d=\;
wire [N_RBS-1:0] void_voi_gid_1_rb_id_vec_dmi\=d=\;
wire [N_RBS-1:0] void_voi_rb_id_vec_dmi\=d=\;
wire [N_RBS-1:0] void_rel_rb_id_vec_dmi\=d=\;
\js }

\js for(let d=0; d<N_CONNECTED_DMIS; d++) { 
assign void_req_rb_id_vec_dmi\=d=\ = {N_RBS{1'b0}}
    \js for (let i=0; i<N_ATT+1; i++) { 
        | (void_req_rb_id_vec\=i=\ & {N_RBS{void_req_d_id_match_vec\=d=\[\=i=\]}})
    \js }
        ;
assign void_rsp_gid_0_rb_id_vec_dmi\=d=\ = (void_req_rb_id_vec\=N_ATT=\ & {N_RBS{void_rsp_gid_0_d_id_match_vec\=d=\}});

assign void_rsp_gid_1_rb_id_vec_dmi\=d=\ = (void_req_rb_id_vec\=N_ATT=\ & {N_RBS{void_rsp_gid_1_d_id_match_vec\=d=\}});

assign void_voi_gid_0_rb_id_vec_dmi\=d=\ = {N_RBS{1'b0}}
    \js for (let i=0; i<N_ATT; i++) { 
        | (void_req_rb_id_vec\=i=\ & {N_RBS{void_voi_gid_0_d_id_match_vec\=d=\[\=i=\]}})
    \js }
        ;
assign void_voi_gid_1_rb_id_vec_dmi\=d=\ = {N_RBS{1'b0}}
    \js for (let i=0; i<N_ATT; i++) { 
        | (void_req_rb_id_vec\=i=\ & {N_RBS{void_voi_gid_1_d_id_match_vec\=d=\[\=i=\]}})
    \js }
        ;
assign void_voi_rb_id_vec_dmi\=d=\ = {N_RBS{1'b0}}
    \js for (let i=0; i<N_ATT; i++) { 
        | (void_req_rb_id_vec\=i=\ & {N_RBS{void_voi_d_id_match_vec\=d=\[\=i=\]}})
    \js }
        ;
assign void_rel_rb_id_vec_dmi\=d=\ = {N_RBS{1'b0}}
    \js for (let i=0; i<N_ATT; i++) { 
        | (void_req_rb_id_vec\=i=\ & {N_RBS{void_rel_d_id_match_vec\=d=\[\=i=\]}})
    \js }
        ;
\js } 

\js for(let d=0; d<N_CONNECTED_DMIS; d++) { 
assign       void_req_rb_id_vec_dmi[N_RBS*\=d=\ +: N_RBS] =       void_req_rb_id_vec_dmi\=d=\;
assign void_rsp_gid_0_rb_id_vec_dmi[N_RBS*\=d=\ +: N_RBS] = void_rsp_gid_0_rb_id_vec_dmi\=d=\;
assign void_rsp_gid_1_rb_id_vec_dmi[N_RBS*\=d=\ +: N_RBS] = void_rsp_gid_1_rb_id_vec_dmi\=d=\;
assign void_voi_gid_0_rb_id_vec_dmi[N_RBS*\=d=\ +: N_RBS] = void_voi_gid_0_rb_id_vec_dmi\=d=\;
assign void_voi_gid_1_rb_id_vec_dmi[N_RBS*\=d=\ +: N_RBS] = void_voi_gid_1_rb_id_vec_dmi\=d=\;
assign       void_voi_rb_id_vec_dmi[N_RBS*\=d=\ +: N_RBS] =       void_voi_rb_id_vec_dmi\=d=\;
assign       void_rel_rb_id_vec_dmi[N_RBS*\=d=\ +: N_RBS] =       void_rel_rb_id_vec_dmi\=d=\;
\js }

wire [N_CONNECTED_DMIS-1:0] void_req_d_id_match;

\js for(let d=0; d<N_CONNECTED_DMIS; d++) { 
assign void_req_d_id_match[\=d=\] =  {|{void_req_d_id_match_vec\=d=\}};
\js }

\js for(let d=0; d< N_CONNECTED_DMIS; d++) { 
assign void_req_rb_id_vec_valid[\=d=\] = void_req_d_id_match[\=d=\];
\js } 


//
// Improved RBID Management Flops
//
\js for(let i=0; i<(N_CONNECTED_DMIS*N_RBS); i++) { 
wire RBID_Valid\=i=\;
wire GID_0_Valid\=i=\;
wire GID_1_Valid\=i=\;
\js }
\js for(let i=0; i<(N_CONNECTED_DMIS*N_RBS); i++) { 
\=u.dffre(1, 'RBID_Valid'+i,  'RBID_Valid_in['+i+']',  "1'b1", 'RBID_Valid_en['+i+']',  'clk', 'reset_n')=\
\=u.dffre(1, 'GID_0_Valid'+i, 'GID_0_Valid_in['+i+']', "1'b1", 'GID_0_Valid_en['+i+']', 'clk', 'reset_n')=\
\=u.dffre(1, 'GID_1_Valid'+i, 'GID_1_Valid_in['+i+']', "1'b1", 'GID_1_Valid_en['+i+']', 'clk', 'reset_n')=\
\js }
\js for(let i=0; i<(N_CONNECTED_DMIS*N_RBS); i++) { 
assign RBID_Valid[\=i=\] = RBID_Valid\=i=\;
assign GID_0_Valid[\=i=\] = GID_0_Valid\=i=\;
assign GID_1_Valid[\=i=\] = GID_1_Valid\=i=\;
\js }


\jsbegin
/* istanbul ignore else env ncore_3p7 */
if (ASSERT_ON) { \jsend
// Assertions
`ifdef OVL_ASSERT_ON
//coverage off
//pragma synthesis_off
property rbid_void_check;
   @(posedge clk) disable iff (~reset_n)
                   (| (att_rb_id_void_valid)) |-> (void_req_rb_id_vec_valid != 'd0);
endproperty 

assert_rbid_void: assert property (rbid_void_check)
                    else begin $error("RBID VOID MISSED !!"); #1000 $finish; end   


                    

\js for(gi=0; gi< N_ATT; gi++) {

                    reg [15:0] rbid_count\=gi=\;
always @ (posedge clk)
                    if (~reset_n)
                    rbid_count\=gi=\ <= 'd0;
                    else if ((att_rb_id_req[\=gi=\] & att_rb_id_grant[\=gi=\]) && ~(att_rb_id_void_valid[\=gi=\]))
                    rbid_count\=gi=\ <= rbid_count\=gi=\ + 'd1;
                    else if (att_rb_id_void_valid[\=gi=\] & ~(att_rb_id_req[\=gi=\] & att_rb_id_grant[\=gi=\]))
                    rbid_count\=gi=\ <= rbid_count\=gi=\ - 'd1;

\js }
                    
 
//pragma synthesis_on
//coverage on
`endif
\js }
                    
endmodule
