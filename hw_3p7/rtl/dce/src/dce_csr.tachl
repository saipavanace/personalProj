\jsbegin
//=============================================================================
// Copyright(C) 2018 Arteris, Inc.
// All rights reserved
//=============================================================================
// DCE Control Status Registers
// Author: Boon Chuan
// Filename: dce_csr.tachl
//=============================================================================
\jsend

\jsbegin

var u = obj.lib;
var m = obj.userLib;
const vlogGen			= m.vlogGen();
const vlogSignal		= vlogGen.vlogSignal;

var clkInterface               = u.getParam('clkInterface');
var clkInterfaceName           = u.getParam('clkInterfaceName');
var apbInterface               = u.getParam('apbInterface');
var apbInterfaceName           = u.getParam('apbInterfaceName');
var pmonCsrInterface           = u.getParam('pmonCsrInterface');
var ccrCsrInputInterface       = u.getParam('ccrCsrInputInterface');
var regProtectionInterface     = u.getParam('regProtectionInterface');
var regProtectionInterfaceName = u.getParam('regProtectionInterfaceName');
var regProtectionStyle         = u.getParam('regProtectionStyle');

var useSysEvtCoh     = u.getParam('useSysEvtCoh');
var wSnoopEnables    = u.getParam('wSnoopEnables');
var wEventTimeout    = u.getParam('wEventTimeout');
var wProtocolTimeout = u.getParam('wProtocolTimeout');
var nCachingAgents   = u.getParam('nCachingAgents');
var nAius            = u.getParam('nAius');

var CSR              = u.getParam('csr');
var useResiliency    = u.getParam('useResiliency');
var wFUnitId         = u.getParam('wFUnitId');
var wNUnitId         = u.getParam('wNUnitId');
var wRpn             = u.getParam('wRpn');
var wNrri            = u.getParam('wNrri');
var wPortId          = u.getParam('wPortId');

var nNUnitId         = Math.pow(2, wNUnitId);
var nDCEUSER		 = Math.ceil(nAius / 32);		// Number of DCEUSER registers
   
var nSkidBufSize                = u.getParam('nSkidBufSize');
var nSkidBufArb                 = u.getParam('nSkidBufArb');

let N_GPRA = m.ParamDefaultGet(u, 'nGPRA', 'int', 2);
let N_WAYS = m.ParamDefaultGet(u, 'nWays', 'int', 4);
let W_ADDR = m.ParamDefaultGet(u, 'wAddr', 'int', 32);
let W_NS = m.ParamDefaultGet(u, 'wNs', 'int', 1);
let W_INIT_ID = m.ParamDefaultGet(u, 'wInitiatorId', 'int', 8);   
let SF_INFO = m.ParamDefaultGet(u, 'SnoopFilterInfo', 'array', []);
let W_MSG_ID = m.ParamDefaultGet(u, 'wMsgId', 'int', 10);   
let W_N_WAYS = m.log2ceil(N_WAYS);
var useQos = m.ParamDefaultGet(u, 'useQos', 'int', 0);   
var wStarvThreshold = m.ParamDefaultGet(u, 'wStarvThreshold', 'int', 16);
var nPerfCounters              = u.getParam('nPerfCounters');   


// Local functions
// Function to build a conditional chain with multiple if-then expressions
function buildTernaryChain( dfault, ifs, thens ) {
	return thens.map( (then, i) => ifs[i]+" ? "+then )	// Returns an array of strings. Each string = cat of if-expr, " ? ", and then-expr.
				.concat(dfault)							// Adds the default expr to the above array
				.join(" : ");							// Glues all the strings in above array with a ":"
}


//
// generate csrHwPorts
//
var dceCSR           = new m.CreateCSRObj(CSR);
var AWIDTH           = dceCSR.addressWidth;

var regs             = dceCSR.spaceBlock[0].registers;
var csrHwPorts       = dceCSR.getHWPorts();
var regFldsIn        = dceCSR.getRegFldsIn();
var regFldsOut       = dceCSR.getRegFldsOut();

var DCEUSER_offsets	= {};

var DCEUCRTR_ResThreshold_width;
var wSkidBufArb;
var wSkidBufSize;
var rfSwWdata = {};
regs.forEach( function (r) {
    r.fields.forEach( function (f) {
    var rf        = r.name+"_"+f.name+"_"+"sw_wdata";
    if ( rf.includes("Rsv") ) {
    } else {
        rfSwWdata[rf] = f.bitWidth;
    }
    if (r.name == "DCEUCRTR0" && f.name == "ResThreshold") {
        DCEUCRTR_ResThreshold_width = f.bitWidth;
    }
    if(r.name == "DCEUSBSIR" && f.name == "SkidBufArb") {
        wSkidBufArb = f.bitWidth;
    }
    if(r.name == "DCEUSBSIR" && f.name == "SkidBufSize") {
        wSkidBufSize = f.bitWidth;
    }

    });
	
	if(r.name.startsWith("DCEUSER"))
		DCEUSER_offsets[r.name]			= r.addressOffset;
});
var rfSwWr = regs.map( r => r.name+"_sw_wr");

Object.keys(rfSwWdata).forEach(rf => { csrHwPorts[rf] = rf; });

rfSwWr.forEach(r => { csrHwPorts[r] = r; });

\jsend

\jsbegin
//=============================================================================
// Ports
//=============================================================================

u.interface(clkInterfaceName, 'slave', clkInterface);

u.port('input', 'my_n_unit_id', wNUnitId);
u.port('input', 'my_f_unit_id', wFUnitId);
u.port('input', 'my_csr_rpn',   wRpn);
u.port('input', 'my_csr_nrri',  wNrri);
u.port('output','apb_busy',     1);

// Protection interface

m.defineMasterPortsFromInterface(regProtectionInterfaceName, regProtectionInterface, u.port);

// APB interface

u.interface(apbInterfaceName, 'slave', apbInterface);
u.interface(pmonCsrInterface.name, 'master', pmonCsrInterface.signals);
u.interface(ccrCsrInputInterface.name, 'master', ccrCsrInputInterface.signals);

// CSR interface

u.port('input', 'csr_DceTransActive',   1);
u.port('input', 'csr_DceMntOpActive',   1);
   
u.port('output', 'csr_sf_init', 1);
u.port('output', 'csr_dm_debg_cfg', 32);

u.port('input', 'csr_dm_ue_valid', 1);
u.port('input', 'csr_dm_ue_way_vec', N_WAYS);
u.port('input', 'csr_dm_ce_valid', 1);
u.port('input', 'csr_dm_ce_way_vec', N_WAYS);
u.port('input', 'csr_dm_addr', W_ADDR);  
u.port('input', 'csr_dm_ns', W_NS);

u.port('input', 'csr_dm_ce_index', W_ADDR+1);  
u.port('input', 'csr_dm_ue_index', W_ADDR+1);  

u.port('input', 'csr_sb_ue_valid', 1);
u.port('input', 'csr_sb_ce_valid', 1);
u.port('input', 'csr_sb_err_index', 20);

u.port('input', 'csr_addr_map_multi_hit', 1);
u.port('input', 'csr_addr_map_no_hit', 1);
u.port('input', 'csr_addr_map_req_wr', 1);
u.port('input', 'csr_addr_map_trans_id', W_MSG_ID);
u.port('input', 'csr_addr_map_addr', W_ADDR);
u.port('input', 'csr_addr_map_unconnected_dmi_access', 1);

u.port('input', 'no_credits_access_err', 1);
u.port('input', 'no_credits_access_err_addr', W_ADDR);
u.port('input', 'err_p1_tm_cmd_req_d_id_valid', 1);
u.port('input', 'err_p1_tm_cmd_req_d_id_addr', W_ADDR);

if (useQos) {
u.port('output', 'csr_starv_count_threshold', wStarvThreshold);
u.port('output', 'csr_eviction_qos',          4);
u.port('output', 'csr_use_eviction_qos',      1);
}

// Address map

for (var i = 0; i < N_GPRA; i++) 
  {
   u.port('output',  'GPRAR'+i+'_Valid',      1);
   u.port('output',  'GPRAR'+i+'_HUT',        1);
   u.port('output',  'GPRAR'+i+'_Size',       6);
   u.port('output',  'GPRAR'+i+'_HUI',        5);
   //u.port('output',  'GPRAR'+i+'_DIGId',      3);
   u.port('output',  'GPRBAR'+i+'_AddrLo',    32);
   u.port('output',  'GPRBAR'+i+'_AddrHi',    8);
   }

u.port('output',  'BRAR_Valid',      1);
//u.port('output',  'BRAR_ST',         1);
u.port('output',  'BRAR_Size',       6);
u.port('output',  'BRAR_HUT',        1);
u.port('output',  'BRAR_HUI',        5);
//u.port('output',  'BRAR_DIGId',      3);
u.port('output',  'BRBAR_AddrLo',    32);
u.port('output',  'BRBAR_AddrHi',    8);

u.port('output',  'AMIGR_AMIGS',     4);
u.port('output',  'AMIGR_Valid',     1);
u.port('output',  'MIFSR_A16WIFId',  3);
u.port('output',  'MIFSR_A8WIFId',   3);
u.port('output',  'MIFSR_A4WIFId',   3);
u.port('output',  'MIFSR_A3WIFId',   3);
u.port('output',  'MIFSR_A2WIFId',   3);  
 
u.port('input', 'cmux_UCE_err_vld', 1);
u.port('input', 'cmux_CE_err_vld', 1);

u.port('input',  'csr_target_ue_valid',   1);
u.port('input',  'csr_target_ue_init_id', wFUnitId);

u.port('input',  'csr_timeout_ue_addr', W_ADDR);
u.port('input',  'csr_timeout_ue_ns', W_NS);
u.port('input',  'csr_timeout_ue_valid', 1);

u.port('output', 'csr_timeout_threshold', 31);
u.port('output', 'csr_timeout_ref_en', 1);
u.port('output', 'csr_timeout_count_reset', 1);

u.port('output', 'IRQ_uc', 1);
u.port('output', 'IRQ_c',  1);
   
if (useResiliency) {
u.port('output', 'dce_res_cerr_threshold', 8);
}

/* istanbul ignore else env ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */
if (useSysEvtCoh) {
    for (i=0; i < nCachingAgents; i++) {
obj.lib.port('input', 'ca'+i+'_n_unit_id', wNUnitId);
    }
u.port('input',  'csr_sys_coh_receiver_err_vld', 1);
u.port('input',  'csr_sys_coh_receiver_err_f_unit_id', wFUnitId);
u.port('input',  'snoop_enables', wSnoopEnables);
u.port('input',  'snoop_enables_update', 1);
u.port('output', 'csr_snoop_enables', wSnoopEnables);
u.port('output', 'csr_snoop_enables_update', 1);
u.port('output', 'csr_protocol_timeout_value', wProtocolTimeout);
u.port('output', 'csr_sys_evt_sender_enable', 1);
u.port('input',  'csr_sys_evt_sender_err_vld', 1);
u.port('input',  'csr_sys_evt_sender_err_f_unit_id', wFUnitId);
u.port('input',  'csr_sys_evt_sender_err_protocol_sys', 1);
u.port('input',  'csr_sys_evt_sender_err_protocol_timeout', 1);
u.port('input',  'csr_sys_evt_sender_err_event_timeout', 1);
u.port('output', 'ca_SnoopEnable', nCachingAgents);
}

for (var rf in regFldsOut) {
  if (rf.includes("CreditLimit") || rf.includes("CounterState") ) {
u.port('output', rf, regFldsOut[rf]);
  }
}

\jsend

module \=u.getModuleName()=\ (\=u.getPorts('\n')=\);

localparam
  N_WAYS = \=N_WAYS=\, 
  W_N_WAYS = \=W_N_WAYS=\,
  W_INIT_ID = \=W_INIT_ID=\,                            
  N_GPRA = \=N_GPRA=\, 
  W_NS = \=W_NS=\,                     
  W_ADDR = \=W_ADDR=\;
                              
    \js Object.keys(rfSwWdata).forEach(rf => {
wire [\=rfSwWdata[rf]-1=\:0] \=rf=\;
    \js });
    \js rfSwWr.forEach(r => {
wire \=r=\;
    \js });


\jsbegin
for (var rf in regFldsIn) {
  if( !(rf.replace(/^DCE/,"") in pmonCsrInterface.signals) && !rf.startsWith('DCEUCCR') ) {
\jsend
wire [\=regFldsIn[rf]-1=\:0] \=rf=\;
\jsbegin
  }
}
\jsend

// Tie off Reserved
\jsbegin
for (var rf in regFldsIn) {
    /* istanbul ignore if env ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */
    if ( rf.includes("Rsv") ) {
\jsend
assign \=rf=\ = 'h0;
\jsbegin
    }
}
\jsend


\jsbegin
for (var rf in regFldsOut) {
  if (rf.includes("CreditLimit") || rf.includes("CounterState") ) {
  } else if( !(rf.replace(/^DCE/,"") in pmonCsrInterface.signals) ) {
\jsend
wire [\=regFldsOut[rf]-1=\:0] \=rf=\;
\jsbegin
  }
}
\jsend

wire IRQ_uc_sig;
wire IRQ_uc_q;
wire IRQ_c_sig;
wire IRQ_c_q; \jsbegin

/* istanbul ignore else env ncore_3p7 */
if (nPerfCounters) { \jsend
wire [\=nPerfCounters-1=\:0] corr_pmon_ovf_int; \jsbegin
} \jsend

wire dff_enable;

    \js for (i=0; i < nCachingAgents; i++) {
wire [\=nNUnitId-1=\:0] ca\=i=\_n_unit_id_vec;
    \js }
wire [\=nNUnitId-1=\:0] ca_n_unit_id_vec;
wire [\=nAius-1=\:0] DCEUSER_SnpsEnb;
wire [\=nCachingAgents-1=\:0] ca_SnoopDisable_sig;
wire [\=nCachingAgents-1=\:0] ca_SnoopDisable;

wire [31:0] \=apbInterfaceName=\pwdata_mux;

wire [19:0] uncorr_err_entry;
wire [5:0]  uncorr_err_way;
wire [5:0]  uncorr_err_word;

wire corr_err_exceed_threshold;

\jsbegin
//=============================================================================
// Logic
//=============================================================================
\jsend

assign dff_enable = 1'b1;

\jsbegin
//=============================================================================
// CSR port connections for Snoop Enable Registers
//=============================================================================
\jsend

\jsbegin
/* istanbul ignore else env ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */
if (useSysEvtCoh) { \jsend

assign ca_SnoopEnable = ~ca_SnoopDisable;

wire csr_snoop_enables_update_in = 1'b0
        \js for (var i=0; i < nDCEUSER; i++) {
                               | DCEUSER\=i=\_sw_wr
        \js }
                               ;

\=u.dffre(1, 'csr_snoop_enables_update', 'csr_snoop_enables_update_in', "1'b0", 'dff_enable', clkInterfaceName+'clk', clkInterfaceName+'reset_n')=\

assign csr_snoop_enables = DCEUSER_SnpsEnb[\=wSnoopEnables-1=\:0];

    \js for (i=0; i < nCachingAgents; i++) {
assign ca\=i=\_n_unit_id_vec = \=nNUnitId=\'b1 << ca\=i=\_n_unit_id;
    \js }
\js } else {
    \js for (i=0; i < nCachingAgents; i++) {
assign ca\=i=\_n_unit_id_vec = \=nNUnitId=\'b1 << \=wNUnitId=\'d\=i=\;
    \js }
\js }

assign ca_n_unit_id_vec = ca0_n_unit_id_vec
    \js for (i=1; i < nCachingAgents; i++) {
        | ca\=i=\_n_unit_id_vec
    \js }
        ;

    \js for (i=0; i < nCachingAgents; i++) {
assign ca_SnoopDisable_sig[\=i=\] = ~{|{ca\=i=\_n_unit_id_vec[\=nAius-1=\:0] & DCEUSER_SnpsEnb[\=nAius-1=\:0]}};
    \js }

\=u.dffre(nCachingAgents, 'ca_SnoopDisable', 'ca_SnoopDisable_sig', nCachingAgents+"'b0", 'dff_enable', clkInterfaceName+'clk', clkInterfaceName+'reset_n')=\

\jsbegin
// Concatenate DCEUSER*_SnpsEnb_out signals into a single vector
const DCEUSER_SnpsEnbs_out		= [];
	
for(let i=nDCEUSER-1; i>=0; i--) {
	DCEUSER_SnpsEnbs_out.push( "DCEUSER"+i+"_SnpsEnb_out" ); 
} \jsend

		assign DCEUSER_SnpsEnb			= { \=DCEUSER_SnpsEnbs_out.join(", ")=\ }; \jsbegin


// If address offset matches one of DCEUSER* registers, then mask pwdata going into apb_csr with ca_n_unit_id_vec
// Replace this with one-hot-select mux with logic trees for improved timing
const caNUnitIdChunks			= vlogSignal( nNUnitId, "ca_n_unit_id_vec" ).split(32); // Split ca_n_unit_id_vec into 32-bit sized chunks
const addrMatches				= [];
const pwDataMasked				= [];

for(let i=nDCEUSER-1; i>=0; i--) {
	const offset				= AWIDTH+"'d"+DCEUSER_offsets["DCEUSER"+i];			// DCEUSER register address offset
	const unitId				= caNUnitIdChunks[i].extend0(32);					// Unit ID vector extended with zeros if width<32

	addrMatches.push( "("+apbInterfaceName+"paddr"+" == "+offset+") & apb_psel");	// Use APB address match as select lines for mux
	pwDataMasked.push( apbInterfaceName+"pwdata"+" & "+unitId );	// Use masked APB write data as inputs of mux
} \jsend
	
		assign \=apbInterfaceName=\pwdata_mux		= \=buildTernaryChain( apbInterfaceName+"pwdata", addrMatches, pwDataMasked )=\;

\jsbegin
const DCEUSER_SnpsEnbs_in		= [];
const DCEUSER_SnpsEnbs_wr		= [];

for(let i=nDCEUSER-1; i>=0; i--) {
	DCEUSER_SnpsEnbs_in.push( "DCEUSER"+i+"_SnpsEnb_in" );
	DCEUSER_SnpsEnbs_wr.push( "DCEUSER"+i+"_SnpsEnb_wr" );
}

/* istanbul ignore else env ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */
if (useSysEvtCoh) {
	const snoopEnablesExt		= vlogSignal(wSnoopEnables, "snoop_enables").extend0(nAius);	// Extend snoop_enables signal by padding zeros \jsend
		assign { \=DCEUSER_SnpsEnbs_in.join(", ")=\ }		= \=snoopEnablesExt=\;
		assign { \=DCEUSER_SnpsEnbs_wr.join(", ")=\ }		= { \=nDCEUSER=\ {snoop_enables_update & ~csr_snoop_enables_update_in} }; \jsbegin

} else { \jsend
		assign { \=DCEUSER_SnpsEnbs_in.join(", ")=\ }		= 'b0;
		assign { \=DCEUSER_SnpsEnbs_wr.join(", ")=\ }		= 'b0; \jsbegin

}


//=============================================================================
// System Event and Coherency Registers
//=============================================================================
\jsend

\jsbegin
/* istanbul ignore else env ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */
if (useSysEvtCoh) { \jsend
assign csr_protocol_timeout_value  = {|{DCEUSEPTOCR_TimeOutThreshold_out}} ? ({|{DCEUSEPTOCR_TimeOutThreshold_out[30:8]}} ? {\=wProtocolTimeout=\{1'b1}} : {DCEUSEPTOCR_TimeOutThreshold_out[7:0], {12{1'b0}}}) : {\=wProtocolTimeout=\{1'b0}};
assign csr_sys_evt_sender_enable   = ~DCEUTCR_EventDisable_out;
\js }

\jsbegin
//=============================================================================
// TAR register                              
//=============================================================================
\jsend

assign DCEUTAR_TransActv_in = csr_DceTransActive;
assign DCEUTAR_TransActv_wr = DCEUTAR_TransActv_in ^ DCEUTAR_TransActv_out;

assign DCEUSFMAR_MntOpActv_in = csr_DceMntOpActive;
assign DCEUSFMAR_MntOpActv_wr = DCEUSFMAR_MntOpActv_in ^ DCEUSFMAR_MntOpActv_out;
assign apb_busy = \=apbInterfaceName=\psel;

// assign DCEUSFMDR_MntData_in = 'b0;
// assign DCEUSFMDR_MntData_wr = 1'b0;

//=============================================================================
// CSR port connections for ID Registers and INFO Registers
//=============================================================================

assign DCEUIDR_RPN_in     = my_csr_rpn;
assign DCEUIDR_NRRI_in    = my_csr_nrri;
assign DCEUIDR_NUnitId_in	= \=vlogSignal(wNUnitId, "my_n_unit_id").extend0(12)=\;
assign DCEUIDR_Valid_in   = 1'b0;
assign DCEUFUIDR_FUnitId_in	= \=vlogSignal(wFUnitId, "my_f_unit_id").extend0(16)=\;

\js //apb_csr will XOR this with the value from the JSON file.

assign DCEUENGIDR_EngVerId_in = 32'd0;

assign DCEUINFOR_ImplVer_in = 16'd0;
assign DCEUINFOR_UT_in      = 4'b0;
assign DCEUINFOR_Valid_in   = 1'b0;

// Maintenance regsiters

assign csr_sf_init = DCEUSFMCR_InitSnoopFilter_out;

// Engg debug registers

assign csr_dm_debg_cfg = DCEUEDR0_CfgCtrl_out;
                              
// address map registers

assign BRAR_Valid = DCEUBRAR_Valid_out;
//assign BRAR_ST = DCEUBRAR_ST_out;
assign BRAR_Size = DCEUBRAR_Size_out;
assign BRAR_HUT = DCEUBRAR_HUT_out;
assign BRAR_HUI = DCEUBRAR_HUI_out;
//assign BRAR_DIGId = DCEUBRAR_DIGId_out;
assign BRBAR_AddrLo = DCEUBRBLR_AddrLow_out;
assign BRBAR_AddrHi = DCEUBRBHR_AddrHigh_out;
assign AMIGR_AMIGS = DCEUAMIGR_AMIGS_out;
assign AMIGR_Valid = DCEUAMIGR_Valid_out;
assign MIFSR_A2WIFId = DCEUMIFSR_MIG2AIFId_out;
assign MIFSR_A3WIFId = DCEUMIFSR_MIG3AIFId_out;
assign MIFSR_A4WIFId = DCEUMIFSR_MIG4AIFId_out;
assign MIFSR_A8WIFId = DCEUMIFSR_MIG8AIFId_out;
assign MIFSR_A16WIFId= DCEUMIFSR_MIG16AIFId_out;

\jsbegin
for (var i = 0; i < N_GPRA; i++) 
  {
\jsend
assign GPRAR\=i=\_Valid = DCEUGPRAR\=i=\_Valid_out;
assign GPRAR\=i=\_HUT = DCEUGPRAR\=i=\_HUT_out;
assign GPRAR\=i=\_Size = DCEUGPRAR\=i=\_Size_out;
assign GPRAR\=i=\_HUI = DCEUGPRAR\=i=\_HUI_out;
//assign GPRAR\=i=\_DIGId = DCEUGPRAR\=i=\_DIGId_out;
assign GPRBAR\=i=\_AddrLo = DCEUGPRBLR\=i=\_AddrLow_out;
assign GPRBAR\=i=\_AddrHi = DCEUGPRBHR\=i=\_AddrHigh_out;
\js }                             

\jsbegin
//=============================================================================
// Error Registers
//=============================================================================

// seprate out way vector on per SF basis
let sf_bitmask_msb = [];
let sf_bitmask_lsb = [];
let bitmask_temp = 0;
for (i=0; i<SF_INFO.length; i++)
  {
   bitmask_temp += SF_INFO[i].nWays;
   sf_bitmask_msb[i] = bitmask_temp -1; 
   sf_bitmask_lsb[i] = bitmask_temp - SF_INFO[i].nWays; 
   }
\jsend
wire [11:0] sf_ue_num;
wire [6:0] sf_ce_num;
wire [5:0] sf_ce_way_num, sf_ue_way_num;
wire [19:0] sf_ce_set_num, sf_ue_set_num;
wire [W_ADDR-1:0] sf_ce_addr, sf_ue_addr;
wire [3:0] sf_ce_type, sb_ce_type, trans_ce_type;
wire [15:0] sf_ce_info, sb_ce_info;  
wire [3:0] sf_ue_type, sb_ue_type;
wire [19:0] sf_ue_info, sb_ue_info;                              
wire sf_ce_valid, sf_ue_valid;

                              
// Snoop filter CE
                             
assign sf_ce_num = (
\js for (i=0; i<SF_INFO.length; i++) {                    
                    (| csr_dm_ce_way_vec[\=sf_bitmask_msb[i]=\ : \=sf_bitmask_lsb[i]=\ ]) ? 7'd\=i=\ :
\js }                                                          
                    7'd0);    


\js for (i=0; i<SF_INFO.length; i++) {
wire [\=Math.max(m.log2ceil(SF_INFO[i].nWays), 1)=\-1:0] sf\=i=\_ce_way_num;
wire [\=SF_INFO[i].nWays-1=\:0] csr_dm_ce_way_ff_vec\=i=\;
       \=u.instance ({
                      instanceName: 'ce_way_rl'+i,
                      moduleName: 'find_first_rl',
                      params: {
                               width : SF_INFO[i].nWays
                               },
                      ports : {
                               value : "1'b1",
                               invec : 'csr_dm_ce_way_vec['+sf_bitmask_msb[i]+' : '+sf_bitmask_lsb[i]+']',
                               outvec: 'csr_dm_ce_way_ff_vec'+i,
                               outvec_encode : 'sf'+i+'_ce_way_num'
                               }
                      })=\
\js }                      
                                                            
assign sf_ce_way_num = (
\js for (i=0; i<SF_INFO.length; i++) {                    
                    (| csr_dm_ce_way_vec[\=sf_bitmask_msb[i]=\ : \=sf_bitmask_lsb[i]=\ ]) ? {{(6-\=Math.max(m.log2ceil(SF_INFO[i].nWays), 1)=\){1'b0}}, sf\=i=\_ce_way_num} :
\js }                                                          
                    6'd0);

\js// TODO: connect me
assign sf_ce_set_num = csr_dm_ce_index[19:0];                       

assign sf_ce_valid = csr_dm_ce_valid;
assign sf_ce_addr = csr_dm_addr;                     
assign sf_ce_type = 4'd0;
assign trans_ce_type = 4'd8;
assign sf_ce_info = {1'b0, sf_ce_num, 5'b0, 3'b011};

assign sb_ce_type = 4'd0;
assign sb_ce_info = {8'b0, 5'b0, 3'b101};

// Snoop filter UE
                                                           
assign sf_ue_num = (
\js for (i=0; i<SF_INFO.length; i++) {                    
                    (| csr_dm_ue_way_vec[\=sf_bitmask_msb[i]=\ : \=sf_bitmask_lsb[i]=\ ]) ? 12'd\=i=\ :
\js }                                                          
                    12'd0);


\js for (i=0; i<SF_INFO.length; i++) {
wire [\=Math.max(m.log2ceil(SF_INFO[i].nWays), 1)=\-1:0] sf\=i=\_ue_way_num;
wire [\=SF_INFO[i].nWays-1=\:0] csr_dm_ue_way_vec\=i=\;
       \=u.instance ({
                      instanceName: 'ue_way_rl'+i,
                      moduleName: 'find_first_rl',
                      params: {
                               width : SF_INFO[i].nWays
                               },
                      ports : {
                               value : "1'b1",
                               invec : 'csr_dm_ue_way_vec['+sf_bitmask_msb[i]+' : '+sf_bitmask_lsb[i]+']',
                               outvec : 'csr_dm_ue_way_vec'+i,
                               outvec_encode : 'sf'+i+'_ue_way_num'
                               }
                      })=\
\js }                      
                                                            
assign sf_ue_way_num = (
\js for (i=0; i<SF_INFO.length; i++) {                    
                    (| csr_dm_ue_way_vec[\=sf_bitmask_msb[i]=\ : \=sf_bitmask_lsb[i]=\ ]) ? {{(6-\=Math.max(m.log2ceil(SF_INFO[i].nWays), 1)=\){1'b0}}, sf\=i=\_ue_way_num} :
\js }                                                          
                    6'd0);                                 
\js// TODO: connect me
assign sf_ue_set_num = csr_dm_ue_index[19:0];
assign sf_ue_valid = csr_dm_ue_valid;
assign sf_ue_addr = csr_dm_addr;
assign sf_ue_type = 4'd0;
assign sf_ue_info = {sf_ue_num, 5'b0, 3'b011};//{csr_dm_ns, sf_ue_num, sf_ue_way_num};

assign sb_ue_type = 4'd0;
assign sb_ue_info = {12'b0, 5'b0, 3'b101};

// Timeout UE
wire timeout_ue_valid;
wire [3:0] sys_evt_timeout_ue_type;
wire [3:0] timeout_ue_type;
wire [19:0] timeout_ue_info;
wire [51:0] timeout_ue_addr;

assign sys_evt_timeout_ue_type = 4'ha;

assign timeout_ue_valid = csr_timeout_ue_valid;
assign timeout_ue_type = 4'h9;
assign timeout_ue_info = {\=20-2-W_NS=\'b0, csr_timeout_ue_ns , 2'b0};
assign timeout_ue_addr	= \=vlogSignal(W_ADDR, "csr_timeout_ue_addr").extend0(52)=\;
// Address Map UE, Software/Configuration UE
//

wire addr_map_ue_valid, sw_cfg_ue_valid;
wire [3:0] addr_map_ue_type, sw_cfg_ue_type;
wire [19:0] addr_map_ue_info, sw_cfg_ue_info;
wire [3:0] addr_map_ue_err_type, sw_cfg_ue_err_type;
wire [11:0] addr_map_ue_trans_id, sw_cfg_ue_trans_id;
wire [51:0] addr_map_ue_addr, sw_cfg_ue_addr;
wire [1:0] addr_map_ue_req_type, sw_cfg_ue_req_type;
assign addr_map_ue_valid = csr_addr_map_multi_hit | csr_addr_map_no_hit;
assign addr_map_ue_type = 4'h7;

assign addr_map_ue_err_type = csr_addr_map_multi_hit ? 4'b0001:
                              csr_addr_map_no_hit    ? 4'b0000: 4'b0000;


assign addr_map_ue_req_type = {1'b0, csr_addr_map_req_wr};
assign addr_map_ue_trans_id	= \=vlogSignal(W_MSG_ID, "csr_addr_map_trans_id").extend0(12)=\;
assign addr_map_ue_info = {addr_map_ue_trans_id, 2'b0, addr_map_ue_req_type, addr_map_ue_err_type};
assign addr_map_ue_addr	= \=vlogSignal(W_ADDR, "csr_addr_map_addr").extend0(52)=\;
assign csr_timeout_threshold = DCEUTOCR_TimeOutThreshold_out;
assign csr_timeout_ref_en = DCEUTOCR_TimeOutRefEn_out;
assign csr_timeout_count_reset = DCEUTOCR_sw_wr;
// Target UE                            
wire trans_ue_valid;
wire [3:0] trans_ue_type;
wire [19:0] trans_ue_info;
                              
assign trans_ue_valid = csr_target_ue_valid | cmux_UCE_err_vld | (cmux_CE_err_vld & corr_err_exceed_threshold);
assign trans_ue_type = 4'h8;
assign trans_ue_info = {\=20-8-wFUnitId=\'d0, csr_target_ue_init_id, 7'b0, 1'b0}; 
                              
// CE counter     
                              
assign corr_err_exceed_threshold = (DCEUCESR_ErrCount_out == DCEUCECR_ErrThreshold_out);

assign DCEUCESR_ErrCount_in = DCEUCESAR_sw_wr                        ? DCEUCESAR_ErrCount_sw_wdata :
                              (DCEUCESR_sw_wr & DCEUCESR_ErrVld_sw_wdata) ? 8'b0 : (DCEUCESR_ErrCount_out + 1'b1); 
assign DCEUCESR_ErrCount_wr = DCEUCESAR_sw_wr |
                              (DCEUCESR_sw_wr & DCEUCESR_ErrVld_sw_wdata & DCEUCESR_ErrVld_out) |
             ((csr_sb_ce_valid | sf_ce_valid | cmux_CE_err_vld) & DCEUCECR_ErrDetEn_out & ~corr_err_exceed_threshold);
assign DCEUCESR_ErrCountOverflow_in = DCEUCESAR_sw_wr                        ? DCEUCESAR_ErrCountOverflow_sw_wdata :
                              (DCEUCESR_sw_wr & DCEUCESR_ErrVld_sw_wdata) ? 1'b0 : 1'b1;
assign DCEUCESR_ErrCountOverflow_wr =DCEUCESAR_sw_wr |
                              ((DCEUCESR_sw_wr & DCEUCESR_ErrVld_sw_wdata) | 
             ((csr_sb_ce_valid | sf_ce_valid | cmux_CE_err_vld) & ~DCEUCESR_ErrCountOverflow_out & DCEUCECR_ErrDetEn_out)) & DCEUCESR_ErrVld_out;

          
// CE register

assign DCEUCESR_ErrVld_in = DCEUCESAR_sw_wr                        ? DCEUCESAR_ErrVld_sw_wdata :
                            (DCEUCESR_sw_wr & DCEUCESR_ErrVld_out) ? (~DCEUCESR_ErrVld_sw_wdata & DCEUCESR_ErrVld_out) :
             ((csr_sb_ce_valid | sf_ce_valid | cmux_CE_err_vld) & corr_err_exceed_threshold & DCEUCECR_ErrDetEn_out) ? 1'b1 :
                            DCEUCESR_ErrVld_out;

assign DCEUCESR_ErrVld_wr = DCEUCESAR_sw_wr |
                            DCEUCESR_sw_wr  | 
             ((csr_sb_ce_valid | sf_ce_valid | cmux_CE_err_vld) & corr_err_exceed_threshold & DCEUCECR_ErrDetEn_out);

assign DCEUCESR_ErrType_in = DCEUCESAR_sw_wr                                                   ? DCEUCESAR_ErrType_sw_wdata :
                             ((sf_ce_valid) & DCEUCECR_ErrDetEn_out & ~DCEUCESR_ErrVld_out) ? sf_ce_type :
                             ((cmux_CE_err_vld) & DCEUCECR_ErrDetEn_out & ~DCEUCESR_ErrVld_out) ? trans_ce_type :
                         ((csr_sb_ce_valid)                   & DCEUCECR_ErrDetEn_out & ~DCEUCESR_ErrVld_out) ? sb_ce_type :
                             DCEUCESR_ErrType_out;

assign DCEUCESR_ErrType_wr = DCEUCESAR_sw_wr |
             ((csr_sb_ce_valid | sf_ce_valid | cmux_CE_err_vld) & DCEUCECR_ErrDetEn_out & ~DCEUCESR_ErrVld_out);

assign DCEUCESR_ErrInfo_in = DCEUCESAR_sw_wr                                                  ? DCEUCESAR_ErrInfo_sw_wdata :
                            ((sf_ce_valid | cmux_CE_err_vld) & DCEUCECR_ErrDetEn_out & ~DCEUCESR_ErrVld_out) ? sf_ce_info          :
                        ((csr_sb_ce_valid)                   & DCEUCECR_ErrDetEn_out & ~DCEUCESR_ErrVld_out) ? sb_ce_info          :
                            DCEUCESR_ErrInfo_out;

assign DCEUCESR_ErrInfo_wr = DCEUCESAR_sw_wr |
             ((csr_sb_ce_valid | sf_ce_valid | cmux_CE_err_vld) & DCEUCECR_ErrDetEn_out & ~DCEUCESR_ErrVld_out);

assign DCEUCELR0_ErrAddr_wr   = ((csr_sb_ce_valid | sf_ce_valid | cmux_CE_err_vld) & DCEUCECR_ErrDetEn_out & ~DCEUCESR_ErrVld_out);
assign DCEUCELR0_ErrAddr_in   = csr_sb_ce_valid ? {6'b0, 6'b0, csr_sb_err_index} : {6'b0, sf_ce_way_num, sf_ce_set_num};
assign DCEUCELR1_ErrAddr_wr   = 1'b0;
assign DCEUCELR1_ErrAddr_in   = 20'd0; 

// UE register
assign DCEUUESR_ErrVld_in = DCEUUESAR_sw_wr                                 ? DCEUUESAR_ErrVld_sw_wdata :
                           (DCEUUESR_sw_wr   & DCEUUESR_ErrVld_out)         ? (~DCEUUESR_ErrVld_sw_wdata & DCEUUESR_ErrVld_out) :
                           (trans_ue_valid   & DCEUUEDR_TransErrDetEn_out)  ? 1'b1 :
                           (sf_ue_valid      & DCEUUEDR_MemErrDetEn_out)    ? 1'b1 :
                       (csr_sb_ue_valid      & DCEUUEDR_MemErrDetEn_out)    ? 1'b1 :
                           (timeout_ue_valid & DCEUUEDR_TimeoutErrDetEn_out)? 1'b1 :
                           (csr_sys_evt_sender_err_vld & (csr_sys_evt_sender_err_protocol_timeout | csr_sys_evt_sender_err_event_timeout) & DCEUUEDR_TimeoutErrDetEn_out)? 1'b1 :
                           (addr_map_ue_valid & DCEUUEDR_DecErrDetEn_out)   ? 1'b1 :
                           (sw_cfg_ue_valid  & DCEUUEDR_SoftwareProgConfigErrDetEn_out) ? 1'b1 : DCEUUESR_ErrVld_out;
assign DCEUUESR_ErrType_in = DCEUUESAR_sw_wr                                                     ? DCEUUESAR_ErrType_sw_wdata :
                            (trans_ue_valid     & DCEUUEDR_TransErrDetEn_out    & ~DCEUUESR_ErrVld_out) ? trans_ue_type :
                            (sf_ue_valid        & DCEUUEDR_MemErrDetEn_out      & ~DCEUUESR_ErrVld_out) ? sf_ue_type :
                        (csr_sb_ue_valid        & DCEUUEDR_MemErrDetEn_out      & ~DCEUUESR_ErrVld_out) ? sb_ue_type :
                            (timeout_ue_valid   & DCEUUEDR_TimeoutErrDetEn_out  & ~DCEUUESR_ErrVld_out) ? timeout_ue_type :
                            (csr_sys_evt_sender_err_vld & (csr_sys_evt_sender_err_protocol_timeout | csr_sys_evt_sender_err_event_timeout) & DCEUUEDR_TimeoutErrDetEn_out  & ~DCEUUESR_ErrVld_out) ? sys_evt_timeout_ue_type :
                            (addr_map_ue_valid  & DCEUUEDR_DecErrDetEn_out      & ~DCEUUESR_ErrVld_out) ? addr_map_ue_type:
                            (sw_cfg_ue_valid    & DCEUUEDR_SoftwareProgConfigErrDetEn_out & ~DCEUUESR_ErrVld_out) ? sw_cfg_ue_type:
                                                                                                          DCEUUESR_ErrType_out;
assign DCEUUESR_ErrInfo_in = DCEUUESAR_sw_wr                                                            ? DCEUUESAR_ErrInfo_sw_wdata :
                            (trans_ue_valid     & DCEUUEDR_TransErrDetEn_out    & ~DCEUUESR_ErrVld_out) ? trans_ue_info :
                            (sf_ue_valid        & DCEUUEDR_MemErrDetEn_out      & ~DCEUUESR_ErrVld_out) ? sf_ue_info :
                        (csr_sb_ue_valid        & DCEUUEDR_MemErrDetEn_out      & ~DCEUUESR_ErrVld_out) ? sb_ue_info :
                            (timeout_ue_valid   & DCEUUEDR_TimeoutErrDetEn_out  & ~DCEUUESR_ErrVld_out) ? timeout_ue_info :
                            (csr_sys_evt_sender_err_vld & csr_sys_evt_sender_err_protocol_timeout & DCEUUEDR_TimeoutErrDetEn_out)? {19'b0, 1'b0} :
                            (csr_sys_evt_sender_err_vld & csr_sys_evt_sender_err_event_timeout & DCEUUEDR_TimeoutErrDetEn_out)? {19'b0, 1'b1} :
                            (addr_map_ue_valid  & DCEUUEDR_DecErrDetEn_out      & ~DCEUUESR_ErrVld_out) ? addr_map_ue_info :
                            (sw_cfg_ue_valid  & DCEUUEDR_SoftwareProgConfigErrDetEn_out & ~DCEUUESR_ErrVld_out) ? sw_cfg_ue_info :
                                                                                                          DCEUUESR_ErrInfo_out;
assign DCEUUESR_ErrVld_wr   = DCEUUESAR_sw_wr                                    | 
                             (DCEUUESR_sw_wr    & DCEUUESR_ErrVld_out)           | 
                             (trans_ue_valid    & DCEUUEDR_TransErrDetEn_out)    |
                             (sf_ue_valid       & DCEUUEDR_MemErrDetEn_out)      |
                         (csr_sb_ue_valid       & DCEUUEDR_MemErrDetEn_out)      |
                             (timeout_ue_valid  & DCEUUEDR_TimeoutErrDetEn_out)  |
                             (csr_sys_evt_sender_err_vld & (csr_sys_evt_sender_err_protocol_timeout | csr_sys_evt_sender_err_event_timeout) & DCEUUEDR_TimeoutErrDetEn_out)  |
                             (addr_map_ue_valid & DCEUUEDR_DecErrDetEn_out) |
                             (sw_cfg_ue_valid   & DCEUUEDR_SoftwareProgConfigErrDetEn_out);
assign DCEUUESR_ErrType_wr  = DCEUUESAR_sw_wr                                                         | 
                             (trans_ue_valid   & DCEUUEDR_TransErrDetEn_out    & ~DCEUUESR_ErrVld_out)|
                             (sf_ue_valid      & DCEUUEDR_MemErrDetEn_out      & ~DCEUUESR_ErrVld_out)|
                         (csr_sb_ue_valid      & DCEUUEDR_MemErrDetEn_out      & ~DCEUUESR_ErrVld_out)|
                             (timeout_ue_valid & DCEUUEDR_TimeoutErrDetEn_out  & ~DCEUUESR_ErrVld_out)|
                             (csr_sys_evt_sender_err_vld & (csr_sys_evt_sender_err_protocol_timeout | csr_sys_evt_sender_err_event_timeout) & DCEUUEDR_TimeoutErrDetEn_out  & ~DCEUUESR_ErrVld_out)|
                             (addr_map_ue_valid & DCEUUEDR_DecErrDetEn_out     & ~DCEUUESR_ErrVld_out)|
                             (sw_cfg_ue_valid  & DCEUUEDR_SoftwareProgConfigErrDetEn_out & ~DCEUUESR_ErrVld_out);
assign DCEUUESR_ErrInfo_wr  = DCEUUESAR_sw_wr                                                         |
                             (trans_ue_valid   & DCEUUEDR_TransErrDetEn_out    & ~DCEUUESR_ErrVld_out)|
                             (sf_ue_valid      & DCEUUEDR_MemErrDetEn_out      & ~DCEUUESR_ErrVld_out)|
                         (csr_sb_ue_valid      & DCEUUEDR_MemErrDetEn_out      & ~DCEUUESR_ErrVld_out)|
                             (timeout_ue_valid & DCEUUEDR_TimeoutErrDetEn_out  & ~DCEUUESR_ErrVld_out)|
                             (addr_map_ue_valid & DCEUUEDR_DecErrDetEn_out     & ~DCEUUESR_ErrVld_out)|
                             (sw_cfg_ue_valid  & DCEUUEDR_SoftwareProgConfigErrDetEn_out & ~DCEUUESR_ErrVld_out);

assign uncorr_err_entry      = trans_ue_valid    ? 20'd0 :
                               sf_ue_valid       ? sf_ue_set_num :
                           csr_sb_ue_valid       ? csr_sb_err_index : 
                               timeout_ue_valid  ? timeout_ue_addr[19:0] :
                               addr_map_ue_valid ? addr_map_ue_addr[19:0]: 
                               sw_cfg_ue_valid   ? sw_cfg_ue_addr[19:0]: 
                                                   20'd0;
assign uncorr_err_way        = trans_ue_valid    ? 6'd0 :
                               sf_ue_valid       ? sf_ue_way_num[5:0] : 
                           csr_sb_ue_valid       ? 6'd0 : 
                               timeout_ue_valid  ? timeout_ue_addr[25:20]  :
                               addr_map_ue_valid ? addr_map_ue_addr[25:20] :
                               sw_cfg_ue_valid   ? sw_cfg_ue_addr[25:20] :
                                                   6'd0;
assign uncorr_err_word       = trans_ue_valid    ? 6'd0 :
                               sf_ue_valid       ? 6'd0 :        
                           csr_sb_ue_valid       ? 6'd0 :        
                               timeout_ue_valid  ? timeout_ue_addr[31:26]  :
                               addr_map_ue_valid ? addr_map_ue_addr[31:26] :
                               sw_cfg_ue_valid   ? sw_cfg_ue_addr[31:26] :
                                                   6'd0;
assign DCEUUELR0_ErrAddr_in   = {uncorr_err_word, uncorr_err_way, uncorr_err_entry}; 
assign DCEUUELR0_ErrAddr_wr  = (trans_ue_valid   & DCEUUEDR_TransErrDetEn_out   & ~DCEUUESR_ErrVld_out) |
                               (sf_ue_valid      & DCEUUEDR_MemErrDetEn_out     & ~DCEUUESR_ErrVld_out) |
                               (timeout_ue_valid & DCEUUEDR_TimeoutErrDetEn_out & ~DCEUUESR_ErrVld_out) |
                               (addr_map_ue_valid & DCEUUEDR_DecErrDetEn_out    & ~DCEUUESR_ErrVld_out) | 
                               (sw_cfg_ue_valid  & DCEUUEDR_SoftwareProgConfigErrDetEn_out & ~DCEUUESR_ErrVld_out); 
assign DCEUUELR1_ErrAddr_in   = timeout_ue_valid ? timeout_ue_addr[51:32]: 
                                addr_map_ue_valid ? addr_map_ue_addr[51:32]: sw_cfg_ue_valid ? sw_cfg_ue_addr[51:32]: 20'd0;
assign DCEUUELR1_ErrAddr_wr   = (timeout_ue_valid & DCEUUEDR_TimeoutErrDetEn_out | 
                                 addr_map_ue_valid & DCEUUEDR_DecErrDetEn_out    |
                                 sw_cfg_ue_valid   & DCEUUEDR_SoftwareProgConfigErrDetEn_out) & ~DCEUUESR_ErrVld_out;
\jsbegin
//=============================================================================
// Resiliency Correctable Error Threshold
//=============================================================================
\jsend

\js if (useResiliency) {
assign dce_res_cerr_threshold = DCEUCRTR0_ResThreshold_out; 
\js }


\jsbegin
//=============================================================================
// Qos event Threshold
//=============================================================================
\jsend

\js if (useQos) {
assign csr_starv_count_threshold = DCEUQOSCR0_EventThreshold_out;
assign csr_eviction_qos          = DCEUQOSCR0_EvictionQoS_out;
assign csr_use_eviction_qos      = DCEUQOSCR0_useEvictionQoS_out;
\js } 

\jsbegin
//=============================================================================
// IRQ
//=============================================================================
\jsend

assign IRQ_c  = IRQ_c_q;
assign IRQ_uc = IRQ_uc_q;

wire uncorr_timeout_err_int;
wire uncorr_trans_err_int;
wire uncorr_mem_err_int;
wire uncorr_dec_err_int;
wire uncorr_sw_cfg_err_int;
assign uncorr_timeout_err_int = DCEUUEIR_TimeoutErrIntEn_out & DCEUUESR_ErrVld_out & ((DCEUUESR_ErrType_out == 4'h9) | (DCEUUESR_ErrType_out == 4'ha));
assign uncorr_trans_err_int   = DCEUUEIR_TransErrIntEn_out   & DCEUUESR_ErrVld_out & (DCEUUESR_ErrType_out == 4'h8);
assign uncorr_mem_err_int     = DCEUUEIR_MemErrIntEn_out     & DCEUUESR_ErrVld_out & (DCEUUESR_ErrType_out == 4'h0);
assign uncorr_dec_err_int     = DCEUUEIR_DecErrIntEn_out     & DCEUUESR_ErrVld_out & (DCEUUESR_ErrType_out == 4'h7);
assign uncorr_sw_cfg_err_int  = DCEUUEIR_SoftwareProgConfigErrIntEn_out & DCEUUESR_ErrVld_out & (DCEUUESR_ErrType_out == 4'hC);
\js for(let i=0; i<nPerfCounters; i++) {
assign corr_pmon_ovf_int[\=i=\] = DCECNTCR\=i=\_InterruptEn_out & DCECNTCR\=i=\_OverFlowStatus_out;
\js }
 
wire corr_pmon_int; \jsbegin
/* istanbul ignore else env ncore_3p7 */
if (nPerfCounters) { \jsend
assign corr_pmon_int = |corr_pmon_ovf_int; \jsbegin
} else { \jsend
assign corr_pmon_int = 1'b0; \jsbegin
} \jsend


assign IRQ_c_sig  = (DCEUCECR_ErrIntEn_out & DCEUCESR_ErrVld_out) | corr_pmon_int;
assign IRQ_uc_sig = uncorr_timeout_err_int |
                    uncorr_trans_err_int   |
                    uncorr_mem_err_int     |
                    uncorr_dec_err_int     |  
                    uncorr_sw_cfg_err_int;
\=u.dffre(1, 'IRQ_c_q',  'IRQ_c_sig',  "1'b0", 'dff_enable', clkInterfaceName+'clk', clkInterfaceName+'reset_n')=\
\=u.dffre(1, 'IRQ_uc_q', 'IRQ_uc_sig', "1'b0", 'dff_enable', clkInterfaceName+'clk', clkInterfaceName+'reset_n')=\

//=============================================================================
// Skidbuffer Info
//=============================================================================

assign DCEUSBSIR_SkidBufArb_in  = \=wSkidBufArb=\'h0;
assign DCEUSBSIR_SkidBufSize_in = \=wSkidBufSize=\'h0;
assign DCEUSBSIR_Valid_in       = 1'b0;

\jsbegin
//=============================================================================
// Symphony Stuff
//=============================================================================
\jsend

// Instantiate CSR registers:

\jsbegin
var reg_interfaces = [];

reg_interfaces.push({
        modulePrefix: clkInterfaceName,
        localPrefix: clkInterfaceName,
        interface: clkInterface
});

//reg_interfaces.push({
//        modulePrefix: apbInterfaceName,
//        localPrefix:apbInterfaceName,
//        interface: apbInterface
//});

/* istanbul ignore if env ncore_3p0, ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */
if(regProtectionStyle != null) {
  if(regProtectionStyle.protection != "none") {
    reg_interfaces.push({
        modulePrefix: regProtectionInterfaceName,
        localPrefix: regProtectionInterfaceName,
        interface: regProtectionInterface
    });
  }
}

Object.keys(apbInterface).forEach(function(key) {
    if (key == 'pwdata') {
csrHwPorts[apbInterfaceName+'pwdata']  = apbInterfaceName+'pwdata_mux';
    } /* istanbul ignore next env ncore_3p6, ncore_3p7 */ else if (Math.abs((apbInterface[key]))) {
csrHwPorts[apbInterfaceName+key]       = apbInterfaceName+key;
    }
});

\jsend

\=u.instance({
        instanceName: 'u_apb_csr',
        moduleName: 'apb_csr',
        params: {
          clkInterface          : {"name" : clkInterfaceName,           "signals" : clkInterface},
          cfgInterface          : {"name" : apbInterfaceName,           "signals" : apbInterface},
          protectionInterface   : {"name" : regProtectionInterfaceName, "signals" : regProtectionInterface},
          protectionStyle       : regProtectionStyle,
          flopAPB               : "yes",
          csr                   : CSR
        },
        ports: csrHwPorts,
        interfaces: reg_interfaces
})=\

// Software/Configuration Uncorrectable Error

assign sw_cfg_ue_valid = csr_addr_map_unconnected_dmi_access | no_credits_access_err | err_p1_tm_cmd_req_d_id_valid;

assign sw_cfg_ue_type = 4'hC;

assign sw_cfg_ue_err_type = no_credits_access_err ? 4'b0001 : 
                            csr_addr_map_unconnected_dmi_access | err_p1_tm_cmd_req_d_id_valid ? 4'b0010 : 4'b0000;

assign sw_cfg_ue_req_type = 2'b0;

assign sw_cfg_ue_trans_id = 12'b0;

assign sw_cfg_ue_info     = {sw_cfg_ue_trans_id, 2'b0, sw_cfg_ue_req_type, sw_cfg_ue_err_type};

assign sw_cfg_ue_addr     = no_credits_access_err        ? \=vlogSignal(W_ADDR, "no_credits_access_err_addr").extend0(52)=\ :
                            err_p1_tm_cmd_req_d_id_valid ? \=vlogSignal(W_ADDR, "err_p1_tm_cmd_req_d_id_addr").extend0(52)=\ :  
                                                           \=vlogSignal(W_ADDR, "csr_addr_map_addr").extend0(52)=\;

endmodule
