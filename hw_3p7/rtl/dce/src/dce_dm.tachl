\jsbegin
var u = obj.lib;
var m = obj.userLib;

var ioaiu_log = function(n) { return (n > 1) ? m.log2ceil(n) : /* istanbul ignore next ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */ 1; };

var assertOn = u.getParam('assertOn');

var useSramInputFlop = u.getParam('useSramInputFlop');

let NULL_FILTER =m.ParamDefaultGet(u, 'NullFilter', 'int', 0);
let CMD_REQ_INTF = m.ParamDefaultGet(u, 'cmdReqInterface', 'object', {});
let ATN =m.ParamDefaultGet(u, 'nAttEntries', 'int', 0);
let SFI = m.ParamDefaultGet(u, 'SnoopFilterInfo', 'array', {});
let CLO = m.ParamDefaultGet(u, 'wCacheLineOffset', 'int', 3);
/* istanbul ignore next env ncore_3p0 */
let ARST = m.ParamDefaultGet(u, 'AsyncReset', 'int', 0) ? "or negedge reset_ni" : /* istanbul ignore next ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */ "";
/* istanbul ignore next env ncore_3p0 */
let DRST = m.ParamDefaultGet(u, 'DataReset', 'int', 0) ? "1'b0" : /* istanbul ignore next ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */ "1'bx";
/* istanbul ignore next env ncore_3p0 */
var DARST = (u.getParam('DataReset')==1) ? ARST : /* istanbul ignore next ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */ "";
/* istanbul ignore next env ncore_3p0 */
var EARST = (u.getParam('DataReset')==1) ? "end" : /* istanbul ignore next ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */ "";
let RRD = m.ParamDefaultGet(u, 'RetryDepth', 'int', 4);
let PIPEDEPTH = m.ParamDefaultGet(u, 'PipeDepth', 'int', 3);
let UIDW = m.ParamDefaultGet(u, 'wFUnitId', 'int', 5);

let W_ADDR = CMD_REQ_INTF.addr;
let W_NS = CMD_REQ_INTF.ns;
let W_CM_TYPE = CMD_REQ_INTF.cm_type;
let W_INIT_ID = CMD_REQ_INTF.initiator_id;
let W_MPF1 = CMD_REQ_INTF.mpf1;
let W_MPF2 = CMD_REQ_INTF.mpf2;
let W_ES = CMD_REQ_INTF.es;

var FN = SFI.length;
var AW = CMD_REQ_INTF.addr+1;		//plus NS security bit
var IW = CMD_REQ_INTF.initiator_id;
var TW = CMD_REQ_INTF.cm_type;
var ATW = m.log2ceil(ATN);
var FW = (FN>1) ? m.log2ceil(FN) : 1;

var msg = u.getParam('cmType');
var UpdInv = msg.UpdInv;
var CmdRdNitc = msg.CmdRdNitc;
var CmdRdNitcCI = msg.CmdRdNitcCI;
var CmdRdNitcMI = msg.CmdRdNitcMI;
var CmdWrUnqPtl = msg.CmdWrUnqPtl;
var CmdWrUnqFull = msg.CmdWrUnqFull;
var CmdWrStshFull = msg.CmdWrStshFull;
var CmdWrStshPtl = msg.CmdWrStshPtl;
var CmdLdCchShd = msg.CmdLdCchShd;
var CmdLdCchUnq = msg.CmdLdCchUnq;

var MSET = 0;
var TotalAgents = 0;
var TotalWays = 0;
var MaxEntry = 1;
var MNW = 0;
for (let i=0; i<FN; i++) {
	var wEntry = 0;
    /* istanbul ignore if env ncore_3p0, ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */
	if (SFI[i].SetSelectInfo.PriSubDiagAddrBits.length != 
	    m.log2ceil(SFI[i].nSets)) 			DceParamError_1;
    /* istanbul ignore if env ncore_3p0, ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */
	if (SFI[i].SetSelectInfo.PriSubDiagAddrBits.length != 
	    SFI[i].SetSelectInfo.SecSubRows.length) 	DceParamError_2;
    /* istanbul ignore if env ncore_3p0, ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */
	if (CLO != 6) 					DceParamError_3;
    /* istanbul ignore if env ncore_3p0, ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */
	if (CLO >= AW) 					DceParamError_4;
    /* istanbul ignore if env ncore_3p0, ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */
	if (((SFI[i].biten>1) & (SFI[i].biten != SFI[i].nMemory)) |
	    ((SFI[i].biten==0) & (SFI[i].nMemory != SFI[i].nWays)) |
	    ((SFI[i].biten>1) & (SFI[i].nWays%SFI[i].biten)) |
	    (SFI[i].nWays <= SFI[i].biten))		DceParamError_5; 

	var MNW = (SFI[i].wEntry > MNW) ? SFI[i].wEntry : MNW;
	if (SFI[i].nSets > MSET) MSET = SFI[i].nSets;
	var TotalAgents = TotalAgents + SFI[i].nCachingAgents;
	var TotalWays = TotalWays + SFI[i].nWays;
	var wEntry = AW - m.log2ceil(SFI[i].nSets) - CLO +
		     SFI[i].nCachingAgents + 1 + 
	    ((SFI[i].nCachingAgents>1) ? m.log2ceil(SFI[i].nCachingAgents) : 0);
	var MaxEntry = (SFI[i].TagFilterErrorInfo.fnErrDetectCorrect=="SECDED" &
			(wEntry>MaxEntry)) ? wEntry : MaxEntry;
}

var TCN = TotalAgents;
/* istanbul ignore next env ncore_3p0 */
var TCW = m.log2ceil(TCN) ? m.log2ceil(TCN) : 1;
var WN = TotalWays;
var WW = m.log2ceil(WN);

var MSW = Math.max(4, ioaiu_log(MSET));
var ICW = MSW + 1;

var usePLRU = u.getParam('usePLRU');

u.port('input', 'CachingAgents', UIDW*TCN);
u.port('input', 'clk_i', 1);
u.port('input', 'reset_ni', 1);
u.port('input', 'cfg_i', 32);
u.port('input', 'cfg_init_i', 1);
u.port('input', 'cfg_busy_i', WN);
u.port('input', 'cfg_filter_i', FN);
u.port('output', 'idle_o', 1);
u.port('output', 'csr_DceMntOpActive_o', 1);
u.port('output', 'dm_t_p2_stall_o', 1);

u.port('output', 'dm_upd_req_ready_o', 1);
u.port('input', 'dm_upd_req_valid_i', 1);
u.port('input', 'dm_upd_req_ns_i', 1);
u.port('input', 'dm_upd_req_addr_i', AW-1);
u.port('input', 'dm_upd_req_iid_i', IW); 
u.port('output', 'dm_upd_status_o', 2);
u.port('output', 'dm_upd_status_valid_o', 1);

u.port('output', 'dm_cmd_req_ready_o', 1);
u.port('input', 'dm_cmd_req_valid_i', 1);
u.port('input', 'dm_cmd_req_ns_i', 1);
u.port('input', 'dm_cmd_req_addr_i', AW-1);
u.port('input', 'dm_cmd_req_iid_i', IW);
u.port('input', 'dm_cmd_req_sid_i', IW);
u.port('input', 'dm_cmd_req_type_i', TW);
u.port('input', 'dm_cmd_req_wakeup_i', 1);
u.port('input', 'dm_cmd_req_att_vec_i', ATN);
u.port('input', 'dm_cmd_req_mpf1_i', W_MPF1);
u.port('input', 'dm_cmd_req_mpf2_i', W_MPF2);
u.port('input', 'dm_cmd_req_es_i', W_ES);

u.port('output', 'dm_cmd_req1_valid_o', 1);
u.port('output', 'dm_cmd_req1_filter_num_o', FW);
u.port('output', 'dm_cmd_req1_filter_vec_o', FN);
u.port('input', 'dm_cmd_req1_busy_vec_i', WN);
u.port('input', 'dm_cmd_req1_alloc_i', 1);
u.port('input', 'dm_cmd_req1_cancel_i', 1);


u.port('input', 'dm_cmd_rsp_ready_i', 1);	
u.port('output', 'dm_cmd_rsp_valid_o', 1);
u.port('output', 'dm_cmd_rsp_att_vec_o', ATN);
u.port('output', 'dm_cmd_rsp_way_vec_o', WN);
u.port('output', 'dm_cmd_rsp_owner_val_o', 1);
u.port('output', 'dm_cmd_rsp_owner_num_o', TCW);
u.port('output', 'dm_cmd_rsp_sharer_vec_o', TCN);
u.port('output', 'dm_cmd_rsp_wr_required_o', 1);
u.port('output', 'dm_cmd_rsp_vb_hits_o', FN);
u.port('output', 'dm_cmd_rsp_error_o', 1);
u.port('output', 'dm_rsp_lookup_cm_type', W_CM_TYPE);
u.port('output', 'dm_rsp_lookup_ns', W_NS);
u.port('output', 'dm_rsp_lookup_addr', W_ADDR);
u.port('output', 'dm_rsp_lookup_initiator_id', W_INIT_ID);
u.port('output', 'dm_rsp_lookup_mpf2', W_MPF2);
u.port('output', 'dm_rsp_lookup_es', W_ES);


u.port('input', 'dm_rtr_ready_i', 1);	
u.port('output', 'dm_rtr_valid_o', 1);
u.port('output', 'dm_rtr_att_vec_o', ATN);
//u.port('output', 'dm_rtr_filter_num_o', FW);	//nnm: remove
u.port('output', 'dm_rtr_filter_vec_o', FN);
u.port('output', 'dm_rtr_way_mask_o', WN);
u.port('output', 'dm_rtr_req_cm_type', W_CM_TYPE);
u.port('output', 'dm_rtr_req_ns', W_NS);
u.port('output', 'dm_rtr_req_addr', W_ADDR);
u.port('output', 'dm_rtr_req_initiator_id', W_INIT_ID);
u.port('output', 'dm_rtr_req_mpf1', W_MPF1);
u.port('output', 'dm_rtr_req_mpf2', W_MPF2);
u.port('output', 'dm_rtr_req_es', W_ES);

u.port('input', 'dm_recall_ready_i', 1);
u.port('output', 'dm_recall_valid_o', 1);
u.port('output', 'dm_recall_ns_o', 1);
u.port('output', 'dm_recall_addr_o', AW-1);
u.port('output', 'dm_recall_sharer_vec_o', TCN);
u.port('output', 'dm_recall_owner_val_o', 1);
u.port('output', 'dm_recall_owner_num_o', TCW);

u.port('output', 'dm_write_ready_o', 1);
u.port('input', 'dm_write_valid_i', 1);
u.port('input', 'dm_write_ns_i', 1);
u.port('input', 'dm_write_addr_i', AW-1);
u.port('input', 'dm_write_way_vec_i', WN);
u.port('input', 'dm_write_owner_val_i', 1);
u.port('input', 'dm_write_owner_num_i', TCW);
u.port('input', 'dm_write_sharer_vec_i', TCN);
u.port('input', 'dm_write_change_vec_i', TCN);

u.port('input', 'dm_write_valid_dup_i', 1);
u.port('input', 'dm_write_ns_dup_i', 1);
u.port('input', 'dm_write_addr_dup_i', AW-1);
u.port('input', 'dm_write_way_vec_dup_i', WN);
u.port('input', 'dm_write_owner_val_dup_i', 1);
u.port('input', 'dm_write_owner_num_dup_i', TCW);
u.port('input', 'dm_write_sharer_vec_dup_i', TCN);
u.port('input', 'dm_write_change_vec_dup_i', TCN);

u.port('output', 'dm_error_uerr_o', 1);
u.port('output', 'dm_error_uway_vec_o', WN);
u.port('output', 'dm_error_uindex_o', AW);
u.port('output', 'dm_error_cerr_o', 1);
u.port('output', 'dm_error_cway_vec_o', WN);
u.port('output', 'dm_error_cindex_o', AW);
u.port('output', 'dm_error_addr_o', AW);

for (let f=0; f<FN; f++) {
	for (let w=0; w<SFI[f].nMemory; w++) {
u.port('output', 'f'+f+'m'+w+'_ce_o', 1);
u.port('output', 'f'+f+'m'+w+'_we_o', 1);
u.port('output', 'f'+f+'m'+w+'_addr_o', m.log2ceil(SFI[f].nSets));
u.port('output', 'f'+f+'m'+w+'_biten_o', SFI[f].wMemory);
u.port('output', 'f'+f+'m'+w+'_wdata_o', SFI[f].wMemory);
u.port('input', 'f'+f+'m'+w+'_rdata_i', SFI[f].wMemory);
	}
}

if (usePLRU) {
    for (let f=0; f<FN; f++) {
u.port('output', 'f'+f+'_plru_mem_read_en', 1);
u.port('output', 'f'+f+'_plru_mem_read_addr', m.log2ceil(SFI[f].nSets));
u.port('input',  'f'+f+'_plru_mem_read_data', SFI[f].nWays);
u.port('output', 'f'+f+'_plru_mem_write_en', 1);
u.port('output', 'f'+f+'_plru_mem_write_addr', m.log2ceil(SFI[f].nSets)); 
u.port('output', 'f'+f+'_plru_mem_write_data', SFI[f].nWays);
    }
}

\jsend


module \=u.getModuleName()=\
	(\=u.getPorts('\n\t')=\
);

localparam DRST = \=DRST=\;
localparam NULL_FILTER = \=NULL_FILTER=\;
localparam ATN = \=ATN=\;
localparam ATW = \=ATW=\;
localparam FN = \=FN=\;
localparam TCN = \=TCN=\;
localparam WN = \=WN=\;
localparam AW = \=AW=\;
localparam IW = \=IW=\;
localparam TW = \=TW=\;
localparam TCW = \=TCW=\;
localparam WW = \=WW=\;
localparam FW = \=FW=\;
localparam UIDW = \=UIDW=\;
localparam UpdInv = \=UpdInv=\;
localparam CmdRdNitc = \=CmdRdNitc=\;
localparam CmdRdNitcCI = \=CmdRdNitcCI=\;
localparam CmdRdNitcMI = \=CmdRdNitcMI=\;
localparam CmdWrUnqPtl = \=CmdWrUnqPtl=\;
localparam CmdWrUnqFull = \=CmdWrUnqFull=\;
localparam CmdWrStshFull = \=CmdWrStshFull=\;
localparam CmdWrStshPtl = \=CmdWrStshPtl=\;
localparam CmdLdCchShd = \=CmdLdCchShd=\;
localparam CmdLdCchUnq = \=CmdLdCchUnq=\;
localparam CLO = \=CLO=\;
localparam RRD = \=RRD=\;
localparam PIPEDEPTH = \=PIPEDEPTH=\;
localparam MSET = \=MSET=\;
localparam MSW = \=MSW=\;
localparam MNW = \=MNW=\;
localparam MaxEntry = \=MaxEntry=\;
localparam FCT = 6+MSW;
localparam W_ES = \=W_ES=\;
localparam W_MPF1 = \=W_MPF1=\;
localparam W_MPF2 = \=W_MPF2=\;

wire dff_enable = 1'b1;

\jsbegin
/* istanbul ignore else env ncore_3p7 */
if (useSramInputFlop) {
\jsend

wire                 n_p0plus_ready;
wire                 w_p0plus_valid;
wire [W_ES-1:0]      w_p0plus_es;
wire [W_MPF1-1:0]    w_p0plus_mpf1;
wire [W_MPF2-1:0]    w_p0plus_mpf2;
wire [IW-1:0]        w_p0plus_initiator_id;
wire [TW-1:0]        w_p0plus_type;
wire [AW-1:0]        w_p0plus_addr;
wire [IW-1:0]        w_p0plus_iid;
wire                 w_p0plus_upd;
wire [ATW-1:0]       w_p0plus_aid;

\js }

wire [IW-1:0]	t_cid;
wire				n_wr_ready;
wire				w_wr_valid;
\js for (var gd=0; gd<FN; gd++) {
wire				w_wr_valid_sf\=gd=\;
wire [AW-1:0]			w_wr_addr_sf\=gd=\;
wire [WN-1:0]			w_wr_ways_sf\=gd=\;
wire				w_wr_oval_sf\=gd=\;
wire [TCW-1:0]			w_wr_owner_sf\=gd=\;
wire [TCN-1:0]			w_wr_sbv_sf\=gd=\;
wire [TCN-1:0]			w_wr_change_sf\=gd=\;
wire				t_init_valid_sf\=gd=\;
wire [AW-1:0]			t_init_addr_sf\=gd=\;
    \js if (usePLRU) {
wire f\=gd=\_plru_mem_init;
wire [\=m.log2ceil(SFI[gd].nSets)-1=\:0] f\=gd=\_plru_mem_init_addr;
    \js }
\js }
wire      	t_wr_sel, t_wr_sel_dup;
wire		n_p0_ready,	n_p1_ready,	n_p2_ready;
wire		w_p0_valid,	w_p1_valid,	w_p2_valid, w_p2_valid_dup, w_p1_valid_dup;
wire [AW-1:0]	w_p0_addr,	w_p1_addr,	w_p2_addr, w_p2_addr_dup, w_p1_addr_dup;
wire [IW-1:0]	w_p0_iid,	w_p1_iid,	w_p2_iid, w_p2_iid_dup, w_p1_iid_dup;
wire [IW-1:0]	w_p0_initiator_id, w_p1_initiator_id, w_p2_initiator_id, w_p2_initiator_id_dup, w_p1_initiator_id_dup;
wire [W_ES-1:0]   w_p0_es,      w_p1_es,        w_p2_es, w_p2_es_dup, w_p1_es_dup;
wire [W_MPF1-1:0] w_p0_mpf1,    w_p1_mpf1,      w_p2_mpf1, w_p2_mpf1_dup, w_p1_mpf1_dup;
wire [W_MPF2-1:0] w_p0_mpf2,    w_p1_mpf2,      w_p2_mpf2, w_p2_mpf2_dup, w_p1_mpf2_dup;
wire				w_p1_cancel,	w_p2_cancel, w_p2_cancel_dup;
wire				w_p1_alloc;
wire [TW-1:0]	w_p0_type,      w_p1_type,      w_p2_type, w_p2_type_dup, w_p1_type_dup;
wire		w_p0_wakeup;
wire		w_p0_upd,	w_p1_upd,	w_p2_upd, w_p2_upd_dup, w_p1_upd_dup;
wire [ATW-1:0]	w_p0_aid,	w_p1_aid,	w_p2_aid, w_p2_aid_dup, w_p1_aid_dup;
wire [FW-1:0]			w_p1_fid,	w_p2_fid, w_p2_fid_dup;
wire [ATN-1:0]                                  w_p2_aid_onehot;
wire [FN-1:0]			w_p1_home;
wire [WN-1:0]			w_p1_busy, t_p1_busy;
wire [FN-1:0]	w_p0_fbv;
wire [1:0]	t_p0_sel;
wire		t_p0_lookup;
wire [FN*FW-1:0]		w_p1_fids;
wire [FN-1:0]					w_p2_stalls;
wire						t_p2_stall;
wire [FN-1:0]					w_p2_retrys;
wire [FN-1:0]					w_p2_vretrys;
wire						t_p2_vretry;
wire [FN-1:0]					w_p2_up_hits;
wire [FN-1:0]			w_p1_rc_hits,	w_p2_rc_hits;
wire 				t_p1_rc_hit,	t_p2_rc_hit;
wire [FN-1:0]							w_rc_readys;
wire [FN-1:0]							n_rc_valids;
wire [FN*AW-1:0]						n_rc_addrs;
wire [FN*TCN-1:0]				w_p2_sbvs,	n_rc_sbvs;
wire [FN-1:0]					w_p2_ovals,	n_rc_ovals;
wire [FN*TCW-1:0]				w_p2_owners,	n_rc_owners;
wire [FN*WN-1:0]				w_p2_ybvs;
wire [FN*WN-1:0]				w_p2_yuerr, 
						w_p2_ycerr;
wire [FN*AW-1:0]				w_p2_uindex,
						w_p2_cindex;
wire [FN-1:0]							w_rc_sel;
wire [TCN-1:0]					w_p2_sbv;
wire						w_p2_oval;
wire [TCW-1:0]					w_p2_owner;
wire [FN-1:0]					w_p2_allocs;
wire [FN-1:0]					w_p2_wbs;
wire [FN-1:0]					w_p2_vhits;
wire [FN-1:0]					w_p2_errors;
wire [WN-1:0]					w_p2_ybv;
wire		w_rr_af;
wire		w_rr_ready,	n_rr_ready;
wire		n_rr_valid,	w_rr_valid;
wire [ATN-1:0]			w_rr_aid_onehot;
wire [FW-1:0]			w_rr_fid;
wire		n_up_valid;
wire [2:0]	t_rs_sel;

wire			t_init_valid, t_init_valid_dup;
wire [AW-1:0]		t_init_addr, t_init_addr_dup;
wire [FN*WN-1:0]	w_ymask;

wire		q_reset_n,    reset_n_in, q_reset_n_dup, q_init_count_idle;
wire [MSW:0]	q_init_count, init_count_in, q_init_count_dup;
wire [1:0]	q_flush,      flush_in, q_flush_dup;




//nnm: t_cfg_single step one write at a time
//nnm: t_cfg_single step one update at a time
//nnm: t_cfg_arbiter read/write/update
//nnm: t_cfg_mru flush (Little/Big endian arbiters)
//nnm: t_cfg_retry back-to-back second request
//nnm: t_cfg_retry victim buffer hit
//nnm: t_cfg_change write all selected ways.
//nnm: t_cfg_retry until victim buffer is empty
//nnm: t_cfg_single port memory even if flop or 2 ports exist

wire		t_cfg_init = cfg_init_i;	//Initialize memory
wire		t_cfg_stall_update = cfg_i[21];	//Stall Update if p1/p2 valid.
wire		t_cfg_wb = cfg_i[20];		//Require TM WriteBack (rmW).
wire		t_cfg_rc = cfg_i[19];		//Recall if pipe is empty
wire [1:0]	t_cfg_save = cfg_i[18:17];	//Disable VB recovery on {wr,up}
wire		t_cfg_vb = cfg_i[16];		//Disable Victim Buffer
wire [2:0]	t_cfg_skid = cfg_i[15:13];	//VB almost full recall
wire [2:0]	t_cfg_throttle = cfg_i[12:10];	//One request every n cycles
wire		t_cfg_single = cfg_i[9];	//depipelined
wire		t_cfg_stall_p1 = cfg_i[8];	//Stall if p1 valid
wire		t_cfg_stall_p2 = cfg_i[7];	//Stall if p2 valid
wire		t_cfg_stall_rr = cfg_i[6];	//Stall if retry pending
wire		t_cfg_stall_wr = cfg_i[5];	//Stall until TM writes
wire		t_cfg_retry_rc = cfg_i[4];	//Retry if Recalling
wire		t_cfg_retry_bb = cfg_i[3];	//Retry back-2-back collision
wire [WN-1:0]	t_cfg_busy = cfg_busy_i;	//Mark individual ways as busy
wire [FN-1:0]	t_cfg_null_err = cfg_filter_i;	//Null filter on errors
wire		t_cfg_null_rtr = cfg_i[2];	//Turn retry into NULL response
wire		t_cfg_null_all = cfg_i[1];	//NULL filter always
wire		t_cfg_alloc = cfg_i[0];		//all requests allocate a way
wire		t_cfg_atomic_update = 1'b1;	//update is atomic operation

wire		q_t_cfg_init;

\=u.dffre(1, 'q_t_cfg_init', 't_cfg_init', "1'b0", 'dff_enable', 'clk_i', 'reset_ni')=\

assign idle_o = q_init_count_idle & ~(~t_cfg_init & q_t_cfg_init) &
		~w_p1_valid_dup & ~w_p2_valid_dup & ~w_rr_valid & (~| n_rc_valids);


assign t_cid = ((dm_cmd_req_type_i==CmdWrStshFull) |
		(dm_cmd_req_type_i==CmdWrStshPtl) |
		(dm_cmd_req_type_i==CmdLdCchShd) |
		(dm_cmd_req_type_i==CmdLdCchUnq)) ? dm_cmd_req_sid_i : 
						    dm_cmd_req_iid_i;
\=u.instance({
	moduleName: 'dce_mux',
	instanceName: 'req_mux',
	params: {
		assertOn: assertOn,
		DW:		W_ES+W_MPF1+W_MPF2+IW+AW+IW+TW+1,
		NUM:		2
	},
	ports: {
		clk_i:		'clk_i',
		reset_ni:	'reset_ni',
		ready_o:	'{dm_cmd_req_ready_o, dm_upd_req_ready_o}',
		valid_i:	'{dm_cmd_req_valid_i, dm_upd_req_valid_i}',
		data_i:		`{dm_cmd_req_es_i, dm_cmd_req_mpf1_i, dm_cmd_req_mpf2_i, dm_cmd_req_iid_i, dm_cmd_req_ns_i, dm_cmd_req_addr_i, 
				  t_cid, dm_cmd_req_type_i, dm_cmd_req_wakeup_i,
				  {W_ES{1'b0}}, {W_MPF1{1'b0}}, {W_MPF2{1'b0}}, dm_upd_req_iid_i, dm_upd_req_ns_i, dm_upd_req_addr_i, 
				  dm_upd_req_iid_i, UpdInv, 1'b0}`,
		ready_i:	'n_p0_ready',
		valid_o:	'w_p0_valid',
		data_o:		'{w_p0_es, w_p0_mpf1, w_p0_mpf2, w_p0_initiator_id, w_p0_addr, w_p0_iid, w_p0_type, w_p0_wakeup}',
		bvsel_i:	't_p0_sel'
	}
})=\

assign w_p0_upd = w_p0_valid & t_p0_sel[0];

assign t_p0_sel = dm_write_valid_i
                | (| q_flush)
                | (t_cfg_atomic_update & w_p1_valid & w_p1_upd)
                | (t_cfg_stall_update & dm_upd_req_valid_i & (w_p1_valid | w_p2_valid))
                | (t_cfg_stall_p1 & w_p1_valid)
                | (t_cfg_stall_p2 & w_p2_valid)
                | (w_p2_valid & w_p2_upd)
                | (w_p1_valid & w_p1_upd)
\js if (useSramInputFlop) {
                | (w_p0plus_valid & w_p0plus_upd) |
\js }
                | (| q_init_count[2:0])
                | ~q_reset_n
                | t_init_valid
                | (~dm_upd_req_valid_i & ~dm_recall_ready_i)
                | (~dm_upd_req_valid_i & ~w_rr_ready)
                | (~dm_upd_req_valid_i & w_rr_af & t_cfg_stall_rr)
\jsbegin
/* istanbul ignore else env ncore_3p7 */
if (useSramInputFlop) {
\jsend
                | (~dm_upd_req_valid_i & w_rr_af)
\js } else {
                | (~dm_upd_req_valid_i & w_rr_af      & (w_p1_valid | w_p2_valid))
\js }
                | (~dm_upd_req_valid_i & t_cfg_single & (w_p1_valid | w_p2_valid))
                ? 2'b00

                : dm_upd_req_valid_i
                ? 2'b01

                : 2'b10;

    \=u.instance({
        instanceName: 'att_enc',
        moduleName: 'encoder',
        params: { width : ATN },
        ports: {
            invector  : 'dm_cmd_req_att_vec_i',
            outdecode : 'w_p0_aid'
        }
    })=\

assign t_p0_lookup = w_p0_valid & n_p0_ready;
assign t_p1_busy = w_p1_busy | t_cfg_busy;

assign w_wr_valid = w_wr_valid_sf0;

\js for (var gd=0; gd<FN; gd++) {
    \js if (gd < Math.max(Math.floor(FN/2),1)) {
assign w_wr_valid_sf\=gd=\  = t_wr_sel & dm_write_valid_i;
assign w_wr_addr_sf\=gd=\   = {dm_write_ns_i, dm_write_addr_i};
assign w_wr_ways_sf\=gd=\   = dm_write_way_vec_i;
assign w_wr_oval_sf\=gd=\   = dm_write_owner_val_i;
assign w_wr_owner_sf\=gd=\  = dm_write_owner_num_i;
assign w_wr_sbv_sf\=gd=\    = dm_write_sharer_vec_i;
assign w_wr_change_sf\=gd=\ = dm_write_change_vec_i;
assign t_init_valid_sf\=gd=\ = t_init_valid;
assign t_init_addr_sf\=gd=\  = t_init_addr;
    \js if (usePLRU) {
assign f\=gd=\_plru_mem_init = t_init_valid;
assign f\=gd=\_plru_mem_init_addr = t_init_addr[\=m.log2ceil(SFI[gd].nSets)-1=\:0];
    \js }
    \js } else {
assign w_wr_valid_sf\=gd=\  = t_wr_sel_dup & dm_write_valid_dup_i;
assign w_wr_addr_sf\=gd=\   = {dm_write_ns_dup_i, dm_write_addr_dup_i};
assign w_wr_ways_sf\=gd=\   = dm_write_way_vec_dup_i;
assign w_wr_oval_sf\=gd=\   = dm_write_owner_val_dup_i;
assign w_wr_owner_sf\=gd=\  = dm_write_owner_num_dup_i;
assign w_wr_sbv_sf\=gd=\    = dm_write_sharer_vec_dup_i;
assign w_wr_change_sf\=gd=\ = dm_write_change_vec_dup_i;
assign t_init_valid_sf\=gd=\ = t_init_valid_dup;
assign t_init_addr_sf\=gd=\  = t_init_addr_dup;
    \js if (usePLRU) {
assign f\=gd=\_plru_mem_init = t_init_valid_dup;
assign f\=gd=\_plru_mem_init_addr = t_init_addr_dup[\=m.log2ceil(SFI[gd].nSets)-1=\:0];
    \js }
    \js }
\js }

assign dm_write_ready_o = t_wr_sel & n_wr_ready;

assign n_wr_ready = 1'b1;

assign t_wr_sel = ((| t_cfg_throttle) & (q_init_count[2:0] != 3'h1))
                | (t_cfg_atomic_update & w_p1_valid & w_p1_upd)
                | (t_cfg_stall_update & dm_upd_req_valid_i & (w_p1_valid | w_p2_valid))
                | (t_cfg_stall_p1 & w_p1_valid)
                | (t_cfg_stall_p2 & w_p2_valid)
                | (w_p2_valid & w_p2_upd)
                | (| q_flush)
                | ~q_reset_n
                | t_init_valid
                ? 1'b0
                : 1'b1;

assign t_wr_sel_dup = ((| t_cfg_throttle) & (q_init_count_dup[2:0] != 3'h1))
                | (t_cfg_atomic_update & w_p1_valid_dup & w_p1_upd_dup)
                | (t_cfg_stall_update & dm_upd_req_valid_i & (w_p1_valid_dup | w_p2_valid_dup))
                | (t_cfg_stall_p1 & w_p1_valid_dup)
                | (t_cfg_stall_p2 & w_p2_valid_dup)
                | (w_p2_valid_dup & w_p2_upd_dup)
                | (| q_flush_dup)
                | ~q_reset_n_dup
                | t_init_valid_dup
                ? 1'b0
                : 1'b1;

\jsbegin

var TotalAgents = 0;
var TotalWays = 0;

for (var gd=0; gd<FN; gd=gd+1) {

    var dce_dir_ports = {
		my_fid_i:	FW+"'d"+gd,
		CachingAgents:	'CachingAgents',
		clk_i:		'clk_i',
		reset_ni:	'reset_ni',
		cfg_bb_i:	't_cfg_retry_bb',
		cfg_rc_i:	't_cfg_rc',
		cfg_vb_i:	't_cfg_vb',
		cfg_wb_i:	't_cfg_wb',
		cfg_skid_i:	't_cfg_skid',
		cfg_null_i:	't_cfg_null_err['+gd+']',
		cfg_save_i:	't_cfg_save',
		in_valid_i:	't_init_valid_sf'+gd,
		in_addr_i:	't_init_addr_sf'+gd,
		wr_valid_i:	'w_wr_valid_sf'+gd,
		wr_addr_i:	'w_wr_addr_sf'+gd,
		wr_ways_i:	'w_wr_ways_sf'+gd,
		wr_oval_i:	'w_wr_oval_sf'+gd,
		wr_owner_i:	'w_wr_owner_sf'+gd,
		wr_sbv_i:	'w_wr_sbv_sf'+gd,
		wr_change_i:	'w_wr_change_sf'+gd,
		lu_valid_i:	't_p0_lookup',
		lu_addr_i:	'w_p0_addr',
		lu_iid_i:	'w_p0_iid',
		lu_upd_i:	'w_p0_upd',
		lu_wakeup_i:	'w_p0_wakeup',
		lu_home_o:	'w_p0_fbv['+gd+']',
		p1_fid_o:	'w_p1_fids['+(gd*FW)+' +: '+FW+']',
		p1_home_o:	'w_p1_home['+gd+']',
		p1_busy_i:	't_p1_busy',
		p1_alloc_i:	'w_p1_alloc',
		p1_rc_hit_o:	'w_p1_rc_hits['+gd+']',
		p1_rc_hit_i:	't_p1_rc_hit',
		p2_cancel_i:	'w_p2_cancel',
		p2_iid_i:	'w_p2_iid',
		p2_stall_o:	'w_p2_stalls['+gd+']',
		p2_stall_i:	't_p2_stall',
		p2_vretry_o:	'w_p2_vretrys['+gd+']',
		p2_vretry_i:	't_p2_vretry',
		p2_retry_o:	'w_p2_retrys['+gd+']',
		p2_sbv_o:	'w_p2_sbvs['+(gd*TCN)+ ' +: '+TCN+']',
		p2_oval_o:	'w_p2_ovals['+gd+']',
		p2_owner_o:	'w_p2_owners['+(gd*TCW)+' +: '+TCW+']',
		p2_ways_o:	'w_p2_ybvs['+(gd*WN)+' +: '+WN+']',
		p2_uerrs_o:	'w_p2_yuerr['+(gd*WN)+' +: '+WN+']',
		p2_cerrs_o:	'w_p2_ycerr['+(gd*WN)+' +: '+WN+']',
		p2_uindex_o:	'w_p2_uindex['+(gd*AW)+' +: '+AW+']',
		p2_cindex_o:	'w_p2_cindex['+(gd*AW)+' +: '+AW+']',
		p2_wb_o:	'w_p2_wbs['+gd+']',
		p2_vhit_o:	'w_p2_vhits['+gd+']',
		p2_error_o:	'w_p2_errors['+gd+']',
		p2_alloc_o:	'w_p2_allocs['+gd+']',
		p2_up_hit_o:	'w_p2_up_hits['+gd+']',
		p2_rc_hit_o:	'w_p2_rc_hits['+gd+']',
		p2_rc_hit_i:	't_p2_rc_hit',
		rc_ready_i:	'w_rc_readys['+gd+']',
		rc_valid_o:	'n_rc_valids['+gd+']',
		rc_addr_o:	'n_rc_addrs['+(gd*AW)+' +: '+AW+']',
		rc_sbv_o:	'n_rc_sbvs['+(gd*TCN)+' +: '+TCN+']',
		rc_oval_o:	'n_rc_ovals['+gd+']',
		rc_owner_o:	'n_rc_owners['+(gd*TCW)+' +: '+TCW+']',
		ymask_o:	'w_ymask['+(gd*WN)+' +: '+WN+']'
	};
	for (let w=0; w < SFI[gd].nMemory; w++) {
            dce_dir_ports['fm'+w+'_ce_o']    = 'f'+gd+'m'+w+'_ce_o';
            dce_dir_ports['fm'+w+'_we_o']    = 'f'+gd+'m'+w+'_we_o';
            dce_dir_ports['fm'+w+'_addr_o']  = 'f'+gd+'m'+w+'_addr_o';
            dce_dir_ports['fm'+w+'_biten_o'] = 'f'+gd+'m'+w+'_biten_o';
            dce_dir_ports['fm'+w+'_wdata_o'] = 'f'+gd+'m'+w+'_wdata_o';
            dce_dir_ports['fm'+w+'_rdata_i'] = 'f'+gd+'m'+w+'_rdata_i';
	};
    if (usePLRU) {
dce_dir_ports['plru_mem_init']       = 'f'+gd+'_plru_mem_init';
dce_dir_ports['plru_mem_init_addr']  = 'f'+gd+'_plru_mem_init_addr';
dce_dir_ports['plru_mem_read_en']    = 'f'+gd+'_plru_mem_read_en';
dce_dir_ports['plru_mem_read_addr']  = 'f'+gd+'_plru_mem_read_addr';
dce_dir_ports['plru_mem_read_data']  = 'f'+gd+'_plru_mem_read_data';
dce_dir_ports['plru_mem_write_en']   = 'f'+gd+'_plru_mem_write_en';
dce_dir_ports['plru_mem_write_addr'] = 'f'+gd+'_plru_mem_write_addr';
dce_dir_ports['plru_mem_write_data'] = 'f'+gd+'_plru_mem_write_data';
    }

\jsend

\=u.instance({
	moduleName: 'dce_dir',
	instanceName: 'dce_dir'+gd,
	params: {ARST: ARST,
		 DARST: DARST,
		 EARST: EARST,
		 UIDW: UIDW,
		 AW: AW,
		 WN: WN,
		 TCW: TCW,
		 TCN: TCN,
		 IW: IW,
		 FN: FN,
		 MSW: MSW,
		 MNW: MNW,

                 SFI: SFI[gd],

                 CBASE: TotalAgents,
                 YBASE: TotalWays,
                 FCN: SFI[gd].nCachingAgents,
                 VB: SFI[gd].nVictimEntries,
                 WAYS: SFI[gd].nWays,
                 SETS: SFI[gd].nSets,
                 MGN: SFI[gd].nMemory,
                 PROT: (SFI[gd].TagFilterErrorInfo.fnErrDetectCorrect=="NONE") ? 0 :
                       (SFI[gd].TagFilterErrorInfo.fnErrDetectCorrect=="PARITY") ? 1 : SFI[gd].wEntry,


                 PriSubDiagAddrBits: SFI[gd].SetSelectInfo.PriSubDiagAddrBits,
                 SecSubRows: SFI[gd].SetSelectInfo.SecSubRows,
                 assertOn: assertOn,
                 usePLRU: usePLRU,
                 useSramInputFlop: useSramInputFlop,

		 CLO: CLO,
		 TMNW: SFI[gd].wEntry},
	verilogParams: {
		DRST:		'DRST',
		FID:		gd,
		UpdInv:		'UpdInv'
	},
	ports: dce_dir_ports,
	portsDelimiter: '\n\t'
})=\

\jsbegin

        TotalAgents = TotalAgents + SFI[gd].nCachingAgents;
        TotalWays = TotalWays + SFI[gd].nWays;

}

\jsend

assign dm_upd_status_o = {(w_p2_valid_dup & w_p2_upd_dup & ~t_p2_stall), 
			  (| w_p2_up_hits)};

assign dm_upd_status_valid_o = w_p2_valid_dup & w_p2_upd_dup & ~t_p2_stall;

assign t_p1_rc_hit = (| w_p1_rc_hits) | (t_cfg_retry_rc & (| n_rc_valids));
assign t_p2_rc_hit = (| w_p2_rc_hits) | (t_cfg_retry_rc & (| n_rc_valids));
assign t_p2_vretry = (| w_p2_vretrys) | q_flush[1];
assign t_p2_stall = (| w_p2_stalls) & ((~| q_flush) | q_flush[1]);

assign dm_t_p2_stall_o = t_p2_stall;

\=u.instance({
	moduleName: 'dce_ror',
	instanceName: 'ror_fid',
	params: {},
	verilogParams: {
		NUM:		'FN',
		DW:		'FW'
	},
	ports: {
		vec_i:		'w_p1_fids',
		ror_o:		'w_p1_fid'
	},
	portsDelimiter: '\n\t'
})=\
assign dm_cmd_req1_filter_num_o = w_p1_fid;
assign dm_cmd_req1_filter_vec_o = w_p1_home;

\=u.instance({
	moduleName: 'dce_ror',
	instanceName: 'ror_sbv',
	params: {},
	verilogParams: {
		NUM:		'FN',
		DW:		'TCN'
	},
	ports: {
		vec_i:		'w_p2_sbvs',
		ror_o:		'w_p2_sbv'
	},
	portsDelimiter: '\n\t'
})=\

assign w_p2_oval = (| w_p2_ovals);

\=u.instance({
	moduleName: 'dce_ror',
	instanceName: 'ror_owner',
	params: {},
	verilogParams: {
		NUM:		'FN',
		DW:		'TCW'
	},
	ports: {
		vec_i:		'w_p2_owners',
		ror_o:		'w_p2_owner'
	},
	portsDelimiter: '\n\t'
})=\

\=u.instance({
	moduleName: 'dce_ror',
	instanceName: 'ror_way',
	params: {},
	verilogParams: {
		NUM:		'FN',
		DW:		'WN'
	},
	ports: {
		vec_i:		'w_p2_ybvs',
		ror_o:		'w_p2_ybv'
	},
	portsDelimiter: '\n\t'
})=\

\jsbegin
/* istanbul ignore else env ncore_3p7 */
if (useSramInputFlop) {
\jsend

    \=u.instance({
        moduleName: 'dce_stage_type0',
        instanceName: 'p0plus',
        params: {
            assertOn: assertOn,
            DUPS : 0,
            WIDTH : W_ES+W_MPF1+W_MPF2+IW+TW+AW+IW+1+ATW
        },
        ports: {
            clk_i:      'clk_i',
            reset_ni:   'reset_ni',
            wr_ready_o: 'n_p0_ready',
            wr_valid_i: 'w_p0_valid',
            wr_wdata_i: '{w_p0_es, w_p0_mpf1, w_p0_mpf2, w_p0_initiator_id, w_p0_type, w_p0_addr, w_p0_iid, w_p0_upd, w_p0_aid}',
            rd_ready_i: 'n_p0plus_ready',
            rd_valid_o: 'w_p0plus_valid',
            rd_rdata_o: '{w_p0plus_es, w_p0plus_mpf1, w_p0plus_mpf2, w_p0plus_initiator_id, w_p0plus_type, w_p0plus_addr, w_p0plus_iid, w_p0plus_upd, w_p0plus_aid}'
        }
    })=\


    \=u.instance({
        moduleName: 'dce_stage_type0',
        instanceName: 'p1',
        params: {
            assertOn: assertOn,
            DUPS : 1,
            WIDTH : W_ES+W_MPF1+W_MPF2+IW+TW+AW+IW+1+ATW
        },
        ports: {
            clk_i:      'clk_i',
            reset_ni:   'reset_ni',
            wr_ready_o: 'n_p0plus_ready',
            wr_valid_i: 'w_p0plus_valid',
            wr_wdata_i: '{w_p0plus_es, w_p0plus_mpf1, w_p0plus_mpf2, w_p0plus_initiator_id, w_p0plus_type, w_p0plus_addr, w_p0plus_iid, w_p0plus_upd, w_p0plus_aid}',
            rd_ready_i: 'n_p1_ready',
            rd_valid_o: 'w_p1_valid',
            rd_rdata_o: '{w_p1_es, w_p1_mpf1, w_p1_mpf2, w_p1_initiator_id, w_p1_type, w_p1_addr, w_p1_iid, w_p1_upd, w_p1_aid}',
            rd_valid0_o: 'w_p1_valid_dup',
            rd_rdata0_o: '{w_p1_es_dup, w_p1_mpf1_dup, w_p1_mpf2_dup, w_p1_initiator_id_dup, w_p1_type_dup, w_p1_addr_dup, w_p1_iid_dup, w_p1_upd_dup, w_p1_aid_dup}'
        }
    })=\

\js } else {

    \=u.instance({
        moduleName: 'dce_stage_type0',
        instanceName: 'p1',
        params: {
            assertOn: assertOn,
            DUPS : 1,
            WIDTH : W_ES+W_MPF1+W_MPF2+IW+TW+AW+IW+1+ATW
        },
        ports: {
            clk_i:      'clk_i',
            reset_ni:   'reset_ni',
            wr_ready_o: 'n_p0_ready',
            wr_valid_i: 'w_p0_valid',
            wr_wdata_i: '{w_p0_es, w_p0_mpf1, w_p0_mpf2, w_p0_initiator_id, w_p0_type, w_p0_addr, w_p0_iid, w_p0_upd, w_p0_aid}',
            rd_ready_i: 'n_p1_ready',
            rd_valid_o: 'w_p1_valid',
            rd_rdata_o: '{w_p1_es, w_p1_mpf1, w_p1_mpf2, w_p1_initiator_id, w_p1_type, w_p1_addr, w_p1_iid, w_p1_upd, w_p1_aid}',
            rd_valid0_o: 'w_p1_valid_dup',
            rd_rdata0_o: '{w_p1_es_dup, w_p1_mpf1_dup, w_p1_mpf2_dup, w_p1_initiator_id_dup, w_p1_type_dup, w_p1_addr_dup, w_p1_iid_dup, w_p1_upd_dup, w_p1_aid_dup}'
        }
    })=\

\js }

    \=u.instance({
        moduleName: 'dce_stage_type1',
        instanceName: 'r1',
        params: {
            assertOn: assertOn,
            WIDTH : WN+2
        },
        ports: {
            clk_i:      'clk_i',
            reset_ni:   'reset_ni',
            wr_ready_o: '',
            wr_valid_i: 'w_p1_valid',
            wr_wdata_i: '{dm_cmd_req1_cancel_i, dm_cmd_req1_alloc_i, dm_cmd_req1_busy_vec_i}',
            rd_ready_i: 'n_p1_ready',
            rd_valid_o: '',
            rd_rdata_o: '{w_p1_cancel, w_p1_alloc, w_p1_busy}'
        }
    })=\

assign dm_cmd_req1_valid_o = w_p1_valid & n_p1_ready & ~w_p1_upd;

    \=u.instance({
        moduleName: 'dce_stage_type0',
        instanceName: 'p2',
        params: {
            assertOn: assertOn,
            DUPS : 1,
            WIDTH : W_ES+W_MPF1+W_MPF2+IW+TW+1+AW+IW+1+FW+ATW
        },
        ports: {
            clk_i:      'clk_i',
            reset_ni:   'reset_ni',
            wr_ready_o: 'n_p1_ready',
            wr_valid_i: 'w_p1_valid',
            wr_wdata_i: '{w_p1_es, w_p1_mpf1, w_p1_mpf2, w_p1_initiator_id, w_p1_type, w_p1_cancel, w_p1_addr, w_p1_iid, w_p1_upd, w_p1_fid, w_p1_aid}',
            rd_ready_i: 'n_p2_ready',
            rd_valid_o: 'w_p2_valid',
            rd_rdata_o: '{w_p2_es, w_p2_mpf1, w_p2_mpf2, w_p2_initiator_id, w_p2_type, w_p2_cancel, w_p2_addr, w_p2_iid, w_p2_upd, w_p2_fid, w_p2_aid}',
            rd_valid0_o: 'w_p2_valid_dup',
            rd_rdata0_o: '{w_p2_es_dup, w_p2_mpf1_dup, w_p2_mpf2_dup, w_p2_initiator_id_dup, w_p2_type_dup, w_p2_cancel_dup, w_p2_addr_dup, w_p2_iid_dup, w_p2_upd_dup, w_p2_fid_dup, w_p2_aid_dup}'
        }
    })=\

assign dm_rsp_lookup_initiator_id = w_p2_initiator_id;
assign dm_rsp_lookup_cm_type      = w_p2_type;
assign dm_rsp_lookup_mpf2         = w_p2_mpf2;
assign dm_rsp_lookup_es           = w_p2_es;
assign {dm_rsp_lookup_ns, dm_rsp_lookup_addr} = w_p2_addr;

\jsbegin
/* istanbul ignore else env ncore_3p7 */
if (useSramInputFlop) {
\jsend

    \=u.instance({
	moduleName: 'dce_demux',
	instanceName: 'rr_demux',
	params: {
		DW:		1,
		NUM:		3,
		assertOn: assertOn
	},
	ports: {
		clk_i:		'clk_i',
		reset_ni:	'reset_ni',
		ready_o:	'n_p2_ready',
		valid_i:	'w_p2_valid',
		data_i:		`1'b0`,
		ready_i:	`{1'b1,       1'b1,       1'b1}`,
		valid_o:	`{n_up_valid, n_rr_valid, dm_cmd_rsp_valid_o}`,
		data_o:		'',
		bvsel_i:	't_rs_sel'
	}
    })=\

\js } else {

    \=u.instance({
	moduleName: 'dce_demux',
	instanceName: 'rr_demux',
	params: {
		DW:		1,
		NUM:		3,
		assertOn: assertOn
	},
	ports: {
		clk_i:		'clk_i',
		reset_ni:	'reset_ni',
		ready_o:	'n_p2_ready',
		valid_i:	'w_p2_valid',
		data_i:		`1'b0`,
		ready_i:	`{1'b1,       w_rr_ready, dm_cmd_rsp_ready_i}`,
		valid_o:	`{n_up_valid, n_rr_valid, dm_cmd_rsp_valid_o}`,
		data_o:		'',
		bvsel_i:	't_rs_sel'
	}
    })=\

\js }

assign t_rs_sel = t_p2_stall ? 3'h0 :
		  (w_p2_valid & (w_p2_upd | w_p2_cancel)) ? 3'h4 :
		  (w_p2_valid & (| w_p2_retrys))          ? 3'h2 :
							3'h1;

assign dm_cmd_rsp_att_vec_o = ({{ATN-1{1'b0}}, 1'b1} << w_p2_aid);
assign dm_cmd_rsp_way_vec_o = w_p2_ybv;
assign dm_cmd_rsp_owner_val_o = w_p2_oval;
assign dm_cmd_rsp_owner_num_o = w_p2_owner;
assign dm_cmd_rsp_sharer_vec_o = w_p2_sbv;
assign dm_cmd_rsp_wr_required_o = (| w_p2_wbs);
assign dm_cmd_rsp_vb_hits_o = w_p2_vhits;
assign dm_cmd_rsp_error_o = (| w_p2_errors);

assign w_p2_aid_onehot = ({{ATN-1{1'b0}}, 1'b1} << w_p2_aid);

assign n_rr_ready = dm_rtr_ready_i;

    \=u.instance({
        moduleName: 'dce_stage_type3',
        instanceName: 'rr',
        params: {
            assertOn: assertOn,
            DEPTH : RRD,
            WIDTH : W_ES + W_MPF2 + W_MPF1 + W_INIT_ID + W_ADDR + W_NS + W_CM_TYPE + FW + ATN,
            AF :    RRD - PIPEDEPTH
        },
        ports: {
            clk_i:      'clk_i',
            reset_ni:   'reset_ni',
            wr_af_o:	'w_rr_af',
            wr_ready_o:	'w_rr_ready',
            wr_valid_i:	'n_rr_valid',
            wr_wdata_i:	'{w_p2_es, w_p2_mpf2, w_p2_mpf1, w_p2_initiator_id, w_p2_addr, w_p2_type, w_p2_fid, w_p2_aid_onehot}',
            rd_ready_i:	'n_rr_ready',
            rd_valid_o:	'w_rr_valid',
            rd_rdata_o:	'{dm_rtr_req_es, dm_rtr_req_mpf2, dm_rtr_req_mpf1, dm_rtr_req_initiator_id, dm_rtr_req_ns, dm_rtr_req_addr, dm_rtr_req_cm_type, w_rr_fid, w_rr_aid_onehot}'
        }
    })=\

assign dm_rtr_valid_o = w_rr_valid;
assign dm_rtr_att_vec_o = w_rr_aid_onehot;
//assign dm_rtr_filter_num_o = w_rr_fid;
assign dm_rtr_filter_vec_o = \=FN=\'b1 << w_rr_fid;
\js if (FN > 1) {
assign dm_rtr_way_mask_o = w_ymask[w_rr_fid*WN +: WN];
\js } else {
assign dm_rtr_way_mask_o = w_ymask[0 +: WN];
\js }


wire 			q_w_p2_valid;
wire [AW-1:0]		q_w_p2_addr;
wire [FN*AW-1:0]	q_w_p2_uindex,
			q_w_p2_cindex;
wire [FN*WN-1:0]	q_w_p2_yuerr, 
			q_w_p2_ycerr;

\=u.dffre(1,     'q_w_p2_valid',  'w_p2_valid',             "1'b0",   'dff_enable', 'clk_i', 'reset_ni')=\
\=u.dffre(AW,    'q_w_p2_addr',   'w_p2_addr',      "{"+AW+"{1'b0}}", 'dff_enable', 'clk_i', 'reset_ni')=\
\=u.dffre(FN*AW, 'q_w_p2_uindex', 'w_p2_uindex', "{"+FN*AW+"{1'b0}}", 'dff_enable', 'clk_i', 'reset_ni')=\
\=u.dffre(FN*AW, 'q_w_p2_cindex', 'w_p2_cindex', "{"+FN*AW+"{1'b0}}", 'dff_enable', 'clk_i', 'reset_ni')=\
\=u.dffre(FN*WN, 'q_w_p2_yuerr',  'w_p2_yuerr',  "{"+FN*WN+"{1'b0}}", 'dff_enable', 'clk_i', 'reset_ni')=\
\=u.dffre(FN*WN, 'q_w_p2_ycerr',  'w_p2_ycerr',  "{"+FN*WN+"{1'b0}}", 'dff_enable', 'clk_i', 'reset_ni')=\

assign dm_error_uerr_o = q_w_p2_valid & (| q_w_p2_yuerr);
assign dm_error_cerr_o = q_w_p2_valid & (| q_w_p2_ycerr);
assign dm_error_addr_o = q_w_p2_addr;

\=u.instance({
	moduleName: 'dce_ror',
	instanceName: 'ror_uway',
	params: {},
	verilogParams: {
		NUM:		'FN',
		DW:		'WN'
	},
	ports: {
		vec_i:		'q_w_p2_yuerr',
		ror_o:		'dm_error_uway_vec_o'
	}
})=\

\=u.instance({
	moduleName: 'dce_ror',
	instanceName: 'ror_cway',
	params: {},
	verilogParams: {
		NUM:		'FN',
		DW:		'WN'
	},
	ports: {
		vec_i:		'q_w_p2_ycerr',
		ror_o:		'dm_error_cway_vec_o'
	}
})=\

\=u.instance({
	moduleName: 'dce_ror',
	instanceName: 'ror_uindex',
	params: {},
	verilogParams: {
		NUM:		'FN',
		DW:		'AW'
	},
	ports: {
		vec_i:		'q_w_p2_uindex',
		ror_o:		'dm_error_uindex_o'
	}
})=\

\=u.instance({
	moduleName: 'dce_ror',
	instanceName: 'ror_cindex',
	params: {},
	verilogParams: {
		NUM:		'FN',
		DW:		'AW'
	},
	ports: {
		vec_i:		'q_w_p2_cindex',
		ror_o:		'dm_error_cindex_o'
	}
})=\



\=u.instance({
	moduleName: 'dce_mux',
	instanceName: 'rc_oval',
	params: {
		assertOn: assertOn,
		DW:		1,
		NUM:		FN
	},
	ports: {
		clk_i:		'clk_i',
		reset_ni:	'reset_ni',
		ready_o:	'w_rc_readys',
		valid_i:	'n_rc_valids',
		data_i:		'n_rc_ovals',
		ready_i:	'dm_recall_ready_i',
		valid_o:	'dm_recall_valid_o',
		data_o:		'dm_recall_owner_val_o',
		bvsel_i:	'w_rc_sel'
	}
})=\

\=u.instance({
	moduleName: 'dce_mux',
	instanceName: 'rc_addr',
	params: {
		assertOn: assertOn,
		DW:		AW,
		NUM:		FN
	},
	ports: {
		clk_i:		'clk_i',
		reset_ni:	'reset_ni',
		ready_o:	'',
		valid_i:	'n_rc_valids',
		data_i:		'n_rc_addrs',
		ready_i:	'dm_recall_ready_i',
		valid_o:	'',
		data_o:		'{dm_recall_ns_o, dm_recall_addr_o}',
		bvsel_i:	'w_rc_sel'
	}
})=\

\=u.instance({
	moduleName: 'dce_mux',
	instanceName: 'rc_sbv',
	params: {
		assertOn: assertOn,
		DW:		TCN,
		NUM:		FN
	},
	ports: {
		clk_i:		'clk_i',
		reset_ni:	'reset_ni',
		ready_o:	'',
		valid_i:	'n_rc_valids',
		data_i:		'n_rc_sbvs',
		ready_i:	'dm_recall_ready_i',
		valid_o:	'',
		data_o:		'dm_recall_sharer_vec_o',
		bvsel_i:	'w_rc_sel'
	}
})=\

\=u.instance({
	moduleName: 'dce_mux',
	instanceName: 'rc_owner',
	params: {
		assertOn: assertOn,
		DW:		TCW,
		NUM:		FN
	},
	ports: {
		clk_i:		'clk_i',
		reset_ni:	'reset_ni',
		ready_o:	'',
		valid_i:	'n_rc_valids',
		data_i:		'n_rc_owners',
		ready_i:	'dm_recall_ready_i',
		valid_o:	'',
		data_o:		'dm_recall_owner_num_o',
		bvsel_i:	'w_rc_sel'
	}
})=\

\=u.instance({
        moduleName: 'dce_dir_arb',
        instanceName: 'rc_arb',
        params: { DW: FN },
        ports: {
                clk:            'clk_i',
                reset_n:        'reset_ni',
                ready_i:        'dm_recall_ready_i',
                bv_i:           'n_rc_valids',
                wbv_o:          'w_rc_sel'
        }
})=\

assign t_init_addr = {AW{1'b0}} | q_init_count;
assign t_init_addr_dup = {AW{1'b0}} | q_init_count_dup;

\=u.dffre(1,     'q_reset_n',    'reset_n_in',    "1'b0",              'dff_enable', 'clk_i', 'reset_ni')=\
\=u.dffre(ICW,   'q_init_count', 'init_count_in', "{"+ICW+"{1'b0}}",   'dff_enable', 'clk_i', 'reset_ni')=\
\=u.dffre(2,     'q_flush',      'flush_in',      "2'b0",              'dff_enable', 'clk_i', 'reset_ni')=\

\=u.dffre(1,     'q_reset_n_dup',    'reset_n_in',    "1'b0",              'dff_enable', 'clk_i', 'reset_ni')=\
\=u.dffre(ICW,   'q_init_count_dup', 'init_count_in', "{"+ICW+"{1'b0}}",   'dff_enable', 'clk_i', 'reset_ni')=\
\=u.dffre(2,     'q_flush_dup',      'flush_in',      "2'b0",              'dff_enable', 'clk_i', 'reset_ni')=\

wire   t_init_valid_in = reset_n_in & ~init_count_in[MSW] & ~cfg_init_i;

wire   init_count_idle_in = ((~| init_count_in) | init_count_in[MSW]) & ~t_init_valid_in;

\=u.dffre(1, 't_init_valid',     't_init_valid_in', "1'b0", 'dff_enable', 'clk_i', 'reset_ni')=\
\=u.dffre(1, 't_init_valid_dup', 't_init_valid_in', "1'b0", 'dff_enable', 'clk_i', 'reset_ni')=\

\=u.dffre(1, 'q_init_count_idle', 'init_count_idle_in', "1'b1", 'dff_enable', 'clk_i', 'reset_ni')=\

assign reset_n_in = t_cfg_init ? 1'b0 :
		     q_reset_n ? q_reset_n : 
				 1'b1;

assign init_count_in = t_cfg_init ? {MSW+1{1'b0}} :
			(q_reset_n & q_init_count[MSW] & 
			 (q_init_count[2:0] == t_cfg_throttle) &
			 (| t_cfg_throttle)) ? {1'b1, {MSW{1'b0}}} :
			(((| t_cfg_throttle) | ~q_init_count[MSW]) &
			 q_reset_n) ? q_init_count + 1'b1 :
				      q_init_count;

assign flush_in = q_flush[1] ? {1'b0, (w_p0_valid | w_p1_valid)} :
		   q_flush[0] ? 2'h2 :
		   t_p2_stall ? 2'b1 :
				q_flush;


assign csr_DceMntOpActive_o = t_init_valid;

\jsbegin
/* istanbul ignore else env ncore_3p7 */
if (assertOn) { \jsend
`ifdef OVL_ASSERT_ON
//coverage off
//pragma synthesis_off


function automatic integer ioaiu_log (input integer num);
begin: func_ioaiu_log
integer num_m1;
        num_m1 = (num > 1) ? num - 1 : num;
        for (ioaiu_log=0; num_m1>0; ioaiu_log=ioaiu_log+1) begin
                num_m1 = num_m1 >> 1;
        end
end
endfunction

function automatic integer ioaiu_sum (input [1023:0] num);
begin: func_ioaiu_sum
        for (ioaiu_sum=(num%2); num>0; ioaiu_sum=ioaiu_sum+(num%2)) begin
                num = (num >> 1);
        end
end
endfunction


reg a_error_test;

initial begin
	if ($test$plusargs("error_test")) begin
		a_error_test = 1'b1;
	end else begin
		a_error_test = 1'b0;
	end
end

assert_never #(0) assert_param(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	((ATN<2) | (FN<1) | (TCN<1) | (FN>TCN) | (AW<1) | 
			 (IW<1) | (TW != 8) | (RRD<3) | 
			 (MSW<4) |
			 (TCW != ioaiu_log(TCN)) | 
			 (WW != ioaiu_log(WN)))
);

assert_never #(0) assert_pipe(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	((t_p0_lookup & w_wr_valid) |
			 (ioaiu_sum(w_p2_allocs)>1) |
			 (w_p2_valid & (dm_cmd_rsp_error_o ^ (| w_p2_yuerr))) |
			 (w_p1_valid & ~n_p1_ready & ~t_p2_stall) |
			 (w_p2_valid & ~n_p2_ready & ~t_p2_stall) |
			 (w_p2_valid & ~w_rr_ready))
					      
);

assert_never #(0) assert_recall(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	((t_p2_rc_hit & dm_cmd_rsp_valid_o & ~w_p2_cancel) |
			 (t_p2_rc_hit & ~n_rr_valid & ~w_p2_upd & ~w_p2_cancel & ~t_p2_stall)|
			 (dm_recall_valid_o & 
		((~dm_recall_owner_val_o & (~| dm_recall_sharer_vec_o)) |
		 (~dm_recall_owner_val_o & (| dm_recall_owner_num_o)))))
);

assert_never #(0) assert_req(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	((dm_cmd_req_valid_i & (dm_cmd_req_type_i==UpdInv)) |
			 (w_p1_valid & (ioaiu_sum(dm_cmd_req1_filter_vec_o)>1))|
			 (dm_rtr_valid_o & (ioaiu_sum(dm_rtr_filter_vec_o)>1)) |
			 (dm_recall_valid_o & ~dm_recall_ready_i & 
			  dm_cmd_req_valid_i & dm_cmd_req_ready_o))
);

assert_never #(0) assert_resp(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	(dm_cmd_rsp_valid_o & ~a_error_test & (
	     ~dm_cmd_rsp_ready_i |
	     (~| dm_cmd_rsp_att_vec_o) |
	     ((| w_p2_allocs) & (~| t_cfg_null_err) & ~t_cfg_null_rtr &
						      ~t_cfg_null_all &
			    (~| dm_cmd_rsp_way_vec_o)) |
	     ((~| t_cfg_null_err) & ~t_cfg_null_rtr & ~t_cfg_null_all &
			    ~w_p2_cancel &
			    (NULL_FILTER==0) & ~dm_cmd_rsp_owner_val_o & 
					     (| dm_cmd_rsp_owner_num_o)) |
	     (((& t_cfg_null_err) | t_cfg_null_rtr | t_cfg_null_all |
			    (NULL_FILTER>0)) & (dm_rtr_valid_o |
						dm_cmd_rsp_owner_val_o |
					    (~& dm_cmd_rsp_owner_num_o) |
					    (~& dm_cmd_rsp_sharer_vec_o))) |
	     ((& t_cfg_null_err) & dm_recall_valid_o) |
	     ((~| t_cfg_null_err) & ~t_cfg_null_rtr & ~t_cfg_null_all & 
				    ~w_p2_cancel &
	      (~| dm_cmd_rsp_way_vec_o) & (| dm_cmd_rsp_sharer_vec_o)) |
	     (~w_p2_cancel & 
	      (~| dm_cmd_rsp_way_vec_o) & dm_cmd_rsp_owner_val_o)))
);

assert_never #(0) assert_write(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	(dm_write_valid_i & ~a_error_test & ((~| dm_write_change_vec_i) |
					     (~| dm_write_way_vec_i) |
			   (dm_write_owner_val_i & (dm_write_owner_num_i>TCN)) |
			   (~dm_write_owner_val_i & (| dm_write_owner_num_i))))
);

assert_never_unknown #(0, 18+MSW+21+WN+FN) assert_unknown_control(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.qualifier	(reset_ni),
	.test_expr	({18+MSW+21+WN+FN{reset_ni}} &
			 {dm_upd_req_ready_o, dm_upd_req_valid_i,
			  dm_cmd_req_ready_o, dm_cmd_req_valid_i,
			  dm_cmd_rsp_ready_i, dm_cmd_rsp_valid_o,
			  dm_recall_ready_i, dm_recall_valid_o,
			  dm_write_ready_o, dm_write_valid_i, 
			  dm_rtr_ready_i, dm_rtr_valid_o, dm_upd_status_o,
			  dm_error_uerr_o, dm_error_cerr_o,
			  q_reset_n, q_init_count, t_cfg_stall_update,
			  t_cfg_vb, t_cfg_skid, t_cfg_throttle, t_cfg_single, 
			  t_cfg_stall_p1, t_cfg_stall_p2, t_cfg_stall_rr, 
			  t_cfg_stall_wr, t_cfg_busy, t_cfg_null_err, 
			  t_cfg_null_rtr, t_cfg_null_all, t_cfg_atomic_update, 
			  t_cfg_alloc, t_cfg_retry_rc, t_cfg_save, t_cfg_rc})
);
assert_never_unknown #(0, AW+IW) assert_unknown_update(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.qualifier	(dm_upd_req_valid_i),
	.test_expr	({AW+IW{reset_ni}} &
			 {dm_upd_req_ns_i, dm_upd_req_addr_i, dm_upd_req_iid_i})
);
assert_never_unknown #(0, AW+IW+IW+TW+ATN+1) assert_unknown_req(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.qualifier	(dm_cmd_req_valid_i),
	.test_expr	({AW+IW+IW+TW+ATN+1{reset_ni}} &
			 {dm_cmd_req_ns_i, dm_cmd_req_addr_i, dm_cmd_req_iid_i,
			  dm_cmd_req_sid_i,dm_cmd_req_wakeup_i,
			  dm_cmd_req_type_i, dm_cmd_req_att_vec_i})
);
assert_never_unknown #(0, WN+2) assert_unknown_req1(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.qualifier	(w_p1_valid),
	.test_expr	({WN+2{reset_ni}} & 
			 {dm_cmd_req1_busy_vec_i, dm_cmd_req1_alloc_i,
			  dm_cmd_req1_cancel_i})
);
assert_never_unknown #(0, ATN+WN+1+TCW+TCN+FN+2) assert_unknown_resp(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.qualifier	(dm_cmd_rsp_valid_o),
	.test_expr	({ATN+WN+1+TCW+TCN+FN+2{reset_ni}} &
			 {dm_cmd_rsp_att_vec_o, dm_cmd_rsp_way_vec_o,
			  dm_cmd_rsp_owner_val_o, dm_cmd_rsp_owner_num_o,
			  dm_cmd_rsp_sharer_vec_o, dm_cmd_rsp_vb_hits_o,
			  dm_cmd_rsp_wr_required_o, dm_cmd_rsp_error_o})
);
assert_never_unknown #(0, AW+TCN+1+TCW) assert_unknown_recall(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.qualifier	(dm_recall_valid_o),
	.test_expr	({AW+TCN+1+TCW{reset_ni}} &
			 {dm_recall_ns_o, dm_recall_addr_o, 
			  dm_recall_sharer_vec_o, dm_recall_owner_val_o, 
			  dm_recall_owner_num_o})
);
assert_never_unknown #(0, AW+WN+1+TCW+TCN+TCN) assert_unknown_write(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.qualifier	(dm_write_valid_i),
	.test_expr	({AW+WN+1+TCW+TCN+TCN{reset_ni}} &
			 {dm_write_ns_i, dm_write_addr_i, dm_write_way_vec_i,
			  dm_write_owner_val_i, dm_write_owner_num_i,
			  dm_write_sharer_vec_i, dm_write_change_vec_i})
);

assert_never_unknown #(0, ATN+FN+WN) assert_unknown_retry(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.qualifier	(dm_rtr_valid_o),
	.test_expr	({ATN+FW+WN{reset_ni}} &
			 {dm_rtr_att_vec_o, 
			  dm_rtr_filter_vec_o, dm_rtr_way_mask_o})
);

assert_never_unknown #(0, WN+AW+AW) assert_unknown_uerror(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.qualifier	(dm_error_uerr_o),
	.test_expr	({WN+AW{reset_ni}} & 
			 {dm_error_uway_vec_o, dm_error_addr_o,
			  dm_error_uindex_o})
);
assert_never_unknown #(0, WN+AW+AW) assert_unknown_cerror(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.qualifier	(dm_error_cerr_o),
	.test_expr	({WN+AW{reset_ni}} & 
			 {dm_error_cway_vec_o, dm_error_addr_o,
			  dm_error_cindex_o})
);

assert_one_hot #(0, ATN) assert_att_rtr(
	.clk		(clk_i),
	.reset_n	(dm_rtr_valid_o),
	.test_expr	(dm_rtr_att_vec_o)
);

assert_one_hot #(0, ATN) assert_att_req(
	.clk		(clk_i),
	.reset_n	(dm_cmd_req_valid_i),
	.test_expr	(dm_cmd_req_att_vec_i)
);
assert_one_hot #(0, ATN) assert_att_resp(
	.clk		(clk_i),
	.reset_n	(dm_cmd_rsp_valid_o),
	.test_expr	(dm_cmd_rsp_att_vec_o)
);

assert_zero_one_hot #(0, FN) assert_fbv(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	({FN{w_p0_valid}} & w_p0_fbv)
);
assert_zero_one_hot #(0, FN) assert_alloc(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	({FN{w_p2_valid}} & w_p2_allocs)
);

assert_zero_one_hot #(0, FN) assert_zoh_oval(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	({FN{w_p2_valid & (~| w_p2_stalls) &
					  (~| q_flush)}} & w_p2_ovals)
);

assert_never #(0) assert_dup(
        .clk            (clk_i),
        .reset_n        (reset_ni),
        .test_expr      (  (t_wr_sel_dup != t_wr_sel)
                         | (w_p2_valid_dup != w_p2_valid)
                         | (w_p1_valid_dup != w_p1_valid)
                         | (w_p2_upd_dup != w_p2_upd)
                         | (w_p1_upd_dup != w_p1_upd)
                         | (t_init_valid_dup != t_init_valid)
                         | (q_flush_dup != q_flush)
                         | (q_init_count_dup != q_init_count)
                         | (q_reset_n_dup != q_reset_n)
                         | (dm_write_valid_dup_i != dm_write_valid_i)
                         | (dm_write_ns_dup_i != dm_write_ns_i)
                         | (dm_write_addr_dup_i != dm_write_addr_i)
                         | (dm_write_way_vec_dup_i != dm_write_way_vec_i)
                         | (dm_write_owner_val_dup_i != dm_write_owner_val_i)
                         | (dm_write_owner_num_dup_i != dm_write_owner_num_i)
                         | (dm_write_sharer_vec_dup_i != dm_write_sharer_vec_i)
                         | (dm_write_change_vec_dup_i != dm_write_change_vec_i)
                        )
);

\js if (useSramInputFlop) {
\js } else {
assert_never #(0) retry_fifo_backpressure (
        .clk(clk_i),
        .reset_n(reset_ni),
        .test_expr(dm_rtr_valid_o & ~dm_rtr_ready_i)
);
\js }

//pragma synthesis_on
//coverage on
`endif
\js }
endmodule

