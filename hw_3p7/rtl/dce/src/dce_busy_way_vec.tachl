\jsbegin
//=============================================================================
// Copyright (C) 2018 Arteris, Inc.
// All rights reserved.
//=============================================================================
// busy way vector generation
//=============================================================================
// Example: W_ADDR = 52, N_WAYS = 40, N_ATT = 4, N_SF = 2;
//
// dce_sf_index_gen_a req_addr_index (
//                 .req_addr       (req_addr),
//                 .sf0_index      (req_sf0_index),
//                 .sf1_index      (req_sf1_index));
//
// generate for (gi=0; gi<N_ATT; gi=gi+1) begin : BUSY_WAY_VEC
// dce_sf_index_gen_a att_addr_index (
//                 .req_addr       (att_addr[gi*W_ADDR +: W_ADDR]),
//                 .sf0_index      (att_sf0_index[gi*9 +: 9]),
//                 .sf1_index      (att_sf1_index[gi*10 +: 10]));
// assign att_sf0_match[gi] = att_valid[gi] & req_valid & (req_sf0_index == att_sf0_index[gi*9 +: 9]);
// assign att_sf1_match[gi] = att_valid[gi] & req_valid & (req_sf1_index == att_sf1_index[gi*10 +: 10]);
// end endgenerate
//
// assign dm_busy_way_vec = {    ({20 {att_sf1_match[0 ]}} & att_way_vec[0*N_WAYS+39 : 0*N_WAYS+20 ]),
//                               ({20 {att_sf0_match[0 ]}} & att_way_vec[0*N_WAYS+19 : 0*N_WAYS+0 ])
//                          }
//                        | {    ({20 {att_sf1_match[1 ]}} & att_way_vec[1*N_WAYS+39 : 1*N_WAYS+20 ]),
//                               ({20 {att_sf0_match[1 ]}} & att_way_vec[1*N_WAYS+19 : 1*N_WAYS+0 ])
//                          }
//                        | {    ({20 {att_sf1_match[2 ]}} & att_way_vec[2*N_WAYS+39 : 2*N_WAYS+20 ]),
//                               ({20 {att_sf0_match[2 ]}} & att_way_vec[2*N_WAYS+19 : 2*N_WAYS+0 ])
//                          }
//                        | {    ({20 {att_sf1_match[3 ]}} & att_way_vec[3*N_WAYS+39 : 3*N_WAYS+20 ]),
//                               ({20 {att_sf0_match[3 ]}} & att_way_vec[3*N_WAYS+19 : 3*N_WAYS+0 ])
//                          };
//=============================================================================

var u = obj.lib;
var m = obj.userLib;

//
// Params
//
let W_ADDR =  m.ParamDefaultGet(u, 'wAddr', 'int', 32);
let N_WAYS = m.ParamDefaultGet(u, 'nWays', 'int', 4);
let N_ATT = m.ParamDefaultGet(u, 'nAtt', 'int', 32);
let SF_INFO = m.ParamDefaultGet(u, 'SnoopFilterInfo', 'array', []);

//
// Ports
//
u.port('input', 'req_valid', 1);
u.port('input', 'req_addr', W_ADDR);
u.port('input', 'att_addr', N_ATT*W_ADDR);
u.port('input', 'att_way_vec', N_ATT*N_WAYS);
u.port('input', 'att_valid', N_ATT);
u.port('output', 'dm_busy_way_vec', N_WAYS);

\jsend

module \=u.getModuleName()=\ (\=u.getPorts()=\ );

localparam
  W_ADDR = \=W_ADDR=\,
  N_WAYS = \=N_WAYS=\,
  N_ATT = \=N_ATT=\;

genvar gi;

// busy way vector generation

\js for (let i=0; i<SF_INFO.length; i++) {
   wire [\=SF_INFO[i].SetSelectInfo.PriSubDiagAddrBits.length=\-1:0] req_sf\=i=\_index;
   wire [\=SF_INFO[i].SetSelectInfo.PriSubDiagAddrBits.length=\*N_ATT-1:0] att_sf\=i=\_index;
   wire [N_ATT-1:0] att_sf\=i=\_match;
\js }
wire [N_ATT-1:0] att_sf_match;   
   
\jsbegin
let req_ports = SF_INFO.reduce(function(res, val, idx) {
                res['sf' + idx + '_index'] = 'req_sf' + idx + '_index';
                return res;
           }, {req_addr : 'req_addr'});
\jsend
   
\=u.instance ({
               instanceName: 'req_addr_index',
               moduleName: 'dce_sf_index_gen',
               params: {
                        wAddr : W_ADDR,
                        SnoopFilterInfo : SF_INFO
                        },
               ports : req_ports
                        
               })=\

\jsbegin
let att_ports = SF_INFO.reduce(function(res, val, idx) {
                res['sf' + idx + '_index'] = 'att_sf' + idx + '_index[gi*' + val.SetSelectInfo.PriSubDiagAddrBits.length + ' +: ' + val.SetSelectInfo.PriSubDiagAddrBits.length +']';
                return res;
           }, {req_addr : 'att_addr[gi*W_ADDR +: W_ADDR]'});

// seprate out way vector on per SF basis
let sf_bitmask_msb = [];
let sf_bitmask_lsb = [];
let bitmask_temp = 0;
for (let i=0; i<SF_INFO.length; i++)
  {
   bitmask_temp += SF_INFO[i].nWays;
   sf_bitmask_msb[i] = bitmask_temp -1; 
   sf_bitmask_lsb[i] = bitmask_temp - SF_INFO[i].nWays; 
   }
\jsend

generate
   for (gi=0; gi<N_ATT; gi=gi+1)
     begin : BUSY_WAY_VEC
        \=u.instance ({
                       instanceName: 'att_addr_index',
                       moduleName: 'dce_sf_index_gen',
                       params: {
                                wAddr : W_ADDR,
                                SnoopFilterInfo : SF_INFO
                                },
                       ports : att_ports             
                       })=\
\js for(let i=0; i<SF_INFO.length; i++) {           
        assign att_sf\=i=\_match[gi] = att_valid[gi] & req_valid & (req_sf\=i=\_index == att_sf\=i=\_index[gi*\=SF_INFO[i].SetSelectInfo.PriSubDiagAddrBits.length=\ +: \=SF_INFO[i].SetSelectInfo.PriSubDiagAddrBits.length=\]);
\js }
     end
endgenerate

assign dm_busy_way_vec = (
\jsbegin
   for (let i=0; i < N_ATT; i=i+1)
                          {
\jsend                      
                           {
\jsbegin 
                            for (let j=SF_INFO.length-1; j>=0; j--) 
                            {
                             if(j==0)
                             {
\jsend                            
                                ({\=SF_INFO[j].nWays=\ {att_sf\=j=\_match[\=i=\ ]}} & att_way_vec[\=i=\*N_WAYS+\=sf_bitmask_msb[j]=\ : \=i=\*N_WAYS+\=sf_bitmask_lsb[j]=\ ])
\js                           } else {                                                                                          
                                ({\=SF_INFO[j].nWays=\ {att_sf\=j=\_match[\=i=\ ]}} & att_way_vec[\=i=\*N_WAYS+\=sf_bitmask_msb[j]=\ : \=i=\*N_WAYS+\=sf_bitmask_lsb[j]=\ ]),
\js                         } }  
                            } |
\js                        }                          
                           {N_WAYS{1'b0}});



endmodule
