//=============================================================================
// Copyright (C) 2017 Arteris, Inc.
// All rights reserved.
//=============================================================================
\jsbegin
// This module defines single transaction table entry
//
//=============================================================================
\jsend

\jsbegin
var u = obj.lib;

var bundleFunctions = obj.userLib.bundleFunctions;
var log2ceil = function(n) { return Math.ceil(Math.log(n)/Math.LN2); };
var unit_id_width   = u.getParam('unit_id_width');
var port_id_width   = u.getParam('port_id_width');
var node_id_width   = u.getParam('node_id_width');
var intf_size_width = u.getParam('intf_size_width');
var dtw_dwid_width  = u.getParam('dtw_dwid_width');
var cm_type         = u.getParam('cm_type');
var chi_cmd         = u.getParam('chi_cmd');
var wData           = u.getParam('wData');
var wAddr           = u.getParam('wAddr');
//var wNdpAux         = u.getParam('wNdpAux');
var wFlit_TxnID          = u.getParam('wFlit_TxnID');
var wDatFlit_TraceTag_local    = u.getParam('wDatFlit_TraceTag_local');
var wSnpFlit_DoNotGoToSD_local = u.getParam('wSnpFlit_DoNotGoToSD_local');
var wSnpFlit_FwdTxnID_local    = u.getParam('wSnpFlit_FwdTxnID_local');
var wSnpFlit_FwdNID_local      = u.getParam('wSnpFlit_FwdNID_local');
var chi_a              = u.getParam('chi_a');
var chi_b              = u.getParam('chi_b');
var chi_e              = u.getParam('chi_e');
var interfaces         = u.getParam('interfaces');
var enPoison = interfaces.chiInt.params.enPoison;
var wDatFlit_Opcode = u.getParam('wDatFlit_Opcode');

var clkInterface = {
    clk: 1,
    reset_n: 1
}
var assertOn = u.getParam('assertOn');
var nEntries  = u.getParam('nSttEntries');
var nDvmSnpInFlight = u.getParam('nDvmSnpInFlight');
var wEntries = Math.max(log2ceil(nEntries),1);
var nOttCtrlEntries  = u.getParam('nOttCtrlEntries'); //Number of OTT credits with CHI
var nOttStashEntries  = Math.max(u.getParam('nOttStashEntries'),1); //Number of Stashing entries reserved for Stashing in OTT
var nOttEntries  =  nOttCtrlEntries + nOttStashEntries; //Total number of OTT entries (CHI requests + stashing requests)
var wMsgId  =  u.getParam('DTWReqInterface').message_id
var stt_id_width = Math.max(log2ceil(nEntries),1);
var mpf1_width = u.getParam('SNPRspInterface').mpf1;
var num_dw = (wData/64);
var dtw_aux_width = u.getParam('DTWReqInterface').aux;
var dtr_aux_width = u.getParam('DTRReqTxInterface').aux;
var chi_snp_opcode_width = u.getParam('CHI_SnpInterface').OpCode;
var wDvmAttr = 3;
var snp_req_order_fifo_width = wDvmAttr + nOttStashEntries + 1 + wEntries;
var nDvmSttEntries = (nEntries >= 8) ? 8 :
                     /* istanbul ignore next env ncore_3p7 */ (nEntries >= 6) ? 6 :
                     (nEntries >= 4) ? 4 : 2;
var SNPReqInterface   = u.getParam('SNPReqInterface');
var nSnpReqSkidBufSize = u.getParam("nSnpReqSkidBufSize");
\jsend

\jsbegin

u.port('input','clk', 1);
u.port('input','reset_n',1);
u.port('input','csr_one_dvm_sync',1);

u.port('output','stt_busy',1);
u.port('output','RXDATFLIT_target_intf_size', intf_size_width);
u.port('output','RXDATFLIT_snp_addr_bit3', 1);
u.port('output','RXDATFLIT_delay_dtw_valid', 1);
u.port('output','chi_snp_resp_error',1);
u.port('output','chi_snp_resp_err_info',2);
u.port('output','chi_snp_resp_txn_id', u.getParam('CHI_SnpInterface').TxnID);
u.port('output','chi_snp_resp_addr',wAddr);
u.port('output','chi_snp_resp_ns',1);

u.port('output', 'chi_tx_snp_req_valid',1);
u.port('input',  'chi_tx_snp_req_ready',1);
u.port('input',  'SYSCOACK', 1);
u.port('input',  'co_state_disabled', 1);
u.port('input',  'co_state_connect', 1);
u.port('input',  'co_state_enabled', 1);
u.port('input',  'co_state_disconnect', 1);
u.port('output', 'co_state_connect_ready', 1);
u.port('output', 'co_state_disconnect_ready', 1);

u.port('input', 'stash_entries_full', 1);
u.port('input', 'ott_initvec_stash', nOttStashEntries);
u.port('input', 'entry_validvec_stash', nOttStashEntries);

u.interface('snp_req_slv_', 'slave', u.getParam('SNPReqInterface'));
u.interface('RXDAT_', 'slave', u.getParam('DatInterface'));
u.interface('RXRSPFLIT_', 'slave', u.getParam('RspInterface'));
u.interface('TXSNPFLIT_', 'master', u.getParam('CHI_SnpInterface'));
u.interface('RXDATFLIT_', 'slave', u.getParam('DatInterface'), ['Poison','Data','BE','TraceTag','DataID','CCID','RespErr','Homenode_ID','TgtID','QoS','DBID','SrcID']);

u.interface('dtr_req_mst_', 'master', u.getParam('DTRReqTxInterface'));
u.interface('dtw_req_mst_', 'master', u.getParam('DTWReqInterface'));
u.interface('snp_rsp_mst_', 'master', u.getParam('SNPRspInterface'));
u.interface('dtr_rsp_slv_', 'slave', u.getParam('DTRRspRxInterface'));
u.interface('dtw_rsp_slv_', 'slave', u.getParam('DTWRspInterface'), ['ready']);

u.port('input', 'dtw_rsp_slv_ready',1);

u.port('input',  'rx_data_valid', 1);
u.port('input',  'dtw_data_valid', 1);
u.port('output', 'stt_data_ready', 1);

u.port('input', 'rx_rsp_valid',1);
u.port('input', 'RXDAT_LAST',1);
u.port('input', 'RXDAT_DWID', dtw_dwid_width);
u.port('input', 'my_f_unit_id',unit_id_width);
u.port('input', 'dve_f_unit_id',unit_id_width);

u.port('output', 'aiu_node_stash_target_init', 1);
u.port('input', 'sel_initvec_stash', nOttStashEntries);
u.port('output', 'snp_req_order_fifo__pop_sel_initvec_stash', nOttStashEntries);

\jsend

module \=u.getModuleName()=\ (\=u.getPorts('\n    ')=\);

wire dff_enable = 1'b1;
wire stash_entries_full_d;
wire snp_req_order_fifo__pop_stash_entries_full;
wire chi_dvm_op_part1_req_dropped;
wire chi_dvm_op_part2_req_pending;
wire chi_snp_co_pending;
wire stt_do_not_send_chi_snp;
wire chi_tx_snp_req_valid_int;
wire chi_tx_snp_req_ready_int;
wire [\=wDvmAttr-1=\:0] dvm_attr;
wire [\=nEntries-1=\:0] entry_validvec, entry_validvec_early ;

\=obj.userLib.bundleFunctions.wiresFromInterface('snp_req_sb_pop_', SNPReqInterface, [], obj.lib.bundle)=\

wire entry_validvec_early_or, entry_validvec_early_and;

  \=u.instance({
    instanceName: 'u_entry_validvec_early_or',
    moduleName:   'logic_tree',
    params: {'width' : nEntries,
             'logic' : '|'},
    ports: { 'din'  : 'entry_validvec_early',
             'dout' : 'entry_validvec_early_or' }
    })=\

  \=u.instance({
    instanceName: 'u_entry_validvec_early_and',
    moduleName:   'logic_tree',
    params: {'width' : nEntries,
             'logic' : '&'},
    ports: { 'din'  : 'entry_validvec_early',
             'dout' : 'entry_validvec_early_and' }
    })=\

\=u.dffre(1, 'snp_req_sb_pop_ready', '~entry_validvec_early_and', "1'b0", 'dff_enable', 'clk', 'reset_n')=\

\=u.dffre(1, 'stt_busy', 'entry_validvec_early_or', "1'b0", 'dff_enable', 'clk', 'reset_n')=\

wire [5:0] snp_rsp_status_rsp_channel ;
wire [5:0] snp_rsp_status_dat_channel ;

wire [\=nEntries-1=\:0] snp_data_muxsel_onehot = ({\=nEntries=\'b1} << RXDAT_TxnID[\=wEntries-1=\:0]) & {\=nEntries=\{(RXDAT_OpCode== \=u.getParam('DatInterface').OpCode=\\=chi_cmd.SnpRespData=\) | (RXDAT_OpCode== \=u.getParam('DatInterface').OpCode=\\=chi_cmd.SnpRespDataPtl=\)}};

wire [\=nEntries-1=\:0] snp_data_in_onehot = snp_data_muxsel_onehot & {\=nEntries=\{rx_data_valid | dtw_data_valid}};

//rx_data_valid and dtw_data_valid are mutually exclusive. dtw_data_valid is replayed data from rxdat_chan_stt module for SnpDTW that follows SnpDTR.
wire snp_data_in      = (rx_data_valid | dtw_data_valid) & ((RXDAT_OpCode== \=u.getParam('DatInterface').OpCode=\\=chi_cmd.SnpRespData=\) | (RXDAT_OpCode== \=u.getParam('DatInterface').OpCode=\\=chi_cmd.SnpRespDataPtl=\)); 
wire rx_data_in       = (rx_data_valid                 ) & ((RXDAT_OpCode== \=u.getParam('DatInterface').OpCode=\\=chi_cmd.SnpRespData=\) | (RXDAT_OpCode== \=u.getParam('DatInterface').OpCode=\\=chi_cmd.SnpRespDataPtl=\)); 

wire snp_data_in_last = snp_data_in & RXDAT_LAST;
wire rx_data_in_last  = rx_data_in  & RXDAT_LAST;

wire snp_rsp_valid = rx_rsp_valid & (RXRSPFLIT_OpCode== \=u.getParam('RspInterface').OpCode=\\=chi_cmd.SnpResp=\);

wire [\=nEntries-1=\:0] snp_rsp_in_onehot = ({\=nEntries=\'b1} << RXRSPFLIT_TxnID[\=wEntries-1=\:0]) & {\=nEntries=\{snp_rsp_valid}};

wire [\=nEntries-1=\:0] dtr_rsp_in_onehot = ({\=nEntries=\'b1} << dtr_rsp_slv_r_message_id[\=wMsgId-1=\:0]) & {\=nEntries=\{dtr_rsp_slv_valid & dtr_rsp_slv_ready}};

//Since DTW responses can be sent from both OTT & STT, the message id of the DTW requuests are differentiated by setting the MSB bit of snoop DTW to high and OTT DTW to low.

wire [\=nEntries-1=\:0] dtw_rsp_in_onehot = ({\=nEntries=\'b1} << dtw_rsp_slv_r_message_id[\=wMsgId-2=\:0]) & {\=nEntries=\{dtw_rsp_slv_valid & dtw_rsp_slv_ready & dtw_rsp_slv_r_message_id[\=wMsgId-1=\]}};
 
assign dtr_rsp_slv_ready = 1'b1 ;

wire tie1 = 1'b1 ;
wire tie0 = 1'b0 ;
wire [\=nEntries-1=\:0] sel_initvec, sel_initvec_coh, sel_initvec_dvm;
wire [\=nEntries-1=\:0] initvec  = sel_initvec & {\=nEntries=\{snp_req_sb_pop_valid}};
wire [\=nEntries-1=\:0] snp_rsp_out_req_vec;
wire [\=nEntries-1=\:0] snp_rsp_out_ack_vec;
wire [\=nEntries-1=\:0] snp_req_sent_vec , snp_req_popped_vec;
wire [\=nEntries-1=\:0] snp_req_co_sent_vec ;
wire [\=nEntries-1=\:0] snp_req_dropped_vec, stt_do_not_send_chi_snp_vec;
wire [\=stt_id_width-1=\:0] snp_resp_encoded;
reg  [\=stt_id_width-1=\:0] snp_resp_encoded_v1;
reg [\=wEntries=\-1:0] last_dvm_write_entry_v1;
wire [\=wEntries=\-1:0] last_dvm_write_entry_a1;
wire [\=wEntries=\-1:0] last_dvm_write_entry ;
wire                    last_dvm_write_range;
wire snp_req_is_dvm_sync_part2;
\jsbegin
var snp_req_width = bundleFunctions.getBundleWidth(u.getParam('CHI_SnpInterface'),[],obj.lib.bundle); 
var dtr_req_stt_bundle_width = bundleFunctions.getBundleWidth(u.getParam('DTRReqTxInterface'),['valid','ready','last','data','be','aux','dwid','dbad'],obj.lib.bundle);
var dtr_req_width = dtr_req_stt_bundle_width;
var dtw_req_width = bundleFunctions.getBundleWidth(u.getParam('DTWReqInterface'),['valid','ready','last','data','be','aux','dwid','dbad'],obj.lib.bundle )

var snp_rsp_width = bundleFunctions.getBundleWidth(u.getParam('SNPRspInterface'),['valid','ready','last'],obj.lib.bundle ) + wAddr + 1 + 2 + u.getParam('CHI_SnpInterface').TxnID; // wAddr + wNS + wErrInfo + wTxnID
var initiator_id_width = unit_id_width + port_id_width; 
var stash_target_id_spare_bits = mpf1_width - unit_id_width -1;

\jsend


wire snp_target_aiu_256  = (snp_req_sb_pop_intf_size == 2'b10);
wire snp_target_aiu_128  = (snp_req_sb_pop_intf_size == 2'b01);
wire snp_target_aiu_64  =  (snp_req_sb_pop_intf_size == 2'b00);

\js if (wData == 128) {
wire [2:0] intf_size_mask = ( {3{snp_target_aiu_64}}  & ({3{1'b1}} << 0) )
                          | ( {3{snp_target_aiu_128}} & ({3{1'b1}} << 0) )
                          | ( {3{snp_target_aiu_256}} & ({3{1'b1}} << 2) )
                          ;
\js }

\js if (wData == 256) {
wire [2:0] intf_size_mask = ( {3{snp_target_aiu_64}}  & ({3{1'b1}} << 0) )
                          | ( {3{snp_target_aiu_128}} & ({3{1'b1}} << 0) )
                          | ( {3{snp_target_aiu_256}} & ({3{1'b1}} << 0) )
                          ;
\js }

wire [2:0] snp_cdw = snp_req_sb_pop_addr[5:3] & intf_size_mask;

wire [\=snp_req_width-1=\:0] snp_req_data ;
wire [\=snp_rsp_width-1=\:0] snp_rsp_out_data ;
wire [\=dtw_req_width-1=\:0] dtw_req_data ;
wire [\=initiator_id_width-1=\:0] init_id;
wire [\=unit_id_width-1=\:0] stash_node_id;

assign init_id  =  ({{\=port_id_width=\{1'b0}}, my_f_unit_id}  << \=port_id_width=\);
assign stash_node_id = my_f_unit_id ;
\jsbegin
    /* istanbul ignore else env ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */
    if( stash_target_id_spare_bits > 0){
\jsend
wire aiu_node_stash_target = (snp_req_sb_pop_mpf1 == {1'b1,\=mpf1_width - unit_id_width -1=\'b0, stash_node_id});
\js } else {
wire aiu_node_stash_target = (snp_req_sb_pop_mpf1 == {1'b1, stash_node_id});
\js }
wire  snp_rsp_sent = |(snp_rsp_out_ack_vec);
wire dvm_entry_write, block_dvm_sync, block_dvm_nonsync;
wire [\=nEntries-1=\:0] dvm_sync_part2_sent_vec, dvm_sent_vec;
\jsbegin 

for (var i = 0; i < nEntries; i++ ) {
\jsend
wire [\=snp_req_width-1=\:0] snp_req_data\=i=\ ;
wire [\=dtr_req_width-1=\:0] dtr_req_data_out\=i=\ ;
wire [\=dtw_req_width-1=\:0] dtw_req_data_out\=i=\ ;
wire [\=snp_rsp_width-1=\:0] snp_rsp_out_data\=i=\ ;
wire [\=wEntries-1=\:0] stt_entry_num\=i=\ = \=wEntries=\'d\=i=\ ;
wire [\=intf_size_width-1=\:0] q_snp_req_intf_size\=i=\;
wire snp_addr_bit3_\=i=\;
wire [7:0] RXDATFLIT_dtr_data_opcode\=i=\ ;
wire [7:0] RXDATFLIT_dtw_data_opcode\=i=\ ;
\jsbegin
}

var ports_array = [];
for (var i = 0; i < nEntries; i++ ) {

var stt_ports = {
        clk : 'clk',
        reset_n                    : 'reset_n',
        snp_req_slv_ready          : 'snp_req_sb_pop_ready',
        init                       : 'initvec['+i+']',
        snp_cdw                    : 'snp_cdw',
        entry_valid_early          : 'entry_validvec_early['+i+']',
        entry_valid                : 'entry_validvec['+i+']',
        dtr_rsp_sel                : 'dtr_rsp_in_onehot['+i+']',  
        dtw_rsp_sel                : 'dtw_rsp_in_onehot['+i+']',  
        snp_data_sel               : 'snp_data_in_onehot['+i+']',  
        snprsp_in_sel              : 'snp_rsp_in_onehot['+i+']',  
        snp_rsp_out_req            : 'snp_rsp_out_req_vec['+i+']' ,
        snp_rsp_out_ack            : 'snp_rsp_out_ack_vec['+i+']' ,
        snp_req_sent               : 'snp_req_sent_vec['+i+']' ,
        snp_req_dropped            : 'snp_req_dropped_vec['+i+']' ,
        snp_req_popped             : 'snp_req_popped_vec['+i+']' ,
        snp_req_data               : 'snp_req_data'+i,
        stt_do_not_send_chi_snp    : 'stt_do_not_send_chi_snp_vec['+i+']' ,
        snp_addr_bit3              : 'snp_addr_bit3_'+i,
        snp_rsp_out_data           : 'snp_rsp_out_data'+i,
        snp_rsp_sent               : 'snp_rsp_sent',
        dtr_req_data               : 'dtr_req_data_out'+i,
        dtw_req_data               : 'dtw_req_data_out'+i,
        RXDATFLIT_dtr_data_opcode  : 'RXDATFLIT_dtr_data_opcode'+i,
        RXDATFLIT_dtw_data_opcode  : 'RXDATFLIT_dtw_data_opcode'+i,
        stt_entry_num              : 'stt_entry_num'+i,
        q_snp_req_slv_intf_size    : 'q_snp_req_intf_size'+i,
        rx_data_valid              : 'rx_data_valid',
        aiu_node_stash_target      : 'aiu_node_stash_target',
        RXDAT_LAST                 : 'RXDAT_LAST',
        stash_entries_full         : 'snp_req_order_fifo__pop_stash_entries_full',
        stash_entries_full_d       : 'stash_entries_full_d',
        ott_initvec_stash          : 'ott_initvec_stash',
        entry_validvec_stash       : 'entry_validvec_stash',
        init_id                    : 'init_id',
        my_f_unit_id               : 'my_f_unit_id',
        dve_f_unit_id              : 'dve_f_unit_id',
        snp_resp_encoded           : 'snp_resp_encoded',
        last_dvm_write_entry       : 'last_dvm_write_entry',
        last_dvm_write_range       : 'last_dvm_write_range',
        snp_req_is_dvm_sync_part2  : 'snp_req_is_dvm_sync_part2',
        dvm_sync_part2_sent        : 'dvm_sync_part2_sent_vec['+i+']',
        dvm_sent                   : 'dvm_sent_vec['+i+']' 
}
ports_array.push(stt_ports);

}
\jsend

\jsbegin
for (var i = 0; i < nEntries; i++ ) {
\jsend


        \=u.instance({
            instanceName: 'entry'+i,
            moduleName: 'stt_entry',
            params: { 
                      assertOn              : assertOn,
                      interfaces            : interfaces,
                      SNPRspInterface       : u.getParam('SNPRspInterface') ,
                      CHI_SNPREQ_interface  : u.getParam('CHI_SnpInterface'),
                      DTWReqInterface       : u.getParam('DTWReqInterface'),
                      DTRReqTxInterface     : u.getParam('DTRReqTxInterface'),
                      SNPReqInterface       : u.getParam('SNPReqInterface'),
                      DTRRspRxInterface     : u.getParam('DTRRspRxInterface'),
                      DTWRspInterface       : u.getParam('DTWRspInterface'),
                      WdatInterface         : u.getParam('DatInterface'),
                      RspInterface          : u.getParam('RspInterface') ,
                      nSttEntries           : u.getParam('nSttEntries'),
                      nOttCtrlEntries       : u.getParam('nOttCtrlEntries'),
                      nOttStashEntries      : u.getParam('nOttStashEntries'),
                      initiator_id_width    : initiator_id_width,
                      unit_id_width         : unit_id_width,
                      port_id_width         : port_id_width,
                      intf_size_width       : intf_size_width,
                      cm_type               : cm_type,
                      chi_cmd               : chi_cmd,
                      chi_a                 : chi_a,
                      chi_b                 : chi_b,
                      chi_e                 : chi_e,
                      wAddr                 : wAddr,
                      wData                 : wData,
                      wDatFlit_Opcode       : wDatFlit_Opcode,
                      wSnpFlit_DoNotGoToSD_local : wSnpFlit_DoNotGoToSD_local,
                      wDatFlit_TraceTag_local : wDatFlit_TraceTag_local,
                      wSnpFlit_FwdTxnID_local : wSnpFlit_FwdTxnID_local,
                      wSnpFlit_FwdNID_local : wSnpFlit_FwdNID_local,
},
            verilogParams: {},
            ports: ports_array[i],
            interfaces : [
{ modulePrefix: 'snp_req_slv_'  , localPrefix : 'snp_req_sb_pop_' , interface : u.getParam('SNPReqInterface'),exclude : ['ready','last']},
{ modulePrefix: 'dtr_rsp_slv_'  , localPrefix : 'dtr_rsp_slv_' , interface : u.getParam('DTRRspRxInterface'),exclude : ['valid','ready','last','aux','initiator_id','r_message_id','message_id']},
{ modulePrefix: 'dtw_rsp_slv_'  , localPrefix : 'dtw_rsp_slv_' , interface : u.getParam('DTWRspInterface'),exclude : ['valid','ready','last','aux','initiator_id','r_message_id','message_id']},
{ modulePrefix: 'RXDAT_',         localPrefix : 'RXDAT_' , interface : u.getParam('DatInterface'),exclude : ['TgtID','SrcID','TxnID','DBID','BE','Data', 'Poison']},
{ modulePrefix: 'RXDATFLIT_', localPrefix : 'RXDATFLIT_' , interface : u.getParam('DatInterface'),exclude : ['TgtID','SrcID','TxnID','DBID','BE','Data', 'Poison','QoS','Homenode_ID','RespErr','TraceTag','CCID','DataID']},
{ modulePrefix: 'RXRSP_',     localPrefix : 'RXRSPFLIT_' , interface : u.getParam('RspInterface'),exclude : ['TgtID','SrcID','TxnID','DBID','PCrdType']}


],
            portsDelimiter: '\n    '
        })=\
\jsbegin
}
\jsend


wire [\=nEntries-1=\:0] snp_rsp_arb__sink_ready;
wire [\=nEntries-1=\:0] snp_rsp_arb__sink_valid;
wire [\=nEntries-1=\:0] snp_rsp_arb__sink_last;
wire [\=nEntries-1=\:0] snp_rsp_arb__sink_grant;
wire snp_rsp_arb__source_ready;
wire snp_rsp_arb__source_valid;
wire snp_rsp_arb__source_last;

wire snp_rsp_data_fifo_push_valid;
wire snp_rsp_data_fifo_push_ready;
wire [\=snp_rsp_width-1=\:0] snp_rsp_data_fifo_push_data;
wire [\=snp_rsp_width-1=\:0] snp_rsp_data_fifo_pop_data;
wire snp_rsp_data_fifo_pop_valid;
wire snp_rsp_data_fifo_pop_ready;

\jsbegin
    var snpRspArbParams = {
        num_inputs  : nEntries
    };
    var instance_ports_for_snp_rsp_arb = {
        clk                 : 'clk',
        reset_n             : 'reset_n',
        sink_ready          : 'snp_rsp_arb__sink_ready',
        sink_valid          : 'snp_rsp_arb__sink_valid',
        sink_last           : 'snp_rsp_arb__sink_last',
        sink_grant          : 'snp_rsp_arb__sink_grant',
        source_ready        : 'snp_rsp_arb__source_ready',
        source_valid        : 'snp_rsp_arb__source_valid',
        source_last         : 'snp_rsp_arb__source_last'
    };
\jsend
    \=u.instance({
        instanceName: 'snp_rsp_arb',
        moduleName: 'rr_arb_comb_mux',
        params : snpRspArbParams,
        verilogParams: {},
        ports: instance_ports_for_snp_rsp_arb,
        portsDelimiter: '\n    '
    })=\

\jsbegin
    var snp_rsp_data_FifoParams = {
        width       : snp_rsp_width,
        depth       : 2,
        bypass_mode : 0,
        zerodepth   : 0
    };
    var instance_ports_for_snp_rsp_data_fifo = {
        clk                 : 'clk',
        reset_n             : 'reset_n',
        push_data           : 'snp_rsp_data_fifo_push_data',
        push_valid          : 'snp_rsp_data_fifo_push_valid',
        push_ready          : 'snp_rsp_data_fifo_push_ready',
        pop_data            : 'snp_rsp_data_fifo_pop_data',
        pop_valid           : 'snp_rsp_data_fifo_pop_valid',
        pop_ready           : 'snp_rsp_data_fifo_pop_ready'
    };
\jsend
    \=obj.lib.instance({
        instanceName: 'snp_rsp_data_fifo',
        moduleName: 'fifo',
        params : snp_rsp_data_FifoParams,
        verilogParams: {},
        ports: instance_ports_for_snp_rsp_data_fifo,
        portsDelimiter: '\n    '
    })=\

assign snp_rsp_data_fifo_push_data = ({\=snp_rsp_width=\{snp_rsp_arb__sink_grant[0]}} & snp_rsp_out_data0)
            \js for (var i = 1; i < nEntries; i++ ) {
                                   | ({\=snp_rsp_width=\{snp_rsp_arb__sink_grant[\=i=\]}} & snp_rsp_out_data\=i=\)
            \js }
                                   ;

assign snp_rsp_arb__sink_valid = snp_rsp_out_req_vec;
assign snp_rsp_out_ack_vec     = snp_rsp_arb__sink_ready;
assign snp_rsp_arb__sink_last  = {\=nEntries=\{1'b1}};

assign snp_rsp_data_fifo_push_valid = snp_rsp_arb__source_valid;
assign snp_rsp_arb__source_ready = snp_rsp_data_fifo_push_ready;

assign snp_rsp_mst_valid = snp_rsp_data_fifo_pop_valid;
assign snp_rsp_data_fifo_pop_ready = snp_rsp_mst_ready;
assign snp_rsp_out_data = snp_rsp_data_fifo_pop_data;



     \=u.instance({
          instanceName: 'init_stt_coh',
          moduleName: 'find_first_one',
          params: { width : nEntries } ,
          verilogParams: {},
          ports: { invec : "~entry_validvec" ,
                   outvec : "sel_initvec_coh"
                 },
          portsDelimiter: '\n    '
    })=\

//DTR request generation
wire [\=dtr_req_width-1=\:0] dtr_req_data ;

wire dtr_valid = (dtr_req_mst_cm_type == \=cm_type.DtrDataInv=\)
               | (dtr_req_mst_cm_type == \=cm_type.DtrDataSCln=\)
               | (dtr_req_mst_cm_type == \=cm_type.DtrDataSDty=\)
               | (dtr_req_mst_cm_type == \=cm_type.DtrDataUCln=\)
               | (dtr_req_mst_cm_type == \=cm_type.DtrDataUDty=\)
               ;

assign dtr_req_mst_valid = rx_data_valid & dtr_valid;

wire drop_dtr = rx_data_valid & ~dtr_valid;

assign dtr_req_mst_data = RXDAT_Data ;
assign dtr_req_mst_be   = RXDAT_BE ;
assign dtr_req_mst_dwid = RXDAT_DWID ;
assign dtr_req_mst_last = RXDAT_LAST ;

//Set dbad if RespErr or Poison is set on Dat flit

assign dtr_req_mst_dbad = {\=num_dw=\{RXDAT_RespErr[1]}}
            \js if (enPoison == true) {
                        | RXDAT_Poison
            \js }
                        ;

\jsbegin
/* istanbul ignore if env ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */
if (dtr_aux_width > 0) {
\jsend
assign dtr_req_mst_aux  = \=dtr_aux_width=\'b0;
\js }

assign dtr_req_data = ({\=dtr_req_width=\{snp_data_muxsel_onehot[0]}} & dtr_req_data_out0)  
\js for (var i = 1; i < nEntries; i++ ) {
                    | ({\=dtr_req_width=\{snp_data_muxsel_onehot[\=i=\]}} & dtr_req_data_out\=i=\) 
\js }
                    ;


wire [\=nEntries-1=\:0] snp_data_entry = (\=nEntries=\'b1 << RXDATFLIT_TxnID[\=wEntries-1=\:0]) & {\=nEntries=\{((RXDATFLIT_OpCode == \=u.getParam('DatInterface').OpCode=\\=chi_cmd.SnpRespData=\) | (RXDATFLIT_OpCode == \=u.getParam('DatInterface').OpCode=\\=chi_cmd.SnpRespDataPtl=\))}};

assign RXDATFLIT_snp_addr_bit3 = (snp_data_entry[0] & snp_addr_bit3_0)
\jsbegin
for (var i = 1; i < nEntries; i++ ) {
\jsend
    |  (snp_data_entry[\=i=\] & snp_addr_bit3_\=i=\)
\jsbegin
}
\jsend
;

assign chi_snp_resp_error = snp_rsp_data_fifo_pop_valid & snp_rsp_data_fifo_pop_ready & chi_snp_resp_err_info[1];
assign {chi_snp_resp_txn_id, chi_snp_resp_err_info, chi_snp_resp_ns , chi_snp_resp_addr, \=bundleFunctions.packetizeBundle('snp_rsp_mst_', u.getParam('SNPRspInterface') , ['valid','ready','last'] , obj.lib.bundle )=\}   = snp_rsp_out_data  ;
assign  \=bundleFunctions.packetizeBundle('TXSNPFLIT_', u.getParam('CHI_SnpInterface') , [] , obj.lib.bundle )=\   = snp_req_data ;

assign  {\=bundleFunctions.packetizeBundle('dtr_req_mst_', u.getParam('DTRReqTxInterface'), ['valid','ready','last','data','be','aux','dwid','dbad'], obj.lib.bundle)=\} = dtr_req_data ;

assign  \=bundleFunctions.packetizeBundle('dtw_req_mst_', u.getParam('DTWReqInterface'), ['valid','ready','last','data','be','aux','dwid','dbad'], obj.lib.bundle)=\ = dtw_req_data ;

wire snp_resp_Data_I       = (RXDAT_OpCode == \=u.getParam('DatInterface').OpCode=\\=chi_cmd.SnpRespData=\) & (RXDAT_Resp ==  3'b000);
wire snp_resp_Data_UC      = (RXDAT_OpCode == \=u.getParam('DatInterface').OpCode=\\=chi_cmd.SnpRespData=\) & (RXDAT_Resp ==  3'b010);
wire snp_resp_Data_UD      = (RXDAT_OpCode == \=u.getParam('DatInterface').OpCode=\\=chi_cmd.SnpRespData=\) & (RXDAT_Resp ==  3'b010);
wire snp_resp_Data_SC      = (RXDAT_OpCode == \=u.getParam('DatInterface').OpCode=\\=chi_cmd.SnpRespData=\) & (RXDAT_Resp ==  3'b001);
wire snp_resp_Data_SD      = (RXDAT_OpCode == \=u.getParam('DatInterface').OpCode=\\=chi_cmd.SnpRespData=\) & (RXDAT_Resp ==  3'b011);
wire snp_resp_Data_I_PD    = (RXDAT_OpCode == \=u.getParam('DatInterface').OpCode=\\=chi_cmd.SnpRespData=\) & (RXDAT_Resp ==  3'b100);
wire snp_resp_Data_UC_PD   = (RXDAT_OpCode == \=u.getParam('DatInterface').OpCode=\\=chi_cmd.SnpRespData=\) & (RXDAT_Resp ==  3'b110);
wire snp_resp_Data_SC_PD   = (RXDAT_OpCode == \=u.getParam('DatInterface').OpCode=\\=chi_cmd.SnpRespData=\) & (RXDAT_Resp ==  3'b101);
wire snp_resp_DataPtl_I_PD = (RXDAT_OpCode == \=u.getParam('DatInterface').OpCode=\\=chi_cmd.SnpRespDataPtl=\) & (RXDAT_Resp ==  3'b100);
wire snp_resp_DataPtl_UD   = (RXDAT_OpCode == \=u.getParam('DatInterface').OpCode=\\=chi_cmd.SnpRespDataPtl=\) & (RXDAT_Resp ==  3'b010);


wire [7:0] RXDATFLIT_dtw_data_opcode;
wire [7:0] RXDATFLIT_dtr_data_opcode;

assign RXDATFLIT_dtw_data_opcode = ({8{snp_data_entry[0]}} & RXDATFLIT_dtw_data_opcode0)
\js for (var i = 1; i < nEntries; i++ ) {
                                 | ({8{snp_data_entry[\=i=\]}} & RXDATFLIT_dtw_data_opcode\=i=\)
\js }
                                 ;

assign RXDATFLIT_dtr_data_opcode = ({8{snp_data_entry[0]}} & RXDATFLIT_dtr_data_opcode0)
\js for (var i = 1; i < nEntries; i++ ) {
                                 | ({8{snp_data_entry[\=i=\]}} & RXDATFLIT_dtr_data_opcode\=i=\)
\js }
                                 ;

wire RXDATFLIT_dtw_valid = (RXDATFLIT_dtw_data_opcode == \=cm_type.DtwDataFullCln=\)
                         | (RXDATFLIT_dtw_data_opcode == \=cm_type.DtwDataPtlDty=\)
                         | (RXDATFLIT_dtw_data_opcode == \=cm_type.DtwDataFullDty=\)
                         | (RXDATFLIT_dtw_data_opcode == \=cm_type.DtwMrgMrdInv=\)
                         | (RXDATFLIT_dtw_data_opcode == \=cm_type.DtwMrgMrdSCln=\)
                         | (RXDATFLIT_dtw_data_opcode == \=cm_type.DtwMrgMrdUCln=\)
                         | (RXDATFLIT_dtw_data_opcode == \=cm_type.DtwMrgMrdUDty=\)
                         ;

wire RXDATFLIT_dtr_valid = (RXDATFLIT_dtr_data_opcode == \=cm_type.DtrDataInv=\)
                         | (RXDATFLIT_dtr_data_opcode == \=cm_type.DtrDataSCln=\)
                         | (RXDATFLIT_dtr_data_opcode == \=cm_type.DtrDataSDty=\)
                         | (RXDATFLIT_dtr_data_opcode == \=cm_type.DtrDataUCln=\)
                         | (RXDATFLIT_dtr_data_opcode == \=cm_type.DtrDataUDty=\)
                         ;

assign RXDATFLIT_delay_dtw_valid = RXDATFLIT_dtw_valid & RXDATFLIT_dtr_valid & ((RXDATFLIT_OpCode== \=u.getParam('DatInterface').OpCode=\\=chi_cmd.SnpRespData=\) | (RXDATFLIT_OpCode== \=u.getParam('DatInterface').OpCode=\\=chi_cmd.SnpRespDataPtl=\));



//DTW request generaton

wire dtw_valid = (dtw_req_mst_cm_type == \=cm_type.DtwDataFullCln=\)
               | (dtw_req_mst_cm_type == \=cm_type.DtwDataPtlDty=\)
               | (dtw_req_mst_cm_type == \=cm_type.DtwDataFullDty=\)
               | (dtw_req_mst_cm_type == \=cm_type.DtwMrgMrdInv=\)
               | (dtw_req_mst_cm_type == \=cm_type.DtwMrgMrdSCln=\)
               | (dtw_req_mst_cm_type == \=cm_type.DtwMrgMrdUCln=\)
               | (dtw_req_mst_cm_type == \=cm_type.DtwMrgMrdUDty=\)
               ;

wire drop_dtw = rx_data_valid & ~dtw_valid;

wire drop_chi_data = snp_data_in & (drop_dtr & drop_dtw);

assign dtw_req_mst_data = RXDAT_Data ;
assign dtw_req_mst_be   = RXDAT_BE ;
assign dtw_req_mst_dwid = RXDAT_DWID ;
assign dtw_req_mst_last = RXDAT_LAST ;


assign dtw_req_mst_valid = (rx_data_valid & dtw_valid & ~dtr_valid)
                         | dtw_data_valid;


//Set dbad if RespErr or Poison is set on Dat flit

assign dtw_req_mst_dbad = {\=num_dw=\{RXDAT_RespErr[1]}}
            \js if (enPoison == true) {
                        | RXDAT_Poison
            \js }
                        ;

\jsbegin
/* istanbul ignore if env ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */
if (dtw_aux_width > 0) {
\jsend
assign dtw_req_mst_aux  = \=dtw_aux_width=\'b0;
\js }

assign dtw_req_data = ({\=dtw_req_width=\{snp_data_muxsel_onehot[0]}} & dtw_req_data_out0)
\js for (var i = 1; i < nEntries; i++ ) {
                    | ({\=dtw_req_width=\{snp_data_muxsel_onehot[\=i=\]}} & dtw_req_data_out\=i=\)
\js }
                    ;



assign dvm_entry_write = snp_req_sb_pop_valid & (snp_req_sb_pop_cm_type == \=cm_type.SnpDvmMsg=\);
wire dvm_entry_write_part1 = dvm_entry_write & ~snp_req_sb_pop_addr[3];

//Storing the last dvm entry written
  always @* begin
        case (1'b1)
\js       for (var entry = 0 ; entry < nEntries; entry++) {
           sel_initvec[\=entry=\] :    
                 last_dvm_write_entry_v1 =  \=stt_id_width=\'d\=entry=\;
\js        }
               default:
                 last_dvm_write_entry_v1 =  \=stt_id_width=\'d0;
        endcase
    end

assign last_dvm_write_entry_a1 = last_dvm_write_entry_v1;

\=u.dffre(wEntries, 'last_dvm_write_entry', 'last_dvm_write_entry_a1', wEntries+"'b0", 'dvm_entry_write_part1' , 'clk', 'reset_n')=\

\=u.dffre(1, 'last_dvm_write_range', 'snp_req_sb_pop_mpf3[1]', "1'b0", 'dvm_entry_write_part1' , 'clk', 'reset_n')=\

   always @* begin
        case (1'b1)
\js       for (var entry = 0 ; entry < nEntries ; entry++) {
             (snp_rsp_out_ack_vec[\=entry=\]):
                          snp_resp_encoded_v1 =  \=stt_id_width=\'d\=entry=\;
\js        }
               default:
                          snp_resp_encoded_v1 =  \=stt_id_width=\'d0;
        endcase
    end

 assign snp_resp_encoded = snp_resp_encoded_v1;

reg [\=intf_size_width-1=\:0] intf_size_reg;

//Finding Intf size
  always @* begin
        case (RXDATFLIT_TxnID[\=wFlit_TxnID-2=\:0])
            \js for (i=0; i < nEntries; i++) {
             \=i=\:  intf_size_reg = q_snp_req_intf_size\=i=\;
            \js }
               default:  intf_size_reg = \=intf_size_width=\'d0;
        endcase
    end

assign RXDATFLIT_target_intf_size = intf_size_reg;


wire [\=nOttStashEntries-1=\:0] sel_initvec_stash_qual = aiu_node_stash_target_init ? sel_initvec_stash : \=nOttStashEntries=\'b0;

wire [\=wEntries-1=\:0] stt_entry_num;

wire snp_req_order_fifo__push_valid;
wire snp_req_order_fifo__push_ready;
wire [\=snp_req_order_fifo_width-1=\:0] snp_req_order_fifo__push_data;
wire [\=snp_req_order_fifo_width-1=\:0] snp_req_order_fifo__pop_data;
wire snp_req_order_fifo__pop_valid, snp_req_order_fifo__pop_valid_org;
wire snp_req_order_fifo__pop_ready, snp_req_order_fifo__pop_ready_org;
wire chi_snp_dvm_counter_hit;
wire [\=nEntries-1=\:0] snp_req_order_fifo__pop_id_onehot;

assign stt_entry_num = ({\=wEntries=\{sel_initvec[0]}} & stt_entry_num0)
    \js for (var i=1; i < nEntries; i++) {
                     | ({\=wEntries=\{sel_initvec[\=i=\]}} & stt_entry_num\=i=\)
    \js }
                     ;

assign snp_req_order_fifo__push_valid = snp_req_sb_pop_valid & snp_req_sb_pop_ready;

assign snp_req_order_fifo__push_data  = {dvm_attr, sel_initvec_stash_qual, stash_entries_full, stt_entry_num};

assign chi_tx_snp_req_valid_int = snp_req_order_fifo__pop_valid;

assign snp_req_order_fifo__pop_ready = chi_tx_snp_req_ready_int;

assign snp_req_order_fifo__pop_sel_initvec_stash = snp_req_order_fifo__pop_data[\=nOttStashEntries+wEntries=\:\=wEntries+1=\];
assign snp_req_order_fifo__pop_stash_entries_full = snp_req_order_fifo__pop_data[\=wEntries=\];
assign snp_req_order_fifo__pop_id_onehot = (\=nEntries=\'d1 << snp_req_order_fifo__pop_data[\=wEntries-1=\:0]);

assign snp_req_data = ({\=snp_req_width=\{snp_req_order_fifo__pop_id_onehot[0]}} & snp_req_data0)
    \js for (var i=1; i < nEntries; i++) {
                        | ({\=snp_req_width=\{snp_req_order_fifo__pop_id_onehot[\=i=\]}} & snp_req_data\=i=\)
    \js }
                     ;

assign snp_req_sent_vec = snp_req_order_fifo__pop_id_onehot & {\=nEntries=\{snp_req_order_fifo__pop_valid & snp_req_order_fifo__pop_ready}};
assign snp_req_popped_vec = snp_req_order_fifo__pop_id_onehot & {\=nEntries=\{snp_req_order_fifo__pop_valid_org & snp_req_order_fifo__pop_ready_org}};

wire co_state_enabled_decode = co_state_enabled | co_state_connect | (co_state_disconnect & ~co_state_disconnect_ready);
assign snp_req_co_sent_vec = snp_req_sent_vec & {\=nEntries=\{co_state_enabled_decode}};
assign snp_req_dropped_vec = snp_req_sent_vec & {\=nEntries=\{~co_state_enabled_decode}};

assign block_dvm_sync    = {|{dvm_sync_part2_sent_vec[\=nEntries-1=\:\=nEntries-(nDvmSnpInFlight ? nDvmSnpInFlight : 1)=\]}} | block_dvm_nonsync;
assign block_dvm_nonsync = ({&{dvm_sent_vec[\=nEntries-1=\:\=nEntries-nDvmSttEntries=\]}}) | chi_snp_dvm_counter_hit;

\jsbegin
    var snpReqOrderFifoParams = {
        width       : snp_req_order_fifo_width,
        depth       : nEntries,
        use_fastread: 1,
        bypass_mode : 0,
        zerodepth   : 0
    };
    var instance_ports_for_snp_req_order_fifo = {
        clk                 : 'clk',
        reset_n             : 'reset_n',
        csr_one_dvm_sync    : 'csr_one_dvm_sync',
        block_dvm_sync      : 'block_dvm_sync',
        block_dvm_nonsync   : 'block_dvm_nonsync',
        push_data           : 'snp_req_order_fifo__push_data',
        push_valid          : 'snp_req_order_fifo__push_valid',
        push_ready          : 'snp_req_order_fifo__push_ready',
        pop_data            : 'snp_req_order_fifo__pop_data',
        pop_valid           : 'snp_req_order_fifo__pop_valid_org',
        pop_ready           : 'snp_req_order_fifo__pop_ready_org'
    };
\jsend
    \=obj.lib.instance({
        instanceName: 'snp_req_order_fifo',
        moduleName: 'chi_aiu_snp_req_order_fifo',
        params : snpReqOrderFifoParams,
        verilogParams: {},
        ports: instance_ports_for_snp_req_order_fifo,
        portsDelimiter: '\n    '
    })=\


wire chi_dvm_op         = (TXSNPFLIT_OpCode == \=chi_cmd.SnpDvmOp=\);
wire chi_dvm_op_part1   = (TXSNPFLIT_OpCode == \=chi_cmd.SnpDvmOp=\) & ~TXSNPFLIT_Addr[0];
wire chi_dvm_op_part2   = (TXSNPFLIT_OpCode == \=chi_cmd.SnpDvmOp=\) &  TXSNPFLIT_Addr[0];
wire chi_tx_snp_co_sent = chi_tx_snp_req_valid & chi_tx_snp_req_ready;
wire chi_tx_snp_sent    = chi_tx_snp_req_valid_int & chi_tx_snp_req_ready_int;

wire [\=wEntries=\:0] chi_dvm_op_prog_counter;
wire [\=wEntries=\:0] chi_dvm_op_prog_counter_in = chi_dvm_op_part1 ? (chi_dvm_op_prog_counter + \=wEntries+1=\'d1) :
                                                   chi_dvm_op_part2 ? (chi_dvm_op_prog_counter - \=wEntries+1=\'d1) :
                                                                       chi_dvm_op_prog_counter;

\=u.dffre(wEntries+1, 'chi_dvm_op_prog_counter', 'chi_dvm_op_prog_counter_in', wEntries+1+"'b0", 'chi_tx_snp_sent', 'clk', 'reset_n')=\

assign chi_dvm_op_part2_req_pending = {|{chi_dvm_op_prog_counter}};

wire chi_tx_snp_dat_rcvd = rx_data_in_last & stt_data_ready;
wire chi_tx_snp_rsp_rcvd = snp_rsp_valid;

wire [\=wEntries=\:0] chi_snp_prog_counter;
wire [\=wEntries=\:0] chi_snp_prog_counter_in = chi_snp_prog_counter
                                                + (chi_tx_snp_co_sent & ~chi_dvm_op_part2 ? \=wEntries+1=\'d1 :  \=wEntries+1=\'d0)
                                                - (chi_tx_snp_rsp_rcvd                    ? \=wEntries+1=\'d1 :  \=wEntries+1=\'d0)
                                                - (chi_tx_snp_dat_rcvd                    ? \=wEntries+1=\'d1 :  \=wEntries+1=\'d0);

\=u.dffre(wEntries+1, 'chi_snp_prog_counter', 'chi_snp_prog_counter_in', wEntries+1+"'b0", 'dff_enable', 'clk', 'reset_n')=\

assign chi_snp_co_pending = {|{chi_snp_prog_counter}};


wire chi_dvm_op_snp_req_sent = chi_dvm_op & {|{snp_req_sent_vec}};

assign co_state_connect_ready = ~chi_dvm_op_part2_req_pending & ~chi_snp_co_pending & ~chi_dvm_op_part1_req_dropped & ~chi_dvm_op_snp_req_sent;

assign co_state_disconnect_ready = ~chi_dvm_op_part2_req_pending & ~chi_snp_co_pending & ~stt_busy;

assign chi_tx_snp_req_valid = co_state_enabled_decode ? chi_tx_snp_req_valid_int : 1'b0;

assign chi_tx_snp_req_ready_int = co_state_enabled_decode ? chi_tx_snp_req_ready : 1'b1;

wire chi_dvm_op_part1_req_dropped_in = chi_dvm_op_part1 & {|{snp_req_dropped_vec}};
wire chi_dvm_op_part1_req_dropped_en = chi_dvm_op_snp_req_sent;

\=u.dffre(1, 'chi_dvm_op_part1_req_dropped', 'chi_dvm_op_part1_req_dropped_in', "1'b0", 'chi_dvm_op_part1_req_dropped_en', 'clk', 'reset_n')=\

assign stt_data_ready = (dtr_req_mst_valid & dtr_req_mst_ready)
                      | (dtw_req_mst_valid & dtw_req_mst_ready)
                      | drop_chi_data
                      ;




assign aiu_node_stash_target_init = snp_req_sb_pop_valid & snp_req_sb_pop_ready & aiu_node_stash_target & (
                          (snp_req_sb_pop_cm_type == \=cm_type.SnpInvStsh=\)
                        | (snp_req_sb_pop_cm_type == \=cm_type.SnpUnqStsh=\)
                        | (snp_req_sb_pop_cm_type == \=cm_type.SnpStshShd=\)
                        | (snp_req_sb_pop_cm_type == \=cm_type.SnpStshUnq=\)
                      );

assign stt_do_not_send_chi_snp = {|{snp_req_order_fifo__pop_id_onehot & stt_do_not_send_chi_snp_vec}};

assign snp_req_order_fifo__pop_valid = snp_req_order_fifo__pop_valid_org & ~stt_do_not_send_chi_snp;

assign snp_req_order_fifo__pop_ready_org = snp_req_order_fifo__pop_ready | stt_do_not_send_chi_snp;

\jsbegin
// CONC-13411 STT Entry and OTT Stash Entry have init signal that is aligned on (snp_slv_req_valid & snp_slv_req_ready)
// Hence, stash_entries_full is aligned with init, and stash_entries_full_d is aligned with init_d
\jsend

\=u.dffre(1, 'stash_entries_full_d', 'stash_entries_full', "1'b0", 'dff_enable', 'clk', 'reset_n')=\

\jsbegin
// CONC-13666 DVM
\jsend

wire [2:0] DVM_OPCODE_SYNC = 3'b100;

wire ST_DVM_PART_1 = 1'b0;
wire ST_DVM_PART_2 = 1'b1;
wire dvm_state;
reg  nxt_dvm_state;

wire snp_req_is_dvm;
wire snp_req_is_dvm_part1;
wire snp_req_is_dvm_part2;
wire snp_req_is_dvm_sync_part1;
//wire snp_req_is_dvm_sync_part2;
wire snp_req_is_dvm_sync;

assign snp_req_is_dvm       = (snp_req_sb_pop_cm_type == \=cm_type.SnpDvmMsg=\);
assign snp_req_is_dvm_part1 = snp_req_is_dvm & ~snp_req_sb_pop_addr[3];
assign snp_req_is_dvm_part2 = snp_req_is_dvm & snp_req_sb_pop_addr[3];

assign snp_req_is_dvm_sync_part1 = snp_req_is_dvm_part1 & (snp_req_sb_pop_addr[13:11] == DVM_OPCODE_SYNC);
assign snp_req_is_dvm_sync_part2 = snp_req_is_dvm_part2 & (dvm_state == ST_DVM_PART_2);

assign snp_req_is_dvm_sync = snp_req_is_dvm_sync_part1 | snp_req_is_dvm_sync_part2;

always @(*)
case (dvm_state)
    ST_DVM_PART_1:
        if (snp_req_sb_pop_valid & snp_req_sb_pop_ready & snp_req_is_dvm_sync_part1) begin
            nxt_dvm_state = ST_DVM_PART_2;
        end else begin
            nxt_dvm_state = ST_DVM_PART_1;
        end
    ST_DVM_PART_2:
        if (snp_req_sb_pop_valid & snp_req_sb_pop_ready & snp_req_is_dvm_part2) begin
            nxt_dvm_state = ST_DVM_PART_1;
        end else begin
            nxt_dvm_state = ST_DVM_PART_2;
        end
    default
        nxt_dvm_state = dvm_state;
endcase

\=u.dffre(1, "dvm_state", "nxt_dvm_state", "1'b0", "dff_enable", "clk", "reset_n")=\


assign dvm_attr = {snp_req_is_dvm_part2, snp_req_is_dvm_sync, snp_req_is_dvm};


     \=u.instance({
          instanceName: 'init_stt_dvm',
          moduleName: 'find_first_one_rev',
          params: { width : nEntries } ,
          verilogParams: {},
          ports: { invec : "~entry_validvec" ,
                   outvec : "sel_initvec_dvm"
                 }
    })=\

assign sel_initvec = dvm_entry_write ? sel_initvec_dvm : sel_initvec_coh;

\js // CONC-14171

wire chi_snp_dvm_counter_incr = chi_tx_snp_req_valid & chi_tx_snp_req_ready & chi_dvm_op;
wire chi_snp_dvm_counter_decr = snp_rsp_valid & {|{snp_rsp_in_onehot & dvm_sent_vec}};
wire [\=wEntries=\:0] chi_snp_dvm_counter;
wire [\=wEntries=\:0] chi_snp_dvm_counter_in = chi_snp_dvm_counter_incr & ~chi_snp_dvm_counter_decr ? (chi_snp_dvm_counter + \=wEntries+1=\'d1) :
                                               chi_snp_dvm_counter_decr & ~chi_snp_dvm_counter_incr ? (chi_snp_dvm_counter - \=wEntries+1=\'d2) :
                                               chi_snp_dvm_counter_decr &  chi_snp_dvm_counter_incr ? (chi_snp_dvm_counter - \=wEntries+1=\'d1) :
                                                                                                       chi_snp_dvm_counter;

\=u.dffre(wEntries+1, 'chi_snp_dvm_counter', 'chi_snp_dvm_counter_in', wEntries+1+"'b0", 'dff_enable', 'clk', 'reset_n')=\

assign chi_snp_dvm_counter_hit = chi_snp_dvm_counter >= \=wEntries+1=\'d4;

\jsbegin
// Skid Buffer for Ncore 3.7
var fnEnableQos             = 0;
var wStarvThreshold         = 0;
var useSramFifoForSnpReqSB  = false;
var snpReq_sb_memoryType    = 'SYNOPSYS';
var snpReqSbSize            = { Skidfifo: nSnpReqSkidBufSize, SkidBuffer: 0 }; 

var snpReqSkidBufferInterfaces =[]

snpReqSkidBufferInterfaces.push({
    modulePrefix: "", 
    localPrefix: "", 
    "interface": clkInterface,
    direction: "slave"
});

snpReqSkidBufferInterfaces.push({
    modulePrefix: "req_in_", 
    localPrefix: "snp_req_slv_", 
    "interface": SNPReqInterface,
    direction: "slave",
    exclude : []
});

snpReqSkidBufferInterfaces.push({
    modulePrefix: "req_out_", 
    localPrefix: "snp_req_sb_pop_", 
    "interface": SNPReqInterface,
    direction: "master"
});

\jsend
    \=obj.lib.instance({
        instanceName: 'snp_req_skid_buffer',
        moduleName: 'chi_aiu_skid_buffer',
        params : {
          assertOn,
          useSmallArea : 1,
          bypass :       1,
          useQos : fnEnableQos,
          useAge : 1,
          wStarvThreshold : fnEnableQos * wStarvThreshold,
          reqInterface : SNPReqInterface,
          clkInterface,
          priorityThreshold   : fnEnableQos,
          bufferSize          : snpReqSbSize,
          useOutputFifo       : 0,
          priAgeBypass        : 1,
          useSramFifo         : useSramFifoForSnpReqSB
        },
        interfaces            : snpReqSkidBufferInterfaces
    })=\


\js if (assertOn) {
`ifdef OVL_ASSERT_ON
// synthesis_off
// pragma synthesis_off
// coverage off

    property p_snp_rsp_out_ack_vec_onehot0;
        @(posedge clk) disable iff (~reset_n)
            $onehot0(snp_rsp_out_ack_vec);
    endproperty

    property p_snp_rsp_out_ack_vec_idle;
        @(posedge clk) disable iff (~reset_n)
        ~({|{snp_rsp_out_req_vec}}) |-> ~({|{snp_rsp_out_ack_vec}});
    endproperty

    assert_snp_rsp_out_ack_vec_onehot0: assert property (p_snp_rsp_out_ack_vec_onehot0)
        else begin $error("snp_rsp_out_ack_vec must be onehot0 !"); #100 $finish; end

    assert_snp_rsp_out_ack_vec_idle: assert property (p_snp_rsp_out_ack_vec_idle)
        else begin $error("snp_rsp_out_ack_vec must be 0 when snp_rsp_out_req_vec is 0"); #100 $finish; end

// coverage on
// pragma synthesis_on
// synthesis_on
`endif
\js }

endmodule
