\jsbegin
//=============================================================================
// Copyright(C) 2018 Arteris, Inc.
// All rights reserved
//=============================================================================
// DMI Top Level
// Author: Tso-Wei Chang
//=============================================================================
var utilFunctions   = obj.userLib.lib_utils;
var log2ceil                    = function(n) { return Math.ceil(Math.log(n)/Math.LN2); };
var newToOldStyleInterface	= obj.userLib.newToOldStyleInterface.bind( null, obj.userLib );

obj.lib.paramDefault('useMemoryGating',             'int',      0);
obj.lib.paramDefault('usePma',                      'int',      1);
obj.lib.paramDefault('useCmc',                      'int',      0);
obj.lib.paramDefault('ccpParams',                   'object',   {});
obj.lib.paramDefault('useAtomic',                   'int',      0);
obj.lib.paramDefault('assertOn',                    'int',      0);
obj.lib.paramDefault('MemoryGeneration',            'object',   {});
obj.lib.paramDefault('timeOutThreshold',            'int',      0);
obj.lib.paramDefault('wAddr',                       'int',      48);
obj.lib.paramDefault('wRpn',                        'int',      3);
obj.lib.paramDefault('wNrri',                       'int',      3);
obj.lib.paramDefault('nAius',                       'int',      6);
obj.lib.paramDefault('wFPortId',                    'int',      2);
obj.lib.paramDefault('wFUnitId',                    'int',      7);
obj.lib.paramDefault('wNUnitId',                    'int',      5);
obj.lib.paramDefault('wData',                       'int',      128);
obj.lib.paramDefault('cmType',                      'object',   {});
obj.lib.paramDefault('PmaInfo',                     'object',   {});
obj.lib.paramDefault('concParams',                  'object',   {});
obj.lib.paramDefault('concMuxMsgParams',            'object',   {});
obj.lib.paramDefault('engVerId',                    'int',      0);
obj.lib.paramDefault('implVerId',                   'int',      0);
obj.lib.paramDefault('fnErrDetectCorrect',          'string',   "NONE");
obj.lib.paramDefault('useResiliency',               'int',      0);
obj.lib.paramDefault('useAddrTranslation',          'int',      0);
obj.lib.paramDefault('nAddrTransRegisters',         'int',      0);
obj.lib.paramDefault('useWayPartitioning',          'int',      0);
obj.lib.paramDefault('nWayPartitioningRegisters',   'int',      0);
obj.lib.paramDefault('fnNativeInterface',           'string',   "AXI");
obj.lib.paramDefault('ResilienceInfo',              'object',   {});
obj.lib.paramDefault('wCacheLineOffset',            'int',      6);
obj.lib.paramDefault('cmpInfo',                     'object',   {});
obj.lib.paramDefault('interfaces',                  'object',   {});
obj.lib.paramDefault('smiPortParams',               'object',   null);
obj.lib.paramDefault('nativeInterfacePipe',         'int',      1);
obj.lib.paramDefault('enWrPipe',                    'int',      1);
obj.lib.paramDefault('enRdPipe',                    'int',      1);
obj.lib.paramDefault('nUnitTraceBufSize',           'int',      8);
obj.lib.paramDefault('traceDebugEnable',            'boolean',  true);
obj.lib.paramDefault('nPerfCounters', 'int', 4);
obj.lib.paramDefault('syncDepth', 'int', 2);

var usePLRU = 1;

var regProtectionInterface = {};
var regProtectionInterfaceName = "";
var regProtectionStyle = "";
// Variables
var nativeInterfacePipe= obj.lib.getParam('nativeInterfacePipe');
var memFunctions       = obj.userLib;
var utilFunctions      = obj.userLib;
var bundleFunctions    = obj.userLib.bundleFunctions;
var interfaceGen       = obj.userLib.interfaceGenerators;
var wCacheLineOffset   = obj.lib.getParam('wCacheLineOffset');
var assertOn           = obj.lib.getParam('assertOn');
var syncDepth          = obj.lib.getParam('syncDepth');
var wFUnitId           = obj.lib.getParam('wFUnitId');
var wFPortId           = obj.lib.getParam('wFPortId');
var wInitiatorId       = wFUnitId + wFPortId;
var wRpn               = obj.lib.getParam('wRpn');
var wNrri              = obj.lib.getParam('wNrri');
var wNUnitId           = obj.lib.getParam('wNUnitId');
var wMessageId         = obj.lib.getParam('concParams', 'hdrParams', 'wMsgId');
var cmpInfo            = obj.lib.getParam('cmpInfo');
var nMrdSkidBufArb = obj.lib.getParam("nMrdSkidBufArb");
var nMrdSkidBufSize = obj.lib.getParam("nMrdSkidBufSize");
var nCMDSkidBufSize = obj.lib.getParam("nCMDSkidBufSize");
var nCMDSkidBufArb = obj.lib.getParam("nCMDSkidBufArb");
var cmType             = obj.lib.getParam('cmType');
var useCmc             = obj.lib.getParam('useCmc');
var wData              = obj.lib.getParam('wData');
var wAddr              = obj.lib.getParam('wAddr');
var nBeats             = (1<<wCacheLineOffset) / (wData/8);
var useAtomic          = obj.lib.getParam('useAtomic');
var csr                = obj.lib.getParam('csr');
var wCsrData           = obj.lib.getParam('interfaces', 'apbInt', 'params', 'wData');
var wCsrAddr           = obj.lib.getParam('interfaces', 'apbInt', 'params', 'wAddr');
var smiTxPortParams    = obj.lib.getParam('smiPortParams', 'tx');
var smiRxPortParams    = obj.lib.getParam('smiPortParams', 'rx');
var concParams         = obj.lib.getParam('concParams');
var concMuxTxMsgParams = obj.lib.getParam('concMuxMsgParams', 'tx');
var concMuxRxMsgParams = obj.lib.getParam('concMuxMsgParams', 'rx');
var interfaces         = obj.lib.getParam('interfaces');
var axiParams          = interfaces.axiInt.params;
var useAddrTranslation = obj.lib.getParam('useAddrTranslation');
var nAddrTransRegisters= obj.lib.getParam('nAddrTransRegisters');
var fnNativeInterface  = obj.lib.getParam('fnNativeInterface');
var usePma             = obj.lib.getParam('usePma');
var useMemoryGating    = obj.lib.getParam('useMemoryGating');
var PmaInfo            = obj.lib.getParam('PmaInfo');
var nAius              = obj.lib.getParam('nAius');
var fnEnableQos        = obj.userLib.ParamDefaultGet(obj.lib, 'fnEnableQos',            'int',       0);
var QosInfo            = obj.userLib.ParamDefaultGet(obj.lib, 'QosInfo',                'object',   {});
var fnEnableTimeOutRef = obj.userLib.ParamDefaultGet(obj.lib, 'fnEnableTimeOutRef',     'int',       0);
var sameWidthSystem    = 0;
var fnErrDetectCorrect = obj.lib.getParam('fnErrDetectCorrect');
var enWrPipe           = obj.lib.getParam('enWrPipe');
var enRdPipe           = obj.lib.getParam('enRdPipe');
var nUnitTraceBufSize  = obj.lib.getParam('nUnitTraceBufSize');
var traceDebugEnable   = obj.lib.getParam('traceDebugEnable');

//useTrace is always set in ncore_3p2
 /* istanbul ignore next env ncore_3p2, ncore_3p4 */
var useTrace = (concMuxRxMsgParams.hasOwnProperty('dtwDbgRsp') || concMuxTxMsgParams.hasOwnProperty('dtwDbgReq'));
var nPerfCounters      = obj.lib.getParam('nPerfCounters');

var enableReadDataInterleaving  = obj.lib.getParam('cmpInfo', 'useMemRspIntrlv');
var nWrDataBanks                = obj.lib.getParam('cmpInfo', 'nWrDataBanks');
var nRdDataBanks                = obj.lib.getParam('cmpInfo', 'nRdDataBanks');


// way partitioning
var useWayPartitioning          = obj.lib.getParam('useWayPartitioning');
var nWayPartitioningRegisters   = obj.lib.getParam('nWayPartitioningRegisters');
// resilience params
var useResiliency               = obj.lib.getParam('useResiliency');
var ResilienceInfo              = obj.lib.getParam('ResilienceInfo');
var nResiliencyDelay            = ResilienceInfo['nResiliencyDelay'];
var enableUnitDuplication       = ResilienceInfo['enableUnitDuplication'];
var enableNativeIntfProtection  = ResilienceInfo['enableNativeIntfProtection'];
var fnResiliencyProtectionType  = ResilienceInfo['fnResiliencyProtectionType'];
var nResiliencyDelay            = ResilienceInfo['nResiliencyDelay'];
if(useCmc || useAtomic) {
    var ccpParams               = obj.lib.getParam('ccpParams');
    var nrumem                  = 0;
    //parameter not suported in 3.2
    /* istanbul ignore next env ncore_3p0,ncore_3p2,ncore_3p4 */
    if ((ccpParams.nRPPorts == 2) && (ccpParams.RepPolicy != "RANDOM") && (ccpParams.nWays > 1)) {
        nrumem                  = 1;
    }
} else {
    var ccpParams               = {};
    var nrumem                  = 0;
}

if(useAtomic) {
    useCmc = 1;
}

for(var reg=0; reg < csr.spaceBlock[0].registers.length; reg++) { 
    var reg_name = csr.spaceBlock[0].registers[reg].name ;
    for(var field=0; field < csr.spaceBlock[0].registers[reg].fields.length ; field++) {
        var entry = csr.spaceBlock[0].registers[reg].fields[field];
            if(reg_name == "DMIUCRTR" && entry.name == "ResThreshold") {
                var wResThreshold = entry.bitWidth;
            }
      }
}

if ( wResThreshold == undefined ) { 
var wResThreshold = 0;
}

// Concerto Mux RX Message struture
var MRD_REQ = obj.userLib.concMsgGen(obj, 'mrd_req_', 'ConcMsgBodyMRDReq', concParams.hdrParams, concParams.mrdReqParams, concMuxRxMsgParams.mrdReq, 'rx');
var CMD_REQ = obj.userLib.concMsgGen(obj, 'cmd_req_', 'ConcMsgBodyCMDReq', concParams.hdrParams, concParams.cmdReqParams, concMuxRxMsgParams.cmdReq, 'rx');
var RBR_REQ = obj.userLib.concMsgGen(obj, 'rbr_req_', 'ConcMsgBodyRBRReq', concParams.hdrParams, concParams.rbrReqParams, concMuxRxMsgParams.rbrReq, 'rx');
var STR_RSP = obj.userLib.concMsgGen(obj, 'str_rsp_', 'ConcMsgBodySTRRsp', concParams.hdrParams, concParams.strRspParams, concMuxRxMsgParams.strRsp, 'rx');
var RBU_RSP = obj.userLib.concMsgGen(obj, 'rbu_rsp_', 'ConcMsgBodyRBURsp', concParams.hdrParams, concParams.rbuRspParams, concMuxRxMsgParams.rbuRsp, 'rx');
var DTR_RSP = obj.userLib.concMsgGen(obj, 'dtr_rsp_', 'ConcMsgBodyDTRRsp', concParams.hdrParams, concParams.dtrRspParams, concMuxRxMsgParams.dtrRsp, 'rx');
var DTW_REQ = obj.userLib.concMsgGen(obj, 'dtw_req_', 'ConcMsgBodyDTWReq', concParams.hdrParams, concParams.dtwReqParams, concMuxRxMsgParams.dtwReq, 'rx');
var DTWDBG_RSP    = obj.userLib.concMsgGen(obj, 'dtw_dbg_rsp_',    'ConcMsgBodyDTWDBGRsp',   concParams.hdrParams, concParams.dtwDbgRspParams,   concMuxRxMsgParams.dtwDbgRsp,   'rx');

// Concerto Mux TX Message structure
var NC_CMD_RSP = obj.userLib.concMsgGen(obj, 'nc_cmd_rsp_', 'ConcMsgBodyNCCMDRsp', concParams.hdrParams, concParams.ncCmdRspParams, concMuxTxMsgParams.ncCmdRsp, 'tx');
var DTW_RSP    = obj.userLib.concMsgGen(obj, 'dtw_rsp_',    'ConcMsgBodyDTWRsp',   concParams.hdrParams, concParams.dtwRspParams,   concMuxTxMsgParams.dtwRsp,   'tx');
var DTWDBG_REQ = obj.userLib.concMsgGen(obj, 'dtw_dbg_req_', 'ConcMsgBodyDTWDBGReq', concParams.hdrParams, concParams.dtwDbgReqParams, concMuxTxMsgParams.dtwDbgReq, 'tx');
var RBR_RSP    = obj.userLib.concMsgGen(obj, 'rbr_rsp_',    'ConcMsgBodyRBRRsp',   concParams.hdrParams, concParams.rbrRspParams,   concMuxTxMsgParams.rbrRsp,   'tx');
var RBU_REQ    = obj.userLib.concMsgGen(obj, 'rbu_req_',    'ConcMsgBodyRBUReq',   concParams.hdrParams, concParams.rbuReqParams,   concMuxTxMsgParams.rbuReq,   'tx');
var STR_REQ    = obj.userLib.concMsgGen(obj, 'str_req_',    'ConcMsgBodySTRReq',   concParams.hdrParams, concParams.strReqParams,   concMuxTxMsgParams.strReq,   'tx');
var MRD_RSP    = obj.userLib.concMsgGen(obj, 'mrd_rsp_',    'ConcMsgBodyMRDRsp',   concParams.hdrParams, concParams.mrdRspParams,   concMuxTxMsgParams.mrdRsp,   'tx');
var DTR_REQ    = obj.userLib.concMsgGen(obj, 'dtr_req_',    'ConcMsgBodyDTRReq',   concParams.hdrParams, concParams.dtrReqParams,   concMuxTxMsgParams.dtrReq,   'tx');

var CONC_TX_INTF = [];
var CONC_RX_INTF = [];
CONC_TX_INTF.push(NC_CMD_RSP, DTW_RSP, RBR_RSP, RBU_REQ, STR_REQ, MRD_RSP, DTR_REQ);
//not a user settable parameter.
 /* istanbul ignore else env ncore_3p2, ncore_3p4 */
if(useTrace) { 
CONC_TX_INTF.push(DTWDBG_REQ); 
}
CONC_RX_INTF.push(CMD_REQ, MRD_REQ, RBR_REQ, STR_RSP, RBU_RSP, DTR_RSP, DTW_REQ);
//not a user settable parameter.
 /* istanbul ignore else env ncore_3p2, ncore_3p4 */
if(useTrace) { 
CONC_RX_INTF.push(DTWDBG_RSP); 
}
//console.log("DMI:CONC_RX_INTF = \n"+JSON.stringify(CONC_RX_INTF,null,8));
// Concerto Message Interfaces generation
var CONC_INTF = {};
CONC_INTF['CMDReqInterface']  = CMD_REQ.signals;
CONC_INTF['MRDReqInterface']  = MRD_REQ.signals;
CONC_INTF['RBReqInterface']   = RBR_REQ.signals;
CONC_INTF['STRRespInterface'] = STR_RSP.signals;
CONC_INTF['RBURespInterface'] = RBU_RSP.signals;
CONC_INTF['DTRRespInterface'] = DTR_RSP.signals;
CONC_INTF['DTWReqInterface']  = DTW_REQ.signals;
CONC_INTF['NCCMDRespInterface'] = NC_CMD_RSP.signals;
CONC_INTF['DTWRespInterface']   = DTW_RSP.signals;
CONC_INTF['RBRRespInterface']   = RBR_RSP.signals;
CONC_INTF['RBUseInterface']     = RBU_REQ.signals;
CONC_INTF['STRReqInterface']    = STR_REQ.signals;
CONC_INTF['MRDRespInterface']   = MRD_RSP.signals;
CONC_INTF['DTRReqInterface']    = DTR_REQ.signals;
//not user settable
 /* istanbul ignore else env ncore_3p2, ncore_3p4 */
if(useTrace) { 
CONC_INTF['DTWDBGReqInterface']  = DTWDBG_REQ.signals;
CONC_INTF['DTWDBGRespInterface']   = DTWDBG_RSP.signals;
} else {
CONC_INTF['DTWDBGReqInterface']  = DTW_REQ.signals;
CONC_INTF['DTWDBGRespInterface']   = DTW_RSP.signals;
}

// SMI interface params generation
var SMI_TX_INTF = [];
var SMI_TX_INTF_DIRECTION = [];
var SMI_RX_INTF = [];
var SMI_RX_INTF_DIRECTION = [];
for(var i = 0; i< smiTxPortParams.length; i++) {
    SMI_TX_INTF.push(obj.userLib.smiPortGen(obj, smiTxPortParams[i], interfaces.smiTxInt[i].params, 'tx'));
    SMI_TX_INTF_DIRECTION.push(interfaces.smiTxInt[i].direction);
};

for(var i = 0; i < smiRxPortParams.length; i++) {
    SMI_RX_INTF.push(obj.userLib.smiPortGen(obj, smiRxPortParams[i], interfaces.smiRxInt[i].params, 'rx'));
    SMI_RX_INTF_DIRECTION.push(interfaces.smiRxInt[i].direction);
};

// AXI interface params generation
var interfaceFunc = new obj.userLib[interfaces.axiInt.interface];
var axiInterface = interfaceFunc.getSignals(interfaces.axiInt.params);
var axiInterfaceBundle = interfaceFunc.getSignalsBundle(interfaces.axiInt.params);

// APB interface params generation
var interfaceFunc = new obj.userLib[interfaces.apbInt.interface];
var apbInterface = interfaceFunc.getSignalsBundle(interfaces.apbInt.params);

// clk interface params generation
var interfaceFunc       = new obj.userLib[interfaces.clkInt.interface];
var clkInterface        = interfaceFunc.getSignalsBundle(interfaces.clkInt.params);
var clkInterfaceName    = interfaces.clkInt.name; 
var clkInterfaceParam   = interfaces.clkInt.params;
var blkClkGateOn        = interfaces.clkInt.blkClkGateOn;
var intClkInterface     = { clk: 1, reset_n: 1 }; 

// IRQ interface params generation
var interfaceFunc = new obj.userLib[interfaces.irqInt.interface];
var irqInterface = interfaceFunc.getSignalsBundle(interfaces.irqInt.params);

// Unit Id interface params generation
var interfaceFunc = new obj.userLib[interfaces.uIdInt.interface];
var unitIdInterface = interfaceFunc.getSignalsBundle(interfaces.uIdInt.params);
var unitIdInterfaceName = interfaces.uIdInt.name;
// PIN interface params generation
var havePinInterface = interfaces.bistDebugDisableInt && !interfaces.bistDebugDisableInt._SKIP_;
// Unit Dve Id interface params generation
var haveDveInterface = interfaces.uSysDveIdInt !== undefined;
//not user settable
 /* istanbul ignore else env ncore_3p2, ncore_3p4 */
if (haveDveInterface) {
  var interfaceFunc         = new obj.userLib[interfaces.uSysDveIdInt.interface];
  var uDveIdInterface       = interfaceFunc.getSignals(interfaces.uSysDveIdInt.params);
  var uDveIdInterfaceBundle = interfaceFunc.getSignalsBundle(interfaces.uSysDveIdInt.params);
  var uDveIdInterfaceName   = interfaces.uSysDveIdInt.name;
}

// System Unit Id interface params generation
var interfaceFunc = new obj.userLib[interfaces.uSysIdInt.interface];
var sysUnitIdInterface = interfaceFunc.getSignalsBundle(interfaces.uSysIdInt.params);
var sysUnitIdInterfaceName = interfaces.uSysIdInt.name;
// Resiliency interface params generation
if(useResiliency) {
  var interfaceFunc         = new obj.userLib[interfaces.bistInt.interface];
  var bistInterface         = interfaceFunc.getSignals(interfaces.bistInt.params);
  var bistInterfaceBundle   = interfaceFunc.getSignalsBundle(interfaces.bistInt.params);
  var bistInterfaceName     = interfaces.bistInt.name;

  var interfaceFunc          = new obj.userLib[interfaces.faultInt.interface];
  var faultInterface         = interfaceFunc.getSignals(interfaces.faultInt.params);
  var faultInterfaceBundle   = interfaceFunc.getSignalsBundle(interfaces.faultInt.params);
  var faultInterfaceName     = interfaces.faultInt.name;

    if (enableUnitDuplication) {
var interfaceFunc            = new obj.userLib[interfaces.checkClkInt.interface];
var checkClkInterface        = interfaceFunc.getSignalsBundle(interfaces.checkClkInt.params);
var checkClkInterfaceName    = interfaces.checkClkInt.name; 
var checkClkInterfaceParam   = interfaces.checkClkInt.params;
var checkBlkClkGateOn        = interfaces.checkClkInt.blkClkGateOn;
    }
}

if(usePma) {
// Q-Channel Interface
var interfaceFunc        = new obj.userLib[interfaces.qInt.interface];
var qInterface           = interfaceFunc.getSignals(interfaces.qInt.params);
var qInterfaceBundle     = interfaceFunc.getSignalsBundle(interfaces.qInt.params);
var qInterfaceName       = interfaces.qInt.name;
} else {
var qInterfaceBundle     = {};
var qInterfaceName       = '';
}

// Read Data Interface: used in transaction control logic
var readDataInterface = {
    valid:  1,
    ready: -1,
    last:   1,
    first:  1,
    resp:  -axiInterfaceBundle.r_.resp,
    id:    -axiInterfaceBundle.r_.id,
    data:   wData,
    user:  -axiInterfaceBundle.r_.user
}

// Register Protection interface params generation


// internal Fault interface
var internalFaultInterface  = {
        placeholder_UCE         : 1,
        placeholder_CE          : 1,
        timeout_error_UCE       : 1,
        cmux_UCE                : 1,
        smc_tag_UCE             : 1,
        smc_tag_CE              : 1,
        smc_data_UCE            : 1,
        smc_data_CE             : 1,
        c_wr_buff_UCE           : 1,
        c_wr_buff_CE            : 1,
        rd_buffer_UCE           : 1,
        rd_buffer_CE            : 1,
        target_id_UCE           : 1,
        native_wr_resp_UCE      : 1,
        native_rd_resp_UCE      : 1,
        cmux_cmd_req_CE         : 1,
        cmux_mrd_req_CE         : 1,
        cmux_rbr_req_CE         : 1,
        cmux_str_rsp_CE         : 1,
        cmux_rbu_rsp_CE         : 1,
        cmux_dtr_rsp_CE         : 1,
        cmux_dtw_req_CE         : 1,
        cmux_dtw_dbg_rsp_CE     : 1
    };

// native placeholder interface params generation
if(enableNativeIntfProtection & useResiliency) {
  var interfaceFunc        = new obj.userLib[interfaces.userPlaceInt.interface];
  var placeInterface       = interfaceFunc.getSignals(interfaces.userPlaceInt.params);
  var placeInterfaceBundle = interfaceFunc.getSignalsBundle(interfaces.userPlaceInt.params);
  var placeInterfaceName   = interfaces.userPlaceInt.name;
  var placeInterfaceDef    = interfaces.userPlaceInt.synonyms;
  var placeInterfaceSkip   = interfaces.userPlaceInt._SKIP_;
} else {
  var placeInterface       = {};
  var placeInterfaceBundle = {};
  var placeInterfaceName   = "";
  var placeInterfaceDef    = {};
  var placeInterfaceSkip   = true;
}

// Generic interface (for memory sideband signals) params generation
  var memInterfaceFunc      = [];
  var memInterface          = [];
  var memInterfaceBundle    = [];
  var memInterfaceName      = [];
  var memInterfaceDirection = [];
  var memInterfaceDef       = [];
  var memInterfaceSkip      = [];
  var memInterfaceDict      = {};
  for (var i=0; i < interfaces.memoryInt.length; i++) {
    memInterfaceFunc.push( new obj.userLib[interfaces.memoryInt[i].interface] );
    memInterface.push( memInterfaceFunc[i].getSignals(interfaces.memoryInt[i].params) );
    memInterfaceBundle.push( memInterfaceFunc[i].getSignalsBundle(interfaces.memoryInt[i].params) );
    memInterfaceName.push( interfaces.memoryInt[i].name );
    memInterfaceDirection.push( interfaces.memoryInt[i].direction );
    memInterfaceDef.push( interfaces.memoryInt[i].synonyms );
    memInterfaceSkip.push( interfaces.memoryInt[i]._SKIP_ );
    memInterfaceDict[ interfaces.memoryInt[i].name ] = i;
  }

var MemoryGeneration = obj.lib.getParam('MemoryGeneration');

var ccpMemoryInterface = {};
var wrDataBufferMemoryInterface = {};
var cWrDataGen      = obj.lib.getParam('MemoryGeneration', 'wrDataMem');
var useExWrDataMem  = (cWrDataGen[0].MemType !== "NONE");
var cWrMemPorts     = "sp";
var wrBufferProtType= fnErrDetectCorrect;
var dataBuffer = {
    intf_size:    DTW_REQ.signals.intf_size,
    aux:          DTW_REQ.signals.aux,
    initiator_id: DTW_REQ.signals.initiator_id,
    message_id:   DTW_REQ.signals.message_id,
    cm_type:      DTW_REQ.signals.cm_type,
    rb_id :       DTW_REQ.signals.rb_id,
    cm_status:    DTW_REQ.signals.cm_status,
    rl:           DTW_REQ.signals.rl,
    primary:      DTW_REQ.signals.primary,
    mpf1:         DTW_REQ.signals.mpf1,
    mpf2:         DTW_REQ.signals.mpf2,
    dwid:         DTW_REQ.signals.dwid,
    dbad:         DTW_REQ.signals.dbad,
    tm:           DTW_REQ.signals.tm,
    valid:        1,
    ready:       -1,
    last:         1,
    data:         wData,
    be:           wData/8,
    user:         DTW_REQ.signals.user        
};
var cWrDataWidth    = bundleFunctions.getBundleWidth( dataBuffer, ['valid', 'ready'], obj.lib.bundle);
var cWrDataParam    = memFunctions.dataBufferMemoryParams(cWrDataWidth, cmpInfo.nDceRbEntries, nBeats, nWrDataBanks, wrBufferProtType, {"sramAddressProtection" : 1});
var wrDataStructures= [];
for (var i = 0; i < nWrDataBanks; i++) {
    wrDataStructures[i] =
            memFunctions.createMemoryDataStructure(
                cWrDataGen[0],
                cWrDataParam,
                cWrMemPorts,
                0, // biten
                cWrDataGen[0].rtlPrefixString,
                '',
                0 // unused
            );
}
// pass information to lower hierarchy
cWrDataParam['nBanks'] = nWrDataBanks;
cWrDataParam['nPorts'] = cWrMemPorts;
// External Memory signals
for (var i = 0; i < nWrDataBanks; i++) {
    if (wrDataStructures[i].memoryType === "SYNOPSYS") {
        /* istanbul ignore if env ncore_3p0, ncore_3p2, ncore_3p4 */
        if (Object.keys(wrDataStructures[i].signals).length > 0) {
            utilFunctions.defineMasterPortsFromInterface(wrDataStructures[i].rtlPrefixString + i + '_', wrDataStructures[i].signals, obj.lib.port);
        }
    }
}

for(var bank = 0; bank < wrDataStructures.length; bank++) {
    for(var signal in wrDataStructures[bank].controlSignals) {
        wrDataBufferMemoryInterface[cWrDataGen[0].rtlPrefixString+bank+'_'+signal] = wrDataStructures[bank].controlSignals[signal];
    }
}
// Read Buffer Params
var rdBufferPorts     = "sp";
var rdBufferMemoryInterface = {};
var rdBufferProtType= fnErrDetectCorrect;
var rdBufferGen      = obj.lib.getParam('MemoryGeneration', 'rdDataMem');
var useExRdDataMem          = (rdBufferGen[0].MemType !== "NONE") && enableReadDataInterleaving;
var rdDataStructures= [];
var rdBufferWidth    = bundleFunctions.getBundleWidth( readDataInterface, ['valid', 'ready','first'], obj.lib.bundle);
var rdBufferParam   = memFunctions.dataBufferMemoryParams(rdBufferWidth, cmpInfo.nRttCtrlEntries, nBeats, nRdDataBanks, rdBufferProtType, {"sramAddressProtection" : 1});
// pass information to lower hierarchy
rdBufferParam['nBanks'] = nRdDataBanks;
rdBufferParam['nPorts'] = rdBufferPorts;
for (var i = 0; i < nRdDataBanks; i++) {
    rdDataStructures[i] =
            memFunctions.createMemoryDataStructure(
                rdBufferGen[0],
                rdBufferParam,
                rdBufferPorts,
                0, // biten
                rdBufferGen[0].rtlPrefixString,
                '',
                0 // unused
            );
}

for(var bank = 0; bank < rdDataStructures.length; bank++) {
    for(var signal in rdDataStructures[bank].controlSignals) {
        rdBufferMemoryInterface[rdBufferGen[0].rtlPrefixString+bank+'_'+signal] = rdDataStructures[bank].controlSignals[signal];
    }
}

//=============================================================================
// Trace CSR Interface
//=============================================================================
const CSRS                      = obj.lib.getParam('csr');
const traceRegisters		    = obj.userLib.genTraceCaptureRegisters(CSRS.spaceBlock[0].registers, "DMI");
const traceCsrIfGenerator   	= obj.userLib.createCSRInterfaceGenerator( traceRegisters );

if(useCmc) {
//NOTE: DMI passes ccpParams as the only parameter object to CCP, and CCP treats TagMemAddressProtection and DataMemAddressPrection as default parameters.
//            instanceName: 'dmi_ccp',
//            moduleName: 'ccp_top',
//            params: ccpParams,
    ccpParams['enTagpipeDatapipeDecoupleTimingFix'] = 1;
    ccpParams['TagMemAddressProtection'] = 1;
    ccpParams['DataMemAddressProtection'] = 1;
    ccpParams['usePLRU'] = usePLRU;
    ccpParams['plru_addr_w'] = log2ceil(ccpParams.nSets / ccpParams.nTagBanks);
    var ccpTagGen       = obj.lib.getParam('MemoryGeneration', 'tagMem');
    var ccpDataGen      = obj.lib.getParam('MemoryGeneration', 'dataMem');
    var ccpRpGen        = obj.lib.getParam('MemoryGeneration', 'rpMem');
    var tagMemRtlPrefix = ccpTagGen[0].rtlPrefixString;
    var dataMemRtlPrefix= ccpDataGen[0].rtlPrefixString;
    var rpMemRtlPrefix  = (ccpRpGen.length > 0) ?  /* istanbul ignore next env ncore_3p2, ncore_3p4 */  ccpRpGen[0].rtlPrefixString : "";
    var tagP            = memFunctions.ccpTagMemoryParams(obj.lib.getParam(), { sramAddressProtection : ccpParams.TagMemAddressProtection });
    var dataP           = memFunctions.ccpDataMemoryParams(obj.lib.getParam(), { sramAddressProtection : ccpParams.DataMemAddressProtection });
    var rpP             = memFunctions.ccpRpMemoryParams(obj.lib.getParam());
    var tagStructures   = [];
    var dataStructures  = [];
    var rpStructures    = [];
    var portNum         = 0; // unused

    for (var i = 0; i < ccpParams.nTagBanks; i++) {
        tagStructures[i] = 
            memFunctions.createMemoryDataStructure(
                ccpTagGen[i],
                tagP,  
                'sp',
                1,
                ccpTagGen[i].rtlPrefixString, //tagMemRtlPrefix,
                '',
                portNum);

        //fixed parameter
        /* istanbul ignore if env ncore_3p0, ncore_3p2, ncore_3p4 */
        if (nrumem) {
            rpStructures[i] = memFunctions.createMemoryDataStructure(
                                  ccpRpGen[0],
                                  rpP,
                                  'tp',
                                  1,
                                  rpMemRtlPrefix,
                                  '',
                                  portNum);
        }
    }

    for (var i = 0; i < ccpParams.nDataBanks; i++) {
        dataStructures[i] =
            memFunctions.createMemoryDataStructure(
                ccpDataGen[i],
                dataP,
                'sp',
                0,
                ccpDataGen[i].rtlPrefixString, //dataMemRtlPrefix,
                '',
                portNum);
    }

    for (var i = 0; i < ccpParams.nTagBanks; i++) {
        if (tagStructures[i].memoryType === "SYNOPSYS") {
            /* istanbul ignore if env ncore_3p0, ncore_3p2, ncore_3p4*/
            if (Object.keys(tagStructures[i].signals).length > 0) {
                utilFunctions.defineMasterPortsFromInterface(tagStructures[i].rtlPrefixString + i + '_', tagStructures[i].signals, obj.lib.port);
            }
            //parameter not supported in 3.2
            /* istanbul ignore if env ncore_3p0, ncore_3p2, ncore_3p4 */
            if (nrumem) {
                if (Object.keys(rpStructures[i].signals).length > 0) {
                    utilFunctions.defineMasterPortsFromInterface(rpStructures[i].rtlPrefixString + i + '_', rpStructures[i].signals, obj.lib.port);
                }
            }
        }
    }

    for (var i = 0; i < ccpParams.nDataBanks; i++) {
        if (dataStructures[i].memoryType === "SYNOPSYS") {
            /* istanbul ignore if env ncore_3p0, ncore_3p2, ncore_3p4*/
            if (Object.keys(dataStructures[i].signals).length > 0) {
                utilFunctions.defineMasterPortsFromInterface(dataStructures[i].rtlPrefixString + i + '_', dataStructures[i].signals, obj.lib.port);
            }
        }
    }
    ccpParams['tagStructures']  = tagStructures;
    ccpParams['dataStructures'] = dataStructures;
    ccpParams['rpStructures']   = rpStructures;

   for(var bank = 0; bank < tagStructures.length; bank++) {
       for(var signal in tagStructures[bank].controlSignals) {
           ccpMemoryInterface[tagStructures[bank].rtlPrefixString+bank+'_'+signal] = tagStructures[bank].controlSignals[signal];
       }
        //parameter not supported in 3.2
        /* istanbul ignore if env ncore_3p0, ncore_3p2, ncore_3p4 */
       if(nrumem) {
           for(var signal in rpStructures[bank].controlSignals) {
               ccpMemoryInterface[rpMemRtlPrefix+bank+'_'+signal] = rpStructures[bank].controlSignals[signal];
           }
       }
   }
   for(var bank = 0; bank < dataStructures.length; bank++) {
       for(var signal in dataStructures[bank].controlSignals) {
           ccpMemoryInterface[dataStructures[bank].rtlPrefixString+bank+'_'+signal] = dataStructures[bank].controlSignals[signal];
       }
   }

} // useCmc

// Top level Ports
//
// clk interface
obj.lib.interface(clkInterfaceName, 'slave', clkInterface);

// irq interface
obj.lib.interface(interfaces.irqInt.name, interfaces.irqInt.direction, irqInterface);


for (i=0; i<SMI_TX_INTF.length; i++) {
                                      obj.userLib.defineMasterPortsFromInterface(SMI_TX_INTF[i].name, SMI_TX_INTF[i].signals, obj.lib.port);
                                      if(SMI_TX_INTF[i].params.dpPresent) {
                                            obj.userLib.defineMasterPortsFromInterface(SMI_TX_INTF[i].name, SMI_TX_INTF[i].dpSignals, obj.lib.port);    
                                      }
                                     }
for (i=0; i<SMI_RX_INTF.length; i++) {
                                      obj.userLib.defineSlavePortsFromInterface(SMI_RX_INTF[i].name, SMI_RX_INTF[i].signals, obj.lib.port);
                                      if(SMI_RX_INTF[i].params.dpPresent) {
                                            obj.userLib.defineSlavePortsFromInterface(SMI_RX_INTF[i].name, SMI_RX_INTF[i].dpSignals, obj.lib.port);    
                                      }
                                     }

//
// AXI Interface
//
obj.lib.interface(interfaces.axiInt.name, interfaces.axiInt.direction, axiInterface);
//
// APB Interface
//
obj.lib.interface(interfaces.apbInt.name, interfaces.apbInt.direction, apbInterface);
//
// Unit Id Interface
//
obj.lib.interface(interfaces.uIdInt.name, interfaces.uIdInt.direction, unitIdInterface);
//
// Unit dve Id Interface
//
//dve always present
 /* istanbul ignore else env ncore_3p2, ncore_3p4 */
if (haveDveInterface) {
    obj.lib.interface(uDveIdInterfaceName, interfaces.uSysDveIdInt.direction, uDveIdInterface);
}
//
// Sys Unit Id Interface
//
obj.lib.interface(interfaces.uSysIdInt.name, interfaces.uSysIdInt.direction, sysUnitIdInterface);

//
// Resiliency interface
//
if(useResiliency) {
    obj.lib.interface(bistInterfaceName, interfaces.bistInt.direction, bistInterface);
    obj.lib.interface(faultInterfaceName, interfaces.faultInt.direction , faultInterface);
    if (enableUnitDuplication) {
    obj.lib.interface(checkClkInterfaceName, interfaces.checkClkInt.direction, checkClkInterface);
    }
}
//
// Placeholder Interface
//
if(enableNativeIntfProtection & useResiliency) {
    obj.lib.interface(placeInterfaceName, interfaces.userPlaceInt.direction , placeInterface);
}

//
// Memory Interface Sideband Signals 
//
for (var i=0; i < memInterface.length; i++) {
    obj.lib.interface(memInterfaceName[i], memInterfaceDirection[i], memInterface[i]);
}

if(usePma) {
//
// Q Interface
//
obj.lib.interface(qInterfaceName, interfaces.qInt.direction, qInterface);
}

//=============================================================================
// PIN Interface
//=============================================================================
if( havePinInterface ) {
  var pinInterface      = newToOldStyleInterface( interfaces.bistDebugDisableInt );
  obj.lib.interface( pinInterface.name, 'slave', pinInterface.signals);
}
//=============================================================================
// Master Trigger Interface
//=============================================================================
// trigger intf always present on 3.4 
/* istanbul ignore else env ncore_3p4 */
if( interfaces.masterTriggerInt && !interfaces.masterTriggerInt._SKIP_ ) {
  var masterTriggerInterface      = newToOldStyleInterface( interfaces.masterTriggerInt );
  obj.lib.interface( masterTriggerInterface.name, 'slave', masterTriggerInterface.signals);
}


obj.lib.setAttribute("csr", csr);

\jsend
module \=obj.lib.getModuleName()=\ (\=obj.lib.getPorts('\n')=\);

\jsbegin
    //
    // Wire Declarations
    //
\jsend

// Trace Capture Registers
\=obj.userLib.bundleFunctions.wiresFromInterface('csr_trace_',traceCsrIfGenerator.signalBundle('master'), [], obj.lib.bundle)=\
// Trace Capture DTW DBG
\=obj.userLib.bundleFunctions.wiresFromInterface('dtw_dbg_req_',CONC_INTF['DTWDBGReqInterface'], [], obj.lib.bundle)=\
\=obj.userLib.bundleFunctions.wiresFromInterface('dtw_dbg_rsp_',CONC_INTF['DTWDBGRespInterface'], [], obj.lib.bundle)=\

\=bundleFunctions.wiresFromInterface('dmi_', internalFaultInterface,   [], obj.lib.bundle)=\

wire trace_capture_busy; \jsbegin

// trigger intf always present on 3.4 
/* istanbul ignore else env ncore_3p4 */
if( interfaces.masterTriggerInt && !interfaces.masterTriggerInt._SKIP_ ) { \jsend
wire \=masterTriggerInterface.name=\trigger_sync; \jsbegin
} \jsend

\jsbegin
if (useResiliency) {
    /* istanbul ignore else env ncore_3p4 */
    if (havePinInterface) { \jsend
wire dmi_en_debug_bist;
\=obj.lib.instance({
   instanceName: 'u_en_debug_bist_sync',
   moduleName:   'dffr_sync',
   params: {
       'width' : 1,
       'depth' : syncDepth,
   },
   ports: {
       clk      : clkInterfaceName+'clk',
       reset_n  : clkInterfaceName+'reset_n',
       in_data  : pinInterface.name+'pin',
       out_data : 'dmi_en_debug_bist'
    }
})=\
    \jsbegin
    } else { \jsend
wire dmi_en_debug_bist = 1'b1; 
    \jsbegin
    } \jsend
wire fault_checker_clk;
wire fault_checker_reset_n;
wire [\=wResThreshold-1=\:0] res_cerr_thresh;
\jsbegin
} \jsend

\js if (usePma) {
wire \=qInterfaceName=\REQn_sync;
\js }

\js if (useResiliency && enableUnitDuplication) {
wire dup_unit__trace_capture_busy;
wire [\=wResThreshold-1=\:0] dup_unit__res_cerr_thresh;

\jsbegin
// trigger intf always present on 3.4 
/* istanbul ignore else env ncore_3p4 */
if (interfaces.masterTriggerInt && !interfaces.masterTriggerInt._SKIP_) { \jsend
\=bundleFunctions.wiresFromInterface('dup_unit__' + masterTriggerInterface.name, masterTriggerInterface.signals, ['trigger'], obj.lib.bundle)=\
wire dup_unit__\=masterTriggerInterface.name=\trigger_sync;
wire dup_unit__\=masterTriggerInterface.name=\trigger; 
\jsbegin 
} \jsend
\=bundleFunctions.wiresFromInterface('dup_unit__' + clkInterfaceName,           clkInterface,           [], obj.lib.bundle)=\

\=bundleFunctions.wiresFromInterface('dup_unit__' + interfaces.uIdInt.name,     unitIdInterface,        [], obj.lib.bundle)=\

\jsbegin
//dve always present
 /* istanbul ignore else env ncore_3p2, ncore_3p4 */
if (haveDveInterface) {
\jsend

  \=bundleFunctions.wiresFromInterface('dup_unit__' + uDveIdInterfaceName,     uDveIdInterface,        [], obj.lib.bundle)=\

\jsbegin
    }
\jsend

// Trace Capture DTW DBG
\=obj.userLib.bundleFunctions.wiresFromInterface('dup_unit__dtw_dbg_req_',CONC_INTF['DTWDBGReqInterface'], [], obj.lib.bundle)=\
\=obj.userLib.bundleFunctions.wiresFromInterface('dup_unit__dtw_dbg_rsp_',CONC_INTF['DTWDBGRespInterface'], [], obj.lib.bundle)=\
\=obj.userLib.bundleFunctions.wiresFromInterface('dup_unit__csr_trace_',traceCsrIfGenerator.signalBundle('master'), [], obj.lib.bundle)=\

\=bundleFunctions.wiresFromInterface('dup_unit__' + interfaces.apbInt.name,     apbInterface,           [], obj.lib.bundle)=\

\=bundleFunctions.wiresFromInterface('dup_unit__' + interfaces.irqInt.name,     irqInterface,           [], obj.lib.bundle)=\

\=bundleFunctions.wiresFromInterface('dup_unit__' + interfaces.axiInt.name,     axiInterface,           [], obj.lib.bundle)=\

\=bundleFunctions.wiresFromInterface('dup_unit__dmi_',                          internalFaultInterface, [], obj.lib.bundle)=\

\=bundleFunctions.wiresFromInterface('dup_unit__' + interfaces.uSysIdInt.name,  sysUnitIdInterface,     [], obj.lib.bundle)=\
\js if (enableNativeIntfProtection) {
\=bundleFunctions.wiresFromInterface('dup_unit__' + placeInterfaceName,  placeInterface,     [], obj.lib.bundle)=\
\js }

\js if(usePma) {
\=bundleFunctions.wiresFromInterface('dup_unit__' + qInterfaceName,  qInterface,     ['REQn'], obj.lib.bundle)=\
wire dup_unit__\=qInterfaceName=\REQn;
wire dup_unit__\=qInterfaceName=\REQn_sync;
\js }




\js for (var i=0; i < SMI_TX_INTF.length; i++) {
\=bundleFunctions.wiresFromInterface('dup_unit__' + SMI_TX_INTF[i].name, SMI_TX_INTF[i].signals, [], obj.lib.bundle)=\
    \js if (SMI_TX_INTF[i].params.dpPresent) {
\=bundleFunctions.wiresFromInterface('dup_unit__' + SMI_TX_INTF[i].name,SMI_TX_INTF[i].dpSignals, [], obj.lib.bundle)=\
    \js }
\js };

\js for (var i=0; i < SMI_RX_INTF.length; i++) {
\=bundleFunctions.wiresFromInterface('dup_unit__' + SMI_RX_INTF[i].name, SMI_RX_INTF[i].signals, [], obj.lib.bundle)=\
    \js if (SMI_RX_INTF[i].params.dpPresent) {
\=bundleFunctions.wiresFromInterface('dup_unit__' + SMI_RX_INTF[i].name, SMI_RX_INTF[i].dpSignals, [], obj.lib.bundle)=\
    \js }
\js };


\js }

\jsbegin
if(useExRdDataMem) {
    var str = '';
    for (var i = 0; i < nRdDataBanks; i++) {
        var rtlPrefixString = rdDataStructures[i].rtlPrefixString + i;
        var memoryControlInterface = rdDataStructures[i].controlSignals;
        str += utilFunctions.string_defineSignalsFromInterface('mem__' + rtlPrefixString + '_', memoryControlInterface);
        str += utilFunctions.string_defineSignalsFromInterface(''      + rtlPrefixString + '_', memoryControlInterface);
        if (useResiliency & enableUnitDuplication) {
            str += utilFunctions.string_defineSignalsFromInterface('dup_unit__' + rtlPrefixString + '_', memoryControlInterface);
        }

    }
\jsend
\=str=\
\jsbegin
} \jsend

\jsbegin
    if(useExWrDataMem) {
        var str = '';
        for (var i = 0; i < nWrDataBanks; i++) {
            var rtlPrefixString = wrDataStructures[i].rtlPrefixString + i;
            var memoryControlInterface = wrDataStructures[i].controlSignals;
            str += utilFunctions.string_defineSignalsFromInterface('mem__' + rtlPrefixString + '_', memoryControlInterface);
            str += utilFunctions.string_defineSignalsFromInterface(''      + rtlPrefixString + '_', memoryControlInterface);
            if (useResiliency & enableUnitDuplication) {
                str += utilFunctions.string_defineSignalsFromInterface('dup_unit__' + rtlPrefixString + '_', memoryControlInterface);
            }

        }
\jsend
\=str=\
\js }
\jsbegin
    if(useCmc) {
        var str = '';
        for (var i = 0; i < ccpParams.nTagBanks; i++) {
            var rtlPrefixString = tagStructures[i].rtlPrefixString + i;
            var memoryControlInterface = tagStructures[i].controlSignals;
            str += utilFunctions.string_defineSignalsFromInterface('mem__' + rtlPrefixString + '_', memoryControlInterface);
            str += utilFunctions.string_defineSignalsFromInterface(''      + rtlPrefixString + '_', memoryControlInterface);
            if (useResiliency & enableUnitDuplication) {
            str += utilFunctions.string_defineSignalsFromInterface('dup_unit__' + rtlPrefixString + '_', memoryControlInterface);
            }
            //parameter not supported in 3.2
            /* istanbul ignore if env ncore_3p0, ncore_3p2, ncore_3p4 */
            if(nrumem) {
                var rtlPrefixString = rpStructures[i].rtlPrefixString + i;
                var memoryControlInterface = rpStructures[i].controlSignals;
                str += utilFunctions.string_defineSignalsFromInterface('mem__' + rtlPrefixString + '_', memoryControlInterface);
                str += utilFunctions.string_defineSignalsFromInterface(''      + rtlPrefixString + '_', memoryControlInterface);
                if (useResiliency & enableUnitDuplication) {
                    str += utilFunctions.string_defineSignalsFromInterface('dup_unit__' + rtlPrefixString + '_', memoryControlInterface);
                }

            }
        }

\jsend
\=str=\
\jsbegin
        var str = '';
        for (var i = 0; i < ccpParams.nDataBanks; i++) {
            var rtlPrefixString = dataStructures[i].rtlPrefixString + i;
            var memoryControlInterface = dataStructures[i].controlSignals;
            str += utilFunctions.string_defineSignalsFromInterface('mem__' + rtlPrefixString + '_', memoryControlInterface);
            str += utilFunctions.string_defineSignalsFromInterface(''      + rtlPrefixString + '_', memoryControlInterface);
            if (useResiliency & enableUnitDuplication) {
                str += utilFunctions.string_defineSignalsFromInterface('dup_unit__' + rtlPrefixString + '_', memoryControlInterface);
            }

        }
\jsend
\=str=\
\js } //useCmc
\jsbegin
// =======================================================
// dmi core logic instantiation
// =======================================================
\jsend
\jsbegin
    var DMI_UNIT_INTF = [];
    var TRACE_CAPTURE_INTF = [];
    var nNonDataNetworks = 0; 
    var nDataNetworks = 0; 

    DMI_UNIT_INTF.push({
        modulePrefix: '',
        localPrefix: clkInterfaceName,
        interface: clkInterface,
        direction: interfaces.clkInt.direction
    });    

    DMI_UNIT_INTF.push({
        modulePrefix: 'axi_mst_',
        localPrefix: interfaces.axiInt.name,
        interface: axiInterfaceBundle,
        direction: interfaces.axiInt.direction
    });

    DMI_UNIT_INTF.push({
        modulePrefix: 'apb_slv_',
        localPrefix: interfaces.apbInt.name,
        interface: apbInterface,
        direction: interfaces.apbInt.direction
    });

    DMI_UNIT_INTF.push({
        modulePrefix: 'irq_',
        localPrefix: interfaces.irqInt.name,
        interface: irqInterface,
        direction: interfaces.irqInt.direction,
        excludeFromFC : true
    });

    DMI_UNIT_INTF.push({
        modulePrefix: 'dmi_',
        localPrefix: 'dmi_',
        interface: internalFaultInterface,
        direction: 'master',
        excludeFromFC : true
    });

    DMI_UNIT_INTF.push({
        modulePrefix: 'csr_trace_',
        localPrefix: 'csr_trace_',
        interface: traceCsrIfGenerator.signalBundle('slave'),
        direction: 'master'
    });

    DMI_UNIT_INTF.push({
        modulePrefix: 'dtw_dbg_req_',
        localPrefix: 'dtw_dbg_req_',
        interface: CONC_INTF['DTWDBGReqInterface'],
        direction: 'slave'
    });

    DMI_UNIT_INTF.push({
        modulePrefix: 'dtw_dbg_rsp_',
        localPrefix: 'dtw_dbg_rsp_',
        interface: CONC_INTF['DTWDBGRespInterface'],
        direction: 'master'
    });

if(usePma) {
    DMI_UNIT_INTF.push({
        modulePrefix: qInterfaceName,
        localPrefix: qInterfaceName,
        interface: qInterfaceBundle,
	    direction : 'slave',
        exclude : ['REQn']
    });
}

// trigger intf always present on 3.4 
/* istanbul ignore else env ncore_3p4 */
if (interfaces.masterTriggerInt && !interfaces.masterTriggerInt._SKIP_) {
    DMI_UNIT_INTF.push({
        modulePrefix: masterTriggerInterface.name,
        localPrefix: masterTriggerInterface.name,
        interface: masterTriggerInterface.signals,
        direction: 'slave',
	exclude : ['trigger']
    });
   
}


  for (var i=0; i<SMI_TX_INTF.length; i++)
    {
     TRACE_CAPTURE_INTF.push({
                                modulePrefix: SMI_TX_INTF[i].name, 
                                localPrefix: SMI_TX_INTF[i].name, 
                                interface: SMI_TX_INTF[i].signals
     });
     DMI_UNIT_INTF.push({
                         modulePrefix: SMI_TX_INTF[i].name, 
                         localPrefix: SMI_TX_INTF[i].name, 
                         interface: SMI_TX_INTF[i].signals,
                         direction: SMI_TX_INTF_DIRECTION[i]
                         });

     if(SMI_TX_INTF[i].params.dpPresent) {
     nNonDataNetworks++;
     TRACE_CAPTURE_INTF.push({
                             modulePrefix: SMI_TX_INTF[i].name, 
                             localPrefix: SMI_TX_INTF[i].name, 
                             interface: SMI_TX_INTF[i].dpSignals,
                             exclude: ['dp_ready']
     });
     DMI_UNIT_INTF.push({
                         modulePrefix: SMI_TX_INTF[i].name, 
                         localPrefix: SMI_TX_INTF[i].name, 
                         interface: SMI_TX_INTF[i].dpSignals,
                         direction: SMI_TX_INTF_DIRECTION[i]                        
                         });
     } else {
     nDataNetworks++;
     }

     };
//width needed for total number of smi ports*2 (each rx/tx direction)+1.
const wTotalSmiPortsNum = log2ceil(((nNonDataNetworks+nDataNetworks)*2)+1);
 

   for (var i=0; i<SMI_RX_INTF.length; i++)
     {
      TRACE_CAPTURE_INTF.push({
                                  modulePrefix: SMI_RX_INTF[i].name, 
                                  localPrefix: SMI_RX_INTF[i].name, 
                                  interface: SMI_RX_INTF[i].signals
      });
      DMI_UNIT_INTF.push({
                          modulePrefix: SMI_RX_INTF[i].name, 
                          localPrefix: SMI_RX_INTF[i].name, 
                          interface: SMI_RX_INTF[i].signals,
                          direction: SMI_RX_INTF_DIRECTION[i]
                          });

     if(SMI_RX_INTF[i].params.dpPresent) {
     TRACE_CAPTURE_INTF.push({
                                 modulePrefix: SMI_RX_INTF[i].name, 
                                 localPrefix: SMI_RX_INTF[i].name, 
                                 interface: SMI_RX_INTF[i].dpSignals,
                                 exclude: ['dp_ready']
     });
     DMI_UNIT_INTF.push({
                         modulePrefix: SMI_RX_INTF[i].name, 
                         localPrefix: SMI_RX_INTF[i].name, 
                         interface: SMI_RX_INTF[i].dpSignals,
                         direction: SMI_RX_INTF_DIRECTION[i]
                         });
     }

     };
    //Trace Capture interfaces
    TRACE_CAPTURE_INTF.push({
        modulePrefix: '',
        localPrefix: clkInterfaceName,
        interface: clkInterface,
        exclude: ['test_en']
    });
    TRACE_CAPTURE_INTF.push({
        modulePrefix: 'dtw_req_',
        localPrefix: 'dtw_dbg_req_',
        interface: CONC_INTF['DTWDBGReqInterface']
    });
    TRACE_CAPTURE_INTF.push({
        modulePrefix: 'dtw_resp_',
        localPrefix: 'dtw_dbg_rsp_',
        interface: CONC_INTF['DTWDBGRespInterface']
    });
    TRACE_CAPTURE_INTF.push({
        modulePrefix: 'csr_trace_',
        localPrefix: 'csr_trace_',
        interface: traceCsrIfGenerator.signalBundle("slave")
    });

    if(useCmc) {

        DMI_UNIT_INTF.push({
                modulePrefix: '',
                localPrefix: '',
                interface: ccpMemoryInterface,
	            direction : "master"
        });

        if (usePLRU) {

           var plruMemoryInterface = [];

           for (let i=0; i < ccpParams.nTagBanks; i++) {
               plruMemoryInterface[i] = {
                   '_plru_mem_read_en'      : 1,
                   '_plru_mem_write_en'     : 1,
                   '_plru_mem_read_addr'    : ccpParams.plru_addr_w,
                   '_plru_mem_write_addr'   : ccpParams.plru_addr_w,
                   '_plru_mem_write_data'   : ccpParams.nWays,
                   '_plru_mem_read_data'    :-ccpParams.nWays
               };

            DMI_UNIT_INTF.push({
                        modulePrefix:'f'+ i,
                        localPrefix: 'w_f'+ i,
                        interface: plruMemoryInterface[i],
                        direction: 'master'
            });

        }

}

    } // useCmc

    if (useExRdDataMem) {
        DMI_UNIT_INTF.push({
                modulePrefix: '',
                localPrefix: '',
                interface: rdBufferMemoryInterface,
	            direction : "master"
        });
    } // useExRdDataMem

    if (useExWrDataMem) {
        DMI_UNIT_INTF.push({
                modulePrefix: '',
                localPrefix: '',
                interface: wrDataBufferMemoryInterface,
	            direction : "master"
        });
    } // useExWrDataMem


    if(enableNativeIntfProtection & useResiliency) {
        DMI_UNIT_INTF.push({
            modulePrefix: placeInterfaceName,
            localPrefix: placeInterfaceName,
            interface: placeInterfaceBundle,
	        direction : "master"
        });
    } // enableNativeIntfProtection

    var DMI_UNIT_PORTS = {};
        DMI_UNIT_PORTS['trace_capture_busy'] = 'trace_capture_busy';
        DMI_UNIT_PORTS['pm_trace_messages_captured'] = 'pm_trace_messages_captured';
        DMI_UNIT_PORTS['pm_trace_messages_dropped'] = 'pm_trace_messages_dropped';
// trigger intf always present on 3.4 
/* istanbul ignore else env ncore_3p4 */
    if( interfaces.masterTriggerInt && !interfaces.masterTriggerInt._SKIP_ ) {
	DMI_UNIT_PORTS[masterTriggerInterface.name+'trigger'] = masterTriggerInterface.name+'trigger_sync';
    }
    if ( useResiliency ) {
        DMI_UNIT_PORTS['res_cerr_thresh'] = 'res_cerr_thresh';
        DMI_UNIT_PORTS['dmi_en_debug_bist'] = 'dmi_en_debug_bist';
    } else {
        DMI_UNIT_PORTS['dmi_en_debug_bist'] = "1'b1";
    }
    if (usePma) {
        DMI_UNIT_PORTS[qInterfaceName+'REQn'] = qInterfaceName+'REQn_sync';
    }

    Object.keys(unitIdInterface).forEach(function(key) {
        DMI_UNIT_PORTS[key] = unitIdInterfaceName + key;
    });
//dve always present
 /* istanbul ignore else env ncore_3p2, ncore_3p4 */
    if (haveDveInterface) {
        Object.keys(uDveIdInterface).forEach(function(key) {
            DMI_UNIT_PORTS['dve_' + key] = uDveIdInterfaceName + key;
        });
    }
    
    Object.keys(sysUnitIdInterface).forEach(function(key) {
        DMI_UNIT_PORTS['aiu_' + key] = sysUnitIdInterfaceName + key;
    });


    var dmi_unit_params = {
            assertOn                    : assertOn,
            nUnitTraceBufSize           : nUnitTraceBufSize,
            haveDveInterface            : haveDveInterface,
            sameWidthSystem             : sameWidthSystem,
            nAius                       : nAius,
            usePma                      : usePma,
            PmaInfo                     : PmaInfo,
            useWayPartitioning          : useWayPartitioning,
            nWayPartitioningRegisters   : nWayPartitioningRegisters,
            useAddrTranslation          : useAddrTranslation,
            nAddrTransRegisters         : nAddrTransRegisters,
            axiParams                   : axiParams,
            wInitiatorId                : wInitiatorId,
            wFUnitId                    : wFUnitId,
            wNUnitId                    : wNUnitId,
            wFPortId                    : wFPortId,
            wMessageId                  : wMessageId,
            cmpInfo                     : cmpInfo,
            cmType                      : cmType,
            wCacheLineOffset            : wCacheLineOffset,
            useAtomic                   : useAtomic,
            useCmc                      : useCmc,
            wData                       : wData,
            wAddr                       : wAddr,
            wAiuId                      : wInitiatorId,
            nBeats                      : nBeats,
            ccpParams                   : ccpParams,
	    clkInterfaceJson		: interfaces.clkInt,  //new style clkInterface
            clkInterface                : clkInterface,
            clkInterfaceParam           : clkInterfaceParam,
            blkClkGateOn                : blkClkGateOn,
            axiInterface                : axiInterfaceBundle,
            irqInterface                : irqInterface,
            unitIdInterface             : unitIdInterface,
            uDveIdInterface             : uDveIdInterface,
            apbInterface                : apbInterface,
            readDataInterface           : readDataInterface,
            ccpMemoryInterface          : ccpMemoryInterface,
            wrDataBufferMemoryInterface : wrDataBufferMemoryInterface,
            cWrDataGen                  : cWrDataGen[0],
            cWrDataParam                : cWrDataParam,
            wrBufferProtType            : wrBufferProtType,
            useExWrDataMem              : useExWrDataMem,
            concertoInterfaces          : CONC_INTF,
            smiTxPortInterfaces         : SMI_TX_INTF,
            smiRxPortInterfaces         : SMI_RX_INTF,
            concertoTxInterfaces        : CONC_TX_INTF,
            concertoRxInterfaces        : CONC_RX_INTF,
            regProtInterface            : regProtectionInterface,
            regProtInterfaceName        : regProtectionInterfaceName,
            regProtStyle                : regProtectionStyle,
            qInterface                  : qInterfaceBundle,
            qInterfaceName              : qInterfaceName,
            csr                         : csr,
            wCsrData                    : wCsrData,
            wCsrAddr                    : wCsrAddr,
            fnNativeInterface           : fnNativeInterface,
            useResiliency               : useResiliency,
            ResilienceInfo              : ResilienceInfo,
            placeInterface              : placeInterface,
            placeInterfaceName          : placeInterfaceName,
            placeInterfaceDef           : placeInterfaceDef,
            placeInterfaceSkip          : placeInterfaceSkip,
            internalFaultInterface      : internalFaultInterface,
            sysUnitIdInterface          : sysUnitIdInterface,
            wNrri                       : wNrri,
            wRpn                        : wRpn,
            concParams                  : concParams,
            fnEnableTimeOutRef          : fnEnableTimeOutRef,
            fnEnableQos                 : fnEnableQos,
            QosInfo                     : QosInfo,
            nativeInterfacePipe         : nativeInterfacePipe,
            enRdPipe                    : enRdPipe,
            enWrPipe                    : enWrPipe,
            wTotalSmiPortsNum           : wTotalSmiPortsNum,
            nPerfCounters		: nPerfCounters,
            useExRdDataMem : useExRdDataMem,
            rdBufferMemoryInterface : rdBufferMemoryInterface,
            rdBufferProtType : rdBufferProtType,
            rdBufferGen : rdBufferGen[0],
            rdBufferParam : rdBufferParam,
            enableReadDataInterleaving : enableReadDataInterleaving,
            nMrdSkidBufArb : nMrdSkidBufArb,
            nMrdSkidBufSize : nMrdSkidBufSize,
            nCMDSkidBufArb : nCMDSkidBufArb,
            nCMDSkidBufSize : nCMDSkidBufSize,
	    interfaces	     		: interfaces
};

if ( useResiliency ) {
dmi_unit_params['wResThreshold'] = wResThreshold;
}

\jsend
    wire [\=wTotalSmiPortsNum-1=\:0] pm_trace_messages_dropped;
    wire [\=wTotalSmiPortsNum-1=\:0] pm_trace_messages_captured;

    \jsbegin
    if (useCmc) {
        if (usePLRU) {
            for (let i=0; i < ccpParams.nTagBanks; i++) {
    \jsend
    \=bundleFunctions.wiresFromInterface('w_f'+ i,       plruMemoryInterface[i], [], obj.lib.bundle)=\
            \js if (useResiliency && enableUnitDuplication) {
    \=bundleFunctions.wiresFromInterface('dup_unit_w_f'+ i,       plruMemoryInterface[i], [], obj.lib.bundle)=\
            \js }
    \jsbegin
            }
        }
    }
    \jsend

    \=obj.lib.instance({
        instanceName: 'dmi_unit',
        moduleName: 'dmi_unit',
        params: dmi_unit_params,
        verilogParams: {},
        ports: DMI_UNIT_PORTS,
        interfaces: DMI_UNIT_INTF,
        portsDelimiter: '\n        '
    })=\


\jsbegin
//========================================================
// DMI Duplicate Unit 
//========================================================
\jsend

\jsbegin
if(enableUnitDuplication & useResiliency) {
    var DMI_DUP_UNIT_INTF = [];
    for(var i = 0; i < DMI_UNIT_INTF.length; i++){
        DMI_DUP_UNIT_INTF.push({
            modulePrefix: DMI_UNIT_INTF[i].modulePrefix,
            localPrefix: 'dup_unit__' + DMI_UNIT_INTF[i].localPrefix,
            interface: DMI_UNIT_INTF[i].interface,
            excludeFromFC: DMI_UNIT_INTF[i].excludeFromFC,
            exclude: DMI_UNIT_INTF[i].exclude
        });
    }

var DMI_DUP_UNIT_PORTS = {};
Object.keys(unitIdInterface).forEach(function(key) {
    DMI_DUP_UNIT_PORTS[key] = unitIdInterfaceName + key;
});
//dve always present
 /* istanbul ignore else env ncore_3p2, ncore_3p4 */
if (haveDveInterface) {
    Object.keys(uDveIdInterface).forEach(function(key) {
        DMI_DUP_UNIT_PORTS['dve_' + key] = uDveIdInterfaceName + key;
    });
}

Object.keys(sysUnitIdInterface).forEach(function(key) {
    DMI_DUP_UNIT_PORTS['aiu_' + key] = sysUnitIdInterfaceName + key;
});
DMI_DUP_UNIT_PORTS['dmi_en_debug_bist'] = 'dmi_en_debug_bist';
DMI_DUP_UNIT_PORTS['res_cerr_thresh'] = 'dup_unit__res_cerr_thresh';
DMI_DUP_UNIT_PORTS['trace_capture_busy'] = 'dup_unit__trace_capture_busy';
DMI_DUP_UNIT_PORTS['pm_trace_messages_captured'] = 'dup_unit__pm_trace_messages_captured';
DMI_DUP_UNIT_PORTS['pm_trace_messages_dropped'] = 'dup_unit__pm_trace_messages_dropped';
// trigger intf always present on 3.4 
/* istanbul ignore else env ncore_3p4 */
if( interfaces.masterTriggerInt && !interfaces.masterTriggerInt._SKIP_ ) {
    DMI_DUP_UNIT_PORTS[masterTriggerInterface.name+'trigger'] = 'dup_unit__'+masterTriggerInterface.name+'trigger_sync';
}
if (usePma) {
    DMI_DUP_UNIT_PORTS[qInterfaceName+'REQn'] = 'dup_unit__'+qInterfaceName+'REQn_sync';
}
\jsend

    wire [\=wTotalSmiPortsNum-1=\:0] dup_unit__pm_trace_messages_dropped;
    wire [\=wTotalSmiPortsNum-1=\:0] dup_unit__pm_trace_messages_captured;

    \=obj.lib.instance({
        instanceName: 'dup_unit',
        moduleName: 'dmi_unit',
        params: dmi_unit_params,
        verilogParams: {},
        ports: DMI_DUP_UNIT_PORTS,
        interfaces: DMI_DUP_UNIT_INTF,
        portsDelimiter: '\n        '
    })=\
\js }

\jsbegin
// ===================================================================
// Trace Capture Instance
// Moved external to dmi_unit to avoid duplication. 
// Ensure proper ports of dup_unit feed through fault checker.
// ===================================================================
// TraceDebug Always enabled 
/* istanbul ignore else env ncore_3p4 */    
if (traceDebugEnable) { //TraceDebug Enabled: trace_capture instantiated
var trace_capture_intf_param = {};
trace_capture_intf_param['clkInt'] = {
                               name: '',
                               params: {},
                               direction: 'slave',
                               interface: 'InterfaceCLK'
                           };
\jsend
    \=obj.lib.instance({
        instanceName: 'trace_capture',
        moduleName: 'trace_capture',
        params: {
            assertOn: assertOn,
            smiRxPortInterfaces : SMI_RX_INTF,
            smiTxPortInterfaces: SMI_TX_INTF,
            nNDN: nNonDataNetworks,
            nDN: nDataNetworks,
            nUnitTraceBufSize: nUnitTraceBufSize,
            wForceAccumTimeout: 10,
            DTWReqInterface: CONC_INTF['DTWDBGReqInterface'],
            DTWRespInterface: CONC_INTF['DTWDBGRespInterface'],
	        traceRegInterface: {"name": 'csr_trace_', "signals":traceCsrIfGenerator.signalBundle("slave")},
            wFUnitId: wFUnitId,
            wFPortId: wFPortId,
            cmType: cmType,
            interfaces: trace_capture_intf_param
        },
        verilogParams: {},
        ports: {
            MyId:               unitIdInterfaceName+'my_f_unit_id',
            TargId:             uDveIdInterfaceName+'f_unit_id',
            pm_trace_messages_captured: 'pm_trace_messages_captured',
            pm_trace_messages_dropped: 'pm_trace_messages_dropped',
            trace_capture_busy: 'trace_capture_busy'
               },
        interfaces: TRACE_CAPTURE_INTF,
        portsDelimiter: '\n        '
    })=\

\jsbegin
} else { 
//Set DTW DBG Req keys to only those not excluded & non-zero widths
const dtw_excludes			= ['ready'];
const dtw_req_keys		= Object.keys(CONC_INTF['DTWDBGReqInterface']).filter(signal => !dtw_excludes.includes(signal) && CONC_INTF['DTWDBGReqInterface'][signal]);
const csr_keys		= Object.keys(traceCsrIfGenerator.signalBundle("master")).filter(signal => traceCsrIfGenerator.signalBundle("master")[signal]>0);
for (let key = 0; key < dtw_req_keys.length; key++) { \jsend
    //TraceDebug Disabled: tie-offs
    assign dtw_dbg_req_\=dtw_req_keys[key]=\ = \=CONC_INTF['DTWDBGReqInterface'][dtw_req_keys[key]]=\'h0;
\jsbegin
} 
for (let key = 0; key < csr_keys.length; key++) { \jsend
    assign csr_trace_\=csr_keys[key]=\ = \=traceCsrIfGenerator.signalBundle("master")[csr_keys[key]]=\'h0;
\jsbegin
} 
\jsend
    assign dtw_dbg_rsp_ready = 1'b1; 
    assign pm_trace_messages_captured = \=wTotalSmiPortsNum=\'h0; 
    assign pm_trace_messages_dropped = \=wTotalSmiPortsNum=\'h0; 
    assign trace_capture_busy = 1'b0; 
\jsbegin
} 
\jsend

\jsbegin
// =======================================================
// Checker Delay Instance
// =======================================================
\jsend

\js if (useResiliency && enableUnitDuplication) {
    wire reset_n_delay;
\jsbegin
    var delayInterfaceBundle   = {};
    var checkerInterfaceBundle = {};

if (usePma) {
    delayInterfaceBundle[qInterfaceName+'REQn_sync'] = 1;
}
// trigger intf always present on 3.4 
/* istanbul ignore else env ncore_3p4 */
if( interfaces.masterTriggerInt && !interfaces.masterTriggerInt._SKIP_ ) {
    delayInterfaceBundle[masterTriggerInterface.name+'trigger_sync'] = 1;
}
    delayInterfaceBundle['trace_capture_busy'] = 1;
    delayInterfaceBundle['pm_trace_messages_dropped'] = wTotalSmiPortsNum;
    delayInterfaceBundle['pm_trace_messages_captured'] = wTotalSmiPortsNum;
        for (var intf = 0; intf < DMI_DUP_UNIT_INTF.length; intf++) {
            if (DMI_DUP_UNIT_INTF[intf].excludeFromFC != true) {
                var inputSignalKeys  = [];
                var outputSignalKeys = [];
                // Handle AXI Case of 2 Deep
                if (Object.keys(DMI_DUP_UNIT_INTF[intf].interface)[0] == 'ar_') {
                    var axiKeys = Object.keys(DMI_DUP_UNIT_INTF[intf].interface);
                    var prefix = DMI_UNIT_INTF[intf].localPrefix;
                    for( var axiKey = 0; axiKey < axiKeys.length; axiKey++ ) {
                        var axiSignals = Object.keys(DMI_DUP_UNIT_INTF[intf].interface[axiKeys[axiKey]]);
                        for( var axiSig = 0; axiSig < axiSignals.length; axiSig++ ) {
    	                    if(DMI_DUP_UNIT_INTF[intf].interface[axiKeys[axiKey]][axiSignals[axiSig]] < 0) {
    	                        delayInterfaceBundle[prefix + axiKeys[axiKey] + axiSignals[axiSig]] = Math.abs(DMI_DUP_UNIT_INTF[intf].interface[axiKeys[axiKey]][axiSignals[axiSig]]);
    	                    } else if (DMI_DUP_UNIT_INTF[intf].interface[axiKeys[axiKey]][axiSignals[axiSig]] > 0){
    	                        checkerInterfaceBundle[prefix + axiKeys[axiKey] + axiSignals[axiSig]] = Math.abs(DMI_DUP_UNIT_INTF[intf].interface[axiKeys[axiKey]][axiSignals[axiSig]]);
    	                    }
    	                }
                    }
                } else {
                    if (DMI_UNIT_INTF[intf].direction == "master"){
                        inputSignalKeys  = Object.keys(DMI_DUP_UNIT_INTF[intf].interface).filter(key => (DMI_DUP_UNIT_INTF[intf].interface[key] < 0) & key != 'clk' & key != 'reset_n' & key != 'test_en');
                        outputSignalKeys = Object.keys(DMI_DUP_UNIT_INTF[intf].interface).filter(key => (DMI_DUP_UNIT_INTF[intf].interface[key] > 0) & key != 'clk' & key != 'reset_n' & key != 'test_en');
                    } else {
                        inputSignalKeys  = Object.keys(DMI_DUP_UNIT_INTF[intf].interface).filter(key => (DMI_DUP_UNIT_INTF[intf].interface[key] > 0) & key != 'clk' & key != 'reset_n' & key != 'test_en');
                        outputSignalKeys = Object.keys(DMI_DUP_UNIT_INTF[intf].interface).filter(key => (DMI_DUP_UNIT_INTF[intf].interface[key] < 0) & key != 'clk' & key != 'reset_n' & key != 'test_en');
                    }
                    for (var sig = 0; sig < inputSignalKeys.length; sig++) {
                        delayInterfaceBundle[DMI_UNIT_INTF[intf].localPrefix + inputSignalKeys[sig]] = Math.abs(DMI_DUP_UNIT_INTF[intf].interface[inputSignalKeys[sig]]);
                    }
                    for (var sig = 0; sig < outputSignalKeys.length; sig++) {
                        checkerInterfaceBundle[DMI_UNIT_INTF[intf].localPrefix + outputSignalKeys[sig]] = Math.abs(DMI_DUP_UNIT_INTF[intf].interface[outputSignalKeys[sig]]);
                    }
                }
            }
        }

    var delayInterfaces = [];

    delayInterfaces.push({
            modulePrefix: '',
            localPrefix: clkInterfaceName,
            interface: clkInterface
    });

    delayInterfaces.push({
            modulePrefix: 'in_',
            localPrefix: '',
            interface: delayInterfaceBundle
    });

    delayInterfaces.push({
            modulePrefix: 'out_',
            localPrefix: 'dup_unit__',
            interface: delayInterfaceBundle
    });

var checker_delay_ports = {};
checker_delay_ports['reset_n_delay'] = 'reset_n_delay';
// trigger intf always present on 3.4 
/* istanbul ignore else env ncore_3p4 */
if( interfaces.masterTriggerInt && !interfaces.masterTriggerInt._SKIP_ ) {
    checker_delay_ports['in_'+masterTriggerInterface.name+'trigger_sync'] = masterTriggerInterface.name+'trigger_sync';
    checker_delay_ports['out_'+masterTriggerInterface.name+'trigger_sync'] = 'dup_unit__'+masterTriggerInterface.name+'trigger_sync';
}

if (usePma) {
    checker_delay_ports['in_'+qInterfaceName+'REQn_sync'] = qInterfaceName+'REQn_sync';
    checker_delay_ports['out_'+qInterfaceName+'REQn_sync'] = 'dup_unit__'+qInterfaceName+'REQn_sync';
}

\jsend

    \=obj.lib.instance({
        instanceName   : 'delay_unit',
        moduleName     : 'checker_delay',
        params         :  {
                             clkInterface    : clkInterface,
                             delayInterface  : delayInterfaceBundle,
                             nDelay          : nResiliencyDelay
                          },
        interfaces     : delayInterfaces,
        ports          : checker_delay_ports, 
        verilogParams  :  {},
        portsDelimiter : '\n    '
    })=\

\js }

\jsbegin
// =======================================================
// Fault Checker
// =======================================================
\jsend

\js if (useResiliency) {

assign \=bistInterfaceName=\domain_is_on = 1'b1;

\jsbegin
var DMI_CHECKER_INTF = [];

DMI_CHECKER_INTF.push({
    modulePrefix: '',
    localPrefix: bistInterfaceName,
    interface: bistInterfaceBundle, exclude : ['domain_is_on']
});

DMI_CHECKER_INTF.push({
    modulePrefix: '',
    localPrefix: faultInterfaceName,
    interface: faultInterfaceBundle, exclude : ['late_clk']
});

if (enableUnitDuplication) {
    checkerInterfaceBundle.res_cerr_thresh = wResThreshold;
    DMI_CHECKER_INTF.push({
        modulePrefix: 'func_',
        localPrefix: '',
        interface: checkerInterfaceBundle
    });

    DMI_CHECKER_INTF.push({
        modulePrefix: 'check_',
        localPrefix: 'dup_unit__',
        interface: checkerInterfaceBundle
    });

}

\jsend

wire func_0_fault_in       = dmi_placeholder_UCE;       
wire func_0_cerr_fault_in  = dmi_placeholder_CE;
\js if (enableUnitDuplication) {
wire check_0_fault_in      = dup_unit__dmi_placeholder_UCE;
wire check_0_cerr_fault_in = dup_unit__dmi_placeholder_CE;
\js } else {
wire check_0_fault_in      = dmi_placeholder_UCE;
wire check_0_cerr_fault_in = dmi_placeholder_CE;
\js }

wire func_1_fault_in       = dmi_cmux_UCE;       
wire func_1_cerr_fault_in  = dmi_cmux_cmd_req_CE;        

\js if (enableUnitDuplication) {
wire check_1_fault_in      = dup_unit__dmi_cmux_UCE;
wire check_1_cerr_fault_in = dup_unit__dmi_cmux_cmd_req_CE; 
\js } else {
wire check_1_fault_in      = dmi_cmux_UCE;
wire check_1_cerr_fault_in = dmi_cmux_cmd_req_CE; 
\js }

wire func_2_fault_in       = dmi_smc_tag_UCE;       
wire func_2_cerr_fault_in  = dmi_cmux_mrd_req_CE;        

\js if (enableUnitDuplication) {
wire check_2_fault_in      = dup_unit__dmi_smc_tag_UCE; 
wire check_2_cerr_fault_in = dup_unit__dmi_cmux_mrd_req_CE;
\js } else {
wire check_2_fault_in      = dmi_smc_tag_UCE; 
wire check_2_cerr_fault_in = dmi_cmux_mrd_req_CE;
\js }

wire func_3_fault_in       = dmi_smc_data_UCE;       
wire func_3_cerr_fault_in  = dmi_cmux_rbr_req_CE;        

\js if (enableUnitDuplication) {
wire check_3_fault_in      = dup_unit__dmi_smc_data_UCE; 
wire check_3_cerr_fault_in = dup_unit__dmi_cmux_rbr_req_CE;
\js } else {
wire check_3_fault_in      = dmi_smc_data_UCE; 
wire check_3_cerr_fault_in = dmi_cmux_rbr_req_CE;
\js }

wire func_4_fault_in       = dmi_c_wr_buff_UCE; //dmi_native_rd_resp_UCE;       
wire func_4_cerr_fault_in  = dmi_cmux_str_rsp_CE;        

\js if (enableUnitDuplication) {
wire check_4_fault_in      = dup_unit__dmi_c_wr_buff_UCE; //dup_unit__dmi_native_rd_resp_UCE; 
wire check_4_cerr_fault_in = dup_unit__dmi_cmux_str_rsp_CE;
\js } else {
wire check_4_fault_in      = dmi_c_wr_buff_UCE; //dmi_native_rd_resp_UCE; 
wire check_4_cerr_fault_in = dmi_cmux_str_rsp_CE;
\js }

wire func_5_fault_in       = dmi_timeout_error_UCE; //dmi_native_wr_resp_UCE;       
wire func_5_cerr_fault_in  = dmi_cmux_rbu_rsp_CE;        

\js if (enableUnitDuplication) {
wire check_5_fault_in      = dup_unit__dmi_timeout_error_UCE; //dup_unit__dmi_native_wr_resp_UCE; 
wire check_5_cerr_fault_in = dup_unit__dmi_cmux_rbu_rsp_CE;
\js } else {
wire check_5_fault_in      = dmi_timeout_error_UCE; //dmi_native_wr_resp_UCE; 
wire check_5_cerr_fault_in = dmi_cmux_rbu_rsp_CE;
\js }

wire func_6_fault_in       = dmi_target_id_UCE;       
wire func_6_cerr_fault_in  = dmi_cmux_dtr_rsp_CE;        

\js if (enableUnitDuplication) {
wire check_6_fault_in      = dup_unit__dmi_target_id_UCE; 
wire check_6_cerr_fault_in = dup_unit__dmi_cmux_dtr_rsp_CE;
\js } else {
wire check_6_fault_in      = dmi_target_id_UCE; 
wire check_6_cerr_fault_in = dmi_cmux_dtr_rsp_CE;
\js }

wire func_7_fault_in       = dmi_rd_buffer_UCE;
wire func_7_cerr_fault_in  = dmi_cmux_dtw_req_CE;        

\js if (enableUnitDuplication) {
wire check_7_fault_in      = dup_unit__dmi_rd_buffer_UCE;
wire check_7_cerr_fault_in = dup_unit__dmi_cmux_dtw_req_CE;
\js } else {
wire check_7_fault_in      = dmi_rd_buffer_UCE;
wire check_7_cerr_fault_in = dmi_cmux_dtw_req_CE;
\js }

wire func_8_fault_in       = 'h0;       
wire check_8_fault_in      = 'h0; 
wire func_8_cerr_fault_in  = dmi_smc_tag_CE;        

\js if (enableUnitDuplication) {
wire check_8_cerr_fault_in = dup_unit__dmi_smc_tag_CE;
\js } else {
wire check_8_cerr_fault_in = dmi_smc_tag_CE;
\js }

wire func_9_fault_in       = 'h0;       
wire check_9_fault_in      = 'h0; 
wire func_9_cerr_fault_in  = dmi_smc_data_CE;        

\js if (enableUnitDuplication) {
wire check_9_cerr_fault_in = dup_unit__dmi_smc_data_CE;
\js } else {
wire check_9_cerr_fault_in = dmi_smc_data_CE;
\js }

wire func_10_fault_in       = 'h0;       
wire check_10_fault_in      = 'h0; 
wire func_10_cerr_fault_in  = dmi_c_wr_buff_CE;        

\js if (enableUnitDuplication) {
wire check_10_cerr_fault_in = dup_unit__dmi_c_wr_buff_CE;
\js } else {
wire check_10_cerr_fault_in = dmi_c_wr_buff_CE;
\js }

wire func_11_fault_in       = 'h0;
wire check_11_fault_in      = 'h0;
wire func_11_cerr_fault_in  = dmi_cmux_dtw_dbg_rsp_CE;

\js if (enableUnitDuplication) {
wire check_11_cerr_fault_in = dup_unit__dmi_cmux_dtw_dbg_rsp_CE;
\js } else {
wire check_11_cerr_fault_in = dmi_cmux_dtw_dbg_rsp_CE;
\js }

wire func_12_fault_in       = 'h0;
wire check_12_fault_in      = 'h0;
wire func_12_cerr_fault_in  = dmi_rd_buffer_CE;

\js if (enableUnitDuplication) {
wire check_12_cerr_fault_in = dup_unit__dmi_rd_buffer_CE;
\js } else {
wire check_12_cerr_fault_in = dmi_rd_buffer_CE;
\js }



\jsbegin
var DMI_CHECKER_PORTS = {   
                             clk                   : 'fault_checker_clk',
                             reset_n               : 'fault_checker_reset_n',
                             func_0_fault_in       : 'func_0_fault_in',
                             check_0_fault_in      : 'check_0_fault_in',
                             func_0_cerr_fault_in  : 'func_0_cerr_fault_in',
                             check_0_cerr_fault_in : 'check_0_cerr_fault_in',
                             func_1_fault_in       : 'func_1_fault_in',
                             check_1_fault_in      : 'check_1_fault_in',
                             func_1_cerr_fault_in  : 'func_1_cerr_fault_in',
                             check_1_cerr_fault_in : 'check_1_cerr_fault_in',
                             func_2_fault_in       : 'func_2_fault_in',
                             check_2_fault_in      : 'check_2_fault_in',
                             func_2_cerr_fault_in  : 'func_2_cerr_fault_in',
                             check_2_cerr_fault_in : 'check_2_cerr_fault_in',
                             func_3_fault_in       : 'func_3_fault_in',
                             check_3_fault_in      : 'check_3_fault_in',
                             func_3_cerr_fault_in  : 'func_3_cerr_fault_in',
                             check_3_cerr_fault_in : 'check_3_cerr_fault_in',
                             func_4_fault_in       : 'func_4_fault_in',
                             check_4_fault_in      : 'check_4_fault_in',
                             func_4_cerr_fault_in  : 'func_4_cerr_fault_in',
                             check_4_cerr_fault_in : 'check_4_cerr_fault_in',
                             func_5_fault_in       : 'func_5_fault_in',
                             check_5_fault_in      : 'check_5_fault_in',
                             func_5_cerr_fault_in  : 'func_5_cerr_fault_in',
                             check_5_cerr_fault_in : 'check_5_cerr_fault_in',
                             func_6_fault_in       : 'func_6_fault_in',
                             check_6_fault_in      : 'check_6_fault_in',
                             func_6_cerr_fault_in  : 'func_6_cerr_fault_in',
                             check_6_cerr_fault_in : 'check_6_cerr_fault_in',
                             func_7_fault_in       : 'func_7_fault_in',
                             check_7_fault_in      : 'check_7_fault_in',
                             func_7_cerr_fault_in  : 'func_7_cerr_fault_in',
                             check_7_cerr_fault_in : 'check_7_cerr_fault_in',
                             func_8_fault_in       : 'func_8_fault_in',
                             check_8_fault_in      : 'check_8_fault_in',
                             func_8_cerr_fault_in  : 'func_8_cerr_fault_in',
                             check_8_cerr_fault_in : 'check_8_cerr_fault_in',
                             func_9_fault_in       : 'func_9_fault_in',
                             check_9_fault_in      : 'check_9_fault_in',
                             func_9_cerr_fault_in  : 'func_9_cerr_fault_in',
                             check_9_cerr_fault_in : 'check_9_cerr_fault_in',
                             func_10_fault_in      : 'func_10_fault_in',
                             check_10_fault_in     : 'check_10_fault_in',
                             func_10_cerr_fault_in  : 'func_10_cerr_fault_in',
                             check_10_cerr_fault_in : 'check_10_cerr_fault_in',
                             func_11_fault_in      : 'func_11_fault_in',
                             check_11_fault_in     : 'check_11_fault_in',
                             func_11_cerr_fault_in  : 'func_11_cerr_fault_in',
                             check_11_cerr_fault_in : 'check_11_cerr_fault_in',
                             func_12_fault_in      : 'func_12_fault_in',
                             check_12_fault_in     : 'check_12_fault_in',
                             func_12_cerr_fault_in  : 'func_12_cerr_fault_in',
                             check_12_cerr_fault_in : 'check_12_cerr_fault_in',
                             cerr_threshold        : 'res_cerr_thresh'
                     };

if (enableUnitDuplication) {
    DMI_CHECKER_PORTS['reset_n_delay'] = 'reset_n_delay';
} else {
    DMI_CHECKER_PORTS['reset_n_delay'] = clkInterfaceName+'reset_n';
}
\jsend

    \=obj.lib.instance({
        instanceName   : 'u_dmi_fault_checker',
        moduleName     : 'fault_checker',
        params         :  {
                             nDelay                 : (enableUnitDuplication ? nResiliencyDelay : 0),
                             wThresWidth            : wResThreshold,
                             clkInterface           : intClkInterface,
                             enableUnitDuplication  : enableUnitDuplication,
                             checkerInterface       : (enableUnitDuplication ? checkerInterfaceBundle : {}),
                             numFaultInputs         : 13,
			     eSignalPipe            : 1	     
                          },
        verilogParams  :  {},
        interfaces     :  DMI_CHECKER_INTF,
        ports          :  DMI_CHECKER_PORTS,
        portsDelimiter : '\n    '
    })=\
\js }

\jsbegin
// =======================================================
// Wire Connections
// =======================================================
\jsend

\js if (useResiliency) {
assign fault_checker_clk = \=clkInterfaceName=\clk;
assign fault_checker_reset_n = \=clkInterfaceName=\reset_n;
\js }

\js if (useResiliency && enableUnitDuplication) {
assign dup_unit__\=clkInterfaceName=\clk    = \=checkClkInterfaceName=\clk;
assign dup_unit__\=clkInterfaceName=\reset_n= reset_n_delay;
\jsbegin
 /* istanbul ignore else env ncore_3p2, ncore_3p4 */    
 if (checkClkInterfaceParam.wTestEn) {   \jsend
assign dup_unit__\=clkInterfaceName=\test_en= \=checkClkInterfaceName=\test_en;
\js     }
\js }


\jsbegin
//========================================================
// Read Data Buffer Memory instantiation
//========================================================
if (useExRdDataMem) {
    var instance_ports_for_ram = [];
    for (var i = 0; i < nRdDataBanks; i++) {
        var rtlPrefixString = rdBufferGen[0].rtlPrefixString + i;
        var memoryControlInterface = rdDataStructures[i].controlSignals;
        instance_ports_for_ram[i] = {clk : clkInterfaceName+'clk'};
        for (var signal in memoryControlInterface) {
            instance_ports_for_ram[i][signal]  = 'mem__' + rtlPrefixString + '_' + signal;
        }
    // Forced to 1 in CPR 
    /* istanbul ignore else env ncore_3p4 */    
	if (useMemoryGating) {
		instance_ports_for_ram[i]['cg_test_en'] = clkInterfaceName+'test_en';
	}
        var rdBufferMemIndex = memInterfaceDict[ rdBufferGen[0].rtlPrefixString + '_' ];
        var rdBufferMemIndexi = memInterfaceDict[ rdBufferGen[i].rtlPrefixString + '_' ];
        var em_mem_external_interfaces = {};
         /* istanbul ignore else env ncore_3p0, ncore_3p2, ncore_3p4 */
        if (rdBufferGen[i].MemType !== 'NONE') {
           /* istanbul ignore else env ncore_3p2, ncore_3p4 */
           if (interfaces.memoryInt.length > 0) {
             em_mem_external_interfaces.externalInterface = utilFunctions.deepCopy( interfaces.memoryInt[ rdBufferMemIndexi ] );
             em_mem_external_interfaces.externalInterface.name = ' ';
           }
        }

        var rdBufferMemInterfaces = [];

        rdBufferMemInterfaces.push({
            modulePrefix: '', 
            localPrefix: memInterfaceName[ rdBufferMemIndexi ],
            interface: memInterfaceBundle[ rdBufferMemIndexi ],
            direction: memInterfaceDirection[ rdBufferMemIndexi ]
        });

\jsend
        \=obj.lib.instance({
            instanceName: rdBufferGen[i].rtlPrefixString,
            moduleName: rdBufferGen[i].moduleName + '_em_mem_external',
            tachlName: 'em_mem_external',
            params: {
                useMemoryGating : useMemoryGating,
                sverilog        : assertOn,
                interfaces      : em_mem_external_interfaces,
                memEccBlocks    : rdBufferParam.eccBlocks,
                rtlPrefixString : rdBufferGen[i].moduleName, 
                modulePrefix    : 'dmi',
                memoryType      : rdDataStructures[i].memoryType,
                nSignals        : rdDataStructures[i].signals.length,
                signals         : rdDataStructures[i].signals,
                useHandshake    : 0,
                no_mem_init     : 0,
                ports           : rdBufferPorts,
                bitEnable       : 0,
                numberOfEnables : rdDataStructures[i].width,
                width           : rdDataStructures[i].width,
                depth           : rdDataStructures[i].depth
            },
            verilogParams: {},
            ports: instance_ports_for_ram[i],
            interfaces: rdBufferMemInterfaces,
            portsDelimiter: '\n'
        })=\
    \jsbegin
    } 

    var str = '';
    for (var i = 0; i < nRdDataBanks; i++) {
        var rtlPrefixString = rdBufferGen[0].rtlPrefixString + i;
        var memoryControlInterface = rdDataStructures[i].controlSignals;
        str += memFunctions.string_addConnectionfromInterface('' + rtlPrefixString + '_','mem__' + rtlPrefixString + '_',memoryControlInterface);
    }
\jsend
\=str=\

\jsbegin
} //end if(useExRdDataMem)
\jsend

\jsbegin
//========================================================
// Coherent Write Data Memory instaniation
//========================================================
\jsend
\jsbegin
if (useExWrDataMem) {
        var instance_ports_for_ram = [];
        for (var i = 0; i < nWrDataBanks; i++) {
            var rtlPrefixString = cWrDataGen[0].rtlPrefixString + i;
            var memoryControlInterface = wrDataStructures[i].controlSignals;
            instance_ports_for_ram[i] = {clk : clkInterfaceName+'clk'};
            for (var signal in memoryControlInterface) {
                instance_ports_for_ram[i][signal]  = 'mem__' + rtlPrefixString + '_' + signal;
            }
        // Forced to 1 in CPR 
        /* istanbul ignore else env ncore_3p4 */    
	    if (useMemoryGating) {
		instance_ports_for_ram[i]['cg_test_en'] = clkInterfaceName+'test_en';
	    }

    var cWrMemIndex = memInterfaceDict[ cWrDataGen[0].rtlPrefixString + '_' ];
    var cWrMemIndexi = memInterfaceDict[ cWrDataGen[i].rtlPrefixString + '_' ];
    var em_mem_external_interfaces = {};
     /* istanbul ignore else env ncore_3p0, ncore_3p2, ncore_3p4 */
    if (cWrDataGen[i].MemType !== 'NONE') {
         /* istanbul ignore else env ncore_3p2, ncore_3p4 */
        if (interfaces.memoryInt.length > 0) {
    em_mem_external_interfaces.externalInterface = utilFunctions.deepCopy( interfaces.memoryInt[ cWrMemIndexi ] );
    em_mem_external_interfaces.externalInterface.name = ' ';
        }
    }

    var cWrMemInterfaces = [];

    cWrMemInterfaces.push({
        modulePrefix: '', //cWrDataGen[0].rtlPrefixString + '_', //memInterfaceName[ cWrMemIndex ],
        localPrefix: memInterfaceName[ cWrMemIndexi ],
        interface: memInterfaceBundle[ cWrMemIndexi ],
        direction: memInterfaceDirection[ cWrMemIndexi ]
    });

\jsend
        \=obj.lib.instance({
                    instanceName: cWrDataGen[i].rtlPrefixString,
                    moduleName: cWrDataGen[i].moduleName + '_em_mem_external',
                    tachlName: 'em_mem_external',
                    params: {
                        useMemoryGating : useMemoryGating,
                        sverilog        : assertOn,
                        interfaces      : em_mem_external_interfaces,
                        memEccBlocks    : cWrDataParam.eccBlocks,
                        rtlPrefixString : cWrDataGen[i].moduleName, //cWrDataGen[0].rtlPrefixString,
                        modulePrefix    : 'dmi',
                        memoryType      : wrDataStructures[i].memoryType,
                        nSignals        : wrDataStructures[i].signals.length,
                        signals         : wrDataStructures[i].signals,
                        useHandshake    : 0,
                        no_mem_init     : 0,
                        ports           : cWrMemPorts,
                        bitEnable       : 0,
                        numberOfEnables : wrDataStructures[i].width,
                        width           : wrDataStructures[i].width,
                        depth           : wrDataStructures[i].depth
                    },
                    verilogParams: {},
                    ports: instance_ports_for_ram[i],
                    interfaces: cWrMemInterfaces,
                    portsDelimiter: '\n'
        })=\
\jsbegin
        }

        var str = '';
        for (var i = 0; i < nWrDataBanks; i++) {
            var rtlPrefixString = cWrDataGen[0].rtlPrefixString + i;
            var memoryControlInterface = wrDataStructures[i].controlSignals;
            str += memFunctions.string_addConnectionfromInterface(''      + rtlPrefixString + '_',
                                                                  'mem__' + rtlPrefixString + '_',
                                                                   memoryControlInterface);
        }
\jsend
\=str=\

\js } 

\jsbegin
//========================================================
// CCP Tag RAMs instaniation
//========================================================
\jsend

\jsbegin
    if(useCmc) {
        var instance_ports_for_ram = [];
        for (var i = 0; i < ccpParams.nTagBanks; i++) {
            var rtlPrefixString = ccpTagGen[i].rtlPrefixString + i; //BOON
            var memoryControlInterface = tagStructures[i].controlSignals;
            instance_ports_for_ram[i] = {clk : clkInterfaceName+'clk'};
            for (var signal in memoryControlInterface) {
                instance_ports_for_ram[i][signal]  = 'mem__' + rtlPrefixString + '_' + signal;
            }
        // Forced to 1 in CPR 
        /* istanbul ignore else env ncore_3p4 */    
	    if (useMemoryGating) {
		instance_ports_for_ram[i]['cg_test_en'] = clkInterfaceName+'test_en';
	    }
            if (tagStructures[i].memoryType === "SYNOPSYS") {
                /* istanbul ignore if env ncore_3p0, ncore_3p2, ncore_3p4 */
                if (Object.keys(tagStructures[i].signals).length > 0) {
                    for (var signal in tagStructures[i].signals) {
                        if(signal!='int_chip_en') {
                            instance_ports_for_ram[i][tagStructures[i].rtlPrefixString + '_' + signal] = tagStructures[i].rtlPrefixString + i + '_' + signal;
                        }
                    }
                }    
            }

    var ccpTagMemIndex = memInterfaceDict[ ccpTagGen[0].rtlPrefixString + '_' ];
    var ccpTagMemIndexi = memInterfaceDict[ ccpTagGen[i].rtlPrefixString + '_' ];
    var em_mem_external_interfaces = {};
    if (ccpTagGen[i].MemType !== 'NONE') {
      /* istanbul ignore else env ncore_3p2, ncore_3p4 */
        if (interfaces.memoryInt.length > 0) {
    em_mem_external_interfaces.externalInterface = utilFunctions.deepCopy(interfaces.memoryInt[ ccpTagMemIndexi ]);
    em_mem_external_interfaces.externalInterface.name = ' ';
        }
    }

    var ccpTagMemInterfaces = [];

    ccpTagMemInterfaces.push({
        modulePrefix: '', //memInterfaceName[ ccpTagMemIndex ],
        localPrefix: memInterfaceName[ ccpTagMemIndexi ],
        interface: memInterfaceBundle[ ccpTagMemIndexi ],
        direction: memInterfaceDirection[ ccpTagMemIndexi ]
    });

\jsend
        \=obj.lib.instance({
                    instanceName: ccpTagGen[i].rtlPrefixString, //tagMemRtlPrefix + i,
                    moduleName: ccpTagGen[i].moduleName + '_em_mem_external', //tagMemRtlPrefix + '_em_mem_external',
                    tachlName: 'em_mem_external',
                    params: {
                        useMemoryGating : useMemoryGating,
                        sverilog : assertOn,
                        interfaces      : em_mem_external_interfaces,
                        memEccBlocks : tagP.eccBlocks,
                        rtlPrefixString: ccpTagGen[i].moduleName, //ccpTagGen[0].rtlPrefixString, //tagMemRtlPrefix,
                        modulePrefix: 'dmi',
                        memoryType: tagStructures[i].memoryType,
                        nSignals: tagStructures[i].signals.length,
                        signals: tagStructures[i].signals,
                        useHandshake: 0,
                        no_mem_init: 0,
                        ports: 'sp',
                        bitEnable: 1,
                        numberOfEnables: tagStructures[i].width,
                        width: tagStructures[i].width,
                        depth: tagStructures[i].depth
                    },
                    verilogParams: {},
                    ports: instance_ports_for_ram[i],
                    interfaces: ccpTagMemInterfaces,
                    portsDelimiter: '\n'
        })=\
\jsbegin
        }
    }
\jsend

\jsbegin
//========================================================
// CCP Rp RAMs instaniation
//========================================================
\jsend

\jsbegin
    if (useCmc) {
        /* istanbul ignore if env ncore_3p0, ncore_3p2, ncore_3p4 */
        if (nrumem) {
            var instance_ports_for_ram = [];
            for (var i = 0; i < ccpParams.nTagBanks; i++) {
                var rtlPrefixString = rpStructures[i].rtlPrefixString + i;
                var memoryControlInterface = rpStructures[i].controlSignals;
                instance_ports_for_ram[i] = {clk : clkInterfaceName+'clk'};
                for (var signal in memoryControlInterface) {
                    instance_ports_for_ram[i][signal]  = 'mem__' + rtlPrefixString + '_' + signal;
                }
            // Forced to 1 in CPR 
            /* istanbul ignore else env ncore_3p4 */    
	        if (useMemoryGating) {
		        instance_ports_for_ram[i]['cg_test_en'] = clkInterfaceName+'test_en';
	        }
                if (rpStructures[i].memoryType === "SYNOPSYS") {
                    if (Object.keys(rpStructures[i].signals).length > 0) {
                        for (var signal in rpStructures[i].signals) {
                            if(signal!='int_chip_en') {
                                instance_ports_for_ram[i][rpStructures[i].rtlPrefixString + '_' + signal] = rpStructures[i].rtlPrefixString + i + '_' + signal;
                            }
                        }
                    }
                }
\jsend
                \=obj.lib.instance({
                            instanceName: rpMemRtlPrefix + i,
                            moduleName: rpMemRtlPrefix + '_em_mem_external',
                            tachlName: 'em_mem_external',
                            params: {
                                useMemoryGating : useMemoryGating,
                                sverilog : assertOn,
                                rtlPrefixString: rpMemRtlPrefix,
                                modulePrefix: 'dmi',
                                memoryType: rpStructures[i].memoryType,
                                nSignals: rpStructures[i].signals.length,
                                signals: rpStructures[i].signals,
                                useHandshake: 0,
                                no_mem_init: 0,
                                ports: 'tp',
                                bitEnable: 1,
                                numberOfEnables: ccpParams.nWays, // rpStructures[i].width,
                                width: rpStructures[i].width,
                                depth: rpStructures[i].depth
                            },
                            verilogParams: {},
                            ports: instance_ports_for_ram[i],
                            portsDelimiter: '\n'
                })=\
\js         }
\js // Wire external RAMS to CCP ports
\jsbegin
            var str = '';
            for (var i = 0; i < ccpParams.nTagBanks; i++) {
                var rtlPrefixString = rpStructures[i].rtlPrefixString + i;
                var memoryControlInterface = rpStructures[i].controlSignals;
                str += memFunctions.string_addConnectionfromInterface(''      + rtlPrefixString + '_',
                                                                      'mem__' + rtlPrefixString + '_',
                                                                      memoryControlInterface);
            }
\jsend 
            \=str=\
\js    } // nrumem
\js } //useCmc

\jsbegin
//========================================================
// CCP Data RAMs instaniation
//========================================================
\jsend
\jsbegin
    if(useCmc) {
        var instance_ports_for_ram = [];
        for (var i = 0; i < ccpParams.nDataBanks; i++) {
            var rtlPrefixString = ccpDataGen[i].rtlPrefixString + i; //BOON
            var memoryControlInterface = dataStructures[i].controlSignals;
            instance_ports_for_ram[i] = {clk : clkInterfaceName+'clk'};
            for (var signal in memoryControlInterface) {
                instance_ports_for_ram[i][signal]  = 'mem__' + rtlPrefixString + '_' + signal;
            }
        // Forced to 1 in CPR 
        /* istanbul ignore else env ncore_3p4 */    
	    if (useMemoryGating) {
		    instance_ports_for_ram[i]['cg_test_en'] = clkInterfaceName+'test_en';
	    }
            if (dataStructures[i].memoryType === "SYNOPSYS") {
                /* istanbul ignore if env ncore_3p0, ncore_3p2, ncore_3p4 */
                if (Object.keys(dataStructures[i].signals).length > 0) {
                    for (var signal in dataStructures[i].signals) {
                        if(signal!='int_chip_en') {
                            instance_ports_for_ram[i][dataStructures[i].rtlPrefixString + '_' + signal] = dataStructures[i].rtlPrefixString + i + '_' + signal;
                        }
                    }
                }
            }
    var ccpDataMemIndex = memInterfaceDict[ ccpDataGen[0].rtlPrefixString + '_' ];
    var ccpDataMemIndexi = memInterfaceDict[ ccpDataGen[i].rtlPrefixString + '_' ];
    var em_mem_external_interfaces = {};
    if (ccpDataGen[i].MemType !== 'NONE') {
         /* istanbul ignore else env ncore_3p2, ncore_3p4 */
        if (interfaces.memoryInt.length > 0) {
    em_mem_external_interfaces.externalInterface = utilFunctions.deepCopy(interfaces.memoryInt[ ccpDataMemIndexi ]);
    em_mem_external_interfaces.externalInterface.name = ' ';
        }
    }

    var ccpDataMemInterfaces = [];

    ccpDataMemInterfaces.push({
        modulePrefix: '', //memInterfaceName[ ccpDataMemIndex ],
        localPrefix: memInterfaceName[ ccpDataMemIndexi ],
        interface: memInterfaceBundle[ ccpDataMemIndexi ],
        direction: memInterfaceDirection[ ccpDataMemIndexi ]
    });
\jsend
            \=obj.lib.instance({
                        instanceName: ccpDataGen[i].rtlPrefixString, //dataMemRtlPrefix + i,
                        moduleName: ccpDataGen[i].moduleName + '_em_mem_external', //dataMemRtlPrefix + '_em_mem_external',
                        tachlName: 'em_mem_external',
                        params: {
                            useMemoryGating : useMemoryGating,
                            sverilog : assertOn,
                            interfaces      : em_mem_external_interfaces,
                            memEccBlocks : dataP.eccBlocks,
                            rtlPrefixString: ccpDataGen[i].moduleName, //ccpDataGen[0].rtlPrefixString, //dataMemRtlPrefix,
                            modulePrefix: 'dmi',
                            memoryType: dataStructures[i].memoryType,
                            nSignals: dataStructures[i].signals.length,
                            signals: dataStructures[i].signals,
                            useHandshake: 0,
                            no_mem_init: 0,
                            ports: 'sp',
                            bitEnable: 0,
                            width: dataStructures[i].width,
                            depth: dataStructures[i].depth,
                            useMemWrapperDoutFlop: 0
                        },
                        verilogParams: {},
                        ports: instance_ports_for_ram[i],
                        interfaces: ccpDataMemInterfaces,
                        portsDelimiter: '\n'
            })=\
\jsbegin
        }
    }
\jsend

\js // Wire external RAMS to CCP ports, just changing wire name
\jsbegin
    if(useCmc) {
        var str = '';
        for (var i = 0; i < ccpParams.nDataBanks; i++) {
            var rtlPrefixString = ccpDataGen[i].rtlPrefixString + i;
            var memoryControlInterface = dataStructures[i].controlSignals;
            str += memFunctions.string_addConnectionfromInterface(''      + rtlPrefixString + '_',
                                                                  'mem__' + rtlPrefixString + '_',
                                                                   memoryControlInterface);
        }
\jsend
\=str=\
\js }
\jsbegin
    if(useCmc) {
        var str = '';
        for (var i = 0; i < ccpParams.nTagBanks; i++) {
            var rtlPrefixString = ccpTagGen[i].rtlPrefixString + i;
            var memoryControlInterface = tagStructures[i].controlSignals;
            str += memFunctions.string_addConnectionfromInterface(''      + rtlPrefixString + '_',
                                                                  'mem__' + rtlPrefixString + '_',
                                                                   memoryControlInterface);
        }
\jsend
\=str=\
\js } // useCmc

\jsbegin
//========================================================
// CCP PLRU RAMs instaniation
//========================================================
\jsend

\jsbegin
if (useCmc) {

 if (usePLRU) {

  for (let f=0; f < ccpParams.nTagBanks; f++) {
            var plru_mem_ports = {
                clk:            interfaces.clkInt.name+'clk',
                int_chip_en_read:       'w_f'+f+'_plru_mem_read_en',
                int_chip_en_write:      'w_f'+f+'_plru_mem_write_en',
                int_address_read:       'w_f'+f+'_plru_mem_read_addr',
                int_address_write:      'w_f'+f+'_plru_mem_write_addr',
                int_data_in:    'w_f'+f+'_plru_mem_write_data',
                int_data_out:   'w_f'+f+'_plru_mem_read_data'
                };
                /* istanbul ignore else env ncore_3p4 */
                if (useMemoryGating) {
                        plru_mem_ports['cg_test_en'] = interfaces.clkInt.name+'test_en';
                }

    var plruMemEccBlocks = [[]];

    var plru_em_mem_external_interfaces = {};

    var PlruMemInterfaces = [];

   if (MemoryGeneration.plruMem != undefined) {

    var PlruMemIndexi = memInterfaceDict[ MemoryGeneration.plruMem[f].PlruMem.rtlPrefixString + '_' ];

    if (MemoryGeneration.plruMem[f].MemType !== 'NONE') {
                /* istanbul ignore else env ncore_3p2, ncore_3p4 */
        if (interfaces.memoryInt.length > 0) {
    plru_em_mem_external_interfaces.externalInterface = utilFunctions.deepCopy(interfaces.memoryInt[ PlruMemIndexi ]);
    plru_em_mem_external_interfaces.externalInterface.name = ' ';
        }
    }

    PlruMemInterfaces.push({
        modulePrefix: '',
        localPrefix: memInterfaceName[ PlruMemIndexi ],
        interface: memInterfaceBundle[ PlruMemIndexi ],
        direction: memInterfaceDirection[ PlruMemIndexi ]
    });

   }

\jsend

    \=obj.lib.instance({
        instanceName: (MemoryGeneration.plruMem != undefined) ? MemoryGeneration.plruMem[f].rtlPrefixString : 'u_f'+f+'_plru_mem',
        moduleName: (MemoryGeneration.plruMem != undefined) ? MemoryGeneration.plruMem[f].moduleName + '_em_mem_external' : 'f'+f+'_plru_'+'_em_mem_external',
        tachlName: 'em_mem_external',
        params: {
                useMemoryGating: useMemoryGating,
                sverilog: 0, //ASSERT_ON
                interfaces      : plru_em_mem_external_interfaces,
                memEccBlocks: plruMemEccBlocks,
                rtlPrefixString: (MemoryGeneration.plruMem != undefined) ? MemoryGeneration.plruMem[f].moduleName : 'f'+f+'plru_',
                modulePrefix: 'plru',
                memoryType: (MemoryGeneration.plruMem != undefined) ? MemoryGeneration.plruMem[f].MemType : 'SYNOPSYS',
                nSignals: (MemoryGeneration.plruMem != undefined) ? MemoryGeneration.plruMem[f].Signals.length : 0,
                signals: (MemoryGeneration.plruMem != undefined) ? MemoryGeneration.plruMem[f].Signals : [],
                useHandshake: 0,
                no_mem_init: 0,
                ports: 'tp',
                bitEnable: 0,
                numberOfEnables: ccpParams.nWays,
                width: ccpParams.nWays,
                depth: ccpParams.nSets / ccpParams.nTagBanks },
        verilogParams: {},
        ports: plru_mem_ports,
        interfaces: PlruMemInterfaces,
        portsDelimiter: '\n\t'
    })=\

\jsbegin
  }
 }
}
\jsend

\jsbegin
// =======================================================
// PMA REQn Synchronizers
// =======================================================
\jsend

\js if (usePma) {

\=obj.lib.instance({
   instanceName: 'u_pma_REQn_sync',
   moduleName:   'dffr_sync',
   params: {
       'width' : 1,
       'depth' : syncDepth,
   },
   ports: {
       clk      : clkInterfaceName+'clk',
       reset_n  : clkInterfaceName+'reset_n',
       in_data  : qInterfaceName+'REQn',
       out_data : qInterfaceName+'REQn_sync'
    }
})=\

\js }

\jsbegin
// =======================================================
// Master Trigger Synchronizer
// =======================================================
// trigger intf always present on 3.4 
/* istanbul ignore else env ncore_3p4 */
if( interfaces.masterTriggerInt && !interfaces.masterTriggerInt._SKIP_ ) { \jsend

 \=obj.lib.instance({
    'portsDelimiter': '\n  ',
    'instanceName': 'u_sync_main_trig',
    'moduleName':   'dffr_sync',
    'params': {
      'width' : 1,
      'depth' : syncDepth}, 
    'ports': {
      'clk'      : clkInterfaceName+'clk',
      'reset_n'  : clkInterfaceName+'reset_n',
      'in_data'  : masterTriggerInterface.name+'trigger',
      'out_data' : masterTriggerInterface.name+'trigger_sync'}})=\
\jsbegin
} \jsend

endmodule
