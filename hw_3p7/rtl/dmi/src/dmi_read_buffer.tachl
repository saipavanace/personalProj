//=============================================================================
// Copyright(C) 2022 Arteris, Inc.
// All rights reserved
//=============================================================================
\jsbegin
// DMI Read Buffer
// Author: Jason Villanueva
// Descriptions:
// 
// The DMI read buffer is a data buffer sized to hold [RTT numEntries]
//  cache lines of data. It's purpose is to be able to accept all outstanding
//  read data requests. This is useful when the AXI target has read data
//  interleaving enabled. The DMI must receive all data beats before sending
//  back towards the resource_control block for processing. 
//  This data buffer is implemented as a SRAM.
//
// If read data interleaving is not supported on AXI, this buffer is not needed 
//  or instantiated. 
//=============================================================================
\jsend

\jsbegin
const u							= obj.lib;
const libUtils					= obj.userLib;
const bundleFunctions			= obj.userLib.bundleFunctions;

var log2ceil = function(n) { return Math.ceil(Math.log(n)/Math.LN2); };
//=============================================================================
// Default Parameter Declarations
//=============================================================================

//=============================================================================
// Parameters
//=============================================================================
var SRAM                        = u.getParam('SRAM');
var numEntries                  = u.getParam('numEntries');
var assertOn                    = u.getParam('assertOn');
var rdBufferProtType            = u.getParam('rdBufferProtType');
var rdBufferGen                 = u.getParam('rdBufferGen');
var rdBufferParam               = u.getParam('rdBufferParam');
var nBeats                      = u.getParam('nBeats');
var wId                         = u.getParam('wId');
var useExRdDataMem              = u.getParam('useExRdDataMem');
var clkInterface                = u.getParam('clkInterface');
var readDataInterface           = u.getParam('readDataInterface');
var rdBufferMemoryInterface     = u.getParam('rdBufferMemoryInterface');

//=============================================================================
// Variables
//=============================================================================
var dataBufferSize      = nBeats * numEntries;
var wDataBufferSize     = log2ceil(dataBufferSize);
var wBeats              = log2ceil(nBeats);
var wNumEntries         = log2ceil(numEntries);

var wDataBuffer = bundleFunctions.getBundleWidth(readDataInterface, ['valid', 'ready','first'], u.bundle);

var rd_Fifo_bundle = {};
rd_Fifo_bundle['valid'] = 1;
rd_Fifo_bundle['ready'] = -1;
rd_Fifo_bundle['RTTid'] = wNumEntries;
rd_Fifo_bundle['beats'] = wBeats;

var readDataInterfaceMinusFirst    = Object.assign({},readDataInterface);  
readDataInterfaceMinusFirst.first  = 0;

//=============================================================================
// Ports & Interfaces
//=============================================================================

if(useExRdDataMem) {
    obj.lib.interface('', 'master', rdBufferMemoryInterface);
} 

var wMemIndex        = log2ceil(dataBufferSize);
// SRAM always set for read buffer for 3.4
/* istanbul ignore else env ncore_3p4,ncore_3p6, ncore_3p7 */
if (SRAM) {
    if ( rdBufferProtType !== 'NONE' ) {
        obj.lib.port('output', 'mem_uce',               1);
        obj.lib.port('output', 'mem_uce_index',         wMemIndex);
    }
        
    if ( rdBufferProtType === 'SECDED' ) {
        obj.lib.port('output', 'mem_ce',                1);
        obj.lib.port('output', 'mem_ce_index',          wMemIndex);
    }
}
obj.lib.port('input', 'csr_CECR_ErrDetEn',      1);
obj.lib.port('input', 'csr_UEDR_MemErrDetEn',   1);

u.interface('',                 'slave',    clkInterface);
u.interface('read_data_in_',    'slave',    readDataInterface);
u.interface('read_data_out_',   'master',   readDataInterface);
u.port('input',  'alloc_en',                1);
u.port('input',  'alloc_Id',                wId);
u.port('input',  'alloc_Idx_vec',           numEntries);
u.port('output', 'active',                  1);
\jsend
module \=u.getModuleName()=\ (\=u.getPorts('\n')=\);

//=============================================================================
// Local Parameters
//=============================================================================

//=============================================================================
// Wires
//=============================================================================
\=bundleFunctions.wiresFromInterface('rd_Fifo_push_', rd_Fifo_bundle, [],  u.bundle)=\
\=bundleFunctions.wiresFromInterface('rd_Fifo_pop_',  rd_Fifo_bundle, [],  u.bundle)=\

wire                                        data_fifo_active;
wire                                        rd_wr_bank_conflict;
wire                                        read_ready;
wire                                        data_req_in_ready;

wire                                        deallocEn;
wire [\=numEntries-1=\:0]                   deallocIdxVec;
wire                                        writeEn;

wire                                        validEn;
wire [\=numEntries-1=\:0]                   valid;
wire [\=numEntries-1=\:0]                   validIn;
wire [\=numEntries-1=\:0]                   validSet;
wire [\=numEntries-1=\:0]                   validClr;

wire [\=wBeats-1=\:0]                       rd_beatIn;
wire [\=wBeats-1=\:0]                       rd_beat;
wire [\=wBeats-1=\:0]                       wr_beat_sel;

wire [\=wNumEntries-1=\:0]                  write_id;
wire [\=wDataBufferSize-1=\:0]              wr_ptr;

wire                                        rd_ptr_en;
wire [\=wDataBufferSize-1=\: 0 ]            rd_ptr;

\jsbegin
for(var i = 0; i < numEntries; i++) { \jsend
wire [\=wBeats-1=\:0]                       beat_\=i=\;
wire [\=wBeats-1=\:0]                       beatIn_\=i=\;
wire                                        beatEn_\=i=\;
\jsbegin
} \jsend

wire [\=numEntries-1=\:0]                   writeIdCAM;

wire                                        d_read_data_first;
wire                                        en_read_data_first;

\jsbegin
//=============================================================================
// ID Transaction Tracker 
//  Used to maintain order with same ID transactions. 
// Allocate : Upon new transaction being sent to transaction control layer.
//            RTT selected and AXI Id is captured
// De-Allocate : As last beat is written into Memory remove from ID tracker
//               to update order link list. 
// SearchId : Output used to determine oldest matching AXI Id & use that entry as 
//            part of the Memory write address.
//=============================================================================
\jsend
    \=obj.lib.instance({
        instanceName: 'dmi_rdBuffer_id_tracker',
        moduleName: 'dmi_id_tracker',
        params: {
            width: wId,
            numEntries: numEntries,
            lookup_bypass_mode: 0,
            clkInterface: clkInterface,
            assertOn : assertOn
        },
        verilogParams: {},
        ports: {
            allocEn: 'alloc_en',
            allocIdx: 'alloc_Idx_vec',
            allocId: 'alloc_Id',
            deallocEn: 'rd_Fifo_push_valid',
            searchId: 'read_data_in_id',
            searchIdx: 'writeIdCAM',
        },
        interfaces: [{
            modulePrefix: '',
            localPrefix: '',
            interface: clkInterface
        }],
        portsDelimiter: '\n        '
    })=\

\jsbegin
//=============================================================================
// Read Buffer Entries: Each entry corresponds to RTT entry.
// valid    : bit vector used indicate if buffer holds valid data.
//            set on allocate & cleared when data is read out of SRAM
// beat     : Current beat number, used to keep track of wr_ptr.
//            cleared on allocate, updated upon each write to SRAM
//=============================================================================
// Valid flops
\jsend
    \=obj.lib.dffre(numEntries, 'valid', 'validIn', numEntries+"'d0", 'validEn', 'clk', 'reset_n')=\
 
    assign validIn  = validSet | (valid & ~validClr);
    assign validSet = alloc_en ? alloc_Idx_vec : \=numEntries=\'h0;
    assign validClr = deallocEn ? deallocIdxVec : \=numEntries=\'h0;
    assign validEn  = alloc_en || deallocEn;

\jsbegin
// Beat flops
for (var entry = 0; entry < numEntries; entry++) { \jsend
    \=obj.lib.dffre(wBeats, 'beat_'+entry, 'beatIn_'+entry, wBeats+"'d0", 'beatEn_'+entry, 'clk', 'reset_n')=\
    assign beatEn_\=entry=\ = validSet[\=entry=\] || (writeEn && writeIdCAM[\=entry=\]);
    assign beatIn_\=entry=\ = validSet[\=entry=\] ? \=wBeats=\'h0 : beat_\=entry=\ + \=wBeats=\'d1;
\jsbegin
} \jsend

// Select beat entry of write lookup
assign wr_beat_sel = (beat_0 & {\=wBeats=\{writeIdCAM[0]}})
\jsbegin
for (var i = 1; i < numEntries; i++) { \jsend
                     |(beat_\=i=\ & {\=wBeats=\{writeIdCAM[\=i=\]}})
\jsbegin
} \jsend
                     ;
\jsbegin
//=============================================================================
// Write Pointer Logic:
// ADDR = {RTT entry ID, beat count}
// Use writeIdCAM encoded value to use as part of address.
// Use entry's beat count as second part of address.
//=============================================================================
\jsend
\=obj.lib.instance({
    instanceName: 'write_id_encoder',
    moduleName: 'encoder',
    params: {
        width: numEntries
    },
    verilogParams: {},
    ports: {
        invector: 'writeIdCAM',
        outdecode: 'write_id'
    },
    interfaces: [{
        modulePrefix: '',
        localPrefix: ''
    }],
    portsDelimiter: '\n        '
})=\
assign writeEn = read_data_in_valid && read_data_in_ready; 
assign wr_ptr           = {write_id, wr_beat_sel};

\jsbegin
//=============================================================================
// Read Buffer Memory
// Each buffer entry represents a 512 bit cache line. 
// SRAM address is structured as follows: {RTT_entry_ptr,beat}
// Example: 256 bit DMI, 4 entry RTT
//      addr:0x0        [data beat 0] \ Entry 0
//      addr:0x1        [data beat 1] /
//      addr:0x2        [data beat 0] \ Entry 1
//      addr:0x3        [data beat 1] /
//      addr:0x4        [data beat 0] \ Entry 2
//      addr:0x5        [data beat 1] /
//      addr:0x6        [data beat 0] \ Entry 3
//      addr:0x7        [data beat 1] /
//
// Each data beat contains read data payload & other interface signals.
//=============================================================================
//console.log("DMI:RD_BUFFER = \n"+JSON.stringify(rdBufferGen,null,8));
var dataFifoPorts= {
    csr_UEDR_MemErrDetEn: 'csr_UEDR_MemErrDetEn',
    csr_CECR_ErrDetEn   : 'csr_CECR_ErrDetEn',
    active : 'data_fifo_active'
};
var dataFifoParams = {
    clkInterface    : clkInterface,
    memoryInterface : rdBufferMemoryInterface,
    dataReqInterface: readDataInterfaceMinusFirst,
    depth           : dataBufferSize,
    width           : wDataBuffer,
    memParam        : rdBufferParam,
    memGen          : rdBufferGen,
    memProtType     : rdBufferProtType,
    assertOn        : assertOn,
    nPorts          : rdBufferParam.nPorts,
    nBanks          : rdBufferParam.nBanks,
    fastRead        : 0,
    nBeats          : nBeats
};

var dataFifoInterfaces = [];
dataFifoInterfaces.push({modulePrefix: '',                  localPrefix: '',            interface: clkInterface,    exclude: []});
dataFifoInterfaces.push({modulePrefix: 'data_req_in_',      localPrefix: 'read_data_in_',    interface: readDataInterface,      exclude: ["ready","first"]});    
dataFifoInterfaces.push({modulePrefix: 'data_req_out_',     localPrefix: 'read_data_out_',    interface: readDataInterface,      exclude: ["ready","first"]});
if ( useExRdDataMem ) {
    dataFifoInterfaces.push({modulePrefix: '',                  localPrefix: '',            interface: rdBufferMemoryInterface, exclude: []});
};

if ( rdBufferProtType !== 'NONE' ) {
    dataFifoPorts['mem_uce_valid'] = 'mem_uce';
    dataFifoPorts['mem_uce_index'] = 'mem_uce_index';
};

if ( rdBufferProtType === 'SECDED' ) {
    dataFifoPorts['mem_ce_valid'] = 'mem_ce';
    dataFifoPorts['mem_ce_index'] = 'mem_ce_index';
};

dataFifoPorts["data_req_out_ready"] =  "read_data_out_ready";
dataFifoPorts["rd_ptr"] =  "{1'b0,rd_ptr}";
dataFifoPorts["rd_en"] =  "rd_ptr_en";
dataFifoPorts["wr_ptr"] =  "{1'b0,wr_ptr}";
dataFifoPorts["wr_en"] =  "writeEn";
dataFifoPorts["read_ready"] =  "read_ready";
dataFifoPorts["data_req_in_ready"] = "data_req_in_ready";
dataFifoPorts["rd_wr_bank_conflict"] = "rd_wr_bank_conflict"
\jsend
\js // Read Data Buffer is sized to accept all beats of all outstanding reads
\js //  Memory reads are higher priority than memory writes during conflict.
assign read_data_in_ready = ~(rd_ptr_en && rd_wr_bank_conflict);
\=obj.lib.instance({
    instanceName: 'data_fifo',
    moduleName  : 'dmi_write_data_fifo',
    params      : dataFifoParams,
    ports       : dataFifoPorts,
    interfaces  : dataFifoInterfaces
})=\

\js // Read Data First logic:
\js // First has to be calculated as read data is read out of the buffer instead of before read buffer because beats can 
\js //  come interleaved from AXI when read data interleaving is enabled.
\=obj.lib.dffre(1, 'read_data_out_first', 'd_read_data_first', "1'b1", 'en_read_data_first', 'clk', 'reset_n')=\      
assign d_read_data_first = read_data_out_valid && read_data_out_ready && read_data_out_last;
assign en_read_data_first = read_data_out_valid && read_data_out_ready;
\jsbegin
//=============================================================================
// Read FIFO: This FIFO controls reading data out of the read data buffer. 
// Push in:
//  RTT ID : Location in RTT of read request that needs to be read out of buffer
//  beats  : Maximum number of beats of transaction (Max - 1)
// Pop: When beat count reaches max value. 
//=============================================================================
var rd_FifoParams = {
    width           : bundleFunctions.getBundleWidth(rd_Fifo_bundle, ['valid','ready'], u.bundle),
    depth           : numEntries,
    zerodepth       : 0,
    bypass_mode     : 0,
    interface       : rd_Fifo_bundle
}
var rd_FifoInterfaces = [];
rd_FifoInterfaces.push({modulePrefix: '', localPrefix: '',            interface: clkInterface,  exclude: []               });
rd_FifoInterfaces.push({modulePrefix: 'push_',  localPrefix: 'rd_Fifo_push_',    interface: rd_Fifo_bundle, exclude:[] });
rd_FifoInterfaces.push({modulePrefix: 'pop_',  localPrefix: 'rd_Fifo_pop_',    interface: rd_Fifo_bundle, exclude: [] });
\jsend
assign rd_Fifo_push_valid = writeEn && read_data_in_last;
assign rd_Fifo_push_RTTid = write_id;
assign rd_Fifo_push_beats = wr_ptr[\=wBeats-1=\:0]; 
    \=u.instance({
        instanceName    : 'rd_fifo',
        moduleName      : 'fifo_bundle',
        params          : rd_FifoParams,
        verilogParams   : {},
        ports           : {},
        interfaces      : rd_FifoInterfaces,
     })=\
assign rd_Fifo_pop_ready = deallocEn;

\jsbegin
//=============================================================================
// State update for read /write arbitration:
//
//=============================================================================
\jsend

wire last_was_read;
reg last_was_read_d;
\=obj.lib.dffre(1,   "last_was_read",   "last_was_read_d", "1'b0",  "rd_wr_bank_conflict", 'clk', 'reset_n')=\

always@(*) begin

case ({rd_wr_bank_conflict,writeEn,rd_ptr_en})
        3'b000 : last_was_read_d =  last_was_read; 
        3'b001 : last_was_read_d =  last_was_read; 
        3'b010 : last_was_read_d =  last_was_read; 
        3'b011 : last_was_read_d =  last_was_read; 
        3'b100 : last_was_read_d = last_was_read ; 
        3'b101 : last_was_read_d =  read_data_in_valid ^ last_was_read;
        3'b110 : last_was_read_d =  rd_Fifo_pop_valid ^ last_was_read; 
        3'b111 : last_was_read_d =  1'b0;
        default : last_was_read_d = 1'b0;
endcase
end

\jsbegin
//=============================================================================
// Read Pointer Logic:
// ADDR = {RTT entry ID, beat count}
// Read entry out of Memory if read FIFO is valid and Memory is ready to accept
//  a new request. Start beat count at 0 and count up to max beats.
//=============================================================================
\jsend
assign rd_ptr_en        = rd_Fifo_pop_valid && read_ready && ~ (last_was_read & rd_wr_bank_conflict & read_data_in_valid);

assign rd_ptr = {rd_Fifo_pop_RTTid, rd_beat};

assign rd_beatIn = deallocEn ? \=wBeats=\'h0 : rd_beat + \=wBeats=\'d1;
\=u.dffre(wBeats,   "rd_beat",   "rd_beatIn", wBeats+"'b0",  'rd_ptr_en', 'clk', 'reset_n')=\

assign deallocEn = rd_ptr_en && (rd_beat == rd_Fifo_pop_beats);
assign deallocIdxVec = \=numEntries=\'b1 << rd_Fifo_pop_RTTid; 

\jsbegin
//=============================================================================
// Output
//=============================================================================
// Active logic
\jsend
\=u.instance({
    portsDelimiter: '\n    ',
    instanceName: 'u_cam_match',
    moduleName:   'logic_tree',
    params: {
      'width' : numEntries,
      'logic' : '|'},
    ports: {
      'din'  : 'valid',
      'dout' : 'active'}})=\
\jsbegin
//=============================================================================
// Assertions
//=============================================================================
if ( assertOn ) { \jsend
`ifdef OVL_ASSERT_ON
// synthesis_off
// pragma synthesis_off
// coverage off
//
// Allocate/de-allocate check. Cannot allocate and de-allocate the same location at the same time.
ASSERT_RD_BUFFER_ALLOC_DEALLOC_CHECK: assert property (@(posedge clk) disable iff (~reset_n) !(alloc_en && deallocEn && (alloc_Idx_vec==deallocIdxVec)) )
    else begin $error("ASSERT_ERROR: Read Buffer is allocating and de-allocating the same entry in a cycle !"); #100 $finish; end
//
// Underflow check. Do not try to read out of SRAM when no valid entries exist.
ASSERT_RD_BUFFER_UNDERFLOW_CHECK: assert property (@(posedge clk) disable iff (~reset_n) !(!active && rd_ptr_en) )
    else begin $error("ASSERT_ERROR: Read Buffer underflow condition detected, reading out of buffer with no valid entries !"); #100 $finish; end
//
// Write Empty check. Do not try to write into SRAM when no valid entries exist.
ASSERT_RD_BUFFER_WR_EMPTY_CHECK: assert property (@(posedge clk) disable iff (~reset_n) !(!active && writeEn) )
    else begin $error("ASSERT_ERROR: Read Buffer underflow condition detected, reading out of buffer with no valid entries !"); #100 $finish; end
//
//Only match against one entry for read response while writing into buffer    
ASSERT_WRITE_ONEHOT_CHECK: assert property (@(posedge clk) disable iff (~reset_n) !(writeEn && !$onehot(writeIdCAM)) )
    else begin $error("ASSERT_ERROR: writeIdCAM vector is not onehot. Read Data Response is matching against multiple entries !"); #100 $finish; end
// coverage on
// pragma synthesis_on
// synthesis_on
 `endif
\jsbegin
} \jsend

endmodule
