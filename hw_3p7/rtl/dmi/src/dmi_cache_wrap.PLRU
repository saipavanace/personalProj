//=============================================================================
// Copyright (C) 2018 Arteris, Inc.
// All rights reserved.
//=============================================================================
\jsbegin
// Cache Wrapper
// 
//=========================================================================

var u                           = obj.lib;
var bundleFunctions             = obj.userLib.bundleFunctions;

u.paramDefault('ccpOutputPipeEn', 'boolean', true);

var usePLRU                     = obj.lib.getParam('ccpParams', 'usePLRU');
var plru_addr_w                 = obj.lib.getParam('ccpParams', 'plru_addr_w');

var nWays                       = obj.lib.getParam('ccpParams', 'nWays');
var wWays                       = Math.ceil(Math.log2(nWays));
var nSets                       = obj.lib.getParam('ccpParams', 'nSets');
var wSets                       = Math.ceil(Math.log2(nSets));
var wAddr                       = obj.lib.getParam('ccpParams', 'wAddr');
var wSecurity                   = obj.lib.getParam('ccpParams', 'wSecurity');
var wData                       = obj.lib.getParam('ccpParams', 'wData');
var wCacheLineOffset            = obj.lib.getParam('ccpParams', 'wCacheLineOffset');
var rttIdWidth                  = Math.ceil(Math.log2(obj.lib.getParam('nRttCtrlEntries')));
var nBeats                      = (1<<wCacheLineOffset) / (wData/8);
var wBeats                      = Math.log2(nBeats);
var wState                      = obj.lib.getParam('ccpParams', 'wStateBits');
var wId                         = Math.ceil(Math.log2(obj.lib.getParam('ccpParams', 'nTableEntries')));
var wIndex                      = obj.lib.getParam('ccpParams', 'PriSubDiagAddrBits').length + obj.lib.getParam('ccpParams', 'PortPriSubDiagAddrBits').length;
var PriSubDiagAddrBits          = obj.lib.getParam('ccpParams', 'PriSubDiagAddrBits');
var SecSubRows                  = obj.lib.getParam('ccpParams', 'SecSubRows');
var PortPriSubDiagAddrBits      = obj.lib.getParam('ccpParams', 'PortPriSubDiagAddrBits');
var wTagMem                     = (wAddr - wCacheLineOffset -wIndex + wState + wSecurity + 1) * nWays;
var readInterface               = obj.lib.getParam('readProtInterface');
var sysUnitIdInterface          = obj.lib.getParam('sysUnitIdInterface'); 
var ccpOutputPipeEn             = obj.lib.getParam('ccpOutputPipeEn');
var useAtomic                   = obj.lib.getParam('useAtomic');
var ccpParams                   = obj.lib.getParam('ccpParams');
var nTagBanks                   = ccpParams.nTagBanks;
var nDataBanks                  = ccpParams.nDataBanks;
var TagBankSelBits              = ccpParams.TagBankSelBits;
var DataBankSelBits             = ccpParams.DataBankSelBits;
var nRttCtrlEntries             = obj.lib.getParam('nRttCtrlEntries');
var nWttCtrlEntries             = obj.lib.getParam('nWttCtrlEntries');
var useScratchpad               = obj.lib.getParam('ccpParams', 'useScratchpad');
var wQos                        = readInterface.qos; 
var cmType                      = obj.lib.getParam('cmType');
var useWayPartitioning          = obj.lib.getParam('useWayPartitioning');
var nWayPartitioningRegisters   = obj.lib.getParam('nWayPartitioningRegisters');
var addrInterface               = readInterface;
var wAddrInterface              = bundleFunctions.getBundleWidth(addrInterface, ['ready', 'valid'], obj.lib.bundle); 
var nAius                       = obj.lib.getParam('nAius');
var wFUnitId                    = obj.lib.getParam('wFUnitId');
var wFPortId                    = obj.lib.getParam('wFPortId');
var wNUnitId                    = obj.lib.getParam('wNUnitId');
var wReturnData                 = bundleFunctions.getBundleWidth(obj.lib.getParam('returnDataInterface'), ['ready', 'valid'], obj.lib.bundle); 
var fillInterface               = obj.lib.getParam('fillInterface');
var wFillInterface              = bundleFunctions.getBundleWidth(fillInterface, ['ready', 'valid'], obj.lib.bundle);
var wDwid                       = obj.lib.getParam('returnDataInterface', 'dwid')/(wData/64)
var dwsPerBeat                  = wData/64;
var wCmType                     = addrInterface['cm_type'];
var assertOn                    = obj.lib.getParam('assertOn');
var returnDataInterface         = obj.lib.getParam('returnDataInterface');
var wRdUser			= obj.lib.getParam('returnDataInterface', 'user');
var wMntOpCode                  = 5;
var nWriteBuffers               = obj.lib.getParam('nWriteBuffers');
var wWriteBufferId              = Math.log2(nWriteBuffers);
var wSize                       = addrInterface.size;
ccpParams['enPartialFill']      = 1;
ccpParams['enAXIWrapBurst']     = 1;
ccpParams['enMntOpInitDataMem'] = 1;
ccpParams['useTransActive']     = 1;
ccpParams['enScratchpadFill']   = useAtomic * useScratchpad;
var enScratchpadFill            = ccpParams['enScratchpadFill'];
ccpParams['useDataMemWrapperDoutFlop'] = 0;

var vlogStr2IntArray    = function (vlogStr) {
    var hexStr = vlogStr.substr(2, vlogStr.length-2);
    var hex = parseInt(hexStr, 16);
    var binStr = hex.toString(2);
    var mask = 1 << binStr.length - 1;
    var arr = [];
    for (var i=0; i < binStr.length; i++) {
      /* istanbul ignore if env ncore_3p0, ncore_3p2, ncore_3p4 */
      if (hex & mask) {
        arr.push(binStr.length-1-i);
      }
      mask = mask >> 1;
    }
    return arr;
};

var convertSecSubRowsToOld = function ( mySecSubRows ) {
    /* istanbul ignore else env ncore_3p0, ncore_3p2, ncore_3p4 */
    if (Array.isArray(mySecSubRows)) {
        var oldSecSubRows = {};
        for (var i=0; i < mySecSubRows.length; i++) {
            oldSecSubRows[i] = vlogStr2IntArray(mySecSubRows[i]);
        }
      return oldSecSubRows;
    } else {
      return mySecSubRows;
    }
};
var writeOpInterface = {
    valid:         1,
    ready:        -1,
    beat:          wBeats,
    size:          addrInterface['size'],
    trans_id:      addrInterface['trans_id'],
    aiu_id:        addrInterface['aiu_id'],
    aiu_trans_id:  addrInterface['aiu_trans_id'],
    vz:            1,
    tm:            1,
    through:       1,
    dtwmergemrd:   1,
    drop:          1,
    scratch:       1,
    cacheop:       1,
    nc_op:         1,
    atomic:        1,
    atm_error:     1,
    qos:           wQos,
    bypass:        1,
    user:	   wRdUser
};

var readOpInterface = {
    valid:         1,
    ready:        -1,
    qos:           addrInterface['qos'],
    aiu_id:        addrInterface['aiu_id'],
    aiu_trans_id:  addrInterface['aiu_trans_id'],
    late_resp_id:  addrInterface['late_resp_id'],
    cm_type:       addrInterface['cm_type'],
    cdw:           wDwid,
    tag_uce:       1,   
    atm_error:     1,   
    hitdirty:      1,
    vz:            1,
    alloc_id:      obj.lib.getParam('returnDataInterface','id'),
    size:          obj.lib.getParam('returnDataInterface', 'size'),
    intf_size:     obj.lib.getParam('returnDataInterface', 'intf_size'),
    tm:            1,
    user:	   wRdUser
};

var ccpP0CtrlInterface = {
    ctrl_op_valid_p0: nTagBanks,
    cache_op_ready_p0: -nTagBanks,
    ctrl_op_security_p0: wSecurity,
    ctrl_op_address_p0: wAddr
};
var ccpP2CtrlInterface = {
    ctrl_op_allocate_p2: 1,
    ctrl_op_read_data_p2: 1,
    ctrl_op_write_data_p2: 1,
    ctrl_op_port_sel_p2: 1,
    ctrl_op_bypass_p2: 1,
    ctrl_op_rp_update_p2: 1,
    ctrl_op_tag_state_update_p2: 1,
    ctrl_op_state_p2: wState,
    ctrl_op_burst_len_p2: wBeats,
    ctrl_op_burst_wrap_p2: ccpParams['enAXIWrapBurst'],
    ctrl_op_setway_debug_p2: 1,
    ctrl_op_ways_busy_vec_p2: nWays,
    ctrl_op_ways_stale_vec_p2: nWays,
    cache_alloc_way_vec_p2: -1 * nWays,
    cache_hit_way_vec_p2: -1 *nWays,
    cache_valid_p2: -1,
    cache_current_state_p2: -1 * wState,
    cache_evict_valid_p2: -1,
    cache_evict_address_p2: -1 * wAddr,
    cache_evict_state_p2: -1 * wState,
    cache_evict_security_p2: -1 * wSecurity,
    cache_nack_uce_p2: -1,
    cache_nack_p2: -1,
    cache_nack_ce_p2: -1,
    cache_nack_no_allocate_p2: -1
}
var ccpWrInterface = {
    ctrl_wr_valid: 1,
    cache_wr_ready: -1,
    ctrl_wr_last: 1,
    ctrl_wr_data: wData + 1, // poison
    ctrl_wr_byte_en: wData/8,
    ctrl_wr_beat_num: wBeats
}
var ccpFillInterface = {
    ctrl_fill_valid: 1,
    cache_fill_ready: -1,
    ctrl_fill_address: wAddr,
    ctrl_fill_security: wSecurity,
    ctrl_fill_way_num: wWays,
    ctrl_fill_state: wState,
    cache_fill_done: -1,
    cache_fill_done_id: -1 * wId,
    ctrl_fill_scratchpad: 1 * enScratchpadFill
}
var ccpFillDataInterface = {
    ctrl_fill_data_valid: 1,
    cache_fill_data_ready: -1,
    ctrl_fill_data: wData + 1, // poison
    ctrl_fill_data_id: wId,
    ctrl_fill_data_address: wAddr,
    ctrl_fill_data_way_num: wWays,
    ctrl_fill_data_beat_num: wBeats,
    ctrl_fill_data_last: 1,
    ctrl_fill_data_byteen: wData/8
}
var ccpEvictInterface = {
    cache_evict_valid: 1,
    cache_evict_ready: -1,
    cache_evict_last: 1,
    cache_evict_data: wData + 1, // poison
    cache_evict_byteen: wData/8,
    cache_evict_cancel: 1
}
var ccpRdrspInterface = {
    cache_rdrsp_valid: 1,
    cache_rdrsp_ready: -1,
    cache_rdrsp_last: 1,
    cache_rdrsp_data: wData + 1, // poison
    cache_rdrsp_byteen: wData/8,
    cache_rdrsp_cancel: 1
}
var ccpCorrectableErrorInterface = {
    correctible_error_valid: 1,
    correctible_error_entry: 20,
    correctible_error_way:   6,
    correctible_error_double_error: 1,
    correctible_error_type: 4,
    correctible_error_info: 8,
    correctible_error_word: 6,
    correctible_error_addr_hi: 12
}
var ccpUncorrectableErrorInterface = {
    uncorrectible_error_valid: 1,
    uncorrectible_error_entry: 20,
    uncorrectible_error_way:   6,
    uncorrectible_error_double_error: 1,
    uncorrectible_error_type: 4,
    uncorrectible_error_info: 8,
    uncorrectible_error_word: 6,
    uncorrectible_error_addr_hi: 12
}
var ccpErrorEnableInterface = {
    CorrErrDetectEn: 1,
    UnCorrErrDetectEn: 1
}
var ccpInitInterface = {
    reinit: 1,
    init_done: 1,
    tag_init_done: 1,
    data_init_done: 1
}
var ccpMaintInterface = {
    maint_req_opcode: 4,
    maint_req_array_sel: 1,
    maint_req_data: 32,
    maint_req_way: 32,
    maint_req_entry: 20,
    maint_req_word: 6,
    maint_active: -1,
    maint_read_data: -32,
    maint_read_data_en: -1,
}

var ccpTagInterface = obj.lib.getParam('ccpParams', 'tagStructures');
var ccpDataInterface = obj.lib.getParam('ccpParams', 'dataStructures');
var ccpMemoryInterface = obj.lib.getParam('ccpMemoryInterface');
var ccpCsrInterface = obj.lib.getParam('ccpCsrInterface');
var rsrcCsrInterface = obj.lib.getParam('rsrcCsrInterface');

var wDataIndex = PriSubDiagAddrBits.length - DataBankSelBits.length;

var ccpScratchInterface = {
    scratch_op_valid:      useScratchpad * nDataBanks,
    scratch_op_way_num:    useScratchpad * wWays,
    scratch_op_index_addr: useScratchpad * wDataIndex,
    scratch_op_beat_num:   useScratchpad * wBeats,
    scratch_op_read_data:  useScratchpad * 1,
    scratch_op_write_data: useScratchpad * 1,
    scratch_op_burst_len:  useScratchpad * wBeats,
    scratch_op_burst_wrap: useScratchpad * ccpParams['enAXIWrapBurst'],
    scratch_op_ready:      useScratchpad *-nDataBanks,
    scratch_wr_valid:      useScratchpad * 1,
    scratch_wr_data:       useScratchpad * (wData + 1), // poison
    scratch_wr_byte_en:    useScratchpad * wData/8,
    scratch_wr_beat_num:   useScratchpad * wBeats,
    scratch_wr_last:       useScratchpad * 1,
    scratch_wr_ready:      useScratchpad * -1,
    scratch_rdrsp_valid:   useScratchpad * -1,
    scratch_rdrsp_data:    useScratchpad * -(wData + 1), // poison
    scratch_rdrsp_byteen:  useScratchpad * -wData/8,
    scratch_rdrsp_last:    useScratchpad * -1,
    scratch_rdrsp_cancel:  useScratchpad * -1,
    scratch_rdrsp_ready:   useScratchpad *  1
}

var scratchOpInterface = {
    scratch_op_valid:           useScratchpad,
    scratch_op_way_num:         useScratchpad * wWays,
    scratch_op_index_addr:      useScratchpad * wDataIndex,
    scratch_op_beat_num:        useScratchpad * wBeats,
    scratch_op_read_data:       useScratchpad * 1,
    scratch_op_write_data:      useScratchpad * 1,
    scratch_op_burst_len:       useScratchpad * wBeats,
    scratch_op_bank_sel_onehot: useScratchpad * nDataBanks,
    scratch_op_ready:          -useScratchpad
}

var pipeScratchInterface = {
    scratch_ways:          nWays,
    scratch_p0_valid:       1,
    scratch_p2_valid:      -1,
    scratch_rd_req:        -1
}

var mntOpReqInterface = {
    mnt_op_req_valid:      1,
    mnt_op_req_ready:     -1,
    mnt_op_req_addr:       wAddr,
    mnt_op_req_security :  wSecurity, 
    mnt_op_req_way:        wWays,
    mnt_op_req_msg:        wMntOpCode
}
var ccpPipeOutput               = {};
var excludeList                 = ['ccp_mntop_active', 'ccp_trans_active','ccp_trans_active_4clkGate','ccp_SMCISR_Tag_Init_Done', 'ccp_SMCISR_Data_Init_Done'];
Object.keys(ccpCsrInterface).forEach(function (signal) {
    if ( ccpCsrInterface[signal] > 0 && !excludeList.includes(signal) ) {
        ccpPipeOutput[signal] = ccpCsrInterface[signal];
    }
});

//=========================================================================
// ports
//=========================================================================
u.interface('', 'slave', obj.lib.getParam('clkInterface'));

// upstream from NoC
u.interface('read_addr_s_', 'slave', readInterface);
u.interface('read_data_s_', 'master', obj.lib.getParam('returnDataInterface'));
u.interface('read_resp_',   'master', obj.lib.getParam('writeResponseInterface'));
u.interface('write_prot_',  'slave', obj.lib.getParam('writeProtInterface'));
u.interface('write_prot_data_', 'slave', obj.lib.getParam('writeProtDataInterface'));
u.port('output', 'write_prot_error', 1);
u.interface('write_resp_s_', 'master', obj.lib.getParam('respInterface'));

// downstream to bus
u.interface('read_addr_m_', 'master', readInterface);
u.port('output', 'read_addr_m_bus_valid', 1);
u.port('output', 'read_addr_m_fill', 1);
u.port('output', 'read_addr_m_sp',   1);
u.port('input', 'read_alloc_id', obj.lib.getParam('returnDataInterface', 'id'));
u.port('input', 'rtt_dealloc_id',    wId);
u.port('input', 'rtt_dealloc_valid', 1);
u.port('input', 'write_prot_nc_sel', 1);
u.port('input', 'rtt_dealloc_vec', obj.lib.getParam('nRttCtrlEntries'));
u.port('output', 'dmi_ccp_cache_fill_fifo_avail', 1);
u.port('output', 'dmi_ccp_cache_fill_done',  1);
u.port('output', 'dmi_ccp_cache_fill_done_id', wId);

//=================================================
//Adding PMON Cache Events
//=================================================
u.port('output', 'pmon_cache_rd_hit', 1);
u.port('output', 'pmon_cache_wr_hit', 1);
u.port('output', 'pmon_cache_cmo_hit', 1);
u.port('output', 'pmon_cache_evict', 1);
u.port('output', 'pmon_cache_no_way_alloc', 1);
u.port('output', 'pmon_cache_rd_stall', 1);
u.port('output', 'pmon_cache_wr_stall', 1);
u.port('output', 'pmon_cache_replay', 1);
u.port('output', 'pmon_cache_rd_miss', 1);
u.port('output', 'pmon_cache_wr_miss', 1);
u.port('output', 'pmon_cache_cmo_miss', 1);
u.port('output', 'pmon_cache_fill_stall', 1);
u.port('output', 'ccp_p1_valid', 1);
u.port('output', 'read_write_addr_s_pop_ready_p1', 1);

u.interface('read_data_m_', 'slave', obj.lib.getParam('returnDataInterface'));
u.interface('fill_data_',   'slave', obj.lib.getParam('fillInterface'));
u.interface('write_addr_m_', 'master', obj.lib.getParam('writeProtInterface'));
u.interface('write_data_m_', 'master', obj.lib.getParam('writeDataInterface'));
u.interface('write_resp_m_', 'slave', obj.lib.getParam('writeResponseInterface'));
u.interface('aiu_', 'slave', sysUnitIdInterface);

// to atomic engine
if ( useAtomic ) {
u.interface('atomic_op_', 'master', obj.lib.getParam('writeProtDataInterface'));
u.interface('atomic_rd_', 'master', obj.lib.getParam('returnDataInterface'));
u.port('output', 'atomic_rd_sp', 1);
}
u.port('output', 'write_addr_m_evict', 1);
// from merge buffer
u.interface('mrg_', 'slave', obj.lib.getParam('writeDataBufferInterface'));

u.interface('read_cam_',  'master', obj.lib.getParam('camAddrInterface'));
u.port('input', 'read_cam_match_fill', 1);
u.interface('rtt_cam_',   'master', obj.lib.getParam('camRttVectorInterface'));
u.interface('write_cam_', 'master', obj.lib.getParam('camAddrInterface'));
u.interface('', 'master', ccpMemoryInterface);
u.interface('', 'master', ccpCsrInterface);
u.interface('', 'master', rsrcCsrInterface);

    for (var i = 0; i < nTagBanks; i++) {
        if (usePLRU) {
u.port('output', 'plru_mem'+i+'_read_en', 1);
u.port('output', 'plru_mem'+i+'_read_addr', plru_addr_w);
u.port('input',  'plru_mem'+i+'_read_data', nWays);
u.port('output', 'plru_mem'+i+'_write_en', 1);
u.port('output', 'plru_mem'+i+'_write_addr', plru_addr_w);
u.port('output', 'plru_mem'+i+'_write_data', nWays);
        }
    }

\jsend

module \=u.getModuleName()=\ (\=u.getPorts('\n')=\);

localparam ST_INVAL = 2'h0;
localparam ST_CLEAN = 2'h1;
localparam ST_DIRTY = 2'h2;

localparam RD_WSCLN = \=cmType['MrdRdWSCln']=\;
localparam RD_WUCLN = \=cmType['MrdRdWUCln']=\;
localparam RD_WUNIQ = \=cmType['MrdRdWU']=\;
localparam RD_WINV  = \=cmType['MrdRdWInv']=\;
localparam RD_PREF  = \=cmType['MrdPref']=\;
localparam RD_CLEAN = \=cmType['MrdCln']=\;
localparam RD_INV   = \=cmType['MrdInv']=\;
localparam RD_FLUSH = \=cmType['MrdFlush']=\;
localparam HN_READ  = \=cmType['HntRead']=\;

localparam NC_CMDRD = \=cmType['CmdRdNC']=\;
localparam NC_CLEAN = \=cmType['CmdClnVld']=\;
localparam NC_PRSST = \=cmType['CmdClnShPsist']=\;
localparam NC_FLUSH = \=cmType['CmdClnInv']=\;
localparam NC_MKINV = \=cmType['CmdMkInv']=\;
localparam NC_PREF  = \=cmType['CmdPref']=\;

localparam WR_NDATA = \=cmType['DtwNullData']=\;
localparam WR_CLEAN = \=cmType['DtwDataFullCln']=\;
localparam WR_PARTL = \=cmType['DtwDataPtlDty']=\;
localparam WR_DIRTY = \=cmType['DtwDataFullDty']=\;

localparam WM_INV   = \=cmType['DtwMrgMrdInv']=\;
localparam WM_RSCLN = \=cmType['DtwMrgMrdSCln']=\;
localparam WM_RSDTY = \=cmType['DtwMrgMrdSDty']=\;
localparam WM_RUCLN = \=cmType['DtwMrgMrdUCln']=\;
localparam WM_RUDTY = \=cmType['DtwMrgMrdUDty']=\;

localparam DT_INV   = \=cmType['DtrDataInv']=\;
localparam DT_SCLN  = \=cmType['DtrDataSCln']=\;
localparam DT_SDTY  = \=cmType['DtrDataSDty']=\;
localparam DT_UCLN  = \=cmType['DtrDataUCln']=\;
localparam DT_UDTY  = \=cmType['DtrDataUDty']=\;

localparam RD_ATM   = \=cmType['CmdRdAtm']=\;
localparam WR_ATM   = \=cmType['CmdWrAtm']=\;
localparam CM_ATM   = \=cmType['CmdCompAtm']=\;
localparam SW_ATM   = \=cmType['CmdSwapAtm']=\;

    function is_atomic;
        input [\=addrInterface['cm_type']-1=\:0] cm_type;
        begin
            is_atomic = (cm_type == RD_ATM) | (cm_type == WR_ATM) |
                        (cm_type == CM_ATM) | (cm_type == SW_ATM);
        end
    endfunction

    function is_atomic_str;
        input [\=addrInterface['cm_type']-1=\:0] cm_type;
        begin
            is_atomic_str = (cm_type == WR_ATM);
        end
    endfunction

    function is_cacheop;
        input [\=addrInterface['cm_type']-1=\:0] cm_type;
        begin
            is_cacheop = (cm_type == RD_PREF)  | (cm_type == NC_PREF)  | /*(cm_type == HN_READ) |*/
                         (cm_type == RD_FLUSH) | (cm_type == NC_FLUSH) |
                         (cm_type == RD_CLEAN) | (cm_type == NC_CLEAN) | (cm_type == NC_PRSST) | 
                         (cm_type == RD_INV)   | (cm_type == NC_MKINV);
        end
    endfunction

    function is_cleanflush;
        input [\=addrInterface['cm_type']-1=\:0] cm_type;
        begin
            is_cleanflush = (cm_type == RD_CLEAN) |  (cm_type == RD_FLUSH) |
                            (cm_type == NC_CLEAN) |  (cm_type == NC_FLUSH) |
                            (cm_type == NC_PRSST);
        end
    endfunction

    function [\=addrInterface['cm_type']-1=\:0] return_type;
        input [\=addrInterface['cm_type']-1=\:0] cm_type;
        input hitdirty;
        begin
            return_type = (cm_type==RD_WSCLN /*| cm_type==WM_RSCLN*/) ?  DT_SCLN :
                          (cm_type==RD_WUCLN | cm_type==WM_RUCLN) ?  DT_UCLN :
                           cm_type==RD_WUNIQ ? (DT_UCLN) :
                          (cm_type==RD_WINV  | cm_type==WM_INV)   ?  DT_INV :
                          (cm_type==NC_CMDRD | is_atomic(cm_type))?  DT_INV :
                          /* cm_type==WM_RSDTY ?                       DT_SDTY :*/
                           cm_type==WM_RUDTY ?                       DT_UDTY :
                                                                     cm_type;
        end
    endfunction

    function is_dtwmergemrd;
      input [\=addrInterface['cm_type']-1=\:0] cm_type;
      begin
          is_dtwmergemrd = (cm_type == WM_INV)   |
                           /*(cm_type == WM_RSCLN) | (cm_type == WM_RSDTY) |*/
                           (cm_type == WM_RUCLN) | (cm_type == WM_RUDTY);
      end
    endfunction

\jsbegin
//=========================================================================
// Wires
//=========================================================================
\jsend
    \=bundleFunctions.wiresFromInterface('pipe_in_', ccpPipeOutput, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dmi_ccp_', ccpP0CtrlInterface, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dmi_ccp_', ccpP2CtrlInterface, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dmi_ccp_', ccpWrInterface, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dmi_ccp_', ccpFillInterface, ['cache_fill_done', 'cache_fill_done_id'], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dmi_ccp_', ccpFillDataInterface, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dmi_ccp_', ccpEvictInterface, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dmi_ccp_', ccpRdrspInterface, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dmi_ccp_', ccpCorrectableErrorInterface, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dmi_ccp_', ccpUncorrectableErrorInterface, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dmi_ccp_', ccpErrorEnableInterface, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dmi_ccp_', ccpInitInterface, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dmi_ccp_', ccpMaintInterface, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('', mntOpReqInterface, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('ccp_p2_', mntOpReqInterface, ['mnt_op_req_valid', 'mnt_op_req_ready'], obj.lib.bundle)=\
\jsbegin
    /* istanbul ignore if env ncore_3p0, ncore_3p2, ncore_3p4 */
    if(obj.lib.getParam('writeDataInterface','user') != 0){
\jsend
    wire [\=obj.lib.getParam('writeDataInterface','user')-1=\:0] dmi_ccp_cache_evict_user;
\js }
    wire dmi_ccp_tag_ce;
    wire dmi_ccp_tag_uce;
    wire dmi_ccp_data_ce;
    wire dmi_ccp_data_uce;
    wire mntop_init_all_entries_p2;
    wire mntop_flush_all_entries_p2;
    wire mntop_flush_entry_by_indexway_p2;
    wire mntop_flush_entry_by_address_p2;
    wire mntop_flush_entry_by_address_range_p2;
    wire mntop_flush_entry_by_indexway_range_p2;
    wire mntop_read_tag_entry_by_indexwayword_p2;
    wire mntop_write_tag_entry_by_indexwayword_p2;
    wire mntop_read_data_entry_by_indexwayword_p2;
    wire mntop_write_data_entry_by_indexwayword_p2;
    wire dmi_ccp_ctrl_op_setway_debug_p2_org;
    wire dmi_cache_valid_p2;
    wire cache_pipe_busy;
    wire mnt_req_valid_p2;
    wire mnt_req_valid_flush_p2;
    wire mnt_op_req_valid_p2;
    wire hit_evict_write;
    wire hit_evict_flush;
    wire hit_dirty_mntop_flush;
    wire rtt_addr_match_p2;
    wire wtt_addr_match_p2;
    wire fill_enable;
    wire fill_data_done;
    wire fill_tag_done;
    wire [\=nWays-1=\:0] fill_data_way_pipe;
    wire [\=wWays-1=\:0] fill_pop_way_num;
    \=bundleFunctions.wiresFromInterface('fill_pop_', fillInterface, [], obj.lib.bundle)=\
    wire update_to_inval;
    wire update_to_clean;
    wire update_to_dirty;
    wire read_addr_s_acq;
    wire write_addr_s_acq;
    wire main_wr_ac_en;
    wire ccp_p0_mnt;
    wire ccp_p0_valid;
    wire ccp_p0_ready;
    wire ccp_p0_ns;
    wire [\=wAddr-1=\:0] ccp_p0_addr;
    \=bundleFunctions.wiresFromInterface('ccp_p2_', addrInterface, [], obj.lib.bundle)=\
    wire dmi_cancel_p2;
    wire dmi_p2_kill_ac;
    wire ccp_p2_kill_ac;
    wire ccp_p2_lookup_en;
    wire ccp_p2_to_replay;
    wire ccp_p2_to_replay_q;
    wire ccp_p2_atomic;
    wire ccp_p2_atm_error;
    wire ccp_p2_hit;
    wire ccp_p2_hitdirty;
    wire ccp_p2_unlock;
    wire ccp_p2_mnt;
    wire ccp_p2_way_fwd;
    wire ccp_op_atomic;
    wire ccp_op_scratch;
    wire ccp_op_rd_type;
    \=bundleFunctions.wiresFromInterface('ccp_op_', readOpInterface, [], obj.lib.bundle)=\
    wire [\=obj.lib.getParam('returnDataInterface', 'trans_id')-1=\:0] ccp_op_trans_id;
    \=bundleFunctions.wiresFromInterface('wr_op_', writeOpInterface, [], obj.lib.bundle)=\
    wire [\=obj.lib.getParam('writeResponseInterface', 'cm_type')-1=\:0] wr_op_cop_type;
    wire wr_op_ccp;
    wire wr_op_last;
    wire wr_op_block_merge;
    wire wr_op_resp_late;
    wire wr_op_resp_ready;
    wire wr_op_resp_pend;
    wire wr_op_resp_retry;
    wire wr_op_vdata;
    wire atomic_op_send;
    \=bundleFunctions.wiresFromInterface('write_addr_s_', obj.lib.getParam('writeProtInterface'), [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('write_data_s_', obj.lib.getParam('writeDataBufferInterface'), [], obj.lib.bundle)=\
    wire write_data_s_busy;
    wire write_miss;
    wire write_miss_na;
    wire write_miss_ac;
    wire write_miss_ac_cln;
    wire write_miss_ac_dty;
    wire write_bypass;
    wire write_through;
    wire write_blank;
    wire dtwmergemrd_hit;
    wire [\=obj.lib.getParam('writeResponseInterface', 'resp')-1=\:0] wr_ccp_resp;
    \=bundleFunctions.wiresFromInterface('wr_ccp_p2_', obj.lib.getParam('writeProtInterface'), [], obj.lib.bundle)=\
    wire wr_ccp_p2_drop;
    wire wr_ccp_p2_full;
    wire wr_ccp_p2_sel;
    wire ccp_p2_drop;
    wire ccp_p2_uce_send_rd_opq;
    wire ccp_p2_uce_send_wr_opq;
    wire ccp_p2_rd;
    wire ccp_p2_wr;
    wire ccp_p2_cmo;
    wire ccp_p2_send_opq;
    wire ccp_p2_send_miss;
    wire ccp_p2_send_p0;
   // wire ccp_p1_valid;
    wire [\=nWays-1=\:0] ccp_p2_alloc_way;
    wire [\=addrInterface['aiu_id']-1=\:0] ccp_p1_aiu_id;
    wire dmi_ccp_block;
    wire dmi_ccp_ctrl_op_miss_p2;
    wire dmi_ccp_ctrl_op_hit_p2;
    wire dmi_ccp_trans_active;
    wire read_rdrsp_valid;
    wire read_rdrsp_ready;
    wire [\=wData-1=\:0] read_rdrsp_data;
    wire read_rdrsp_last;
    wire read_rdrsp_poison;
    \=bundleFunctions.wiresFromInterface('read_hit_', obj.lib.getParam('returnDataInterface'), [], obj.lib.bundle)=\
    wire evict_addr_valid, evict_addr_valid_q;
    wire evict_addr_ready;
    wire [\=wAddr-1=\:0] evict_addr;
    wire [\=wAddr-1=\:0] push_evict_address_p2;
    wire [\=wSecurity-1=\:0] evict_ns;
    wire [\=wSecurity-1=\:0] push_evict_security_p2;
    
    \=bundleFunctions.wiresFromInterface('evict_', obj.lib.getParam('writeDataInterface'), ['valid','ready'], obj.lib.bundle)=\
    wire new_evict_read;
    wire new_evict_addr;

    wire scratch_p1_valid;
\js if (useScratchpad) {
    wire [\=wAddr-wCacheLineOffset=\:0] scratch_offset_high;
    wire [\=wAddr-wCacheLineOffset=\:0] scratch_offset_low;
    wire p0_addr_outside_scratch;  
    wire write_addr_s_outside_scratch;  
    wire fill_addr_outside_scratch;
    wire read_addr_m_outside_scratch;
    \=bundleFunctions.wiresFromInterface('', ccpScratchInterface, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('pipe_', scratchOpInterface, [], obj.lib.bundle)=\
    wire [\=nDataBanks-1=\:0]       scratch_op_bank_sel_onehot;
    wire                            scratch_p0_match;
    wire [\=wWays-1=\:0]            scratch_max_way;
    wire                            scratch_en;
\js }
    wire [\=nWays-1=\:0]            scratch_way_p2;
    wire                            scratch_p0_ready;
    wire                            scratch_wr_kill_ac;
    wire                            scratch_fill;
    wire                            scratch_done_p2;
    \=bundleFunctions.wiresFromInterface('', pipeScratchInterface, [], obj.lib.bundle)=\
    wire [\=nWays-1=\:0]            ccp_p1_wp_way;
    wire [\=addrInterface['aiu_trans_id']-1=\:0] ccp_p1_aiu_trans_id;
    wire [\=returnDataInterface.trans_id-1=\:0]  read_hit_push_trans_id;

    \js// TODO: perhaps this should work with same sync reset in protocol control
    \js// and be triggered from csr block
    \js// wire [2:0] q_reset_delay;
    \js// \=obj.lib.dffre(3, 'q_reset_delay', '{q_reset_delay[1:0], 1\'b1}', "{3{1'b0}}", "1'b1", 'clk', 'reset_n')=\
    \js// assign dmi_ccp_reinit = q_reset_delay[2:1] == 2'b01;
    wire [\=wNUnitId-1=\:0]         ccp_p1_n_unit_id;
    wire [\=wAddr-1=\:0]            ccp_p1_addr;
    wire                            pop_scratch_op_valid;
    wire                            pop_scratch_op_ready;
    wire                            read_busy_en;
    wire [1:0]                      read_busy_scratch;
    wire                            read_busy_in;
    wire [\=wDwid*dwsPerBeat-1=\:0] ccp_op_dwid;
    wire                            read_hit_push_valid;
    wire                            read_hit_push_exokay;
    wire                            read_hit_push_qos;
    wire                            read_hit_push_ready;
    wire                            read_hit_push_last;
    wire                            read_hit_push_poison;
    wire [\=wCmType-1=\:0]          read_hit_push_cm_type;
    wire [1:0]                      read_hit_push_err_type;
    wire [\=wData-1=\:0]            read_hit_push_data;
    wire [\=wSize-1=\:0]            read_hit_push_size;
    wire [\=wDwid-1=\:0]            q_dwid;
    wire                            dwid_en;
    wire [\=wDwid-1=\:0]            dw_mask;
    wire [\=wDwid-1=\:0]            dwid_wrap_boundary;
    wire [\=wDwid-1=\:0]            size_aligned_dwid;
    wire [\=wDwid-1=\:0]            next_dwid;
    wire [\=wDwid-1=\:0]            trans_size_dw;
    wire [\=wDwid-1=\:0]            beat_first_dw;
    wire                            d_hit_data_first;
    wire                            q_hit_data_first;
    wire                            en_hit_data_first;

    wire                            push_trans_id_valid;
    wire                            push_trans_id_ready;
    wire                            pop_trans_id_valid;
    wire                            pop_trans_id_ready;

    wire                            push_trans_cache_id_valid;
    wire                            push_trans_cache_id_ready;
    wire                            pop_trans_cache_id_valid;
    wire                            pop_trans_cache_id_ready;
    wire [\=obj.lib.getParam('returnDataInterface', 'trans_id')-1=\:0] ccp_op_cache_trans_id;

    \jsbegin
    if (useScratchpad) {
    \jsend
        wire                            push_trans_sp_id_valid;
        wire                            push_trans_sp_id_ready;
        wire                            pop_trans_sp_id_valid;
        wire                            pop_trans_sp_id_ready;
        wire [\=obj.lib.getParam('returnDataInterface', 'trans_id')-1=\:0] ccp_op_sp_trans_id;
    \jsbegin
    }
    \jsend
    
    wire                            write_data_go;
    wire                            read_hit_sent;
    wire                            read_hit_sent_in;
    wire                            read_hit_sent_en;
    wire [\=wBeats=\:0]             manufac_beat_downcnt;
    wire [\=wBeats=\:0]             q_manufac_beat_downcnt;
    wire [\=wBeats=\:0]             d_manufac_beat_downcnt;
    wire                            en_manufac_beat_downcnt;
    wire [\=wBeats=\:0]             manufac_beat_num;
    wire                            op_needs_manufac_beat;
    wire                            wtt_ready;
    wire                            mntop_active;
    wire                            auto_init_active;
    wire                            mntop_flush_p2;
    wire                            flush_fail_p2;

    wire                            ccp_p1_wp_no_rsvd_way;
    wire                            ccp_p2_wp_no_rsvd_way;

   //PMON Wires
    wire pmon_cache_rd_hit_in;
    wire pmon_cache_wr_hit_in;
    wire pmon_cache_cmo_hit_in;
    wire pmon_cache_evict_in;
    wire pmon_cache_no_way_alloc_in;
    wire pmon_cache_rd_stall_in;
    wire pmon_cache_wr_stall_in;
    wire pmon_cache_rd_miss_in;
    wire pmon_cache_wr_miss_in;
    wire pmon_cache_cmo_miss_in;
    wire pmon_cache_fill_stall_in;
    wire dff_enable = 1'b1;

    
	

//
//  write buffer
//
    \=u.instance({
        instanceName: 'write_data_buffer',
        moduleName: 'dmi_wdata_buffer',
        params: {
            wCacheLineOffset:   wCacheLineOffset,
            nWriteBuffers:      nWriteBuffers,
            clkInterface:       obj.lib.getParam('clkInterface'),
            cmType:             cmType,
            writeAddrInterface: obj.lib.getParam('writeProtInterface'),
            writeDataInterface: obj.lib.getParam('writeProtDataInterface'),
            writeDataBufferInterface: obj.lib.getParam('writeDataBufferInterface')
        },
        interfaces: [
                {modulePrefix: '',                 localPrefix: '',                 interface: obj.lib.getParam('clkInterface') },
                {modulePrefix: 'write_prot_',      localPrefix: 'write_prot_',      interface: obj.lib.getParam('writeProtInterface')},
                {modulePrefix: 'write_prot_data_', localPrefix: 'write_prot_data_', interface: obj.lib.getParam('writeProtDataInterface')},
                {modulePrefix: 'write_res_',       localPrefix: 'write_addr_s_',    interface: obj.lib.getParam('writeProtInterface')},
                {modulePrefix: 'wrdata0_',         localPrefix: 'write_data_s_',    interface: obj.lib.getParam('writeDataBufferInterface')},
                {modulePrefix: 'wrdata1_',         localPrefix: 'mrg_',             interface: obj.lib.getParam('writeDataBufferInterface')}
        ],
        ports: {
                write_res_trans_id:      'write_addr_s_trans_id',
                wrdata0_unlock:          'ccp_p2_unlock',
                wrdata0_unlock_id:       'ccp_p2_trans_id'
        },
        portsDelimiter: '\n        '
    })=\
    
    wire write_data_req_sent;
    wire write_data_req_sent_d;
    \=obj.lib.dffre(1, 'write_data_req_sent', 'write_data_req_sent_d', "1'b0", "1'b1", 'clk', 'reset_n')=\

    assign write_data_req_sent_d  = ~wr_op_ready & (write_data_s_req_valid & write_data_s_req_ready | write_data_req_sent);
    assign write_data_s_req_valid = wr_op_vdata & ~write_data_req_sent;

\jsbegin
//=============================================================================
// CCP pipe state required for timing
//=============================================================================
// Set true for timing on 3.4
/* istanbul ignore else env ncore_3p4 */
if (ccpOutputPipeEn) { 
\jsend
\=u.instance({
              instanceName : 'ccp_output_pipe',
              moduleName : 'simple_pipe_stage',
              params : {
                        pipeSignals: ccpPipeOutput
                        },
              ports : {
                       clk : 'clk',
                       reset_n : 'reset_n',
                       en : "1'b1",
                       },
              interfaces : [
                            {modulePrefix: 'in_',   localPrefix: 'pipe_in_',        interface: ccpPipeOutput},
                            {modulePrefix: 'out_',  localPrefix: '',   interface: ccpPipeOutput}
                            ]
              })=\
\jsbegin
} else { \jsend
    \=bundleFunctions.assignByBundle('', 'pipe_in_', ccpPipeOutput, [], obj.lib.bundle)=\
\jsbegin
} \jsend

\jsbegin
//=============================================================================
// Generate bank_sel_onehot for ctrl_op_valid_p0
//=============================================================================
    // TODO: need to fix timing on p1 p0 index conflict
\jsend
    wire [\=wAddr-1=\:0] gen_index_p0__addr_in;
    wire [\=wAddr-1=\:0] gen_index_p1__addr_in;
    wire [\=wAddr-1=\:0] gen_index_p2__addr_in;
    wire [\=PriSubDiagAddrBits.length-1=\:0] gen_index_p0__index_out;
    wire [\=PriSubDiagAddrBits.length-1=\:0] gen_index_p1__index_out;
    wire [\=PriSubDiagAddrBits.length-1=\:0] gen_index_p2__index_out;

    wire [\=nTagBanks-1=\:0] bank_sel_onehot;
\jsbegin
    /* istanbul ignore else env ncore_3p0 */
    if (nTagBanks > 1) {
\jsend
    wire [\=Math.log2(nTagBanks)-1=\:0] bank_sel;
\js }
\jsbegin
    /* istanbul ignore else env ncore_3p0 */
    if (TagBankSelBits.length > 0) {
\jsend
    wire [\=TagBankSelBits.length-1=\:0] bank_p0;
\js }
\jsbegin
    /* istanbul ignore else env ncore_3p0 */
    if (nTagBanks > 1) {
\jsend
    assign bank_sel_onehot = \=nTagBanks=\'b1 << bank_sel;
\js } else {
    assign bank_sel_onehot = \=nTagBanks=\'b1;
\js }

    assign gen_index_p0__addr_in = dmi_ccp_ctrl_op_address_p0;
    assign gen_index_p1__addr_in = ccp_p1_addr;
    assign gen_index_p2__addr_in = ccp_p2_addr;

\js for (var i=0; i < TagBankSelBits.length; i++) {
    assign bank_p0[\=i=\] = gen_index_p0__index_out[\=TagBankSelBits[i]=\];
\js }
\jsbegin
    /* istanbul ignore else env ncore_3p0 */
    if (nTagBanks > 1) {
\jsend
    assign bank_sel = bank_p0;
\js }

\jsbegin
//=============================================================================
// Instantiation for set_select for gen_index_p0
//=============================================================================
\jsend

\jsbegin
    var set_select_params = {  PriSubDiagAddrBits : PriSubDiagAddrBits,
                               SecSubRows         : convertSecSubRowsToOld(SecSubRows),
                               wAddr              : wAddr
                            };
    var instance_ports_for_gen_index_p0 = {
        addr_in                          : 'gen_index_p0__addr_in',
        index_out                        : 'gen_index_p0__index_out'
    };
    var instance_ports_for_gen_index_p1 = {
        addr_in                          : 'gen_index_p1__addr_in',
        index_out                        : 'gen_index_p1__index_out'
    };
    var instance_ports_for_gen_index_p2 = {
        addr_in                          : 'gen_index_p2__addr_in',
        index_out                        : 'gen_index_p2__index_out'
    };

\jsend
    \=obj.lib.instance({
        instanceName: 'u_gen_index_p0',
        moduleName: 'set_select',
        params: set_select_params,
        verilogParams: {},
        ports: instance_ports_for_gen_index_p0,
        portsDelimiter: '\n    '
    })=\
    \=obj.lib.instance({
        instanceName: 'u_gen_index_p1',
        moduleName: 'set_select',
        params: set_select_params,
        verilogParams: {},
        ports: instance_ports_for_gen_index_p1,
        portsDelimiter: '\n    '
    })=\
    \=obj.lib.instance({
        instanceName: 'u_gen_index_p2',
        moduleName: 'set_select',
        params: set_select_params,
        verilogParams: {},
        ports: instance_ports_for_gen_index_p2,
        portsDelimiter: '\n    '
    })=\

\js //TODO: check ways_busy in all scratchpad case
\js //TODO: FIX this using set_select output
\js //TODO; check timing on this

    assign ccp_p2_way_fwd = ~|(gen_index_p2__index_out ^ gen_index_p1__index_out) & ccp_p1_valid & ccp_p2_valid;

//=============================================================================
// Instantiation for ccp
//=============================================================================

\jsbegin

    var instance_ports_for_ccp = {};

    instance_ports_for_ccp["trans_active"] = 'dmi_ccp_trans_active';

    for (var i = 0; i < nTagBanks; i++) {
        if (usePLRU) {
instance_ports_for_ccp['plru_mem'+i+'_read_en']    = 'plru_mem'+i+'_read_en';
instance_ports_for_ccp['plru_mem'+i+'_read_addr']  = 'plru_mem'+i+'_read_addr';
instance_ports_for_ccp['plru_mem'+i+'_read_data']  = 'plru_mem'+i+'_read_data';
instance_ports_for_ccp['plru_mem'+i+'_write_en']   = 'plru_mem'+i+'_write_en';
instance_ports_for_ccp['plru_mem'+i+'_write_addr'] = 'plru_mem'+i+'_write_addr';
instance_ports_for_ccp['plru_mem'+i+'_write_data'] = 'plru_mem'+i+'_write_data';
        }
    }


\jsend

        \=obj.lib.instance({
            instanceName: 'dmi_ccp',
            moduleName: 'ccp_top',
            params: ccpParams,
            verilogParams: {},
            ports: instance_ports_for_ccp,
            interfaces: [
                {modulePrefix: '', localPrefix: '', interface: obj.lib.getParam('clkInterface')},
                {modulePrefix: '', localPrefix: 'dmi_ccp_', interface: ccpP0CtrlInterface},
                {modulePrefix: '', localPrefix: 'dmi_ccp_', interface: ccpP2CtrlInterface},
                {modulePrefix: '', localPrefix: 'dmi_ccp_', interface: ccpWrInterface},
                {modulePrefix: '', localPrefix: 'dmi_ccp_', interface: ccpFillInterface},
                {modulePrefix: '', localPrefix: 'dmi_ccp_', interface: ccpFillDataInterface},
                {modulePrefix: '', localPrefix: 'dmi_ccp_', interface: ccpEvictInterface},
                {modulePrefix: '', localPrefix: 'dmi_ccp_', interface: ccpRdrspInterface},
                {modulePrefix: '', localPrefix: 'dmi_ccp_', interface: ccpCorrectableErrorInterface},
                {modulePrefix: '', localPrefix: 'dmi_ccp_', interface: ccpUncorrectableErrorInterface},
                {modulePrefix: '', localPrefix: 'dmi_ccp_', interface: ccpErrorEnableInterface},
                {modulePrefix: '', localPrefix: 'dmi_ccp_', interface: ccpInitInterface},
                {modulePrefix: '', localPrefix: 'dmi_ccp_', interface: ccpMaintInterface},
                {modulePrefix: '', localPrefix: '',         interface: ccpScratchInterface},
                {modulePrefix: '', localPrefix: '',         interface: ccpMemoryInterface}
            ],
            portsDelimiter: '\n        '
        })=\

    wire dtwmergemrd_fill;
    wire wr_data_valid;
    // Active Write Stage

    assign wr_ccp_p2_drop     = (ccp_p2_wr & (ccp_p2_cm_type == WR_CLEAN) &
                                                 (~ccp_p2_ac | ccp_p2_kill_ac |(ccp_p2_ac & ccp_p2_hit))) | ccp_p2_uce_send_wr_opq;
    assign write_miss         = ccp_p2_wr & dmi_ccp_ctrl_op_miss_p2;
    assign write_miss_ac      = ccp_p2_wr & ccp_p2_ac & dmi_ccp_ctrl_op_miss_p2 & ~ccp_p2_kill_ac & 
                                ((~ccp_p2_vz &  (ccp_p2_cm_type == WR_DIRTY)) |
                                                (ccp_p2_cm_type == WR_CLEAN));
    assign dtwmergemrd_fill   = is_dtwmergemrd(ccp_p2_cm_type) &
                                ccp_p2_ac & ~ccp_p2_kill_ac & ~(ccp_p2_cm_type == WM_RUDTY);
    assign write_miss_na      = write_miss & ~write_miss_ac & ~wr_ccp_p2_drop & ~dtwmergemrd_fill;

    // even if write hit, need to force bypass for the write through case with VZ=SV
    assign write_bypass       = write_miss_na | (write_through & ~scratch_p2_valid);
    assign write_through      = ((dmi_ccp_ctrl_op_hit_p2 & ccp_p2_vz & ((ccp_p2_cm_type == WR_DIRTY) |
                                                                        (ccp_p2_cm_type == WR_PARTL))) |
                                dtwmergemrd_hit) & ~ccp_p2_mnt;
    assign dtwmergemrd_hit    = ccp_p2_hit & is_dtwmergemrd(ccp_p2_cm_type);
                              
    assign write_miss_ac_cln  = write_miss_ac & (ccp_p2_cm_type == WR_CLEAN);
    assign write_miss_ac_dty  = write_miss_ac & (ccp_p2_cm_type == WR_DIRTY);

    assign wr_data_valid            = write_data_s_valid & wr_op_vdata & ~wr_op_drop & ~wr_op_atomic & ~wr_op_resp_retry & ~wr_op_block_merge;
    assign dmi_ccp_ctrl_wr_valid    = wr_data_valid & ~wr_op_scratch;
    assign dmi_ccp_ctrl_wr_data     = {write_data_s_poison, write_data_s_data};

    wire [\=wBeats-1=\:0] write_beat;
    wire [\=wBeats-1=\:0] write_beat_d;
    wire [\=wBeats-1=\:0] write_beat_inc;
    wire [\=wBeats-1=\:0] write_beat_mask;
    wire write_beat_en;
    wire write_next;
    wire write_next_d;
    wire prev_beat_en;
    wire [\=wBeats=\:0] write_next_beat;
    wire [\=wBeats-1=\:0] prev_beat_inc;
    // this counter wraps at size boundary, according to AXI rules
    \=obj.lib.dffre(wBeats+1, 'write_next_beat', '{write_next_d, write_beat_d}', '{'+(wBeats+1)+"{1'b0}}", 'write_beat_en', 'clk', 'reset_n')=\

    assign {write_next, write_beat} = write_next_beat;
    assign write_next_d             = ~wr_op_last;
    assign write_beat_inc           = dmi_ccp_ctrl_wr_beat_num + 'b1;
    // mask is to wrap increment on boundary according to size
    assign write_beat_mask          = ((\=wBeats=\'b1<<wr_op_size) - 1) >> \=Math.log2(wData/8)=\;
    assign write_beat_d             = ( write_beat_mask & write_beat_inc) |
                                      (~write_beat_mask & wr_op_beat);
    assign write_beat_en            = ~write_blank & prev_beat_en;
    assign dmi_ccp_ctrl_wr_beat_num = write_blank ? prev_beat_inc : write_next ? write_beat : wr_op_beat;
    assign dmi_ccp_ctrl_wr_byte_en  = write_blank ? 'b0 : write_data_s_be;
    assign dmi_ccp_ctrl_wr_last     = write_blank ? 'b0 : write_data_s_last;

    // this logic is necessary to get around ccp wrap issue conc-4346, conc-4345
    // the data is not delivered in the order that ccp can accept it 
    assign write_blank              = write_next & wr_op_through & (prev_beat_inc != write_beat);
    // this counter wraps at cacheline boundary
    \=obj.lib.dffre(wBeats, 'prev_beat_inc', 'write_beat_inc', '{'+wBeats+"{1'b0}}", 'prev_beat_en', 'clk', 'reset_n')=\

    assign prev_beat_en             = (dmi_ccp_ctrl_wr_valid & dmi_ccp_cache_wr_ready)\=useScratchpad ? '| (scratch_wr_valid & scratch_wr_ready);' : ';'=\
 //=============================================================================
// PMON Events
//=============================================================================
wire pmon_ccp_ctrl_op_allocate_nack_no_allocate;
assign pmon_ccp_ctrl_op_allocate_nack_no_allocate = dmi_ccp_ctrl_op_miss_p2 & ccp_p2_ac & ~dmi_cancel_p2 & ~ccp_p2_mnt &
                      ccp_p2_kill_ac & 
                      (ccp_p2_cm_type == RD_WSCLN |
                       ccp_p2_cm_type == RD_WUCLN |
                       ccp_p2_cm_type == RD_WINV  |
                       ccp_p2_cm_type == NC_CMDRD |
//                       ccp_p2_cm_type == HN_READ  |
                       ccp_p2_cm_type == NC_PREF  |
                       ccp_p2_cm_type == RD_PREF  |
                       ccp_p2_cm_type == WM_INV   |
//                       ccp_p2_cm_type == WM_RSCLN |
//                       ccp_p2_cm_type == WM_RSDTY |
                       ccp_p2_cm_type == WM_RUCLN |
                       ccp_p2_cm_type == WR_CLEAN |
                      (ccp_p2_cm_type == WR_DIRTY & ~ccp_p2_vz) | 
                       is_atomic(ccp_p2_cm_type));



assign pmon_cache_rd_hit_in = dmi_ccp_ctrl_op_hit_p2 & ccp_p2_rd; 
assign pmon_cache_wr_hit_in = dmi_ccp_ctrl_op_hit_p2 &  ccp_p2_wr;
assign pmon_cache_cmo_hit_in =  dmi_ccp_ctrl_op_hit_p2 & ccp_p2_cmo & ~dmi_ccp_cache_nack_p2;
assign pmon_cache_evict_in = dmi_ccp_cache_evict_valid_p2 & (dmi_ccp_cache_evict_state_p2 != ST_INVAL);
assign pmon_cache_fill_stall_in = dmi_ccp_ctrl_fill_data_valid & ~dmi_ccp_cache_fill_data_ready;
assign pmon_cache_no_way_alloc_in = pmon_ccp_ctrl_op_allocate_nack_no_allocate;
assign pmon_cache_rd_stall_in = dmi_ccp_cache_rdrsp_valid & ~dmi_ccp_cache_rdrsp_ready;
assign pmon_cache_wr_stall_in = dmi_ccp_ctrl_wr_valid & ~dmi_ccp_cache_wr_ready; 

assign pmon_cache_rd_miss_in = dmi_ccp_ctrl_op_miss_p2 & ccp_p2_rd;
assign pmon_cache_wr_miss_in = dmi_ccp_ctrl_op_miss_p2 & ccp_p2_wr;
assign pmon_cache_cmo_miss_in = dmi_ccp_ctrl_op_miss_p2 & ccp_p2_cmo & ~dmi_ccp_cache_nack_p2;

\=u.dffre(1, 'pmon_cache_rd_hit', 'pmon_cache_rd_hit_in', "1'b0",  'dff_enable', 'clk', 'reset_n')=\
\=u.dffre(1, 'pmon_cache_wr_hit', 'pmon_cache_wr_hit_in', "1'b0",  'dff_enable', 'clk', 'reset_n')=\
\=u.dffre(1, 'pmon_cache_cmo_hit', 'pmon_cache_cmo_hit_in', "1'b0",  'dff_enable', 'clk', 'reset_n')=\
\=u.dffre(1, 'pmon_cache_evict', 'pmon_cache_evict_in', "1'b0",  'dff_enable', 'clk', 'reset_n')=\
\=u.dffre(1, 'pmon_cache_no_way_alloc', 'pmon_cache_no_way_alloc_in', "1'b0",  'dff_enable', 'clk', 'reset_n')=\

\=u.dffre(1, 'pmon_cache_fill_stall', 'pmon_cache_fill_stall_in', "1'b0",  'dff_enable', 'clk', 'reset_n')=\
\=u.dffre(1, 'pmon_cache_rd_stall', 'pmon_cache_rd_stall_in', "1'b0",  'dff_enable', 'clk', 'reset_n')=\
\=u.dffre(1, 'pmon_cache_wr_stall', 'pmon_cache_wr_stall_in', "1'b0",  'dff_enable', 'clk', 'reset_n')=\

\=u.dffre(1, 'pmon_cache_rd_miss', 'pmon_cache_rd_miss_in', "1'b0",  'dff_enable', 'clk', 'reset_n')=\
\=u.dffre(1, 'pmon_cache_wr_miss', 'pmon_cache_wr_miss_in', "1'b0",  'dff_enable', 'clk', 'reset_n')=\
\=u.dffre(1, 'pmon_cache_cmo_miss', 'pmon_cache_cmo_miss_in', "1'b0",  'dff_enable', 'clk', 'reset_n')=\





    // Write Response mux
    // To avoid timing issues, capture write response in latch if can't be sent back to 
    // protocol block in same cycle and only backpressure bus if latch is full.
    // In most cases, late response is not required so response can be dropped.

    wire wr_bus_resp_valid;
    wire wr_bus_resp_ready;
    \=bundleFunctions.wiresFromInterface('bus_resp_', obj.lib.getParam('writeResponseInterface'), ['ready'], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('write_resp_q_', obj.lib.getParam('writeResponseInterface'), ['valid','ready'], obj.lib.bundle)=\
    wire evict_resp_valid;
    wire evict_resp_ready;
    wire cacheop_resp_valid;
    wire op_done_p2;

    wire set_bus_resp_pend;
    wire bus_resp_pend_d;
    wire bus_resp_pend;

    wire clr_bus_resp_pend;
    wire bus_resp_evict; 


\js var width = bundleFunctions.getBundleWidth(obj.lib.getParam('writeResponseInterface'), ['ready', 'valid'], obj.lib.bundle);
    wire [\=width-1=\:0] write_resp_q;
    wire wr_op_resp_valid;
    wire cacheop_resp_ready; 
    wire push_evict_addr_valid;
    wire push_evict_addr_ready;
    \=obj.lib.dffre(width, 'write_resp_q', bundleFunctions.packetizeBundle('write_resp_m_', obj.lib.getParam('writeResponseInterface'), ['valid', 'ready'], obj.lib.bundle), '{'+width+"{1'b0}}", 'set_bus_resp_pend', 'clk', 'reset_n')=\

    assign \=bundleFunctions.packetizeBundle('write_resp_q_', obj.lib.getParam('writeResponseInterface'), ['valid', 'ready'], obj.lib.bundle)=\ = write_resp_q; 

    \=obj.lib.dffre(1, 'bus_resp_pend', 'bus_resp_pend_d', "1'b0", "1'b1", 'clk', 'reset_n')=\

    assign set_bus_resp_pend  = write_resp_m_valid & write_resp_m_ready & 
                               ((wr_bus_resp_valid & ~wr_bus_resp_ready) | (evict_resp_valid & ~evict_resp_ready));
    assign clr_bus_resp_pend  = (wr_bus_resp_valid &  wr_bus_resp_ready) | (evict_resp_valid &  evict_resp_ready);
    assign bus_resp_pend_d    = set_bus_resp_pend | (bus_resp_pend & ~clr_bus_resp_pend);
    assign write_resp_m_ready = ~bus_resp_pend;

                        
    assign \=bundleFunctions.packetizeBundle('bus_resp_', obj.lib.getParam('writeResponseInterface'), ['valid', 'ready'], obj.lib.bundle)=\ = bus_resp_pend ? \=bundleFunctions.packetizeBundle('write_resp_q_', obj.lib.getParam('writeResponseInterface'), ['valid', 'ready'], obj.lib.bundle)=\ 
                                         : \=bundleFunctions.packetizeBundle('write_resp_m_', obj.lib.getParam('writeResponseInterface'), ['valid', 'ready'], obj.lib.bundle)=\;

    assign bus_resp_valid    = write_resp_m_valid | bus_resp_pend;
    assign bus_resp_evict    = is_cleanflush(bus_resp_cm_type);
    assign evict_resp_valid  =  bus_resp_valid & bus_resp_vz &  bus_resp_evict;
    assign wr_bus_resp_valid =  bus_resp_valid & bus_resp_vz & ~bus_resp_evict;
    assign wr_ccp_resp       = 'b0;
    \=obj.lib.instance({
        instanceName: 'write_response',
        moduleName: 'muxarb_bundle',
        params: {
            number_of_inputs: 2,
            width: bundleFunctions.getBundleWidth( obj.lib.getParam('respInterface'), ['valid', 'ready'], obj.lib.bundle),
            sink_type: 'RdyVld',
            pipeline: 0,
            arb_priority: 'RoundRobin',
            sfi_compliant: 1,
            output_grant: 0,
            interface: obj.lib.getParam('respInterface'),
            noLastSignal: 1
        },
        verilogParams: {},
        ports: {
            sink0_resp:  'wr_ccp_resp',
            sink0_valid: 'wr_op_resp_valid',
            sink0_ready: 'wr_op_resp_ready',
            sink1_valid: 'wr_bus_resp_valid',
            sink1_ready: 'wr_bus_resp_ready'},
        interfaces: [{
            modulePrefix: '',
            localPrefix: '',
            interface: obj.lib.getParam('clkInterface')
        },{
            modulePrefix: 'sink0_',
            localPrefix: 'wr_op_',
            interface: obj.lib.getParam('respInterface'),
            exclude: ['resp', 'ready', 'valid']
        },{
            modulePrefix: 'sink1_',
            localPrefix: 'bus_resp_',
            interface: obj.lib.getParam('respInterface'),
            exclude: ['ready', 'valid']
        },{
            modulePrefix: 'source_',
            localPrefix: 'write_resp_s_',
            interface: obj.lib.getParam('respInterface')
        }],
        portsDelimiter: '\n        '
    })=\

    // specific type doesn't matter, just need to distinguish nc from coh
    assign wr_op_cop_type         = wr_op_nc_op ? NC_FLUSH : RD_FLUSH;

    assign write_prot_error       = wr_op_atm_error & wr_op_resp_valid & wr_op_resp_ready;

    assign cacheop_resp_valid     = wr_op_valid & wr_op_cacheop;
    assign read_resp_valid        = cacheop_resp_valid | evict_resp_valid;
    assign read_resp_vz           = cacheop_resp_valid ? wr_op_vz           : bus_resp_vz;
    assign read_resp_tm           = cacheop_resp_valid ? wr_op_tm           : bus_resp_tm;
    assign read_resp_cm_type      = cacheop_resp_valid ? wr_op_cop_type     : bus_resp_cm_type;
    assign read_resp_resp         = cacheop_resp_valid ? 'b0                : bus_resp_resp;
    assign read_resp_aiu_id       = cacheop_resp_valid ? wr_op_aiu_id       : bus_resp_aiu_id;
    assign read_resp_aiu_trans_id = cacheop_resp_valid ? wr_op_aiu_trans_id : bus_resp_aiu_trans_id;
\js if ( wQos != 0 ) {
    assign read_resp_qos          = cacheop_resp_valid ? wr_op_qos          : bus_resp_qos; 
\js }
\js if(obj.lib.getParam('writeResponseInterface').user>0) {
    assign read_resp_user = \=obj.lib.getParam('writeResponseInterface').user=\'b0;
\js}
    assign evict_resp_ready       =~cacheop_resp_valid & read_resp_ready;
    assign cacheop_resp_ready     = cacheop_resp_valid & read_resp_ready;
    
    // Accept write data if write miss to bus, write miss fill (full), or write hit
\js if (useScratchpad) {
    assign wr_op_ccp          = ~write_blank & ~wr_op_atomic & ~wr_op_block_merge & (wr_op_scratch ? scratch_wr_ready : dmi_ccp_cache_wr_ready);
\js } else {
    assign wr_op_ccp          = ~write_blank & ~wr_op_atomic & ~wr_op_block_merge & dmi_ccp_cache_wr_ready;
\js }
    assign write_data_s_ready  = wr_op_vdata & ~wr_op_resp_retry & (wr_op_ccp | wr_op_drop | atomic_op_send | wr_op_bypass & write_data_m_ready);
    assign write_data_s_req_id = wr_op_vdata ?  wr_op_trans_id : 'b0;

    assign wr_op_resp_late    = wr_op_last & wr_op_vz & ~wr_op_dtwmergemrd;
    assign wr_op_resp_valid   = wr_op_resp_late  |  wr_op_resp_retry;
    assign wr_op_vdata        = wr_op_valid & ~wr_op_cacheop;
    assign wr_op_ready        = wr_op_atomic  ? (wr_op_last & atomic_op_send) :
                                wr_op_cacheop ? cacheop_resp_ready :
                                               (wr_op_last & ~wr_op_resp_late)  | (wr_op_resp_valid & wr_op_resp_ready);
    assign wr_op_resp_pend    = wr_op_resp_valid & ~wr_op_resp_ready;
    assign wr_op_last         = write_data_s_valid & write_data_s_ready & write_data_s_last;

    // for atomic ops, write data contains operand so send it on special atomic op bus
\js if ( useAtomic ) {
    assign atomic_op_send     = wr_op_vdata & wr_op_atomic & (atomic_op_ready | wr_op_drop);
    \=bundleFunctions.assignByBundle('atomic_op_', 'write_data_s_', obj.lib.getParam('writeProtDataInterface'), ['valid','ready'], obj.lib.bundle)=\
    assign atomic_op_valid    = wr_op_vdata & wr_op_atomic & write_data_s_valid & ~wr_op_drop;
\js } else {
    assign atomic_op_send     = 1'b0;
\js }
    \=obj.lib.dffre(1, 'wr_op_resp_retry', 'wr_op_resp_pend', "1'b0", "1'b1", 'clk', 'reset_n')=\

\jsbegin
    // Evict Buffer
    // Save Evict Address in 1 entry bypass fifo in case not accepted in WTT right away.
\jsend

    wire [\=wAddr + wSecurity-1=\:0] push_evict_addr_data;
    \=obj.lib.instance({
        instanceName: 'evict_addr_fifo',
        moduleName: 'fifo',
        params: {
            width: wAddr + wSecurity,
            depth: 1,
            zerodepth: 0,
            bypass_mode: 1
        },
        interfaces: [{ modulePrefix: '', localPrefix: '', interface: obj.lib.getParam('clkInterface') }],
        ports: {
            push_valid: 'push_evict_addr_valid',
            push_ready: 'push_evict_addr_ready',
            push_data:  'push_evict_addr_data',
            pop_valid:  'evict_addr_valid',
            pop_ready:  'evict_addr_ready',
            pop_data:   '{evict_ns, evict_addr}'
        },
        portsDelimiter: '\n        '
    })=\
    assign push_evict_addr_valid = ~dmi_cancel_p2 & new_evict_addr;

    assign push_evict_addr_data = { push_evict_security_p2, push_evict_address_p2 };

    assign push_evict_security_p2 = mnt_req_valid_p2 & 
                                    (mntop_flush_entry_by_address_range_p2 | 
                                     mntop_flush_entry_by_address_p2       ) ? ccp_p2_mnt_op_req_security  
                                                                             : dmi_ccp_cache_evict_security_p2;
    assign push_evict_address_p2 = mnt_req_valid_p2 & 
                                   (mntop_flush_entry_by_address_range_p2 | 
                                    mntop_flush_entry_by_address_p2       ) ? ccp_p2_mnt_op_req_addr
                                                                            : dmi_ccp_cache_evict_address_p2;

    assign mnt_req_valid_flush_p2 = mntop_flush_p2 & mnt_req_valid_p2 & ~flush_fail_p2;

    assign hit_dirty_mntop_flush = (dmi_ccp_cache_current_state_p2 == ST_DIRTY) & mnt_req_valid_flush_p2;

    assign hit_evict_write = dmi_ccp_ctrl_op_hit_p2 &
                             ((ccp_p2_cm_type == WR_PARTL) | (ccp_p2_cm_type == WR_DIRTY)) & ccp_p2_vz;
    assign hit_evict_flush = dmi_ccp_ctrl_op_hit_p2 & (dmi_ccp_cache_current_state_p2 == ST_DIRTY) & 
                             is_cleanflush(ccp_p2_cm_type);
                               
    assign new_evict_read = hit_evict_write | hit_evict_flush | new_evict_addr;
    assign new_evict_addr = ~ccp_p2_kill_ac &
                            (dmi_ccp_cache_evict_valid_p2 & dmi_ccp_ctrl_op_allocate_p2 & 
                             dmi_ccp_cache_evict_state_p2 == ST_DIRTY) | hit_dirty_mntop_flush;

    \js var width = bundleFunctions.getBundleWidth(obj.lib.getParam('writeDataInterface'), ['ready', 'valid'], obj.lib.bundle);

    wire evict_valid;
    wire evict_ready;

    \=obj.lib.instance({
        instanceName: 'evict_buffer',
        moduleName: 'fifo_bundle',
        params: {
            width: width,
            depth: nBeats,
            zerodepth: 0,
            bypass_mode: 0,
            interface: obj.lib.getParam('writeDataInterface'),
        },
        verilogParams: {},
        ports: {
            push_data: 'dmi_ccp_cache_evict_data['+(wData-1)+':0]',
            push_be: 'dmi_ccp_cache_evict_byteen',
            push_poison: 'dmi_ccp_cache_evict_data['+wData+']'},
        interfaces: [{
            modulePrefix: '',
            localPrefix: '',
            interface: obj.lib.getParam('clkInterface')
        },{
            modulePrefix: 'push_',
            localPrefix: 'dmi_ccp_cache_evict_',
            interface: obj.lib.getParam('writeDataInterface'),
            exclude: ['be','data','poison']
        },{
            modulePrefix: 'pop_',
            localPrefix: 'evict_',
            interface: obj.lib.getParam('writeDataInterface')
        }],
        portsDelimiter: '\n        '
    })=\

    wire dmi_ccp_cache_evict_poison;
    \js// TODO: do we do anything with this poisoned eviction
    assign dmi_ccp_cache_evict_poison = dmi_ccp_cache_evict_data[\=wData=\];

\jsbegin
/* istanbul ignore if env ncore_3p0, ncore_3p2, ncore_3p4 */
    if(obj.lib.getParam('writeDataInterface','user') != 0){
\jsend
    assign dmi_ccp_cache_evict_user = 'b0;
\js }
    wire write_addr_sel;

    //Timing fix. use unqualified signal to select and qualify valid with error at end of cone of logic.
    assign write_addr_sel     = wr_ccp_p2_sel;
    assign write_addr_m_valid = write_addr_sel ? wr_ccp_p2_valid : evict_addr_valid;
    assign write_addr_m_addr  = write_addr_sel ? wr_ccp_p2_addr : evict_addr;
    assign write_addr_m_ns    = write_addr_sel ? wr_ccp_p2_ns   : evict_ns;
    assign write_addr_m_size  =(write_addr_sel & ~wr_ccp_p2_full) ? wr_ccp_p2_size : 'd\=wCacheLineOffset=\;
    assign write_addr_m_evict = write_addr_sel ? is_cleanflush(ccp_p2_cm_type) : evict_addr_valid;

\js //set evict address vz to 0 : no SMI response required.

    assign \=bundleFunctions.packetizeBundle('write_addr_m_', obj.lib.getParam('writeProtInterface'), ['valid', 'ready', 'addr', 'ns', 'size'], obj.lib.bundle)=\ = write_addr_sel ? \=bundleFunctions.packetizeBundle('wr_ccp_p2_', obj.lib.getParam('writeProtInterface'), ['valid', 'ready', 'addr', 'ns', 'size'], obj.lib.bundle)=\ : 'b0;

    assign evict_addr_ready   = ~write_addr_sel & write_addr_m_ready;
\js // don't put write valid in wr_ccp_p2_ready because creates timing loop, but it is qualified where needed
    assign wr_ccp_p2_ready    =  write_addr_m_ready;

    wire bypass_ccp;
    assign bypass_ccp = wr_op_bypass;

    assign write_data_m_valid = bypass_ccp ? wr_data_valid      : evict_valid;
    assign write_data_m_last  = bypass_ccp ? write_data_s_last  : evict_last;
    assign write_data_m_data  = bypass_ccp ? write_data_s_data  : evict_data;
    assign write_data_m_be    = bypass_ccp ? write_data_s_be    : evict_be;
    assign write_data_m_poison= bypass_ccp ? write_data_s_poison: evict_poison;
\jsbegin
    /* istanbul ignore if env ncore_3p0, ncore_3p2, ncore_3p4 */
    if(obj.lib.getParam('writeDataInterface','user') != 0) {
\jsend
    assign write_data_m_user  = bypass_ccp ? write_data_s_user : evict_user;
\js }

\js // TODO: examine eviction & bypass conflict:
    assign evict_ready        =~bypass_ccp &  write_data_m_ready;

    wire [\=wWays-1=\:0] fill_data_way_enc;

    assign fill_data_way_enc =  \=wWays=\'d0 & {\=wWays=\{fill_data_way_pipe[0]}}
\js for(var i = 1; i< nWays; i++) {
                              |(\=wWays=\'d\=i=\ & {\=wWays=\{fill_data_way_pipe[\=i=\]}})
\js }
;

    // Fill state machine
    wire en_fill_state;
    wire [\=wBeats-1=\:0] fill_beat;
    wire [\=wBeats-1=\:0] fill_beat_q;
    wire tag_fill;
    wire data_fill;
    wire data_fill_last;
    wire [\=wBeats=\:0] fill_beat_dbusy;
    wire fill_dbusy_d;
    wire fill_dbusy;

    \=obj.lib.dffre(wBeats+1, 'fill_beat_dbusy', '{fill_dbusy_d, fill_beat}', '{'+(wBeats+1)+"{1'b0}}", 'en_fill_state', 'clk', 'reset_n')=\

    assign {fill_dbusy, fill_beat_q} = fill_beat_dbusy;
    assign fill_beat     = fill_dbusy ? fill_beat_q + 'b1 : fill_pop_addr[\=wCacheLineOffset-1=\:\=wCacheLineOffset-wBeats=\];
    assign fill_dbusy_d  = (data_fill | fill_dbusy) & ~data_fill_last;
    assign en_fill_state =  data_fill;

    assign tag_fill      = dmi_ccp_ctrl_fill_valid      & dmi_ccp_cache_fill_ready;
    assign data_fill     = dmi_ccp_ctrl_fill_data_valid & dmi_ccp_cache_fill_data_ready;
    assign data_fill_last= data_fill & fill_pop_last;

    assign dmi_ccp_ctrl_fill_valid         = fill_enable & fill_pop_valid & fill_pop_last & ~fill_tag_done & ~scratch_fill;
    assign dmi_ccp_ctrl_fill_address       = fill_pop_addr;
\jsbegin
/* istanbul ignore else env ncore_3p0, ncore_3p2, ncore_3p4 */
    if(wSecurity != 0) {
\jsend
    assign dmi_ccp_ctrl_fill_security      = fill_pop_ns;
\js } else {
    assign dmi_ccp_ctrl_fill_security      = 0;  
\js }

    assign dmi_ccp_ctrl_fill_way_num       = fill_pop_way_num;
    assign dmi_ccp_ctrl_fill_state         = fill_pop_dirty? ST_DIRTY : ST_CLEAN;
\js if(enScratchpadFill) {
    assign dmi_ccp_ctrl_fill_scratchpad    = fill_pop_sp;
\js }
    assign dmi_ccp_ctrl_fill_data_valid    = fill_enable & fill_pop_valid & ~fill_data_done;
    assign dmi_ccp_ctrl_fill_data          = {fill_pop_poison, fill_pop_data};
    assign dmi_ccp_ctrl_fill_data_id       = fill_pop_id;
    assign dmi_ccp_ctrl_fill_data_address  = fill_pop_addr;
    assign dmi_ccp_ctrl_fill_data_way_num  = fill_pop_way_num;
    assign dmi_ccp_ctrl_fill_data_beat_num = fill_beat;
    assign dmi_ccp_ctrl_fill_data_last     = fill_pop_last;
    assign dmi_ccp_ctrl_fill_data_byteen   = {\=(wData/8)=\{1'b1}};

    wire dmi_ccp_cache_nack_ce_p2_d1;
    wire dmi_ccp_cache_nack_ce_p2_d2;
    wire dmi_ccp_ctrl_op_valid_p0_pre;
    // Need to account for the init_done in the ready equation.
    // If still busy with init sequence, then we don't want to send transactions.
    // block the request only if lookupEn = 1 and cahce not init_done yet.
    assign dmi_ccp_block                = ~dmi_ccp_tag_init_done & csr_SMCTCR_LookupEn;
    assign dmi_ccp_ctrl_op_valid_p0     = {\=nTagBanks=\{dmi_ccp_ctrl_op_valid_p0_pre & csr_SMCTCR_LookupEn}} & bank_sel_onehot;
    assign dmi_ccp_ctrl_op_valid_p0_pre = ~evict_addr_valid_q & ~dmi_ccp_block & ccp_p0_valid & ~scratch_p0_valid & ~(dmi_ccp_cache_nack_ce_p2 | dmi_ccp_cache_nack_ce_p2_d1 | dmi_ccp_cache_nack_ce_p2_d2);
\js // TODO: review this, evict_addr_valid shouldn't qualify with scratchpad case
    assign ccp_p0_ready                 = ~evict_addr_valid_q & (scratch_p0_valid ? scratch_p0_ready :
                                                              (|({\=nTagBanks=\{dmi_ccp_ctrl_op_valid_p0_pre}} & bank_sel_onehot & dmi_ccp_cache_op_ready_p0) & ~dmi_ccp_block) & ~(dmi_ccp_cache_nack_ce_p2 | dmi_ccp_cache_nack_ce_p2_d1 | dmi_ccp_cache_nack_ce_p2_d2));

    \=obj.lib.dffre(1, 'dmi_ccp_cache_nack_ce_p2_d1', 'dmi_ccp_cache_nack_ce_p2',   "1'b0", "1'b1", 'clk', 'reset_n')=\
    \=obj.lib.dffre(1, 'dmi_ccp_cache_nack_ce_p2_d2', 'dmi_ccp_cache_nack_ce_p2_d1',"1'b0", "1'b1", 'clk', 'reset_n')=\

    assign dmi_ccp_ctrl_op_address_p0  =ccp_p0_addr;
    assign dmi_ccp_ctrl_op_security_p0 =ccp_p0_ns;

    assign dmi_ccp_tag_uce  = dmi_ccp_uncorrectible_error_valid & (dmi_ccp_uncorrectible_error_type == 'd0);
    assign dmi_ccp_tag_ce   = dmi_ccp_correctible_error_valid & (dmi_ccp_correctible_error_type == 'd0);
     
    assign dmi_ccp_data_uce = dmi_ccp_uncorrectible_error_valid & (dmi_ccp_uncorrectible_error_type == 'd1);
    assign dmi_ccp_data_ce  = dmi_ccp_correctible_error_valid & (dmi_ccp_correctible_error_type == 'd1);

\jsbegin
 var cachePipePorts = {
           write_addr_s_nc_sel:     'write_prot_nc_sel',
           rd_miss_bus_valid:       'read_addr_m_bus_valid',
           rd_miss_fill:            'read_addr_m_fill',
           rd_miss_cm_typeq:        'read_addr_m_cm_type',
           wr_miss_vz_qual:         'wr_ccp_p2_vz',
           wr_miss_full:            'wr_ccp_p2_full',
           wr_miss_sel:             'wr_ccp_p2_sel', 
           read_addr_s_ac:          'read_addr_s_acq',
           write_addr_s_ac:         'write_addr_s_acq',
           write_through:           'write_through',
           new_evict:               'new_evict_addr',  
           ccp_p0_valid:            'ccp_p0_valid',
           ccp_p0_ready:            'ccp_p0_ready',
           ccp_p0_addr:             'ccp_p0_addr',
           ccp_p0_ns:               'ccp_p0_ns',
           ccp_p0_lookup_en:        'csr_SMCTCR_LookupEn',
           ccp_p2_send_opq:         'ccp_p2_send_opq',
           ccp_p2_uce_send_rd_opq:  'ccp_p2_uce_send_rd_opq',
           ccp_p2_uce_send_wr_opq:  'ccp_p2_uce_send_wr_opq',
           ccp_p2_send_miss:        'ccp_p2_send_miss',
           ccp_p2_send_p0:          'ccp_p2_send_p0',
           wr_ccp_p2_drop:          'wr_ccp_p2_drop',
           ccp_p2_hitdirty:         'ccp_p2_hitdirty', 
           ccp_p2_to_replay:        'ccp_p2_to_replay',
           ccp_p2_atomic:           'ccp_p2_atomic',
           ccp_p2_atm_error:        'ccp_p2_atm_error',
           ccp_p2_tag_uce:          'dmi_ccp_cache_nack_uce_p2',
           ccp_p2_mnt:              'ccp_p2_mnt',
           ccp_p2_hit:              'ccp_p2_hit',
           ccp_p2_kill_ac:          'ccp_p2_kill_ac',
           ccp_p2_lookup_en:        'ccp_p2_lookup_en',
           dmi_p2_kill_ac:          'dmi_p2_kill_ac',
           ccp_p2_way:              'ccp_p2_alloc_way',
           ccp_p1_aiu_trans_id:     'ccp_p1_aiu_trans_id',
           ccp_p1_wp_way:           'ccp_p1_wp_way',
           ccp_p2_ways_busy:        'dmi_ccp_ctrl_op_ways_busy_vec_p2',
           ccp_p2_ways_stale:       'dmi_ccp_ctrl_op_ways_stale_vec_p2',
           ccp_op_scratch:          'ccp_op_scratch',
           wtt_dealloc_valid:       'write_resp_m_valid',
           read_alloc_id:           'read_alloc_id',
           read_cam_match_fill:     'read_cam_match_fill',
           rtt_dealloc_id:          'rtt_dealloc_id',
           rtt_dealloc_valid:       'rtt_dealloc_valid',
           rtt_dealloc_vec:         'rtt_dealloc_vec',
           rtt_lookup_id:           'fill_data_id',
           rtt_lookup_way:          'fill_data_way_pipe',
           mntop_active:            'ccp_mntop_active',
           ccp_p1_valid:            'ccp_p1_valid',
	   read_write_addr_s_pop_ready_p1: 'read_write_addr_s_pop_ready_p1',
           ccp_p1_addr:             'ccp_p1_addr',
           scratch_p1_valid:        'scratch_p1_valid',
           cache_pipe_busy:         'cache_pipe_busy',
           ccp_p1_aiu_id:           'ccp_p1_aiu_id',
           ccp_p2_ce_nack:          'dmi_ccp_cache_nack_ce_p2',
           ccp_p2_way_fwd:          'ccp_p2_way_fwd',
           ccp_p1_wp_no_rsvd_way :  'ccp_p1_wp_no_rsvd_way',
	   pmon_cache_replay: 	    'pmon_cache_replay'
           };

if (useScratchpad) {
cachePipePorts['scratch_addr_offset_low'] = 'scratch_offset_low'; 
}

\jsend    
    \=obj.lib.instance({
        instanceName: 'cache_pipe',
        moduleName: 'dmi_cache_pipe',
        params: {
            clkInterface:     obj.lib.getParam('clkInterface'),
            cmType:           cmType,
            addrInterface:    addrInterface,
            writeOpInterface: writeOpInterface,
            readOpInterface:  readOpInterface,
            camAddrInterface: obj.lib.getParam('camAddrInterface'),
            camRttVectorInterface: obj.lib.getParam('camRttVectorInterface'),
            pipeScratchInterface: pipeScratchInterface, 
            scratchOpInterface:   scratchOpInterface, 
            useScratchpad:        useScratchpad,
            nRttCtrlEntries:  obj.lib.getParam('nRttCtrlEntries'),
            wCacheLineOffset: wCacheLineOffset,
            mntOpReqInterface: mntOpReqInterface, 
            wBeats:           wBeats,
            wSets:            wSets,
            nWays:            nWays,
            wData:            wData,
            wDataIndex:       wDataIndex,
            nDataBanks:       nDataBanks,
            DataBankSelBits:  DataBankSelBits,
            wMntOpCode:       wMntOpCode,
            assertOn:         assertOn,
        },
        ports: cachePipePorts,
        interfaces: [
           {modulePrefix: '',        localPrefix: '',        interface: obj.lib.getParam('clkInterface') },
           {modulePrefix: 'read_addr_s_',  localPrefix: 'read_addr_s_',  interface: addrInterface, exclude: ['ac'] },
           {modulePrefix: 'write_addr_s_', localPrefix: 'write_addr_s_', interface: addrInterface, exclude: ['ac'] },
           {modulePrefix: 'ccp_p2_', localPrefix: 'ccp_p2_', interface: addrInterface},
           {modulePrefix: 'ccp_op_', localPrefix: 'ccp_op_', interface: readOpInterface},
           {modulePrefix: 'wr_op_',  localPrefix: 'wr_op_',  interface: writeOpInterface},
           {modulePrefix: 'read_cam_',  localPrefix: 'read_cam_',  interface: obj.lib.getParam('camAddrInterface')},
           {modulePrefix: 'rtt_cam_',   localPrefix:  'rtt_cam_',  interface: obj.lib.getParam('camRttVectorInterface')},
           {modulePrefix: 'write_cam_', localPrefix: 'write_cam_', interface: obj.lib.getParam('camAddrInterface')},
           {modulePrefix: '', localPrefix: '', interface: pipeScratchInterface},
           {modulePrefix: 'pipe_', localPrefix: 'pipe_', interface: scratchOpInterface},
           {modulePrefix: 'rd_miss_', localPrefix: 'read_addr_m_', interface: addrInterface, exclude: ['cm_type']},
           {modulePrefix: 'wr_miss_', localPrefix: 'wr_ccp_p2_', interface: addrInterface, exclude: ['vz']},
           {modulePrefix: '', localPrefix: '', interface: mntOpReqInterface},
           {modulePrefix: 'ccp_p2_', localPrefix: 'ccp_p2_', interface: mntOpReqInterface, exclude: ['mnt_op_req_valid', 'mnt_op_req_ready']}
        ],
        portsDelimiter: '\n        '
    })=\

    assign ccp_p2_ready       = 1'b1;

    // this signal needed by tb to figure out hint dropped in p2
    wire   ccp_p2_drop_hint   = (ccp_p2_cm_type == HN_READ) & ccp_p2_valid & ccp_p2_kill_ac;

    assign ccp_p2_drop        = 0; //(ccp_p2_cm_type == HN_READ &
                                  //(~ccp_p2_ac | ccp_p2_hit | ccp_p2_kill_ac | dmi_ccp_cache_nack_p2 | dmi_ccp_cache_nack_uce_p2));
    assign dmi_cache_valid_p2 = ccp_p2_valid & ~scratch_p2_valid;
    assign op_done_p2         = (dmi_cache_valid_p2 & ~dmi_cancel_p2 & ~ccp_p2_to_replay &
                              ((is_cleanflush(ccp_p2_cm_type) & (dmi_ccp_cache_current_state_p2 != ST_DIRTY)) |
                                (ccp_p2_cm_type == NC_MKINV) |
                                (ccp_p2_cm_type == RD_INV)   |
                              (((ccp_p2_cm_type == NC_PREF)  |
                                (ccp_p2_cm_type == RD_PREF)) & (dmi_ccp_ctrl_op_hit_p2 | ~ccp_p2_ac)))) | 
                                ccp_p2_atm_error |
                                scratch_done_p2;

    // cacheop done if going to scratchpad or all ways dedicated to scratchpad
    assign scratch_done_p2    = is_cacheop(ccp_p2_cm_type) & (scratch_p2_valid | (ccp_p2_valid & (&scratch_ways)))  & ~ccp_p2_to_replay;

    assign ccp_p2_hit         = dmi_ccp_ctrl_op_hit_p2 | scratch_p2_valid;
    assign ccp_p2_hitdirty    = dmi_ccp_ctrl_op_hit_p2 & (dmi_ccp_cache_current_state_p2 == ST_DIRTY);
\jsbegin
    // send to opq to generate dummy DTR upon tag UCE if return data is required
    // atomic load type,
    // read,
    // dtwMrgMrd
\jsend
    assign ccp_p2_send_opq    = ((ccp_p2_hit & ~is_cacheop(ccp_p2_cm_type)                      | 
                                  op_done_p2 & ccp_p2_vz                                        | 
                                  write_miss & ~dtwmergemrd_fill & ~(ccp_p2_cm_type == WM_RUDTY)| 
                                  dmi_cache_valid_p2 & ccp_p2_atomic) & 
                                 ~ccp_p2_to_replay & ~ccp_p2_send_p0 & ~dmi_ccp_cache_nack_ce_p2 & (~dmi_ccp_cache_nack_p2 | wr_ccp_p2_drop) & ~mnt_req_valid_p2 & ~dmi_ccp_cache_nack_uce_p2);

    assign ccp_p2_send_miss   = ((dmi_ccp_ctrl_op_miss_p2 & ~write_miss_ac & ~wr_ccp_p2_drop) |
                                  hit_evict_flush | (write_bypass & ~dtwmergemrd_hit & ~scratch_p2_valid) | ccp_p2_atomic) &
                                 ~op_done_p2 & ~ccp_p2_to_replay & ~ccp_p2_send_p0 & ~mnt_req_valid_p2 & ~dmi_ccp_cache_nack_ce_p2 & ~dmi_ccp_cache_nack_uce_p2 & ~dmi_ccp_cache_nack_p2;

    assign ccp_p2_send_p0     =  dmi_cache_valid_p2 & dmi_ccp_cache_nack_p2 & ~ccp_p2_drop & ~ccp_p2_to_replay & ~wr_ccp_p2_drop & ~scratch_p2_valid & ~dmi_ccp_cache_nack_ce_p2;

\js // assume debug rd/wr will never get a nack_p2

    // force this to 0 if not allocating, because it's used in the equation to forward way busy
    // also if atomic hit then use the hit way because it keeps the way reserved in rtt during atomic
    assign ccp_p2_alloc_way   = scratch_p2_valid ? scratch_way_p2 : 
                                (ccp_p2_atomic ?
                                (dmi_ccp_ctrl_op_hit_p2 ? dmi_ccp_cache_hit_way_vec_p2
                                                        : dmi_ccp_cache_alloc_way_vec_p2) :
                                (dmi_ccp_ctrl_op_allocate_p2 & ~dmi_ccp_cache_nack_no_allocate_p2 & ~dmi_p2_kill_ac)
                                                        ? dmi_ccp_cache_alloc_way_vec_p2 : 'b0); 

    wire policy_ac_rd;
    wire policy_ac_wr;
    wire policy_ac_dty;
    wire policy_ac_cln;
    wire main_rd_ac_en;
    wire write_through_wrap;
    //
    // AC Policy control
    //
    assign policy_ac_rd  = ~csr_SMCAPR_Rd_Alloc;
    assign policy_ac_wr  = ~csr_SMCAPR_Wr_Alloc;
    assign policy_ac_dty = ~csr_SMCAPR_DtyWr_Alloc;
    assign policy_ac_cln = ~csr_SMCAPR_ClnWr_Alloc;

    assign main_rd_ac_en = csr_SMCTCR_LookupEn & csr_SMCTCR_AllocEn & read_addr_s_ac;
    assign read_addr_s_acq    = (main_rd_ac_en  &  (read_addr_s_size == \=wCacheLineOffset=\) & policy_ac_rd &
                                                   (read_addr_s_cm_type == NC_CMDRD |
                                                    read_addr_s_cm_type == RD_WSCLN |
                                                    read_addr_s_cm_type == RD_WUCLN |
                                                    read_addr_s_cm_type == RD_WINV))|
                                (main_rd_ac_en  &  (read_addr_s_cm_type == NC_PREF  |
                                                    read_addr_s_cm_type == RD_PREF));
    assign main_wr_ac_en = csr_SMCTCR_LookupEn & csr_SMCTCR_AllocEn & ~scratch_wr_kill_ac;
    assign write_addr_s_acq   = main_wr_ac_en   & ((write_addr_s_cm_type == WR_DIRTY & write_addr_s_ac & policy_ac_wr & policy_ac_dty & ~write_addr_s_vz) |
                                                   (write_addr_s_cm_type == WR_CLEAN & write_addr_s_ac & policy_ac_wr & policy_ac_cln) | 
                                                    is_atomic(write_addr_s_cm_type) |
                                                   (is_dtwmergemrd(write_addr_s_cm_type) & write_addr_s_ac & policy_ac_rd & ~(write_addr_s_cm_type == WM_RUDTY)));

    assign dmi_ccp_ctrl_op_hit_p2  = dmi_cache_valid_p2 & |dmi_ccp_cache_hit_way_vec_p2 & ccp_p2_lookup_en;
    assign dmi_ccp_ctrl_op_miss_p2 = dmi_cache_valid_p2 & ~dmi_ccp_ctrl_op_hit_p2;

    // ccp only ignores some signals with nack, make it consistent by cancelling all ctrl in p2
    assign dmi_cancel_p2 = dmi_ccp_cache_nack_uce_p2 | dmi_ccp_cache_nack_ce_p2 | dmi_ccp_cache_nack_p2 | ccp_p2_to_replay | scratch_p2_valid;
    assign dmi_ccp_ctrl_op_allocate_p2 = dmi_ccp_ctrl_op_miss_p2 & ccp_p2_ac & ~dmi_cancel_p2 & ~ccp_p2_mnt &
                      ~ccp_p2_kill_ac & 
                      (ccp_p2_cm_type == RD_WSCLN |
                       ccp_p2_cm_type == RD_WUCLN |
                       ccp_p2_cm_type == RD_WINV  |
                       ccp_p2_cm_type == NC_CMDRD |
//                       ccp_p2_cm_type == HN_READ  |
                       ccp_p2_cm_type == NC_PREF  |
                       ccp_p2_cm_type == RD_PREF  |
                       ccp_p2_cm_type == WM_INV   |
//                       ccp_p2_cm_type == WM_RSCLN |
//                       ccp_p2_cm_type == WM_RSDTY |
                       ccp_p2_cm_type == WM_RUCLN |
                       ccp_p2_cm_type == WR_CLEAN |
                      (ccp_p2_cm_type == WR_DIRTY & ~ccp_p2_vz) | 
                       is_atomic(ccp_p2_cm_type));


\js if ( useWayPartitioning ) {
    \=obj.lib.dffre(1, 'ccp_p2_wp_no_rsvd_way', 'ccp_p1_wp_no_rsvd_way', "1'b0", "1'b1", 'clk', 'reset_n')=\    
\js } else {
    assign ccp_p2_wp_no_rsvd_way = 1'b0;
\js }

    assign ccp_p2_kill_ac = (dmi_ccp_cache_nack_no_allocate_p2 |
                             ccp_p2_wp_no_rsvd_way             |
                             dmi_p2_kill_ac                     ) & ~ccp_p2_to_replay;

    assign ccp_p2_rd =~ccp_p2_mnt &
                      (ccp_p2_cm_type == RD_WSCLN |
                       ccp_p2_cm_type == RD_WUCLN |
                       ccp_p2_cm_type == RD_WUNIQ |
                       ccp_p2_cm_type == RD_WINV  |
                       ccp_p2_cm_type == NC_CMDRD |
                       ccp_p2_atomic)             ;

    assign ccp_p2_uce_send_rd_opq = ~ccp_p2_mnt &
                      (ccp_p2_cm_type == RD_WSCLN |
                       ccp_p2_cm_type == RD_WUCLN |
                       ccp_p2_cm_type == RD_WUNIQ |
                       ccp_p2_cm_type == RD_WINV  |
                       ccp_p2_cm_type == NC_CMDRD |
                       ccp_p2_cm_type == RD_ATM   |
                       ccp_p2_cm_type == CM_ATM   |
                       ccp_p2_cm_type == SW_ATM   |
                       ccp_p2_cm_type == WM_RUCLN |
                       ccp_p2_cm_type == WM_RUDTY)&
                       dmi_ccp_cache_nack_uce_p2;

    assign ccp_p2_uce_send_wr_opq = ~ccp_p2_mnt &
                      (ccp_p2_cm_type == RD_ATM   |
                       ccp_p2_cm_type == CM_ATM   |
                       ccp_p2_cm_type == SW_ATM   |
                       ccp_p2_cm_type == WR_CLEAN |
                       ccp_p2_cm_type == WR_DIRTY |
                       ccp_p2_cm_type == WR_PARTL |
                       ccp_p2_cm_type == WM_INV   |
                       ccp_p2_cm_type == WM_RUCLN |
                       ccp_p2_cm_type == WM_RUDTY |
                       (is_cacheop(ccp_p2_cm_type) & ccp_p2_vz))&
                       dmi_ccp_cache_nack_uce_p2;

    assign ccp_p2_wr = ccp_p2_valid & ~ccp_p2_to_replay & ~ccp_p2_mnt &
                       (ccp_p2_cm_type == WR_CLEAN |
                        ccp_p2_cm_type == WR_DIRTY |
                        ccp_p2_cm_type == WR_PARTL |
                        ccp_p2_cm_type == WM_INV   |
//                        ccp_p2_cm_type == WM_RSCLN |
//                        ccp_p2_cm_type == WM_RSDTY |
                        ccp_p2_cm_type == WM_RUCLN |
                        ccp_p2_cm_type == WM_RUDTY);

    assign ccp_p2_unlock    = is_dtwmergemrd(ccp_p2_cm_type) & ccp_p2_valid &
                              (ccp_p2_hit | dtwmergemrd_fill | (~ccp_p2_hit & ccp_p2_cm_type == WM_RUDTY) | dmi_ccp_cache_nack_uce_p2) & 
                              ~(dmi_ccp_cache_nack_ce_p2 | dmi_ccp_cache_nack_p2 | ccp_p2_to_replay);

    assign ccp_p2_cmo = (ccp_p2_cm_type == NC_FLUSH |
                        ccp_p2_cm_type == NC_MKINV |  ccp_p2_cm_type == RD_INV |  			ccp_p2_cm_type == RD_CLEAN | ccp_p2_cm_type == RD_FLUSH 			| ccp_p2_cm_type == NC_PRSST | ccp_p2_cm_type == NC_CLEAN ) ;


    // Need to enable read for read hit or miss allocate
    assign dmi_ccp_ctrl_op_read_data_p2  = ~dmi_cancel_p2 & (hit_evict_flush            |
                                            (dmi_ccp_ctrl_op_hit_p2 & ccp_p2_rd)        |
                                            (dmi_ccp_ctrl_op_miss_p2 & new_evict_read)  |
                                            hit_dirty_mntop_flush                       );
    assign dmi_ccp_ctrl_op_write_data_p2 = ((dmi_ccp_ctrl_op_hit_p2 &  ccp_p2_wr & ~wr_ccp_p2_drop) | write_miss_ac) &
                                           ~dmi_cancel_p2;
    assign dmi_ccp_ctrl_op_bypass_p2     = ~dmi_cancel_p2 & write_bypass & ~(ccp_p2_cm_type == WM_RUDTY & ~ccp_p2_hit);
    assign dmi_ccp_ctrl_op_port_sel_p2   = (write_bypass & ~dtwmergemrd_hit) | hit_evict_flush | hit_dirty_mntop_flush;
    assign dmi_ccp_ctrl_op_rp_update_p2  = ~dmi_cancel_p2 & ~ccp_p2_mnt & (write_miss_ac |
                                           (dmi_ccp_ctrl_op_hit_p2 & ~update_to_inval & ~is_cleanflush(ccp_p2_cm_type)));

    // write through case of small size may wrap in weird way for AXI,
    // need to increase it to full cacheline due to conc-4346, conc-4345
    // This happens any time it is less than full cacheline and
    // start address is not aligned to size
    assign write_through_wrap = write_through & (ccp_p2_size < 'd\=wCacheLineOffset=\) &
                                |(ccp_p2_addr[\=wCacheLineOffset-1=\:0] & ({\=wCacheLineOffset=\{1'b1}} << \=wCacheLineOffset=\'d\=wCacheLineOffset-wBeats=\) &
                                   ((\=wCacheLineOffset=\'b1 << ccp_p2_size) - 'b1));

    wire [\=wBeats-1=\:0] burst_len_p2;
    assign burst_len_p2                  = (ccp_p2_size == \=wCacheLineOffset=\) ? {\=wBeats=\{1'b1}} :
                                           (ccp_p2_size >  \=Math.log2(wData/8)=\) ? (\=wBeats=\'b1 << (ccp_p2_size - \=Math.log2(wData/8)=\) - \=wBeats=\'b1)
                                                              : \=wBeats=\'b0;
    assign dmi_ccp_ctrl_op_burst_len_p2  = (hit_evict_flush | write_miss_ac | write_through_wrap | hit_dirty_mntop_flush) ? ~\=wBeats=\'b0 :
                                           (ccp_p2_cm_type == CM_ATM) ? burst_len_p2 >> \=wBeats=\'b1
                                                                      : burst_len_p2;


    assign dmi_ccp_ctrl_op_burst_wrap_p2 = 1'b1;
                                                                      

    assign update_to_inval =  (ccp_p2_cm_type == RD_INV)   |
                              (ccp_p2_cm_type == NC_MKINV) |
                              (ccp_p2_cm_type == RD_FLUSH) |
                              (ccp_p2_cm_type == NC_FLUSH) |
                              (ccp_p2_cm_type == WM_RUDTY) ;
                              
    assign update_to_clean =  (dmi_ccp_cache_current_state_p2 == ST_DIRTY) &
                              (ccp_p2_cm_type == RD_CLEAN |
                               ccp_p2_cm_type == NC_CLEAN |
                               ccp_p2_cm_type == NC_PRSST |
                              (ccp_p2_vz & ((ccp_p2_cm_type == WR_PARTL) | (ccp_p2_cm_type == WR_DIRTY))));
    assign update_to_dirty = (dmi_ccp_cache_current_state_p2 == ST_CLEAN) &
                            ((~ccp_p2_vz & ((ccp_p2_cm_type == WR_PARTL) | (ccp_p2_cm_type == WR_DIRTY))) |
                              (ccp_p2_cm_type == WM_INV  ) |
//                              (ccp_p2_cm_type == WM_RSCLN) |
                              (ccp_p2_cm_type == WM_RUCLN));
    assign dmi_ccp_ctrl_op_tag_state_update_p2 = ~dmi_cancel_p2 &
                                                 (write_miss_ac | 
                                                  (dmi_ccp_ctrl_op_hit_p2 & (update_to_inval | update_to_clean | update_to_dirty)) | 
                                                   mnt_req_valid_flush_p2);
    assign dmi_ccp_ctrl_op_state_p2 = (mnt_req_valid_p2 & mntop_flush_p2)   ? ST_INVAL : 
                                      (update_to_clean | write_miss_ac_cln) ? ST_CLEAN :
                                      (update_to_dirty | write_miss_ac_dty) ? ST_DIRTY :
                                                                              ST_INVAL;


    assign dmi_ccp_ctrl_op_setway_debug_p2 = (mntop_flush_all_entries_p2                |
                                              mntop_flush_entry_by_indexway_p2          |
                                              mntop_flush_entry_by_indexway_range_p2    | 
                                              mntop_read_tag_entry_by_indexwayword_p2   |
                                              mntop_read_data_entry_by_indexwayword_p2  |
                                              mntop_write_tag_entry_by_indexwayword_p2  |
                                              mntop_write_data_entry_by_indexwayword_p2
                                             ) & mnt_req_valid_p2;

    assign dmi_ccp_ctrl_op_setway_debug_p2_org = (mntop_flush_all_entries_p2                |
                                                  mntop_flush_entry_by_indexway_p2          |
                                                  mntop_flush_entry_by_address_p2           |
                                                  mntop_flush_entry_by_address_range_p2     |
                                                  mntop_flush_entry_by_indexway_range_p2    |
                                                  mntop_read_tag_entry_by_indexwayword_p2   |
                                                  mntop_read_data_entry_by_indexwayword_p2  |
                                                  mntop_write_tag_entry_by_indexwayword_p2  |
                                                  mntop_write_data_entry_by_indexwayword_p2
                                                 ) & mnt_req_valid_p2;

    assign mntop_init_all_entries_p2                 = (ccp_p2_mnt_op_req_msg[3:0] == 4'b0000);
    assign mntop_flush_all_entries_p2                = (ccp_p2_mnt_op_req_msg[3:0] == 4'b0100);
    assign mntop_flush_entry_by_indexway_p2          = (ccp_p2_mnt_op_req_msg[3:0] == 4'b0101);
    assign mntop_flush_entry_by_address_p2           = (ccp_p2_mnt_op_req_msg[3:0] == 4'b0110);
    assign mntop_flush_entry_by_address_range_p2     = (ccp_p2_mnt_op_req_msg[3:0] == 4'b0111);
    assign mntop_flush_entry_by_indexway_range_p2    = (ccp_p2_mnt_op_req_msg[3:0] == 4'b1000);
    assign mntop_read_tag_entry_by_indexwayword_p2   = (ccp_p2_mnt_op_req_msg[3:0] == 4'b1100) & ~ccp_p2_mnt_op_req_msg[4];
    assign mntop_write_tag_entry_by_indexwayword_p2  = (ccp_p2_mnt_op_req_msg[3:0] == 4'b1110) & ~ccp_p2_mnt_op_req_msg[4];
    assign mntop_read_data_entry_by_indexwayword_p2  = (ccp_p2_mnt_op_req_msg[3:0] == 4'b1100) &  ccp_p2_mnt_op_req_msg[4];
    assign mntop_write_data_entry_by_indexwayword_p2 = (ccp_p2_mnt_op_req_msg[3:0] == 4'b1110) &  ccp_p2_mnt_op_req_msg[4];

\jsbegin
var wReturnDataPkt = bundleFunctions.getBundleWidth(returnDataInterface, ['valid', 'ready', 'last'], obj.lib.bundle);

var readDataMuxarbParams = {
    number_of_inputs: 2,
    width           : wReturnDataPkt,
    sink_type       : 'RdyVld',
    pipeline        : 0,
    arb_priority    : 'RoundRobin',
    sfi_compliant   : 1,
    output_grant    : 0
};

var readDataMuxarbPorts = {
    sink0_valid     : 'read_data_m_valid',
    sink0_ready     : 'read_data_m_ready',
    sink0_last      : 'read_data_m_last',
    sink0_data      : 'read_data_m_pkt',
    sink1_valid     : 'read_hit_valid',
    sink1_ready     : 'read_hit_ready',
    sink1_last      : 'read_hit_last',
    sink1_data      : 'read_hit_pkt',
    source_valid    : 'read_data_s_valid', 
    source_ready    : 'read_data_s_ready',
    source_last     : 'read_data_s_last',
    source_data     : 'read_data_s_pkt'
};

var readDataMuxarbInterfaces = [];
readDataMuxarbInterfaces.push({modulePrefix: '', localPrefix: '', interface: obj.lib.getParam('clkInterface')});

\jsend
    wire [\=wReturnDataPkt-1=\:0] read_data_m_pkt;
    wire [\=wReturnDataPkt-1=\:0] read_hit_pkt;
    wire [\=wReturnDataPkt-1=\:0] read_data_s_pkt;


    assign read_data_m_pkt  = \=bundleFunctions.packetizeBundle('read_data_m_',     returnDataInterface, ['valid', 'ready', 'last'], obj.lib.bundle)=\;
    assign read_hit_pkt     = \=bundleFunctions.packetizeBundle('read_hit_',        returnDataInterface, ['valid', 'ready', 'last'], obj.lib.bundle)=\;

    assign \=bundleFunctions.packetizeBundle('read_data_s_', returnDataInterface, ['valid', 'ready', 'last'], obj.lib.bundle)=\ = read_data_s_pkt;


    \=obj.lib.instance({
        instanceName    : 'read_data_muxarb',
        moduleName      : 'muxarb',
        params          : readDataMuxarbParams,
        ports           : readDataMuxarbPorts,
        interfaces      : readDataMuxarbInterfaces
    })=\

    assign read_hit_push_size     = is_dtwmergemrd(ccp_op_cm_type)? \=wSize=\'h\=wCacheLineOffset=\ : (ccp_op_cm_type == CM_ATM)? (ccp_op_size-1) : ccp_op_size;
    assign ccp_op_rd_type         =~is_dtwmergemrd(ccp_op_cm_type);
    assign read_hit_push_trans_id = is_dtwmergemrd(ccp_op_cm_type) ? ccp_op_trans_id : ccp_op_late_resp_id;
\jsbegin
    // Hit buffer
    // Need this buffer to prevent deadlock when doing fill and hit read at same time.
    // This lets the cache read complete even if the fill miss is blocking the return data mux.
    // push manufactured size of data for tag error
    // exclude for atomics store. Atomic load should carry the right trans size.

var readHitBufferPorts = {
           push_valid       : 'read_hit_push_valid',
           push_ready       : 'read_hit_push_ready',
           push_id          : '{'+obj.lib.getParam('returnDataInterface', 'id')+'{1\'b0}}',
           push_last        : 'read_hit_push_last',
           push_first       : 'q_hit_data_first',
           push_target_id   : 'ccp_op_aiu_id',
           push_r_message_id: 'ccp_op_aiu_trans_id',
           push_trans_id    : 'read_hit_push_trans_id',
           push_vz          : 'ccp_op_vz',
           push_cm_type     : 'read_hit_push_cm_type',
           push_exokay      : "1'b0",
           push_data        : 'read_hit_push_data',
           push_poison      : 'read_hit_push_poison',
           push_err_type    : 'read_hit_push_err_type',
           push_dwid        : 'ccp_op_dwid',
           push_cdw         : 'ccp_op_cdw',
           push_size        : 'read_hit_push_size',
           push_intf_size   : 'ccp_op_intf_size',
           push_mpf1        : '{'+obj.lib.getParam('returnDataInterface', 'mpf1')+'{1\'b0}}',
           push_tm          : 'ccp_op_tm',
           push_rd_type     : 'ccp_op_rd_type'
};


if (wQos != 0) {
readHitBufferPorts['push_qos'] = 'ccp_op_qos';
}

if (wRdUser != 0) {
readHitBufferPorts['push_user'] = 'ccp_op_user'; 
}
\jsend



    \=obj.lib.instance({
        instanceName: 'read_hit',
        moduleName: 'fifo_bundle',
        params: {
            width: bundleFunctions.getBundleWidth(obj.lib.getParam('returnDataInterface'), ['valid', 'ready'], obj.lib.bundle),
            depth: nBeats,
            zerodepth: 0,
            bypass_mode: 0,
            interface: obj.lib.getParam('returnDataInterface')
        },
        verilogParams: {},
        ports: readHitBufferPorts,
        interfaces: [
           {modulePrefix: '', localPrefix: '', interface: obj.lib.getParam('clkInterface')},
           {modulePrefix: 'pop_', localPrefix: 'read_hit_', interface: obj.lib.getParam('returnDataInterface')}],
        portsDelimiter: '\n        '
    })=\

\js // err_type: 
\js // 2'b00: No Error
\js // 2'b01: Data Error
\js // 2'b10: Non-data error
    assign read_hit_push_cm_type    = return_type(ccp_op_cm_type, ccp_op_hitdirty);
    assign read_hit_push_err_type   = op_needs_manufac_beat ? 2'b10 : read_rdrsp_poison? 2'b01 : 2'b00; 
    assign read_hit_push_poison     = op_needs_manufac_beat ? 1'b1  : read_rdrsp_poison;
    assign read_hit_push_data       = op_needs_manufac_beat ? \=wData=\'b0 : read_rdrsp_data;

    assign read_hit_sent_in =~(read_rdrsp_ready & read_rdrsp_valid | op_needs_manufac_beat);
    assign read_hit_sent_en = (read_rdrsp_ready & read_rdrsp_valid) | (read_hit_push_ready & read_hit_push_valid);

\js // atomics str not going to return dtr.
    assign read_hit_push_valid      = op_needs_manufac_beat ? (manufac_beat_downcnt != \=wBeats+1=\'b0) & ~is_atomic_str(ccp_op_cm_type) 
                                                            : (~is_atomic_str(ccp_op_cm_type) & read_rdrsp_valid & ~read_hit_sent);
    assign read_hit_push_last       = op_needs_manufac_beat ? (manufac_beat_downcnt == \=wBeats+1=\'d1) 
                                                            : read_rdrsp_last;
    assign manufac_beat_num         = (read_hit_push_size > \=Math.log2(wData/8)=\)? (\=wBeats+1=\'d1 << (read_hit_push_size -\=Math.log2(wData/8)=\)) 
                                                                            :  \=wBeats+1=\'d1;
    assign op_needs_manufac_beat    = ccp_op_valid & ccp_op_scratch? 1'b0 : ccp_op_valid & ccp_op_tag_uce;
    assign manufac_beat_downcnt     =~op_needs_manufac_beat ? \=wBeats+1=\'b0 : 
                                                              q_hit_data_first ? manufac_beat_num : q_manufac_beat_downcnt;
    assign d_manufac_beat_downcnt   = manufac_beat_downcnt - \=wBeats+1=\'d1; 
    assign en_manufac_beat_downcnt  = op_needs_manufac_beat & read_hit_push_valid & read_hit_push_ready;

    assign dwid_en = read_hit_push_valid & read_hit_push_ready;
    assign dw_mask = {\=wDwid=\{1'b1}} << \=Math.log2(dwsPerBeat)=\;

    assign atm_error_valid = ccp_p2_valid && ccp_p2_atm_error; 
    assign atm_error_source_id = ccp_p1_aiu_id[\=addrInterface['aiu_id']-1=\:\=wFPortId=\];
    assign atm_error_addr  = ccp_p2_addr; 
\jsbegin
/* istanbul ignore if env ncore_3p0, ncore_3p2, ncore_3p4 */
    if(dwsPerBeat == 1) {
\jsend
    assign ccp_op_dwid = beat_first_dw;
\js }
\js if(dwsPerBeat == 2) {
    assign ccp_op_dwid = {(beat_first_dw+\=wDwid=\'d1) , beat_first_dw};
\js }
\js if(dwsPerBeat == 4) {
    assign ccp_op_dwid = {(beat_first_dw+\=wDwid=\'d3), (beat_first_dw+\=wDwid=\'d2), (beat_first_dw+\=wDwid=\'d1) , beat_first_dw};
\js } 
    assign next_dwid            = (q_dwid + \=dwsPerBeat=\);
    assign trans_size_dw        = (\=wDwid=\'b1 << (read_hit_push_size-3));
    assign dwid_wrap_boundary   = size_aligned_dwid + trans_size_dw;
    assign size_aligned_dwid    = ccp_op_cdw & ~(trans_size_dw - 1);
    assign beat_first_dw        = q_hit_data_first ? (ccp_op_cdw & dw_mask) 
                                                   : ((next_dwid == dwid_wrap_boundary) ? size_aligned_dwid
                                                                                        : next_dwid);
    assign d_hit_data_first     = dwid_en & read_hit_push_last;
    assign en_hit_data_first    = dwid_en;

    \=obj.lib.dffre(1,          'read_hit_sent',            'read_hit_sent_in',         "1'b0",             'read_hit_sent_en',         'clk', 'reset_n')=\
    \=obj.lib.dffre(wBeats+1,   'q_manufac_beat_downcnt',   'd_manufac_beat_downcnt',   (wBeats+1)+"'d0",   'en_manufac_beat_downcnt',  'clk', 'reset_n')=\
    \=obj.lib.dffre(wDwid,      'q_dwid',                   'beat_first_dw',            '{'+wDwid+"{1'b0}}",'dwid_en',                  'clk', 'reset_n')=\
    \=obj.lib.dffre(1,          'q_hit_data_first',         'd_hit_data_first',         "1'b1",             'en_hit_data_first',        'clk', 'reset_n')=\      

\js // Save mpf1 from write data buffer if it's a late response dtwmergemrd.
\js // mpf1 contains ptr to late response info that's returned with return data

\jsbegin
var wTransId=obj.lib.getParam('returnDataInterface', 'trans_id');
var wMpf1=obj.lib.getParam('returnDataInterface', 'mpf1');
if ( wTransId> wMpf1){
    var write_data_s_mpf1 = "{"+(wTransId-wMpf1-1)+"'d0,write_data_s_mpf1}";

}else {
    var write_data_s_mpf1="write_data_s_mpf1["+(wTransId-1)+":0]";
}
\jsend


    \=obj.lib.instance({
        instanceName: 'trans_id_fifo',
        moduleName: 'fifo',
        params: {
            width: obj.lib.getParam('returnDataInterface', 'trans_id'),
            depth: 2,
            zerodepth: 0,
            bypass_mode: 1
        },
        interfaces: [{ modulePrefix: '', localPrefix: '', interface: obj.lib.getParam('clkInterface') }],
        ports: {
            push_valid: 'push_trans_cache_id_valid',
            push_ready: 'push_trans_cache_id_ready',
            push_data:  write_data_s_mpf1,
            pop_valid:  'pop_trans_cache_id_valid',
            pop_ready:  'pop_trans_cache_id_ready',
            pop_data:   'ccp_op_cache_trans_id'
        },
        portsDelimiter: '\n        '
    })=\

\jsbegin
if (useScratchpad) {
\jsend

\=obj.lib.instance({
    instanceName: 'sp_trans_id_fifo',
    moduleName: 'fifo',
    params: {
        width: obj.lib.getParam('returnDataInterface', 'trans_id'),
        depth: 2,
        zerodepth: 0,
        bypass_mode: 1
    },
    interfaces: [{ modulePrefix: '', localPrefix: '', interface: obj.lib.getParam('clkInterface') }],
    ports: {
        push_valid: 'push_trans_sp_id_valid',
        push_ready: 'push_trans_sp_id_ready',
        push_data:  write_data_s_mpf1,
        pop_valid:  'pop_trans_sp_id_valid',
        pop_ready:  'pop_trans_sp_id_ready',
        pop_data:   'ccp_op_sp_trans_id'
    },
    portsDelimiter: '\n        '
})=\

assign pop_trans_sp_id_ready = read_hit_push_valid & read_hit_push_ready & read_rdrsp_last & ccp_op_vz & is_dtwmergemrd(ccp_op_cm_type) & ccp_op_scratch;

assign push_trans_sp_id_valid= wr_op_vdata & wr_op_vz & wr_op_dtwmergemrd & wr_op_scratch &
                            write_data_s_valid & write_data_s_ready & ~write_data_s_busy 
                            ;

assign push_trans_cache_id_valid= wr_op_vdata & wr_op_vz & wr_op_dtwmergemrd & ~wr_op_scratch & 
                            write_data_s_valid & write_data_s_ready & ~write_data_s_busy 
                            ;
assign pop_trans_cache_id_ready = read_hit_push_valid & read_hit_push_ready & read_rdrsp_last & ccp_op_vz & is_dtwmergemrd(ccp_op_cm_type) & ~ccp_op_scratch;

assign ccp_op_trans_id = ccp_op_scratch ? ccp_op_sp_trans_id:ccp_op_cache_trans_id;

assign pop_trans_id_valid = ccp_op_scratch ? pop_trans_sp_id_valid : pop_trans_cache_id_valid;

assign wr_op_block_merge  = wr_op_dtwmergemrd & wr_op_vz & (~push_trans_cache_id_ready & ~wr_op_scratch | ~push_trans_sp_id_ready & wr_op_scratch) ;

\jsbegin
}
else {
\jsend

assign ccp_op_trans_id = ccp_op_cache_trans_id ;

assign push_trans_cache_id_valid= wr_op_vdata & wr_op_vz & wr_op_dtwmergemrd &
                                    write_data_s_valid & write_data_s_ready & ~write_data_s_busy;

assign pop_trans_cache_id_ready = read_hit_push_valid & read_hit_push_ready & read_rdrsp_last & ccp_op_vz & is_dtwmergemrd(ccp_op_cm_type);

assign wr_op_block_merge  = wr_op_dtwmergemrd & wr_op_vz & ~push_trans_id_ready;
assign pop_trans_id_valid = pop_trans_cache_id_valid;
assign push_trans_id_ready = push_trans_cache_id_ready;

\jsbegin
}
\jsend

    \=obj.lib.dffre(1, 'write_data_s_busy', '~write_data_s_last', "1'b0", 'write_data_go', 'clk', 'reset_n')=\

    assign write_data_go = write_data_s_valid & write_data_s_ready;

\js // Steer the read hit data to atomic_rd port for atomics
\js // Don't need a deep fifo here, because atomics only read one beat
\js // make these optional
    assign ccp_op_atomic                    =  is_atomic(ccp_op_cm_type) & ccp_op_valid;


\js if ( useAtomic ) {
    wire                        atomic_hit_push_valid;
    wire                        atomic_hit_push_ready;
    wire                        atomic_hit_sent_en;
    wire                        atomic_hit_sent_in;
    wire                        atomic_hit_sent;
    wire                        atomic_hit_push_last;
    wire [1:0]                  atomic_hit_push_err_type; 
    wire                        atomic_hit_push_poison;
    wire [\=wData-1=\:0]        atomic_hit_push_data;

\js // reusing first field in fifo for scratchpad signal
    assign atomic_rd_first = 1'b1;
\js // no need to send dummy beat to atomic engine upon tag uce since allocation will be automatically cancelled.
    assign atomic_hit_push_valid            =  ccp_op_atomic & read_rdrsp_valid & ~atomic_hit_sent;
\js // 0 for data error, 1 for address error
    assign atomic_hit_push_err_type         =  read_rdrsp_poison? 2'b01 : 2'b00;
    assign atomic_hit_push_poison           =  read_rdrsp_poison;
    assign atomic_hit_push_last             =  read_rdrsp_last;
    assign atomic_hit_sent_in               =~(read_rdrsp_ready & read_rdrsp_valid);
    assign atomic_hit_sent_en               = (read_rdrsp_ready & read_rdrsp_valid) | (atomic_hit_push_ready & atomic_hit_push_valid); 
    assign atomic_hit_push_data             =  read_rdrsp_data; 

    \=obj.lib.dffre(1,          'atomic_hit_sent',                  'atomic_hit_sent_in',            "1'b0",            'atomic_hit_sent_en',               'clk', 'reset_n')=\

\jsbegin
var atomicRdFifoPorts = {
           push_intf_size   : '{'+obj.lib.getParam('returnDataInterface', 'intf_size')+'{1\'b0}}',
           push_size        : '{'+obj.lib.getParam('returnDataInterface', 'size')+'{1\'b0}}',
           push_mpf1        : '{'+obj.lib.getParam('returnDataInterface', 'mpf1')+'{1\'b0}}',
           push_valid       : 'atomic_hit_push_valid',
           push_ready       : 'atomic_hit_push_ready',
           push_vz          : '{1\'b0}',
           push_trans_id    : '{'+obj.lib.getParam('returnDataInterface','trans_id')+'\'b0}',
           push_id          : 'ccp_op_alloc_id',
           push_last        : 'atomic_hit_push_last',
           push_first       : 'ccp_op_scratch',
           push_target_id   : 'ccp_op_aiu_id',
           push_exokay      : '{1\'b0}',
           push_r_message_id: 'ccp_op_aiu_trans_id',
           push_cm_type     : 'ccp_op_cm_type',
           push_data        : 'atomic_hit_push_data',
           push_poison      : 'atomic_hit_push_poison',
           push_dwid        : '{'+obj.lib.getParam('returnDataInterface', 'dwid')+'{1\'b0}}',
           push_cdw         : 'ccp_op_cdw',
           push_err_type    : 'atomic_hit_push_err_type',
           push_tm          : 'ccp_op_tm',
           push_rd_type     : 'ccp_op_rd_type',
           pop_first        : 'atomic_rd_sp'
};

if ( wQos != 0 ) {
atomicRdFifoPorts['push_qos'] = 'ccp_op_qos';
}
// user field only avail on aw/ar channels
/* istanbul ignore if env ncore_3p4 */
if (wRdUser != 0) {
atomicRdFifoPorts['push_user'] = 'ccp_op_user';

}
\jsend

    \=obj.lib.instance({
        instanceName: 'atomic_rd_fifo',
        moduleName: 'fifo_bundle',
        params: {
            width: bundleFunctions.getBundleWidth(obj.lib.getParam('returnDataInterface'), ['valid', 'ready'], obj.lib.bundle),
            depth: 1,
            zerodepth: 0,
            bypass_mode: 1,
            interface: obj.lib.getParam('returnDataInterface')
        },
        verilogParams: {},
        ports: atomicRdFifoPorts,
        interfaces: [
           {modulePrefix: '',       localPrefix: '',            interface: obj.lib.getParam('clkInterface')},
           {modulePrefix: 'pop_',   localPrefix: 'atomic_rd_',  interface: obj.lib.getParam('returnDataInterface'), exclude: ['first']}],
        portsDelimiter: '\n        '
    })=\



    // Note atomic may be a scratchpad op, so need to kill rdrsp ready
    assign dmi_ccp_cache_rdrsp_ready= (ccp_op_scratch | op_needs_manufac_beat) ? 1'b0         
                                                                               : ccp_op_atomic ? (atomic_hit_push_ready | atomic_hit_sent) & (read_hit_push_ready | read_hit_sent | is_atomic_str(ccp_op_cm_type)) 
                                                                                               : read_hit_push_ready;
\js } else {
    assign dmi_ccp_cache_rdrsp_ready= (ccp_op_scratch | op_needs_manufac_beat) ? 1'b0 : read_hit_push_ready;
\js }

    assign ccp_op_ready = op_needs_manufac_beat ? ((read_hit_push_valid & read_hit_push_ready & read_hit_push_last) | is_atomic_str(ccp_op_cm_type)) 
                                                : (read_rdrsp_valid & read_rdrsp_ready & read_rdrsp_last);

    // Miss buffer
    // Collect entire burst before sending on to
    //  - minimize disruption to cache on a fill
    //  - ease handshaking between hit and miss path 
    //    (give miss data a place to go while cache is servicing a hit)
    //  - prevent timing issues from DMI ports
    //  - help bandwidth on NoC upstream by not starting burst until have all
\js var width = wFillInterface + wWays;
\js var fillDepth = nBeats * 3;
\js var wFillDepth =  Math.ceil(Math.log2(fillDepth));

    wire [\=width-1=\:0] fill_data_packet;
    wire [\=width-1=\:0] fill_pop_packet;


    \=obj.lib.instance({
        instanceName: 'fill_fifo',
        moduleName: 'fifo',
        params: {
            width: width,
            depth: fillDepth,
            zerodepth: 0,
            bypass_mode: 0
        },
        interfaces: [{ modulePrefix: '', localPrefix: '', interface: obj.lib.getParam('clkInterface') }],
        ports: {
            push_valid: 'fill_data_valid',
            push_ready: 'fill_data_ready',
            push_data:  'fill_data_packet',
            pop_valid:  'fill_pop_valid',
            pop_ready:  'fill_pop_ready',
            pop_data:   'fill_pop_packet'
        },
        portsDelimiter: '\n        '
    })=\

    assign fill_data_packet = {\=bundleFunctions.packetizeBundle('fill_data_', fillInterface, ['valid', 'ready'], obj.lib.bundle)=\, fill_data_way_enc};
    assign {\=bundleFunctions.packetizeBundle('fill_pop_', fillInterface, ['valid', 'ready'], obj.lib.bundle)=\, fill_pop_way_num} = fill_pop_packet;


    wire [\=wFillDepth-1=\:0] fill_beat_downcount, d_fill_beat_downcount;
    wire inc_fill_beat_downcount, dec_fill_beat_downcount;

    \=obj.lib.dffre(wFillDepth, 'fill_beat_downcount', 'd_fill_beat_downcount', wFillDepth+"'d"+fillDepth, "1'b1", 'clk', 'reset_n')=\

    assign inc_fill_beat_downcount = fill_pop_valid  & fill_pop_ready;
    assign dec_fill_beat_downcount = fill_data_valid & fill_data_ready;

    assign d_fill_beat_downcount = fill_beat_downcount + {\=wFillDepth-1=\'d0, inc_fill_beat_downcount} 
                                                       - {\=wFillDepth-1=\'d0, dec_fill_beat_downcount};

    assign dmi_ccp_cache_fill_fifo_avail = fill_beat_downcount >= \=wFillDepth=\'d\=nBeats=\;


    // Count last in fill buffer, the number of complete bursts in buffer
\js var width =  wFillDepth ;
    wire [\=width-1=\:0] fill_last_count;
    wire [\=width-1=\:0] d_fill_last_count;
    wire                  inc_fill_last_count;
    wire                  dec_fill_last_count;

    \=obj.lib.dffre(width, 'fill_last_count', 'd_fill_last_count', '{'+width+"{1'b0}}", "1'b1", 'clk', 'reset_n')=\
    

    assign inc_fill_last_count = fill_data_valid & fill_data_ready & fill_data_last;
    assign dec_fill_last_count = fill_pop_valid  & fill_pop_ready  & fill_pop_last;
    assign d_fill_last_count   = fill_last_count
                                      + {\=width-1=\'b0, inc_fill_last_count}
                                      - {\=width-1=\'b0, dec_fill_last_count};
    // Don't enable fill until have last in buffer or until buffer full
    assign fill_enable         = (fill_last_count != 0)? 1'b1 : ~fill_data_ready;

    // Send fill to data and tag if last at same time
    // If only one side accepts, then done block valid for that side until other side accepts, then pop

    wire fill_data_done_d;
    wire fill_tag_done_d;

    wire [1:0] fill_data_tag_done;

    \=obj.lib.dffre(2, 'fill_data_tag_done', '{fill_data_done_d, fill_tag_done_d}', "{2{1'b0}}", "1'b1", 'clk', 'reset_n')=\

    assign {fill_data_done, fill_tag_done} = fill_data_tag_done;
    assign fill_data_done_d = (data_fill | fill_data_done) & ~fill_pop_ready;
    assign fill_tag_done_d  = (tag_fill  | fill_tag_done ) & ~fill_pop_ready;

    assign fill_pop_ready   = ((fill_enable & dmi_ccp_cache_fill_data_ready) | fill_data_done) &
                              ((fill_enable & dmi_ccp_cache_fill_ready     ) | fill_tag_done | scratch_fill);

    //
    // Scratchpad control
    //
\js if (useScratchpad) {

\js var wayBase = wCacheLineOffset+wSets;
    localparam SCRATCH_MASK = {\=wAddr=\{1'b1}} << \=wayBase+wWays=\;
    wire [\=wWays=\:0] scratch_num_ways;

    assign scratch_en            = csr_SMCSPR_SPEnable;
    assign scratch_num_ways      = {1'b0, csr_SMCSPR_nSPWays[\=wWays-1=\:0]} + \=wWays+1=\'b1;
    assign scratch_max_way       = csr_SMCSPR_nSPWays[\=wWays-1=\:0];
    assign scratch_ways          = scratch_en ? ((\=nWays=\'b1 << scratch_num_ways) - \=nWays=\'b1) : 'b0;
    
    // check scratchpad match in p0
    // if this doesn't meet timing, then need to move to p1 and allow ccp lookup that we can't later
//    assign scratch_p0_match = ~|((scratch_base ^ ccp_p0_addr) & scratch_mask) &
//                              (ccp_p0_addr[\=wWays+wayBase-1=\:\=wayBase=\] <= scratch_max_way);

\js if (Math.abs(ccpCsrInterface.csr_SMCSPR_Size) > Math.abs(ccpCsrInterface.csr_SMCSPR_Base)) {
    assign scratch_offset_high = csr_SMCSPR_Base + csr_SMCSPR_Size[\=Math.abs(ccpCsrInterface.csr_SMCSPR_Base)-1=\:0];
\js } else {
    assign scratch_offset_high = csr_SMCSPR_Base + {\=wAddr-wCacheLineOffset+1-Math.abs(ccpCsrInterface.csr_SMCSPR_Size)=\'h0,csr_SMCSPR_Size};
\js }
    assign scratch_offset_low = csr_SMCSPR_Base;

    assign p0_addr_outside_scratch = ( {ccp_p0_ns, ccp_p0_addr[\=wAddr-1=\:\=wCacheLineOffset=\]} > scratch_offset_high )|
                                     ( {ccp_p0_ns, ccp_p0_addr[\=wAddr-1=\:\=wCacheLineOffset=\]} < scratch_offset_low  ); 
\js //Check address at input of dmi_cache_pipe rd_wr FIFO instead of p0
    assign write_addr_s_outside_scratch = ( {write_addr_s_ns, write_addr_s_addr[\=wAddr-1=\:\=wCacheLineOffset=\]} > scratch_offset_high )|
                                          ( {write_addr_s_ns, write_addr_s_addr[\=wAddr-1=\:\=wCacheLineOffset=\]} < scratch_offset_low  ); 

    assign read_addr_m_outside_scratch =  ( {read_addr_m_ns, read_addr_m_addr[\=wAddr-1=\:\=wCacheLineOffset=\]} > scratch_offset_high )|
                                          ( {read_addr_m_ns, read_addr_m_addr[\=wAddr-1=\:\=wCacheLineOffset=\]} < scratch_offset_low  ); 

    assign fill_addr_outside_scratch =  ( {fill_pop_ns, fill_pop_addr[\=wAddr-1=\:\=wCacheLineOffset=\]} > scratch_offset_high )|
                                        ( {fill_pop_ns, fill_pop_addr[\=wAddr-1=\:\=wCacheLineOffset=\]} < scratch_offset_low  ); 

    assign scratch_p0_match = ~p0_addr_outside_scratch;
 
    assign scratch_p0_valid =  scratch_en & ccp_p0_valid & scratch_p0_match;

    assign scratch_wr_kill_ac = scratch_en & (&scratch_ways) & write_addr_s_outside_scratch;

\js     if ( useAtomic ) {
    assign scratch_rdrsp_ready       = (ccp_op_atomic & ccp_op_scratch) ? (atomic_hit_push_ready | atomic_hit_sent) & (read_hit_push_ready | read_hit_sent | is_atomic_str(ccp_op_cm_type)):
                                                                          ccp_op_scratch ? read_hit_push_ready : 1'b0;
\js     } else {
    assign scratch_rdrsp_ready       = ccp_op_scratch ? read_hit_push_ready : 1'b0;
\js     }
\js var width = bundleFunctions.getBundleWidth(scratchOpInterface, ['scratch_op_ready', 'scratch_op_valid'], obj.lib.bundle);

    \=u.instance({
        instanceName: 'scratch_op',
        moduleName: 'fifo',
        params: {
            width: width,
            depth: 1,
            zerodepth: 0,
            bypass_mode: 1
        },
        interfaces: [{ modulePrefix: '', localPrefix: '', interface: u.getParam('clkInterface') }],
        ports: {
            push_valid: 'pipe_scratch_op_valid',
            push_ready: 'pipe_scratch_op_ready',
            push_data:  bundleFunctions.packetizeBundle('pipe_', scratchOpInterface, ['scratch_op_valid','scratch_op_ready'], obj.lib.bundle),
            pop_valid:  'pop_scratch_op_valid',
            pop_ready:  'pop_scratch_op_ready', 
            pop_data:   bundleFunctions.packetizeBundle('', scratchOpInterface, ['scratch_op_valid','scratch_op_ready'], obj.lib.bundle)
        },
        portsDelimiter: '\n        '
    })=\

    assign scratch_op_valid = {\=nDataBanks=\{pop_scratch_op_valid}} & scratch_op_bank_sel_onehot;
    assign pop_scratch_op_ready = |(scratch_op_ready & scratch_op_valid);

    \js// if already scratch op is held up, then don't allow new scratch
    \js// TODO: suppress upon correctable error, maybe too strict.
    assign scratch_p0_ready      = ~(pipe_scratch_op_valid & ~pipe_scratch_op_ready) & ~(dmi_ccp_cache_nack_ce_p2 | dmi_ccp_cache_nack_ce_p2_d1 | dmi_ccp_cache_nack_ce_p2_d2);

    assign scratch_op_burst_wrap = 1'b1;

    // need to capture scratch way in p2 for atomics
    wire scratch_way_en;
    wire [\=wWays-1=\:0] scratch_way_num_p2;

    \=obj.lib.dffre(wWays, 'scratch_way_num_p2', 'pipe_scratch_op_way_num', '{'+wWays+"{1'b0}}", 'scratch_way_en', 'clk', 'reset_n')=\

    assign scratch_way_en        = pipe_scratch_op_valid & pipe_scratch_op_ready;
    assign scratch_way_p2        = \=nWays=\'b1 << scratch_way_num_p2;

    assign scratch_wr_valid      = wr_data_valid & wr_op_scratch;
    assign scratch_wr_data       = {write_data_s_poison, write_data_s_data};
    assign scratch_wr_byte_en    = dmi_ccp_ctrl_wr_byte_en;
    assign scratch_wr_beat_num   = dmi_ccp_ctrl_wr_beat_num;
    assign scratch_wr_last       = dmi_ccp_ctrl_wr_last;

    wire read_busy, read_scratch;

    assign read_busy_in = (read_rdrsp_valid & read_rdrsp_ready)? ~read_rdrsp_last : 1'b1;

    \=obj.lib.dffre(2, 'read_busy_scratch', '{read_busy_in, ccp_op_scratch}', "{2{1'b0}}", 'read_busy_en', 'clk', 'reset_n')=\ 

    assign {read_busy, read_scratch} = read_busy_scratch;
\js // CONC-4605: Once data being pushed into either fifo, ccp_op_scratch should be locked
\js if ( useAtomic ) {
    assign read_busy_en          = (read_rdrsp_valid & read_rdrsp_ready) | (read_hit_push_valid & read_hit_push_ready) | (atomic_hit_push_valid & atomic_hit_push_ready);
\js } else {
    assign read_busy_en          = (read_rdrsp_valid & read_rdrsp_ready) | (read_hit_push_valid & read_hit_push_ready);
\js }
    assign ccp_op_scratch        = read_busy ? read_scratch : (scratch_rd_req & scratch_rdrsp_valid);
\js // TODO: scratchpad always have the higher priority?
    assign read_rdrsp_valid      = ccp_op_scratch ? scratch_rdrsp_valid & ~scratch_rdrsp_cancel : dmi_ccp_cache_rdrsp_valid & ~dmi_ccp_cache_rdrsp_cancel;
    assign read_rdrsp_ready      = ccp_op_scratch ? scratch_rdrsp_ready : dmi_ccp_cache_rdrsp_ready;
    assign read_rdrsp_data       = ccp_op_scratch ? scratch_rdrsp_data[\=wData-1=\:0]  : dmi_ccp_cache_rdrsp_data[\=wData-1=\:0];
    assign read_rdrsp_last       = ccp_op_scratch ? scratch_rdrsp_last  : dmi_ccp_cache_rdrsp_last;
    assign read_rdrsp_poison     = ccp_op_scratch ? scratch_rdrsp_data[\=wData=\]  : dmi_ccp_cache_rdrsp_data[\=wData=\];
    // cancel tag write on scratchpad fill for atomics, not strictly needed but cleaner
    assign scratch_fill          = scratch_en & ~fill_addr_outside_scratch;
    assign read_addr_m_sp        = scratch_en & ~read_addr_m_outside_scratch;

\js } else {
    assign scratch_ways          = 'b0;
    assign scratch_p0_valid      = 'b0;
    assign scratch_p0_ready      = 'b1;
    assign scratch_wr_kill_ac    = 'b0;
    assign scratch_way_p2        = 'b0;
    assign scratch_fill          = 'b0;
    assign read_addr_m_sp        = 'b0;

    assign  ccp_op_scratch       = 1'b0;
    // no scratchpad, just wire these together
    assign read_rdrsp_valid      = dmi_ccp_cache_rdrsp_valid & ~dmi_ccp_cache_rdrsp_cancel;
    assign read_rdrsp_ready      = dmi_ccp_cache_rdrsp_ready;
    assign read_rdrsp_data       = dmi_ccp_cache_rdrsp_data[\=wData-1=\:0];
    assign read_rdrsp_last       = dmi_ccp_cache_rdrsp_last;
    assign read_rdrsp_poison     = dmi_ccp_cache_rdrsp_data[\=wData=\];
\js }

    assign dmi_ccp_CorrErrDetectEn   = csr_CECR_ErrDetEn;
    assign dmi_ccp_UnCorrErrDetectEn = csr_UEDR_MemErrDetEn;

    assign dmi_ccp_maint_req_opcode     = ccp_p2_mnt_op_req_msg[3:0];
    assign dmi_ccp_maint_req_array_sel  = csr_SMCMCR_ArrId;
    assign dmi_ccp_maint_req_data       = csr_SMCMDR_MntData;
    assign dmi_ccp_maint_req_way        = {\=ccpMaintInterface.maint_req_data-wWays=\'b0, ccp_p2_mnt_op_req_way};
    assign dmi_ccp_maint_req_entry      = csr_SMCMLR0_MntSet;
    assign dmi_ccp_maint_req_word       = csr_SMCMLR0_MntWord;
    assign pipe_in_ccp__maint_read_data         = dmi_ccp_maint_read_data;
    assign pipe_in_ccp__maint_read_data_en      = dmi_ccp_maint_read_data_en; 
    
    assign ccp_SMCISR_Tag_Init_Done     = dmi_ccp_tag_init_done;
    assign ccp_SMCISR_Data_Init_Done    = dmi_ccp_data_init_done;

\jsbegin
    var MNTOP_CTRL_UNIT_PORTS = {
            reinit:                 'dmi_ccp_reinit',
            init_done:              'dmi_ccp_init_done',
            tag_init_done:          'dmi_ccp_tag_init_done',
            data_init_done:         'dmi_ccp_data_init_done',

            MntOp_init:             'csr_MntOp_init',
            MCR_MntOp:              'csr_SMCMCR_MntOp',
            MCR_ArrId:              'csr_SMCMCR_ArrId',
            MCR_SecAttr:            'csr_SMCMCR_SecAttr',
            MLR0_MntSet:            'csr_SMCMLR0_MntSet',
            MLR0_MntWay:            'csr_SMCMLR0_MntWay',
            MLR0_MntWord:           'csr_SMCMLR0_MntWord',
            MLR1_MntAddr:           'csr_SMCMLR1_MntAddr',
            MLR1_MntAddrRange:      'csr_SMCMLR1_MntAddrRange',
            
            mnt_req_valid:          'mnt_op_req_valid',
            mnt_req_ready:          'mnt_op_req_ready',
            mnt_req_valid_p2:       'mnt_op_req_valid_p2',
            mnt_req_msg_p2:         'ccp_p2_mnt_op_req_msg',
            ways_pending_p2:        'dmi_ccp_ctrl_op_ways_busy_vec_p2',
            rtt_addr_match_p2:      'rtt_addr_match_p2',
            wtt_addr_match_p2:      'wtt_addr_match_p2',
            wtt_ready:              'wtt_ready',
            mntop_active:           'mntop_active',
            auto_init_active:       'auto_init_active',
            mnt_req_bundle_msg:     'mnt_op_req_msg',
            mnt_req_bundle_addr:    'mnt_op_req_addr',
            mnt_req_bundle_way:     'mnt_op_req_way',
            mntop_flush_p2:         'mntop_flush_p2',
            flush_fail_p2:          'flush_fail_p2'      
    };
    /* istanbul ignore else env ncore_3p0, ncore_3p2, ncore_3p4 */
    if(ccpParams.wSecurity != 0) {           
    MNTOP_CTRL_UNIT_PORTS['mnt_req_bundle_security'] = 'mnt_op_req_security';
    }

    var MNTOP_CTRL_UNIT_PARAMS = {
                    PortPriSubDiagAddrBits: ccpParams.PortPriSubDiagAddrBits,
                    PortSecSubRows:         ccpParams.PortSecSubRows,
                    PriSubDiagAddrBits:     ccpParams.PriSubDiagAddrBits,
                    SecSubRows:             convertSecSubRowsToOld(ccpParams.SecSubRows),
                    num_ports:              ccpParams.num_ports,
                    wSecurity:              ccpParams.wSecurity,
                    nSets:                  ccpParams.nSets,
                    nWays:                  ccpParams.nWays,
                    wAddr:                  wAddr,
                    wCacheLineOffset:       wCacheLineOffset,
                    wWays:                  wWays,
                    wMntOpCode:             wMntOpCode,
                    clkInterface:           obj.lib.getParam('clkInterface')
    };

\jsend

    assign mnt_req_valid_p2         = ccp_p2_mnt & ccp_p2_valid;
    assign mnt_op_req_valid_p2      = mnt_req_valid_p2 & ~dmi_ccp_cache_nack_ce_p2 & ~dmi_ccp_cache_nack_p2;  
    assign wtt_ready                = write_addr_m_ready;
    \=obj.lib.dffre(1, 'rtt_addr_match_p2','read_cam_match',  "1'b0", "1'b1", 'clk', 'reset_n')=\
    \=obj.lib.dffre(1, 'wtt_addr_match_p2','write_cam_match', "1'b0", "1'b1", 'clk', 'reset_n')=\

    \=obj.lib.instance({
        instanceName: 'dmi_mnt_op_ctrl_unit',
        moduleName: 'dmi_mnt_op_ctrl',
        params: MNTOP_CTRL_UNIT_PARAMS,
        interfaces: [{ modulePrefix: '', localPrefix: '', interface: obj.lib.getParam('clkInterface') }],
        ports: MNTOP_CTRL_UNIT_PORTS,
        portsDelimiter: '\n        '
    })=\

    assign pipe_in_ccp__correctible_error_valid         = dmi_ccp_correctible_error_valid; 
    assign pipe_in_ccp__correctible_error_entry         = dmi_ccp_correctible_error_entry; 
    assign pipe_in_ccp__correctible_error_way           = dmi_ccp_correctible_error_way; 
    assign pipe_in_ccp__correctible_error_double_error  = dmi_ccp_correctible_error_double_error; 
    assign pipe_in_ccp__correctible_error_type          = dmi_ccp_correctible_error_type; 
    assign pipe_in_ccp__correctible_error_info          = dmi_ccp_correctible_error_info; 
    assign pipe_in_ccp__correctible_error_word          = dmi_ccp_correctible_error_word; 
    assign pipe_in_ccp__correctible_error_addr_hi       = dmi_ccp_correctible_error_addr_hi; 
    assign pipe_in_ccp__uncorrectible_error_valid       = dmi_ccp_uncorrectible_error_valid; 
    assign pipe_in_ccp__uncorrectible_error_entry       = dmi_ccp_uncorrectible_error_entry; 
    assign pipe_in_ccp__uncorrectible_error_way         = dmi_ccp_uncorrectible_error_way; 
    assign pipe_in_ccp__uncorrectible_error_double_error= dmi_ccp_uncorrectible_error_double_error; 
    assign pipe_in_ccp__uncorrectible_error_type        = dmi_ccp_uncorrectible_error_type; 
    assign pipe_in_ccp__uncorrectible_error_info        = dmi_ccp_uncorrectible_error_info; 
    assign pipe_in_ccp__uncorrectible_error_word        = dmi_ccp_uncorrectible_error_word; 
    assign pipe_in_ccp__uncorrectible_error_addr_hi     = dmi_ccp_uncorrectible_error_addr_hi; 
    assign pipe_in_ccp__maint_active                    = dmi_ccp_maint_active;
    assign ccp_mntop_active                     = mntop_active;
    assign ccp_trans_active                     = cache_pipe_busy       |
                                                  evict_addr_valid      |
                                                  evict_valid           |
                                                  mntop_active          |
                                                  auto_init_active      |
                                                  dmi_ccp_maint_active  |
                                                  dmi_ccp_trans_active  ;
    //Clk Gate enable does not need timing critical CCP outputs or evict valid since
    // that is taken care of in either WTT/RTT entries or protocol active
    assign ccp_trans_active_4clkGate            = cache_pipe_busy       |
                                                  mntop_active          |
                                                  auto_init_active      ;


\js // Way Partitiong register marks busy way

\js if(useWayPartitioning) {
    wire ccp_p1_hit_wp_id;
    wire [\=nWays-1=\:0] ccp_p1_wp_way_pre;
    wire [\=nWays-1=\:0] ccp_p1_way_unavail;
    assign ccp_p1_wp_way_pre = (csr_SMCWP0_Way & {\=nWays=\{(csr_SMCWP0_Id == ccp_p1_n_unit_id) & csr_SMCWP0_Valid}})
\js     for(var i = 1; i < nWayPartitioningRegisters; i++) {
                              |(csr_SMCWP\=i=\_Way & {\=nWays=\{(csr_SMCWP\=i=\_Id == ccp_p1_n_unit_id) & csr_SMCWP\=i=\_Valid}})                   
\js     }
                            ;
    assign ccp_p1_hit_wp_id = (csr_SMCWP0_Id == ccp_p1_n_unit_id) & csr_SMCWP0_Valid 
\js     for(var i = 1; i < nWayPartitioningRegisters; i++) {
                             |(csr_SMCWP\=i=\_Id == ccp_p1_n_unit_id) & csr_SMCWP\=i=\_Valid
\js     }
                              ;

    assign ccp_p1_wp_way = ccp_p1_hit_wp_id ? ccp_p1_wp_way_pre : ~ccp_p1_way_unavail;

    assign ccp_p1_way_unavail = (csr_SMCWP0_Way & {\=nWays=\{csr_SMCWP0_Valid}})
\js     for(var i = 1; i < nWayPartitioningRegisters; i++) {
                               |(csr_SMCWP\=i=\_Way & {\=nWays=\{csr_SMCWP\=i=\_Valid}})
\js     }
                              ;

//    assign ccp_p1_wp_no_rsvd_way = ccp_p1_valid & ~(ccp_p1_hit_wp_id & |(ccp_p1_wp_way & ~scratch_ways)) & (&ccp_p1_way_unavail);

    assign ccp_p1_wp_no_rsvd_way = ccp_p1_valid & ~scratch_p1_valid & ((~ccp_p1_hit_wp_id & (&ccp_p1_way_unavail)) | ~|(ccp_p1_wp_way & ~scratch_ways));

\js } else {
    assign ccp_p1_wp_no_rsvd_way = 1'b0;
    assign ccp_p1_wp_way = {\=nWays=\{1'b1}};
\js }


\js //addrInterface['aiu_id'] == wFUnitId+wFPortId
    assign ccp_p1_n_unit_id = (\=wNUnitId=\'d0 & {\=wNUnitId=\{ccp_p1_aiu_id[\=wFUnitId+wFPortId-1=\:\=wFPortId=\] == aiu_f_unit_id[\=wFUnitId-1=\:0]}})
\js for(var i = 1; i < nAius; i++) {                           
                             |(\=wNUnitId=\'d\=i=\ & {\=wNUnitId=\{ccp_p1_aiu_id[\=wFUnitId+wFPortId-1=\:\=wFPortId=\] == aiu_f_unit_id[\=(i+1)*wFUnitId-1=\:\=i*wFUnitId=\]}})
\js }
                             ;

    \=obj.lib.dffre(1, 'evict_addr_valid_q', 'evict_addr_valid', "1'b0", "1'b1", 'clk', 'reset_n')=\

    `ifdef OVL_ASSERT_ON
    // coverage off
    // synthesis off
    // synopsys translate_off
    //
    //
    //
    //
    reg tag_uce_test;
    reg data_uce_test;
    initial begin
        if ($test$plusargs("uncorr_error_test")) begin
                tag_uce_test = 1'b1;
        end else begin
                tag_uce_test = 1'b0;
        end
        if ($test$plusargs("uncorr_err_inj_test")) begin
                data_uce_test = 1'b1;
        end else begin
                data_uce_test = 1'b0;
        end
    end
\jsbegin
// TODO: temporary comment out for DV to provide accurate plusarg
//    assert_never assert_tag_uce_no_tag_error_inject (
//        .clk(clk),
//        .reset_n(reset_n),
//        .test_expr(dmi_ccp_tag_uce & ~tag_uce_test)
//    );

//    assert_never assert_data_uce_no_data_error_inject (
//        .clk(clk),
//        .reset_n(reset_n),
//        .test_expr(dmi_ccp_data_uce & ~data_uce_test)
//    );
    // shouldn't overwrite evict addr if not sent yet
\jsend
    assert_implication #(0) assert_evict_addr_overwrite (
        .clk(clk),
        .reset_n(reset_n),
        .antecedent_expr(push_evict_addr_valid),
        .consequent_expr(push_evict_addr_ready)
    );
    assert_implication #(0) assert_bypass_data_without_addr (
        .clk(clk),
        .reset_n(reset_n),
        .antecedent_expr(dmi_ccp_ctrl_op_bypass_p2),
        .consequent_expr(ccp_p2_wr)
    );
    // a dropped access shouldn't cause eviction
    assert_implication #(0) assert_evict_for_drop (
        .clk(clk),
        .reset_n(reset_n),
        .antecedent_expr(wr_ccp_p2_drop /*| ccp_p2_drop_hint*/),
        .consequent_expr(~new_evict_addr)
    );

    assert_implication #(0) assert_hit_way_vec_onehot (
        .clk(clk),
        .reset_n(reset_n),
        .antecedent_expr(dmi_ccp_ctrl_op_hit_p2 & ~dmi_ccp_cache_nack_ce_p2 & ~dmi_ccp_cache_nack_uce_p2),
        .consequent_expr($onehot(dmi_ccp_cache_hit_way_vec_p2))    
    );

\jsbegin
    // CONC-5615: Not valid since ccp process fill address & data independently. 
    // Fill done will not be asserted for the fill before tag is filled. And the ready term should be fill_ready instead.
    // For fill, if finished writing data and still writing tag, then fill_done can deallocate
    // RTT before tag is written. Assuming that ccp does not accept new access while still 
    // trying to fill tag then it's okay, otherwise the fill line will be invalid and may lead to error
    //
    //assert_never assert_fill_done_without_tag (
    //    .clk(clk),
    //    .reset_n(reset_n),
    //    .test_expr(|({\=nTagBanks=\{~dmi_ccp_ctrl_fill_data_valid & dmi_ccp_ctrl_fill_valid}} & dmi_ccp_cache_op_ready_p0))
    //);
    // when doing write through, have to insert blanks to fake out ccp for odd
    // wrap cases. But should not write blanks otherwise
    // TODO redo for arbitrary size
  //  assert_implication assert_write_wrap_blank (
  //      .clk(clk),
  //      .reset_n(reset_n),
  //      .antecedent_expr(write_blank),
  //      .consequent_expr(wr_op_beat[0] & (wr_op_size < \=wCacheLineOffset=\))
  //  );

    // bus resp can be capture in latch if can't move forward, but don't overflow 
\jsend
    assert_implication assert_bus_resp_overflow (
        .clk(clk),
        .reset_n(reset_n),
        .antecedent_expr(set_bus_resp_pend),
        .consequent_expr(~(bus_resp_pend & ~clr_bus_resp_pend))
    );
    // synopsys translate_on
    // synthesis on
    // coverage on
    `endif

endmodule

