\jsbegin
//=============================================================================
// Copyright(C) 2018 Arteris, Inc.
// All rights reserved
//=============================================================================
// DMI Top Level
// Author: Tso-Wei Chang
//=============================================================================
var utilFunctions   = obj.userLib.lib_utils;
var log2ceil                    = function(n) { return Math.ceil(Math.log(n)/Math.LN2); };
var newToOldStyleInterface	= obj.userLib.newToOldStyleInterface.bind( null, obj.userLib );
var m = obj.userLib;
var u=obj.lib;

var ASILB = 0;
obj.lib.paramDefault('useMemoryGating',             'int',      0);
obj.lib.paramDefault('usePma',                      'int',      1);
obj.lib.paramDefault('useCmc',                      'int',      0);
obj.lib.paramDefault('ccpParams',                   'object',   {});
obj.lib.paramDefault('useAtomic',                   'int',      0);
obj.lib.paramDefault('assertOn',                    'int',      0);
obj.lib.paramDefault('MemoryGeneration',            'object',   {});
obj.lib.paramDefault('timeOutThreshold',            'int',      0);
obj.lib.paramDefault('wAddr',                       'int',      48);
obj.lib.paramDefault('wRpn',                        'int',      3);
obj.lib.paramDefault('wNrri',                       'int',      3);
obj.lib.paramDefault('nAius',                       'int',      6);
obj.lib.paramDefault('wFPortId',                    'int',      2);
obj.lib.paramDefault('wFUnitId',                    'int',      7);
obj.lib.paramDefault('wNUnitId',                    'int',      5);
obj.lib.paramDefault('wData',                       'int',      128);
obj.lib.paramDefault('cmType',                      'object',   {});
obj.lib.paramDefault('PmaInfo',                     'object',   {});
obj.lib.paramDefault('concParams',                  'object',   {});
obj.lib.paramDefault('concMuxMsgParams',            'object',   {});
obj.lib.paramDefault('engVerId',                    'int',      0);
obj.lib.paramDefault('implVerId',                   'int',      0);
obj.lib.paramDefault('fnErrDetectCorrect',          'string',   "NONE");
obj.lib.paramDefault('useResiliency',               'int',      0);
obj.lib.paramDefault('useAddrTranslation',          'int',      0);
obj.lib.paramDefault('nAddrTransRegisters',         'int',      0);
obj.lib.paramDefault('useWayPartitioning',          'int',      0);
obj.lib.paramDefault('nWayPartitioningRegisters',   'int',      0);
obj.lib.paramDefault('fnNativeInterface',           'string',   "AXI");
obj.lib.paramDefault('ResilienceInfo',              'object',   {});
obj.lib.paramDefault('wCacheLineOffset',            'int',      6);
obj.lib.paramDefault('cmpInfo',                     'object',   {});
obj.lib.paramDefault('interfaces',                  'object',   {});
obj.lib.paramDefault('smiPortParams',               'object',   null);
obj.lib.paramDefault('nativeInterfacePipe',         'int',      1);
obj.lib.paramDefault('enWrPipe',                    'int',      1);
obj.lib.paramDefault('enRdPipe',                    'int',      1);
obj.lib.paramDefault('nUnitTraceBufSize',           'int',      8);
obj.lib.paramDefault('traceDebugEnable',            'boolean',  true);
obj.lib.paramDefault('nPerfCounters', 'int', 4);
obj.lib.paramDefault('syncDepth', 'int', 2);
obj.lib.paramDefault("nExclusiveEntries","int",0);


var regProtectionInterface = {};
var regProtectionInterfaceName = "";
var regProtectionStyle = "";




// Variables


var nativeInterfacePipe= obj.lib.getParam('nativeInterfacePipe');
var memFunctions       = obj.userLib;
var utilFunctions      = obj.userLib;
var bundleFunctions    = obj.userLib.bundleFunctions;
var interfaceGen       = obj.userLib.interfaceGenerators;
var wCacheLineOffset   = obj.lib.getParam('wCacheLineOffset');
var assertOn           = obj.lib.getParam('assertOn');
var syncDepth          = obj.lib.getParam('syncDepth');
var wFUnitId           = obj.lib.getParam('wFUnitId');
var wFPortId           = obj.lib.getParam('wFPortId');
var wInitiatorId       = wFUnitId + wFPortId;
var wRpn               = obj.lib.getParam('wRpn');
var wNrri              = obj.lib.getParam('wNrri');
var wNUnitId           = obj.lib.getParam('wNUnitId');
var wMessageId         = obj.lib.getParam('concParams', 'hdrParams', 'wMsgId');
var cmpInfo            = obj.lib.getParam('cmpInfo');
var nMrdSkidBufArb = obj.lib.getParam("nMrdSkidBufArb");
var nMrdSkidBufSize = obj.lib.getParam("nMrdSkidBufSize");
var nCMDSkidBufSize = obj.lib.getParam("nCMDSkidBufSize");
var nCMDSkidBufArb = obj.lib.getParam("nCMDSkidBufArb");
var cmType             = obj.lib.getParam('cmType');
var useCmc             = obj.lib.getParam('useCmc');
var wData              = obj.lib.getParam('wData');
var wAddr              = obj.lib.getParam('wAddr');
var nBeats             = (1<<wCacheLineOffset) / (wData/8);

// TODO List: 
// terminate tansaction if CMStatus in Rsp != 0 
// need to check DTRReqBuffer size. Count dtwMrgMrds?
// str size must equal nsccmd credits because can't backpressure late read response on cacheops.Or size up to max width?
var bufferSize = {
    DTRReqBuffer    : nMrdSkidBufSize + nCMDSkidBufSize + cmpInfo.nDceRbEntries,
    MRDReqSkidBuffer: nMrdSkidBufArb,
    MRDReqSkidfifo  : nMrdSkidBufSize-nMrdSkidBufArb,
    NCCMDReqBuffer  : nCMDSkidBufSize,
    CMDReqSkidBuffer: nCMDSkidBufArb,
    CMDReqSkidfifo  : nCMDSkidBufSize-nCMDSkidBufArb,
    RBRReqBuffer    : cmpInfo.nDceRbEntries,
    CDataBuffer     : cmpInfo.nDceRbEntries * nBeats,
    NCDataBuffer    : cmpInfo.nDmiRbEntries * nBeats,
    DTWRspBuffer    : cmpInfo.nDmiRbEntries + cmpInfo.nDceRbEntries
};


var MemoryGeneration = obj.lib.getParam('MemoryGeneration');

if ( MemoryGeneration.MrdSkidBufMem.length !=0 & bufferSize.MRDReqSkidfifo > 0 ){
var MRDOverflowBufInSRAM =  MemoryGeneration.MrdSkidBufMem[0].fnMemType == "SRAM";
} else {
    var MRDOverflowBufInSRAM = 0;  
}

if (MRDOverflowBufInSRAM){
var MRDReq_sb_mem_gen   =  MemoryGeneration["MrdSkidBufMem"][0];
}

if ( MemoryGeneration.CmdSkidBufMem.length !=0  & bufferSize.CMDReqSkidfifo > 0 ){
var CMDOverflowBufInSRAM =  MemoryGeneration.CmdSkidBufMem[0].fnMemType == "SRAM";
} else {
var CMDOverflowBufInSRAM = 0;  
}

if (CMDOverflowBufInSRAM){
var CMDReq_sb_mem_gen   =  MemoryGeneration["CmdSkidBufMem"][0];
}

var useAtomic          = obj.lib.getParam('useAtomic');
var csr                = obj.lib.getParam('csr');
var wCsrData           = obj.lib.getParam('interfaces', 'apbInt', 'params', 'wData');
var wCsrAddr           = obj.lib.getParam('interfaces', 'apbInt', 'params', 'wAddr');
var smiTxPortParams    = obj.lib.getParam('smiPortParams', 'tx');
var smiRxPortParams    = obj.lib.getParam('smiPortParams', 'rx');
var concParams         = obj.lib.getParam('concParams');
var concMuxTxMsgParams = obj.lib.getParam('concMuxMsgParams', 'tx');
var concMuxRxMsgParams = obj.lib.getParam('concMuxMsgParams', 'rx');
var interfaces         = obj.lib.getParam('interfaces');
var axiParams          = interfaces.axiInt.params;
var useAddrTranslation = obj.lib.getParam('useAddrTranslation');
var nAddrTransRegisters= obj.lib.getParam('nAddrTransRegisters');
var fnNativeInterface  = obj.lib.getParam('fnNativeInterface');
var usePma             = obj.lib.getParam('usePma');
var useMemoryGating    = obj.lib.getParam('useMemoryGating');
var PmaInfo            = obj.lib.getParam('PmaInfo');
var nAius              = obj.lib.getParam('nAius');
var fnEnableQos        = obj.userLib.ParamDefaultGet(obj.lib, 'fnEnableQos',            'int',       0);
var wStarvThreshold     = obj.userLib.ParamDefaultGet(obj.lib, 'wStarvThreshold',         'int',     fnEnableQos*16);
var QosInfo            = obj.userLib.ParamDefaultGet(obj.lib, 'QosInfo',                'object',   {});
var fnEnableTimeOutRef = obj.userLib.ParamDefaultGet(obj.lib, 'fnEnableTimeOutRef',     'int',       0);
var sameWidthSystem    = 0;
var fnErrDetectCorrect = obj.lib.getParam('fnErrDetectCorrect');
var enWrPipe           = obj.lib.getParam('enWrPipe');
var enRdPipe           = obj.lib.getParam('enRdPipe');
var nUnitTraceBufSize  = obj.lib.getParam('nUnitTraceBufSize');
var traceDebugEnable   = obj.lib.getParam('traceDebugEnable');

var nExclusiveEntries=obj.lib.getParam("nExclusiveEntries");

var useSysReqSender    = concMuxTxMsgParams.hasOwnProperty('sysReq');
 
var N_DVES             = obj.userLib.ParamDefaultGet(obj.lib, 'nDve', 'int', 1); 

//useTrace is always set in ncore_3p2
 /* istanbul ignore next env ncore_3p2, ncore_3p4,ncore_3p6, ncore_3p7 */
var useTrace = (concMuxRxMsgParams.hasOwnProperty('dtwDbgRsp') || concMuxTxMsgParams.hasOwnProperty('dtwDbgReq'));
var nPerfCounters      = obj.lib.getParam('nPerfCounters');

var enableReadDataInterleaving  = obj.lib.getParam('cmpInfo', 'useMemRspIntrlv');
var nWrDataBanks                = obj.lib.getParam('cmpInfo', 'nWrDataBanks');
var nRdDataBanks                = obj.lib.getParam('cmpInfo', 'nRdDataBanks');


// way partitioning
var useWayPartitioning          = obj.lib.getParam('useWayPartitioning');
var nWayPartitioningRegisters   = obj.lib.getParam('nWayPartitioningRegisters');
// resilience params
var useResiliency               = obj.lib.getParam('useResiliency');
var ResilienceInfo              = obj.lib.getParam('ResilienceInfo');
var nResiliencyDelay            = ResilienceInfo['nResiliencyDelay'];
var enableUnitDuplication       = ResilienceInfo['enableUnitDuplication'];
var enableNativeIntfProtection  = ResilienceInfo['enableNativeIntfProtection'];
var fnResiliencyProtectionType  = ResilienceInfo['fnResiliencyProtectionType'];
var nResiliencyDelay            = ResilienceInfo['nResiliencyDelay'];
if(useCmc || useAtomic) {
    var ccpParams               = obj.lib.getParam('ccpParams');
    var usePLRU                 = (ccpParams.RepPolicy == "PLRU") ? 1 : 0;
    var nrumem                  = 0;
    ccpParams ["useOutputPortCachelineAvail"] =1; 
    //parameter not suported in 3.2
    /* istanbul ignore next env ncore_3p0,ncore_3p2,ncore_3p4,ncore_3p6, ncore_3p7 */
    if ((ccpParams.nRPPorts == 2) && (ccpParams.RepPolicy != "RANDOM") && (ccpParams.nWays > 1)) {
        nrumem                  = 1;
    }
} else {
    var ccpParams               = {};
    var usePLRU                 = 0;
    var nrumem                  = 0;
}
var useScratchpad               = useCmc? obj.lib.getParam('ccpParams', 'useScratchpad') : 0;

if(useAtomic) {
    useCmc = 1;
}

for(var reg=0; reg < csr.spaceBlock[0].registers.length; reg++) { 
    var reg_name = csr.spaceBlock[0].registers[reg].name ;
    for(var field=0; field < csr.spaceBlock[0].registers[reg].fields.length ; field++) {
        var entry = csr.spaceBlock[0].registers[reg].fields[field];
            if(reg_name == "DMIUCRTR" && entry.name == "ResThreshold") {
                var wResThreshold = entry.bitWidth;
            }
      }
}

if ( wResThreshold == undefined ) { 
var wResThreshold = 0;
}

var SMI_TX_INTF                 = m.ParamDefaultGet(u, 'smiTxPortInterfaces',   'array', []);
var SMI_RX_INTF                 = m.ParamDefaultGet(u, 'smiRxPortInterfaces',   'array', []);
var CONC_TX_INTF                = m.ParamDefaultGet(u, 'concertoTxInterfaces',  'array', []);
var CONC_RX_INTF                = m.ParamDefaultGet(u, 'concertoRxInterfaces',  'array', []);

// Concerto Mux RX Message struture
var MRD_REQ = obj.userLib.concMsgGen(obj, 'mrd_req_', 'ConcMsgBodyMRDReq', concParams.hdrParams, concParams.mrdReqParams, concMuxRxMsgParams.mrdReq, 'rx');
var CMD_REQ = obj.userLib.concMsgGen(obj, 'cmd_req_', 'ConcMsgBodyCMDReq', concParams.hdrParams, concParams.cmdReqParams, concMuxRxMsgParams.cmdReq, 'rx');
var RBR_REQ = obj.userLib.concMsgGen(obj, 'rbr_req_', 'ConcMsgBodyRBRReq', concParams.hdrParams, concParams.rbrReqParams, concMuxRxMsgParams.rbrReq, 'rx');
var STR_RSP = obj.userLib.concMsgGen(obj, 'str_rsp_', 'ConcMsgBodySTRRsp', concParams.hdrParams, concParams.strRspParams, concMuxRxMsgParams.strRsp, 'rx');
var DTR_RSP = obj.userLib.concMsgGen(obj, 'dtr_rsp_', 'ConcMsgBodyDTRRsp', concParams.hdrParams, concParams.dtrRspParams, concMuxRxMsgParams.dtrRsp, 'rx');
var DTW_REQ = obj.userLib.concMsgGen(obj, 'dtw_req_', 'ConcMsgBodyDTWReq', concParams.hdrParams, concParams.dtwReqParams, concMuxRxMsgParams.dtwReq, 'rx');
var DTWDBG_RSP    = obj.userLib.concMsgGen(obj, 'dtw_dbg_rsp_',    'ConcMsgBodyDTWDBGRsp',   concParams.hdrParams, concParams.dtwDbgRspParams,   concMuxRxMsgParams.dtwDbgRsp,   'rx');

 /* istanbul ignore else env ncore_3p6, ncore_3p7*/
if (useSysReqSender) {
var SYS_RSP_RX = obj.userLib.concMsgGen(obj, 'sys_rsp_rx_', 'ConcMsgBodySYSRsp', concParams.hdrParams, concParams.sysRspParams, concMuxRxMsgParams.sysRsp, 'rx');
}

// Concerto Mux TX Message structure
var NC_CMD_RSP = obj.userLib.concMsgGen(obj, 'cmd_rsp_', 'ConcMsgBodyCMDRsp', concParams.hdrParams, concParams.ncCmdRspParams, concMuxTxMsgParams.ncCmdRsp, 'tx');
var DTW_RSP    = obj.userLib.concMsgGen(obj, 'dtw_rsp_',    'ConcMsgBodyDTWRsp',   concParams.hdrParams, concParams.dtwRspParams,   concMuxTxMsgParams.dtwRsp,   'tx');
var DTWDBG_REQ = obj.userLib.concMsgGen(obj, 'dtw_dbg_req_', 'ConcMsgBodyDTWDBGReq', concParams.hdrParams, concParams.dtwDbgReqParams, concMuxTxMsgParams.dtwDbgReq, 'tx');
var RBR_RSP    = obj.userLib.concMsgGen(obj, 'rbr_rsp_',    'ConcMsgBodyRBRRsp',   concParams.hdrParams, concParams.rbrRspParams,   concMuxTxMsgParams.rbrRsp,   'tx');
var STR_REQ    = obj.userLib.concMsgGen(obj, 'str_req_',    'ConcMsgBodySTRReq',   concParams.hdrParams, concParams.strReqParams,   concMuxTxMsgParams.strReq,   'tx');
var MRD_RSP    = obj.userLib.concMsgGen(obj, 'mrd_rsp_',    'ConcMsgBodyMRDRsp',   concParams.hdrParams, concParams.mrdRspParams,   concMuxTxMsgParams.mrdRsp,   'tx');
var DTR_REQ    = obj.userLib.concMsgGen(obj, 'dtr_req_',    'ConcMsgBodyDTRReq',   concParams.hdrParams, concParams.dtrReqParams,   concMuxTxMsgParams.dtrReq,   'tx');
 /* istanbul ignore else env ncore_3p6, ncore_3p7*/
if (useSysReqSender) {
var SYS_REQ_TX = obj.userLib.concMsgGen(obj, 'sys_req_tx_', 'ConcMsgBodySYSReq', concParams.hdrParams, concParams.sysReqParams, concMuxTxMsgParams.sysReq, 'tx');
}

var CONC_TX_INTF = [];
var CONC_RX_INTF = [];
CONC_TX_INTF.push(NC_CMD_RSP, DTW_RSP, RBR_RSP, STR_REQ, MRD_RSP, DTR_REQ);
//not a user settable parameter.
 /* istanbul ignore else env ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7*/
if(useTrace) { 
CONC_TX_INTF.push(DTWDBG_REQ); 
}
 /* istanbul ignore else env ncore_3p6, ncore_3p7*/
if (useSysReqSender){
CONC_TX_INTF.push(SYS_REQ_TX);
}

CONC_RX_INTF.push(CMD_REQ, MRD_REQ, RBR_REQ, STR_RSP, DTR_RSP, DTW_REQ);

//not a user settable parameter.
 /* istanbul ignore else env ncore_3p2, ncore_3p4,ncore_3p6, ncore_3p7 */
if(useTrace) { 
CONC_RX_INTF.push(DTWDBG_RSP); 
}
 /* istanbul ignore else env ncore_3p6, ncore_3p7*/
if (useSysReqSender) {
CONC_RX_INTF.push(SYS_RSP_RX);
}
//console.log("DMI:CONC_RX_INTF = \n"+JSON.stringify(CONC_RX_INTF,null,8));
// Concerto Message Interfaces generation
var CONC_INTF = {};
CONC_INTF['CMDReqInterface']  = CMD_REQ.signals;
CONC_INTF['MRDReqInterface']  = MRD_REQ.signals;
CONC_INTF['RBReqInterface']   = RBR_REQ.signals;
CONC_INTF['STRRespInterface'] = STR_RSP.signals;
CONC_INTF['DTRRespInterface'] = DTR_RSP.signals;
CONC_INTF['DTWReqInterface']  = DTW_REQ.signals;
CONC_INTF['NCCMDRespInterface'] = NC_CMD_RSP.signals;
CONC_INTF['DTWRespInterface']   = DTW_RSP.signals;
CONC_INTF['RBRRespInterface']   = RBR_RSP.signals;
CONC_INTF['STRReqInterface']    = STR_REQ.signals;
CONC_INTF['MRDRespInterface']   = MRD_RSP.signals;
CONC_INTF['DTRReqInterface']    = DTR_REQ.signals;
//not user settable
 /* istanbul ignore else env ncore_3p2, ncore_3p4,ncore_3p6, ncore_3p7 */
if(useTrace) { 
CONC_INTF['DTWDBGReqInterface']  = DTWDBG_REQ.signals;
CONC_INTF['DTWDBGRespInterface']   = DTWDBG_RSP.signals;
} else {
CONC_INTF['DTWDBGReqInterface']  = DTW_REQ.signals;
CONC_INTF['DTWDBGRespInterface']   = DTW_RSP.signals;
}
 /* istanbul ignore else env ncore_3p6, ncore_3p7*/
if (useSysReqSender) {
CONC_INTF['SYSReqTxInterface'] = SYS_REQ_TX.signals;
CONC_INTF['SYSRspRxInterface'] = SYS_RSP_RX.signals;
}



var wDwid                       = CONC_INTF['DTRReqInterface'] ['dwid'];
var wCmType                     = CONC_INTF["CMDReqInterface"] ["cm_type"];
var wAiuTransId                 = CONC_INTF["CMDReqInterface"] ["message_id"];
var wQos                        = CONC_INTF["CMDReqInterface"] ["qos"];
var wSize                       = CONC_INTF["MRDReqInterface"] ["size"];
var wIntfSize                       = CONC_INTF["MRDReqInterface"] ["intf_size"];
var nWriteDataBuffer            = 4;
var wBeats = Math.log2(nBeats);
var wWriteDataBufferId =Math.log2(nWriteDataBuffer) + wBeats
var nDtwMergeMrdLateInFlight    = obj.userLib.ParamDefaultGet(obj.lib, 'nDtwMergeMrdLateInFlight',  'int',  16);
var nMrdLateInFlight            = obj.userLib.ParamDefaultGet(obj.lib, 'nMrdLateInFlight',  'int',  16); 
var wRdUser                     = CONC_INTF["CMDReqInterface"] ["aux"];
var wWrUser                     = wRdUser;
var wWrDataUser                 = CONC_INTF['DTWReqInterface'].user;
//========================================================
// RTT bundle and interfaces
//========================================================

var rttLookup= {
    dwid:           wDwid/(wData/64),
    cm_type:        wCmType,
    fill:           1,
    vz:             1,
    aiu_id:         wInitiatorId,
    es:             1,
    aiu_trans_id:   wAiuTransId,
    ns:             1,
    es:             1,
    size:           wSize,
    intf_size:      wIntfSize,
    mpf1:           CONC_INTF['CMDReqInterface']['mpf1'],
    qos:            wQos,
    trans_id:       wWriteDataBufferId,
    late_resp_id:   Math.max(Math.ceil(Math.log2(nDtwMergeMrdLateInFlight)), Math.ceil(Math.log2(nMrdLateInFlight))),
    tm:             1,
    user:	    wRdUser,
    addr : wAddr
}
if(obj.lib.getParam("nExclusiveEntries")>0){
    rttLookup["ex_pass"]  =1 ;
}
//ASILB without duplication not suport in Ncore3.7
 /* istanbul ignore if env ncore_3p7*/
if (ASILB){
    var rtt_flop_bundle = { d_tt_req_alloc_bundle_vec : bundleFunctions.getBundleWidth(rttLookup,['dwid', 'fill'],u.bundle),
        en_tt_req_alloc_bundle_vec : cmpInfo.nRttCtrlEntries,
        q_tt_req_alloc_bundle_vec : - bundleFunctions.getBundleWidth(rttLookup,['dwid', 'fill'],u.bundle) * cmpInfo.nRttCtrlEntries
        };
    
    var RTT_FLOP_INTERFACE={
        modulePrefix: "", 
        localPrefix: "rtt_", 
        interface: rtt_flop_bundle
        };
}


//========================================================
// WTT bundle and interfaces
//========================================================



var wttLookup = {
    tm          : 1,
    qos         : wQos,
    vz          : 1,
    cm_type     : wCmType,
    aiu_id      : wInitiatorId,
    aiu_trans_id: wAiuTransId,
    user	: wWrUser,
    addr    :wAddr,
    ns      : 1
}
if (obj.lib.getParam("nExclusiveEntries")>0){
    wttLookup["ex_pass"]=1;
    wttLookup["es"]=1;
}
//ASILB without duplication not suport in Ncore3.7
 /* istanbul ignore if env ncore_3p7*/
if (ASILB){
    var wtt_flop_bundle={d_tt_req_alloc_bundle_vec : bundleFunctions.getBundleWidth(wttLookup,[],u.bundle),
        en_tt_req_alloc_bundle_vec : cmpInfo.nWttCtrlEntries,
        q_tt_req_alloc_bundle_vec : - bundleFunctions.getBundleWidth(wttLookup,[],u.bundle) * cmpInfo.nWttCtrlEntries}
    
    var WTT_FLOP_INTERFACE= {        modulePrefix: "", 
                localPrefix: "wtt_", 
                interface: wtt_flop_bundle
                };
            }


//========================================================
// Coherent Rb buffer bundle and interfaces
//========================================================


var c_rbidBuffer = {
                tm:           CONC_INTF['RBReqInterface']['tm'],
                qos:          wQos,
                initiator_id: CONC_INTF['RBReqInterface']['initiator_id'],
                aux:          CONC_INTF['RBReqInterface']['aux'],
                size:         CONC_INTF['RBReqInterface']['size'],
                ns:           CONC_INTF['RBReqInterface']['ns'],
                pr:           CONC_INTF['RBReqInterface']['pr'],
                cm_type:      CONC_INTF['RBReqInterface']["cm_type"],
                vz:           CONC_INTF['RBReqInterface']['vz'],
                mw:           CONC_INTF['RBReqInterface']['mw'],
                ca:           CONC_INTF['RBReqInterface']['ca'],
                ac:           CONC_INTF['RBReqInterface']['ac'],
                generation_id:1,
                priority :    CONC_INTF['RBReqInterface']['priority'] ,
                addr:         CONC_INTF['RBReqInterface']["addr"],
                ns:           CONC_INTF['RBReqInterface']["ns"]
            }

//ASILB without duplication not suport in Ncore3.7
/* istanbul ignore next env ncore_3p7*/
if (ASILB){
    var c_rb_buffer_flop_bundle={   d_rb_buffer_vec : bundleFunctions.getBundleWidth(c_rbidBuffer,[],u.bundle) * cmpInfo.nDceRbEntries,
                                    en_rb_buffer_vec : cmpInfo.nDceRbEntries,
                                    q_rb_buffer_vec : - bundleFunctions.getBundleWidth(c_rbidBuffer,[],u.bundle) * cmpInfo.nDceRbEntries}
    
    var C_RB_FLOP_INTERFACE= {      modulePrefix: "", 
                                    localPrefix: "c_", 
                                    interface: c_rb_buffer_flop_bundle
                };
            }


//========================================================
// Non Coherent Rb buffer bundle and interfaces
//========================================================
var nc_rbidBuffer = {
    qos:          CONC_INTF['RBReqInterface']['qos'],
    initiator_id: CONC_INTF['RBReqInterface']['initiator_id'],
    size:         CONC_INTF['RBReqInterface']['size'],
    ns:           CONC_INTF['RBReqInterface']['ns'],
    pr:           CONC_INTF['RBReqInterface']['pr'],
    es:           1,
    cm_type:      CONC_INTF['RBReqInterface']['cm_type'],
    aux:          CONC_INTF['RBReqInterface']['aux'],
    vz:           CONC_INTF['RBReqInterface']['vz'],
    mpf1:         CONC_INTF["DTWReqInterface"]['mpf1'] * useAtomic,
    mpf2:         CONC_INTF["CMDReqInterface"]["mpf2"],
    mw:           CONC_INTF['RBReqInterface']['mw'],
    ca:           CONC_INTF['RBReqInterface']['ca'],
    ac:           CONC_INTF['RBReqInterface']['ac'],
    intf_size:    CONC_INTF['CMDReqInterface']['intf_size'],
    addr :  CONC_INTF['CMDReqInterface']['addr']
};
if (u.getParam("nExclusiveEntries")>0){
    nc_rbidBuffer["ex_pass"]=1;
}

//ASILB without duplication not suport in Ncore3.7
/* istanbul ignore if env ncore_3p7*/
if (ASILB){
var nc_rb_buffer_flop_bundle={   d_rb_buffer_vec : bundleFunctions.getBundleWidth(nc_rbidBuffer,[],u.bundle) * cmpInfo.nDmiRbEntries,
                        en_rb_buffer_vec : cmpInfo.nDmiRbEntries,
                        q_rb_buffer_vec : - bundleFunctions.getBundleWidth(nc_rbidBuffer,[],u.bundle) * cmpInfo.nDmiRbEntries}

var NC_RB_FLOP_INTERFACE= {      modulePrefix: "", 
                        localPrefix: "nc_", 
                        interface: nc_rb_buffer_flop_bundle
    };
}

//========================================================
// Non Coherent rb data buffer bundle and interfaces
//========================================================
var nc_dataBuffer = {
    intf_size:    CONC_INTF['DTWReqInterface']['intf_size'],
    aux:          CONC_INTF['DTWReqInterface']['aux'],
    initiator_id: CONC_INTF['DTWReqInterface']['initiator_id'],
    message_id:   CONC_INTF['DTWReqInterface']['message_id'],
    cm_type:      CONC_INTF['DTWReqInterface']['cm_type'],
    rb_id :       CONC_INTF['DTWReqInterface']['rb_id'],
    cm_status:    CONC_INTF['DTWReqInterface']['cm_status'],
    rl:           CONC_INTF['DTWReqInterface']['rl'],
    primary:      CONC_INTF['DTWReqInterface']['primary'],
    mpf2:         CONC_INTF['DTWReqInterface']['mpf2'],
    dwid:         CONC_INTF['DTWReqInterface']['dwid'],
    dbad:         CONC_INTF['DTWReqInterface']['dbad'],
    tm:           CONC_INTF['DTWReqInterface']['tm'],
    last:         1,
    data:         obj.lib.getParam('wData'),
    be:           obj.lib.getParam('wData')/8,
    user:         (CONC_INTF['DTWReqInterface']["user"] == undefined)?  /* istanbul ignore next env ncore_3p2,ncore_3p4,ncore_3p6, ncore_3p7 */ 0 : CONC_INTF['DTWReqInterface']["user"]
};

var nBeats              = (1<<wCacheLineOffset) / (CONC_INTF['DTWReqInterface']["data"]/8);

//ASILB without duplication not suport in Ncore3.7
 /* istanbul ignore if env ncore_3p7*/
if (ASILB){
var nc_data_buffer_flop_bundle={   d_data_buffer_vec : bundleFunctions.getBundleWidth(nc_dataBuffer,[],u.bundle),
                        en_data_buffer_vec : cmpInfo.nDmiRbEntries * nBeats,
                        q_data_buffer_vec : - bundleFunctions.getBundleWidth(nc_dataBuffer,[],u.bundle) * cmpInfo.nDmiRbEntries * nBeats}

var NC_DATA_FLOP_INTERFACE= {       modulePrefix: "", 
                                    localPrefix: "nc_", 
                                    interface: nc_data_buffer_flop_bundle
    };
}

//========================================================
// End Non Coherent rb data buffer bundle and interfaces
//========================================================
// clk interface params generation
var interfaceFunc       = new obj.userLib[interfaces.clkInt.interface];
var clkInterface        = interfaceFunc.getSignalsBundle(interfaces.clkInt.params);
var clkInterfaceName    = interfaces.clkInt.name; 
var clkInterfaceParam   = interfaces.clkInt.params;
var blkClkGateOn        = interfaces.clkInt.blkClkGateOn;
var intClkInterface     = { clk: 1, reset_n: 1 }; 

//========================================================
// Cmd skid buffer bundle, parameter and interfaces
//========================================================
var CMDReqSkidInterface = Object.keys(CONC_INTF['CMDReqInterface']).reduce((CMDReqSkidInterface, key) =>
{
    CMDReqSkidInterface[key] = CONC_INTF['CMDReqInterface'][key];
    return CMDReqSkidInterface;
}, {}
);
if (fnEnableQos){
    CMDReqSkidInterface["h_priority"] = 1;
}


if (CMDOverflowBufInSRAM) {
var CMDReq_sb_width = m.bundleFunctions.getBundleWidth(CMDReqSkidInterface, ['valid', 'ready'],  u.bundle);
/* istanbul ignore next env ncore_3p7 */ 
var CMDReq_sb_mem_addr_width =  bufferSize.CMDReqSkidfifo > 0 ? utilFunctions.log2ceil( bufferSize.CMDReqSkidfifo) : 0;

var CMDReq_sb_ecc_width = utilFunctions.getErrorEncodingWidth(fnErrDetectCorrect, CMDReq_sb_mem_addr_width + CMDReq_sb_width);

var CMDReq_sb_mem_data_width = CMDReq_sb_width + CMDReq_sb_ecc_width;

var CMDReq_sb_memoryType = CMDReq_sb_mem_gen["fnMemType"] ;
}

var cmdSkidBufferParams = {
    assertOn            : assertOn,
    useSmallArea        : 1,
    bypass              : 1,
    useQos              : fnEnableQos,
    useAge              : 1,
    wStarvThreshold     : fnEnableQos*wStarvThreshold,
    reqInterface        : CMDReqSkidInterface,
    clkInterface        : intClkInterface,
    priorityThreshold   : fnEnableQos,
    bufferSize      : {Skidfifo : bufferSize.CMDReqSkidfifo, SkidBuffer :bufferSize.CMDReqSkidBuffer},
    useOutputFifo       : 0,
    priAgeBypass        : 1,
    useSramFifo         : CMDOverflowBufInSRAM,
}

if (CMDOverflowBufInSRAM) {
cmdSkidBufferParams["sb_memoryType"]            = CMDReq_sb_memoryType;
cmdSkidBufferParams["sb_width"     ]            = CMDReq_sb_width;
cmdSkidBufferParams["sb_mem_addr_width" ]       = CMDReq_sb_mem_addr_width;
cmdSkidBufferParams["sb_mem_data_width" ]       = CMDReq_sb_mem_data_width;
cmdSkidBufferParams["sb_fnErrDetectCorrect"]    = fnErrDetectCorrect;
}

var cmdSkidBufferPorts = {
    empty               : 'cmd_skid_buffer_empty',
};
if (CMDOverflowBufInSRAM) {
cmdSkidBufferPorts["sb_mem_write_en"]  = "CmdReq_sb_mem_write_en";
cmdSkidBufferPorts["sb_mem_write_addr"]= "CmdReq_sb_mem_write_addr";
cmdSkidBufferPorts["sb_mem_write_data"]= "CmdReq_sb_mem_write_data";
cmdSkidBufferPorts["sb_mem_read_en"]   = "CmdReq_sb_mem_read_en";
cmdSkidBufferPorts["sb_mem_read_addr"] = "CmdReq_sb_mem_read_addr";
cmdSkidBufferPorts["sb_mem_read_data"] = "CmdReq_sb_mem_read_data";
cmdSkidBufferPorts["sb_mem_out_uerr"] = "CmdReq_sb_mem_out_uerr";
cmdSkidBufferPorts["sb_mem_out_cerr"] = "CmdReq_sb_mem_out_cerr";
cmdSkidBufferPorts["sb_mem_out_err_index"] = "CmdReq_sb_mem_out_err_index";

var CmdReq_sb_mem_interface = {
    CmdReq_sb_mem_write_en    : -1,
    CmdReq_sb_mem_write_addr  : -CMDReq_sb_mem_addr_width,
    CmdReq_sb_mem_write_data  : -CMDReq_sb_mem_data_width,
    CmdReq_sb_mem_read_en     : -1,
    CmdReq_sb_mem_read_addr   : -CMDReq_sb_mem_addr_width,
    CmdReq_sb_mem_read_data   :  CMDReq_sb_mem_data_width
}
}

if (fnEnableQos) {
    cmdSkidBufferPorts['starv_en']              = "cmd_skid_buffer_starv_en"         ;
    cmdSkidBufferPorts['starv_threshold']       = "cmd_skid_buffer_starv_threshold"  ; 
    cmdSkidBufferPorts['qos_disable']           = "cmd_skid_buffer_qos_disable"     ;  
    cmdSkidBufferPorts['starv_overflow_event']  = "cmd_skid_buffer_starv_overflow_event" ;
    cmdSkidBufferPorts['starv_mode']            = "cmd_skid_buffer_starv_mode"         ;
    cmdSkidBufferPorts["full"]                  = "cmd_skid_buffer_full"              ;
}

var cmdSkidBufferInterfaces =[]

cmdSkidBufferInterfaces.push({
    modulePrefix: "", 
    localPrefix: clkInterfaceName, 
    interface: intClkInterface,
    direction: "master"
});

cmdSkidBufferInterfaces.push({
    modulePrefix: "req_in_", 
    localPrefix: "cmd_req_skid_buffer_push_", 
    interface: CMDReqSkidInterface,
    direction: "master",
    exclude : []
});

cmdSkidBufferInterfaces.push({
    modulePrefix: "req_out_", 
    localPrefix: "cmd_skid_buffer_pop_", 
    interface: CMDReqSkidInterface,
    direction: "slave"
});

//========================================================
// Mrd skid buffer bundle, parameter and interfaces
//========================================================
var MRDReqSkidInterface = Object.keys(CONC_INTF['MRDReqInterface']).reduce((MRDReqSkidInterface, key) =>
{
    MRDReqSkidInterface[key] = CONC_INTF['MRDReqInterface'][key];
    return MRDReqSkidInterface;
}, {}
);


if (fnEnableQos){
    MRDReqSkidInterface["h_priority"] = 1;
}


var mrdSkidBufferParams = {
    assertOn            : assertOn,
    useQos              : fnEnableQos,
    wStarvThreshold     : fnEnableQos*wStarvThreshold,
    reqInterface        : MRDReqSkidInterface,
    clkInterface        : intClkInterface,
    bufferSize      : {Skidfifo : bufferSize.MRDReqSkidfifo, SkidBuffer :bufferSize.MRDReqSkidBuffer},
    useOutputFifo       : 0,
    priAgeBypass        :1,
    useSramFifo         : MRDOverflowBufInSRAM

}

if (MRDOverflowBufInSRAM) {
var MRDReq_sb_width = m.bundleFunctions.getBundleWidth(MRDReqSkidInterface, ['valid', 'ready'],  u.bundle);
/* istanbul ignore next env ncore_3p7 */ 
var MRDReq_sb_mem_addr_width =  bufferSize.MRDReqSkidfifo > 0 ? utilFunctions.log2ceil( bufferSize.MRDReqSkidfifo) : 0;
var MRDReq_sb_ecc_width = utilFunctions.getErrorEncodingWidth(fnErrDetectCorrect, MRDReq_sb_mem_addr_width + MRDReq_sb_width);
var MRDReq_sb_mem_data_width = MRDReq_sb_width + MRDReq_sb_ecc_width;
var MRDReq_sb_memoryType = MRDReq_sb_mem_gen["fnMemType"] ;

    mrdSkidBufferParams["sb_memoryType"]            =MRDReq_sb_memoryType;
    mrdSkidBufferParams["sb_width"     ]            =MRDReq_sb_width;
    mrdSkidBufferParams["sb_mem_addr_width" ]       =MRDReq_sb_mem_addr_width;
    mrdSkidBufferParams["sb_mem_data_width" ]       =MRDReq_sb_mem_data_width;
    mrdSkidBufferParams["sb_fnErrDetectCorrect"]    = fnErrDetectCorrect;
    }

var mrdSkidBufferPorts = {
    empty               : 'mrd_skid_buffer_empty',
};

if (MRDOverflowBufInSRAM) {
   mrdSkidBufferPorts["sb_mem_write_en"]  = "MrdReq_sb_mem_write_en";
   mrdSkidBufferPorts["sb_mem_write_addr"]= "MrdReq_sb_mem_write_addr";
   mrdSkidBufferPorts["sb_mem_write_data"]= "MrdReq_sb_mem_write_data";
   mrdSkidBufferPorts["sb_mem_read_en"]   = "MrdReq_sb_mem_read_en";
   mrdSkidBufferPorts["sb_mem_read_addr"] = "MrdReq_sb_mem_read_addr";
   mrdSkidBufferPorts["sb_mem_read_data"] = "MrdReq_sb_mem_read_data";
   mrdSkidBufferPorts["sb_mem_out_uerr"] = "MrdReq_sb_mem_out_uerr";
   mrdSkidBufferPorts["sb_mem_out_cerr"] = "MrdReq_sb_mem_out_cerr";
   mrdSkidBufferPorts["sb_mem_out_err_index"] = "MrdReq_sb_mem_out_err_index";
}
var MrdReq_sb_mem_interface = {
    MrdReq_sb_mem_write_en    : -1,
    MrdReq_sb_mem_write_addr  : -MRDReq_sb_mem_addr_width,
    MrdReq_sb_mem_write_data  : -MRDReq_sb_mem_data_width,
    MrdReq_sb_mem_read_en     : -1,
    MrdReq_sb_mem_read_addr   : -MRDReq_sb_mem_addr_width,
    MrdReq_sb_mem_read_data   :  MRDReq_sb_mem_data_width
}

if (fnEnableQos) {
   mrdSkidBufferPorts['starv_en']              = "mrd_skid_buffer_starv_en"         ;
   mrdSkidBufferPorts['starv_threshold']       = "mrd_skid_buffer_starv_threshold"  ; 
   mrdSkidBufferPorts['qos_disable']           = "mrd_skid_buffer_qos_disable"     ;  
   mrdSkidBufferPorts['starv_overflow_event']  = "mrd_skid_buffer_starv_overflow_event" ;
   mrdSkidBufferPorts['starv_mode']            = "mrd_skid_buffer_starv_mode"         ;
   mrdSkidBufferPorts["full"]                  = "mrd_skid_buffer_full"              ;
}

var mrdSkidBufferInterfaces =[]

mrdSkidBufferInterfaces.push({
    modulePrefix: "", 
    localPrefix: clkInterfaceName, 
    interface: intClkInterface,
    direction: "master"
});

mrdSkidBufferInterfaces.push({
    modulePrefix: "req_in_", 
    localPrefix: "mrd_req_skid_buffer_push_", 
    interface: MRDReqSkidInterface,
    direction: "master"});

mrdSkidBufferInterfaces.push({
    modulePrefix: "req_out_", 
    localPrefix: "mrd_skid_buffer_pop_", 
    interface: MRDReqSkidInterface,
    direction: "slave"
});

//End cmd skid buffer

// SMI interface params generation
var SMI_TX_INTF = [];
var SMI_TX_INTF_DIRECTION = [];
var SMI_RX_INTF = [];
var SMI_RX_INTF_DIRECTION = [];
for(var i = 0; i< smiTxPortParams.length; i++) {
    SMI_TX_INTF.push(obj.userLib.smiPortGen(obj, smiTxPortParams[i], interfaces.smiTxInt[i].params, 'tx'));
    SMI_TX_INTF_DIRECTION.push(interfaces.smiTxInt[i].direction);
};

for(var i = 0; i < smiRxPortParams.length; i++) {
    SMI_RX_INTF.push(obj.userLib.smiPortGen(obj, smiRxPortParams[i], interfaces.smiRxInt[i].params, 'rx'));
    SMI_RX_INTF_DIRECTION.push(interfaces.smiRxInt[i].direction);
};



// AXI interface params generation
var interfaceFunc = new obj.userLib[interfaces.axiInt.interface];
var axiInterface = interfaceFunc.getSignals(interfaces.axiInt.params);
var axiInterfaceBundle = interfaceFunc.getSignalsBundle(interfaces.axiInt.params);


//native itnerface fifo


var readTransactionInterface = {
    valid:  1,
    ready: -1,
    addr:   wAddr,
    ns:     1,
    pr:     1,
    es:     1,
    size:   wSize,
    id:     axiInterfaceBundle["ar_"]["id"],
    qos:    wQos,
    user:   wRdUser
}

var writeTransactionInterface = {
    valid:  1,
    ready: -1,
    addr:   wAddr,
    vz:     1,
    ns:     1,
    pr:     1,
    es:     1,
    id:     axiInterfaceBundle["aw_"]["id"],
    size:   wSize,
    qos:    wQos,
    user:   wWrUser   
}

// Read Data Interface: used in transaction control logic
var readDataInterface = {
    valid:  1,
    ready: -1,
    last:   1,
    first:  1,
    resp:  -axiInterfaceBundle.r_.resp,
    id:    -axiInterfaceBundle.r_.id,
    data:   wData,
    user:  -axiInterfaceBundle.r_.user
}


var writeDataInterface = {
    valid:           1,
    ready:          -1,
    last:            1,
    data:            obj.lib.getParam('wData'),
    be:              obj.lib.getParam('wData')/8,
    poison:          1,
    user:            wWrDataUser        
}

var wBResp = axiInterfaceBundle.b_.resp > 0 ?  /* istanbul ignore next env ncore_3p0, ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */ axiInterfaceBundle.b_.resp : -axiInterfaceBundle.b_.resp;
var writeResponseInterface = {
    valid:         1,
    ready:        -1,
    vz:            1,
    tm:            1,
    qos:           wQos,
    cm_type:       wCmType,
    aiu_id:        wInitiatorId,
    aiu_trans_id:  wAiuTransId,
    resp:          wBResp, 
    user: 	   wWrUser,
}
var ntvCsrInterface = {};

var DMI_NATIVE_INTERFACE_INTF =[]


DMI_NATIVE_INTERFACE_INTF.push({modulePrefix: '',              localPrefix: clkInterfaceName, interface: intClkInterface})
DMI_NATIVE_INTERFACE_INTF.push({modulePrefix: 'read_trans_',   localPrefix: 'read_trans_', interface: readTransactionInterface, exclude:["addr"]})
DMI_NATIVE_INTERFACE_INTF.push({modulePrefix: 'write_trans_',  localPrefix: 'write_trans_', interface: writeTransactionInterface, exclude:["addr"]})
DMI_NATIVE_INTERFACE_INTF.push({modulePrefix: 'read_data_',    localPrefix: 'read_data_', interface: readDataInterface})
DMI_NATIVE_INTERFACE_INTF.push({modulePrefix: 'write_data_',   localPrefix: 'write_data_', interface: writeDataInterface})
DMI_NATIVE_INTERFACE_INTF.push({modulePrefix: 'write_resp_',   localPrefix: 'write_resp_', interface: axiInterfaceBundle["b_"]})
DMI_NATIVE_INTERFACE_INTF.push({modulePrefix: '',              localPrefix: 'axi_mst_placeholder_', interface: axiInterfaceBundle})
DMI_NATIVE_INTERFACE_INTF.push({modulePrefix: '',              localPrefix: 'ntvInt_', interface: ntvCsrInterface})

var DMI_NATIVE_INTERFACE_PORTS = {     read_trans_addr: 'read_trans_addr_t',
                                       write_trans_addr: 'write_trans_addr_t'
                                                                    };


// APB interface params generation
var interfaceFunc = new obj.userLib[interfaces.apbInt.interface];
var apbInterface = interfaceFunc.getSignalsBundle(interfaces.apbInt.params);

// IRQ interface params generation
var interfaceFunc = new obj.userLib[interfaces.irqInt.interface];
var irqInterface = interfaceFunc.getSignalsBundle(interfaces.irqInt.params);

// Unit Id interface params generation
var interfaceFunc = new obj.userLib[interfaces.uIdInt.interface];
var unitIdInterface = interfaceFunc.getSignalsBundle(interfaces.uIdInt.params);
var unitIdInterfaceName = interfaces.uIdInt.name;
// PIN interface params generation
var havePinInterface = interfaces.bistDebugDisableInt && !interfaces.bistDebugDisableInt._SKIP_;
// Unit Dve Id interface params generation
var haveDveInterface = interfaces.uSysDveIdInt !== undefined;
//not user settable
 /* istanbul ignore else env ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7*/
if (haveDveInterface) {
  var interfaceFunc         = new obj.userLib[interfaces.uSysDveIdInt.interface];
  var uDveIdInterface       = interfaceFunc.getSignals(interfaces.uSysDveIdInt.params);
  var uDveIdInterfaceBundle = interfaceFunc.getSignalsBundle(interfaces.uSysDveIdInt.params);
  var uDveIdInterfaceName   = interfaces.uSysDveIdInt.name;
}

// System Unit Id interface params generation
var interfaceFunc = new obj.userLib[interfaces.uSysIdInt.interface];
var sysUnitIdInterface = interfaceFunc.getSignalsBundle(interfaces.uSysIdInt.params);
var sysUnitIdInterfaceName = interfaces.uSysIdInt.name;
// Resiliency interface params generation
if(useResiliency) {
  var interfaceFunc         = new obj.userLib[interfaces.bistInt.interface];
  var bistInterface         = interfaceFunc.getSignals(interfaces.bistInt.params);
  var bistInterfaceBundle   = interfaceFunc.getSignalsBundle(interfaces.bistInt.params);
  var bistInterfaceName     = interfaces.bistInt.name;

  var interfaceFunc          = new obj.userLib[interfaces.faultInt.interface];
  var faultInterface         = interfaceFunc.getSignals(interfaces.faultInt.params);
  var faultInterfaceBundle   = interfaceFunc.getSignalsBundle(interfaces.faultInt.params);
  var faultInterfaceName     = interfaces.faultInt.name;

    if (enableUnitDuplication) {
var interfaceFunc            = new obj.userLib[interfaces.checkClkInt.interface];
var checkClkInterface        = interfaceFunc.getSignalsBundle(interfaces.checkClkInt.params);
var checkClkInterfaceName    = interfaces.checkClkInt.name; 
var checkClkInterfaceParam   = interfaces.checkClkInt.params;
var checkBlkClkGateOn        = interfaces.checkClkInt.blkClkGateOn;
    }
}

if(usePma) {
// Q-Channel Interface
var interfaceFunc        = new obj.userLib[interfaces.qInt.interface];
var qInterface           = interfaceFunc.getSignals(interfaces.qInt.params);
var qInterfaceBundle     = interfaceFunc.getSignalsBundle(interfaces.qInt.params);
var qInterfaceName       = interfaces.qInt.name;
} else {
var qInterfaceBundle     = {};
var qInterfaceName       = '';
}

// Register Protection interface params generation
// internal Fault interface
var internalFaultInterface  = {
        placeholder_UCE         : 1,
        placeholder_CE          : 1,
        timeout_error_UCE       : 1,
        smc_tag_UCE             : 1,
        smc_tag_CE              : 1,
        smc_data_UCE            : 1,
        smc_data_CE             : 1,
        c_wr_buff_UCE           : 1,
        c_wr_buff_CE            : 1,
        rd_buffer_UCE           : 1,
        rd_buffer_CE            : 1,
        target_id_UCE           : 1,
        native_wr_resp_UCE      : 1,
        native_rd_resp_UCE      : 1,
    };

if(CMDOverflowBufInSRAM){
    internalFaultInterface["cmd_skid_buffer_uce"]   =1;
    internalFaultInterface["cmd_skid_buffer_ce"]   =1;
}

if(MRDOverflowBufInSRAM){
internalFaultInterface["mrd_skid_buffer_uce"]   =1;
internalFaultInterface["mrd_skid_buffer_ce"]   =1;
}
//ASILB without duplication not suport in Ncore3.7
 /* istanbul ignore else env ncore_3p7*/
if(!ASILB){
internalFaultInterface["cmux_cmd_req_CE"]= 1;
internalFaultInterface["cmux_mrd_req_CE"]= 1;
internalFaultInterface["cmux_rbr_req_CE"]= 1;
internalFaultInterface["cmux_str_rsp_CE"]= 1;
internalFaultInterface["cmux_dtr_rsp_CE"]= 1;
internalFaultInterface["cmux_dtw_req_CE"]= 1;
internalFaultInterface["cmux_dtw_dbg_rsp_CE"] = 1;
internalFaultInterface["cmux_UCE"]=1;
 /* istanbul ignore else env ncore_3p6, ncore_3p7*/
 if (useSysReqSender) {
    internalFaultInterface["cmux_sys_rsp_rx_CE"] = 1;
  }
}


// native placeholder interface params generation
if(enableNativeIntfProtection) {
  var interfaceFunc        = new obj.userLib[interfaces.userPlaceInt.interface];
  var placeInterface       = interfaceFunc.getSignals(interfaces.userPlaceInt.params);
  var placeInterfaceBundle = interfaceFunc.getSignalsBundle(interfaces.userPlaceInt.params);
  var placeInterfaceName   = interfaces.userPlaceInt.name;
  var placeInterfaceDef    = interfaces.userPlaceInt.synonyms;
  var placeInterfaceSkip   = interfaces.userPlaceInt._SKIP_;
} else {
  var placeInterface       = {};
  var placeInterfaceBundle = {};
  var placeInterfaceName   = "";
  var placeInterfaceDef    = {};
  var placeInterfaceSkip   = true;
}

// Generic interface (for memory sideband signals) params generation
  var memInterfaceFunc      = [];
  var memInterface          = [];
  var memInterfaceBundle    = [];
  var memInterfaceName      = [];
  var memInterfaceDirection = [];
  var memInterfaceDef       = [];
  var memInterfaceSkip      = [];
  var memInterfaceDict      = {};
  for (var i=0; i < interfaces.memoryInt.length; i++) {
    memInterfaceFunc.push( new obj.userLib[interfaces.memoryInt[i].interface] );
    memInterface.push( memInterfaceFunc[i].getSignals(interfaces.memoryInt[i].params) );
    memInterfaceBundle.push( memInterfaceFunc[i].getSignalsBundle(interfaces.memoryInt[i].params) );
    memInterfaceName.push( interfaces.memoryInt[i].name );
    memInterfaceDirection.push( interfaces.memoryInt[i].direction );
    memInterfaceDef.push( interfaces.memoryInt[i].synonyms );
    memInterfaceSkip.push( interfaces.memoryInt[i]._SKIP_ );
    memInterfaceDict[ interfaces.memoryInt[i].name ] = i;
  }



var ccpMemoryInterface = {};
var wrDataBufferMemoryInterface = {};
var cWrDataGen      = obj.lib.getParam('MemoryGeneration', 'wrDataMem');
var useExWrDataMem  = (cWrDataGen[0].MemType !== "NONE");
var cWrMemPorts     = "sp";
var wrBufferProtType= fnErrDetectCorrect;
var dataBuffer = {
    intf_size:    DTW_REQ.signals.intf_size,
    aux:          DTW_REQ.signals.aux,
    initiator_id: DTW_REQ.signals.initiator_id,
    message_id:   DTW_REQ.signals.message_id,
    cm_type:      DTW_REQ.signals.cm_type,
    rb_id :       DTW_REQ.signals.rb_id-1,
    cm_status:    DTW_REQ.signals.cm_status,
    rl:           DTW_REQ.signals.rl,
    primary:      DTW_REQ.signals.primary,
    mpf1:         DTW_REQ.signals.mpf1,
    mpf2:         DTW_REQ.signals.mpf2,
    dwid:         DTW_REQ.signals.dwid,
    dbad:         DTW_REQ.signals.dbad,
    tm:           DTW_REQ.signals.tm,
    valid:        1,
    ready:       -1,
    last:         1,
    data:         wData,
    be:           wData/8,
    user:         DTW_REQ.signals.user        
};
var cWrDataWidth    = bundleFunctions.getBundleWidth( dataBuffer, ['valid', 'ready'], obj.lib.bundle);
var cWrDataParam    = memFunctions.dataBufferMemoryParams(cWrDataWidth, cmpInfo.nDceRbEntries, nBeats, nWrDataBanks, wrBufferProtType, {"sramAddressProtection" : 1});
var wrDataStructures= [];
for (var i = 0; i < nWrDataBanks; i++) {
    wrDataStructures[i] =
            memFunctions.createMemoryDataStructure(
                cWrDataGen[0],
                cWrDataParam,
                cWrMemPorts,
                0, // biten
                cWrDataGen[0].rtlPrefixString,
                '',
                0 // unused
            );
}
// pass information to lower hierarchy
cWrDataParam['nBanks'] = nWrDataBanks;
cWrDataParam['nPorts'] = cWrMemPorts;
// External Memory signals
for (var i = 0; i < nWrDataBanks; i++) {
    if (wrDataStructures[i].memoryType === "SYNOPSYS") {
        /* istanbul ignore if env ncore_3p0, ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */
        if (Object.keys(wrDataStructures[i].signals).length > 0) {
            utilFunctions.defineMasterPortsFromInterface(wrDataStructures[i].rtlPrefixString + i + '_', wrDataStructures[i].signals, obj.lib.port);
        }
    }
}

for(var bank = 0; bank < wrDataStructures.length; bank++) {
    for(var signal in wrDataStructures[bank].controlSignals) {
        wrDataBufferMemoryInterface[cWrDataGen[0].rtlPrefixString+bank+'_'+signal] = wrDataStructures[bank].controlSignals[signal];
    }
}
// Read Buffer Params
var rdBufferPorts     = "sp";
var rdBufferMemoryInterface = {};
var rdBufferProtType= fnErrDetectCorrect;
if (enableReadDataInterleaving) {
    var rdBufferGen      = obj.lib.getParam('MemoryGeneration', 'rdDataMem');
    var useExRdDataMem          = (rdBufferGen[0].MemType !== "NONE") && enableReadDataInterleaving;
    var rdDataStructures= [];
    var rdBufferWidth    = bundleFunctions.getBundleWidth( readDataInterface, ['valid', 'ready','first'], obj.lib.bundle);
    var rdBufferParam   = memFunctions.dataBufferMemoryParams(rdBufferWidth, cmpInfo.nRttCtrlEntries, nBeats, nRdDataBanks, rdBufferProtType, {"sramAddressProtection" : 1});
    // pass information to lower hierarchy
    rdBufferParam['nBanks'] = nRdDataBanks;
    rdBufferParam['nPorts'] = rdBufferPorts;
    for (var i = 0; i < nRdDataBanks; i++) {
        rdDataStructures[i] =
                memFunctions.createMemoryDataStructure(
                    rdBufferGen[0],
                    rdBufferParam,
                    rdBufferPorts,
                    0, // biten
                    rdBufferGen[0].rtlPrefixString,
                    '',
                    0 // unused
                );
    }
    
    for(var bank = 0; bank < rdDataStructures.length; bank++) {
        for(var signal in rdDataStructures[bank].controlSignals) {
            rdBufferMemoryInterface[rdBufferGen[0].rtlPrefixString+bank+'_'+signal] = rdDataStructures[bank].controlSignals[signal];
        }
    }
} else {
 var useExRdDataMem = 0;   
}
//=============================================================================
// Trace CSR Interface
//=============================================================================
const CSRS                      = obj.lib.getParam('csr');
const traceRegisters		    = obj.userLib.genTraceCaptureRegisters(CSRS.spaceBlock[0].registers, "DMI");
const traceCsrIfGenerator   	= obj.userLib.createCSRInterfaceGenerator( traceRegisters );

if(useCmc) {
//NOTE: DMI passes ccpParams as the only parameter object to CCP, and CCP treats TagMemAddressProtection and DataMemAddressPrection as default parameters.
//            instanceName: 'dmi_ccp',
//            moduleName: 'ccp_top',
//            params: ccpParams,
    ccpParams['enTagpipeDatapipeDecoupleTimingFix'] = 1;
    ccpParams['TagMemAddressProtection'] = 1;
    ccpParams['DataMemAddressProtection'] = 1;
    ccpParams["WriteFullPoisonClear"] = 1;
    ccpParams["WriteFullFillPoisonClear"] = 1;
    ccpParams['usePLRU'] = usePLRU;
    ccpParams['plru_addr_w'] = log2ceil(ccpParams.nSets / ccpParams.nTagBanks);
    var ccpTagGen       = obj.lib.getParam('MemoryGeneration', 'tagMem');
    var ccpDataGen      = obj.lib.getParam('MemoryGeneration', 'dataMem');
    var ccpRpGen        = obj.lib.getParam('MemoryGeneration', 'rpMem');
    var tagMemRtlPrefix = ccpTagGen[0].rtlPrefixString;
    var dataMemRtlPrefix= ccpDataGen[0].rtlPrefixString;
    var rpMemRtlPrefix  = (ccpRpGen.length > 0) ?  /* istanbul ignore next env ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7*/  ccpRpGen[0].rtlPrefixString : "";
    var tagP            = memFunctions.ccpTagMemoryParams(obj.lib.getParam(), { sramAddressProtection : ccpParams.TagMemAddressProtection });
    var dataP           = memFunctions.ccpDataMemoryParams(obj.lib.getParam(), { sramAddressProtection : ccpParams.DataMemAddressProtection });
    var rpP             = memFunctions.ccpRpMemoryParams(obj.lib.getParam());
    var tagStructures   = [];
    var dataStructures  = [];
    var rpStructures    = [];
    var portNum         = 0; // unused
    var nSramAccess = (ccpParams.nBeatsPerBank > 1) ? 2 : 1;

    for (var i = 0; i < ccpParams.nTagBanks; i++) {
        tagStructures[i] = 
            memFunctions.createMemoryDataStructure(
                ccpTagGen[i],
                tagP,  
                'sp',
                1,
                ccpTagGen[i].rtlPrefixString, //tagMemRtlPrefix,
                '',
                portNum);

        //fixed parameter
        /* istanbul ignore if env ncore_3p0, ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */
        if (nrumem) {
            rpStructures[i] = memFunctions.createMemoryDataStructure(
                                  ccpRpGen[0],
                                  rpP,
                                  'tp',
                                  1,
                                  rpMemRtlPrefix,
                                  '',
                                  portNum);
        }
    }

    for (var i = 0; i < ccpParams.nDataBanks; i++) {
        dataStructures[i] =
            memFunctions.createMemoryDataStructure(
                ccpDataGen[i],
                dataP,
                'sp',
                0,
                ccpDataGen[i].rtlPrefixString, //dataMemRtlPrefix,
                '',
                portNum);
    }

    for (var i = 0; i < ccpParams.nTagBanks; i++) {
        if (tagStructures[i].memoryType === "SYNOPSYS") {
            /* istanbul ignore if env ncore_3p0, ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7*/
            if (Object.keys(tagStructures[i].signals).length > 0) {
                utilFunctions.defineMasterPortsFromInterface(tagStructures[i].rtlPrefixString + i + '_', tagStructures[i].signals, obj.lib.port);
            }
            //parameter not supported in 3.2
            /* istanbul ignore if env ncore_3p0, ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */
            if (nrumem) {
                if (Object.keys(rpStructures[i].signals).length > 0) {
                    utilFunctions.defineMasterPortsFromInterface(rpStructures[i].rtlPrefixString + i + '_', rpStructures[i].signals, obj.lib.port);
                }
            }
        }
    }

    for (var i = 0; i < ccpParams.nDataBanks; i++) {
        if (dataStructures[i].memoryType === "SYNOPSYS") {
            /* istanbul ignore if env ncore_3p0, ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7*/
            if (Object.keys(dataStructures[i].signals).length > 0) {
                utilFunctions.defineMasterPortsFromInterface(dataStructures[i].rtlPrefixString + i + '_', dataStructures[i].signals, obj.lib.port);
            }
        }
    }
    ccpParams['tagStructures']  = tagStructures;
    ccpParams['dataStructures'] = dataStructures;
    ccpParams['rpStructures']   = rpStructures;

   for(var bank = 0; bank < tagStructures.length; bank++) {
       for(var signal in tagStructures[bank].controlSignals) {
           ccpMemoryInterface[tagStructures[bank].rtlPrefixString+bank+'_'+signal] = tagStructures[bank].controlSignals[signal];
       }
        //parameter not supported in 3.2
        /* istanbul ignore if env ncore_3p0, ncore_3p2, ncore_3p4 , ncore_3p6, ncore_3p7*/
       if(nrumem) {
           for(var signal in rpStructures[bank].controlSignals) {
               ccpMemoryInterface[rpMemRtlPrefix+bank+'_'+signal] = rpStructures[bank].controlSignals[signal];
           }
       }
   }
   for(var bank = 0; bank < dataStructures.length; bank++) {
       for(var signal in dataStructures[bank].controlSignals) {
           ccpMemoryInterface[dataStructures[bank].rtlPrefixString+bank+'_'+signal] = dataStructures[bank].controlSignals[signal];
       }
   }

} // useCmc

// Top level Ports
//
// clk interface
obj.lib.interface(clkInterfaceName, 'slave', clkInterface);

// irq interface
obj.lib.interface(interfaces.irqInt.name, interfaces.irqInt.direction, irqInterface);


for (i=0; i<SMI_TX_INTF.length; i++) {
                                      obj.userLib.defineMasterPortsFromInterface(SMI_TX_INTF[i].name, SMI_TX_INTF[i].signals, obj.lib.port);
                                      if(SMI_TX_INTF[i].params.dpPresent) {
                                            obj.userLib.defineMasterPortsFromInterface(SMI_TX_INTF[i].name, SMI_TX_INTF[i].dpSignals, obj.lib.port);    
                                      }
                                     }
for (i=0; i<SMI_RX_INTF.length; i++) {
                                      obj.userLib.defineSlavePortsFromInterface(SMI_RX_INTF[i].name, SMI_RX_INTF[i].signals, obj.lib.port);
                                      if(SMI_RX_INTF[i].params.dpPresent) {
                                            obj.userLib.defineSlavePortsFromInterface(SMI_RX_INTF[i].name, SMI_RX_INTF[i].dpSignals, obj.lib.port);    
                                      }
                                     }

//
// AXI Interface
//
obj.lib.interface(interfaces.axiInt.name, interfaces.axiInt.direction, axiInterface);
//
// APB Interface
//
obj.lib.interface(interfaces.apbInt.name, interfaces.apbInt.direction, apbInterface);
//
// Unit Id Interface
//
obj.lib.interface(interfaces.uIdInt.name, interfaces.uIdInt.direction, unitIdInterface);
//
// Unit dve Id Interface
//
//dve always present
 /* istanbul ignore else env ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7*/
if (haveDveInterface) {
    obj.lib.interface(uDveIdInterfaceName, interfaces.uSysDveIdInt.direction, uDveIdInterface);
}
//
// Sys Unit Id Interface
//
obj.lib.interface(interfaces.uSysIdInt.name, interfaces.uSysIdInt.direction, sysUnitIdInterface);

//
// Resiliency interface
//
if(useResiliency) {
    obj.lib.interface(bistInterfaceName, interfaces.bistInt.direction, bistInterface);
    obj.lib.interface(faultInterfaceName, interfaces.faultInt.direction , faultInterface);
    if (enableUnitDuplication) {
    obj.lib.interface(checkClkInterfaceName, interfaces.checkClkInt.direction, checkClkInterface);
    }
}
//
// Placeholder Interface
//
if(enableNativeIntfProtection) {
    obj.lib.interface(placeInterfaceName, interfaces.userPlaceInt.direction , placeInterface);
}

//
// Memory Interface Sideband Signals 
//
for (var i=0; i < memInterface.length; i++) {
  if (!memInterfaceSkip[i]) {
    obj.lib.interface(memInterfaceName[i], memInterfaceDirection[i], memInterface[i]);
  }
}

if(usePma) {
//
// Q Interface
//
obj.lib.interface(qInterfaceName, interfaces.qInt.direction, qInterface);
}

//=============================================================================
// PIN Interface
//=============================================================================
if( havePinInterface ) {
  var pinInterface      = newToOldStyleInterface( interfaces.bistDebugDisableInt );
  obj.lib.interface( pinInterface.name, 'slave', pinInterface.signals);
}
//=============================================================================
// Master Trigger Interface
//=============================================================================
// trigger intf always present on 3.4 
/* istanbul ignore else env ncore_3p4,ncore_3p6, ncore_3p7 */
if( interfaces.masterTriggerInt && !interfaces.masterTriggerInt._SKIP_ ) {
  var masterTriggerInterface      = newToOldStyleInterface( interfaces.masterTriggerInt );
  obj.lib.interface( masterTriggerInterface.name, 'slave', masterTriggerInterface.signals);
}


obj.lib.setAttribute("csr", csr);

\jsend
module \=obj.lib.getModuleName()=\ (\=obj.lib.getPorts('\n')=\);

\jsbegin
    //
    // Wire Declarations
    //
\jsend

// Trace Capture Registers
\=obj.userLib.bundleFunctions.wiresFromInterface('csr_trace_',traceCsrIfGenerator.signalBundle('master'), [], obj.lib.bundle)=\
// Trace Capture DTW DBG
\=obj.userLib.bundleFunctions.wiresFromInterface('dtw_dbg_rsp_',CONC_INTF['DTWDBGRespInterface'], [], obj.lib.bundle)=\
\=obj.userLib.bundleFunctions.wiresFromInterface('dtw_dbg_req_',CONC_INTF['DTWDBGReqInterface'], [], obj.lib.bundle)=\

\jsbegin
//ASILB without duplication not suport in Ncore3.7
 /* istanbul ignore if env ncore_3p7*/
 if (ASILB){
\jsend
    \js for (var i=0; i<CONC_TX_INTF.length; i++) {
        \js if (CONC_TX_INTF[i].name!='dtw_dbg_req_') {
    \=m.bundleFunctions.wiresFromInterface(CONC_TX_INTF[i].name, CONC_TX_INTF[i].signals, [], u.bundle)=\
        \js } 
    \js }
    
    \js for (var i=0; i<CONC_RX_INTF.length; i++) {
        \js if (CONC_RX_INTF[i].name=='dtw_dbg_rsp_') {
    \=m.bundleFunctions.wiresFromInterface(CONC_RX_INTF[i].name+"prot_", CONC_RX_INTF[i].signals, [], u.bundle)=\    
        \js } else {
    \=m.bundleFunctions.wiresFromInterface(CONC_RX_INTF[i].name, CONC_RX_INTF[i].signals, [], u.bundle)=\    

        \js}
    \js}
    wire cmux_active;

    wire dmi_cmux_cmd_req_CE;
    wire dmi_cmux_mrd_req_CE;
    wire dmi_cmux_rbr_req_CE;
    wire dmi_cmux_str_rsp_CE;
    wire dmi_cmux_dtr_rsp_CE;
    wire dmi_cmux_dtw_req_CE;
    wire dmi_cmux_dtw_dbg_rsp_CE;
    wire dmi_cmux_sys_rsp_rx_CE;
    wire dmi_cmux_UCE;
   
    \js if (nExclusiveEntries==0){
        assign dmi_cmux_sys_rsp_rx_CE = 1'h0;
    \js }

\js} 


\=bundleFunctions.wiresFromInterface('dmi_', internalFaultInterface,   [], obj.lib.bundle)=\
\jsbegin
if(ccpParams.nBeatsPerBank >1){
\jsend
    wire clkby2;
    wire clkby2_en;
\jsbegin
}
\jsend
wire trace_capture_busy; \jsbegin

// trigger intf always present on 3.4 
/* istanbul ignore else env ncore_3p4,ncore_3p6, ncore_3p7 */
if( interfaces.masterTriggerInt && !interfaces.masterTriggerInt._SKIP_ ) { \jsend
wire \=masterTriggerInterface.name=\trigger_sync; \jsbegin
} \jsend

\jsbegin
if (useResiliency) {
    /* istanbul ignore else env ncore_3p4, ncore_3p6, ncore_3p7 */
    if (havePinInterface) { \jsend
wire dmi_en_debug_bist;
\=obj.lib.instance({
   instanceName: 'u_en_debug_bist_sync',
   moduleName:   'dffr_sync',
   params: {
       'width' : 1,
       'depth' : syncDepth,
   },
   ports: {
       clk      : clkInterfaceName+'clk',
       reset_n  : clkInterfaceName+'reset_n',
       in_data  : pinInterface.name+'pin',
       out_data : 'dmi_en_debug_bist'
    }
})=\
    \jsbegin
    } else { \jsend
wire dmi_en_debug_bist = 1'b1; 
    \jsbegin
    } \jsend
wire fault_checker_clk;
wire fault_checker_reset_n;
wire [\=wResThreshold-1=\:0] res_cerr_thresh;
\jsbegin
} \jsend

\js if (usePma) {
wire \=qInterfaceName=\REQn_sync;
\js }
\jsbegin
if(useCmc & ccpParams.nBeatsPerBank > 1){
    obj.lib.addToFlist(obj.lib.updateModuleName('clock_divider'));
\jsend
\=obj.lib.updateModuleName('clock_divider')=\ clock_divider_by2
  (
    .test_en (\=clkInterfaceName+"test_en"=\),
    .clk  (\=clkInterfaceName=\clk),
    .reset_n(\=clkInterfaceName=\reset_n),
    .clkby2 (clkby2),
    .clkby2_en(clkby2_en)
  );

\jsbegin
}
\jsend

\js if (useResiliency && enableUnitDuplication) {
wire dup_unit__trace_capture_busy;
wire [\=wResThreshold-1=\:0] dup_unit__res_cerr_thresh;


\jsbegin
// trigger intf always present on 3.4 
/* istanbul ignore else env ncore_3p4,ncore_3p6, ncore_3p7 */
if (interfaces.masterTriggerInt && !interfaces.masterTriggerInt._SKIP_) { \jsend
\=bundleFunctions.wiresFromInterface('dup_unit__' + masterTriggerInterface.name, masterTriggerInterface.signals, ['trigger'], obj.lib.bundle)=\
wire dup_unit__\=masterTriggerInterface.name=\trigger_sync;
wire dup_unit__\=masterTriggerInterface.name=\trigger; 
\jsbegin 
} \jsend
\=bundleFunctions.wiresFromInterface('dup_unit__' + clkInterfaceName,           clkInterface,           [], obj.lib.bundle)=\

\=bundleFunctions.wiresFromInterface('dup_unit__' + interfaces.uIdInt.name,     unitIdInterface,        [], obj.lib.bundle)=\

\jsbegin
//dve always present
 /* istanbul ignore else env ncore_3p2, ncore_3p4,ncore_3p6, ncore_3p7 */
if (haveDveInterface) {
\jsend

  \=bundleFunctions.wiresFromInterface('dup_unit__' + uDveIdInterfaceName,     uDveIdInterface,        [], obj.lib.bundle)=\

\jsbegin
    }
\jsend

// Trace Capture DTW DBG
\=obj.userLib.bundleFunctions.wiresFromInterface('dup_unit__dtw_dbg_req_',CONC_INTF['DTWDBGReqInterface'], [], obj.lib.bundle)=\
\=obj.userLib.bundleFunctions.wiresFromInterface('dup_unit__dtw_dbg_rsp_',CONC_INTF['DTWDBGRespInterface'], [], obj.lib.bundle)=\
\=obj.userLib.bundleFunctions.wiresFromInterface('dup_unit__csr_trace_',traceCsrIfGenerator.signalBundle('master'), [], obj.lib.bundle)=\

\=bundleFunctions.wiresFromInterface('dup_unit__' + interfaces.apbInt.name,     apbInterface,           [], obj.lib.bundle)=\

\=bundleFunctions.wiresFromInterface('dup_unit__' + interfaces.irqInt.name,     irqInterface,           [], obj.lib.bundle)=\

\=bundleFunctions.wiresFromInterface('dup_unit__' + interfaces.axiInt.name,     axiInterface,           [], obj.lib.bundle)=\

\=bundleFunctions.wiresFromInterface('dup_unit__dmi_',                          internalFaultInterface, [], obj.lib.bundle)=\
\jsbegin
if(ccpParams.nBeatsPerBank >1){
\jsend
    wire dup_unit__clkby2_en;
\jsbegin
}
\jsend
\=bundleFunctions.wiresFromInterface('dup_unit__' + interfaces.uSysIdInt.name,  sysUnitIdInterface,     [], obj.lib.bundle)=\
\js if (enableNativeIntfProtection) {
\=bundleFunctions.wiresFromInterface('dup_unit__' + placeInterfaceName,  placeInterface,     [], obj.lib.bundle)=\
\js }

\js if(usePma) {
\=bundleFunctions.wiresFromInterface('dup_unit__' + qInterfaceName,  qInterface,     ['REQn'], obj.lib.bundle)=\
wire dup_unit__\=qInterfaceName=\REQn;
wire dup_unit__\=qInterfaceName=\REQn_sync;
\js }




\js for (var i=0; i < SMI_TX_INTF.length; i++) {
\=bundleFunctions.wiresFromInterface('dup_unit__' + SMI_TX_INTF[i].name, SMI_TX_INTF[i].signals, [], obj.lib.bundle)=\
    \js if (SMI_TX_INTF[i].params.dpPresent) {
\=bundleFunctions.wiresFromInterface('dup_unit__' + SMI_TX_INTF[i].name,SMI_TX_INTF[i].dpSignals, [], obj.lib.bundle)=\
    \js }
\js };

\js for (var i=0; i < SMI_RX_INTF.length; i++) {
\=bundleFunctions.wiresFromInterface('dup_unit__' + SMI_RX_INTF[i].name, SMI_RX_INTF[i].signals, [], obj.lib.bundle)=\
    \js if (SMI_RX_INTF[i].params.dpPresent) {
\=bundleFunctions.wiresFromInterface('dup_unit__' + SMI_RX_INTF[i].name, SMI_RX_INTF[i].dpSignals, [], obj.lib.bundle)=\
    \js }
\js };


\js }

\jsbegin
if(useExRdDataMem) {
    var str = '';
    for (var i = 0; i < nRdDataBanks; i++) {
        var rtlPrefixString = rdDataStructures[i].rtlPrefixString + i;
        var memoryControlInterface = rdDataStructures[i].controlSignals;
        str += utilFunctions.string_defineSignalsFromInterface('mem__' + rtlPrefixString + '_', memoryControlInterface);
        str += utilFunctions.string_defineSignalsFromInterface(''      + rtlPrefixString + '_', memoryControlInterface);
        if (useResiliency & enableUnitDuplication) {
            str += utilFunctions.string_defineSignalsFromInterface('dup_unit__' + rtlPrefixString + '_', memoryControlInterface);
        }

    }
\jsend
\=str=\
\jsbegin
} \jsend

\jsbegin
    if(useExWrDataMem) {
        var str = '';
        for (var i = 0; i < nWrDataBanks; i++) {
            var rtlPrefixString = wrDataStructures[i].rtlPrefixString + i;
            var memoryControlInterface = wrDataStructures[i].controlSignals;
            str += utilFunctions.string_defineSignalsFromInterface('mem__' + rtlPrefixString + '_', memoryControlInterface);
            str += utilFunctions.string_defineSignalsFromInterface(''      + rtlPrefixString + '_', memoryControlInterface);
            if (useResiliency & enableUnitDuplication) {
                str += utilFunctions.string_defineSignalsFromInterface('dup_unit__' + rtlPrefixString + '_', memoryControlInterface);
            }

        }
\jsend
\=str=\
\js }
\jsbegin
    if(useCmc) {
        var str = '';
        for (var i = 0; i < ccpParams.nTagBanks; i++) {
            var rtlPrefixString = tagStructures[i].rtlPrefixString + i;
            var memoryControlInterface = tagStructures[i].controlSignals;
            str += utilFunctions.string_defineSignalsFromInterface('mem__' + rtlPrefixString + '_', memoryControlInterface);
            str += utilFunctions.string_defineSignalsFromInterface(''      + rtlPrefixString + '_', memoryControlInterface);
            if (useResiliency & enableUnitDuplication) {
            str += utilFunctions.string_defineSignalsFromInterface('dup_unit__' + rtlPrefixString + '_', memoryControlInterface);
            }
            //parameter not supported in 3.2
            /* istanbul ignore if env ncore_3p0, ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */
            if(nrumem) {
                var rtlPrefixString = rpStructures[i].rtlPrefixString + i;
                var memoryControlInterface = rpStructures[i].controlSignals;
                str += utilFunctions.string_defineSignalsFromInterface('mem__' + rtlPrefixString + '_', memoryControlInterface);
                str += utilFunctions.string_defineSignalsFromInterface(''      + rtlPrefixString + '_', memoryControlInterface);
                if (useResiliency & enableUnitDuplication) {
                    str += utilFunctions.string_defineSignalsFromInterface('dup_unit__' + rtlPrefixString + '_', memoryControlInterface);
                }

            }
        }

\jsend
\=str=\
\jsbegin
        var str = '';
        for (var i = 0; i < ccpParams.nDataBanks; i++) {
            var rtlPrefixString = dataStructures[i].rtlPrefixString + i;
            var memoryControlInterface = dataStructures[i].controlSignals;
            str += utilFunctions.string_defineSignalsFromInterface('mem__' + rtlPrefixString + '_', memoryControlInterface);
            str += utilFunctions.string_defineSignalsFromInterface(''      + rtlPrefixString + '_', memoryControlInterface);
            if (useResiliency & enableUnitDuplication) {
                str += utilFunctions.string_defineSignalsFromInterface('dup_unit__' + rtlPrefixString + '_', memoryControlInterface);
            }

        }
\jsend
\=str=\
\js } //useCmc
\jsbegin
// =======================================================
// dmi core logic instantiation
// =======================================================
    var DMI_UNIT_INTF = [];
    var TRACE_CAPTURE_INTF = [];
    var nNonDataNetworks = 0; 
    var nDataNetworks = 0; 

    DMI_UNIT_INTF.push({
        modulePrefix: '',
        localPrefix: clkInterfaceName,
        interface: clkInterface,
        direction: interfaces.clkInt.direction
    });    

    DMI_UNIT_INTF.push({
        modulePrefix: 'axi_mst_',
        localPrefix: interfaces.axiInt.name,
        interface: axiInterfaceBundle,
        direction: interfaces.axiInt.direction
    });

    DMI_UNIT_INTF.push({
        modulePrefix: 'apb_slv_',
        localPrefix: interfaces.apbInt.name,
        interface: apbInterface,
        direction: interfaces.apbInt.direction
    });

    DMI_UNIT_INTF.push({
        modulePrefix: 'irq_',
        localPrefix: interfaces.irqInt.name,
        interface: irqInterface,
        direction: interfaces.irqInt.direction,
        excludeFromFC : true
    });

    DMI_UNIT_INTF.push({
        modulePrefix: 'dmi_',
        localPrefix: 'dmi_',
        interface: internalFaultInterface,
        direction: 'master',
        excludeFromFC : true
    });

    DMI_UNIT_INTF.push({
        modulePrefix: 'csr_trace_',
        localPrefix: 'csr_trace_',
        interface: traceCsrIfGenerator.signalBundle('slave'),
        direction: 'master'
    });
//ASILB without duplication not suport in Ncore3.7
 /* istanbul ignore else env ncore_3p7*/
    if (!ASILB){
        DMI_UNIT_INTF.push({
            modulePrefix: 'dtw_dbg_req_',
            localPrefix: 'dtw_dbg_req_',
            interface: CONC_INTF['DTWDBGReqInterface'],
            direction: 'slave'
        });
    }
    DMI_UNIT_INTF.push({
        modulePrefix: 'dtw_dbg_rsp_',
        localPrefix: 'dtw_dbg_rsp_',
        interface: CONC_INTF['DTWDBGRespInterface'],
        direction: 'master'
    });

if(usePma) {
    DMI_UNIT_INTF.push({
        modulePrefix: qInterfaceName,
        localPrefix: qInterfaceName,
        interface: qInterfaceBundle,
	    direction : 'slave',
        exclude : ['REQn']
    });
}

// trigger intf always present on 3.4 
/* istanbul ignore else env ncore_3p4,ncore_3p6, ncore_3p7 */
if (interfaces.masterTriggerInt && !interfaces.masterTriggerInt._SKIP_) {
    DMI_UNIT_INTF.push({
        modulePrefix: masterTriggerInterface.name,
        localPrefix: masterTriggerInterface.name,
        interface: masterTriggerInterface.signals,
        direction: 'slave',
	exclude : ['trigger']
    });
   
}


  for (var i=0; i<SMI_TX_INTF.length; i++)
    {
     TRACE_CAPTURE_INTF.push({
                                modulePrefix: SMI_TX_INTF[i].name, 
                                localPrefix: SMI_TX_INTF[i].name, 
                                interface: SMI_TX_INTF[i].signals
     });

//ASILB without duplication not suport in Ncore3.7
 /* istanbul ignore else env ncore_3p7*/
     if (!ASILB){
     DMI_UNIT_INTF.push({
                         modulePrefix: SMI_TX_INTF[i].name, 
                         localPrefix: SMI_TX_INTF[i].name, 
                         interface: SMI_TX_INTF[i].signals,
                         direction: SMI_TX_INTF_DIRECTION[i]
                         });
     }
     if(SMI_TX_INTF[i].params.dpPresent) {
     nNonDataNetworks++;
     TRACE_CAPTURE_INTF.push({
                             modulePrefix: SMI_TX_INTF[i].name, 
                             localPrefix: SMI_TX_INTF[i].name, 
                             interface: SMI_TX_INTF[i].dpSignals,
                             exclude: ['dp_ready']
     });

//ASILB without duplication not suport in Ncore3.7
 /* istanbul ignore else env ncore_3p7*/
     if (!ASILB){
     DMI_UNIT_INTF.push({
                         modulePrefix: SMI_TX_INTF[i].name, 
                         localPrefix: SMI_TX_INTF[i].name, 
                         interface: SMI_TX_INTF[i].dpSignals,
                         direction: SMI_TX_INTF_DIRECTION[i]                        
                         });
    }
     } else {
     nDataNetworks++;
     }

     };
//width needed for total number of smi ports*2 (each rx/tx direction)+1.
const wTotalSmiPortsNum = log2ceil(((nNonDataNetworks+nDataNetworks)*2)+1);
 

   for (var i=0; i<SMI_RX_INTF.length; i++)
     {
      TRACE_CAPTURE_INTF.push({
                                  modulePrefix: SMI_RX_INTF[i].name, 
                                  localPrefix: SMI_RX_INTF[i].name, 
                                  interface: SMI_RX_INTF[i].signals
      });

//ASILB without duplication not suport in Ncore3.7
 /* istanbul ignore else env ncore_3p7*/
      if (!ASILB){
      DMI_UNIT_INTF.push({
                          modulePrefix: SMI_RX_INTF[i].name, 
                          localPrefix: SMI_RX_INTF[i].name, 
                          interface: SMI_RX_INTF[i].signals,
                          direction: SMI_RX_INTF_DIRECTION[i]
                          });
      }

     if(SMI_RX_INTF[i].params.dpPresent) {
     TRACE_CAPTURE_INTF.push({
                                 modulePrefix: SMI_RX_INTF[i].name, 
                                 localPrefix: SMI_RX_INTF[i].name, 
                                 interface: SMI_RX_INTF[i].dpSignals,
                                 exclude: ['dp_ready']
     });

//ASILB without duplication not suport in Ncore3.7
 /* istanbul ignore else env ncore_3p7*/
     if(!ASILB){
     DMI_UNIT_INTF.push({
                         modulePrefix: SMI_RX_INTF[i].name, 
                         localPrefix: SMI_RX_INTF[i].name, 
                         interface: SMI_RX_INTF[i].dpSignals,
                         direction: SMI_RX_INTF_DIRECTION[i]
                         });

    
if (MRDOverflowBufInSRAM) {
        DMI_UNIT_INTF.push({
                                modulePrefix: "", 
                                localPrefix: "", 
                                interface: MrdReq_sb_mem_interface,
                                direction: "slave"
                                });
}
                    
if (CMDOverflowBufInSRAM) {
        DMI_UNIT_INTF.push({
                                modulePrefix: "", 
                                localPrefix: "", 
                                interface: CmdReq_sb_mem_interface,
                                direction: "slave"
                                });
}

    }
     }
     };
//ASILB without duplication not suport in Ncore3.7
 /* istanbul ignore if env ncore_3p7*/
     if(ASILB){

        DMI_UNIT_INTF.push({
            modulePrefix: "cmd_req_", 
            localPrefix: "cmd_req_", 
            interface: CONC_INTF["CMDReqInterface"],
            direction: "slave"
        });

        DMI_UNIT_INTF.push({
            modulePrefix: "nc_cmd_resp_", 
            localPrefix: "cmd_rsp_", 
            interface: CONC_INTF["NCCMDRespInterface"],
            direction: "master"
        });

        DMI_UNIT_INTF.push({
            modulePrefix: "mrd_req_", 
            localPrefix: "mrd_req_", 
            interface: CONC_INTF["MRDReqInterface"],
            direction: "slave"
        });

        DMI_UNIT_INTF.push({
            modulePrefix: "rbr_req_", 
            localPrefix: "rbr_req_", 
            interface: CONC_INTF["RBReqInterface"],
            direction: "slave"
        });

        DMI_UNIT_INTF.push({
            modulePrefix: "dtw_req_", 
            localPrefix: "dtw_req_", 
            interface: CONC_INTF["DTWReqInterface"],
            direction: "slave"
        });

        DMI_UNIT_INTF.push({
            modulePrefix: 'dtw_dbg_rsp_prot_',
            localPrefix: 'dtw_dbg_rsp_prot_',
            interface: CONC_INTF['DTWDBGRespInterface'],
            direction: 'slave'
        });

        DMI_UNIT_INTF.push({
            modulePrefix: "dtr_req_", 
            localPrefix: "dtr_req_", 
            interface: CONC_INTF["DTRReqInterface"],
            direction: "master"
        });

        DMI_UNIT_INTF.push({
            modulePrefix: "str_req_", 
            localPrefix: "str_req_", 
            interface: CONC_INTF["STRReqInterface"],
            direction: "master"
        });

        DMI_UNIT_INTF.push({
            modulePrefix: "dtr_rsp_", 
            localPrefix: "dtr_rsp_", 
            interface: CONC_INTF["DTRRespInterface"],
            direction: "slave"
        });

        DMI_UNIT_INTF.push({
            modulePrefix: "str_rsp_", 
            localPrefix: "str_rsp_", 
            interface: CONC_INTF["STRRespInterface"],
            direction: "slave"
        });

        DMI_UNIT_INTF.push({
            modulePrefix: "dtw_rsp_", 
            localPrefix: "dtw_rsp_", 
            interface: CONC_INTF["DTWRespInterface"],
            direction: "master"
        });

        DMI_UNIT_INTF.push({
            modulePrefix: "mrd_resp_", 
            localPrefix: "mrd_rsp_", 
            interface: CONC_INTF["MRDRespInterface"],
            direction: "master"
        });

        DMI_UNIT_INTF.push({
            modulePrefix: "rbr_resp_", 
            localPrefix: "rbr_rsp_", 
            interface: CONC_INTF["RBRRespInterface"],
            direction: "master"
        });


        DMI_UNIT_INTF.push({
            modulePrefix: "rtt_", 
            localPrefix: "rtt_", 
            interface: rtt_flop_bundle,
            direction: "master"
        })

        DMI_UNIT_INTF.push({
            modulePrefix: "wtt_", 
            localPrefix: "wtt_", 
            interface: wtt_flop_bundle,
            direction: "master"
        })
        DMI_UNIT_INTF.push({
            modulePrefix: "c_", 
            localPrefix: "c_", 
            interface: c_rb_buffer_flop_bundle,
            direction: "master"
        });

        DMI_UNIT_INTF.push({
            modulePrefix: "nc_", 
            localPrefix: "nc_", 
            interface: nc_rb_buffer_flop_bundle,
            direction: "master"
        });

        DMI_UNIT_INTF.push({
            modulePrefix: "nc_", 
            localPrefix: "nc_", 
            interface: nc_data_buffer_flop_bundle,
            direction: "master"
        });


        DMI_UNIT_INTF.push({
            modulePrefix: "cmd_req_skid_buffer_push_", 
            localPrefix: "cmd_req_skid_buffer_push_", 
            interface: CMDReqSkidInterface,
            direction: "master"
        });

        DMI_UNIT_INTF.push({
            modulePrefix: "cmd_skid_buffer_pop_", 
            localPrefix: "cmd_skid_buffer_pop_", 
            interface: CMDReqSkidInterface,
            direction: "slave"
        });


        DMI_UNIT_INTF.push({
            modulePrefix: "mrd_req_skid_buffer_push_", 
            localPrefix: "mrd_req_skid_buffer_push_", 
            interface: MRDReqSkidInterface,
            direction: "master"
        });

        DMI_UNIT_INTF.push({
            modulePrefix: "mrd_skid_buffer_pop_", 
            localPrefix: "mrd_skid_buffer_pop_", 
            interface: MRDReqSkidInterface,
            direction: "slave"
        });

        DMI_UNIT_INTF.push({direction: "master",modulePrefix: 'read_trans_',   localPrefix: 'read_trans_', interface: readTransactionInterface, exclude:['addr']});
        DMI_UNIT_INTF.push({direction: "master",modulePrefix: 'write_trans_',  localPrefix: 'write_trans_', interface: writeTransactionInterface, exclude:['addr']});
        DMI_UNIT_INTF.push({direction: "slave",modulePrefix: 'read_data_',    localPrefix: 'read_data_', interface: readDataInterface});
        DMI_UNIT_INTF.push({direction: "master",modulePrefix: 'write_data_',   localPrefix: 'write_data_', interface: writeDataInterface});
        DMI_UNIT_INTF.push({direction: "master",modulePrefix: 'write_resp_',   localPrefix: 'write_resp_', interface: axiInterfaceBundle["b_"]});
        DMI_UNIT_INTF.push({direction: "slave",modulePrefix: 'axi_mst_placeholder_', localPrefix: 'axi_mst_placeholder_', interface: axiInterfaceBundle});
        DMI_UNIT_INTF.push({direction: "master",modulePrefix: 'ntvInt_',              localPrefix: 'ntvInt_', interface: ntvCsrInterface});
        

        if (useSysReqSender){
            DMI_UNIT_INTF.push({
                modulePrefix: "sys_rsp_rx_", 
                localPrefix: "sys_rsp_rx_", 
                interface: CONC_INTF["SYSRspRxInterface"],
                direction: "slave"
            });
            
            DMI_UNIT_INTF.push({
                modulePrefix: "sys_req_tx_", 
                localPrefix: "sys_req_tx_", 
                interface: CONC_INTF["SYSReqTxInterface"],
                direction: "master"
            });    
        }


}

    //Trace Capture interfaces
    TRACE_CAPTURE_INTF.push({
        modulePrefix: '',
        localPrefix: clkInterfaceName,
        interface: clkInterface,
        exclude: ['test_en']
    });
    TRACE_CAPTURE_INTF.push({
        modulePrefix: 'dtw_req_',
        localPrefix: 'dtw_dbg_req_',
        interface: CONC_INTF['DTWDBGReqInterface']
    });
    TRACE_CAPTURE_INTF.push({
        modulePrefix: 'dtw_resp_',
        localPrefix: 'dtw_dbg_rsp_',
        interface: CONC_INTF['DTWDBGRespInterface']
    });
    TRACE_CAPTURE_INTF.push({
        modulePrefix: 'csr_trace_',
        localPrefix: 'csr_trace_',
        interface: traceCsrIfGenerator.signalBundle("slave")
    });

    if(useCmc) {

        DMI_UNIT_INTF.push({
                modulePrefix: '',
                localPrefix: '',
                interface: ccpMemoryInterface,
	            direction : "master"
        });

        if (usePLRU) {

           var plruMemoryInterface = [];

           for (let i=0; i < ccpParams.nTagBanks; i++) {
               plruMemoryInterface[i] = {
                   '_plru_mem_read_en'      : 1,
                   '_plru_mem_write_en'     : 1,
                   '_plru_mem_read_addr'    : ccpParams.plru_addr_w,
                   '_plru_mem_write_addr'   : ccpParams.plru_addr_w,
                   '_plru_mem_write_data'   : ccpParams.nWays,
                   '_plru_mem_read_data'    :-ccpParams.nWays
               };

            DMI_UNIT_INTF.push({
                        modulePrefix:'f'+ i,
                        localPrefix: 'w_f'+ i,
                        interface: plruMemoryInterface[i],
                        direction: 'master'
            });

        }

}

    } // useCmc

    if (useExRdDataMem) {
        DMI_UNIT_INTF.push({
                modulePrefix: '',
                localPrefix: '',
                interface: rdBufferMemoryInterface,
	            direction : "master"
        });
    } // useExRdDataMem

    if (useExWrDataMem) {
        DMI_UNIT_INTF.push({
                modulePrefix: '',
                localPrefix: '',
                interface: wrDataBufferMemoryInterface,
	            direction : "master"
        });
    } // useExWrDataMem


    if(enableNativeIntfProtection) {
        DMI_UNIT_INTF.push({
            modulePrefix: placeInterfaceName,
            localPrefix: placeInterfaceName,
            interface: placeInterfaceBundle,
	        direction : "master"
        });
    } // enableNativeIntfProtection

    var DMI_UNIT_PORTS = {};
        DMI_UNIT_PORTS['trace_capture_busy'] = 'trace_capture_busy';
        DMI_UNIT_PORTS['pm_trace_messages_captured'] = 'pm_trace_messages_captured';
        DMI_UNIT_PORTS['pm_trace_messages_dropped'] = 'pm_trace_messages_dropped';


//ASILB without duplication not suport in Ncore3.7
 /* istanbul ignore if env ncore_3p7*/
    if(ASILB){
        if(nPerfCounters>0){
        DMI_UNIT_PORTS["pmon_tx0_ndp_stall_in"] = "pmon_tx0_ndp_stall_in";
        DMI_UNIT_PORTS["pmon_tx1_ndp_stall_in"] = "pmon_tx1_ndp_stall_in";
        DMI_UNIT_PORTS["pmon_tx2_ndp_stall_in"] = "pmon_tx2_ndp_stall_in";
        DMI_UNIT_PORTS["pmon_tx3_dp_stall_in"]  = "pmon_tx3_dp_stall_in"; 
        DMI_UNIT_PORTS["pmon_rx0_ndp_stall_in"] = "pmon_rx0_ndp_stall_in";
        DMI_UNIT_PORTS["pmon_rx1_ndp_stall_in"] = "pmon_rx1_ndp_stall_in";
        DMI_UNIT_PORTS["pmon_rx2_ndp_stall_in"] = "pmon_rx2_ndp_stall_in";
        DMI_UNIT_PORTS["pmon_rx3_dp_stall_in"]  = "pmon_rx3_dp_stall_in";
        }
        DMI_UNIT_PORTS["cmd_skid_buffer_empty"] = "cmd_skid_buffer_empty" ;        
        if (fnEnableQos) {
            DMI_UNIT_PORTS['cmd_skid_buffer_starv_en']             = 'cmd_skid_buffer_starv_en'             ;   
            DMI_UNIT_PORTS['cmd_skid_buffer_starv_threshold']      = 'cmd_skid_buffer_starv_threshold'      ;   
            DMI_UNIT_PORTS['cmd_skid_buffer_qos_disable']          = 'cmd_skid_buffer_qos_disable'          ;  
            DMI_UNIT_PORTS['cmd_skid_buffer_starv_overflow_event'] = 'cmd_skid_buffer_starv_overflow_event' ;
            DMI_UNIT_PORTS['cmd_skid_buffer_starv_mode']           = 'cmd_skid_buffer_starv_mode'           ;
            DMI_UNIT_PORTS['cmd_skid_buffer_threshold_reached']    = 'cmd_skid_buffer_threshold_reached'    ;
            DMI_UNIT_PORTS['cmd_skid_buffer_DmiPriorityThVal']     = 'cmd_skid_buffer_DmiPriorityThVal'     ;
            DMI_UNIT_PORTS["cmd_skid_buffer_full"]                 = "cmd_skid_buffer_full"                 ;
        }

        DMI_UNIT_PORTS["mrd_skid_buffer_empty"] = "mrd_skid_buffer_empty" ;        
        if (fnEnableQos) {
            DMI_UNIT_PORTS['mrd_skid_buffer_starv_en']             = 'mrd_skid_buffer_starv_en'             ;   
            DMI_UNIT_PORTS['mrd_skid_buffer_starv_threshold']      = 'mrd_skid_buffer_starv_threshold'      ;   
            DMI_UNIT_PORTS['mrd_skid_buffer_qos_disable']          = 'mrd_skid_buffer_qos_disable'          ;  
            DMI_UNIT_PORTS['mrd_skid_buffer_starv_overflow_event'] = 'mrd_skid_buffer_starv_overflow_event' ;
            DMI_UNIT_PORTS['mrd_skid_buffer_starv_mode']           = 'mrd_skid_buffer_starv_mode'           ;
            DMI_UNIT_PORTS['mrd_skid_buffer_threshold_reached']    = 'mrd_skid_buffer_threshold_reached'    ;
            DMI_UNIT_PORTS['mrd_skid_buffer_DmiPriorityThVal']     = 'mrd_skid_buffer_DmiPriorityThVal'     ;
            DMI_UNIT_PORTS["mrd_skid_buffer_full"]                 = "mrd_skid_buffer_full"                 ;
        }
        DMI_UNIT_PORTS["read_trans_addr_t"] = "read_trans_addr_t";
        DMI_UNIT_PORTS["write_trans_addr_t"] = "write_trans_addr_t";

    }
// trigger intf always present on 3.4 
/* istanbul ignore else env ncore_3p4,ncore_3p6, ncore_3p7 */
    if( interfaces.masterTriggerInt && !interfaces.masterTriggerInt._SKIP_ ) {
	DMI_UNIT_PORTS[masterTriggerInterface.name+'trigger'] = masterTriggerInterface.name+'trigger_sync';
    }
    if ( useResiliency ) {
        DMI_UNIT_PORTS['res_cerr_thresh'] = 'res_cerr_thresh';
        DMI_UNIT_PORTS['dmi_en_debug_bist'] = 'dmi_en_debug_bist';
    } else {
        DMI_UNIT_PORTS['dmi_en_debug_bist'] = "1'b1";
    }
    if (usePma) {
        DMI_UNIT_PORTS[qInterfaceName+'REQn'] = qInterfaceName+'REQn_sync';
    }

    Object.keys(unitIdInterface).forEach(function(key) {
        DMI_UNIT_PORTS[key] = unitIdInterfaceName + key;
    });
//dve always present
 /* istanbul ignore else env ncore_3p2, ncore_3p4,ncore_3p6, ncore_3p7*/
    if (haveDveInterface) {
        Object.keys(uDveIdInterface).forEach(function(key) {
            DMI_UNIT_PORTS['dve_' + key] = uDveIdInterfaceName + key;
        });
    }
    
    Object.keys(sysUnitIdInterface).forEach(function(key) {
        DMI_UNIT_PORTS['aiu_' + key] = sysUnitIdInterfaceName + key;
    });


if(useCmc & ccpParams.nBeatsPerBank > 1){
        DMI_UNIT_PORTS["clkby2_en"] = "clkby2_en"
}

if(useCmc & useScratchpad){
    DMI_UNIT_PORTS["uId_my_n_unit_id"]="uId_my_n_unit_id";
}
//ASILB without duplication not suport in Ncore3.7
 /* istanbul ignore if env ncore_3p7*/
if(ASILB){
    DMI_UNIT_PORTS["cmux_active"]="cmux_active"
}
    var dmi_unit_params = {
            assertOn                    : assertOn,
            rttLookup                   : rttLookup,
            wttLookup                   : wttLookup,
            c_rbidBuffer                : c_rbidBuffer,
            nc_rbidBuffer                : nc_rbidBuffer,
            nc_dataBuffer                  : nc_dataBuffer,
            nWriteDataBuffer            : nWriteDataBuffer,
            wWriteDataBufferId          : wWriteDataBufferId,
            nDtwMergeMrdLateInFlight    : nDtwMergeMrdLateInFlight,
            nMrdLateInFlight            : nMrdLateInFlight,
            usePLRU                     : usePLRU,
            ASILB                       : ASILB,
            nUnitTraceBufSize           : nUnitTraceBufSize,
            haveDveInterface            : haveDveInterface,
            sameWidthSystem             : sameWidthSystem,
            nAius                       : nAius,
            usePma                      : usePma,
            PmaInfo                     : PmaInfo,
            useWayPartitioning          : useWayPartitioning,
            nWayPartitioningRegisters   : nWayPartitioningRegisters,
            useAddrTranslation          : useAddrTranslation,
            nAddrTransRegisters         : nAddrTransRegisters,
            axiParams                   : axiParams,
            wInitiatorId                : wInitiatorId,
            wFUnitId                    : wFUnitId,
            wNUnitId                    : wNUnitId,
            wFPortId                    : wFPortId,
            wMessageId                  : wMessageId,
            cmpInfo                     : cmpInfo,
            cmType                      : cmType,
            wCacheLineOffset            : wCacheLineOffset,
            useAtomic                   : useAtomic,
            useCmc                      : useCmc,
            wData                       : wData,
            wAddr                       : wAddr,
            wAiuId                      : wInitiatorId,
            nBeats                      : nBeats,
            ccpParams                   : ccpParams,
	    clkInterfaceJson		: interfaces.clkInt,  //new style clkInterface
            clkInterface                : clkInterface,
            clkInterfaceParam           : clkInterfaceParam,
            blkClkGateOn                : blkClkGateOn,
            axiInterface                : axiInterfaceBundle,
            irqInterface                : irqInterface,
            unitIdInterface             : unitIdInterface,
            uDveIdInterface             : uDveIdInterface,
            apbInterface                : apbInterface,
            readDataInterface           : readDataInterface,
            ccpMemoryInterface          : ccpMemoryInterface,
            wrDataBufferMemoryInterface : wrDataBufferMemoryInterface,
            cWrDataGen                  : cWrDataGen[0],
            cWrDataParam                : cWrDataParam,
            wrBufferProtType            : wrBufferProtType,
            useExWrDataMem              : useExWrDataMem,
            concertoInterfaces          : CONC_INTF,
            smiTxPortInterfaces         : SMI_TX_INTF,
            smiRxPortInterfaces         : SMI_RX_INTF,
            concertoTxInterfaces        : CONC_TX_INTF,
            concertoRxInterfaces        : CONC_RX_INTF,
            regProtInterface            : regProtectionInterface,
            regProtInterfaceName        : regProtectionInterfaceName,
            regProtStyle                : regProtectionStyle,
            qInterface                  : qInterfaceBundle,
            qInterfaceName              : qInterfaceName,
            csr                         : csr,
            wCsrData                    : wCsrData,
            wCsrAddr                    : wCsrAddr,
            fnNativeInterface           : fnNativeInterface,
            useResiliency               : useResiliency,
            ResilienceInfo              : ResilienceInfo,
            placeInterface              : placeInterface,
            placeInterfaceName          : placeInterfaceName,
            placeInterfaceDef           : placeInterfaceDef,
            placeInterfaceSkip          : placeInterfaceSkip,
            internalFaultInterface      : internalFaultInterface,
            sysUnitIdInterface          : sysUnitIdInterface,
            wNrri                       : wNrri,
            wRpn                        : wRpn,
            concParams                  : concParams,
            fnEnableTimeOutRef          : fnEnableTimeOutRef,
            fnEnableQos                 : fnEnableQos,
            QosInfo                     : QosInfo,
            nativeInterfacePipe         : nativeInterfacePipe,
            enRdPipe                    : enRdPipe,
            enWrPipe                    : enWrPipe,
            wTotalSmiPortsNum           : wTotalSmiPortsNum,
            nPerfCounters		: nPerfCounters,
            enableReadDataInterleaving : enableReadDataInterleaving,
            nMrdSkidBufArb : nMrdSkidBufArb,
            nMrdSkidBufSize : nMrdSkidBufSize,
            nCMDSkidBufArb : nCMDSkidBufArb,
            nCMDSkidBufSize : nCMDSkidBufSize,
	    interfaces	     		: interfaces,
            nExclusiveEntries         : nExclusiveEntries,
	    useSysReqSender		: useSysReqSender,
	    nDves			: N_DVES,
        InterleaveInfo : obj.lib.getParam("InterleaveInfo"),
        addressIdMap : obj.lib.getParam("addressIdMap"),
        CMDReqSkidInterface : CMDReqSkidInterface,
        MRDReqSkidInterface : MRDReqSkidInterface,
        bufferSize                  : bufferSize,
        wStarvThreshold             :wStarvThreshold,
        DMI_NATIVE_INTERFACE_INTF   : DMI_NATIVE_INTERFACE_INTF,
        DMI_NATIVE_INTERFACE_PORTS  : DMI_NATIVE_INTERFACE_PORTS,
        readTransactionInterface    : readTransactionInterface,
        writeTransactionInterface   : writeTransactionInterface,
        readDataInterface           : readDataInterface,
        writeDataInterface          : writeDataInterface,
        ntvCsrInterface             : ntvCsrInterface,
        writeResponseInterface      : writeResponseInterface
};


if (enableReadDataInterleaving) {
    dmi_unit_params["useExRdDataMem"] =            useExRdDataMem;
    dmi_unit_params["rdBufferMemoryInterface"] =   rdBufferMemoryInterface;
    dmi_unit_params["rdBufferProtType"] =          rdBufferProtType;
    dmi_unit_params["rdBufferGen"] =               rdBufferGen[0];
    dmi_unit_params["rdBufferParam"] =             rdBufferParam;
}
//ASILB without duplication not suport in Ncore3.7
 /* istanbul ignore if env ncore_3p7*/
if (ASILB){
    dmi_unit_params["rtt_flop_bundle"]= rtt_flop_bundle;
    dmi_unit_params["wtt_flop_bundle"]= wtt_flop_bundle;
    dmi_unit_params["c_rb_buffer_flop_bundle"] = c_rb_buffer_flop_bundle;
    dmi_unit_params["nc_rb_buffer_flop_bundle"] = nc_rb_buffer_flop_bundle;
    dmi_unit_params["nc_data_buffer_flop_bundle"] = nc_data_buffer_flop_bundle;


    
\jsend
    \=bundleFunctions.wiresFromInterface("rtt_",       rtt_flop_bundle, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface("wtt_",       wtt_flop_bundle, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface("c_",       c_rb_buffer_flop_bundle, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface("nc_",       nc_rb_buffer_flop_bundle, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface("nc_",       nc_data_buffer_flop_bundle, [], obj.lib.bundle)=\

    \=bundleFunctions.wiresFromInterface('ntvInt_',             ntvCsrInterface,        [],                                               obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('axi_mst_placeholder_',axiInterfaceBundle,           [],                                               obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('read_trans_', readTransactionInterface, ["addr"], obj.lib.bundle)=\
    wire [\=wAddr-1=\ : 0] read_trans_addr_t;
    \=bundleFunctions.wiresFromInterface('write_trans_', writeTransactionInterface, ["addr"], obj.lib.bundle)=\
    wire [\=wAddr-1=\ : 0] write_trans_addr_t;
    \=bundleFunctions.wiresFromInterface('read_data_', readDataInterface, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('write_data_', writeDataInterface, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('write_resp_', axiInterfaceBundle.b_, [], obj.lib.bundle)=\


    \=bundleFunctions.wiresFromInterface("cmd_req_skid_buffer_push_",       CMDReqSkidInterface, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface("cmd_skid_buffer_pop_",       CMDReqSkidInterface, [], obj.lib.bundle)=\

    \=bundleFunctions.wiresFromInterface("mrd_req_skid_buffer_push_",       MRDReqSkidInterface, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface("mrd_skid_buffer_pop_",      MRDReqSkidInterface, [], obj.lib.bundle)=\


    wire cmd_skid_buffer_empty;
    wire mrd_skid_buffer_empty;
    \js if(nPerfCounters>0) {
    wire  pmon_tx0_ndp_stall_in;
    wire  pmon_tx1_ndp_stall_in;
    wire  pmon_tx2_ndp_stall_in;
    wire  pmon_tx3_dp_stall_in ;
    wire  pmon_rx0_ndp_stall_in;
    wire  pmon_rx1_ndp_stall_in;
    wire  pmon_rx2_ndp_stall_in;
    wire  pmon_rx3_dp_stall_in ;
    \js }
\jsbegin
    if (fnEnableQos) {
\jsend
        wire   cmd_skid_buffer_starv_en         ;
        wire [\=wStarvThreshold-1=\:0]  cmd_skid_buffer_starv_threshold  ; 
        wire   cmd_skid_buffer_qos_disable     ;  
        wire   cmd_skid_buffer_starv_overflow_event ;
        wire  cmd_skid_buffer_starv_mode         ;
        wire   cmd_skid_buffer_threshold_reached ;
        wire [3:0]  cmd_skid_buffer_DmiPriorityThVal   ;
        wire  cmd_skid_buffer_full             ;



        wire   mrd_skid_buffer_starv_en         ;
        wire [\=wStarvThreshold-1=\:0]  mrd_skid_buffer_starv_threshold  ; 
        wire   mrd_skid_buffer_qos_disable     ;  
        wire   mrd_skid_buffer_starv_overflow_event ;
        wire  mrd_skid_buffer_starv_mode         ;
        wire   mrd_skid_buffer_threshold_reached ;
        wire [3:0]  mrd_skid_buffer_DmiPriorityThVal   ;
        wire  mrd_skid_buffer_full             ;
\jsbegin
    }

} else {
    dmi_unit_params["cmdSkidBufferPorts"] = cmdSkidBufferPorts;
    dmi_unit_params["cmdSkidBufferInterfaces"] = cmdSkidBufferInterfaces;
    dmi_unit_params["cmdSkidBufferParams"] = cmdSkidBufferParams;

    dmi_unit_params["mrdSkidBufferPorts"] = mrdSkidBufferPorts;
    dmi_unit_params["mrdSkidBufferInterfaces"] = mrdSkidBufferInterfaces;
    dmi_unit_params["mrdSkidBufferParams"] = mrdSkidBufferParams;


    
    if (CMDOverflowBufInSRAM ) {
        dmi_unit_params["CmdReq_sb_mem_interface"]  = CmdReq_sb_mem_interface;
\jsend
\=bundleFunctions.wiresFromInterface("",      CmdReq_sb_mem_interface, [], obj.lib.bundle)=\
\jsbegin
     }

    if (MRDOverflowBufInSRAM) {
        \jsend
        \=bundleFunctions.wiresFromInterface("",      MrdReq_sb_mem_interface, [], obj.lib.bundle)=\
        \jsbegin
        dmi_unit_params["MrdReq_sb_mem_interface"]  = MrdReq_sb_mem_interface;
     }
}


if ( useResiliency ) {
dmi_unit_params['wResThreshold'] = wResThreshold;
}

\jsend
    wire [\=wTotalSmiPortsNum-1=\:0] pm_trace_messages_dropped;
    wire [\=wTotalSmiPortsNum-1=\:0] pm_trace_messages_captured;

    \jsbegin
    if (useCmc) {
        if (usePLRU) {
            for (let i=0; i < ccpParams.nTagBanks; i++) {
    \jsend
    \=bundleFunctions.wiresFromInterface('w_f'+ i,       plruMemoryInterface[i], [], obj.lib.bundle)=\
            \js if (useResiliency && enableUnitDuplication) {
    \=bundleFunctions.wiresFromInterface('dup_unit__w_f'+ i,       plruMemoryInterface[i], [], obj.lib.bundle)=\
            \js }
    \jsbegin
            }
        }
    }
    \jsend

    \=obj.lib.instance({
        instanceName: 'dmi_unit',
        moduleName: 'dmi_unit',
        params: dmi_unit_params,
        verilogParams: {},
        ports: DMI_UNIT_PORTS,
        interfaces: DMI_UNIT_INTF,
        portsDelimiter: '\n        '
    })=\


\jsbegin
//========================================================
// DMI Duplicate Unit 
//========================================================

//ASILB without duplication not suport in Ncore3.7
 /* istanbul ignore if env ncore_3p7*/
if(enableUnitDuplication & useResiliency & ASILB){
\jsend
    \=bundleFunctions.wiresFromInterface('dup_unit__' + "cmd_req_", CONC_INTF["CMDReqInterface"], [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dup_unit__' + "cmd_rsp_", CONC_INTF["NCCMDRespInterface"], [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dup_unit__' + "mrd_req_", CONC_INTF["MRDReqInterface"], [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dup_unit__' + "rbr_req_", CONC_INTF["RBReqInterface"], [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dup_unit__' + "dtw_req_", CONC_INTF["DTWReqInterface"], [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dup_unit__' + "dtw_dbg_rsp_prot_", CONC_INTF["DTWDBGRespInterface"], [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dup_unit__' + "dtr_req_", CONC_INTF["DTRReqInterface"], [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dup_unit__' + "str_req_", CONC_INTF["STRReqInterface"], [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dup_unit__' + "dtr_rsp_", CONC_INTF["DTRRespInterface"], [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dup_unit__' + "str_rsp_", CONC_INTF["STRRespInterface"], [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dup_unit__' + "dtw_rsp_", CONC_INTF["DTWRespInterface"], [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dup_unit__' + "mrd_rsp_", CONC_INTF["MRDRespInterface"], [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dup_unit__' + "rbr_rsp_", CONC_INTF["RBRRespInterface"], [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dup_unit__' + "sys_rsp_rx_", CONC_INTF["SYSRspRxInterface"], [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dup_unit__' + "sys_req_tx_", CONC_INTF["SYSReqTxInterface"], [], obj.lib.bundle)=\

    \=bundleFunctions.wiresFromInterface('dup_unit__' + "rtt_", rtt_flop_bundle, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dup_unit__' + "wtt_", wtt_flop_bundle, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dup_unit__' + "c_", c_rb_buffer_flop_bundle, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dup_unit__' + "nc_", nc_rb_buffer_flop_bundle, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dup_unit__' + "nc_", nc_data_buffer_flop_bundle, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dup_unit__' + "cmd_req_skid_buffer_push_", CMDReqSkidInterface, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dup_unit__' + "cmd_skid_buffer_pop_", CMDReqSkidInterface, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dup_unit__' + "mrd_req_skid_buffer_push_", MRDReqSkidInterface, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dup_unit__' + "mrd_skid_buffer_pop_", MRDReqSkidInterface, [], obj.lib.bundle)=\

    \=bundleFunctions.wiresFromInterface('dup_unit__ntvInt_',             ntvCsrInterface,        [],                                               obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dup_unit__axi_mst_placeholder_',axiInterface,           [],                                               obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dup_unit__read_trans_', readTransactionInterface, [], obj.lib.bundle)=\
    wire [\=wAddr-1=\:0] dup_unit__read_trans_addr;
    \=bundleFunctions.wiresFromInterface('dup_unit__write_trans_', writeTransactionInterface, [], obj.lib.bundle)=\
    wire [\=wAddr-1=\:0] dup_unit__write_trans_addr;  
    \=bundleFunctions.wiresFromInterface('dup_unit__read_data_', readDataInterface, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dup_unit__write_data_', writeDataInterface, [], obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('dup_unit__write_resp_', axiInterface.b_, [], obj.lib.bundle)=\

    \js if(nPerfCounters>0) {

    wire dup_unit__cmux_active;
    wire dup_unit__pmon_tx0_ndp_stall_in;
    wire dup_unit__pmon_tx1_ndp_stall_in;
    wire dup_unit__pmon_tx2_ndp_stall_in;
    wire dup_unit__pmon_tx3_dp_stall_in;
    wire dup_unit__pmon_rx0_ndp_stall_in;
    wire dup_unit__pmon_rx1_ndp_stall_in;
    wire dup_unit__pmon_rx2_ndp_stall_in;
    wire dup_unit__pmon_rx3_dp_stall_in;



    wire dup_unit__cmd_skid_buffer_empty      ;
    wire dup_unit__mrd_skid_buffer_empty       ;

    \js if (fnEnableQos) {
    wire dup_unit__cmd_skid_buffer_starv_en          ;
    wire [\=wStarvThreshold-1=\:0] dup_unit__cmd_skid_buffer_starv_threshold      ;
    wire dup_unit__cmd_skid_buffer_qos_disable         ;
    wire dup_unit__cmd_skid_buffer_starv_overflow_event ;
    wire dup_unit__cmd_skid_buffer_starv_mode           ;
    wire dup_unit__cmd_skid_buffer_threshold_reached    ;
    wire [3:0] dup_unit__cmd_skid_buffer_DmiPriorityThVal     ;
    wire dup_unit__cmd_skid_buffer_full                ;

    wire dup_unit__mrd_skid_buffer_starv_en            ;
    wire [\=wStarvThreshold-1=\:0] dup_unit__mrd_skid_buffer_starv_threshold     ;
    wire dup_unit__mrd_skid_buffer_qos_disable          ;
    wire dup_unit__mrd_skid_buffer_starv_overflow_event ;
    wire dup_unit__mrd_skid_buffer_starv_mode         ;
    wire dup_unit__mrd_skid_buffer_threshold_reached   ;
    wire [3:0] dup_unit__mrd_skid_buffer_DmiPriorityThVal    ;
    wire dup_unit__mrd_skid_buffer_full                ;
    \js }




    \js }
\jsbegin
} else {
    if (CMDOverflowBufInSRAM ) {
\jsend
    \=bundleFunctions.wiresFromInterface("dup_unit__",      CmdReq_sb_mem_interface, [], obj.lib.bundle)=\
\jsbegin
    }
    if (MRDOverflowBufInSRAM) {
\jsend
    \=bundleFunctions.wiresFromInterface("dup_unit__",      MrdReq_sb_mem_interface, [], obj.lib.bundle)=\
\jsbegin
    }
}


if(enableUnitDuplication & useResiliency) {
    var DMI_DUP_UNIT_INTF = [];
    for(var i = 0; i < DMI_UNIT_INTF.length; i++){
        DMI_DUP_UNIT_INTF.push({
            modulePrefix: DMI_UNIT_INTF[i].modulePrefix,
            localPrefix: 'dup_unit__' + DMI_UNIT_INTF[i].localPrefix,
            interface: DMI_UNIT_INTF[i].interface,
            excludeFromFC: DMI_UNIT_INTF[i].excludeFromFC,
            exclude: DMI_UNIT_INTF[i].exclude
        });
    }
var DMI_DUP_UNIT_PORTS = {};
//ASILB without duplication not suport in Ncore3.7
 /* istanbul ignore if env ncore_3p7*/
if(ASILB){
   if(nPerfCounters>0){
   DMI_DUP_UNIT_PORTS["pmon_tx0_ndp_stall_in"] = "dup_unit__pmon_tx0_ndp_stall_in";
   DMI_DUP_UNIT_PORTS["pmon_tx1_ndp_stall_in"] = "dup_unit__pmon_tx1_ndp_stall_in";
   DMI_DUP_UNIT_PORTS["pmon_tx2_ndp_stall_in"] = "dup_unit__pmon_tx2_ndp_stall_in";
   DMI_DUP_UNIT_PORTS["pmon_tx3_dp_stall_in"]  = "dup_unit__pmon_tx3_dp_stall_in"; 
   DMI_DUP_UNIT_PORTS["pmon_rx0_ndp_stall_in"] = "dup_unit__pmon_rx0_ndp_stall_in";
   DMI_DUP_UNIT_PORTS["pmon_rx1_ndp_stall_in"] = "dup_unit__pmon_rx1_ndp_stall_in";
   DMI_DUP_UNIT_PORTS["pmon_rx2_ndp_stall_in"] = "dup_unit__pmon_rx2_ndp_stall_in";
   DMI_DUP_UNIT_PORTS["pmon_rx3_dp_stall_in"]  = "dup_unit__pmon_rx3_dp_stall_in";
}
   DMI_DUP_UNIT_PORTS["cmux_active"] = "dup_unit__cmux_active";
   DMI_DUP_UNIT_PORTS["cmd_skid_buffer_empty"] = "dup_unit__cmd_skid_buffer_empty" ;        
    if (fnEnableQos) {
        DMI_DUP_UNIT_PORTS['cmd_skid_buffer_starv_en']             = 'dup_unit__cmd_skid_buffer_starv_en'             ;   
        DMI_DUP_UNIT_PORTS['cmd_skid_buffer_starv_threshold']      = 'dup_unit__cmd_skid_buffer_starv_threshold'      ;   
        DMI_DUP_UNIT_PORTS['cmd_skid_buffer_qos_disable']          = 'dup_unit__cmd_skid_buffer_qos_disable'          ;  
        DMI_DUP_UNIT_PORTS['cmd_skid_buffer_starv_overflow_event'] = 'dup_unit__cmd_skid_buffer_starv_overflow_event' ;
        DMI_DUP_UNIT_PORTS['cmd_skid_buffer_starv_mode']           = 'dup_unit__cmd_skid_buffer_starv_mode'           ;
        DMI_DUP_UNIT_PORTS['cmd_skid_buffer_threshold_reached']    = 'dup_unit__cmd_skid_buffer_threshold_reached'    ;
        DMI_DUP_UNIT_PORTS['cmd_skid_buffer_DmiPriorityThVal']     = 'dup_unit__cmd_skid_buffer_DmiPriorityThVal'     ;
        DMI_DUP_UNIT_PORTS["cmd_skid_buffer_full"]                 = "dup_unit__cmd_skid_buffer_full"                 ;
    }

    DMI_DUP_UNIT_PORTS["mrd_skid_buffer_empty"] = "dup_unit__mrd_skid_buffer_empty" ;        
    if (fnEnableQos) {
       DMI_DUP_UNIT_PORTS['mrd_skid_buffer_starv_en']             = 'dup_unit__mrd_skid_buffer_starv_en'             ;   
       DMI_DUP_UNIT_PORTS['mrd_skid_buffer_starv_threshold']      = 'dup_unit__mrd_skid_buffer_starv_threshold'      ;   
       DMI_DUP_UNIT_PORTS['mrd_skid_buffer_qos_disable']          = 'dup_unit__mrd_skid_buffer_qos_disable'          ;  
       DMI_DUP_UNIT_PORTS['mrd_skid_buffer_starv_overflow_event'] = 'dup_unit__mrd_skid_buffer_starv_overflow_event' ;
       DMI_DUP_UNIT_PORTS['mrd_skid_buffer_starv_mode']           = 'dup_unit__mrd_skid_buffer_starv_mode'           ;
       DMI_DUP_UNIT_PORTS['mrd_skid_buffer_threshold_reached']    = 'dup_unit__mrd_skid_buffer_threshold_reached'    ;
       DMI_DUP_UNIT_PORTS['mrd_skid_buffer_DmiPriorityThVal']     = 'dup_unit__mrd_skid_buffer_DmiPriorityThVal'     ;
       DMI_DUP_UNIT_PORTS["mrd_skid_buffer_full"]                 = "dup_unit__mrd_skid_buffer_full"                 ;
    }
    DMI_DUP_UNIT_PORTS["read_trans_addr_t"] = "dup_unit__read_trans_addr_t";
    DMI_DUP_UNIT_PORTS["write_trans_addr_t"] = "dup_unit__write_trans_addr_t";

}
Object.keys(unitIdInterface).forEach(function(key) {
    DMI_DUP_UNIT_PORTS[key] = unitIdInterfaceName + key;
});
//dve always present
 /* istanbul ignore else env ncore_3p2, ncore_3p4,ncore_3p6, ncore_3p7 */
if (haveDveInterface) {
    Object.keys(uDveIdInterface).forEach(function(key) {
        DMI_DUP_UNIT_PORTS['dve_' + key] = uDveIdInterfaceName + key;
    });
}

Object.keys(sysUnitIdInterface).forEach(function(key) {
    DMI_DUP_UNIT_PORTS['aiu_' + key] = sysUnitIdInterfaceName + key;
});
DMI_DUP_UNIT_PORTS['dmi_en_debug_bist'] = 'dmi_en_debug_bist';


if(useCmc & ccpParams.nBeatsPerBank > 1){
        DMI_DUP_UNIT_PORTS["clkby2_en"] = "dup_unit__clkby2_en"
}

if(useCmc & useScratchpad){
    DMI_DUP_UNIT_PORTS["uId_my_n_unit_id"]="uId_my_n_unit_id";
}
DMI_DUP_UNIT_PORTS['res_cerr_thresh'] = 'dup_unit__res_cerr_thresh';
DMI_DUP_UNIT_PORTS['trace_capture_busy'] = 'dup_unit__trace_capture_busy';
DMI_DUP_UNIT_PORTS['pm_trace_messages_captured'] = 'dup_unit__pm_trace_messages_captured';
DMI_DUP_UNIT_PORTS['pm_trace_messages_dropped'] = 'dup_unit__pm_trace_messages_dropped';
// trigger intf always present on 3.4 
/* istanbul ignore else env ncore_3p4,ncore_3p6, ncore_3p7 */
if( interfaces.masterTriggerInt && !interfaces.masterTriggerInt._SKIP_ ) {
    DMI_DUP_UNIT_PORTS[masterTriggerInterface.name+'trigger'] = 'dup_unit__'+masterTriggerInterface.name+'trigger_sync';
}
if (usePma) {
    DMI_DUP_UNIT_PORTS[qInterfaceName+'REQn'] = 'dup_unit__'+qInterfaceName+'REQn_sync';
}
\jsend

    wire [\=wTotalSmiPortsNum-1=\:0] dup_unit__pm_trace_messages_dropped;
    wire [\=wTotalSmiPortsNum-1=\:0] dup_unit__pm_trace_messages_captured;

    \=obj.lib.instance({
        instanceName: 'dup_unit',
        moduleName: 'dmi_unit',
        params: dmi_unit_params,
        verilogParams: {},
        ports: DMI_DUP_UNIT_PORTS,
        interfaces: DMI_DUP_UNIT_INTF,
        portsDelimiter: '\n        '
    })=\
\js }

\jsbegin
// ===================================================================
// Trace Capture Instance
// Moved external to dmi_unit to avoid duplication. 
// Ensure proper ports of dup_unit feed through fault checker.
// ===================================================================
// TraceDebug Always enabled 
/* istanbul ignore else env ncore_3p4,ncore_3p6, ncore_3p7 */    
if (traceDebugEnable) { //TraceDebug Enabled: trace_capture instantiated
var trace_capture_intf_param = {};
trace_capture_intf_param['clkInt'] = {
                               name: '',
                               params: {},
                               direction: 'slave',
                               interface: 'InterfaceCLK'
                           };
\jsend
    \=obj.lib.instance({
        instanceName: 'trace_capture',
        moduleName: 'trace_capture',
        params: {
            assertOn: assertOn,
            smiRxPortInterfaces : SMI_RX_INTF,
            smiTxPortInterfaces: SMI_TX_INTF,
            nNDN: nNonDataNetworks,
            nDN: nDataNetworks,
            nUnitTraceBufSize: nUnitTraceBufSize,
            wForceAccumTimeout: 10,
            DTWReqInterface: CONC_INTF['DTWDBGReqInterface'],
            DTWRespInterface: CONC_INTF['DTWDBGRespInterface'],
	        traceRegInterface: {"name": 'csr_trace_', "signals":traceCsrIfGenerator.signalBundle("slave")},
            wFUnitId: wFUnitId,
            wFPortId: wFPortId,
            cmType: cmType,
            interfaces: trace_capture_intf_param
        },
        verilogParams: {},
        ports: {
            MyId:               unitIdInterfaceName+'my_f_unit_id',
            TargId:             uDveIdInterfaceName+'f_unit_id',
            pm_trace_messages_captured: 'pm_trace_messages_captured',
            pm_trace_messages_dropped: 'pm_trace_messages_dropped',
            trace_capture_busy: 'trace_capture_busy'
               },
        interfaces: TRACE_CAPTURE_INTF,
        portsDelimiter: '\n        '
    })=\

\jsbegin
} else { 
//Set DTW DBG Req keys to only those not excluded & non-zero widths
const dtw_excludes			= ['ready'];
const dtw_req_keys		= Object.keys(CONC_INTF['DTWDBGReqInterface']).filter(signal => !dtw_excludes.includes(signal) && CONC_INTF['DTWDBGReqInterface'][signal]);
const csr_keys		= Object.keys(traceCsrIfGenerator.signalBundle("master")).filter(signal => traceCsrIfGenerator.signalBundle("master")[signal]>0);
for (let key = 0; key < dtw_req_keys.length; key++) { \jsend
    //TraceDebug Disabled: tie-offs
    assign dtw_dbg_req_\=dtw_req_keys[key]=\ = \=CONC_INTF['DTWDBGReqInterface'][dtw_req_keys[key]]=\'h0;
\jsbegin
} 
for (let key = 0; key < csr_keys.length; key++) { \jsend
    assign csr_trace_\=csr_keys[key]=\ = \=traceCsrIfGenerator.signalBundle("master")[csr_keys[key]]=\'h0;
\jsbegin
} 
\jsend
    assign dtw_dbg_rsp_ready = 1'b1; 
    assign pm_trace_messages_captured = \=wTotalSmiPortsNum=\'h0; 
    assign pm_trace_messages_dropped = \=wTotalSmiPortsNum=\'h0; 
    assign trace_capture_busy = 1'b0; 
\jsbegin
} 
\jsend

\jsbegin
// =======================================================
// Checker Delay Instance
// =======================================================
\jsend

\js if (useResiliency && enableUnitDuplication) {
    wire reset_n_delay;
\jsbegin
    var delayInterfaceBundle   = {};
    var checkerInterfaceBundle = {};

if (usePma) {
    delayInterfaceBundle[qInterfaceName+'REQn_sync'] = 1;
}
// trigger intf always present on 3.4 
/* istanbul ignore else env ncore_3p4,ncore_3p6, ncore_3p7 */
if( interfaces.masterTriggerInt && !interfaces.masterTriggerInt._SKIP_ ) {
    delayInterfaceBundle[masterTriggerInterface.name+'trigger_sync'] = 1;
}
    delayInterfaceBundle['trace_capture_busy'] = 1;
    delayInterfaceBundle['pm_trace_messages_dropped'] = wTotalSmiPortsNum;
    delayInterfaceBundle['pm_trace_messages_captured'] = wTotalSmiPortsNum;
    if(useCmc & ccpParams.nBeatsPerBank > 1){
    delayInterfaceBundle["clkby2_en"] = 1;
    }

//ASILB without duplication not suport in Ncore3.7
 /* istanbul ignore if env ncore_3p7*/
if(ASILB){
    delayInterfaceBundle["cmux_active"] =1;
    if(nPerfCounters){
    delayInterfaceBundle["pmon_tx0_ndp_stall_in"] = 1;
    delayInterfaceBundle["pmon_tx1_ndp_stall_in"] = 1;
    delayInterfaceBundle["pmon_tx2_ndp_stall_in"] = 1;
    delayInterfaceBundle["pmon_tx3_dp_stall_in"]  = 1;
    delayInterfaceBundle["pmon_rx0_ndp_stall_in"] = 1;
    delayInterfaceBundle["pmon_rx1_ndp_stall_in"] = 1;
    delayInterfaceBundle["pmon_rx2_ndp_stall_in"] = 1;
    delayInterfaceBundle["pmon_rx3_dp_stall_in"]  = 1;         
    }
    delayInterfaceBundle["cmd_skid_buffer_empty"] = 1 ;        
     if (fnEnableQos) {
        checkerInterfaceBundle['cmd_skid_buffer_starv_en']             = 1 ;   
         checkerInterfaceBundle['cmd_skid_buffer_starv_threshold']      = wStarvThreshold  ;   
         checkerInterfaceBundle['cmd_skid_buffer_qos_disable']          = 1 ;  
         delayInterfaceBundle['cmd_skid_buffer_starv_overflow_event'] = 1 ;
         delayInterfaceBundle['cmd_skid_buffer_starv_mode']           = 1 ;
         checkerInterfaceBundle['cmd_skid_buffer_threshold_reached']    = 1  ;
         checkerInterfaceBundle['cmd_skid_buffer_DmiPriorityThVal']     = 4  ;
         delayInterfaceBundle["cmd_skid_buffer_full"]                 = 1  ;
     }
 
     delayInterfaceBundle["mrd_skid_buffer_empty"] = 1 ;        
     if (fnEnableQos) {
        checkerInterfaceBundle['mrd_skid_buffer_starv_en']             = 1           ;   
        checkerInterfaceBundle['mrd_skid_buffer_starv_threshold']      = wStarvThreshold    ;   
        checkerInterfaceBundle['mrd_skid_buffer_qos_disable']          = 1  ;  
        delayInterfaceBundle['mrd_skid_buffer_starv_overflow_event'] = 1  ;
        delayInterfaceBundle['mrd_skid_buffer_starv_mode']           = 1   ;
        checkerInterfaceBundle['mrd_skid_buffer_threshold_reached']    = 1   ;
        checkerInterfaceBundle['mrd_skid_buffer_DmiPriorityThVal']     = 4   ;
        delayInterfaceBundle["mrd_skid_buffer_full"]                 = 1   ;
     }
  
     checkerInterfaceBundle["read_trans_addr_t"] =1;
     checkerInterfaceBundle["write_trans_addr_t"] =1;

 }


        for (var intf = 0; intf < DMI_DUP_UNIT_INTF.length; intf++) {
            if (DMI_DUP_UNIT_INTF[intf].excludeFromFC != true) {
                var inputSignalKeys  = [];
                var outputSignalKeys = [];
                // Handle AXI Case of 2 Deep
                if (Object.keys(DMI_DUP_UNIT_INTF[intf].interface)[0] == 'ar_' ) {
                    var axiKeys = Object.keys(DMI_DUP_UNIT_INTF[intf].interface);
                    var prefix = DMI_UNIT_INTF[intf].localPrefix;
                    for( var axiKey = 0; axiKey < axiKeys.length; axiKey++ ) {
                        var axiSignals = Object.keys(DMI_DUP_UNIT_INTF[intf].interface[axiKeys[axiKey]]);
                        //Was required during asil work to have teh native interface info in the main block.
                        /* istanbul ignore else env ncore_3p7*/
                        if (DMI_UNIT_INTF[intf].direction == "master"){
                            for( var axiSig = 0; axiSig < axiSignals.length; axiSig++ ) {
    	                        if(DMI_DUP_UNIT_INTF[intf].interface[axiKeys[axiKey]][axiSignals[axiSig]] < 0) {
    	                            delayInterfaceBundle[prefix + axiKeys[axiKey] + axiSignals[axiSig]] = Math.abs(DMI_DUP_UNIT_INTF[intf].interface[axiKeys[axiKey]][axiSignals[axiSig]]);
    	                        } else if (DMI_DUP_UNIT_INTF[intf].interface[axiKeys[axiKey]][axiSignals[axiSig]] > 0){
    	                            checkerInterfaceBundle[prefix + axiKeys[axiKey] + axiSignals[axiSig]] = Math.abs(DMI_DUP_UNIT_INTF[intf].interface[axiKeys[axiKey]][axiSignals[axiSig]]);
    	                        }
    	                    }
                        } else {
                            for( var axiSig = 0; axiSig < axiSignals.length; axiSig++ ) {
    	                        if(DMI_DUP_UNIT_INTF[intf].interface[axiKeys[axiKey]][axiSignals[axiSig]] > 0) {
    	                            delayInterfaceBundle[prefix + axiKeys[axiKey] + axiSignals[axiSig]] = Math.abs(DMI_DUP_UNIT_INTF[intf].interface[axiKeys[axiKey]][axiSignals[axiSig]]);
    	                        } else if (DMI_DUP_UNIT_INTF[intf].interface[axiKeys[axiKey]][axiSignals[axiSig]] < 0){
    	                            checkerInterfaceBundle[prefix + axiKeys[axiKey] + axiSignals[axiSig]] = Math.abs(DMI_DUP_UNIT_INTF[intf].interface[axiKeys[axiKey]][axiSignals[axiSig]]);
    	                        }
    	                    }



                        }
                    }
                } else {
                    if (DMI_UNIT_INTF[intf].direction == "master"){
                        inputSignalKeys  = Object.keys(DMI_DUP_UNIT_INTF[intf].interface).filter(key => (DMI_DUP_UNIT_INTF[intf].interface[key] < 0) & key != 'clk' & key != 'reset_n' & key != 'test_en');
                        outputSignalKeys = Object.keys(DMI_DUP_UNIT_INTF[intf].interface).filter(key => (DMI_DUP_UNIT_INTF[intf].interface[key] > 0) & key != 'clk' & key != 'reset_n' & key != 'test_en');
                    } else {
                        inputSignalKeys  = Object.keys(DMI_DUP_UNIT_INTF[intf].interface).filter(key => (DMI_DUP_UNIT_INTF[intf].interface[key] > 0) & key != 'clk' & key != 'reset_n' & key != 'test_en');
                        outputSignalKeys = Object.keys(DMI_DUP_UNIT_INTF[intf].interface).filter(key => (DMI_DUP_UNIT_INTF[intf].interface[key] < 0) & key != 'clk' & key != 'reset_n' & key != 'test_en');
                    }
                    for (var sig = 0; sig < inputSignalKeys.length; sig++) {
                        delayInterfaceBundle[DMI_UNIT_INTF[intf].localPrefix + inputSignalKeys[sig]] = Math.abs(DMI_DUP_UNIT_INTF[intf].interface[inputSignalKeys[sig]]);
                    }
                    for (var sig = 0; sig < outputSignalKeys.length; sig++) {
                        checkerInterfaceBundle[DMI_UNIT_INTF[intf].localPrefix + outputSignalKeys[sig]] = Math.abs(DMI_DUP_UNIT_INTF[intf].interface[outputSignalKeys[sig]]);
                    }
                }
            }
        }

    var delayInterfaces = [];

    delayInterfaces.push({
            modulePrefix: '',
            localPrefix: clkInterfaceName,
            interface: clkInterface
    });

    delayInterfaces.push({
            modulePrefix: 'in_',
            localPrefix: '',
            interface: delayInterfaceBundle
    });

    delayInterfaces.push({
            modulePrefix: 'out_',
            localPrefix: 'dup_unit__',
            interface: delayInterfaceBundle
    });

var checker_delay_ports = {};
checker_delay_ports['reset_n_delay'] = 'reset_n_delay';
// trigger intf always present on 3.4 
/* istanbul ignore else env ncore_3p4,ncore_3p6, ncore_3p7 */
if( interfaces.masterTriggerInt && !interfaces.masterTriggerInt._SKIP_ ) {
    checker_delay_ports['in_'+masterTriggerInterface.name+'trigger_sync'] = masterTriggerInterface.name+'trigger_sync';
    checker_delay_ports['out_'+masterTriggerInterface.name+'trigger_sync'] = 'dup_unit__'+masterTriggerInterface.name+'trigger_sync';
}

if (usePma) {
    checker_delay_ports['in_'+qInterfaceName+'REQn_sync'] = qInterfaceName+'REQn_sync';
    checker_delay_ports['out_'+qInterfaceName+'REQn_sync'] = 'dup_unit__'+qInterfaceName+'REQn_sync';
}

\jsend

    \=obj.lib.instance({
        instanceName   : 'delay_unit',
        moduleName     : 'checker_delay',
        params         :  {
                             clkInterface    : clkInterface,
                             delayInterface  : delayInterfaceBundle,
                             nDelay          : nResiliencyDelay
                          },
        interfaces     : delayInterfaces,
        ports          : checker_delay_ports, 
        verilogParams  :  {},
        portsDelimiter : '\n    '
    })=\

\js }

\jsbegin
// =======================================================
// Fault Checker
// =======================================================
\jsend

\js if (useResiliency) {

assign \=bistInterfaceName=\domain_is_on = 1'b1;

\jsbegin
var DMI_CHECKER_INTF = [];

DMI_CHECKER_INTF.push({
    modulePrefix: '',
    localPrefix: bistInterfaceName,
    interface: bistInterfaceBundle, exclude : ['domain_is_on']
});

DMI_CHECKER_INTF.push({
    modulePrefix: '',
    localPrefix: faultInterfaceName,
    interface: faultInterfaceBundle, exclude : ['late_clk']
});

if (enableUnitDuplication) {
    checkerInterfaceBundle.res_cerr_thresh = wResThreshold;
    DMI_CHECKER_INTF.push({
        modulePrefix: 'func_',
        localPrefix: '',
        interface: checkerInterfaceBundle
    });

    DMI_CHECKER_INTF.push({
        modulePrefix: 'check_',
        localPrefix: 'dup_unit__',
        interface: checkerInterfaceBundle
    });

}

\jsend

wire func_0_fault_in       = dmi_placeholder_UCE;       
wire func_0_cerr_fault_in  = dmi_placeholder_CE;
\js if (enableUnitDuplication) {
wire check_0_fault_in      = dup_unit__dmi_placeholder_UCE;
wire check_0_cerr_fault_in = dup_unit__dmi_placeholder_CE;
\js } else {
wire check_0_fault_in      = dmi_placeholder_UCE;
wire check_0_cerr_fault_in = dmi_placeholder_CE;
\js }

wire func_1_fault_in       = dmi_cmux_UCE;       
wire func_1_cerr_fault_in  = dmi_cmux_cmd_req_CE;    
\jsbegin    
//ASILB without duplication not suport in Ncore3.7
 /* istanbul ignore else env ncore_3p7*/
 if (enableUnitDuplication & !ASILB) {
\jsend
wire check_1_fault_in      = dup_unit__dmi_cmux_UCE;
wire check_1_cerr_fault_in = dup_unit__dmi_cmux_cmd_req_CE; 
\js } else {
wire check_1_fault_in      = dmi_cmux_UCE;
wire check_1_cerr_fault_in = dmi_cmux_cmd_req_CE; 
\js }

wire func_2_fault_in       = dmi_smc_tag_UCE;       
wire func_2_cerr_fault_in  = dmi_cmux_mrd_req_CE;        

\jsbegin    
//ASILB without duplication not suport in Ncore3.7
 /* istanbul ignore else env ncore_3p7*/
 if (enableUnitDuplication & !ASILB) {
\jsend
wire check_2_fault_in      = dup_unit__dmi_smc_tag_UCE; 
wire check_2_cerr_fault_in = dup_unit__dmi_cmux_mrd_req_CE;
\js } else {
wire check_2_fault_in      = dmi_smc_tag_UCE; 
wire check_2_cerr_fault_in = dmi_cmux_mrd_req_CE;
\js }

wire func_3_fault_in       = dmi_smc_data_UCE;       
wire func_3_cerr_fault_in  = dmi_cmux_rbr_req_CE;        

\js if (enableUnitDuplication) {
wire check_3_fault_in      = dup_unit__dmi_smc_data_UCE; 
\jsbegin    
//ASILB without duplication not suport in Ncore3.7
 /* istanbul ignore else env ncore_3p7*/
    if(!ASILB){
\jsend
    wire check_3_cerr_fault_in = dup_unit__dmi_cmux_rbr_req_CE;
\js } else {
    wire check_3_cerr_fault_in = dmi_cmux_rbr_req_CE;
\js}

\js } else {
wire check_3_fault_in      = dmi_smc_data_UCE; 
wire check_3_cerr_fault_in = dmi_cmux_rbr_req_CE;
\js }

wire func_4_fault_in       = dmi_c_wr_buff_UCE; //dmi_native_rd_resp_UCE;       
wire func_4_cerr_fault_in  = dmi_cmux_str_rsp_CE;        

\js if (enableUnitDuplication) {
wire check_4_fault_in      = dup_unit__dmi_c_wr_buff_UCE; //dup_unit__dmi_native_rd_resp_UCE; 

\jsbegin    
//ASILB without duplication not suport in Ncore3.7
 /* istanbul ignore else env ncore_3p7*/
    if(!ASILB){
\jsend
    wire check_4_cerr_fault_in = dup_unit__dmi_cmux_str_rsp_CE;
\js } else {
    wire check_4_cerr_fault_in = dmi_cmux_str_rsp_CE;
\js}
\js } else {
wire check_4_fault_in      = dmi_c_wr_buff_UCE; //dmi_native_rd_resp_UCE; 
wire check_4_cerr_fault_in = dmi_cmux_str_rsp_CE;
\js }

wire func_5_fault_in       = dmi_timeout_error_UCE; //dmi_native_wr_resp_UCE;       
wire func_5_cerr_fault_in  = 1'b0;        

\js if (enableUnitDuplication) {
wire check_5_fault_in      = dup_unit__dmi_timeout_error_UCE; //dup_unit__dmi_native_wr_resp_UCE; 
wire check_5_cerr_fault_in = 1'b0;
\js } else {
wire check_5_fault_in      = dmi_timeout_error_UCE; //dmi_native_wr_resp_UCE; 
wire check_5_cerr_fault_in = 1'b0;
\js }

wire func_6_fault_in       = dmi_target_id_UCE;       
wire func_6_cerr_fault_in  = dmi_cmux_dtr_rsp_CE;        

\js if (enableUnitDuplication) {
wire check_6_fault_in      = dup_unit__dmi_target_id_UCE; 
\jsbegin    
//ASILB without duplication not suport in Ncore3.7
 /* istanbul ignore else env ncore_3p7*/
    if(!ASILB){
\jsend
    wire check_6_cerr_fault_in = dup_unit__dmi_cmux_dtr_rsp_CE;
\js } else {
    wire check_6_cerr_fault_in = dmi_cmux_dtr_rsp_CE;
\js}
\js } else {
wire check_6_fault_in      = dmi_target_id_UCE; 
wire check_6_cerr_fault_in = dmi_cmux_dtr_rsp_CE;
\js }

wire func_7_fault_in       = dmi_rd_buffer_UCE;
wire func_7_cerr_fault_in  = dmi_cmux_dtw_req_CE;        

\js if (enableUnitDuplication) {
wire check_7_fault_in      = dup_unit__dmi_rd_buffer_UCE;
\jsbegin    
//ASILB without duplication not suport in Ncore3.7
 /* istanbul ignore else env ncore_3p7*/
    if(!ASILB){
\jsend
    wire check_7_cerr_fault_in = dup_unit__dmi_cmux_dtw_req_CE;
\js } else {
    wire check_7_cerr_fault_in = dmi_cmux_dtw_req_CE;
\js}
\js } else {
wire check_7_fault_in      = dmi_rd_buffer_UCE;
wire check_7_cerr_fault_in = dmi_cmux_dtw_req_CE;
\js }

wire func_8_fault_in       = 1'h0;       
wire check_8_fault_in      = 1'h0; 
wire func_8_cerr_fault_in  = dmi_smc_tag_CE;        

\js if (enableUnitDuplication) {
wire check_8_cerr_fault_in = dup_unit__dmi_smc_tag_CE;
\js } else {
wire check_8_cerr_fault_in = dmi_smc_tag_CE;
\js }

wire func_9_fault_in       = 1'h0;       
wire check_9_fault_in      = 1'h0; 
wire func_9_cerr_fault_in  = dmi_smc_data_CE;        

\js if (enableUnitDuplication) {
wire check_9_cerr_fault_in = dup_unit__dmi_smc_data_CE;
\js } else {
wire check_9_cerr_fault_in = dmi_smc_data_CE;
\js }

wire func_10_fault_in       = 1'h0;       
wire check_10_fault_in      = 1'h0; 
wire func_10_cerr_fault_in  = dmi_c_wr_buff_CE;        

\js if (enableUnitDuplication) {
wire check_10_cerr_fault_in = dup_unit__dmi_c_wr_buff_CE;
\js } else {
wire check_10_cerr_fault_in = dmi_c_wr_buff_CE;
\js }

wire func_11_fault_in       = 1'h0;
wire check_11_fault_in      = 1'h0;
wire func_11_cerr_fault_in  = dmi_cmux_dtw_dbg_rsp_CE;

\js if (enableUnitDuplication) {

    \jsbegin    
    //ASILB without duplication not suport in Ncore3.7
     /* istanbul ignore else env ncore_3p7*/
        if(!ASILB){
    \jsend
        wire check_11_cerr_fault_in = dup_unit__dmi_cmux_dtw_dbg_rsp_CE;
    \js } else {
        wire check_11_cerr_fault_in = dmi_cmux_dtw_dbg_rsp_CE;
    \js}

\js } else {
wire check_11_cerr_fault_in = dmi_cmux_dtw_dbg_rsp_CE;
\js }

wire func_12_fault_in       = 1'h0;
wire check_12_fault_in      = 1'h0;
wire func_12_cerr_fault_in  = dmi_rd_buffer_CE;

\js if (enableUnitDuplication) {
wire check_12_cerr_fault_in = dup_unit__dmi_rd_buffer_CE;
\js } else {
wire check_12_cerr_fault_in = dmi_rd_buffer_CE;
\js }


\js if(cmdSkidBufferParams["useSramFifo"]){

wire func_13_fault_in       = dmi_cmd_skid_buffer_uce;       
wire func_13_cerr_fault_in  = dmi_cmd_skid_buffer_ce;        

\js if (enableUnitDuplication) {
wire check_13_cerr_fault_in = dup_unit__dmi_cmd_skid_buffer_ce;
wire check_13_fault_in      = dup_unit__dmi_cmd_skid_buffer_uce; 

\js } else {
wire check_13_cerr_fault_in = dmi_cmd_skid_buffer_ce;
wire check_13_fault_in      = dmi_cmd_skid_buffer_uce; 
\js }

\js } else {

wire func_13_fault_in       = 1'b0;       
wire func_13_cerr_fault_in  = 1'b0;        
wire check_13_cerr_fault_in = 1'b0;
wire check_13_fault_in      = 1'b0; 
    
\js }


\js if(mrdSkidBufferParams["useSramFifo"]){
wire func_14_fault_in       = dmi_mrd_skid_buffer_uce;       
wire func_14_cerr_fault_in  = dmi_mrd_skid_buffer_ce;        

\js if (enableUnitDuplication) {
wire check_14_cerr_fault_in = dup_unit__dmi_mrd_skid_buffer_ce;
wire check_14_fault_in      = dup_unit__dmi_mrd_skid_buffer_uce; 

\js } else {
wire check_14_cerr_fault_in = dmi_mrd_skid_buffer_ce;
wire check_14_fault_in      = dmi_mrd_skid_buffer_uce; 
\js }
\js } else {

    wire func_14_fault_in       = 1'b0;       
    wire func_14_cerr_fault_in  = 1'b0;        
    wire check_14_cerr_fault_in = 1'b0;
    wire check_14_fault_in      = 1'b0; 
        
    \js }
    

\jsbegin
var DMI_CHECKER_PORTS = {   
                             clk                   : 'fault_checker_clk',
                             reset_n               : 'fault_checker_reset_n',
                             func_0_fault_in       : 'func_0_fault_in',
                             check_0_fault_in      : 'check_0_fault_in',
                             func_0_cerr_fault_in  : 'func_0_cerr_fault_in',
                             check_0_cerr_fault_in : 'check_0_cerr_fault_in',
                             func_1_fault_in       : 'func_1_fault_in',
                             check_1_fault_in      : 'check_1_fault_in',
                             func_1_cerr_fault_in  : 'func_1_cerr_fault_in',
                             check_1_cerr_fault_in : 'check_1_cerr_fault_in',
                             func_2_fault_in       : 'func_2_fault_in',
                             check_2_fault_in      : 'check_2_fault_in',
                             func_2_cerr_fault_in  : 'func_2_cerr_fault_in',
                             check_2_cerr_fault_in : 'check_2_cerr_fault_in',
                             func_3_fault_in       : 'func_3_fault_in',
                             check_3_fault_in      : 'check_3_fault_in',
                             func_3_cerr_fault_in  : 'func_3_cerr_fault_in',
                             check_3_cerr_fault_in : 'check_3_cerr_fault_in',
                             func_4_fault_in       : 'func_4_fault_in',
                             check_4_fault_in      : 'check_4_fault_in',
                             func_4_cerr_fault_in  : 'func_4_cerr_fault_in',
                             check_4_cerr_fault_in : 'check_4_cerr_fault_in',
                             func_5_fault_in       : 'func_5_fault_in',
                             check_5_fault_in      : 'check_5_fault_in',
                             func_5_cerr_fault_in  : 'func_5_cerr_fault_in',
                             check_5_cerr_fault_in : 'check_5_cerr_fault_in',
                             func_6_fault_in       : 'func_6_fault_in',
                             check_6_fault_in      : 'check_6_fault_in',
                             func_6_cerr_fault_in  : 'func_6_cerr_fault_in',
                             check_6_cerr_fault_in : 'check_6_cerr_fault_in',
                             func_7_fault_in       : 'func_7_fault_in',
                             check_7_fault_in      : 'check_7_fault_in',
                             func_7_cerr_fault_in  : 'func_7_cerr_fault_in',
                             check_7_cerr_fault_in : 'check_7_cerr_fault_in',
                             func_8_fault_in       : 'func_8_fault_in',
                             check_8_fault_in      : 'check_8_fault_in',
                             func_8_cerr_fault_in  : 'func_8_cerr_fault_in',
                             check_8_cerr_fault_in : 'check_8_cerr_fault_in',
                             func_9_fault_in       : 'func_9_fault_in',
                             check_9_fault_in      : 'check_9_fault_in',
                             func_9_cerr_fault_in  : 'func_9_cerr_fault_in',
                             check_9_cerr_fault_in : 'check_9_cerr_fault_in',
                             func_10_fault_in      : 'func_10_fault_in',
                             check_10_fault_in     : 'check_10_fault_in',
                             func_10_cerr_fault_in  : 'func_10_cerr_fault_in',
                             check_10_cerr_fault_in : 'check_10_cerr_fault_in',
                             func_11_fault_in      : 'func_11_fault_in',
                             check_11_fault_in     : 'check_11_fault_in',
                             func_11_cerr_fault_in  : 'func_11_cerr_fault_in',
                             check_11_cerr_fault_in : 'check_11_cerr_fault_in',
                             func_12_fault_in      : 'func_12_fault_in',
                             check_12_fault_in     : 'check_12_fault_in',
                             func_12_cerr_fault_in  : 'func_12_cerr_fault_in',
                             check_12_cerr_fault_in : 'check_12_cerr_fault_in',
                             func_13_fault_in       : 'func_13_fault_in',
                             check_13_fault_in      : 'check_13_fault_in',
                             func_13_cerr_fault_in  : 'func_13_cerr_fault_in',
                             check_13_cerr_fault_in : 'check_13_cerr_fault_in',
                             func_14_fault_in       : 'func_14_fault_in',
                             check_14_fault_in      : 'check_14_fault_in',
                             func_14_cerr_fault_in  : 'func_14_cerr_fault_in',
                             check_14_cerr_fault_in : 'check_14_cerr_fault_in',
                             cerr_threshold        : 'res_cerr_thresh'
                     };

if (enableUnitDuplication) {
    DMI_CHECKER_PORTS['reset_n_delay'] = 'reset_n_delay';
} else {
    DMI_CHECKER_PORTS['reset_n_delay'] = clkInterfaceName+'reset_n';
}
\jsend

    \=obj.lib.instance({
        instanceName   : 'u_dmi_fault_checker',
        moduleName     : 'fault_checker',
        params         :  {
                             nDelay                 : (enableUnitDuplication ? nResiliencyDelay : 0),
                             wThresWidth            : wResThreshold,
                             clkInterface           : intClkInterface,
                             enableUnitDuplication  : enableUnitDuplication,
                             checkerInterface       : (enableUnitDuplication ? checkerInterfaceBundle : {}),
                             numFaultInputs         : 15,
			     eSignalPipe            : 1	     
                          },
        verilogParams  :  {},
        interfaces     :  DMI_CHECKER_INTF,
        ports          :  DMI_CHECKER_PORTS,
        portsDelimiter : '\n    '
    })=\
\js }

\jsbegin
// =======================================================
// Wire Connections
// =======================================================
\jsend

\js if (useResiliency) {
assign fault_checker_clk = \=clkInterfaceName=\clk;
assign fault_checker_reset_n = \=clkInterfaceName=\reset_n;
\js }

\js if (useResiliency && enableUnitDuplication) {
assign dup_unit__\=clkInterfaceName=\clk    = \=checkClkInterfaceName=\clk;
assign dup_unit__\=clkInterfaceName=\reset_n= reset_n_delay;
\jsbegin
 /* istanbul ignore else env ncore_3p2, ncore_3p4,ncore_3p6, ncore_3p7 */    
 if (checkClkInterfaceParam.wTestEn) {   \jsend
assign dup_unit__\=clkInterfaceName=\test_en= \=checkClkInterfaceName=\test_en;
\js     }
\js }

\jsbegin
//========================================================
//Concerto Mux
//========================================================
//ASILB without duplication not suport in Ncore3.7
 /* istanbul ignore if env ncore_3p7*/
if (ASILB){

//No Smi port needs to be added to Dmi Unit
//Concerto messages port needs to be added to DMI unit


var CONCERTO_MUX_INTF = [];
for (var i=0; i<SMI_TX_INTF.length; i++){
    CONCERTO_MUX_INTF.push({
                               modulePrefix: SMI_TX_INTF[i].name, 
                               localPrefix: SMI_TX_INTF[i].name, 
                               interface: SMI_TX_INTF[i].signals
    });

    if(SMI_TX_INTF[i].params.dpPresent) {
        CONCERTO_MUX_INTF.push({
                                modulePrefix: SMI_TX_INTF[i].name, 
                                localPrefix: SMI_TX_INTF[i].name, 
                                interface: SMI_TX_INTF[i].dpSignals
        });
    }
};
for (var i=0; i<SMI_RX_INTF.length; i++) {
    CONCERTO_MUX_INTF.push({
                                modulePrefix: SMI_RX_INTF[i].name, 
                                localPrefix: SMI_RX_INTF[i].name, 
                                interface: SMI_RX_INTF[i].signals
    });

    if(SMI_RX_INTF[i].params.dpPresent) {
        CONCERTO_MUX_INTF.push({
                                    modulePrefix: SMI_RX_INTF[i].name, 
                                    localPrefix: SMI_RX_INTF[i].name, 
                                    interface: SMI_RX_INTF[i].dpSignals
        });
    }
};
for (var i=0; i<CONC_TX_INTF.length; i++) {
    CONCERTO_MUX_INTF.push({
                                modulePrefix: CONC_TX_INTF[i].name, 
                                localPrefix: CONC_TX_INTF[i].name, 
                                interface: CONC_TX_INTF[i].signals
    });
};
for (var i=0; i<CONC_RX_INTF.length; i++) {
    if(CONC_RX_INTF[i].name=='dtw_dbg_rsp_') {
    CONCERTO_MUX_INTF.push({
                                modulePrefix: CONC_RX_INTF[i].name, 
                                localPrefix: CONC_RX_INTF[i].name+'prot_', 
                                interface: CONC_RX_INTF[i].signals
    });
    } else {
    CONCERTO_MUX_INTF.push({
                                modulePrefix: CONC_RX_INTF[i].name, 
                                localPrefix: CONC_RX_INTF[i].name, 
                                interface: CONC_RX_INTF[i].signals
    });
    }
};

trace_capture_intf_param['clkInt'] = {
    name: '',
    params: {},
    direction: 'slave',
    interface: 'InterfaceCLK'
};
CONCERTO_MUX_INTF.push({
    modulePrefix: '',
    localPrefix: clkInterfaceName,
    interface: clkInterface,
    direction: interfaces.clkInt.direction,
    exclude: ["test_en"]
});  

\jsend

wire [\=wTotalSmiPortsNum-1=\:0] pmon_trace_messages_dropped;
wire [\=wTotalSmiPortsNum-1=\:0] pmon_trace_messages_captured;


\jsbegin



var concertoMuxFaultPorts = {};
var conc_intf_iterated = []; 

// Create CMUX/Tre Fault Ports if they Exist
var create_UCE = false;
for(let i=0; i<SMI_RX_INTF.length; i++) 
{    
   for (let j=0; j<SMI_RX_INTF[i].params.fnMsgClass.length; j++)
   {
     let name = SMI_RX_INTF[i].params.fnMsgClass[j];
     let index = CONC_RX_INTF.findIndex(function(element) {return element.name === name; });

     var hasMessageProt  = (CONC_RX_INTF[index].params.protection != null & CONC_RX_INTF[index].params.protection != "none");
     var hasDataProt     = (CONC_RX_INTF[index].params.dpProtection != null & CONC_RX_INTF[index].params.dpProtection != "none" & CONC_RX_INTF[index].params.dpPresent);
     var hasHeaderProt   = (SMI_RX_INTF[i].params.protection != null & SMI_RX_INTF[i].params.protection != "none");
     var isDuplicate     = conc_intf_iterated.includes(name);
     /* istanbul ignore else env ncore_3p0 */
     if((hasMessageProt | hasDataProt | hasHeaderProt) & !isDuplicate) {
        //u.port('output', CONC_RX_INTF[index].name + 'CE', 1);
        concertoMuxFaultPorts[CONC_RX_INTF[index].name + 'CE'] = 'dmi_cmux_' + CONC_RX_INTF[index].name + 'CE';
     }   //if else is restructured with else{if()}
     else {
    /* istanbul ignore else env ncore_3p2, ncore_3p4,ncore_3p6, ncore_3p7 */
\jsend
    assign  dmi_cmux_\=CONC_RX_INTF[index].name=\CE = 'h0;
\jsbegin
}
     if(hasHeaderProt & !isDuplicate ) {
\jsend
    wire dmi_cmux_\=CONC_RX_INTF[index].name=\header_UCE;
\jsbegin
    concertoMuxFaultPorts[CONC_RX_INTF[index].name + 'header_UCE'] = 'dmi_cmux_' + CONC_RX_INTF[index].name + 'header_UCE';
        create_UCE = true;
     }
     if(hasMessageProt & !isDuplicate ) {
\jsend
    wire dmi_cmux_\=CONC_RX_INTF[index].name=\message_UCE;
\jsbegin
    concertoMuxFaultPorts[CONC_RX_INTF[index].name + 'message_UCE'] = 'dmi_cmux_' + CONC_RX_INTF[index].name + 'message_UCE';
     } 
     if(hasDataProt & !isDuplicate ) {
\jsend
    wire dmi_cmux_\=CONC_RX_INTF[index].name=\data_UCE;
\jsbegin
    concertoMuxFaultPorts[CONC_RX_INTF[index].name + 'data_UCE'] = 'dmi_cmux_' + CONC_RX_INTF[index].name + 'data_UCE';
     }
   }
}
concertoMuxFaultPorts['busy'] = 'cmux_active';
\jsend

// aggregate header uncorrectable errors into one UCE signal
assign dmi_cmux_UCE = 1'b0 
\jsbegin
    for(let i=0; i<SMI_RX_INTF.length; i++){    
        for (let j=0; j<SMI_RX_INTF[i].params.fnMsgClass.length; j++){
            let name = SMI_RX_INTF[i].params.fnMsgClass[j];
            let index = CONC_RX_INTF.findIndex(function(element) {return element.name === name; });
            var hasHeaderProt   = (SMI_RX_INTF[i].params.protection != null & SMI_RX_INTF[i].params.protection != "none");
            if(hasHeaderProt) { 
\jsend
                | dmi_cmux_\=SMI_RX_INTF[i].params.fnMsgClass[j]=\header_UCE  
\jsbegin
            }
            var hasMessageProt  = (CONC_RX_INTF[index].params.protection != null & CONC_RX_INTF[index].params.protection != "none");
            if( hasMessageProt ) { 
\jsend
                | dmi_cmux_\=SMI_RX_INTF[i].params.fnMsgClass[j]=\message_UCE  
\jsbegin
            }
            var hasDataProt     = (CONC_RX_INTF[index].params.dpProtection != null & CONC_RX_INTF[index].params.dpProtection != "none" & CONC_RX_INTF[index].params.dpPresent);
            if( hasDataProt ) { 
\jsend
                | dmi_cmux_\=SMI_RX_INTF[i].params.fnMsgClass[j]=\data_UCE  
\jsbegin
            }
        }
    } 
\jsend
;
\=obj.lib.instance ({
            instanceName: 'dmi_concerto_mux',
            moduleName: 'concerto_mux',
            params : {
                      wFPortId : wFPortId,
                      wFUnitId : wFUnitId,
                      smiTxPortInterfaces : SMI_TX_INTF,
                      smiRxPortInterfaces : SMI_RX_INTF,
                      concertoTxInterfaces : CONC_TX_INTF,
                      concertoRxInterfaces : CONC_RX_INTF
                      },
            verilogParams : {},
            ports : concertoMuxFaultPorts,
            interfaces : CONCERTO_MUX_INTF})=\


        \jsbegin
        if(!nPerfCounters) {
            var pmonEventTable            = [];
        
        } else {
          const smiTxStallEvents		= SMI_TX_INTF.map( m.genSmiStallEvent ); // Returns an array with { width, expr } objects one for each interface in SMI_TX_INTF array
          const smiRxStallEvents		= SMI_RX_INTF.map( m.genSmiStallEvent ); // Returns an array with { width, expr } objects one for each interface in SMI_RX_INTF array
        \jsend
        
        
        assign pmon_tx0_ndp_stall_in = \=smiTxStallEvents[0].expr=\;
        assign pmon_tx1_ndp_stall_in = \=smiTxStallEvents[1].expr=\;
        assign pmon_tx2_ndp_stall_in = \=smiTxStallEvents[2].expr=\;
        assign pmon_tx3_dp_stall_in  = \=smiTxStallEvents[3].expr=\;
        assign pmon_rx0_ndp_stall_in = \=smiRxStallEvents[0].expr=\;
        assign pmon_rx1_ndp_stall_in = \=smiRxStallEvents[1].expr=\;
        assign pmon_rx2_ndp_stall_in = \=smiRxStallEvents[2].expr=\;
        assign pmon_rx3_dp_stall_in  = \=smiRxStallEvents[3].expr=\;
        
        \jsbegin
        }
} else {
    //smi ports needs to be created to dmi_unit
    //No instanciation
    //No concerto messages port
\jsend


\jsbegin
}
//========================================================
// end Concerto mux
//========================================================

//ASILB without duplication not suport in Ncore3.7
/* istanbul ignore if env ncore_3p7*/
if(ASILB){
//========================================================
// RTT flops
//========================================================
\jsend

\=obj.lib.instance ({
    instanceName: 'dmi_rtt_flops',
    moduleName: 'dmi_tt_flops',
    params : {  N_TT                         : cmpInfo.nRttCtrlEntries,
                tt_req_alloc_bundle_width    : bundleFunctions.getBundleWidth(rttLookup,['dwid', 'fill'],u.bundle),
                ASSERT_ON                    : assertOn
              },
    verilogParams : {},
    ports : {tt_req_alloc_bundle_clk     : clkInterfaceName+"clk",
             tt_req_alloc_bundle_reset_n : clkInterfaceName+"reset_n"},
    interfaces : [RTT_FLOP_INTERFACE]})=\

\jsbegin
//========================================================
// end RTT flops
//========================================================

//========================================================
// WTT flops
//========================================================

\jsend

 \=obj.lib.instance ({
    instanceName: 'dmi_wtt_flops',
    moduleName: 'dmi_tt_flops',
    params : { N_TT                         : cmpInfo.nWttCtrlEntries,
               tt_req_alloc_bundle_width    : bundleFunctions.getBundleWidth(wttLookup,[],u.bundle),
               ASSERT_ON                    : assertOn
              },
    verilogParams : {},
    ports : {tt_req_alloc_bundle_clk     : clkInterfaceName+"clk",
             tt_req_alloc_bundle_reset_n : clkInterfaceName+"reset_n"},
    interfaces : [WTT_FLOP_INTERFACE]})=\
\jsbegin
//========================================================
// end WTT flops
//========================================================

//========================================================
// Coherent write buffer address flops
//========================================================
\jsend

 \=obj.lib.instance ({
    instanceName: 'dmi_c_rb_flops',
    moduleName: 'dmi_rb_flops',
    params : {  N_RB                         : bufferSize.RBRReqBuffer,
                rb_req_alloc_bundle_width    : bundleFunctions.getBundleWidth(c_rbidBuffer,[],u.bundle),
                ASSERT_ON                    : assertOn
              },
    verilogParams : {},
    ports : {clk     : clkInterfaceName+"clk",
             reset_n : clkInterfaceName+"reset_n"},
    interfaces : [C_RB_FLOP_INTERFACE]})=\

\jsbegin
//========================================================
// end Coherent write buffer flops
//========================================================


//========================================================
// Non-Coherent write buffer address flops
//========================================================
\jsend

 \=obj.lib.instance ({
    instanceName: 'dmi_nc_rb_flops',
    moduleName: 'dmi_rb_flops',
    params : {  N_RB                         : cmpInfo.nDmiRbEntries,
                rb_req_alloc_bundle_width    : bundleFunctions.getBundleWidth(nc_rbidBuffer,[],u.bundle),
                ASSERT_ON                    : assertOn
              },
    verilogParams : {},
    ports : {clk     : clkInterfaceName+"clk",
             reset_n : clkInterfaceName+"reset_n"},
    interfaces : [NC_RB_FLOP_INTERFACE]})=\
    
\jsbegin
//========================================================
// end non-Coherent write buffer flops
//========================================================


//========================================================
// Non-Coherent write buffer data flops
//========================================================
\jsend
\=obj.lib.instance ({
    instanceName: 'dmi_nc_data_flops',
    moduleName: 'dmi_nc_data_flops',
    params : {  N_RB                         : bufferSize.NCDataBuffer,
                rb_data_alloc_bundle_width    : bundleFunctions.getBundleWidth(nc_dataBuffer,[],u.bundle),
                ASSERT_ON                    : assertOn
              },
    verilogParams : {},
    ports : {clk     : clkInterfaceName+"clk",
             reset_n : clkInterfaceName+"reset_n"},
    interfaces : [NC_DATA_FLOP_INTERFACE]})=\

\jsbegin

//========================================================
// end non-Coherent write buffer data flops
//========================================================






//=============================================================================
// CmdReq skid buffer 
//=============================================================================

\jsend
    \=obj.lib.instance({
        instanceName        : 'cmd_skid_buffer',
        moduleName          : 'dmi_skid_buffer',
        params              : cmdSkidBufferParams,
        verilogParams       : {},
        ports               : cmdSkidBufferPorts,
        interfaces          : cmdSkidBufferInterfaces
    })=\

\jsbegin    
//=============================================================================
// End CmdReq skid buffer 
//=============================================================================
//=================================================================================================
// MRD Skid Buffer
//=================================================================================================
\jsend


\=obj.lib.instance({
    instanceName    : 'mrd_skid_buffer',
    moduleName      : 'dmi_skid_buffer',
    params          : mrdSkidBufferParams,
    verilogParams   : {},
    ports           : mrdSkidBufferPorts,
    interfaces      : mrdSkidBufferInterfaces
})=\

\jsbegin
//////////////////////////////////////////
// End output fifo
/////////////////////////////////////////





//////////////////////////////////////////
// DMI native interface fifos
/////////////////////////////////////////
\jsend
\=obj.lib.instance({
    instanceName: 'dmi_native_interface',
    moduleName: 'dmi_native_interface',
    params: {
        clkInterface: intClkInterface,
        wUser : wRdUser,
        wDataUser: wWrDataUser,
        readTransactionInterface: readTransactionInterface,
        writeTransactionInterface: writeTransactionInterface,
        readDataInterface: readDataInterface,
        writeDataInterface: writeDataInterface,
        writeResponseInterface: writeResponseInterface,
        AXIInterface: axiInterfaceBundle,
        wData: obj.lib.getParam('wData'),
        wCacheLineOffset: obj.lib.getParam('wCacheLineOffset'),
        ntvCsrInterface: ntvCsrInterface,
        enableReadDataInterleaving : enableReadDataInterleaving,
        enOutputBuffer: nativeInterfacePipe,
        nExclusiveEntries : obj.lib.getParam("nExclusiveEntries")
    },
    verilogParams: {},
    ports: {
        write_trans_addr : "write_trans_addr_t",
        read_trans_addr :  "read_trans_addr_t",
    },
    interfaces: DMI_NATIVE_INTERFACE_INTF,
    portsDelimiter: '\n        '
})=\

\jsbegin
//////////////////////////////////////////
//End DMI native interface fifos
/////////////////////////////////////////

}


//========================================================
// Cmd skid buffer fifo Memory instantiation
//========================================================
if (CMDOverflowBufInSRAM) {


    var CMDReq_sb_mem_ports = {
        clk:                    clkInterfaceName+'clk',
        int_chip_en_read:       'CmdReq_sb_mem_read_en',
        int_chip_en_write:      'CmdReq_sb_mem_write_en',
        int_address_read:       'CmdReq_sb_mem_read_addr',
        int_address_write:      'CmdReq_sb_mem_write_addr',
        int_data_in:            'CmdReq_sb_mem_write_data',
        int_data_out:           'CmdReq_sb_mem_read_data'
    };

var CMDReq_sbMemEccBlocks = [[]];
for (var i=0;i<CMDReq_sb_mem_data_width;i++){
    CMDReq_sbMemEccBlocks[0][i]=i;
}
var CMDReq_sb_em_mem_external_interfaces = {};

var CMDReq_SbMemInterfaces = [];
//guaranteed by MRDOverflowBufInSRAM
/* istanbul ignore if ncore_3p7 */
if (CMDReq_sb_mem_gen != undefined) {

var CMDReq_SbMemIndexi = memInterfaceDict[ CMDReq_sb_mem_gen.rtlPrefixString + '_' ];
//guaranteed by MRDOverflowBufInSRAM
/* istanbul ignore else ncore_3p7 */
if (CMDReq_sb_mem_gen.MemType !== 'NONE') {
/* istanbul ignore else env ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */
if (interfaces.memoryInt.length > 0) {
    CMDReq_sb_em_mem_external_interfaces.externalInterface = utilFunctions.deepCopy(interfaces.memoryInt[ CMDReq_SbMemIndexi ]);
    CMDReq_sb_em_mem_external_interfaces.externalInterface.name = ' ';
}
}

CMDReq_SbMemInterfaces.push({
modulePrefix: '',
localPrefix: memInterfaceName[ CMDReq_SbMemIndexi ],
interface: memInterfaceBundle[ CMDReq_SbMemIndexi ],
direction: memInterfaceDirection[ CMDReq_SbMemIndexi ]
});

}

\jsend




    \=obj.lib.instance({
        instanceName:CMDReq_sb_mem_gen.rtlPrefixString,
        moduleName:  CMDReq_sb_mem_gen.moduleName + '_em_mem_external',
        tachlName: 'em_mem_external',
        params: {
                useMemoryGating: 0, //useMemoryGating
                sverilog: assertOn,
                interfaces      : CMDReq_sb_em_mem_external_interfaces,
                memEccBlocks: CMDReq_sbMemEccBlocks,
                rtlPrefixString: CMDReq_sb_mem_gen.moduleName ,
                modulePrefix: 'dmi_cmd_sb',
                memoryType: CMDReq_sb_mem_gen.MemType ,
                nSignals: CMDReq_sb_mem_gen.Signals.length,
                signals:  CMDReq_sb_mem_gen.Signals,
                useHandshake: 0,
                no_mem_init: 0,
                ports: 'tp',
                bitEnable: 0,
                numberOfEnables: CMDReq_sb_mem_data_width,
                width: CMDReq_sb_mem_data_width,
                depth: bufferSize.CMDReqSkidfifo},
        verilogParams: {},
        ports: CMDReq_sb_mem_ports,
        interfaces: CMDReq_SbMemInterfaces,
        portsDelimiter: '\n\t'
    })=\

\js }

\jsbegin
//========================================================
// mrd skid buffer fifo Memory instantiation
//========================================================
if (MRDOverflowBufInSRAM) {


    var MRDReq_sb_mem_ports = {
        clk:                    clkInterfaceName+'clk',
        int_chip_en_read:       'MrdReq_sb_mem_read_en',
        int_chip_en_write:      'MrdReq_sb_mem_write_en',
        int_address_read:       'MrdReq_sb_mem_read_addr',
        int_address_write:      'MrdReq_sb_mem_write_addr',
        int_data_in:            'MrdReq_sb_mem_write_data',
        int_data_out:           'MrdReq_sb_mem_read_data'
    };

var MRDReq_sbMemEccBlocks = [[]];
for (var i=0;i<MRDReq_sb_mem_data_width;i++){
    MRDReq_sbMemEccBlocks[0][i]=i;
}
var MRDReq_sb_em_mem_external_interfaces = {};

var MRD_req_SbMemInterfaces = [];
//guaranteed by MRDOverflowBufInSRAM
/* istanbul ignore if ncore_3p7 */
if (MRDReq_sb_mem_gen != undefined) {

var MRDReq_SbMemIndexi = memInterfaceDict[ MRDReq_sb_mem_gen.rtlPrefixString + '_' ];
//guaranteed by MRDOverflowBufInSRAM
/* istanbul ignore if ncore_3p7 */
if (MRDReq_sb_mem_gen.MemType !== 'NONE') {
/* istanbul ignore else env ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */
if (interfaces.memoryInt.length > 0) {
    MRDReq_sb_em_mem_external_interfaces.externalInterface = utilFunctions.deepCopy(interfaces.memoryInt[ MRDReq_SbMemIndexi ]);
    MRDReq_sb_em_mem_external_interfaces.externalInterface.name = ' ';
}
}

MRD_req_SbMemInterfaces.push({
modulePrefix: '',
localPrefix: memInterfaceName[MRDReq_SbMemIndexi ],
interface: memInterfaceBundle[ MRDReq_SbMemIndexi ],
direction: memInterfaceDirection[ MRDReq_SbMemIndexi ]
});
}

\jsend




    \=obj.lib.instance({
        instanceName:MRDReq_sb_mem_gen.rtlPrefixString ,
        moduleName: MRDReq_sb_mem_gen.moduleName ,
        tachlName: 'em_mem_external',
        params: {
                useMemoryGating: 0, //useMemoryGating
                sverilog: assertOn,
                interfaces      :  MRDReq_sb_em_mem_external_interfaces,
                memEccBlocks: MRDReq_sbMemEccBlocks,
                rtlPrefixString: MRDReq_sb_mem_gen.moduleName ,
                modulePrefix: 'dmi_mrd_sb',
                memoryType: MRDReq_sb_mem_gen.MemType ,
                nSignals: MRDReq_sb_mem_gen.Signals.length ,
                signals: MRDReq_sb_mem_gen.Signals ,
                useHandshake: 0,
                no_mem_init: 0,
                ports: 'tp',
                bitEnable: 0,
                numberOfEnables: MRDReq_sb_mem_data_width,
                width: MRDReq_sb_mem_data_width,
                depth: bufferSize.MRDReqSkidfifo},
        verilogParams: {},
        ports: MRDReq_sb_mem_ports,
        interfaces: MRD_req_SbMemInterfaces,
        portsDelimiter: '\n\t'
    })=\

\js }

\jsbegin
//========================================================
// Read Data Buffer Memory instantiation
//========================================================
if (useExRdDataMem) {
    var instance_ports_for_ram = [];
    for (var i = 0; i < nRdDataBanks; i++) {
        var rtlPrefixString = rdBufferGen[0].rtlPrefixString + i;
        var memoryControlInterface = rdDataStructures[i].controlSignals;
        instance_ports_for_ram[i] = {clk : clkInterfaceName+'clk'};
        for (var signal in memoryControlInterface) {
            instance_ports_for_ram[i][signal]  = 'mem__' + rtlPrefixString + '_' + signal;
        }
    // Forced to 1 in CPR 
    /* istanbul ignore if env ncore_3p7 */    
	if (useMemoryGating) {
		instance_ports_for_ram[i]['cg_test_en'] = clkInterfaceName+'test_en';
	}
        var rdBufferMemIndex = memInterfaceDict[ rdBufferGen[0].rtlPrefixString + '_' ];
        var rdBufferMemIndexi = memInterfaceDict[ rdBufferGen[i].rtlPrefixString + '_' ];
        var em_mem_external_interfaces = {};
         /* istanbul ignore else env ncore_3p0, ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */
        if (rdBufferGen[i].MemType !== 'NONE') {
           /* istanbul ignore else env ncore_3p2, ncore_3p4 , ncore_3p6, ncore_3p7*/
           if (interfaces.memoryInt.length > 0) {
             em_mem_external_interfaces.externalInterface = utilFunctions.deepCopy( interfaces.memoryInt[ rdBufferMemIndexi ] );
             em_mem_external_interfaces.externalInterface.name = ' ';
           }
        }

        var rdBufferMemInterfaces = [];

        rdBufferMemInterfaces.push({
            modulePrefix: '', 
            localPrefix: memInterfaceName[ rdBufferMemIndexi ],
            interface: memInterfaceBundle[ rdBufferMemIndexi ],
            direction: memInterfaceDirection[ rdBufferMemIndexi ]
        });

\jsend
        \=obj.lib.instance({
            instanceName: rdBufferGen[i].rtlPrefixString,
            moduleName: rdBufferGen[i].moduleName + '_em_mem_external',
            tachlName: 'em_mem_external',
            params: {
                useMemoryGating : useMemoryGating,
                sverilog        : assertOn,
                interfaces      : em_mem_external_interfaces,
                memEccBlocks    : rdBufferParam.eccBlocks,
                rtlPrefixString : rdBufferGen[i].moduleName, 
                modulePrefix    : 'dmi',
                memoryType      : rdDataStructures[i].memoryType,
                nSignals        : rdDataStructures[i].signals.length,
                signals         : rdDataStructures[i].signals,
                useHandshake    : 0,
                no_mem_init     : 0,
                ports           : rdBufferPorts,
                bitEnable       : 0,
                numberOfEnables : rdDataStructures[i].width,
                width           : rdDataStructures[i].width,
                depth           : rdDataStructures[i].depth
            },
            verilogParams: {},
            ports: instance_ports_for_ram[i],
            interfaces: rdBufferMemInterfaces,
            portsDelimiter: '\n'
        })=\
    \jsbegin
    } 

    var str = '';
    for (var i = 0; i < nRdDataBanks; i++) {
        var rtlPrefixString = rdBufferGen[0].rtlPrefixString + i;
        var memoryControlInterface = rdDataStructures[i].controlSignals;
        str += memFunctions.string_addConnectionfromInterface('' + rtlPrefixString + '_','mem__' + rtlPrefixString + '_',memoryControlInterface);
    }
\jsend
\=str=\

\jsbegin
} //end if(useExRdDataMem)
\jsend

\jsbegin
//========================================================
// Coherent Write Data Memory instaniation
//========================================================
\jsend
\jsbegin
if (useExWrDataMem) {
        var instance_ports_for_ram = [];
        for (var i = 0; i < nWrDataBanks; i++) {
            var rtlPrefixString = cWrDataGen[0].rtlPrefixString + i;
            var memoryControlInterface = wrDataStructures[i].controlSignals;
            instance_ports_for_ram[i] = {clk : clkInterfaceName+'clk'};
            for (var signal in memoryControlInterface) {
                instance_ports_for_ram[i][signal]  = 'mem__' + rtlPrefixString + '_' + signal;
            }
        // Forced to 1 in CPR 
        /* istanbul ignore if env ncore_3p7 */    
	    if (useMemoryGating) {
		instance_ports_for_ram[i]['cg_test_en'] = clkInterfaceName+'test_en';
	    }

    var cWrMemIndex = memInterfaceDict[ cWrDataGen[0].rtlPrefixString + '_' ];
    var cWrMemIndexi = memInterfaceDict[ cWrDataGen[i].rtlPrefixString + '_' ];
    var em_mem_external_interfaces = {};
     /* istanbul ignore else env ncore_3p0, ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */
    if (cWrDataGen[i].MemType !== 'NONE') {
         /* istanbul ignore else env ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */
        if (interfaces.memoryInt.length > 0) {
    em_mem_external_interfaces.externalInterface = utilFunctions.deepCopy( interfaces.memoryInt[ cWrMemIndexi ] );
    em_mem_external_interfaces.externalInterface.name = ' ';
        }
    }

    var cWrMemInterfaces = [];

    cWrMemInterfaces.push({
        modulePrefix: '', //cWrDataGen[0].rtlPrefixString + '_', //memInterfaceName[ cWrMemIndex ],
        localPrefix: memInterfaceName[ cWrMemIndexi ],
        interface: memInterfaceBundle[ cWrMemIndexi ],
        direction: memInterfaceDirection[ cWrMemIndexi ]
    });

\jsend
        \=obj.lib.instance({
                    instanceName: cWrDataGen[i].rtlPrefixString,
                    moduleName: cWrDataGen[i].moduleName + '_em_mem_external',
                    tachlName: 'em_mem_external',
                    params: {
                        useMemoryGating : useMemoryGating,
                        sverilog        : assertOn,
                        interfaces      : em_mem_external_interfaces,
                        memEccBlocks    : cWrDataParam.eccBlocks,
                        rtlPrefixString : cWrDataGen[i].moduleName, //cWrDataGen[0].rtlPrefixString,
                        modulePrefix    : 'dmi',
                        memoryType      : wrDataStructures[i].memoryType,
                        nSignals        : wrDataStructures[i].signals.length,
                        signals         : wrDataStructures[i].signals,
                        useHandshake    : 0,
                        no_mem_init     : 0,
                        ports           : cWrMemPorts,
                        bitEnable       : 0,
                        numberOfEnables : wrDataStructures[i].width,
                        width           : wrDataStructures[i].width,
                        depth           : wrDataStructures[i].depth
                    },
                    verilogParams: {},
                    ports: instance_ports_for_ram[i],
                    interfaces: cWrMemInterfaces,
                    portsDelimiter: '\n'
        })=\
\jsbegin
        }

        var str = '';
        for (var i = 0; i < nWrDataBanks; i++) {
            var rtlPrefixString = cWrDataGen[0].rtlPrefixString + i;
            var memoryControlInterface = wrDataStructures[i].controlSignals;
            str += memFunctions.string_addConnectionfromInterface(''      + rtlPrefixString + '_',
                                                                  'mem__' + rtlPrefixString + '_',
                                                                   memoryControlInterface);
        }
\jsend
\=str=\

\js } 

\jsbegin
//========================================================
// CCP Tag RAMs instaniation
//========================================================
\jsend

\jsbegin
    if(useCmc) {
        var instance_ports_for_ram = [];
        for (var i = 0; i < ccpParams.nTagBanks; i++) {
            var rtlPrefixString = ccpTagGen[i].rtlPrefixString + i; //BOON
            var memoryControlInterface = tagStructures[i].controlSignals;
            instance_ports_for_ram[i] = {clk : clkInterfaceName+'clk'};
            for (var signal in memoryControlInterface) {
                instance_ports_for_ram[i][signal]  = 'mem__' + rtlPrefixString + '_' + signal;
            }
        // Forced to 0 in CPR 
        /* istanbul ignore if ncore_3p7*/    
	    if (useMemoryGating) {
		instance_ports_for_ram[i]['cg_test_en'] = clkInterfaceName+'test_en';
	    }
            if (tagStructures[i].memoryType === "SYNOPSYS") {
                /* istanbul ignore if env ncore_3p0, ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */
                if (Object.keys(tagStructures[i].signals).length > 0) {
                    for (var signal in tagStructures[i].signals) {
                        if(signal!='int_chip_en') {
                            instance_ports_for_ram[i][tagStructures[i].rtlPrefixString + '_' + signal] = tagStructures[i].rtlPrefixString + i + '_' + signal;
                        }
                    }
                }    
            }

    var ccpTagMemIndex = memInterfaceDict[ ccpTagGen[0].rtlPrefixString + '_' ];
    var ccpTagMemIndexi = memInterfaceDict[ ccpTagGen[i].rtlPrefixString + '_' ];
    var em_mem_external_interfaces = {};
    if (ccpTagGen[i].MemType !== 'NONE') {
      /* istanbul ignore else env ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */
        if (interfaces.memoryInt.length > 0) {
    em_mem_external_interfaces.externalInterface = utilFunctions.deepCopy(interfaces.memoryInt[ ccpTagMemIndexi ]);
    em_mem_external_interfaces.externalInterface.name = ' ';
        }
    }

    var ccpTagMemInterfaces = [];

    ccpTagMemInterfaces.push({
        modulePrefix: '', //memInterfaceName[ ccpTagMemIndex ],
        localPrefix: memInterfaceName[ ccpTagMemIndexi ],
        interface: memInterfaceBundle[ ccpTagMemIndexi ],
        direction: memInterfaceDirection[ ccpTagMemIndexi ]
    });

\jsend
        \=obj.lib.instance({
                    instanceName: ccpTagGen[i].rtlPrefixString, //tagMemRtlPrefix + i,
                    moduleName: ccpTagGen[i].moduleName + '_em_mem_external', //tagMemRtlPrefix + '_em_mem_external',
                    tachlName: 'em_mem_external',
                    params: {
                        useMemoryGating : useMemoryGating,
                        sverilog : assertOn,
                        interfaces      : em_mem_external_interfaces,
                        memEccBlocks : tagP.eccBlocks,
                        rtlPrefixString: ccpTagGen[i].moduleName, //ccpTagGen[0].rtlPrefixString, //tagMemRtlPrefix,
                        modulePrefix: 'dmi',
                        memoryType: tagStructures[i].memoryType,
                        nSignals: tagStructures[i].signals.length,
                        signals: tagStructures[i].signals,
                        useHandshake: 0,
                        no_mem_init: 0,
                        ports: 'sp',
                        bitEnable: 1,
                        numberOfEnables: tagStructures[i].width,
                        width: tagStructures[i].width,
                        depth: tagStructures[i].depth
                    },
                    verilogParams: {},
                    ports: instance_ports_for_ram[i],
                    interfaces: ccpTagMemInterfaces,
                    portsDelimiter: '\n'
        })=\
\jsbegin
        }
    }
\jsend

\jsbegin
//========================================================
// CCP Rp RAMs instaniation
//========================================================
\jsend

\jsbegin
    if (useCmc) {
        /* istanbul ignore if env ncore_3p0, ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */
        if (nrumem) {
            var instance_ports_for_ram = [];
            for (var i = 0; i < ccpParams.nTagBanks; i++) {
                var rtlPrefixString = rpStructures[i].rtlPrefixString + i;
                var memoryControlInterface = rpStructures[i].controlSignals;
                instance_ports_for_ram[i] = {clk : clkInterfaceName+'clk'};
                for (var signal in memoryControlInterface) {
                    instance_ports_for_ram[i][signal]  = 'mem__' + rtlPrefixString + '_' + signal;
                }
            // Forced to 0 in CPR 
            /* istanbul ignore if env ncore_3p7 */    
	        if (useMemoryGating) {
		        instance_ports_for_ram[i]['cg_test_en'] = clkInterfaceName+'test_en';
	        }
                if (rpStructures[i].memoryType === "SYNOPSYS") {
                    if (Object.keys(rpStructures[i].signals).length > 0) {
                        for (var signal in rpStructures[i].signals) {
                            if(signal!='int_chip_en') {
                                instance_ports_for_ram[i][rpStructures[i].rtlPrefixString + '_' + signal] = rpStructures[i].rtlPrefixString + i + '_' + signal;
                            }
                        }
                    }
                }
\jsend
                \=obj.lib.instance({
                            instanceName: rpMemRtlPrefix + i,
                            moduleName: rpMemRtlPrefix + '_em_mem_external',
                            tachlName: 'em_mem_external',
                            params: {
                                useMemoryGating : 0,
                                sverilog : assertOn,
                                rtlPrefixString: rpMemRtlPrefix,
                                modulePrefix: 'dmi',
                                memoryType: rpStructures[i].memoryType,
                                nSignals: rpStructures[i].signals.length,
                                signals: rpStructures[i].signals,
                                useHandshake: 0,
                                no_mem_init: 0,
                                ports: 'tp',
                                bitEnable: 1,
                                numberOfEnables: ccpParams.nWays, // rpStructures[i].width,
                                width: rpStructures[i].width,
                                depth: rpStructures[i].depth
                            },
                            verilogParams: {},
                            ports: instance_ports_for_ram[i],
                            portsDelimiter: '\n'
                })=\
\js         }
\js // Wire external RAMS to CCP ports
\jsbegin
            var str = '';
            for (var i = 0; i < ccpParams.nTagBanks; i++) {
                var rtlPrefixString = rpStructures[i].rtlPrefixString + i;
                var memoryControlInterface = rpStructures[i].controlSignals;
                str += memFunctions.string_addConnectionfromInterface(''      + rtlPrefixString + '_',
                                                                      'mem__' + rtlPrefixString + '_',
                                                                      memoryControlInterface);
            }
\jsend 
            \=str=\
\js    } // nrumem
\js } //useCmc

\jsbegin
//========================================================
// CCP Data RAMs instaniation
//========================================================
\jsend

\jsbegin
    if(useCmc) {
        var instance_ports_for_ram = [];
        var clk_for_data_ram = (ccpParams.nBeatsPerBank > 1) ? "clkby2" : clkInterfaceName+ "clk";
        for (var i = 0; i < ccpParams.nDataBanks; i++) {
            var rtlPrefixString = ccpDataGen[i].rtlPrefixString + i; //BOON
            var memoryControlInterface = dataStructures[i].controlSignals;
            instance_ports_for_ram[i] = {clk : clk_for_data_ram };
            for (var signal in memoryControlInterface) {
                instance_ports_for_ram[i][signal]  = 'mem__' + rtlPrefixString + '_' + signal;
            }
        // Forced to 1 in CPR 
        /* istanbul ignore else env ncore_3p4, ncore_3p6, ncore_3p7 */    
	    if (ccpParams.nBeatsPerBank == 1 & useMemoryGating) {
		    instance_ports_for_ram[i]['cg_test_en'] = clkInterfaceName+'test_en';
	    }
            if (dataStructures[i].memoryType === "SYNOPSYS") {
                /* istanbul ignore if env ncore_3p0, ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */
                if (Object.keys(dataStructures[i].signals).length > 0) {
                    for (var signal in dataStructures[i].signals) {
                        if(signal!='int_chip_en') {
                            instance_ports_for_ram[i][dataStructures[i].rtlPrefixString + '_' + signal] = dataStructures[i].rtlPrefixString + i + '_' + signal;
                        }
                    }
                }
            }
    var ccpDataMemIndex = memInterfaceDict[ ccpDataGen[0].rtlPrefixString + '_' ];
    var ccpDataMemIndexi = memInterfaceDict[ ccpDataGen[i].rtlPrefixString + '_' ];
    var em_mem_external_interfaces = {};
    if (ccpDataGen[i].MemType !== 'NONE') {
         /* istanbul ignore else env ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */
        if (interfaces.memoryInt.length > 0) {
    em_mem_external_interfaces.externalInterface = utilFunctions.deepCopy(interfaces.memoryInt[ ccpDataMemIndexi ]);
    em_mem_external_interfaces.externalInterface.name = ' ';
        }
    }

    var ccpDataMemInterfaces = [];

    ccpDataMemInterfaces.push({
        modulePrefix: '', //memInterfaceName[ ccpDataMemIndex ],
        localPrefix: memInterfaceName[ ccpDataMemIndexi ],
        interface: memInterfaceBundle[ ccpDataMemIndexi ],
        direction: memInterfaceDirection[ ccpDataMemIndexi ]
    });
\jsend
            \=obj.lib.instance({
                        instanceName: ccpDataGen[i].rtlPrefixString, //dataMemRtlPrefix + i,
                        moduleName: ccpDataGen[i].moduleName + '_em_mem_external', //dataMemRtlPrefix + '_em_mem_external',
                        tachlName: 'em_mem_external',
                        params: {
                            useMemoryGating : (ccpParams.nBeatsPerBank == 1) & useMemoryGating,
                            nSramAccess : nSramAccess,
                            sverilog : assertOn,
                            interfaces      : em_mem_external_interfaces,
                            memEccBlocks : dataP.eccBlocks,
                            rtlPrefixString: ccpDataGen[i].moduleName, //ccpDataGen[0].rtlPrefixString, //dataMemRtlPrefix,
                            modulePrefix: 'dmi',
                            memoryType: dataStructures[i].memoryType,
                            nSignals: dataStructures[i].signals.length,
                            signals: dataStructures[i].signals,
                            useHandshake: 0,
                            no_mem_init: 0,
                            ports: 'sp',
                            bitEnable: 0,
                            width: dataStructures[i].width,
                            depth: dataStructures[i].depth,
                            useMemWrapperDoutFlop: 0
                        },
                        verilogParams: {},
                        ports: instance_ports_for_ram[i],
                        interfaces: ccpDataMemInterfaces,
                        portsDelimiter: '\n'
            })=\
\jsbegin
        }
    }
\jsend

\js // Wire external RAMS to CCP ports, just changing wire name
\jsbegin
    if(useCmc) {
        var str = '';
        for (var i = 0; i < ccpParams.nDataBanks; i++) {
            var rtlPrefixString = ccpDataGen[i].rtlPrefixString + i;
            var memoryControlInterface = dataStructures[i].controlSignals;
            str += memFunctions.string_addConnectionfromInterface(''      + rtlPrefixString + '_',
                                                                  'mem__' + rtlPrefixString + '_',
                                                                   memoryControlInterface);
        }
\jsend
\=str=\
\js }
\jsbegin
    if(useCmc) {
        var str = '';
        for (var i = 0; i < ccpParams.nTagBanks; i++) {
            var rtlPrefixString = ccpTagGen[i].rtlPrefixString + i;
            var memoryControlInterface = tagStructures[i].controlSignals;
            str += memFunctions.string_addConnectionfromInterface(''      + rtlPrefixString + '_',
                                                                  'mem__' + rtlPrefixString + '_',
                                                                   memoryControlInterface);
        }
\jsend
\=str=\
\js } // useCmc

\jsbegin
//========================================================
// CCP PLRU RAMs instaniation
//========================================================
\jsend

\jsbegin
if (useCmc) {

 if (usePLRU) {

  for (let f=0; f < ccpParams.nTagBanks; f++) {
            var plru_mem_ports = {
                clk:            interfaces.clkInt.name+'clk',
                int_chip_en_read:       'w_f'+f+'_plru_mem_read_en',
                int_chip_en_write:      'w_f'+f+'_plru_mem_write_en',
                int_address_read:       'w_f'+f+'_plru_mem_read_addr',
                int_address_write:      'w_f'+f+'_plru_mem_write_addr',
                int_data_in:    'w_f'+f+'_plru_mem_write_data',
                int_data_out:   'w_f'+f+'_plru_mem_read_data'
                };
                /* istanbul ignore if env ncore_3p7 */
                if (0) {
                        plru_mem_ports['cg_test_en'] = interfaces.clkInt.name+'test_en';
                }

    var plruMemEccBlocks = [[]];
    for (var i=0;i<ccpParams.nWays;i++){
        plruMemEccBlocks[0][i]=i;
    }


    var plru_em_mem_external_interfaces = {};

    var PlruMemInterfaces = [];
    //memory can't be undefined for plru
    /* istanbul ignore if env ncore_3p7 */
   if (MemoryGeneration.rpMem != undefined) {

    var PlruMemIndexi = memInterfaceDict[ MemoryGeneration.rpMem[f].rtlPrefixString + '_' ];
    //memory can't be NONE for plru must be sram
    /* istanbul ignore if env  ncore_3p7 */
    if (MemoryGeneration.rpMem[f].MemType !== 'NONE') {

        if (interfaces.memoryInt.length > 0) {
    plru_em_mem_external_interfaces.externalInterface = utilFunctions.deepCopy(interfaces.memoryInt[ PlruMemIndexi ]);
    plru_em_mem_external_interfaces.externalInterface.name = ' ';
        }
    }

    PlruMemInterfaces.push({
        modulePrefix: '',
        localPrefix: memInterfaceName[ PlruMemIndexi ],
        interface: memInterfaceBundle[ PlruMemIndexi ],
        direction: memInterfaceDirection[ PlruMemIndexi ]
    });

   }

\jsend

    \=obj.lib.instance({
        instanceName: (MemoryGeneration.rpMem != undefined) ? MemoryGeneration.rpMem[f].rtlPrefixString : 'u_f'+f+'_plru_mem',
        moduleName: (MemoryGeneration.rpMem != undefined) ? MemoryGeneration.rpMem[f].moduleName + '_em_mem_external' : 'f'+f+'_plru_'+'_em_mem_external',
        tachlName: 'em_mem_external',
        params: {
                useMemoryGating: 0,
                sverilog: assertOn, //ASSERT_ON
                interfaces      : plru_em_mem_external_interfaces,
                memEccBlocks: plruMemEccBlocks,
                rtlPrefixString: (MemoryGeneration.rpMem != undefined) ? MemoryGeneration.rpMem[f].moduleName : 'f'+f+'plru_',
                modulePrefix: 'plru',
                memoryType: (MemoryGeneration.rpMem != undefined) ? MemoryGeneration.rpMem[f].MemType : 'SYNOPSYS',
                nSignals: (MemoryGeneration.rpMem != undefined) ? MemoryGeneration.rpMem[f].Signals.length : 0,
                signals: (MemoryGeneration.rpMem != undefined) ? MemoryGeneration.rpMem[f].Signals : [],
                useHandshake: 0,
                no_mem_init: 0,
                ports: 'tp',
                bitEnable: 0,
                numberOfEnables: ccpParams.nWays,
                width: ccpParams.nWays,
                depth: ccpParams.nSets / ccpParams.nTagBanks },
        verilogParams: {},
        ports: plru_mem_ports,
        interfaces: PlruMemInterfaces,
        portsDelimiter: '\n\t'
    })=\

\jsbegin
  }
 }
}
\jsend

\jsbegin
// =======================================================
// PMA REQn Synchronizers
// =======================================================
\jsend

\js if (usePma) {

\=obj.lib.instance({
   instanceName: 'u_pma_REQn_sync',
   moduleName:   'dffr_sync',
   params: {
       'width' : 1,
       'depth' : syncDepth,
   },
   ports: {
       clk      : clkInterfaceName+'clk',
       reset_n  : clkInterfaceName+'reset_n',
       in_data  : qInterfaceName+'REQn',
       out_data : qInterfaceName+'REQn_sync'
    }
})=\

\js }

\jsbegin
// =======================================================
// Master Trigger Synchronizer
// =======================================================
// trigger intf always present on 3.4 
/* istanbul ignore else env ncore_3p4, ncore_3p6, ncore_3p7*/
if( interfaces.masterTriggerInt && !interfaces.masterTriggerInt._SKIP_ ) { \jsend

 \=obj.lib.instance({
    'portsDelimiter': '\n  ',
    'instanceName': 'u_sync_main_trig',
    'moduleName':   'dffr_sync',
    'params': {
      'width' : 1,
      'depth' : syncDepth}, 
    'ports': {
      'clk'      : clkInterfaceName+'clk',
      'reset_n'  : clkInterfaceName+'reset_n',
      'in_data'  : masterTriggerInterface.name+'trigger',
      'out_data' : masterTriggerInterface.name+'trigger_sync'}})=\
\jsbegin
} \jsend

endmodule
