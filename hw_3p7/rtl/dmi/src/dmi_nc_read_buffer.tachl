//=============================================================================
// Copyright(C) 2018 Arteris, Inc.
// All rights reserved
//=============================================================================
\jsbegin
// DMI NC Read Buffer
// Author: Tso-Wei Chang
//=============================================================================

//=============================================================================
// Variables
//=============================================================================
var u = obj.lib;
var m = obj.userLib;

var bundleFunctions     = m.bundleFunctions;
var depth               = u.getParam('depth');
var wAddrCAM            = u.getParam('wAddrCAM');
var wCacheLineOffset    = u.getParam('wCacheLineOffset');
var CMDReqInterface     = u.getParam('CMDReqInterface');
var readProtInterface   = u.getParam('readProtInterface');
var clkInterface        = u.getParam('clkInterface');
var wrQDepth            = u.getParam('wrQDepth');
var wAddr               = CMDReqInterface.addr;
var wCmType             = CMDReqInterface.cm_type;
var cmType              = u.getParam('cmType');
var useRoundRobin = 1;
var wReqPkt             = bundleFunctions.getBundleWidth(CMDReqInterface, ['valid', 'ready', 'addr'], u.bundle);

//=============================================================================
// Ports & Interfaces
//=============================================================================
u.interface('',                 'slave',                   clkInterface);
u.interface('cmd_req_',         'slave',                CMDReqInterface);
u.interface('read_prot_',       'master',             readProtInterface);
u.port('input',  'cam_addr',                                      wAddr);
u.port('input',  'cam_ns',					      1);
u.port('output', 'cam_match_vec',                                 depth);
u.port('output', 'cam_match_vec_pmon',                            depth);
u.port('input',  'wr_dealloc_idx',                             wrQDepth);
u.port('input',  'wr_dealloc_en',                                     1);

u.port('input',  'wr_cam_match_vec',                           wrQDepth);
u.port('output', 'rd_dealloc_idx',                                depth);
u.port('output', 'rd_dealloc_en',                                     1);
u.port('output', 'active',                                            1);
\jsend
module \=u.getModuleName()=\ (\=u.getPorts('\n')=\);
\jsbegin
//=============================================================================
// Functions & Local params
//=============================================================================
\jsend
localparam RD_ATM   = \=cmType['CmdRdAtm']=\;
localparam WR_ATM   = \=cmType['CmdWrAtm']=\;
localparam CM_ATM   = \=cmType['CmdCompAtm']=\;
localparam SW_ATM   = \=cmType['CmdSwapAtm']=\;

localparam WM_INV   = \=cmType['DtwMrgMrdInv']=\;
localparam WM_RSCLN = \=cmType['DtwMrgMrdSCln']=\;
localparam WM_RSDTY = \=cmType['DtwMrgMrdSDty']=\;
localparam WM_RUCLN = \=cmType['DtwMrgMrdUCln']=\;
localparam WM_RUDTY = \=cmType['DtwMrgMrdUDty']=\;
\jsbegin
//=============================================================================
// Wires
//=============================================================================
\jsend
\=bundleFunctions.wiresFromInterface('cmd_req_rd_', CMDReqInterface, ['valid', 'ready'],  u.bundle)=\
wire [\=wReqPkt-1=\:0]                      req_entry_rd;
wire [\=wReqPkt-1=\:0]                      req_entry_in;

\js for (var i = 0; i < depth; i++) {
wire                                        req_entry_en\=i=\;
wire [\=wReqPkt-1=\:0]                      req_entry\=i=\;
wire [\=wAddr-1=\:0]                        req_entry_addr\=i=\;
wire 					    req_entry_ns\=i=\;
wire [\=wrQDepth-1=\:0]                     dep_vec\=i=\;
wire [\=wrQDepth-1=\:0]                     d_dep_vec\=i=\;
\js }
wire [\=depth-1=\:0]                        read_prot_valid_qual;
wire [\=depth-1=\:0]                        alloc_idx;
wire [\=depth-1=\:0]                        req_entry_valid_d;
wire [\=depth-1=\:0]                        req_entry_valid;
wire                                        req_entry_valid_en;
wire [\=depth-1=\:0]                        dep_vec_en;
wire [\=wAddrCAM-wCacheLineOffset-1=\:0]    rd_order_link_alloc_id;
wire                                        alloc_en;
wire                                        dealloc_en;
wire [\=depth-1=\:0]                        req_entry_n_valid;
wire [\=depth-1=\:0]                        no_dep;
wire                                        empty;
wire                                        full;
wire                                        bypass;
wire [\=depth-1=\:0]                        dealloc_idx;
wire [\=depth-1=\:0]                        rd_valid_head_vec;
wire [\=wAddr-1=\:0]                        req_entry_addr_rd;
\jsbegin
//=============================================================================
// Entry Allocation
//=============================================================================
\jsend
assign alloc_en             = cmd_req_valid & cmd_req_ready & ~(bypass & read_prot_ready);
assign cmd_req_ready        = ~full;
assign req_entry_n_valid    = ~req_entry_valid;
assign empty                = &req_entry_n_valid;
assign full                 = &req_entry_valid;
assign req_entry_valid_en   = alloc_en | dealloc_en;
assign req_entry_valid_d    = (alloc_idx & {\=depth=\{alloc_en}}) 
                             |(req_entry_valid & ~(dealloc_idx & {\=depth=\{dealloc_en}})); 

assign active               = ~empty;
\=u.dffre(depth,  'req_entry_valid',    'req_entry_valid_d',  depth+"'d0",  'req_entry_valid_en', 'clk', 'reset_n')=\


\=obj.lib.instance({
  'portsDelimiter': '\n    ',
  'instanceName': 'alloc_find_first',
  'moduleName':   'arb_spri',
  'params': {
       width : depth
     },
  'verilogParams': {},
  'ports': {
      in_req    : 'req_entry_n_valid',
      out_gnt   : 'alloc_idx',
  }
})=\

\js for (var i = 0; i < depth; i++) {
\=u.dffre(wReqPkt,      'req_entry'+i,          'req_entry_in',     wReqPkt+"'d0",      'req_entry_en'+i,   'clk',  'reset_n')=\
\=u.dffre(wAddr,        'req_entry_addr'+i,     'cmd_req_addr',     wAddr+"'d0",        'req_entry_en'+i,   'clk',  'reset_n')=\
\=u.dffre(1,        'req_entry_ns'+i,     'cmd_req_ns',     "1'd0",        'req_entry_en'+i,   'clk',  'reset_n')=\

assign req_entry_en\=i=\ = alloc_idx[\=i=\] & alloc_en;
\js }

assign req_entry_in = \=bundleFunctions.packetizeBundle('cmd_req_', CMDReqInterface, ['valid', 'ready', 'addr'], u.bundle)=\;
\jsbegin
//=============================================================================
// Entry Arbitration & Deallocation
//=============================================================================
// Always use roundrobin for 3.4
/* istanbul ignore else env ncore_3p4,ncore_3p6, ncore_3p7 */
if ( useRoundRobin ) { 
    \jsend
    wire [\=depth-1=\:0] park_point;
    wire [\=depth-1=\:0] park_point_therm;
    wire [\=depth-1=\:0] park_point_d;
    wire                         park_point_en;
    
    wire [\=depth-1=\:0] d_rob_sel_idx;
    
    \=obj.lib.instance({
        instanceName: 'req_rr_arb',
        moduleName: 'dmi_arb_comb_therm',
        params: { 
                    num_inputs : depth 
                },
        ports: {
                    req        : 'read_prot_valid_qual',
                    park_point : 'park_point',
                    grant      : 'dealloc_idx'
               },
        portsDelimiter: '\n    '
    })=\
    
    \=obj.lib.instance({
            instanceName: 'u_park_point_therm',
            moduleName: 'thermo_fast',
            params: {
                width   : depth
            },
            verilogParams: {
            },
            ports: {
                invec       : 'park_point_d',
                outvec      : 'park_point_therm'
            }
    })=\
    
    \=u.dffre(depth, 'park_point',  'park_point_therm',  depth+"'d1", 'park_point_en', 'clk', 'reset_n')=\
    assign park_point_d = dealloc_idx;
    assign park_point_en = read_prot_valid & read_prot_ready;

\jsbegin

} else {

\jsend

\=obj.lib.instance({
  'portsDelimiter': '\n    ',
  'instanceName': 'read_prot_find_first',
  'moduleName':   'arb_spri',
  'params': {
       width : depth
     },
  'verilogParams': {},
  'ports': {
      in_req    : 'read_prot_valid_qual',
      out_gnt   : 'dealloc_idx',
  }
})=\
\jsbegin
}
\jsend
\=obj.lib.instance({
    instanceName: 'rd_order_link',
    moduleName: 'dep_link',
    params: {
        width: wAddrCAM-wCacheLineOffset,
        depth: depth,
        clkInterface: clkInterface
    },
    verilogParams: {},
    ports: {
        alloc_en:       'alloc_en',
        alloc_id:       'rd_order_link_alloc_id',
        alloc_idx:      'alloc_idx',
        dealloc_en:     'dealloc_en',
        dealloc_idx:    'dealloc_idx',
        valid_head_vec: 'rd_valid_head_vec'
    },
    interfaces: [
        {modulePrefix: '',      localPrefix: '',                interface: clkInterface},
    ],
    portsDelimiter: '\n        '
})=\
assign rd_order_link_alloc_id = cmd_req_addr[\=wAddrCAM-1=\:\=wCacheLineOffset=\];
assign read_prot_valid_qual = req_entry_valid & no_dep & rd_valid_head_vec;

//=============================================================================
// Address Dependency
//=============================================================================
\js for (var i = 0; i < depth; i++) {
assign no_dep[\=i=\]        = ~|dep_vec\=i=\;
assign d_dep_vec\=i=\       = (dep_vec\=i=\ & ~wr_dealloc_idx & {\=wrQDepth=\{wr_dealloc_en}}) | 
                              ((wr_cam_match_vec & ~(wr_dealloc_idx & {\=wrQDepth=\{wr_dealloc_en}})) & {\=wrQDepth=\{alloc_en & alloc_idx[\=i=\]}});
assign dep_vec_en[\=i=\]    = (alloc_idx[\=i=\] & alloc_en) | wr_dealloc_en;
assign cam_match_vec[\=i=\] = req_entry_valid[\=i=\] & ((req_entry_addr\=i=\[\=wAddrCAM-1=\:\=wCacheLineOffset=\] ^ cam_addr[\=wAddrCAM-1=\:\=wCacheLineOffset=\]) == 0);

assign cam_match_vec_pmon[\=i=\] = req_entry_valid[\=i=\] & ((req_entry_addr\=i=\[\=wAddrCAM-1=\:\=wCacheLineOffset=\] ^ cam_addr[\=wAddrCAM-1=\:\=wCacheLineOffset=\]) == 0 & (req_entry_ns\=i=\ ^ cam_ns) == 0);


\=u.dffre(wrQDepth, 'dep_vec'+i,  'd_dep_vec'+i,  wrQDepth+"'b0", 'dep_vec_en['+i+']', 'clk', 'reset_n')=\

\js }

assign rd_dealloc_idx   = dealloc_idx;
assign dealloc_en       = read_prot_valid & read_prot_ready & ~bypass;
assign rd_dealloc_en    = dealloc_en;
\js // assign bypass           = empty & ~|wr_cam_match_vec;
\js // TODO: cut timing path. Need to review this to balance the pipeline.
assign bypass           = 1'b0;
assign req_entry_rd     = (req_entry0 & {\=wReqPkt=\{dealloc_idx[0]}})
\js for (var i = 1; i < depth; i++) {
                         |(req_entry\=i=\ & {\=wReqPkt=\{dealloc_idx[\=i=\]}})
\js }
                         ;

assign req_entry_addr_rd = (req_entry_addr0 & {\=wAddr=\{dealloc_idx[0]}})
\js for (var i = 1; i < depth; i++) {
                          |(req_entry_addr\=i=\ & {\=wAddr=\{dealloc_idx[\=i=\]}})
\js }
                          ;

assign \=bundleFunctions.packetizeBundle('cmd_req_rd_', CMDReqInterface, ['valid','ready','addr'], u.bundle)=\ = bypass?  req_entry_in : req_entry_rd;
assign cmd_req_rd_addr = bypass? cmd_req_addr : req_entry_addr_rd;

\=bundleFunctions.assignByBundle('read_prot_', 'cmd_req_rd_', readProtInterface,
        [
            'valid',
            'ready',
            'trans_id',
            'aiu_id',
            'aiu_trans_id',
            'user',
            'late_resp_id'
        ],
u.bundle)=\

assign read_prot_trans_id       = \=readProtInterface.trans_id=\'d0;
assign read_prot_late_resp_id   = \=readProtInterface.late_resp_id=\'d0;
assign read_prot_aiu_id         = cmd_req_rd_initiator_id;
assign read_prot_aiu_trans_id   = cmd_req_rd_message_id;
\jsbegin
/* istanbul ignore if env ncore_3p0 */    
    if (readProtInterface.user != 0) {
\jsend
assign read_prot_user           = cmd_req_rd_aux;
\js }
assign read_prot_valid          = bypass? cmd_req_valid : |read_prot_valid_qual;
// assign read_prot_pr             = cmd_req_rd_pr;
// assign read_prot_tm             = cmd_req_rd_tm;

endmodule
