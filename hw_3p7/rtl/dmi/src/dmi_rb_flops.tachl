\jsbegin
//=============================================================================
// Copyright(C) 2024 Arteris, Inc.
// All rights reserved
//=============================================================================
// DMI nc write buffer and c write buffer context flops that are moved to the top level for protection
//
// Filename: dmi_rb_flops.tachl
//=============================================================================

var u = obj.lib;
var m = obj.userLib;
var bundleFunctions = obj.userLib.bundleFunctions;

let ASSERT_ON    = m.ParamDefaultGet(u, 'assertOn', 'int', 0);

let N_RB                      = u.getParam('N_RB');
let rb_req_alloc_bundle_width = u.getParam('rb_req_alloc_bundle_width');

u.port('input',  'clk', 1);
u.port('input',  'reset_n', 1);
u.port('input',  'en_rb_buffer_vec',  N_RB);
u.port('input',  'd_rb_buffer_vec', N_RB * rb_req_alloc_bundle_width);
u.port('output', 'q_rb_buffer_vec', N_RB * rb_req_alloc_bundle_width);


\jsend

module \=u.getModuleName()=\ (\=u.getPorts()=\);

  \js for (var i=0; i < N_RB; i++) {
  
wire [\=rb_req_alloc_bundle_width-1=\:0] q_rb_buffer_vec\=i=\;
wire en_rb_buffer_vec\=i=\;
wire [\=rb_req_alloc_bundle_width-1=\ : 0] d_rb_buffer_vec\=i=\;

assign q_rb_buffer_vec[\=(rb_req_alloc_bundle_width*(i+1))-1=\ : \=rb_req_alloc_bundle_width*i=\] = q_rb_buffer_vec\=i=\ ;
assign d_rb_buffer_vec\=i=\ = d_rb_buffer_vec[\=(rb_req_alloc_bundle_width*(i+1))-1=\ : \=rb_req_alloc_bundle_width*i=\] ;


assign en_rb_buffer_vec\=i=\ = en_rb_buffer_vec[\=i=\];

\=u.dffre(rb_req_alloc_bundle_width, 'q_rb_buffer_vec'+i, 'd_rb_buffer_vec'+i, "{"+rb_req_alloc_bundle_width+"{1'b0}}", 'en_rb_buffer_vec'+i, 'clk', 'reset_n')=\

  \js }
  
endmodule
