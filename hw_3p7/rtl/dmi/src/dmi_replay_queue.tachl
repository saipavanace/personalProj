//=============================================================================
// Copyright (C) 2018 Arteris, Inc.
// All rights reserved.
//=============================================================================
\jsbegin
// Dmi Cache Pipe
// Author: Steve Kromer
// 
// Place for accesses that lookup in ccp but then have conflicts with
// TT downstream. Prevent head of line blocking by putting them here
// until the access that is blocking is completed, then replay through ccp.
// 
// TODO drop and replay at same time? what about hint, rd, flush
// TODO match against repq goes to replay
// TODO missq to repq
//=========================================================================

var u = obj.lib;
var bundleFunctions = obj.userLib.bundleFunctions;

var addrInterface   = u.getParam('addrInterface');
var wAddrInterface  = bundleFunctions.getBundleWidth(addrInterface, ['valid', 'ready'], u.bundle);
var UseTagRamInputFlop = u.getParam ("UseTagRamInputFlop");
var UseTagRamOutputFlop = u.getParam("UseTagRamOutputFlop");
var replayQSize = 8;
var wRepId = Math.ceil(Math.log2(replayQSize));

//=========================================================================
// ports
//=========================================================================
u.interface('', 'slave', u.getParam('clkInterface'));
u.interface('repq_cam_', 'slave', u.getParam('camAddrInterface'));

u.port('input',  'ccp_p0_replay',     1);
u.port('input',  'ccp_p1',            wAddrInterface);
u.port('input',  'ccp_p1_to_replay',  1);
u.port('input',  'ccp_p1_wait_rd',    1);
u.port('input',  'ccp_p1_wait_wr',    1);
u.port('input',  'rtt_dealloc_valid', 1);
u.port('input',  'wtt_dealloc_valid', 1);

u.port('output', 'repq_avail',        1);
u.port('output', 'repq_empty',        1);
u.port('output', 'replay_valid',      1);
u.port('output', 'replay_cmd',        wAddrInterface);
u.port('output', 'ccp_p2_to_replay',  1);
\jsend

module \=u.getModuleName()=\ (\=u.getPorts('\n')=\);

    //
    // Wires
    //
    wire [\=replayQSize-1=\:0]      repq_valid;
    wire [\=replayQSize-1=\:0]      repq_empty_vec;
    wire [\=replayQSize-1=\:0]      repq_valid_d;
    wire [\=replayQSize-1=\:0]      repq_valid_clr;
    wire [\=replayQSize-1=\:0]      repq_valid_set;
    wire                            ccp_p1_is_replay;
    wire [\=wRepId-1=\:0]           ccp_p1_replay_id;
    wire [\=replayQSize-1=\:0]      ccp_p1_replay_id_1hot;
    wire                            ccp_p1_replay_alloc;
    wire                            ccp_p1_replay_dealloc;
    wire [\=replayQSize-1=\:0]      repq_first_empty;
    wire [\=wRepId-1=\:0]           repq_first_id;
    wire [\=wAddrInterface-1=\:0]   repq[\=replayQSize-1=\:0];
    wire [\=replayQSize-1=\:0]      cam_match_vector;
    wire                            repq_new_match;
    wire [\=wRepId-1=\:0]           repq_wait_set_id;
    wire [\=wRepId-1=\:0]           ccp_p0_replay_id;
    wire                            replay_ccp_p0;
    wire [\=replayQSize-1=\:0]      repq_wait_hd;
    wire [\=replayQSize-1=\:0]      repq_wait_hd_d;
    wire [\=replayQSize-1=\:0]      repq_wait_hd_set;
    wire [\=replayQSize-1=\:0]      repq_wait_hd_clr;

    wire                            ccp_p0p_is_replay;
    wire [\=wRepId-1=\:0]           ccp_p0p_replay_id;
    wire [\=replayQSize-1=\:0]      ccp_p0p_replay_id_1hot;

    wire [\=replayQSize-1=\:0]      ccp_p1m_replay_id_1hot;
    wire                            ccp_p1m_is_replay;
    wire [\=wRepId-1=\:0]           ccp_p1m_replay_id;


\js for (var entry = 0; entry < replayQSize; entry++) {
    \=bundleFunctions.wiresFromInterface('repq'+entry, addrInterface, ['valid', 'ready'], u.bundle)=\

    wire [\=wAddrInterface-1=\:0] repq_\=entry=\;
    assign repq[\=entry=\] = repq_\=entry=\;
    \=u.dffre(wAddrInterface, 'repq_'+entry,  'ccp_p1',  wAddrInterface+"'b0", 'repq_valid_set['+entry+']', 'clk', 'reset_n')=\

    assign \=bundleFunctions.packetizeBundle('repq'+entry,  addrInterface, ['ready','valid'], obj.lib.bundle)=\ = repq[\=entry=\];
    assign cam_match_vector[\=entry=\] = repq_valid[\=entry=\] & (((repq\=entry=\addr ^ repq_cam_addr) & ~repq_cam_mask) == 0 & (repq\=entry=\ns ^ repq_cam_ns) == 0);
\js }

    // cam_match is used to send to replay queue, if this is already coming from replayq, then kill match
\=u.instance({
    portsDelimiter: '\n    ',
    instanceName: 'u_cam_match',
    moduleName:   'logic_tree',
    params: {
      'width' : replayQSize,
      'logic' : '|'},
    ports: {
      'din'  : 'cam_match_vector',
      'dout' : 'repq_new_match'}})=\
    assign repq_cam_match = repq_new_match & ~ccp_p1_is_replay;

    \=u.dffre(replayQSize, 'repq_valid', 'repq_valid_d', replayQSize+"'b0", '1\'b1', 'clk', 'reset_n')=\

    assign repq_valid_set  = ccp_p1_replay_alloc ? repq_first_empty : \=replayQSize=\'d0;
    assign repq_valid_d    = repq_valid_set | (repq_valid & ~repq_valid_clr);
    assign repq_valid_clr  = ccp_p1_replay_dealloc ? ccp_p1_replay_id_1hot : \=replayQSize=\'d0;

    // if not from replayq and sending to replayq then alloc new entry
    assign ccp_p1_replay_alloc   = ~ccp_p1_is_replay &  ccp_p1_to_replay;
    // if from replayq and not sending back to replayq, then dealloc entry
    assign ccp_p1_replay_dealloc =  ccp_p1_is_replay & ~ccp_p1_to_replay;

    assign repq_empty_vec = ~repq_valid;

    integer i, i0, i1, i2;

    \=obj.lib.instance({
      'portsDelimiter': '\n    ',
      'instanceName': 'repq_empty_find_first',
      'moduleName':   'arb_spri',
      'params': {
           width : replayQSize
         },
      'verilogParams': {},
      'ports': {
          in_req    : 'repq_empty_vec',
          out_gnt   : 'repq_first_empty',
      }
    })=\
    

    assign repq_first_id = \=wRepId=\'d0 & {\=wRepId=\{repq_first_empty[0]}}
\js for(var i = 1; i < replayQSize; i++) {
                           |(\=wRepId=\'d\=i=\ & {\=wRepId=\{repq_first_empty[\=i=\]}})
\js } 
    ;



    \=u.dffre(replayQSize, 'repq_wait_hd',  'repq_wait_hd_d',  replayQSize+"'b0", 'ccp_p1_replay_alloc', 'clk', 'reset_n')=\

    assign repq_wait_hd_d   = repq_wait_hd_set | (repq_wait_hd & ~repq_wait_hd_clr);
    assign repq_wait_hd_set = (ccp_p1_replay_alloc &  repq_new_match) ? repq_first_empty : \=replayQSize=\'d0;
    assign repq_wait_hd_clr = (ccp_p1_replay_alloc & ~repq_new_match) ? repq_first_empty : \=replayQSize=\'d0;

    wire [\=replayQSize-1=\:0] repq_wait_rd;
    wire [\=replayQSize-1=\:0] repq_wait_rd_d;
    wire [\=replayQSize-1=\:0] repq_wait_rd_set;
    wire [\=replayQSize-1=\:0] repq_wait_rd_clr;

    \=u.dffre(replayQSize, 'repq_wait_rd',  'repq_wait_rd_d',  replayQSize+"'b0", '1\'b1', 'clk', 'reset_n')=\

    assign repq_wait_rd_d   = (repq_wait_rd_set | repq_wait_rd) & ~repq_wait_rd_clr;
    assign repq_wait_rd_set = (ccp_p1_to_replay & ccp_p1_wait_rd) ? \=replayQSize=\'b1 << repq_wait_set_id : \=replayQSize=\'d0;
    assign repq_wait_rd_clr = repq_valid_clr | (rtt_dealloc_valid ? {\=replayQSize=\{1'b1}} : \=replayQSize=\'d0);

    wire [\=replayQSize-1=\:0] repq_wait_wr;
    wire [\=replayQSize-1=\:0] repq_wait_wr_d;
    wire [\=replayQSize-1=\:0] repq_wait_wr_set;
    wire [\=replayQSize-1=\:0] repq_wait_wr_clr;

    \=u.dffre(replayQSize, 'repq_wait_wr',  'repq_wait_wr_d',  replayQSize+"'b0", '1\'b1', 'clk', 'reset_n')=\

    assign repq_wait_wr_d   = (repq_wait_wr_set | repq_wait_wr) & ~repq_wait_wr_clr;
    assign repq_wait_wr_set = (ccp_p1_to_replay & ccp_p1_wait_wr) ? \=replayQSize=\'b1 << repq_wait_set_id : \=replayQSize=\'d0;
    assign repq_wait_wr_clr = repq_valid_clr | (wtt_dealloc_valid ? {\=replayQSize=\{1'b1}} : \=replayQSize=\'d0);

    assign repq_wait_set_id = ccp_p1_is_replay ? ccp_p1_replay_id : repq_first_id;

    \=u.dffre(wRepId,   'ccp_p1_replay_id',  'ccp_p1m_replay_id',  wRepId+"'b0", '1\'b1', 'clk', 'reset_n')=\
    \=u.dffre(1,        'ccp_p1_is_replay',  'ccp_p1m_is_replay',     "1'b0",       '1\'b1', 'clk', 'reset_n')=\
    \=u.dffre(1,        'ccp_p2_to_replay',  'ccp_p1_to_replay',  "1'b0",       '1\'b1', 'clk', 'reset_n')=\

    assign ccp_p1_replay_id_1hot = \=replayQSize=\'b1 << ccp_p1_replay_id;


\jsbegin
if (UseTagRamInputFlop){
\jsend

    assign ccp_p0p_replay_id_1hot = \=replayQSize=\'b1 << ccp_p0p_replay_id;
    \=u.dffre(wRepId,   'ccp_p0p_replay_id',  'ccp_p0_replay_id',  wRepId+"'b0", '1\'b1', 'clk', 'reset_n')=\
    \=u.dffre(1,        'ccp_p0p_is_replay',  'ccp_p0_replay',     "1'b0",       '1\'b1', 'clk', 'reset_n')=\


\jsbegin
}
else {
\jsend

    assign ccp_p0p_replay_id = ccp_p0_replay_id;
    assign ccp_p0p_is_replay = ccp_p0_replay;

\jsbegin
}
\jsend



\jsbegin
if (UseTagRamOutputFlop){
\jsend

    \=u.dffre(1,        'ccp_p1m_is_replay',  'ccp_p0p_is_replay',     "1'b0",       '1\'b1', 'clk', 'reset_n')=\
    \=u.dffre(wRepId,   'ccp_p1m_replay_id',  'ccp_p0p_replay_id',  wRepId+"'b0", '1\'b1', 'clk', 'reset_n')=\


\jsbegin
}
else {
\jsend

    assign ccp_p1m_replay_id = ccp_p0p_replay_id;
    assign ccp_p1m_is_replay = ccp_p0p_is_replay;

\jsbegin  
}
\jsend



    assign ccp_p1m_replay_id_1hot = \=replayQSize=\'b1 << ccp_p1m_replay_id;

    wire [\=replayQSize-1=\:0] repq_id_en;
    wire [\=replayQSize-1=\:0] repq_id_v;
    wire [\=replayQSize-1=\:0] repq_id_v_d;
    wire [\=replayQSize-1=\:0] repq_id_v_clr;
    reg  [\=replayQSize-1=\:0] repq_id_shift;

    wire [\=wRepId-1=\:0] repq_id[\=replayQSize-1=\:0];
    wire [\=wRepId-1=\:0] repq_id_d[\=replayQSize-1=\:0];

\js for (var entry = 0; entry < replayQSize; entry++) {
    wire [\=wRepId-1=\:0] repq_id_\=entry=\;
    assign repq_id[\=entry=\] = repq_id_\=entry=\;
    \=u.dffre(wRepId,    'repq_id_'+entry,  'repq_id_d['+entry+']',     wRepId+"'b0",   'repq_id_en['+entry+']', 'clk', 'reset_n')=\

\js if (entry == replayQSize-1) {
    assign repq_id_d[\=entry=\] = repq_first_id;
\js } else {
    assign repq_id_d[\=entry=\] = repq_id_shift[\=entry=\] ? repq_id[\=entry+1=\] : repq_first_id;
\js }
\js }

    \=u.dffre(replayQSize,    'repq_id_v',  'repq_id_v_d',    replayQSize+"'b0",   '1\'b1', 'clk', 'reset_n')=\

    assign repq_id_v_d = (ccp_p1_replay_alloc & ~ccp_p1_replay_dealloc) ? {repq_id_v[\=replayQSize-2=\:0], 1'b1} :
                         (~ccp_p1_replay_alloc & ccp_p1_replay_dealloc) ? {1'b0, repq_id_v[\=replayQSize-1=\:1]} :
                                                                          repq_id_v;
    assign repq_id_en  = (repq_id_v_d & ~repq_id_v) | repq_id_shift;

    reg [\=replayQSize-1=\:0] repq_id_in_p1;
    always @(*) begin
        for (i = 0; i < \=replayQSize=\; i = i + 1)
            repq_id_in_p1[i] = ccp_p1_is_replay & repq_id_v[i] & (repq_id[i] == ccp_p1_replay_id);
    end
    assign repq_id_v_clr = ccp_p1_replay_dealloc ? repq_id_in_p1 : \=replayQSize=\'d0;

    reg  [\=replayQSize-1=\:0] repq_id_v_clr_mask;
    wire [\=replayQSize-1=\:0] repq_id_v_clr_first;

    always @(*) begin
        for(i0 = 0; i0 < \=replayQSize=\; i0 = i0 + 1) begin
            if(i0 == 0)
                repq_id_v_clr_mask[i0] = repq_id_v_clr_first[i0];
            else
                repq_id_v_clr_mask[i0] = repq_id_v_clr_first[i0] | repq_id_v_clr_mask[i0-1];
        end
    end

    \=obj.lib.instance({
      'portsDelimiter': '\n    ',
      'instanceName': 'repq_id_v_clr_find_first',
      'moduleName':   'arb_spri',
      'params': {
           width : replayQSize
         },
      'verilogParams': {},
      'ports': {
          in_req    : 'repq_id_v_clr',
          out_gnt   : 'repq_id_v_clr_first',
      }
    })=\


    always @(*) begin
        for(i1 = 0; i1 < \=replayQSize=\; i1 = i1 + 1) begin
            if(i1 != \=replayQSize-1=\)
                repq_id_shift[i1] = repq_id_v_clr_mask[i1] & repq_id_v[i1+1];
            else
                repq_id_shift[i1] = 1'b0;
        end
    end



    wire [\=replayQSize-1=\:0] repq_rdy;
    wire [\=wRepId-1=\:0] repq_id0 = repq_id[0];
    assign repq_rdy     = repq_valid & ~repq_wait_rd & ~repq_wait_wr &
                          (~repq_wait_hd | (\=replayQSize=\'b1 << repq_id[0])) &
                          ~(ccp_p1_is_replay ? ccp_p1_replay_id_1hot : \=replayQSize=\'d0) 
                        \jsbegin 
                        if(UseTagRamOutputFlop){
                        \jsend
                            & ~(ccp_p1m_is_replay ? ccp_p1m_replay_id_1hot : \=replayQSize=\'d0) 
                        \jsbegin    
                          }
                        \jsend
                        \jsbegin 
                        if(UseTagRamInputFlop){
                        \jsend
                            & ~(ccp_p0p_is_replay ? ccp_p0p_replay_id_1hot : \=replayQSize=\'d0)
                        \jsbegin    
                          }
                        \jsend
                        ;
\=u.instance({
    portsDelimiter: '\n    ',
    instanceName: 'u_replay_valid',
    moduleName:   'logic_tree',
    params: {
      'width' : replayQSize,
      'logic' : '|'},
    ports: {
      'din'  : 'repq_rdy',
      'dout' : 'replay_valid'}})=\

    reg [\=replayQSize-1=\:0] ccp_p0_replay_vec;
    wire [\=replayQSize-1=\:0] ccp_p0_replay_first;

    always @(*) begin
        for(i2 = 0; i2< \=replayQSize=\; i2 = i2 + 1)
            ccp_p0_replay_vec[i2] = repq_id_v[i2] & repq_rdy[repq_id[i2]];
    end

    \=obj.lib.instance({
      'portsDelimiter': '\n    ',
      'instanceName': 'ccp_p0_replay_sel_find_first',
      'moduleName':   'arb_spri',
      'params': {
           width : replayQSize
         },
      'verilogParams': {},
      'ports': {
          in_req    : 'ccp_p0_replay_vec',
          out_gnt   : 'ccp_p0_replay_first',
      }
    })=\

    assign ccp_p0_replay_id = repq_id[0] & {\=wRepId=\{ccp_p0_replay_first[0]}}
\js for(var i = 1; i < replayQSize; i++) {
                             |(repq_id[\=i=\] & {\=wRepId=\{ccp_p0_replay_first[\=i=\]}})
\js }
    ;

    assign replay_cmd = repq[ccp_p0_replay_id];
    assign repq_avail = ~repq_id_v[\=replayQSize-4=\] | (~repq_id_v[\=replayQSize-3=\] & ~ccp_p1_to_replay);
    wire repq_id_v_or; 
\=u.instance({
    portsDelimiter: '\n    ',
    instanceName: 'u_repq_empty',
    moduleName:   'logic_tree',
    params: {
      'width' : replayQSize,
      'logic' : '|'},
    ports: {
      'din'  : 'repq_id_v',
      'dout' : 'repq_id_v_or'}})=\
    assign repq_empty = ~repq_id_v_or;

endmodule

