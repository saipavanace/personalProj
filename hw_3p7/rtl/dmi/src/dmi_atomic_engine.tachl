\jsbegin
//=============================================================================
// Copyright (C) 2018 Arteris, Inc.
// All rights reserved.
//=============================================================================
// DMI Atomic Engine
// Aurthor: Tso-Wei Chang
//
//=============================================================================
\jsend

\jsbegin
// 
// Variables
//
var returnDataInterface         = Object.assign({}, obj.lib.getParam('returnDataInterface'));
returnDataInterface.intf_size   = 0;
returnDataInterface.size        = 0;
returnDataInterface.mpf1        = 0;
var bundleFunctions             = obj.userLib.bundleFunctions;
var dw                          = obj.lib.getParam('dw');
var numEntries                  = obj.lib.getParam('numEntries');
var rttIdWidth                  = returnDataInterface.id;
var wAddrOffset                 = Math.log2(dw/8);
var wAddr                       = obj.lib.getParam('wAddr');
// atomic compare & swap data needs 16B each
var maxOpDw                     = 128;
var wProcDb                     = 2 * maxOpDw;
var wAtomicType                 = obj.lib.getParam('wAtomicType');
var wOpType                     = obj.lib.getParam('wAtomicOpType');
var useScratchpad               = obj.lib.getParam('useScratchpad');
var wSize                       = obj.lib.getParam('readAllocateInterface', 'size');
var wCmType                     = obj.lib.getParam('readAllocateInterface', 'cm_type');
var wSizeInByte                 = Math.log2(wProcDb/8) + 1;
var atomicFillInterface         = obj.lib.getParam('atomicFillInterface');
var atomicMemInterface          = obj.lib.getParam('atomicMemInterface');
var wQos                        = returnDataInterface.qos;
var assertOn                    = obj.lib.getParam("assertOn")
var atomicAddrInterface = {
    valid       :   1,
    ready       :  -1,
    addr        :   wAddr,
    size        :   wSize,
    endian      :   1,
    type        :   wAtomicType,
    op          :   wOpType,
    id          :   rttIdWidth,
    ns          :   1
}


var atomicDataInterface = {
    compLdStr_data   : dw,
    compLdStr_be     : dw/8,
    swap_data        : dw,
    swap_be          : dw/8
};

var abReqInterface = {
    valid   : 1,
    ready   :-1,
    addr    : wAddr,
    size    : wSize,
    endian  : 1,
    type    : wAtomicType,
    op      : wOpType,
    id      : rttIdWidth,
    ns      : 1,
    data    : wProcDb,
    data_be : wProcDb/8,
    poison  : 1
};

//
// Interfaces
//
obj.lib.interface('',               'slave', obj.lib.getParam('clkInterface'));
obj.lib.interface('proc_data_',     'slave', obj.lib.getParam('writeProtDataInterface'));
obj.lib.interface('mem_data_in_',   'slave', atomicMemInterface);
obj.lib.interface('result_data_',   'master',returnDataInterface);
obj.lib.interface('alloc_',         'slave', obj.lib.getParam('readAllocateInterface'));
obj.lib.interface('fill_',          'master',atomicFillInterface);

// port
obj.lib.port('input',   'alloc_rtt_id',          rttIdWidth);
obj.lib.port('input',   'alloc_type',           wAtomicType);
obj.lib.port('input',   'alloc_hit',                      1);
obj.lib.port('input',   'alloc_sp',                       1);
obj.lib.port('output',  'op_drop',                        1);
obj.lib.port('output',  'op_drop_rtt_id',        rttIdWidth);
obj.lib.port('output',  'pop_hit_ptr_valid',                   1);
if(useScratchpad){
obj.lib.port('output','pop_sp_hit_ptr_valid',1);
}
\jsend

module \=obj.lib.getModuleName()=\ (\=obj.lib.getPorts('\n')=\);

    // local encoding for atomic types
    localparam  LD      = 2'b0,
                STR     = 2'b01,
                COMPARE = 2'b10,
                SWAP    = 2'b11;

    localparam  ADD     = 3'b0,
                CLR     = 3'b001,
                EOR     = 3'b010,
                SET     = 3'b011,
                SMAX    = 3'b100,
                SMIN    = 3'b101,
                UMAX    = 3'b110,
                UMIN    = 3'b111;
    
\jsbegin
    //
    // Wires
    //
\jsend
    \=bundleFunctions.wiresFromInterface('push_result_data_',returnDataInterface,       [],                     obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('mem_data_',        returnDataInterface,       [],                     obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('ab_req_',          atomicAddrInterface,       [],                     obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('ab_alloc_',        atomicAddrInterface,       [],                     obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('push_ab_req_',     abReqInterface,            [],                     obj.lib.bundle)=\
    \=bundleFunctions.wiresFromInterface('push_ab_req_',     atomicAddrInterface,       ['valid', 'ready', 'type', 'op', 'id', 'addr', 'size', 'ns', 'endian'],     obj.lib.bundle)=\
    wire                                push_mem_data_in_ready;
    wire                                push_mem_data_in_valid;
    wire                                compCondTrue;
    wire                                compMatch;
    wire                                beatNoOp;
    wire                                ab_deallocVld;
    wire [\=dw-1=\:0]                   compLdStrData;
    wire [\=dw-1=\:0]                   memData;
    wire [\=dw-1=\:0]                   compSwapData;
    wire [\=dw-1=\:0]                   swapData;
    wire [\=dw-1=\:0]                   swapResult;
    wire [\=dw-1=\:0]                   opResult;
    wire [\=dw-1=\:0]                   atomicResult;
    wire [\=(dw/8)-1=\:0]               compLdStrDataBE;
    wire [\=(dw/8)-1=\:0]               compSwapDataBE;
    wire                                op_drop_cond;
    wire [\=wAtomicType-1=\:0]          atomicType;
    wire [\=wOpType-1=\:0]              opType;
    wire [\=rttIdWidth-1=\:0]           ab_searchId;
    wire [\=wSizeInByte-2=\:0]          halfSizeInByte;
    wire [\=wProcDb=\-1:0]              ab_req_data;
    wire [\=wProcDb/8=\-1:0]            ab_req_data_be;
    wire                                ab_req_poison;
    wire [\=dw-1=\:0]                   ab_req_compLdStr_data;
    wire [\=(dw/8)-1=\:0]               ab_req_compLdStr_be;
    wire                                pop_fill_dirty_valid;
    wire                                push_fill_dirty;
    wire                                d_op_dropped;
    wire                                op_dropped;
    wire                                en_op_dropped;
    wire                                hit_mem_data;
    wire                                hit_mem_data_in; 
    wire [\=dw-1=\:0]                   compData;
    wire [\=dw-1=\:0]                   memCompData;
    wire                                push_req_result_ready;
\js if(useScratchpad) {
    wire                                mem_data_sp_valid;
    wire                                mem_data_sp_in_ready;
\js }
    wire                                mem_data_sp;
    wire                                ab_lookup_valid;
    wire                                push_result_req_ready;
    wire                                push_result_data_fill;
\js // swap address
    wire                                s_addr;
    wire [\=wProcDb/8-1=\:0]            ab_req_data_be_shift;
\jsbegin
    //
    // Instances
    // 
    var atomic_buffer_ports ={       alloc_valid     :   'alloc_valid',
            alloc_ready     :   'alloc_ready',
            alloc_hit       :   'alloc_hit',
            alloc_ns        :   'alloc_ns',
            alloc_sp        :   'alloc_sp',
            hit_data        :   'hit_mem_data_in',
            sp_data         :   'mem_data_in_sp',
            deallocVld      :   'ab_deallocVld',
            searchRttId     :   'ab_searchId',
            procDataVld     :   'ab_lookup_valid',
            procData        :   'push_ab_req_data',
            procDataPoison  :   'push_ab_req_poison',
            procDataBE      :   'push_ab_req_data_be',
            pop_hit_ptr_valid      :   'pop_hit_ptr_valid'}
            if(useScratchpad) {
            atomic_buffer_ports['pop_sp_hit_ptr_valid']= 'pop_sp_hit_ptr_valid'
            }
\jsend

    assign hit_mem_data = mem_data_last & mem_data_first;
    assign hit_mem_data_in = mem_data_in_last & mem_data_in_first;

\js // atomic buffer
    \=obj.lib.instance({
        instanceName: 'dmi_atomic_buffer',
        moduleName: 'dmi_atomic_buffer',
        params: {
            clkInterface:       obj.lib.getParam('clkInterface'),
            numEntries:         numEntries,
            wAtomicType:        wAtomicType,
            wOpType:            wOpType,
            maxOpDw:            maxOpDw,
            dw:                 dw,
            wId:                returnDataInterface.id,
            writeProtDataInterface: obj.lib.getParam('writeProtDataInterface'),
            atomicAddrInterface:atomicAddrInterface, 
            atomicDataInterface:atomicDataInterface,
            useScratchpad:useScratchpad
        },
        verilogParams: {},
        ports: atomic_buffer_ports,
        interfaces: [
            {modulePrefix: '',              localPrefix: '',                interface: obj.lib.getParam('clkInterface')},
            {modulePrefix: 'alloc_',        localPrefix: 'ab_alloc_',       interface: atomicAddrInterface},
            {modulePrefix: 'proc_data_',    localPrefix: 'proc_data_',      interface: obj.lib.getParam('writeProtDataInterface')},
            {modulePrefix: 'req_',          localPrefix: 'push_ab_req_',    interface: atomicAddrInterface, exclude: ['valid', 'ready']}
        ],
        portsDelimiter: '\n        '
    })=\
    assign ab_alloc_valid   = alloc_valid; 
    assign alloc_ready      = ab_alloc_ready;
    assign ab_alloc_addr    = alloc_addr;
    assign ab_alloc_size    = alloc_size;

\js // TODO: add big endian support in the future
    assign ab_alloc_endian  = /*alloc_endian*/1'b0; 

    // assign by bundle
    assign ab_alloc_type    = alloc_type; 
    assign ab_alloc_ns      = alloc_ns;
\js // op is coming with processor data
    assign ab_alloc_op      = \=wOpType=\'d0;

    assign ab_alloc_id      = alloc_rtt_id;
    assign ab_searchId      = mem_data_in_id;
    // deallocate buffer when the first data is processed or dropped in hit case
    // and need to have room in mem_data_fifo
    assign ab_deallocVld    = push_ab_req_valid & push_ab_req_ready & push_mem_data_in_ready;
    assign ab_req_ready     = (push_result_data_ready | (op_drop_cond & mem_data_first)) & mem_data_valid & mem_data_last; // cannot pop on first because still remaining beats still need fill information
    assign atomicType       = ab_req_type;
    assign opType           = ab_req_op;

    // swap data address bit

    assign s_addr = |(ab_req_addr[\=wSizeInByte-2=\:0] & halfSizeInByte);

\jsbegin
// now only support 128/256
if ( dw < wProcDb) { \jsend // 128
    assign compSwapDataBE = (ab_req_size == \=Math.abs(atomicAddrInterface.size)=\'b101)? {\=dw/8=\{1'b1}} : ab_req_data_be[\=(dw/8)-1=\:0] & ab_req_data_be_shift[\=(dw/8)-1=\:0];
\jsbegin
} else { \jsend // 256
    assign compSwapDataBE = ab_req_data_be[\=(dw/8)-1=\:0] & ab_req_data_be_shift[\=(dw/8)-1=\:0];
\jsbegin
} \jsend

    assign ab_req_data_be_shift = s_addr ? (ab_req_data_be >> halfSizeInByte) : (ab_req_data_be << halfSizeInByte);
    wire [\=dw-1=\:0] swapDataMux;

\js // now only support 128/256
\js if ( dw > wProcDb/2) { // 256
    assign swapDataMux = {\=dw-wProcDb/2=\'b0 ,ab_req_data[\=wProcDb-1=\:\=wProcDb/2=\]};
\js } else { // 128
    assign swapDataMux = ((atomicType == COMPARE) && (ab_req_size == \=Math.abs(atomicAddrInterface.size)=\'b101) && s_addr) ? ab_req_data[\=dw-1=\:0] : ab_req_data[\=wProcDb-1=\:\=wProcDb/2=\];
\js }

\js // s_addr = 1 means data swap data is wrapping around
\jsbegin
// now only support 128/256
if ( dw < wProcDb) { \jsend // 128
    assign compSwapData   = (ab_req_size == \=Math.abs(atomicAddrInterface.size)=\'b101)? swapDataMux :
\jsbegin
} else { \jsend // 256
    assign compSwapData   = 
\jsbegin
} \jsend
                                                    s_addr      ? (ab_req_data[\=dw-1=\:0] << (8*halfSizeInByte)):
                                                                  (ab_req_data[\=dw-1=\:0] >> (8*halfSizeInByte));
 
\jsbegin
// now only support 128/256
if ( dw < wProcDb) { \jsend // 128
    assign compLdStrDataBE  = (ab_req_type == LD | ab_req_type == STR | ab_req_type == SWAP)? ab_req_data_be[\=(dw/8)-1=\:0] : (ab_req_size == \=Math.abs(atomicAddrInterface.size)=\'b101)? {\=dw/8=\{1'b1}} : ab_req_data_be[\=(dw/8)-1=\:0] & ~compSwapDataBE; 

    assign compLdStrData    = ((atomicType == COMPARE) && (ab_req_size == \=Math.abs(atomicAddrInterface.size)=\'b101) && s_addr) ? ab_req_data[\=wProcDb-1=\:\=wProcDb/2=\] : ab_req_data[\=dw-1=\:0];
\jsbegin
} else { \jsend // 256
    assign compLdStrDataBE  = (ab_req_type == LD | ab_req_type == STR | ab_req_type == SWAP)? ab_req_data_be[\=(dw/8)-1=\:0] : ab_req_data_be[\=(dw/8)-1=\:0] & ~compSwapDataBE; 

    assign compLdStrData    = ab_req_data[\=dw-1=\:0];
\jsbegin
} \jsend

\js // Compare/Swap logic
\js // TODO: add 64-bit support. 
\js // TODO: a 16byte buffer is required to gather mem_data
    assign halfSizeInByte   = (\=wSizeInByte-1=\'b1 << (ab_req_size-1));


\js for(var i = 0; i< dw/8; i++) {
    assign compData[\=i*8=\+:8] = compLdStrData[\=i*8=\+:8] & {8{compLdStrDataBE[\=i=\]}};
    assign memCompData[\=i*8=\+:8] = memData[\=i*8=\+:8] & {8{compLdStrDataBE[\=i=\]}};
\js }
    assign compMatch = (compData == memCompData);

\js for(var i = 0; i < dw/8; i++) {
    assign swapData[\=i*8=\+:8] = (atomicType == COMPARE)? (compSwapData[\=i*8=\+:8]  & {8{compLdStrDataBE[\=i=\]}}) | (memData[\=i*8=\+:8] & {8{~compLdStrDataBE[\=i=\]}})
                                                         : (compLdStrData[\=i*8=\+:8] & {8{compLdStrDataBE[\=i=\]}}) | (memData[\=i*8=\+:8] & {8{~compLdStrDataBE[\=i=\]}});
\js }
    assign swapResult = (swapData & ({\=dw=\{(atomicType == SWAP) | ((atomicType == COMPARE) & compMatch)}}))|
                        (memData  & ({\=dw=\{                       ((atomicType == COMPARE) &~compMatch)}}));

\js // atomic op processor                       
    \=obj.lib.instance({
        instanceName: 'dmi_atomic_op_processor',
        moduleName: 'dmi_atomic_op_processor',
        params: {
            clkInterface:       obj.lib.getParam('clkInterface'),
            wAtomicType:        wAtomicType,
            wOpType:            wOpType,
            dw:                 dw,
            wAddr:              wAddrOffset,
            atomicAddrInterface:atomicAddrInterface, 
            atomicDataInterface:atomicDataInterface,
            returnDataInterface: returnDataInterface
        },
        verilogParams: {},
        ports: {
            muxedCompLdStrData: 'compData',
            muxedMemData: 'memCompData',
            opResult: 'opResult',
            memData: 'memData',
            compCondTrue: 'compCondTrue'
        },
        interfaces: [
            {modulePrefix: '',          localPrefix: '',                interface: obj.lib.getParam('clkInterface')},
            {modulePrefix: 'req_',      localPrefix: 'ab_req_',         interface: atomicAddrInterface, exclude:['id', 'valid', 'ready']},
            {modulePrefix: 'req_data_', localPrefix: 'ab_req_',         interface: atomicDataInterface, exclude:['swap_data', 'swap_be']}
        ],
        portsDelimiter: '\n        '
    })=\

    assign ab_req_compLdStr_data = compLdStrData;
    assign ab_req_compLdStr_be   = compLdStrDataBE;

\js // result fifo
    \=obj.lib.instance({
        instanceName: 'atomic_result_fifo',
        moduleName: 'fifo_bundle',
        params: {
            width: bundleFunctions.getBundleWidth(returnDataInterface, ['valid', 'ready'], obj.lib.bundle),
            depth: 2,
            zerodepth: 0,
            bypass_mode: 0,
            interface: returnDataInterface
        },
        verilogParams: {},
        ports: {
            push_valid: 'push_result_data_valid',
            push_ready: 'push_result_data_ready'},
        interfaces: [
            {modulePrefix: '',      localPrefix: '',                  interface: obj.lib.getParam('clkInterface')},
            {modulePrefix: 'push_', localPrefix: 'push_result_data_', interface: returnDataInterface, exclude:['valid', 'ready', 'size', 'intf_size', 'mpf1']},
            {modulePrefix: 'pop_',  localPrefix: 'result_data_',      interface: returnDataInterface, exclude:['size', 'intf_size', 'mpf1']}
        ],
        portsDelimiter: '\n        '
    })=\
    assign push_result_data_fill = 1'b1;
    assign push_result_data_data = atomicResult;
\js // implies the dependency of ab alloc <- proc data <- mem miss data <- result data
\js // TODO: add 64-bit support on drop. Now all assuming single beat for hit case.
    assign push_result_data_valid           = mem_data_valid & ~(op_drop_cond & hit_mem_data);
    assign push_result_data_first           = mem_data_first;
    assign push_result_data_last            = mem_data_last;
\js // hit mem data may not carry the correct id
    assign push_result_data_id              = hit_mem_data? ab_req_id : mem_data_id; 
    assign push_result_data_trans_id        = mem_data_trans_id;
    assign push_result_data_target_id       = mem_data_target_id;
    assign push_result_data_r_message_id    = mem_data_r_message_id;
    assign push_result_data_cm_type         = mem_data_cm_type;
    assign push_result_data_dwid            = mem_data_dwid;
    assign push_result_data_vz              = mem_data_vz;
    assign push_result_data_poison          = mem_data_poison | (ab_req_poison & mem_data_first);
    assign push_result_data_cdw             = \=returnDataInterface.cdw=\'d0;
    assign push_result_data_err_type        = \=returnDataInterface.err_type=\'d0;
    assign push_result_data_tm              = \=returnDataInterface.tm=\'d0; //unused
    assign push_result_data_rd_type         = \=returnDataInterface.rd_type=\'d0; //unused
    assign push_result_data_exokay          = \=returnDataInterface.exokay=\'d0; //unused
    \jsbegin 
    // AXI user fields not avail on w/r data channels on ncore 3.4
    /* istanbul ignore if env ncore_3p4,ncore_3p6 */
    if (returnDataInterface.user != 0) {
    \jsend
        assign push_result_data_user 	    =  \=returnDataInterface.user=\'d0; //unused
    \jsbegin
    }
    \jsend

\js if ( wQos != 0 ) {
    assign push_result_data_qos             = mem_data_qos;

\js }
    assign atomicResult                     = (beatNoOp | op_drop_cond)? memData : ((atomicType == LD) | (atomicType == STR))? opResult : swapResult;

    assign op_drop_cond = ((atomicType == COMPARE) & ~compMatch)                                                                                                    | 
                          (((atomicType == LD) | (atomicType == STR)) & ((opType == SMAX) | (opType == SMIN) | (opType == UMAX) | (opType == UMIN)) & ~compCondTrue);
    assign op_drop = mem_data_ready & mem_data_valid & op_drop_cond & mem_data_first & mem_data_last;
    assign op_drop_rtt_id = hit_mem_data? ab_req_id : mem_data_id;

    \=obj.lib.dffre(1, 'op_dropped', 'd_op_dropped', "1'b0", 'en_op_dropped', 'clk', 'reset_n')=\

\js // fill_dirty will remain asserted for all beats if not dropped
    assign d_op_dropped  = op_drop_cond; 
    assign en_op_dropped = push_result_data_valid & push_result_data_ready & push_result_data_first;
    assign push_fill_dirty = beatNoOp? ~op_dropped : ~op_drop_cond;
    wire req_sp;
\js if(useScratchpad == 0) {
    wire fill_sp;
\js }

    \=obj.lib.instance({
        instanceName: 'req_out_fifo',
        moduleName: 'fifo',
        params: {
            width: 1 + 1 + 1 + wAddr,
            depth: 2,
            zerodepth: 0,
            bypass_mode: 0
        },
        verilogParams: {},
        ports: {
            push_valid: 'push_result_data_valid',
            push_ready: 'push_result_req_ready',
            pop_valid:  'pop_fill_dirty_valid',
            pop_ready:  'result_data_ready',
            push_data:  '{push_fill_dirty, ab_req_ns, ab_req_addr, req_sp}',
            pop_data:   '{fill_dirty, fill_ns, fill_addr, fill_sp}'},
        interfaces: [
            {modulePrefix: '',      localPrefix: '',                interface: obj.lib.getParam('clkInterface')},
        ],
        portsDelimiter: '\n        '
    })=\

\js if(useScratchpad) {
    assign req_sp = mem_data_sp & mem_data_sp_valid;
\js } else {
    assign req_sp = mem_data_sp;
\js }

    assign mem_data_in_ready = push_mem_data_in_ready & (ab_lookup_valid & push_ab_req_ready | ~mem_data_in_first) ;
    assign push_mem_data_in_valid = mem_data_in_valid & (ab_lookup_valid & push_ab_req_ready | ~mem_data_in_first) ;
\js // memory data fifo
    \=obj.lib.instance({
        instanceName: 'mem_data_fifo',
        moduleName: 'fifo_bundle',
        params: {
            width: bundleFunctions.getBundleWidth(returnDataInterface, ['valid', 'ready'], obj.lib.bundle),
            depth: numEntries*(64/(dw/8)),
            zerodepth: 0,
            bypass_mode: 0,
            interface: returnDataInterface
        },
        verilogParams: {},
        ports: {
            push_valid: 'push_mem_data_in_valid',
            push_ready: 'push_mem_data_in_ready'},
        interfaces: [
            {modulePrefix: '',      localPrefix: '',                interface: obj.lib.getParam('clkInterface')},
            {modulePrefix: 'push_', localPrefix: 'mem_data_in_',    interface: returnDataInterface, exclude:['valid','ready']},
            {modulePrefix: 'pop_',  localPrefix: 'mem_data_',       interface: returnDataInterface}
        ],
        portsDelimiter: '\n        '
    })=\

\js if(useScratchpad) {
    wire  push_mem_data_sp_in_valid;
    // Need to ensure only push when accepted to avoid placing multiple entries for same transaction.
    assign push_mem_data_sp_in_valid = mem_data_in_valid & mem_data_in_ready & ab_lookup_valid;

    \=obj.lib.instance({
        instanceName: 'mem_data_sp_fifo',
        moduleName: 'fifo',
        params: {
            width: 1,
            depth: numEntries*(32/(dw/8)),
            zerodepth: 0,
            bypass_mode: 0
        },
        verilogParams: {},
        ports: {
            push_valid: 'push_mem_data_sp_in_valid',
            push_ready: 'mem_data_sp_in_ready',
            pop_valid:  'mem_data_sp_valid',
            pop_ready:  'mem_data_ready & mem_data_valid & mem_data_last',
            push_data:  'mem_data_in_sp',
            pop_data:   'mem_data_sp'},
        interfaces: [
            {modulePrefix: '',      localPrefix: '',                interface: obj.lib.getParam('clkInterface')},
        ],
        portsDelimiter: '\n        '
    })=\
\js } else {
    assign mem_data_sp = 1'b0;
\js }

    assign memData          = mem_data_data;
    assign mem_data_ready   = (push_result_data_ready | (op_drop_cond & mem_data_first & mem_data_last));
    assign beatNoOp         =~mem_data_first;



    // this lookup needs to be valid: dataValid, reqValid.
    // Need to ensure only push when accepted to avoid placing multiple entries for same transaction.
    assign push_ab_req_valid = ab_lookup_valid & mem_data_in_valid & mem_data_in_ready & mem_data_in_first;

\js // atomic buffer data fifo
    \=obj.lib.instance({
        instanceName: 'atomic_data_buffer_fifo',
        moduleName: 'fifo_bundle',
        params: {
            width: bundleFunctions.getBundleWidth(abReqInterface, ['valid', 'ready'], obj.lib.bundle),
            depth: numEntries*(32/(dw/8)),
            zerodepth: 0,
            bypass_mode: 0,
            interface: abReqInterface
        },
        verilogParams: {},
        ports: {
                push_valid: 'push_ab_req_valid',
                push_ready: 'push_ab_req_ready',
                pop_valid:  'ab_req_valid', 
                pop_ready:  'ab_req_ready'
        },
        interfaces: [
            {modulePrefix: '',      localPrefix: '',                    interface: obj.lib.getParam('clkInterface')},
            {modulePrefix: 'push_', localPrefix: 'push_ab_req_',        interface: abReqInterface, exclude:['valid', 'ready']},
            {modulePrefix: 'pop_',  localPrefix: 'ab_req_',             interface: abReqInterface, exclude:['valid', 'ready']}
        ],
        portsDelimiter: '\n        '
    })=\

\jsbegin
 // always enabled in sim
 /* istanbul ignore else env ncore_3p6 */
 if ( assertOn ) {
    \jsend
    `ifdef OVL_ASSERT_ON
    // synthesis_off
    // pragma synthesis_off
    // coverage off

    assert_never #(0) atomic_fifo_overflow(
        .clk(clk),
        .reset_n(reset_n),
        .test_expr(mem_data_in_valid & mem_data_in_ready & push_ab_req_valid & ~push_ab_req_ready)
    );

    // coverage on
    // pragma synthesis_on
    // synthesis_on
    `endif
    \jsbegin
 }

// Assertion:
// 1. atomic axi always sending critical beat address
// 2. Memory data always wrap, and critical word first
// 3. no interleaved memory data 
// 4. fill_dirty_valid == result_data_valid
// TODO: Drop case: hit no fill.
\jsend
endmodule

