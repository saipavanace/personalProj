\jsbegin
//=============================================================================
// Copyright(C) 2018 Arteris, Inc.
// All rights reserved
//=============================================================================
// DVE Protocol Manager
// Author: Boon Chuan
// Filename: dve_protocol_man.tachl
//=============================================================================
// CONC-7583
// =========
// ARM DSU cannot accept more than 4 DVM snoop pairs.
// Non-Sync DVM Bypass is required to guarantee forward progress for Non-Sync DVM.
//
// Number of snoop credits are fixed at 8 so that the number of STT entries are fixed at 4.
// STT entries are partitioned to regular and reserved. The number of reserved STT entry is fixed at 1.
// The reserved STT entry is only for Non-Sync DVMOp bypass.
// Max number of Sync DVMOp in regular STT entries is 3 (This can be controlled by CSR to be 1).
//  
// Transaction Flow:
//  
// (1) CMDreq arrives at the Skid Buffer.
// => allocate an RBID using a Free List Manager that is sized nRbidEntries.
// => allocate an STTID. This STTID is not the STT Index. This STTID is just a unique number allocated from a counter. 
// => place the CMDreq + parameters (such as RBID, STTID) in the Skid Buffer @ RBID.
// => issue STRreq with RBID and STTID.
// => issue CMDrsp
//  
// (2) DTWreq with RBID arrives at the Skid Buffer.
// => place the DTWreq in the Skid Buffer @ DTWreq RBID.
// => issue DTWrsp.
// => now we have a complete DVM message = CMDreq + DTWreq.
//  
// (3) The Snoop Request State Machine looks into the Skid Buffer and all the 4 STT entries.
// If STT is not full
// * allocate for a regular STT entry index, pull the oldest DVM message from the Skid Buffer, and load it to the STT @ the regular STT entry index
// * start issuing SNPreq messages with STTID (this STTID is not the STT entry index), and update the snoop credit counter.
// * deallocate the RBID (at the end of SNPreq broadcast).

// If STT is full, and all 3 regular STT entries are in use by Sync DVMOp, and 1 reserved STT entry is available:
// * allocate for a reserved STT entry index, pull the oldest Non-Sync DVM message from the Skid Buffer, and load it to the STT @ the reserved STT entry index
// * start issuing SNPreq messages with STTID (this STTID is not the STT entry index)
// * deallocate the RBID (at the end of SNPreq broadcast).
// Otherwise
// * wait
//  
// (4) SNPrsp with STTID arrives.
// Update the STT entry with matching STTID with the SNPrsp protocol information, and update the snoop credit counter.
// Issue CMPrsp when all required SNPrsp messages have arrived.
//  
// (5) STRrsp with STTID arrives.
// Deallocate the STT entry with matching STTID.
//=============================================================================

\jsend

\jsbegin

var u = obj.lib;

var log2ceil = function(n) { return Math.ceil(Math.log(n)/Math.LN2); };

var assertOn           = obj.lib.getParam('assertOn');
var memErrType         = obj.lib.getParam('memErrType');
var memErrWidth        = obj.lib.getParam('memErrWidth');
var nMainTraceBufSize  = obj.lib.getParam('nMainTraceBufSize');
var nTraceBanks        = obj.lib.getParam('nTraceBanks');
var wMainTraceBufSize  = Math.max(1, log2ceil(nMainTraceBufSize));
var wTraceBanks        = Math.max(1, log2ceil(nTraceBanks));
var wTraceMe           = obj.lib.getParam('wTraceMe');
var wFUnitId           = obj.lib.getParam('wFUnitId');
var wDvmReqAddr        = obj.lib.getParam('wDvmReqAddr');    // AMBA 5 CHI DVM requires 44,45,46..52
var wDvmReqData        = obj.lib.getParam('wDvmReqData');    // Always 64 as DVM data payload is always lower 64 bits.
var wDvmReqAttr        = obj.lib.getParam('wDvmReqAttr');
var wDvmReqAiuId       = obj.lib.getParam('wDvmReqAiuId');
var wDvmReqMsgId       = obj.lib.getParam('wDvmReqMsgId');
var wDvmReqQos         = obj.lib.getParam('wDvmReqQos');
var wDvmReqPriority    = obj.lib.getParam('wDvmReqPriority');
var nDvmSnpCredits     = obj.lib.getParam('nDvmSnpCredits');
var nSkidEntries       = obj.lib.getParam('nSkidEntries');
var nSttEntries        = obj.lib.getParam('nSttEntries');
var wSttEntries        = Math.max(1, log2ceil(nSttEntries));
var nDveAgents         = obj.lib.getParam('nDveAgents');
var wSttId             = obj.lib.getParam('wSttId');

var nDvmSnpCreditsAll  = nDvmSnpCredits >> 1; // nDvmSnpCredits must be an even number; a pair of snoop messages consume 2 credits
var wSkidEntries       = Math.max(1, log2ceil(nSkidEntries));
var wDvmSnpCntr        = Math.max(1, log2ceil(nDveAgents + 1));
var wDvmSnpCreditsCntr = Math.max(1, log2ceil(nDvmSnpCreditsAll + 1));

var wStrReqFifo        = wDvmReqMsgId + wDvmReqAiuId + wDvmReqPriority;
var wDtwRspFifo        = wDvmReqMsgId + wDvmReqAiuId + wDvmReqPriority;
var wCmpIssueFifo      = wSttId;
\jsend

\jsbegin
//=============================================================================
// Ports
//=============================================================================
\jsend

\jsbegin

obj.lib.port('input',  'clk',      1);
obj.lib.port('input',  'reset_n',  1);
obj.lib.port('input',  'csr_DeallocEarly',  1);
obj.lib.port('input',  'csr_AceDvmOrder',  1);
obj.lib.port('input',  'csr_RelaxDvmSnoopPairs', 1);
// Ncore3.2 always has a trace buffer
/* istanbul ignore else env ncore_3p2,ncore_3p4,ncore_3p6,ncore_3p7 */
if (nMainTraceBufSize>0) {
obj.lib.port('input',  'ungated_clk',      1);
obj.lib.port('input',  'ungated_reset_n',  1);
}
obj.lib.port('output', 'csr_DvmTransActive',   1);
obj.lib.port('input',  'csr_DvmSnoopDisable',  nDveAgents);
obj.lib.port('input',  'csr_MaxOneSyncDVMOp',  1);
obj.lib.port('output', 'agents_inactive_vec',  nDveAgents);

    for (i=0; i < nDveAgents; i++) {
obj.lib.port('input', 'dvm_aiu'+i+'_f_unit_id', wFUnitId);
    }

// Input DVM CMDreq
obj.lib.port('input',  'dvm_cmdreq_valid',  1);
obj.lib.port('output', 'dvm_cmdreq_ready',  1);
obj.lib.port('input',  'dvm_cmdreq_cmstatus', 8);
obj.lib.port('input',  'dvm_cmdreq_addr',   wDvmReqAddr);
obj.lib.port('input',  'dvm_cmdreq_attr',   wDvmReqAttr);
obj.lib.port('input',  'dvm_cmdreq_aiuid',  wDvmReqAiuId);
obj.lib.port('input',  'dvm_cmdreq_msgid',  wDvmReqMsgId);
    if (wDvmReqQos > 0) {
obj.lib.port('input',  'dvm_cmdreq_qos',    wDvmReqQos);
    }
    if (wDvmReqPriority > 0) {
obj.lib.port('input',  'dvm_cmdreq_priority', wDvmReqPriority);
    }

// Output DVM CMDrsp
obj.lib.port('output', 'dvm_cmdrsp_valid',  1);
obj.lib.port('input',  'dvm_cmdrsp_ready',  1);
obj.lib.port('output', 'dvm_cmdrsp_aiuid',  wDvmReqAiuId);
obj.lib.port('output', 'dvm_cmdrsp_msgid',  wDvmReqMsgId); //this is the RMessageId
obj.lib.port('output', 'dvm_cmdrsp_sttid',  wSttId);
obj.lib.port('output', 'dvm_cmdrsp_cmstatus', 8);
    if (wDvmReqPriority > 0) {
obj.lib.port('output', 'dvm_cmdrsp_priority', wDvmReqPriority);
    }
// Ncore3.2 always has a trace bit
/* istanbul ignore else env ncore_3p2,ncore_3p4,ncore_3p6,ncore_3p7 */
    if (wTraceMe > 0) {
obj.lib.port('output', 'dvm_cmdrsp_tm', wTraceMe);
    }

// Output DVM STRreq
obj.lib.port('output', 'dvm_strreq_valid',  1);
obj.lib.port('input',  'dvm_strreq_ready',  1);
obj.lib.port('output', 'dvm_strreq_rbid',   wSkidEntries);
obj.lib.port('output', 'dvm_strreq_sttid',  wSttId);
obj.lib.port('output', 'dvm_strreq_aiuid',  wDvmReqAiuId);
obj.lib.port('output', 'dvm_strreq_msgid',  wDvmReqMsgId); //this is the RMessageId
    if (wDvmReqPriority > 0) {
obj.lib.port('output', 'dvm_strreq_priority', wDvmReqPriority);
    }
// Ncore3.2 always has a trace bit
/* istanbul ignore else env ncore_3p2,ncore_3p4,ncore_3p6,ncore_3p7 */
    if (wTraceMe > 0) {
obj.lib.port('output', 'dvm_strreq_tm', wTraceMe);
    }
// Input DVM DTWreq 
obj.lib.port('input',  'dvm_dtwreq_valid',  1);
obj.lib.port('output', 'dvm_dtwreq_ready',  1);
obj.lib.port('input',  'dvm_dtwreq_last',   1);
obj.lib.port('input',  'dvm_dtwreq_cmstatus', 8);
obj.lib.port('input',  'dvm_dtwreq_data',   wDvmReqData);
obj.lib.port('input',  'dvm_dtwreq_dbad',   1);
obj.lib.port('input',  'dvm_dtwreq_rbid',   wSkidEntries);
obj.lib.port('input',  'dvm_dtwreq_aiuid',  wDvmReqAiuId);
obj.lib.port('input',  'dvm_dtwreq_msgid',  wDvmReqMsgId);
    if (wDvmReqPriority > 0) {
obj.lib.port('input',  'dvm_dtwreq_priority', wDvmReqPriority);
    }
// Ncore3.2 always has a trace bit
/* istanbul ignore else env ncore_3p2,ncore_3p4,ncore_3p6,ncore_3p7 */
    if (wTraceMe > 0) {
obj.lib.port('input',  'dvm_dtwreq_tm', wTraceMe);
    }

// Ncore3.2 always has a trace buffer
/* istanbul ignore else env ncore_3p2,ncore_3p4,ncore_3p6,ncore_3p7 */
if (nMainTraceBufSize>0) {
// Input DVM DTWreq
obj.lib.port('input',  'dvm_dbg_dtwreq_valid',  1);
obj.lib.port('output', 'dvm_dbg_dtwreq_ready',  1);
obj.lib.port('input',  'dvm_dbg_dtwreq_last',   1);
obj.lib.port('input',  'dvm_dbg_dtwreq_data',   wDvmReqData);
obj.lib.port('input',  'dvm_dbg_dtwreq_dbad',   1);
//obj.lib.port('input',  'dvm_dbg_dtwreq_rbid',   wSkidEntries);
obj.lib.port('input',  'dvm_dbg_dtwreq_aiuid',  wDvmReqAiuId);
obj.lib.port('input',  'dvm_dbg_dtwreq_msgid',  wDvmReqMsgId);
    if (wDvmReqPriority > 0) {
obj.lib.port('input',  'dvm_dbg_dtwreq_priority', wDvmReqPriority);
    }
}

// Output DVM DTWrsp 
obj.lib.port('output', 'dvm_dtwrsp_valid',  1);
obj.lib.port('input',  'dvm_dtwrsp_ready',  1);
obj.lib.port('output', 'dvm_dtwrsp_aiuid',  wDvmReqAiuId);
obj.lib.port('output', 'dvm_dtwrsp_msgid',  wDvmReqMsgId);
obj.lib.port('output', 'dvm_dtwrsp_cmstatus', 8);
obj.lib.port('output', 'dvm_dtwrsp_dbad',   1);
    if (wDvmReqPriority > 0) {
obj.lib.port('output', 'dvm_dtwrsp_priority', wDvmReqPriority);
    }
// Ncore3.2 always has a trace bit
/* istanbul ignore else env ncore_3p2,ncore_3p4,ncore_3p6,ncore_3p7 */
    if (wTraceMe > 0) {
obj.lib.port('output', 'dvm_dtwrsp_tm', wTraceMe);
    }
// Ncore3.2 always has a trace buffer
/* istanbul ignore else env ncore_3p2,ncore_3p4,ncore_3p6,ncore_3p7 */
if (nMainTraceBufSize>0) {
// Output DVM DTWrsp
obj.lib.port('output', 'dvm_dbg_dtwrsp_valid',  1);
obj.lib.port('input',  'dvm_dbg_dtwrsp_ready',  1);
obj.lib.port('output', 'dvm_dbg_dtwrsp_aiuid',  wDvmReqAiuId);
obj.lib.port('output', 'dvm_dbg_dtwrsp_msgid',  wDvmReqMsgId);
obj.lib.port('output', 'dvm_dbg_dtwrsp_cmstatus', 8);
obj.lib.port('output', 'dvm_dbg_dtwrsp_dbad',   1);
    if (wDvmReqPriority > 0) {
obj.lib.port('output', 'dvm_dbg_dtwrsp_priority', wDvmReqPriority);
    }
}

// Output DVM SNPreq
obj.lib.port('output', 'dvm_snpreq_valid',  1);
obj.lib.port('input',  'dvm_snpreq_ready',  1);
obj.lib.port('output', 'dvm_snpreq_cmstatus', 8);
obj.lib.port('output', 'dvm_snpreq_sttid',  wSttId);
obj.lib.port('output', 'dvm_snpreq_addr',   wDvmReqAddr);
obj.lib.port('output', 'dvm_snpreq_mpf1', 8); // vmidext is sent in snoop part 1
obj.lib.port('output', 'dvm_snpreq_mpf3', 8);
obj.lib.port('output', 'dvm_snpreq_attr',   wDvmReqAttr);
obj.lib.port('output', 'dvm_snpreq_aiuid',  wDvmReqAiuId);
    if (wDvmReqQos > 0) {
obj.lib.port('output', 'dvm_snpreq_qos',    wDvmReqQos);
    }
    if (wDvmReqPriority > 0) {
obj.lib.port('output', 'dvm_snpreq_priority', wDvmReqPriority);
    }

// Input DVM SNPrsp
obj.lib.port('input',  'dvm_snprsp_valid',   1);
obj.lib.port('output', 'dvm_snprsp_ready',   1);
obj.lib.port('input',  'dvm_snprsp_aiuid',   wDvmReqAiuId);
obj.lib.port('input',  'dvm_snprsp_sttid',   wSttId);
obj.lib.port('input',  'dvm_snprsp_cmstatus', 8);

// Output DVM CMPrsp
obj.lib.port('output', 'dvm_cmp_valid',  1);
obj.lib.port('input',  'dvm_cmp_ready',  1);
obj.lib.port('output', 'dvm_cmp_sttid',  wSttId);
obj.lib.port('output', 'dvm_cmp_aiuid',  wDvmReqAiuId);
obj.lib.port('output', 'dvm_cmp_msgid',  wDvmReqMsgId);
obj.lib.port('output', 'dvm_cmp_cmstatus', 8);
    if (wDvmReqPriority > 0) {
obj.lib.port('output', 'dvm_cmp_priority', wDvmReqPriority);
    }
// Ncore3.2 always has a trace bit
/* istanbul ignore else env ncore_3p2,ncore_3p4,ncore_3p6,ncore_3p7 */
    if (wTraceMe > 0) {
obj.lib.port('output', 'dvm_cmp_tm', wTraceMe);
    }

// Input DVM STRrsp
obj.lib.port('input',  'dvm_strrsp_valid',   1);
obj.lib.port('output', 'dvm_strrsp_ready',   1);
obj.lib.port('input',  'dvm_strrsp_sttid',   wSttId);

obj.lib.port('output', 'dve_pmon_active_stt_entries',    wSttEntries);

// Ncore3.2 always has a trace buffer
/* istanbul ignore else env ncore_3p2,ncore_3p4,ncore_3p6,ncore_3p7 */
if (nMainTraceBufSize>0) {
// Trace and Debug
obj.lib.port('input', 'csr_DVETASCR_BufferIsCircular',   1);
obj.lib.port('input', 'csr_DVETASCR_BufferClear',        1);
obj.lib.port('input', 'csr_DVETASCR_BufferRead',         1);

obj.lib.port('output', 'dve_trace_busy',                 1);
obj.lib.port('output', 'dve_pmon_trace_packets_dropped', 1);
obj.lib.port('output', 'dve_pmon_trace_packets_accepted',1);

obj.lib.port('output', 'dve_trace_buffer_empty',          1);
obj.lib.port('output', 'dve_trace_buffer_full',           1);
obj.lib.port('output', 'dve_trace_funit_id',              8);
obj.lib.port('output', 'dve_trace_read_data_valid',       1);
obj.lib.port('output', 'dve_trace_timestamp',            32);
for (i=0;i<16;i++) {
obj.lib.port('output', 'dve_trace_capture_data_valid'+i,  1);
obj.lib.port('output', 'dve_trace_capture_data'+i,       32);
}

obj.lib.port('output', 'dve_trace_hdr_ecc_sb_error',          1);
obj.lib.port('output', 'dve_trace_hdr_ecc_db_error',          1);

obj.lib.port('output', 'dve_trace_hdr_ecc_addr',          wMainTraceBufSize);

obj.lib.port('output', 'dve_trace_data_ecc_sb_error',          1);
obj.lib.port('output', 'dve_trace_data_ecc_db_error',          1);

obj.lib.port('output', 'dve_trace_data_ecc_addr',          wMainTraceBufSize+wTraceBanks);
}

// Ncore3.2 always has a trace buffer
/* istanbul ignore else env ncore_3p2,ncore_3p4,ncore_3p6,ncore_3p7 */
if (nMainTraceBufSize>0) {
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Trace & Debug ram interface
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
obj.lib.port('output', 'f_cen_hdr',                      1);
obj.lib.port('output', 'f_wen_hdr',                      1);
obj.lib.port('output', 'f_caddr_hdr',    wMainTraceBufSize);
obj.lib.port('output', 'f_wdata_hdr',                   64+memErrWidth);
obj.lib.port('input',  'f_rdata_hdr',                   64+memErrWidth);

obj.lib.port('output', 'f_cen_data',                     1);
obj.lib.port('output', 'f_wen_data',                     1);
obj.lib.port('output', 'f_caddr_data',   wMainTraceBufSize+wTraceBanks);
obj.lib.port('output', 'f_wdata_data',                  64+memErrWidth);
obj.lib.port('input',  'f_rdata_data',                  64+memErrWidth);
}

\jsend

module \=obj.lib.getModuleName()=\ (\=obj.lib.getPorts('\n')=\);

\jsbegin
//=============================================================================
// Wires
//=============================================================================
\jsend

wire [2:0] DVM_OPCODE_SYNC = 3'b100;
wire dff_enable = 1'b1;

wire flm_sttid_collision;
wire [\=wSttId-1=\:0] flm_sttid;

wire cmdreq_fifo__pop_valid;
wire cmdrsp_fifo__pop_valid;
wire dtwrsp_fifo__pop_valid;
\jsbegin
// Ncore3.2 always has a trace buffer
/* istanbul ignore else env ncore_3p2,ncore_3p4,ncore_3p6,ncore_3p7 */
    if (nMainTraceBufSize>0) { \jsend
wire dtwrsp_dbg_fifo__pop_valid;
\js }
wire strreq_fifo__pop_valid;

wire [\=nSttEntries-1=\:0] stt_index_flm__allocate0;
wire stt_index_flm__allocate0_vld;
wire stt_index_flm__allocate0_ack;
wire [\=nSttEntries-1=\:0] stt_index_flm__deallocate0;
wire stt_index_flm__deallocate0_vld;
wire [\=nSttEntries-1=\:0] dve_flm__mask  = csr_RelaxDvmSnoopPairs ? {\=nSttEntries=\{1'b1}} : \=nSttEntries=\'hf;
wire [\=nSttEntries-1=\:0] dve_flm__mask0 = (csr_MaxOneSyncDVMOp ? {{\=nSttEntries-1=\{1'b0}}, 1'b1} : {1'b0, {\=nSttEntries-1=\{1'b1}}}) & dve_flm__mask;
wire [\=nSttEntries-1=\:0] dve_flm__mask1 = csr_MaxOneSyncDVMOp ? {1'b1, {\=nSttEntries-1=\{1'b0}}} : {1'b1, {\=nSttEntries-1=\{1'b0}}};

wire [\=nSttEntries-1=\:0] dve_flm__allocate0;
wire dve_flm__allocate0_vld;
wire dve_flm__allocate0_ack;
wire [\=nSttEntries-1=\:0] dve_flm__allocate1;
wire dve_flm__allocate1_vld;
wire dve_flm__allocate1_ack;
wire [\=nSttEntries-1=\:0] dve_flm__deallocate;
wire dve_flm__deallocate_vld;

wire dtf_valid;
wire dtf_ready;
wire [7:0] dtf_cmstatus;
wire [\=wDvmReqAddr-1=\:0] dtf_addr;
wire [\=wDvmReqAttr-1=\:0] dtf_attr;
wire [\=wDvmReqAiuId-1=\:0] dtf_aiuid;
wire [\=wDvmReqMsgId-1=\:0] dtf_msgid;
wire [\=wSkidEntries-1=\:0] dtf_rbid;
wire [\=wSttId-1=\:0] dtf_sttid;
wire [\=wDvmReqData-1=\:0] dtf_data;
\js if ( wDvmReqQos > 0 ) {
wire [\=wDvmReqQos-1=\:0] dtf_qos;
\js }
\js if ( wDvmReqPriority > 0 ) {
wire [\=wDvmReqPriority-1=\:0] dtf_priority;
\js }
\jsbegin
// Ncore3.2 always has a trace bit
/* istanbul ignore else env ncore_3p2,ncore_3p4,ncore_3p6,ncore_3p7 */
    if ( wTraceMe > 0 ) { \jsend
wire [\=wTraceMe-1=\:0] dtf_tm;
\js }

wire dtf_dbad;
wire dtf_cmstatus_err;
wire dtf_addr_sync_decode;

wire stt_init_in;
wire stt_init;
wire [\=nSttEntries-1=\:0] stt_init_vec;
wire [\=nSttEntries-1=\:0] stt_deinit_vec;

wire [2:0] IDLE             = 3'b000;
wire [2:0] CHECK            = 3'b001;
wire [2:0] SEND_SNP1        = 3'b010;
wire [2:0] SEND_SNP2        = 3'b011;
wire [2:0] TERMINATE        = 3'b100;

reg  [2:0] next_state;
wire [2:0] state;

wire state_is_IDLE;
wire state_is_CHECK;
wire state_is_SEND_SNP1;
wire state_is_SEND_SNP2;
wire state_is_TERMINATE;

wire next_state_is_IDLE;
wire next_state_is_CHECK;
wire next_state_is_SEND_SNP1;
wire next_state_is_SEND_SNP2;
wire next_state_is_TERMINATE;


wire [\=nDveAgents-1=\:0] dest_aiu_vec;
wire [\=nDveAgents-1=\:0] dest_aiu_vec_sel;
wire dest_aiu_vec_is_zero;
wire dest_aiu_vec_is_last;
wire update_dest_aiu_vec;
wire update_snpreq_counter;
wire update_snprsp_counter;

\js for(var i=0; i < nDveAgents; i++) {
wire dvm_aiu_bit\=i=\;
\js }
wire [\=nDveAgents-1=\:0] dvm_aiu_bitvec;
wire [\=nDveAgents-1=\:0] dvm_aiu_bitvec_sig;
wire [\=nDveAgents-1=\:0] dvm_aiu_bitvec_en;
wire [\=nDveAgents-1=\:0] set_dvm_aiu_bitvec;
wire [\=nDveAgents-1=\:0] reset_dvm_aiu_bitvec;

wire [\=nDveAgents-1=\:0] src_aiuid_vec;

wire stt_sync_active;

wire credits_avail;
wire [\=nDveAgents-1=\:0] credits_avail_vec;
\js for(var i=0; i < nDveAgents; i++) {
wire [\=wDvmSnpCreditsCntr-1=\:0] credits_counter\=i=\;
wire [\=wDvmSnpCreditsCntr-1=\:0] credits_counter\=i=\_in;
\js }
wire [\=nDveAgents-1=\:0] credits_incr;
wire [\=nDveAgents-1=\:0] credits_decr;
wire [\=nDveAgents-1=\:0] credits_all_free;

wire dvm_snprsp_all_received;
wire [\=nDveAgents-1=\:0] dvm_snprsp_received;

wire cmp_issue_fifo__push0_valid;
wire cmp_issue_fifo__push0_ready;
wire [\=wCmpIssueFifo-1=\:0] cmp_issue_fifo__push0_data;
wire cmp_issue_fifo__push1_valid;
wire cmp_issue_fifo__push1_ready;
wire [\=wCmpIssueFifo-1=\:0] cmp_issue_fifo__push1_data;
wire [\=wCmpIssueFifo-1=\:0] cmp_issue_fifo__pop_data;
wire cmp_issue_fifo__pop_valid;
wire cmp_issue_fifo__pop_ready;

wire snprsp_stt_entry_valid;
wire snprsp_stt_entry_terminate;
wire [\=wDvmSnpCntr-1=\:0] snprsp_stt_entry_snprsp_counter;
wire [\=wDvmSnpCntr-1=\:0] snprsp_stt_entry_snprsp_counter_plus1;
wire [\=wDvmSnpCntr-1=\:0] snprsp_stt_entry_snpreq_counter;
wire snprsp_stt_entry_snpreq_pending;

wire [\=nSttEntries-1=\:0] stt_valid_vec;
wire [\=nSttEntries-1=\:0] stt_sync_active_vec;
wire [\=nSttEntries-1=\:0] stt_sync_active_vec_regular;
wire stt_valid;

wire [\=nDveAgents-1=\:0] csr_DvmSnoopDisable_ff;

wire dve_cmd_age_buffer__lookup_en;
wire nonsync_bypass_q, nonsync_bypass;
wire nonsync_bypass_in;
wire nonsync_bypass_en;

\jsbegin
//=============================================================================
// Command Skid Buffer Entries
// Data    Skid Buffer Entries
//=============================================================================
\jsend

\jsbegin
// Ncore3.2 always has a trace buffer
/* istanbul ignore else env ncore_3p2,ncore_3p4,ncore_3p6,ncore_3p7 */
    if (nMainTraceBufSize>0) { \jsend
wire dve_init_in_progress;
wire dvm_dbg_dtwreq_ready_pre;
assign dvm_dbg_dtwreq_ready = dvm_dbg_dtwreq_ready_pre & ~dve_init_in_progress;
wire dvm_dbg_dtwreq_valid_post = dvm_dbg_dtwreq_valid & ~dve_init_in_progress;
wire [7:0] dvm_dbg_dtwreq_cmstatus_new;
\js }
\jsbegin
    var skidBufferParams = {
        assertOn     : assertOn,
        wDvmReqAddr  : wDvmReqAddr,
        wDvmReqAttr  : wDvmReqAttr,
        wDvmReqAiuId : wDvmReqAiuId,
        wDvmReqMsgId : wDvmReqMsgId,
        wDvmReqQos   : wDvmReqQos,
        wDvmReqPriority : wDvmReqPriority,
        wDvmReqData  : wDvmReqData,
        nSkidEntries : nSkidEntries,
        wSkidEntries : wSkidEntries,
        wSttId       : wSttId,
        wTraceMe     : wTraceMe,
        nMainTraceBufSize : nMainTraceBufSize
    };
    var instance_ports_for_skidbuf = {
        clk                      : 'clk',
        reset_n                  : 'reset_n',
        csr_MaxOneSyncDVMOp      : 'csr_MaxOneSyncDVMOp',
        csr_AceDvmOrder          : 'csr_AceDvmOrder',
        stt_sync_active          : 'stt_sync_active',
        nonsync_bypass_in        : 'nonsync_bypass_in',
        flm_sttid_collision      : 'flm_sttid_collision',
        flm_sttid                : 'flm_sttid',
        dvm_cmdreq_valid         : 'dvm_cmdreq_valid',
        dvm_cmdreq_ready         : 'dvm_cmdreq_ready',
        dvm_cmdreq_cmstatus      : 'dvm_cmdreq_cmstatus',
        dvm_cmdreq_addr          : 'dvm_cmdreq_addr',
        dvm_cmdreq_attr          : 'dvm_cmdreq_attr',
        dvm_cmdreq_aiuid         : 'dvm_cmdreq_aiuid',
        dvm_cmdreq_msgid         : 'dvm_cmdreq_msgid',
        dvm_cmdrsp_valid         : 'dvm_cmdrsp_valid',
        dvm_cmdrsp_ready         : 'dvm_cmdrsp_ready',
        dvm_cmdrsp_aiuid         : 'dvm_cmdrsp_aiuid',
        dvm_cmdrsp_msgid         : 'dvm_cmdrsp_msgid',
        dvm_cmdrsp_cmstatus      : 'dvm_cmdrsp_cmstatus',
        dvm_dtwreq_valid         : 'dvm_dtwreq_valid',
        dvm_dtwreq_last          : 'dvm_dtwreq_last',
        dvm_dtwreq_ready         : 'dvm_dtwreq_ready',
        dvm_dtwreq_cmstatus      : 'dvm_dtwreq_cmstatus',
        dvm_dtwreq_rbid          : 'dvm_dtwreq_rbid',
        dvm_dtwreq_aiuid         : 'dvm_dtwreq_aiuid',
        dvm_dtwreq_msgid         : 'dvm_dtwreq_msgid',
        dvm_dtwreq_data          : 'dvm_dtwreq_data',
        dvm_dtwreq_dbad          : 'dvm_dtwreq_dbad',
        dvm_strreq_valid         : 'dvm_strreq_valid',
        dvm_strreq_ready         : 'dvm_strreq_ready',
        dvm_strreq_rbid          : 'dvm_strreq_rbid',
        dvm_strreq_sttid         : 'dvm_strreq_sttid',
        dvm_strreq_aiuid         : 'dvm_strreq_aiuid',
        dvm_strreq_msgid         : 'dvm_strreq_msgid',
        dvm_dtwrsp_valid         : 'dvm_dtwrsp_valid',
        dvm_dtwrsp_ready         : 'dvm_dtwrsp_ready',
        dvm_dtwrsp_aiuid         : 'dvm_dtwrsp_aiuid',
        dvm_dtwrsp_msgid         : 'dvm_dtwrsp_msgid',
        dvm_dtwrsp_cmstatus      : 'dvm_dtwrsp_cmstatus',
        dvm_dtwrsp_dbad          : 'dvm_dtwrsp_dbad',
        cmdreq_fifo__pop_valid   : 'cmdreq_fifo__pop_valid',
        cmdrsp_fifo__pop_valid   : 'cmdrsp_fifo__pop_valid',
        dtwrsp_fifo__pop_valid   : 'dtwrsp_fifo__pop_valid',
        strreq_fifo__pop_valid   : 'strreq_fifo__pop_valid',
        dve_cmd_age_buffer__lookup_en : 'dve_cmd_age_buffer__lookup_en',
        dtf_valid                : 'dtf_valid',
        dtf_ready                : 'dtf_ready',
        dtf_cmstatus             : 'dtf_cmstatus',
        dtf_addr                 : 'dtf_addr',
        dtf_attr                 : 'dtf_attr',
        dtf_aiuid                : 'dtf_aiuid',
        dtf_msgid                : 'dtf_msgid',
        dtf_rbid                 : 'dtf_rbid',
        dtf_sttid                : 'dtf_sttid',
        dtf_data                 : 'dtf_data',
        dtf_dbad                 : 'dtf_dbad'
    };
// Ncore3.2 always has a trace buffer
/* istanbul ignore else env ncore_3p2,ncore_3p4,ncore_3p6,ncore_3p7 */
    if (nMainTraceBufSize>0) {
      instance_ports_for_skidbuf['dtwrsp_dbg_fifo__pop_valid'] = 'dtwrsp_dbg_fifo__pop_valid';
      instance_ports_for_skidbuf['dvm_dbg_dtwreq_valid']    = 'dvm_dbg_dtwreq_valid_post';
      instance_ports_for_skidbuf['dvm_dbg_dtwreq_last']     = 'dvm_dbg_dtwreq_last';
      instance_ports_for_skidbuf['dvm_dbg_dtwreq_ready']    = 'dvm_dbg_dtwreq_ready_pre';
      instance_ports_for_skidbuf['dvm_dbg_dtwreq_cmstatus'] = 'dvm_dbg_dtwreq_cmstatus_new';
//    instance_ports_for_skidbuf['dvm_dbg_dtwreq_rbid']     = 'dvm_dbg_dtwreq_rbid';
      instance_ports_for_skidbuf['dvm_dbg_dtwreq_aiuid']    = 'dvm_dbg_dtwreq_aiuid';
      instance_ports_for_skidbuf['dvm_dbg_dtwreq_msgid']    = 'dvm_dbg_dtwreq_msgid';
      instance_ports_for_skidbuf['dvm_dbg_dtwrsp_valid']    = 'dvm_dbg_dtwrsp_valid';
      instance_ports_for_skidbuf['dvm_dbg_dtwrsp_ready']    = 'dvm_dbg_dtwrsp_ready';
      instance_ports_for_skidbuf['dvm_dbg_dtwrsp_aiuid']    = 'dvm_dbg_dtwrsp_aiuid';
      instance_ports_for_skidbuf['dvm_dbg_dtwrsp_msgid']    = 'dvm_dbg_dtwrsp_msgid';
      instance_ports_for_skidbuf['dvm_dbg_dtwrsp_cmstatus'] = 'dvm_dbg_dtwrsp_cmstatus';
      instance_ports_for_skidbuf['dvm_dbg_dtwrsp_dbad']     = 'dvm_dbg_dtwrsp_dbad';
      if ( wDvmReqPriority > 0 ) {
        instance_ports_for_skidbuf['dvm_dbg_dtwreq_priority'] = 'dvm_dbg_dtwreq_priority';
        instance_ports_for_skidbuf['dvm_dbg_dtwrsp_priority'] = 'dvm_dbg_dtwrsp_priority';
      }
    }
// Ncore3.2 always has a trace bit
/* istanbul ignore else env ncore_3p2,ncore_3p4,ncore_3p6,ncore_3p7 */
    if (wTraceMe > 0) {
        instance_ports_for_skidbuf['dvm_dtwreq_tm']         = 'dvm_dtwreq_tm';
        instance_ports_for_skidbuf['dvm_dtwrsp_tm']         = 'dvm_dtwrsp_tm';
        instance_ports_for_skidbuf['dvm_strreq_tm']         = 'dvm_strreq_tm';
        instance_ports_for_skidbuf['dvm_cmdrsp_tm']         = 'dvm_cmdrsp_tm';
    }
    if ( wDvmReqQos > 0 ) {
        instance_ports_for_skidbuf['dvm_cmdreq_qos']     = 'dvm_cmdreq_qos';
        instance_ports_for_skidbuf['dtf_qos']            = 'dtf_qos';
    }
    if ( wDvmReqPriority > 0 ) {
        instance_ports_for_skidbuf['dvm_cmdreq_priority'] = 'dvm_cmdreq_priority';
        instance_ports_for_skidbuf['dvm_cmdrsp_priority'] = 'dvm_cmdrsp_priority';
        instance_ports_for_skidbuf['dvm_strreq_priority'] = 'dvm_strreq_priority';
        instance_ports_for_skidbuf['dvm_dtwreq_priority'] = 'dvm_dtwreq_priority';
        instance_ports_for_skidbuf['dvm_dtwrsp_priority'] = 'dvm_dtwrsp_priority';
        instance_ports_for_skidbuf['dtf_priority']        = 'dtf_priority';
    }
\jsend
    \=obj.lib.instance({
        instanceName: 'skidbuf',
        moduleName: 'dve_skid_buffer',
        params : skidBufferParams,
        verilogParams: {},
        ports: instance_ports_for_skidbuf,
        portsDelimiter: '\n    '
    })=\

assign dvm_cmdrsp_sttid = \=wSttId=\'b0;

assign dtf_cmstatus_err = dtf_cmstatus[7];

\jsbegin
//=============================================================================
//  Free List Manager (FLM): Port 1 reserved for NonSync Bypass, Port 0 for everything else
//=============================================================================
\jsend

assign stt_index_flm__allocate0_ack = stt_init;

assign stt_index_flm__deallocate0_vld = csr_DeallocEarly ? dvm_cmp_valid & dvm_cmp_ready : dvm_strrsp_valid & dvm_strrsp_ready;

assign stt_index_flm__allocate0_vld = nonsync_bypass ? dve_flm__allocate1_vld & ~dtf_addr_sync_decode : dve_flm__allocate0_vld;

assign stt_index_flm__allocate0 = nonsync_bypass ? dve_flm__allocate1 : dve_flm__allocate0;

    \jsbegin
        var dve_flm_params = {
            num_entries               : nSttEntries
        };
        var instance_ports_for_dve_flm = {
            clk                             : 'clk',
            reset_n                         : 'reset_n',
            mask0                           : 'dve_flm__mask0',
            mask1                           : 'dve_flm__mask1',
            allocate0                       : 'dve_flm__allocate0',
            allocate0_vld                   : 'dve_flm__allocate0_vld',
            allocate0_ack                   : 'dve_flm__allocate0_ack',
            allocate1                       : 'dve_flm__allocate1',
            allocate1_vld                   : 'dve_flm__allocate1_vld',
            allocate1_ack                   : 'dve_flm__allocate1_ack',
            deallocate                      : 'dve_flm__deallocate',
            deallocate_vld                  : 'dve_flm__deallocate_vld'
        };
    \jsend
        \=obj.lib.instance({
            instanceName: 'u_dve_flm',
            moduleName: 'dve_flm',
            params: dve_flm_params,
            verilogParams: {},
            ports: instance_ports_for_dve_flm,
            portsDelimiter: '\n    '
        })=\

assign dve_flm__allocate0_ack = stt_index_flm__allocate0_ack & ~nonsync_bypass;
assign dve_flm__allocate1_ack = stt_index_flm__allocate0_ack & nonsync_bypass;

assign dve_flm__deallocate = stt_index_flm__deallocate0;
assign dve_flm__deallocate_vld = stt_index_flm__deallocate0_vld;


assign dvm_strrsp_ready = 1'b1;

\jsbegin
//=============================================================================
// Snoop Transaction Table Entries init vector
//=============================================================================
\jsend

assign stt_init_in = state_is_IDLE & ~next_state_is_IDLE;

\=u.dffre(1, 'stt_init', 'stt_init_in', "1'b0", 'dff_enable', 'clk', 'reset_n')=\

assign stt_init_vec = {\=nSttEntries=\{stt_init}} & stt_index_flm__allocate0;

assign stt_deinit_vec = {\=nSttEntries=\{stt_index_flm__deallocate0_vld}} & stt_index_flm__deallocate0;

assign stt_valid = {|{stt_valid_vec}};

wire [\=wSttEntries-1=\:0] pmon_active_stt_entries_in;
assign pmon_active_stt_entries_in = ((~stt_init & ~stt_index_flm__deallocate0_vld) ? dve_pmon_active_stt_entries                      : \=wSttEntries=\'b0) |
                                    ((~stt_init &  stt_index_flm__deallocate0_vld) ? dve_pmon_active_stt_entries - \=wSttEntries=\'b1 : \=wSttEntries=\'b0) |
                                    (( stt_init & ~stt_index_flm__deallocate0_vld) ? dve_pmon_active_stt_entries + \=wSttEntries=\'b1 : \=wSttEntries=\'b0) |
                                    (( stt_init &  stt_index_flm__deallocate0_vld) ? dve_pmon_active_stt_entries                      : \=wSttEntries=\'b0);
\=u.dffre(wSttEntries, 'dve_pmon_active_stt_entries', 'pmon_active_stt_entries_in', wSttEntries+"'b0", 'dff_enable', 'clk', 'reset_n')=\

\jsbegin
//=============================================================================
// Snoop Transaction Table
//=============================================================================
\jsend

\jsbegin
    var sttParams = {
        assertOn       : assertOn,
        wTraceMe       : wTraceMe,
        wDvmReqAddr    : wDvmReqAddr,
        wDvmReqAttr    : wDvmReqAttr,
        wDvmReqAiuId   : wDvmReqAiuId,
        wDvmReqMsgId   : wDvmReqMsgId,
        wDvmReqQos     : wDvmReqQos,
        wDvmReqPriority : wDvmReqPriority,
        wDvmReqData    : wDvmReqData,
        wDvmSnpCntr    : wDvmSnpCntr,
        nSttEntries    : nSttEntries,
        wSttId         : wSttId
    };
    var instance_ports_for_stt = {
        clk                             : 'clk',
        reset_n                         : 'reset_n',
        csr_DeallocEarly                : 'csr_DeallocEarly',
        flm_sttid_collision             : 'flm_sttid_collision',
        flm_sttid                       : 'flm_sttid',

        stt_init_vec                    : 'stt_init_vec',
        stt_deinit_vec                  : 'stt_deinit_vec',
        update_snpreq_counter           : 'update_snpreq_counter',
        update_snprsp_counter           : 'update_snprsp_counter',
        dvm_snprsp_cmstatus             : 'dvm_snprsp_cmstatus',

        dvm_snpreq_valid                : 'dvm_snpreq_valid',
        dvm_snpreq_sttid                : 'dvm_snpreq_sttid',
        dvm_snprsp_valid                : 'dvm_snprsp_valid',
        dvm_snprsp_sttid                : 'dvm_snprsp_sttid',
        dvm_cmp_valid                   : 'dvm_cmp_valid',
        dvm_cmp_sttid                   : 'dvm_cmp_sttid',
        dvm_strrsp_valid                : 'dvm_strrsp_valid',
        dvm_strrsp_sttid                : 'dvm_strrsp_sttid',
        stt_index_flm__deallocate0      : 'stt_index_flm__deallocate0',

        state_is_TERMINATE              : 'state_is_TERMINATE',
        dtf_ready                       : 'dtf_ready',
        dtf_addr_sync_decode            : 'dtf_addr_sync_decode',
        dtf_dbad                        : 'dtf_dbad',
        dtf_aiuid                       : 'dtf_aiuid',
        dtf_msgid                       : 'dtf_msgid',
        dtf_sttid                       : 'dtf_sttid',
        stt_valid_vec                   : 'stt_valid_vec',
        stt_sync_active_vec             : 'stt_sync_active_vec',
        snprsp_stt_entry_valid          : 'snprsp_stt_entry_valid',
        snprsp_stt_entry_terminate      : 'snprsp_stt_entry_terminate',
        snprsp_stt_entry_snprsp_counter : 'snprsp_stt_entry_snprsp_counter',
        snprsp_stt_entry_snpreq_counter : 'snprsp_stt_entry_snpreq_counter',
        snprsp_stt_entry_snpreq_pending : 'snprsp_stt_entry_snpreq_pending',
        dvm_cmp_aiuid                   : 'dvm_cmp_aiuid',
        dvm_cmp_msgid                   : 'dvm_cmp_msgid',
        dvm_cmp_cmstatus                : 'dvm_cmp_cmstatus'
    };

    if ( wDvmReqQos > 0 ) {
        instance_ports_for_stt['dtf_qos']       = 'dtf_qos';
    }
    if ( wDvmReqPriority > 0 ) {
        instance_ports_for_stt['dtf_priority']  = 'dtf_priority';
        instance_ports_for_stt['dvm_cmp_priority'] = 'dvm_cmp_priority';
    }
// Ncore3.2 always has a trace bit
/* istanbul ignore else env ncore_3p2,ncore_3p4,ncore_3p6,ncore_3p7 */
    if ( wTraceMe > 0) {
        instance_ports_for_stt['dvm_cmp_tm']    = 'dvm_cmp_tm';
        instance_ports_for_stt['dtf_tm']    = 'dtf_attr[7]';
    }

\jsend
    \=obj.lib.instance({
        instanceName: 'stt',
        moduleName: 'dve_stt',
        params : sttParams,
        verilogParams: {},
        ports: instance_ports_for_stt,
        portsDelimiter: '\n    '
    })=\

\jsbegin
//=============================================================================
// SnpReq
//
// DVE supports address width of 32,40,44,48    bits to satisfy ACE DVM.
// DVE supports address width of 44,45,46 to 52 bits to satisfy CHI DVM.
//=============================================================================
\jsend

assign dvm_snpreq_sttid  = dtf_sttid;

assign dvm_snpreq_cmstatus = dtf_cmstatus;

assign dvm_snpreq_addr[2:0]   = 3'b0;
assign dvm_snpreq_addr[3]     = state_is_SEND_SNP2 ? 1'b1            : 1'b0;
assign dvm_snpreq_addr[31:4]  = state_is_SEND_SNP2 ? dtf_data[31:4]  : dtf_addr[31:4];
\jsbegin
// Ncore3.2 always has an addresss width > 40 bits
/* istanbul ignore else env ncore_3p2,ncore_3p4,ncore_3p6,ncore_3p7 */
        if (wDvmReqAddr > 32) { \jsend
assign dvm_snpreq_addr[39:32] = state_is_SEND_SNP2 ? dtf_data[39:32] : dtf_addr[39:32];
    \js }
wire is_chi = (dtf_attr[10:8]==3'b001);
wire is_pici = (dtf_addr[13:11]==3'b010);
\jsbegin
// Ncore3.2 always has an addresss width > 40 bits
/* istanbul ignore else env ncore_3p2,ncore_3p4,ncore_3p6,ncore_3p7 */
        if (wDvmReqAddr > 40) { \jsend
assign dvm_snpreq_addr[43:40] = state_is_SEND_SNP2 ? dtf_data[43:40] : {dtf_data[46:44], dtf_addr[40]};
    \js }
    \js if (wDvmReqAddr > 44) {
assign dvm_snpreq_addr[44]    = state_is_SEND_SNP2 ? (is_pici ? dtf_data[44] : dtf_data[47]) : dtf_data[48];
    \js }
    \js if (wDvmReqAddr > 45) {
assign dvm_snpreq_addr[45]    = state_is_SEND_SNP2 ? (is_pici ? dtf_data[45] : dtf_data[49]) : dtf_data[50];
    \js }
    \js if (wDvmReqAddr > 46) {
assign dvm_snpreq_addr[47:46] = state_is_SEND_SNP2 ? dtf_data[47:46] : 2'b0;
    \js }
\jsbegin
// AMBA spec does not define dvms for address > 48 bits
/* istanbul ignore if env ncore_3p2,ncore_3p4,ncore_3p6,ncore_3p7 */
        if (wDvmReqAddr > 48) { \jsend
assign dvm_snpreq_addr[48]    = state_is_SEND_SNP2 ? dtf_data[48] : 1'b0;
    \js }
\jsbegin
// AMBA spec does not define dvms for address > 48 bits
/* istanbul ignore if env ncore_3p2,ncore_3p4,ncore_3p6,ncore_3p7 */
        if (wDvmReqAddr > 49) { \jsend
assign dvm_snpreq_addr[49]    = state_is_SEND_SNP2 ? dtf_data[49] : 1'b0;
    \js }
\jsbegin
// AMBA spec does not define dvms for address > 48 bits
/* istanbul ignore if env ncore_3p2,ncore_3p4,ncore_3p6,ncore_3p7 */
        if (wDvmReqAddr > 50) { \jsend
assign dvm_snpreq_addr[\=wDvmReqAddr-1=\:50] = \=wDvmReqAddr-50=\'b0;
    \js }

assign dvm_snpreq_mpf1 = state_is_SEND_SNP2 ? { 4'b0, is_chi ? 4'b0         : dtf_data[54:51] }                   : dtf_data[63:56];

assign dvm_snpreq_mpf3 = state_is_SEND_SNP2 ? { 2'b0, is_chi ? 
\jsbegin
/* istanbul ignore else env ncore_3p6,ncore_3p7 */
        if (wDvmReqAddr > 42) { \jsend
                                                               dtf_addr[42] 
    \js } else {
                                                               1'b0
    \js }
\jsbegin
/* istanbul ignore else envncore_3p6 */
        if (wDvmReqAddr > 41) { \jsend
                                                             : dtf_data[55], 
                                                               dtf_data[3:0], 1'b1 } : { 6'b0, dtf_addr[41], 1'b0 };
    \js } else {
                                                             : dtf_data[55], 
                                                               dtf_data[3:0], 1'b1 } : { 6'b0, 1'b0,         1'b0 };
    \js }

assign dvm_snpreq_attr    = dtf_attr;

assign dvm_snpreq_aiuid[\=wDvmReqAiuId-1=\:0] =
                       ({\=wDvmReqAiuId=\{dest_aiu_vec_sel[0]}} & dvm_aiu0_f_unit_id)
            \js for (var i = 1; i < nDveAgents; i++) {
                     | ({\=wDvmReqAiuId=\{dest_aiu_vec_sel[\=i=\]}} & dvm_aiu\=i=\_f_unit_id)
            \js }
                     ;
\js if ( wDvmReqQos > 0 ) {
assign dvm_snpreq_qos     = dtf_qos;
\js }

\js if ( wDvmReqPriority > 0 ) {
assign dvm_snpreq_priority = dtf_priority;
\js }

\jsbegin
//=============================================================================
// State Machine
// CONC-6962 : spec change: DVMSync should not be blocked by outstanding DVMSync
//=============================================================================
\jsend

always @(*)
case (state)
    IDLE : next_state = stt_index_flm__allocate0_vld & dtf_valid ? CHECK : IDLE;

    CHECK : next_state =
        dtf_valid & (dest_aiu_vec_is_zero  | dtf_dbad | dtf_cmstatus_err) ? TERMINATE :
        dtf_valid & (~dest_aiu_vec_is_zero & credits_avail)               ? SEND_SNP1 :
                                                                            CHECK ;

    SEND_SNP1 : next_state = (dvm_snpreq_ready) ? SEND_SNP2 : SEND_SNP1 ;

    SEND_SNP2:  next_state = (dvm_snpreq_ready) ? (dest_aiu_vec_is_last ? IDLE : SEND_SNP1) : SEND_SNP2 ;

    TERMINATE : next_state = cmp_issue_fifo__push1_ready ? IDLE : TERMINATE;

    default next_state = state;
endcase

\=u.dffre(3, 'state', 'next_state', "3'b0", 'dff_enable', 'clk', 'reset_n')=\

assign state_is_IDLE             = (state == IDLE);
assign state_is_CHECK            = (state == CHECK);
assign state_is_SEND_SNP1        = (state == SEND_SNP1);
assign state_is_SEND_SNP2        = (state == SEND_SNP2);
assign state_is_TERMINATE        = (state == TERMINATE);

assign next_state_is_IDLE        = (next_state == IDLE);
assign next_state_is_CHECK       = (next_state == CHECK);
assign next_state_is_SEND_SNP1   = (next_state == SEND_SNP1);
assign next_state_is_SEND_SNP2   = (next_state == SEND_SNP2);
assign next_state_is_TERMINATE   = (next_state == TERMINATE);

assign dtf_addr_sync_decode      = (dtf_addr[13:11] == DVM_OPCODE_SYNC);
assign stt_sync_active           = {|{stt_sync_active_vec}};

\jsbegin
//=============================================================================
// NonSync Bypass when regular STT entries are in use by SYNC DVMOp
//=============================================================================
\jsend

assign dve_cmd_age_buffer__lookup_en = nonsync_bypass & state_is_IDLE;

\=u.dffre(1, 'nonsync_bypass_q', 'nonsync_bypass_in', "1'b0", 'nonsync_bypass_en', 'clk', 'reset_n')=\
assign nonsync_bypass = csr_MaxOneSyncDVMOp ? (nonsync_bypass_q | stt_sync_active) : (nonsync_bypass_q | nonsync_bypass_in);
assign nonsync_bypass_en = (next_state_is_IDLE & ~state_is_IDLE) | (nonsync_bypass & ~nonsync_bypass_in);
assign nonsync_bypass_in = csr_MaxOneSyncDVMOp ? stt_sync_active_vec_regular[0] : {&{stt_sync_active_vec_regular[\=nSttEntries-2=\:0]}};

assign stt_sync_active_vec_regular = stt_valid_vec & stt_sync_active_vec & dve_flm__mask0;

\jsbegin
//=============================================================================
// State Machine Actions
//=============================================================================
\jsend

assign dvm_snpreq_valid = state_is_SEND_SNP1 | state_is_SEND_SNP2;

assign update_dest_aiu_vec = dvm_snpreq_valid & dvm_snpreq_ready & state_is_SEND_SNP2;

assign update_snpreq_counter = dvm_snpreq_valid & dvm_snpreq_ready & state_is_SEND_SNP2;

assign dtf_ready = (state_is_SEND_SNP2 & next_state_is_IDLE)
                 | (state_is_TERMINATE & next_state_is_IDLE);

assign cmp_issue_fifo__push1_valid = state_is_TERMINATE;
assign cmp_issue_fifo__push1_data  = dtf_sttid;

\jsbegin
//=============================================================================
// dest_aiu_vec_is_zero
// dest_aiu_vec_is_last
// dest_aiu_vec_sel
//=============================================================================
\jsend

assign dest_aiu_vec_is_zero = ~{|{dest_aiu_vec}};
assign dest_aiu_vec_is_last = (dest_aiu_vec_sel == dest_aiu_vec) & ~dest_aiu_vec_is_zero;

    \=obj.lib.instance({
        instanceName: 'u_dest_aiu_vec_sel',
        moduleName: 'find_first_one',
        params: { width : nDveAgents },
        verilogParams: { WIDTH : nDveAgents },
        ports: {
            invec : 'dest_aiu_vec', outvec : 'dest_aiu_vec_sel'
        }
    })=\

\jsbegin
//=============================================================================
// dest_aiu_vec
//=============================================================================
\jsend

assign dest_aiu_vec = dvm_aiu_bitvec & ~src_aiuid_vec & ~csr_DvmSnoopDisable_ff;

\js for(var i=0; i < nDveAgents; i++) {

\=u.dffre(1, 'dvm_aiu_bit'+i, 'dvm_aiu_bitvec_sig['+i+']', "1'b1", 'dvm_aiu_bitvec_en['+i+']', 'clk', 'reset_n')=\

assign dvm_aiu_bitvec[\=i=\] = dvm_aiu_bit\=i=\;

\js }

assign set_dvm_aiu_bitvec = {\=nDveAgents=\{next_state_is_IDLE}};

assign reset_dvm_aiu_bitvec = {\=nDveAgents=\{update_dest_aiu_vec}} & dest_aiu_vec_sel;

assign dvm_aiu_bitvec_en = set_dvm_aiu_bitvec | reset_dvm_aiu_bitvec;

assign dvm_aiu_bitvec_sig = set_dvm_aiu_bitvec;

\jsbegin
//=============================================================================
// src_aiuid_vec
//=============================================================================
\jsend
    \js for(var i=0; i < nDveAgents; i++) {
assign src_aiuid_vec[\=i=\] = (dtf_aiuid == dvm_aiu\=i=\_f_unit_id) ? 1'b1 : 1'b0;
    \js }

\jsbegin
//=============================================================================
// agents_inactive_vec for SysCo
//=============================================================================
\jsend

assign agents_inactive_vec = state_is_IDLE ? credits_all_free : (credits_all_free & ~dest_aiu_vec);

\jsbegin
//=============================================================================
// Snoop Credits Counter (incremented by one per snoop request broadcast, decremented by one when all snoop responses received)
//=============================================================================
\jsend

    \js for(var i=0; i < nDveAgents; i++) {

\jsbegin
// Ncore3.2 always has more than one dve agent
/* istanbul ignore if env ncore_3p2,ncore_3p4,ncore_3p6,ncore_3p7 */
    if (nDveAgents==1) { \jsend
assign credits_all_free
\js } else {
assign credits_all_free[\=i=\] 
\js }
                               = (credits_counter\=i=\ == \=wDvmSnpCreditsCntr=\'d\=nDvmSnpCreditsAll=\);

assign credits_avail_vec[\=i=\] = |{credits_counter\=i=\};

\=u.dffre(wDvmSnpCreditsCntr, 'credits_counter'+i, 'credits_counter'+i+'_in', wDvmSnpCreditsCntr+"'d"+nDvmSnpCreditsAll, 'dff_enable', 'clk', 'reset_n')=\

assign credits_counter\=i=\_in = ( credits_incr[\=i=\] & ~credits_decr[\=i=\]) ? credits_counter\=i=\ + \=wDvmSnpCreditsCntr=\'b1 :
                                 (~credits_incr[\=i=\] &  credits_decr[\=i=\]) ? credits_counter\=i=\ - \=wDvmSnpCreditsCntr=\'b1 :
                                                                  credits_counter\=i=\;

assign credits_decr[\=i=\] = dvm_snpreq_valid & dvm_snpreq_ready & dest_aiu_vec_sel[\=i=\] & state_is_SEND_SNP2 & (next_state_is_IDLE | next_state_is_SEND_SNP1);

assign credits_incr[\=i=\] = (dvm_snprsp_aiuid == dvm_aiu\=i=\_f_unit_id) & update_snprsp_counter;
    \js }

assign credits_avail = &credits_avail_vec;

\jsbegin
//=============================================================================
// Snoop Response Processing
//=============================================================================
\jsend

assign dvm_snprsp_ready = cmp_issue_fifo__push0_ready;

assign update_snprsp_counter = dvm_snprsp_valid & dvm_snprsp_ready;

assign dvm_snprsp_all_received = update_snprsp_counter & snprsp_stt_entry_valid & ~snprsp_stt_entry_snpreq_pending
                               & (snprsp_stt_entry_snprsp_counter_plus1 == snprsp_stt_entry_snpreq_counter);

assign cmp_issue_fifo__push0_valid = dvm_snprsp_all_received;

assign cmp_issue_fifo__push0_data = dvm_snprsp_sttid;


assign snprsp_stt_entry_snprsp_counter_plus1 = snprsp_stt_entry_snprsp_counter + \=wDvmSnpCntr=\'h1;

\jsbegin
//=============================================================================
// DVM Completion
//=============================================================================
\jsend

\jsbegin
    var cmpIssueFifoParams = {
        width       : wCmpIssueFifo,
        depth       : nSttEntries,
        use_fastread: 0,
        number_of_inputs : 2
    };
    var instance_ports_for_cmp_issue_fifo = {
        clk                 : 'clk',
        reset_n             : 'reset_n',
        push0_data          : 'cmp_issue_fifo__push0_data',
        push0_valid         : 'cmp_issue_fifo__push0_valid',
        push0_ready         : 'cmp_issue_fifo__push0_ready',
        push1_data          : 'cmp_issue_fifo__push1_data',
        push1_valid         : 'cmp_issue_fifo__push1_valid',
        push1_ready         : 'cmp_issue_fifo__push1_ready',
        pop_data            : 'cmp_issue_fifo__pop_data',
        pop_valid           : 'cmp_issue_fifo__pop_valid',
        pop_ready           : 'cmp_issue_fifo__pop_ready'
    };
\jsend
    \=obj.lib.instance({
        instanceName: 'cmp_issue_fifo',
        moduleName: 'multiport_fifo',
        params : cmpIssueFifoParams,
        verilogParams: {},
        ports: instance_ports_for_cmp_issue_fifo,
        portsDelimiter: '\n    '
    })=\

assign dvm_cmp_valid = cmp_issue_fifo__pop_valid;

assign cmp_issue_fifo__pop_ready = dvm_cmp_ready;

assign dvm_cmp_sttid = cmp_issue_fifo__pop_data;

\jsbegin
//=============================================================================
// CSR DVM Snoop Disable
//=============================================================================
\jsend

\=u.dffre(nDveAgents, 'csr_DvmSnoopDisable_ff', 'csr_DvmSnoopDisable', '{'+nDveAgents+"{1'b0}}", 'next_state_is_IDLE', 'clk', 'reset_n')=\

\jsbegin
//=============================================================================
// CSR DVM Transaction Active
//=============================================================================
\jsend

assign csr_DvmTransActive = cmdreq_fifo__pop_valid
                          | cmdrsp_fifo__pop_valid
                          | dtwrsp_fifo__pop_valid
\jsbegin
// Ncore3.2 always has a trace buffer
/* istanbul ignore else env ncore_3p2,ncore_3p4,ncore_3p6,ncore_3p7 */
    if (nMainTraceBufSize>0) { \jsend
                          | dtwrsp_dbg_fifo__pop_valid
\js }
                          | strreq_fifo__pop_valid
                          | cmp_issue_fifo__pop_valid
                          | dtf_valid
                          | stt_valid
                          ;

\jsbegin
// Ncore3.2 always has a trace buffer
/* istanbul ignore else env ncore_3p2,ncore_3p4,ncore_3p6,ncore_3p7 */
    if (nMainTraceBufSize>0) { \jsend
\jsbegin
//=============================================================================
// Debug/Trace Accumulation
//=============================================================================
\jsend

wire dvm_dbg_dtwreq_valid_last;
wire dvm_dbg_dtwreq_ready_last;
wire dvm_dbg_dtwreq_last_last;
wire [\=wDvmReqAiuId-1=\:0] dvm_dbg_dtwreq_aiuid_last;
wire [\=wDvmReqData-1=\:0]  dvm_dbg_dtwreq_data_last;

\=u.dffre(1, 'dvm_dbg_dtwreq_valid_last', 'dvm_dbg_dtwreq_valid_post', "1'b0", 'dff_enable', 'clk', 'reset_n')=\
\=u.dffre(1, 'dvm_dbg_dtwreq_ready_last', 'dvm_dbg_dtwreq_ready', "1'b0", 'dff_enable', 'clk', 'reset_n')=\
\=u.dffre(1, 'dvm_dbg_dtwreq_last_last', 'dvm_dbg_dtwreq_last', "1'b0", 'dff_enable', 'clk', 'reset_n')=\
\=u.dffre(wDvmReqAiuId, 'dvm_dbg_dtwreq_aiuid_last', 'dvm_dbg_dtwreq_aiuid', wDvmReqAiuId+"'b0", 'dff_enable', 'clk', 'reset_n')=\
\=u.dffre(wDvmReqData, 'dvm_dbg_dtwreq_data_last', 'dvm_dbg_dtwreq_data', wDvmReqData+"'b0", 'dff_enable', 'clk', 'reset_n')=\

    \jsbegin
        var dve_trace_accumulator_params = {
            assertOn                        : assertOn,
            memErrType                      : memErrType,
            memErrWidth                     : memErrWidth,
            nMainTraceBufSize               : nMainTraceBufSize,
            nTraceBanks                     : nTraceBanks,
            wDvmReqAiuId                    : wDvmReqAiuId,
            wDvmReqData                     : wDvmReqData
        };
        var instance_ports_for_dve_trace_accumulator = {
            clk                             : 'clk',
            reset_n                         : 'reset_n',
            ungated_clk                     : 'ungated_clk',
            ungated_reset_n                 : 'ungated_reset_n',
            dvm_dtwreq_valid                : 'dvm_dbg_dtwreq_valid_last',
            dvm_dtwreq_ready                : 'dvm_dbg_dtwreq_ready_last',
            dvm_dtwreq_last                 : 'dvm_dbg_dtwreq_last_last',
            dvm_dtwreq_aiuid                : 'dvm_dbg_dtwreq_aiuid_last',
            dvm_dtwreq_data                 : 'dvm_dbg_dtwreq_data_last',
            dvm_dtwreq_cmstatus_new         : 'dvm_dbg_dtwreq_cmstatus_new',
            csr_DVETASCR_BufferIsCircular   : 'csr_DVETASCR_BufferIsCircular',
            csr_DVETASCR_BufferClear        : 'csr_DVETASCR_BufferClear',
            csr_DVETASCR_BufferRead         : 'csr_DVETASCR_BufferRead',
            dve_init_in_progress            : 'dve_init_in_progress',
            dve_trace_hdr_ecc_sb_error      : 'dve_trace_hdr_ecc_sb_error',
            dve_trace_hdr_ecc_db_error      : 'dve_trace_hdr_ecc_db_error',
            dve_trace_hdr_ecc_addr          : 'dve_trace_hdr_ecc_addr',
            dve_trace_data_ecc_sb_error     : 'dve_trace_data_ecc_sb_error',
            dve_trace_data_ecc_db_error     : 'dve_trace_data_ecc_db_error',
            dve_trace_data_ecc_addr         : 'dve_trace_data_ecc_addr',
            dve_trace_buffer_empty          : 'dve_trace_buffer_empty',
            dve_trace_buffer_full           : 'dve_trace_buffer_full',
            dve_trace_funit_id              : 'dve_trace_funit_id',
            dve_trace_read_data_valid       : 'dve_trace_read_data_valid',
            dve_trace_timestamp             : 'dve_trace_timestamp',
            dve_trace_busy                  : 'dve_trace_busy',
            dve_trace_packets_dropped       : 'dve_pmon_trace_packets_dropped',
            dve_trace_packets_accepted      : 'dve_pmon_trace_packets_accepted',
            dve_trace_capture_data_valid0   : 'dve_trace_capture_data_valid0',
            dve_trace_capture_data_valid1   : 'dve_trace_capture_data_valid1',
            dve_trace_capture_data_valid2   : 'dve_trace_capture_data_valid2',
            dve_trace_capture_data_valid3   : 'dve_trace_capture_data_valid3',
            dve_trace_capture_data_valid4   : 'dve_trace_capture_data_valid4',
            dve_trace_capture_data_valid5   : 'dve_trace_capture_data_valid5',
            dve_trace_capture_data_valid6   : 'dve_trace_capture_data_valid6',
            dve_trace_capture_data_valid7   : 'dve_trace_capture_data_valid7',
            dve_trace_capture_data_valid8   : 'dve_trace_capture_data_valid8',
            dve_trace_capture_data_valid9   : 'dve_trace_capture_data_valid9',
            dve_trace_capture_data_valid10  : 'dve_trace_capture_data_valid10',
            dve_trace_capture_data_valid11  : 'dve_trace_capture_data_valid11',
            dve_trace_capture_data_valid12  : 'dve_trace_capture_data_valid12',
            dve_trace_capture_data_valid13  : 'dve_trace_capture_data_valid13',
            dve_trace_capture_data_valid14  : 'dve_trace_capture_data_valid14',
            dve_trace_capture_data_valid15  : 'dve_trace_capture_data_valid15',
            dve_trace_capture_data0         : 'dve_trace_capture_data0',
            dve_trace_capture_data1         : 'dve_trace_capture_data1',
            dve_trace_capture_data2         : 'dve_trace_capture_data2',
            dve_trace_capture_data3         : 'dve_trace_capture_data3',
            dve_trace_capture_data4         : 'dve_trace_capture_data4',
            dve_trace_capture_data5         : 'dve_trace_capture_data5',
            dve_trace_capture_data6         : 'dve_trace_capture_data6',
            dve_trace_capture_data7         : 'dve_trace_capture_data7',
            dve_trace_capture_data8         : 'dve_trace_capture_data8',
            dve_trace_capture_data9         : 'dve_trace_capture_data9',
            dve_trace_capture_data10        : 'dve_trace_capture_data10',
            dve_trace_capture_data11        : 'dve_trace_capture_data11',
            dve_trace_capture_data12        : 'dve_trace_capture_data12',
            dve_trace_capture_data13        : 'dve_trace_capture_data13',
            dve_trace_capture_data14        : 'dve_trace_capture_data14',
            dve_trace_capture_data15        : 'dve_trace_capture_data15'
        };
        instance_ports_for_dve_trace_accumulator['f_wen_hdr']    = 'f_wen_hdr';
        instance_ports_for_dve_trace_accumulator['f_cen_hdr']    = 'f_cen_hdr';
        instance_ports_for_dve_trace_accumulator['f_caddr_hdr']  = 'f_caddr_hdr';
        instance_ports_for_dve_trace_accumulator['f_wdata_hdr']  = 'f_wdata_hdr';
        instance_ports_for_dve_trace_accumulator['f_rdata_hdr']  = 'f_rdata_hdr';
        instance_ports_for_dve_trace_accumulator['f_wen_data']   = 'f_wen_data';
        instance_ports_for_dve_trace_accumulator['f_cen_data']   = 'f_cen_data';
        instance_ports_for_dve_trace_accumulator['f_caddr_data'] = 'f_caddr_data';
        instance_ports_for_dve_trace_accumulator['f_wdata_data'] = 'f_wdata_data';
        instance_ports_for_dve_trace_accumulator['f_rdata_data'] = 'f_rdata_data';

    \jsend
        \=obj.lib.instance({
            instanceName: 'u_dve_trace_accumulator',
            moduleName: 'dve_trace_accumulator',
            params: dve_trace_accumulator_params,
            verilogParams: {},
            ports: instance_ports_for_dve_trace_accumulator,
            portsDelimiter: '\n    '
        })=\
\js }

endmodule
