\jsbegin
//=============================================================================
// Copyright(C) 2018 Arteris, Inc.
// All rights reserved
//=============================================================================
// Trace Capture
//
// Author: Jason Villanueva
//
// Descriptions:
// 
// The trace capture block is responsible for snooping the unit's SMI i/f, 
//  and if enabled by CSR will look at the concerto TraceMe field to decide
//  if the message will be captured along with a timestamp. 
// Captured SMI messages are then packed into a 64 Byte data structure and 
//  sent out as a Concerto DTW DBG Request Message. 
//
// The Trace Capture has the following transaction flow:
// Request in -> will generate DTW DBG request to DVE (Trace Accumulator)
//            -> receive DTW DBg response from DVE.
//=============================================================================
\jsend

\jsbegin
const u							= obj.lib;
const libUtils					= obj.userLib;
const bundleFunctions			= obj.userLib.bundleFunctions;

var log2ceil = function(n) { return Math.ceil(Math.log(n)/Math.LN2); };
//=============================================================================
// Default Parameter Declarations
//=============================================================================
u.paramDefault('usePipe', 'int', 1);
u.paramDefault('useDtwDbgPipe', 'int', 1);
u.paramDefault('nNDN', 'int', 3);
u.paramDefault('nDN', 'int', 1);
u.paramDefault('nAccums', 'int', 3);
u.paramDefault('smiFifoDepth', 'int', 4);
u.paramDefault('wTimestamp', 'int', 32);
u.paramDefault('accum_size_bits', 'int', 512);
u.paramDefault('nUnitTraceBufSize', 'int', 8);
u.paramDefault('wForceAccumTimeout', 'int', 10);
u.paramDefault('smiTxPortInterfaces','array',[]);
u.paramDefault('smiRxPortInterfaces','array',[]);
u.paramDefault('DTWReqInterface','object',null);
u.paramDefault('DTWRespInterface','object',null);
u.paramDefault('traceRegInterface','object',null);
u.paramDefault('interfaces','object',null);

//=============================================================================
// Parameters
//=============================================================================
// Read all block parameters
const usePipe               = libUtils.hierGetParam('usePipe', u.getParam);
const useDtwDbgPipe         = libUtils.hierGetParam('useDtwDbgPipe', u.getParam);
const smiRxPortInterfaces	= libUtils.hierGetParam('smiRxPortInterfaces', u.getParam);
const smiTxPortInterfaces	= libUtils.hierGetParam('smiTxPortInterfaces', u.getParam);
const nNDN		            = libUtils.hierGetParam('nNDN', u.getParam);
const nDN			        = libUtils.hierGetParam('nDN', u.getParam);
const nAccums			    = libUtils.hierGetParam('nAccums', u.getParam);
const smiFifoDepth			= libUtils.hierGetParam('smiFifoDepth', u.getParam);
const wTimestamp			= libUtils.hierGetParam('wTimestamp', u.getParam);
const accum_size_bits		= libUtils.hierGetParam('accum_size_bits', u.getParam);
const nUnitTraceBufSize		= libUtils.hierGetParam('nUnitTraceBufSize', u.getParam);
const wForceAccumTimeout	= libUtils.hierGetParam('wForceAccumTimeout', u.getParam);
const assertOn  			= libUtils.hierGetParam('assertOn', u.getParam);
const DTWReqInterface		= libUtils.hierGetParam('DTWReqInterface', u.getParam);
const DTWRespInterface		= libUtils.hierGetParam('DTWRespInterface', u.getParam);
const traceRegInterface		= libUtils.hierGetParam('traceRegInterface', u.getParam);
const wFUnitId		        = libUtils.hierGetParam('wFUnitId', u.getParam);
const wFPortId		        = libUtils.hierGetParam('wFPortId', u.getParam);
const cmType		        = libUtils.hierGetParam('cmType', u.getParam);
const interfaces			= libUtils.hierGetParam('interfaces', u.getParam);

const excludes			= ['valid','ready','last','data','cm_type','message_id','target_id','initiator_id','rl'];
//Set keys to only those not excluded & non-zero widths
const dtw_req_keys		= Object.keys(DTWReqInterface).filter(signal => !excludes.includes(signal) && DTWReqInterface[signal]);
const dtw_req_all_keys	= Object.keys(DTWReqInterface).filter(signal => DTWReqInterface[signal] && (signal!='valid') && (signal!='ready'));
const dtw_rsp_keys		= Object.keys(DTWRespInterface).filter(signal => !excludes.includes(signal) && DTWRespInterface[signal]);
const wDtwDbgReq        = libUtils.bundleFunctions.getBundleWidth(DTWReqInterface, ['valid', 'ready'], u.bundle);
const wDtwDbgResp       = libUtils.bundleFunctions.getBundleWidth(DTWRespInterface, ['valid', 'ready'], u.bundle);
const wTSGain = traceRegInterface.signals.CCTRLR_gain_out;
const wTSInc = traceRegInterface.signals.CCTRLR_inc_out;
//Product width is cm_status[6:0]xGAIN
const wTSProd = wTSGain+7; 

const wnUnitTraceBufSize = log2ceil(nUnitTraceBufSize);
const wTraceBufCntr = wnUnitTraceBufSize+1;
const total_smi_ports_num = (nNDN + nDN)*2;
const wTotalSmiPortsNum = log2ceil(total_smi_ports_num+1);
const wDTWData = DTWReqInterface['data'];
const wAccumSizebits = log2ceil(accum_size_bits);
const accum_size_bytes = accum_size_bits/8;
const wAccumSizeBytes = log2ceil(accum_size_bytes);
const maxDtwBeats = Math.trunc(accum_size_bits/wDTWData);
// Ncore currently does not have dtw dbg data width==512bits, max=256
const wMaxDtwBeats = (log2ceil(maxDtwBeats)==0) ? /* istanbul ignore next env ncore_3p2, ncore_3p4,ncore_3p6, ncore_3p7 */ 1 : log2ceil(maxDtwBeats);
const accum_min_size_write_bits = 8; 
const wAccum_ptr = log2ceil(Math.ceil(accum_size_bits/accum_min_size_write_bits)+1); 
const wPipeFifoAccums = accum_size_bits+wAccum_ptr;
const wMsgId = DTWReqInterface['message_id']; 
//console.log("TRACE_CAPTURE:traceRegInterface = \n"+JSON.stringify(traceRegInterface,null,8));
//=============================================================================
// Interface Declarations
//=============================================================================
u.nInterfaces(interfaces);
\jsend

//=============================================================================
// Ports
//=============================================================================
\jsbegin
// FUnitId interface
u.port('input', 'MyId', wFUnitId);
u.port('input', 'TargId', wFUnitId);
u.port('output', 'trace_capture_busy', 1);
u.port('output', 'pm_trace_messages_dropped', wTotalSmiPortsNum);
u.port('output', 'pm_trace_messages_captured', wTotalSmiPortsNum);

u.interface('dtw_req_', 'master',   u.getParam('DTWReqInterface'));
u.interface('dtw_resp_','slave',    u.getParam('DTWRespInterface'));

u.interface(traceRegInterface.name,'slave', traceRegInterface.signals);

for (let i=0; i<smiTxPortInterfaces.length; i++) { 
    libUtils.forceSlavePortsFromInterface(smiTxPortInterfaces[i].name, smiTxPortInterfaces[i].signals, u.port);
    if(smiTxPortInterfaces[i].params.dpPresent) {
    libUtils.defineSlavePortsFromInterface(smiTxPortInterfaces[i].name, smiTxPortInterfaces[i].dpSignals, u.port, 'dp_ready');    
    }
}
for (let i=0; i<smiRxPortInterfaces.length; i++) {
    libUtils.forceSlavePortsFromInterface(smiRxPortInterfaces[i].name, smiRxPortInterfaces[i].signals, u.port);
    if(smiRxPortInterfaces[i].params.dpPresent) {
    libUtils.defineSlavePortsFromInterface(smiRxPortInterfaces[i].name, smiRxPortInterfaces[i].dpSignals, u.port, 'dp_ready');    
    }
}
\jsend

module \=u.getModuleName()=\ (\=u.getPorts('\n')=\);
//=============================================================================
// Local Parameters
//=============================================================================
localparam DTW_TRACE_REQ  = \=cmType['DtwDbg']=\;      
localparam DTW_TRACE_RESP = \=cmType['DtwDbgRsp']=\;   
localparam TM_BIT = 0; 

//=============================================================================
// Wires
//=============================================================================
\=bundleFunctions.wiresFromInterface('dtw_req_int_', DTWReqInterface, [], obj.lib.bundle)=\
\=bundleFunctions.wiresFromInterface('dtw_resp_int_', DTWRespInterface, [], obj.lib.bundle)=\
\jsbegin
/* istanbul ignore else env ncore_3p4,ncore_3p6, ncore_3p7 */
if (useDtwDbgPipe){ \jsend
wire [\=wDtwDbgReq-1=\:0]           dtw_req_int_pkt; 
wire [\=wDtwDbgReq-1=\:0]           dtw_req_pkt; 
wire [\=wDtwDbgResp-1=\:0]          dtw_resp_int_pkt; 
wire [\=wDtwDbgResp-1=\:0]          dtw_resp_pkt; 
\jsbegin
} \jsend
wire                                trace_capture_dtw_dbg_request_sent; 
wire [\=total_smi_ports_num-1=\:0]  trace_capture_smi_msg_dropped_vec; 
wire [\=total_smi_ports_num-1=\:0]  trace_capture_smi_msg_captured_vec; 
wire [\=wTotalSmiPortsNum-1=\:0]  trace_capture_event_msg_dropped; 
wire [\=wTotalSmiPortsNum-1=\:0]  trace_capture_event_msg_captured; 

wire                        dtw_beat_counter_en;
wire                        dtw_beat_counter_last;
wire                        dtw_beat_counter_clr;
wire [\=wMaxDtwBeats-1=\:0] dtw_beat_counter;
wire [\=wMaxDtwBeats-1=\:0] dtw_beat_counter_in;
\jsbegin
for (let i=0; i<nAccums;i++) { \jsend
wire [\=wForceAccumTimeout+1-1=\:0] force_accum_\=i=\_counter;
wire [\=wForceAccumTimeout+1-1=\:0] force_accum_\=i=\_counter_in;
wire                                force_accum_\=i=\_counter_clr;
wire                                force_accum_\=i=\_counter_expired;
wire                                force_accum_\=i=\_counter_en;
\jsbegin
} \jsend
wire                  messageId_flm_en;
wire [\=wMsgId-1=\:0] messageId_flm;
wire [\=wMsgId-1=\:0] messageId_flm_in;

wire [\=wTimestamp-1=\:0] capture_frc;
wire [\=wTimestamp-1=\:0] capture_frc_in;
wire        capture_frc_en; 
wire        capture_frc_upd; 

\jsbegin
for (let i=0; i<nAccums;i++) { \jsend
wire                           accumulator_\=i=\_in_valid; 
wire                           accumulator_\=i=\_in_restart; 
wire [\=wAccum_ptr-1=\:0]      accumulator_\=i=\_in_size;
wire [\=accum_size_bits-1=\:0] accumulator_\=i=\_in_data;
wire                           accumulator_\=i=\_out_valid; 
wire [\=wAccum_ptr-1=\:0]      accumulator_\=i=\_out_size;
wire [\=wAccum_ptr-1=\:0]      accumulator_\=i=\_out_size_int;
wire [\=accum_size_bits-1=\:0] accumulator_\=i=\_out_data;

wire                           accumulator_\=i=\_msg_fit; 
wire                           accumulator_\=i=\_new_msg_push; 
wire                           accumulator_\=i=\_push; 
wire                           accumulator_\=i=\_full; 
wire [\=wAccum_ptr=\:0]        accumulator_\=i=\_remaining;

wire                           pipe_fifo_accum_\=i=\_in_ready; 
wire [\=wPipeFifoAccums-1=\:0] pipe_fifo_accum_\=i=\_in_bus; 
wire [\=accum_size_bits-1=\:0] pipe_fifo_accum_\=i=\_in_data; 
wire [\=wAccum_ptr-1=\:0]      pipe_fifo_accum_\=i=\_in_size; 
wire                           pipe_fifo_accum_\=i=\_out_valid; 
wire [\=wPipeFifoAccums-1=\:0] pipe_fifo_accum_\=i=\_out_bus; 
wire [\=accum_size_bits-1=\:0] pipe_fifo_accum_\=i=\_out_data; 
wire [\=wAccum_ptr-1=\:0]      pipe_fifo_accum_\=i=\_out_size; 
wire                           pipe_fifo_accum_\=i=\_out_ready; 
\jsbegin
} \jsend
wire                             trace_capture_buffer_in_valid; 
wire                             trace_capture_buffer_in_ready; 
wire                             trace_capture_buffer_out_valid; 
wire                             trace_capture_buffer_out_ready; 
wire [\=accum_size_bits-1=\:0]   trace_capture_buffer_data_in;
wire [\=accum_size_bits-1=\:0]   trace_capture_buffer_data_out;
wire                             trace_capture_buffer_full;

wire                              trace_capture_buffer_counter_en;
wire                              trace_capture_buffer_counter_inc;
wire                              trace_capture_buffer_counter_dec;
wire [\=wTraceBufCntr-1=\:0] trace_capture_buffer_counter;
wire [\=wTraceBufCntr-1=\:0] trace_capture_buffer_counter_in;

wire                           trace_capture_request_valid; 
wire [\=total_smi_ports_num-1=\:0]  trace_capture_arb_req; 

wire [\=total_smi_ports_num-1=\:0]  fifo_accumulator_ready; 
wire [\=total_smi_ports_num-1=\:0]  fifo_accumulator_arb_gnt; 

wire                                accumulator_daisy_grant_valid; 
\jsbegin
for (let i=0; i<nAccums;i++) { \jsend
wire [\=total_smi_ports_num-1=\:0]  accumulator_\=i=\_daisy_gnt; 
wire                                accumulator_\=i=\_grant_valid; 
\jsbegin
}
// Number of accumulators set to 3 for ncore32
/* istanbul ignore else env ncore_3p2, ncore_3p4,ncore_3p6, ncore_3p7 */
if (nAccums>1) { \jsend
wire [\=nAccums-1=\:0]  accumulator_arb_req; 
wire [\=nAccums-1=\:0]  accumulator_arb_gnt; 
\jsbegin
} \jsend
wire [\=wTSProd-1=\:0]  timestamp_gainErrProduct;
wire [\=wTSInc-1=\:0]   timestamp_inc_updated; 
\jsbegin
//=============================================================================
// Bypassable pipe stages for DTW DBG interfaces
//=============================================================================
/* istanbul ignore else env ncore_3p4,ncore_3p6, ncore_3p7 */
if (useDtwDbgPipe){ \jsend
\=u.instance({
    'portsDelimiter': '\n    ',
    'instanceName': 'dtw_req_pipe',
    'moduleName':   'rdy_vld_pipe',
    'params': {
            pipeForward         : "yes",
            pipeBackward        : "no",
            simplePipe          : false,
            circular            : false,
	        forceClk            : true,
            depth               : 1,
            width               : wDtwDbgReq
    },
    'verilogParams': {},
    'ports': {
          clk        : 'clk',
          reset_n    : 'reset_n',
          in_valid   : 'dtw_req_int_valid',
          in_data    : 'dtw_req_int_pkt',
          in_ready   : 'dtw_req_int_ready',
          out_valid  : 'dtw_req_valid',
          out_data   : 'dtw_req_pkt',
          out_ready  : 'dtw_req_ready'
    }
})=\  

assign dtw_req_int_pkt = \=bundleFunctions.packetizeBundle('dtw_req_int_', DTWReqInterface, ['valid','ready'], obj.lib.bundle)=\;
assign \=bundleFunctions.packetizeBundle('dtw_req_', DTWReqInterface, ['valid','ready'], obj.lib.bundle)=\ = dtw_req_pkt;

\=u.instance({
    'portsDelimiter': '\n    ',
    'instanceName': 'dtw_resp_pipe',
    'moduleName':   'rdy_vld_pipe',
    'params': {
            pipeForward         : "yes",
            pipeBackward        : "no",
            simplePipe          : false,
            circular            : false,
	        forceClk            : true,
            depth               : 1,
            width               : wDtwDbgResp
    },
    'verilogParams': {},
    'ports': {
          clk        : 'clk',
          reset_n    : 'reset_n',
          in_valid   : 'dtw_resp_valid',
          in_data    : 'dtw_resp_pkt',
          in_ready   : 'dtw_resp_ready',
          out_valid  : 'dtw_resp_int_valid',
          out_data   : 'dtw_resp_int_pkt',
          out_ready  : 'dtw_resp_int_ready'
    }
})=\  

assign dtw_resp_pkt = \=bundleFunctions.packetizeBundle('dtw_resp_', DTWRespInterface, ['valid','ready'], obj.lib.bundle)=\;
assign \=bundleFunctions.packetizeBundle('dtw_resp_int_', DTWRespInterface, ['valid','ready'], obj.lib.bundle)=\ = dtw_resp_int_pkt;

\jsbegin
// else --- if useDtwDbgPipe
// Do not instantiate pipe stages
} else { \jsend
\=bundleFunctions.assignByBundle('dtw_req_', 'dtw_req_int_', DTWReqInterface, [], obj.lib.bundle)=\
\=bundleFunctions.assignByBundle('dtw_resp_int_', 'dtw_resp_', DTWRespInterface, [], obj.lib.bundle)=\
\jsbegin
} \jsend
//=============================================================================
// Logic Trees for aid in timing
//=============================================================================
\=u.instance({
  'portsDelimiter': '\n    ',
  'instanceName': 'u_request_valid',
  'moduleName':   'logic_tree',
  'params': {
    'width' : total_smi_ports_num,
    'logic' : '|'}, 
  'ports': {
    'din'  : 'trace_capture_arb_req',
    'dout' : 'trace_capture_request_valid'}})=\
\jsbegin
for (let i=0; i<nAccums;i++) { \jsend
\=u.instance({
  'portsDelimiter': '\n    ',
  'instanceName': 'u_accumulator_'+i+'_grant_valid',
  'moduleName':   'logic_tree',
  'params': {
    'width' : total_smi_ports_num,
    'logic' : '|'}, 
  'ports': {
    'din'  : 'accumulator_'+i+'_daisy_gnt',
    'dout' : 'accumulator_'+i+'_grant_valid'}})=\
\jsbegin
} \jsend
//=============================================================================
// DTW Beat Counter
// Keeps track of DP data beats sent out per DTW DBG request, total beats
//  dependent upon width of dp_data bus. 
//=============================================================================
\=u.dffre(wMaxDtwBeats, 'dtw_beat_counter', 'dtw_beat_counter_in', wMaxDtwBeats+"'d0", 'dtw_beat_counter_en', 'clk', 'reset_n')=\

assign dtw_beat_counter_en = 1'b1;
assign dtw_beat_counter_last = (dtw_beat_counter==\=wMaxDtwBeats=\'d\=maxDtwBeats-1=\);
assign dtw_beat_counter_clr = trace_capture_dtw_dbg_request_sent; 
assign dtw_beat_counter_in = dtw_beat_counter_clr ? \=wMaxDtwBeats=\'d0 : (dtw_req_int_valid && dtw_req_int_ready) ? (dtw_beat_counter + \=wMaxDtwBeats=\'d1) : dtw_beat_counter;
//=============================================================================
// SMI Capture FIFOs
//  Captures incoming smi messages off SMI buses. 
//=============================================================================
\jsbegin
var grant_bit = total_smi_ports_num-1; 
// RX SMI Ports
for(let i=0; i<smiRxPortInterfaces.length; i++) { 
    smiRxPortInterfaces[i].signals["timestamp"] = wTimestamp;
    var smiPipeSignals = Object.assign({},smiRxPortInterfaces[i].signals);
    var smiSignals	= Object.keys(smiPipeSignals).filter(name => (smiPipeSignals[name]) && (name!='ndp_msg_valid') && (name!='ndp_msg_ready'));    
    var bundle_signals = []; 
    bundle_signals.push( 'fifo_'+smiRxPortInterfaces[i].name+ 'ndp_ndp' );
    for(let j=0; j<smiSignals.length; j++) {
        var signalName	= smiSignals[j];
        if(signalName != 'ndp_ndp') {
            bundle_signals.push( 'fifo_'+smiRxPortInterfaces[i].name+ signalName );
        }
    }
\jsend
wire \=smiRxPortInterfaces[i].name=\valid_qual; 
wire \=smiRxPortInterfaces[i].name=\enable; 
wire [\=wTimestamp-1=\:0]   \=smiRxPortInterfaces[i].name=\timestamp = capture_frc; 
wire [\=libUtils.bundleFunctions.getBundleWidth(smiRxPortInterfaces[i].signals, ['ndp_msg_valid', 'ndp_msg_ready'], u.bundle)-1=\:0] fifo_\=smiRxPortInterfaces[i].name=\bundle; 
wire \=smiRxPortInterfaces[i].name=\ndp_msg_ready_fifo;
\=libUtils.bundleFunctions.wiresFromInterface('fifo_'+smiRxPortInterfaces[i].name, smiRxPortInterfaces[i].signals, [''], u.bundle)=\
wire [\=wAccumSizebits-1=\:0]   fifo_\=smiRxPortInterfaces[i].name=\size_bits;
wire [\=wAccum_ptr-1=\:0]   fifo_\=smiRxPortInterfaces[i].name=\size_bytes;
\=u.instance ({
                  instanceName: smiRxPortInterfaces[i].name+'fifo',
                  moduleName: 'fifo_bundle',
                  params: {
                           width: libUtils.bundleFunctions.getBundleWidth(smiRxPortInterfaces[i].signals, ['ndp_msg_valid', 'ndp_msg_ready'], u.bundle),
                           depth: smiFifoDepth,
                           zerodepth: 0,
                           bypass_mode: 0,
                           valid: 'ndp_msg_valid',
                           ready: 'ndp_msg_ready',
                           interface: smiRxPortInterfaces[i].signals
                           },
                  verilogParams: {},
                  ports: {
                          'clk' : 'clk',
                          'reset_n' : 'reset_n',
                          'push_ndp_msg_valid' : smiRxPortInterfaces[i].name+'valid_qual',
                          'push_ndp_msg_ready' : smiRxPortInterfaces[i].name+'ndp_msg_ready_fifo'
                          },
                  interfaces: [
                               {modulePrefix: 'push_', localPrefix: smiRxPortInterfaces[i].name, interface: smiRxPortInterfaces[i].signals,exclude:['ndp_msg_valid','ndp_msg_ready']},
                               {modulePrefix: 'pop_', localPrefix: 'fifo_'+smiRxPortInterfaces[i].name, interface: smiRxPortInterfaces[i].signals}]
              })=\  
// Msg can be removed from input Fifos if msg has won arbitration.
assign fifo_\=smiRxPortInterfaces[i].name=\ndp_msg_ready = fifo_accumulator_arb_gnt[\=grant_bit=\] && fifo_accumulator_ready[\=grant_bit=\];
// All fields bundled for storing into accumulator
assign fifo_\=smiRxPortInterfaces[i].name=\bundle = { \=bundle_signals.join(",")=\ };
// Qualify incoming valid with CSR enable & if packet is marked with TraceTag==1
assign \=smiRxPortInterfaces[i].name=\enable = 
\jsbegin
if (smiRxPortInterfaces[i].params.dpPresent) { \jsend
        \=traceRegInterface.name=\CCTRLR_dn0Rx_out;  
\jsbegin
} else { \jsend
        \=traceRegInterface.name=\CCTRLR_ndn\=i=\Rx_out;  
\jsbegin
} \jsend
assign \=smiRxPortInterfaces[i].name=\valid_qual = \=smiRxPortInterfaces[i].name=\ndp_msg_valid && \=smiRxPortInterfaces[i].name=\ndp_msg_ready && \=smiRxPortInterfaces[i].name=\ndp_ndp[TM_BIT] && \=smiRxPortInterfaces[i].name=\enable; 
// Vectors for performance events to track total captured/dropped in one cycle.
assign trace_capture_smi_msg_captured_vec[\=grant_bit=\] = \=smiRxPortInterfaces[i].name=\valid_qual && \=smiRxPortInterfaces[i].name=\ndp_msg_ready_fifo;
assign trace_capture_smi_msg_dropped_vec[\=grant_bit=\]  = \=smiRxPortInterfaces[i].name=\valid_qual && !\=smiRxPortInterfaces[i].name=\ndp_msg_ready_fifo;
// Determine size (in bits)
//  Bits of entire SMI bundle plus timestamp, Minus SMI ndp_ndp field +
//  Bits of valid SMI ndp_ndp field, determined by SMI ndp_ndp_len field
assign fifo_\=smiRxPortInterfaces[i].name=\size_bits = (\=wAccumSizebits=\'d\=libUtils.bundleFunctions.getBundleWidth(smiRxPortInterfaces[i].signals, ['ndp_msg_valid', 'ndp_msg_ready','ndp_ndp'], u.bundle)=\ + {\=wAccumSizebits-smiRxPortInterfaces[i].signals.ndp_ndp_len=\'d0,fifo_\=smiRxPortInterfaces[i].name=\ndp_ndp_len});
// Convert size in bits and byte aligned for loading into accumulator
assign fifo_\=smiRxPortInterfaces[i].name=\size_bytes = ({\=wAccum_ptr-(wAccumSizebits-3)=\'d0,fifo_\=smiRxPortInterfaces[i].name=\size_bits[\=wAccumSizebits-1=\:3]} + {\=wAccum_ptr-1=\'d0,|fifo_\=smiRxPortInterfaces[i].name=\size_bits[2:0]});
\jsbegin
    grant_bit--; 
} 
// TX SMI Ports
for(let i=0; i<smiTxPortInterfaces.length; i++) { 
    smiTxPortInterfaces[i].signals["timestamp"] = wTimestamp;
    var smiPipeSignals = Object.assign({},smiTxPortInterfaces[i].signals);
    var smiSignals	= Object.keys(smiPipeSignals).filter(name => (smiPipeSignals[name]) && (name!='ndp_msg_valid') && (name!='ndp_msg_ready'));    
    var bundle_signals = []; 
    bundle_signals.push( 'fifo_'+smiTxPortInterfaces[i].name+ 'ndp_ndp' );
    for(let j=0; j<smiSignals.length; j++) {
        var signalName	= smiSignals[j];
        if(signalName != 'ndp_ndp') {
            bundle_signals.push( 'fifo_'+smiTxPortInterfaces[i].name+ signalName );
        }
    }
\jsend
wire \=smiTxPortInterfaces[i].name=\valid_qual; 
wire \=smiTxPortInterfaces[i].name=\enable; 
wire [\=wTimestamp-1=\:0]   \=smiTxPortInterfaces[i].name=\timestamp = capture_frc; 
wire [\=libUtils.bundleFunctions.getBundleWidth(smiTxPortInterfaces[i].signals, ['ndp_msg_valid', 'ndp_msg_ready'], u.bundle)-1=\:0] fifo_\=smiTxPortInterfaces[i].name=\bundle; 
wire \=smiTxPortInterfaces[i].name=\ndp_msg_ready_fifo;
\=libUtils.bundleFunctions.wiresFromInterface('fifo_'+smiTxPortInterfaces[i].name, smiTxPortInterfaces[i].signals, [''], u.bundle)=\
wire [\=wAccumSizebits-1=\:0]   fifo_\=smiTxPortInterfaces[i].name=\size_bits;
wire [\=wAccum_ptr-1=\:0]   fifo_\=smiTxPortInterfaces[i].name=\size_bytes;
\=u.instance ({
                  instanceName: smiTxPortInterfaces[i].name+'fifo',
                  moduleName: 'fifo_bundle',
                  params: {
                           width: libUtils.bundleFunctions.getBundleWidth(smiTxPortInterfaces[i].signals, ['ndp_msg_valid', 'ndp_msg_ready'], u.bundle),
                           depth: smiFifoDepth,
                           zerodepth: 0,
                           bypass_mode: 0,
                           valid: 'ndp_msg_valid',
                           ready: 'ndp_msg_ready',
                           interface: smiTxPortInterfaces[i].signals
                           },
                  verilogParams: {},
                  ports: {
                          'clk' : 'clk',
                          'reset_n' : 'reset_n',
                          'push_ndp_msg_valid' : smiTxPortInterfaces[i].name+'valid_qual',
                          'push_ndp_msg_ready' : smiTxPortInterfaces[i].name+'ndp_msg_ready_fifo'
                          },
                  interfaces: [
                               {modulePrefix: 'push_', localPrefix: smiTxPortInterfaces[i].name, interface: smiTxPortInterfaces[i].signals,exclude:['ndp_msg_valid','ndp_msg_ready']},
                               {modulePrefix: 'pop_', localPrefix: 'fifo_'+smiTxPortInterfaces[i].name, interface: smiTxPortInterfaces[i].signals}]
              })=\  
// Msg can be removed from input Fifos if msg has won arbitration.
assign fifo_\=smiTxPortInterfaces[i].name=\ndp_msg_ready = fifo_accumulator_arb_gnt[\=grant_bit=\] && fifo_accumulator_ready[\=grant_bit=\];
// All fields bundled for storing into accumulator
assign fifo_\=smiTxPortInterfaces[i].name=\bundle = { \=bundle_signals.join(",")=\ };
// Qualify incoming valid with CSR enable & if packet is marked with TraceTag==1
assign \=smiTxPortInterfaces[i].name=\enable = 
\jsbegin
if (smiTxPortInterfaces[i].params.dpPresent) { \jsend
        \=traceRegInterface.name=\CCTRLR_dn0Tx_out;  
\jsbegin
} else { \jsend
        \=traceRegInterface.name=\CCTRLR_ndn\=i=\Tx_out;  
\jsbegin
} \jsend
assign \=smiTxPortInterfaces[i].name=\valid_qual = \=smiTxPortInterfaces[i].name=\ndp_msg_valid && \=smiTxPortInterfaces[i].name=\ndp_msg_ready && \=smiTxPortInterfaces[i].name=\ndp_ndp[TM_BIT] && \=smiTxPortInterfaces[i].name=\enable; 
// Vectors for performance events to track total captured/dropped in one cycle.
assign trace_capture_smi_msg_captured_vec[\=grant_bit=\] = \=smiTxPortInterfaces[i].name=\valid_qual && \=smiTxPortInterfaces[i].name=\ndp_msg_ready_fifo;
assign trace_capture_smi_msg_dropped_vec[\=grant_bit=\]  = \=smiTxPortInterfaces[i].name=\valid_qual && !\=smiTxPortInterfaces[i].name=\ndp_msg_ready_fifo;
// Determine size (in bits)
//  Bits of entire SMI bundle plus timestamp, Minus SMI ndp_ndp field +
//  Bits of valid SMI ndp_ndp field, determined by SMI ndp_ndp_len field
assign fifo_\=smiTxPortInterfaces[i].name=\size_bits = (\=wAccumSizebits=\'d\=libUtils.bundleFunctions.getBundleWidth(smiTxPortInterfaces[i].signals, ['ndp_msg_valid', 'ndp_msg_ready','ndp_ndp'], u.bundle)=\ + {\=wAccumSizebits-smiTxPortInterfaces[i].signals.ndp_ndp_len=\'d0,fifo_\=smiTxPortInterfaces[i].name=\ndp_ndp_len});
// Convert size in bits and byte aligned for loading into accumulator
assign fifo_\=smiTxPortInterfaces[i].name=\size_bytes = ({\=wAccum_ptr-(wAccumSizebits-3)=\'d0,fifo_\=smiTxPortInterfaces[i].name=\size_bits[\=wAccumSizebits-1=\:3]} + {\=wAccum_ptr-1=\'d0,|fifo_\=smiTxPortInterfaces[i].name=\size_bits[2:0]});
\jsbegin
    grant_bit--; 
} \jsend
// Vector of fifo valid outputs.
assign trace_capture_arb_req = {
\jsbegin
for(let i=0; i<smiRxPortInterfaces.length; i++) { \jsend
                  fifo_\=smiRxPortInterfaces[i].name=\ndp_msg_valid,
\jsbegin
}
for(let i=0; i<smiTxPortInterfaces.length; i++) { 
    if(i==smiTxPortInterfaces.length-1) { \jsend
                  fifo_\=smiTxPortInterfaces[i].name=\ndp_msg_valid
    \jsbegin
    } else { \jsend
                  fifo_\=smiTxPortInterfaces[i].name=\ndp_msg_valid,
    \jsbegin
    }
} \jsend
}; 
\jsbegin
for(let i=0; i<total_smi_ports_num; i++) { \jsend
// Select ready based on which accumulator was selected.
assign fifo_accumulator_ready[\=i=\] = 
    \jsbegin
    for (let j=0; j<nAccums;j++) { \jsend
          accumulator_\=j=\_daisy_gnt[\=i=\] ? pipe_fifo_accum_\=j=\_in_ready :
    \jsbegin
    } \jsend
          1'b0; 
// Fifo won arbitration on any accumulator
assign fifo_accumulator_arb_gnt[\=i=\] = 1'b0 
    \jsbegin
    for (let j=0; j<nAccums;j++) { \jsend
          || accumulator_\=j=\_daisy_gnt[\=i=\] 
    \jsbegin
    } \jsend
          ; 
\jsbegin
} \jsend
// Combined grant OR across all accumulators, used to update daisy_arb state
assign accumulator_daisy_grant_valid = 1'b0
\jsbegin
for (let j=0; j<nAccums;j++) { \jsend
          || accumulator_\=j=\_grant_valid 
\jsbegin
} \jsend
          ; 
//=============================================================================
// Force Accumulator Counters
// Timeout counter to force accumulator to load into capture buffer when expires.
// Only runs while Accumulator contains a msg and will reset when loaded into
//  capture buffer.
// Do not update if has reached timeout value
//=============================================================================
\jsbegin
for (let i=0; i<nAccums;i++) { \jsend
\=u.dffre(wForceAccumTimeout+1, 'force_accum_'+i+'_counter', 'force_accum_'+i+'_counter_in', wForceAccumTimeout+1+"'b0", 'force_accum_'+i+'_counter_en', 'clk', 'reset_n')=\

assign force_accum_\=i=\_counter_en = accumulator_\=i=\_out_valid && ~(force_accum_\=i=\_counter_expired && ~accumulator_arb_gnt[\=i=\]); 
assign force_accum_\=i=\_counter_clr = force_accum_\=i=\_counter_expired || accumulator_arb_gnt[\=i=\]; 
assign force_accum_\=i=\_counter_expired = force_accum_\=i=\_counter[\=wForceAccumTimeout=\];
assign force_accum_\=i=\_counter_in = force_accum_\=i=\_counter_clr ? \=wForceAccumTimeout+1=\'d0 : force_accum_\=i=\_counter +  \=wForceAccumTimeout+1=\'d1;
\jsbegin
} \jsend
//=============================================================================
// SMI FIFO Output Arbiters
// Daisy Chain Arbiter
// Used for handling multiple requests and their selection into accumuators
//=============================================================================
\jsbegin
var daisy_arb_ports = {};
daisy_arb_ports['clk']     = "clk";
daisy_arb_ports['reset_n'] = "reset_n";
daisy_arb_ports['in_req']  = "trace_capture_arb_req";
daisy_arb_ports['next']    = "accumulator_daisy_grant_valid";
for (let i=0; i<nAccums;i++) {
daisy_arb_ports['out_gnt_'+i] = "accumulator_"+i+"_daisy_gnt";
}
\jsend
\=u.instance ({
          instanceName: 'trace_capture_daisy_arbs',
          moduleName: 'daisy_arb',
          params: {
                   width: total_smi_ports_num,
                   depth: nAccums
                  },
          verilogParams: {},
          ports: daisy_arb_ports
          })=\
\jsbegin
//=============================================================================
// Bypassable pipe stages added for timing
// Hold winning message
//=============================================================================
// ncore3.2 forcing pipe stage for timing
/* istanbul ignore else env ncore_3p2, ncore_3p4,ncore_3p6, ncore_3p7 */
if (usePipe){
  var PipeFwd = "yes";
  var PipeBwd = "no";
} else {
  var PipeFwd = "no";
  var PipeBwd = "no";
} 
for (let i=0; i<nAccums;i++) { \jsend
\=u.instance({
    'portsDelimiter': '\n    ',
    'instanceName': 'pipe_fifo_accum_'+i,
    'moduleName':   'rdy_vld_pipe',
    'params': {
            pipeForward         : PipeFwd,
            pipeBackward        : PipeBwd,
            simplePipe          : false,
            circular            : false,
	        forceClk            : true,
            depth               : 1,
            width               : wPipeFifoAccums
    },
    'verilogParams': {},
    'ports': {
          clk        : 'clk',
          reset_n    : 'reset_n',
          in_valid   : 'accumulator_'+i+'_grant_valid',
          in_data    : 'pipe_fifo_accum_'+i+'_in_bus',
          in_ready   : 'pipe_fifo_accum_'+i+'_in_ready',
          out_valid  : 'pipe_fifo_accum_'+i+'_out_valid',
          out_data   : 'pipe_fifo_accum_'+i+'_out_bus',
          out_ready  : 'pipe_fifo_accum_'+i+'_out_ready'
    }
})=\  
assign pipe_fifo_accum_\=i=\_in_bus = {pipe_fifo_accum_\=i=\_in_data, pipe_fifo_accum_\=i=\_in_size};
assign {pipe_fifo_accum_\=i=\_out_data, pipe_fifo_accum_\=i=\_out_size} = pipe_fifo_accum_\=i=\_out_bus;
// Remove entry if it fits into accumulator and trace capture has availability. 
// Hold entry if causing accumulator to push and does needs to restart.
//  When due to expired accumulator counter
assign pipe_fifo_accum_\=i=\_out_ready = accumulator_\=i=\_msg_fit && ~(~(trace_capture_buffer_in_ready && accumulator_\=i=\_in_restart && ~force_accum_\=i=\_counter_expired) && accumulator_\=i=\_push);
\jsbegin
} \jsend
//=============================================================================
// Trace Capture Accumulators
// 64 Byte structures that hold a new DTW DBG message payload.
//  Built from multiple SMI messages that are being captured off the SMI 
//  interfaces.
//=============================================================================
\jsbegin
for (let j=0; j<nAccums;j++) { \jsend
// Winner data in, includes SMI bundle & timestamp
assign pipe_fifo_accum_\=j=\_in_data = 
\jsbegin
var grant_bit = total_smi_ports_num-1; 
for(let i=0; i<smiRxPortInterfaces.length; i++) { \jsend
    (accumulator_\=j=\_daisy_gnt[\=grant_bit=\]) ? {\=accum_size_bits-libUtils.bundleFunctions.getBundleWidth(smiRxPortInterfaces[i].signals, ['ndp_msg_valid', 'ndp_msg_ready'], u.bundle)=\'d0,fifo_\=smiRxPortInterfaces[i].name=\bundle} : 
\jsbegin
    grant_bit--; 
}
for(let i=0; i<smiTxPortInterfaces.length; i++) { \jsend 
    (accumulator_\=j=\_daisy_gnt[\=grant_bit=\]) ? {\=accum_size_bits-libUtils.bundleFunctions.getBundleWidth(smiTxPortInterfaces[i].signals, ['ndp_msg_valid', 'ndp_msg_ready'], u.bundle)=\'d0,fifo_\=smiTxPortInterfaces[i].name=\bundle} : 
\jsbegin
    grant_bit--; 
} \jsend
    {\=accum_size_bits=\'d0};
// Determine winner size (in bytes) to load to accumulator
assign pipe_fifo_accum_\=j=\_in_size = 
\jsbegin
var grant_bit = total_smi_ports_num-1; 
for(let i=0; i<smiRxPortInterfaces.length; i++) { \jsend
    (accumulator_\=j=\_daisy_gnt[\=grant_bit=\]) ? fifo_\=smiRxPortInterfaces[i].name=\size_bytes :
\jsbegin
    grant_bit--; 
}
for(let i=0; i<smiTxPortInterfaces.length; i++) { \jsend
    (accumulator_\=j=\_daisy_gnt[\=grant_bit=\]) ? fifo_\=smiTxPortInterfaces[i].name=\size_bytes :
\jsbegin
    grant_bit--; 
} \jsend
    \=wAccum_ptr=\'d0;
// Push accumulator data into capture buffer under two conditions:
// 1) accumulator timer has expired.
// 2) winning msg will cause an overflow. 
assign accumulator_\=j=\_new_msg_push = accumulator_\=j=\_out_valid && pipe_fifo_accum_\=j=\_out_valid && (!accumulator_\=j=\_msg_fit || accumulator_\=j=\_full);
assign accumulator_\=j=\_push = force_accum_\=j=\_counter_expired || accumulator_\=j=\_new_msg_push; 
// Winning msg fills up accumulator during load. Only when valid message is ready for capture and no accumulator timer has expired. 
assign accumulator_\=j=\_full = (pipe_fifo_accum_\=j=\_out_valid && !force_accum_\=j=\_counter_expired) ? ({1'b0,pipe_fifo_accum_\=j=\_out_size} == accumulator_\=j=\_remaining) : 1'b0;
// Does winning msg from arbiter fit into accumulator. Only when valid message is ready for capture and no accumulator timer has expired. 
assign accumulator_\=j=\_msg_fit = (pipe_fifo_accum_\=j=\_out_valid && !force_accum_\=j=\_counter_expired) ? ({1'b0,pipe_fifo_accum_\=j=\_out_size} <= accumulator_\=j=\_remaining) : 1'b0;
\=u.instance ({
          instanceName: 'trace_accumulator_'+j,
          moduleName: 'accumulator',
          params: {
                   width: accum_size_bits,
                   minWriteSize: accum_min_size_write_bits
                  },
          verilogParams: {},
          ports: {
                  'clk' :       'clk',
                  'reset_n' :   'reset_n',
                  'din_valid':  'accumulator_'+j+'_in_valid',
                  'restart':    'accumulator_'+j+'_in_restart',
                  'din_size':   'accumulator_'+j+'_in_size',
                  'din':        'accumulator_'+j+'_in_data',
                  'dout_valid': 'accumulator_'+j+'_out_valid',
                  'dout_size':  'accumulator_'+j+'_out_size',
                  'dout_size_int':  'accumulator_'+j+'_out_size_int',
                  'dout' :      'accumulator_'+j+'_out_data'
                  }
          })=\
// Write into accumulator when fifos have an request available that can fit
//  or need to update state when force_counter has expired
assign accumulator_\=j=\_in_valid = pipe_fifo_accum_\=j=\_out_valid || force_accum_\=j=\_counter_expired;
assign accumulator_\=j=\_in_data =        
    (pipe_fifo_accum_\=j=\_out_valid && !(accumulator_\=j=\_in_restart && !accumulator_\=j=\_full)) ?  pipe_fifo_accum_\=j=\_out_data : {\=accum_size_bits=\'d0};
assign accumulator_\=j=\_in_size =        
    (pipe_fifo_accum_\=j=\_out_valid && !(accumulator_\=j=\_in_restart || (accumulator_\=j=\_push && !(accumulator_arb_gnt[\=j=\] && trace_capture_buffer_in_ready)))) ? pipe_fifo_accum_\=j=\_out_size : \=wAccum_ptr=\'d0;
assign accumulator_\=j=\_in_restart = accumulator_arb_gnt[\=j=\] && trace_capture_buffer_in_ready;
// Remaining bytes available in accumulator
assign accumulator_\=j=\_remaining = \=wAccum_ptr+1=\'d64 - {1'b0,accumulator_\=j=\_out_size_int};
\jsbegin
} \jsend
//=============================================================================
// Trace Capture Arbiter
//  Instantiaed if using more than 1 accumulator
//=============================================================================
\jsbegin
// Number of accumulators set to 3 for ncore32
/* istanbul ignore else env ncore_3p2, ncore_3p4,ncore_3p6, ncore_3p7 */
if (nAccums>1) { //Arbiter used when multiple accumulators are used
    for (let i=0; i<nAccums;i++) { \jsend
assign accumulator_arb_req[\=i=\] = accumulator_\=i=\_push;
    \jsbegin
    } \jsend
\=u.instance({
    instanceName: 'accumulator_arb',
    moduleName: 'arb_spri',
    params: {
                    width          : nAccums          
    },
    verilogParams: {},
    ports: {
  in_req  : 'accumulator_arb_req',
  out_gnt : 'accumulator_arb_gnt'
}
 })=\
// Selection based on winning accumulator
assign trace_capture_buffer_in_valid  = 
    \jsbegin
    for (let i=0; i<nAccums;i++) { \jsend
            accumulator_arb_gnt[\=i=\] ? accumulator_\=i=\_push : 
    \jsbegin
    } \jsend
            1'b0;
assign trace_capture_buffer_data_in  = 
    \jsbegin
    for (let i=0; i<nAccums;i++) { \jsend
            accumulator_arb_gnt[\=i=\] ? accumulator_\=i=\_out_data : 
    \jsbegin
    } \jsend
            \=accum_size_bits=\'d0;
\jsbegin
} else { \jsend 
// Select single accumulator outputs
assign trace_capture_buffer_in_valid  = accumulator_0_push; 
assign trace_capture_buffer_data_in   = accumulator_0_out_data;
\jsbegin
} \jsend
//=============================================================================
// Capture Buffer
//=============================================================================
// n-entry 64byte capture buffer used to store DTW requests
// Capture Buffer will not drop any transactions. If full, pressure will be applied 
// backwards and force drops at the input to the SMI Fifos.
\jsbegin
const trace_capture_buffer_ports			= {};
trace_capture_buffer_ports['clk']			= 'clk';
trace_capture_buffer_ports['reset_n']		= 'reset_n';
trace_capture_buffer_ports['in_valid']		= 'trace_capture_buffer_in_valid';
trace_capture_buffer_ports['in_ready']		= 'trace_capture_buffer_in_ready';
trace_capture_buffer_ports['in_data']		= 'trace_capture_buffer_data_in';
trace_capture_buffer_ports['out_valid']		= 'trace_capture_buffer_out_valid';
trace_capture_buffer_ports['out_ready']		= 'trace_capture_buffer_out_ready';
trace_capture_buffer_ports['out_data']		= 'trace_capture_buffer_data_out';
\jsend
\=u.instance({
    'portsDelimiter': '\n    ',
    'instanceName': 'trace_capture_buffer',
    'moduleName':   'rdy_vld_pipe',
    'params': {
            pipeForward         : "yes",
            pipeBackward        : "no",
            simplePipe          : false,
            circular            : false,
	        forceClk            : true,
            depth               : nUnitTraceBufSize,
            width               : accum_size_bits
    },
    'verilogParams': {},
    'ports': trace_capture_buffer_ports
})=\  
// Capture Buffer entry is removed when DTW DBG request sends last beat
assign trace_capture_buffer_out_ready = dtw_req_int_ready && dtw_req_int_last; 
assign trace_capture_buffer_full = (trace_capture_buffer_counter==\=wTraceBufCntr=\'d\=nUnitTraceBufSize=\);
//=============================================================================
// Capture Buffer Counter
//=============================================================================
// Used to track number of DTW DBG messages awaiting to be sent out
\=u.dffre(wTraceBufCntr, 'trace_capture_buffer_counter', 'trace_capture_buffer_counter_in', wTraceBufCntr+"'d0", 'trace_capture_buffer_counter_en', 'clk', 'reset_n')=\

assign trace_capture_buffer_counter_en = 1'b1;
assign trace_capture_buffer_counter_inc = trace_capture_buffer_in_valid && trace_capture_buffer_in_ready; 
assign trace_capture_buffer_counter_dec = trace_capture_buffer_out_valid && trace_capture_buffer_out_ready; 
assign trace_capture_buffer_counter_in = (trace_capture_buffer_counter_inc && !trace_capture_buffer_counter_dec) ? (trace_capture_buffer_counter + \=wTraceBufCntr=\'d1) : (trace_capture_buffer_counter_dec && !trace_capture_buffer_counter_inc) ? (trace_capture_buffer_counter - \=wTraceBufCntr=\'d1) : trace_capture_buffer_counter;

//=============================================================================
// DTW Response Processing
//=============================================================================
// Update timestamp upon receipt of DTW response
assign capture_frc_upd = dtw_resp_int_valid && (dtw_resp_int_cm_type == DTW_TRACE_RESP); 

// Always accepting DTW responses. 
assign dtw_resp_int_ready = 1'b1; 

// Multiply error correction returned by csr[GAIN]
assign timestamp_gainErrProduct = {\=wTSProd-wTSGain=\'d0,\=traceRegInterface.name=\CCTRLR_gain_out} * {\=wTSProd-7=\'d0,dtw_resp_int_cm_status[6:0]};
// Use sign from error status being returned to control add/subtract correction
wire timestamp_inc_updated_overflow;
assign {timestamp_inc_updated_overflow,timestamp_inc_updated} = dtw_resp_int_cm_status[7] ? ({1'b0, \=traceRegInterface.name=\CCTRLR_inc_out} - {1'b0, \=wTSInc-8=\'d0,timestamp_gainErrProduct[\=wTSProd-1=\:3]}) : ({1'b0, \=traceRegInterface.name=\CCTRLR_inc_out} + {1'b0, \=wTSInc-8=\'d0,timestamp_gainErrProduct[\=wTSProd-1=\:3]});
// Update csr[INC] field with newly calculated Increment
assign \=traceRegInterface.name=\CCTRLR_inc_wr = capture_frc_upd;
assign \=traceRegInterface.name=\CCTRLR_inc_in = timestamp_inc_updated;
//=============================================================================
// capture_frc (Timestamp)
//=============================================================================
// Free running counter that gets updated accordingly with a DTW DBG response
// Signed error correction is returned on the DTW DBG response cm_status field.
// cm_status[7]==sign (0-positive, 1-negative)
// cm_status[6:0]==error
// Upon reception of response, error correction is multiplied by GAIN & 8 MSB bits 
//  of the resulting 11 bit value are added/subtracted to the current INC field.
//  This updated INCREMENT is then added to the current timestamp & loaded to the 
//  register INC field.
\=u.dffre(wTimestamp, 'capture_frc', 'capture_frc_in', wTimestamp+"'d0", 'capture_frc_en', 'clk', 'reset_n')=\
assign capture_frc_en = 1'b1;
wire capture_frc_in_overflow;
assign {capture_frc_in_overflow,capture_frc_in} = capture_frc_upd ? ({1'b0, capture_frc} + {1'b0, \=wTimestamp-12=\'d0,timestamp_inc_updated}) : ({1'b0, capture_frc} +  {1'b0, \=wTimestamp=\'d1});
//=============================================================================
// DTW DBG Free List Manager (free running counter)
// Update when new last beat of DTW DBG request is sent out.
//=============================================================================
\=u.dffre(wMsgId, 'messageId_flm', 'messageId_flm_in', wMsgId+"'d0", 'messageId_flm_en', 'clk', 'reset_n')=\
assign messageId_flm_en = dtw_req_int_valid && dtw_req_int_ready && dtw_req_int_last; 
assign messageId_flm_in = messageId_flm + \=wMsgId=\'d1;
//=============================================================================
// DTW Request Processing
//=============================================================================
// Send out DTW DBG message when one is available in the Capture Buffer
assign dtw_req_int_valid = trace_capture_buffer_out_valid;
assign dtw_req_int_target_id = {TargId,\=wFPortId=\'d0};   //DVE unit (trace_accumulator)
assign dtw_req_int_initiator_id = {MyId,\=wFPortId=\'d0};  
assign dtw_req_int_message_id = messageId_flm; 
assign dtw_req_int_cm_type = DTW_TRACE_REQ;
assign dtw_req_int_last = dtw_beat_counter_last;
assign dtw_req_int_rl = \=DTWReqInterface['rl']=\'d1; //Response Level = 1
//Grab portion of 64Byte data bus for each beat
assign dtw_req_int_data = 
\jsbegin
for (let i = 0; i < maxDtwBeats; i++) {
    if (i!=maxDtwBeats-1) { \jsend
    (dtw_beat_counter == \=wMaxDtwBeats=\'d\=i=\) ? trace_capture_buffer_data_out[\=wDTWData*(i+1)-1=\:\=i*wDTWData=\] : 
    \jsbegin
    } else { \jsend
    trace_capture_buffer_data_out[\=wDTWData*(i+1)-1=\:\=i*wDTWData=\] ; 
    \jsbegin
    }
} \jsend
//Tie off unused fields for now
\jsbegin
for (let key = 0; key < dtw_req_keys.length; key++) { \jsend
assign dtw_req_int_\=dtw_req_keys[key]=\ = \=DTWReqInterface[dtw_req_keys[key]]=\'h0;
\jsbegin
} \jsend
//=============================================================================
// Miscellaneous Outputs
// Performance Monitor, Busy
//=============================================================================
// Module used to provide event count based on captured vector input.
\=u.instance ({
          instanceName: 'trace_bits2count_msg_captured',
          moduleName: 'bits2cnt',
          params: {
                   width: total_smi_ports_num
                  },
          verilogParams: {},
          ports: {
                  'din':     'trace_capture_smi_msg_captured_vec',
                  'cnt':     'trace_capture_event_msg_captured'
                  }
          })=\
// Module used to provide event count based on dropped vector input.
\=u.instance ({
          instanceName: 'trace_bits2count_msg_dropped',
          moduleName: 'bits2cnt',
          params: {
                   width: total_smi_ports_num
                  },
          verilogParams: {},
          ports: {
                  'din':     'trace_capture_smi_msg_dropped_vec',
                  'cnt':     'trace_capture_event_msg_dropped'
                  }
          })=\
// Busy signal output of trace capture block. 
// 1) There are no valids out of the input SMI fifos
// 2) Capture Buffer is not empty
// 3) DTW DBG Response is being processed
// 4) Accumulators are busy working
assign trace_capture_busy = 
                            trace_capture_request_valid ||
                            (trace_capture_buffer_counter!=\=wTraceBufCntr=\'d0) ||
\jsbegin
for (let i=0; i<nAccums;i++) { \jsend
                            accumulator_\=i=\_out_valid ||
\jsbegin
} \jsend
                            dtw_resp_int_valid;
// Event output for valid DTW DBG request sent
assign trace_capture_dtw_dbg_request_sent = dtw_req_int_valid && dtw_req_int_ready && dtw_req_int_last; 

// Ports to perf counters
\=u.dffre(wTotalSmiPortsNum, 'pm_trace_messages_dropped', 'trace_capture_event_msg_dropped', wTotalSmiPortsNum+"'d0", "1'd1", 'clk', 'reset_n')=\
\=u.dffre(wTotalSmiPortsNum, 'pm_trace_messages_captured', 'trace_capture_event_msg_captured', wTotalSmiPortsNum+"'d0", "1'd1", 'clk', 'reset_n')=\
\jsbegin
//=============================================================================
// asserts
//=============================================================================
if(assertOn) { \jsend
`ifdef OVL_ASSERT_ON
// synthesis_off
// pragma synthesis_off
// coverage off

wire        cover_captured_count_en; 
wire [31:0] cover_captured_count_in; 
wire [31:0] cover_captured_count;
wire        cover_dropped_count_en; 
wire [31:0] cover_dropped_count_in; 
wire [31:0] cover_dropped_count;
wire        cover_dtwdbg_count_en; 
wire [31:0] cover_dtwdbg_count_in; 
wire [31:0] cover_dtwdbg_count;

\=u.dffre(32, 'cover_captured_count', 'cover_captured_count_in', "32'd0", 'cover_captured_count_en', 'clk', 'reset_n')=\
assign cover_captured_count_en = 1'b1;
assign cover_captured_count_in = cover_captured_count + {\=32-wTotalSmiPortsNum=\'d0,trace_capture_event_msg_captured};

\=u.dffre(32, 'cover_dropped_count', 'cover_dropped_count_in', "32'd0", 'cover_dropped_count_en', 'clk', 'reset_n')=\
assign cover_dropped_count_en = 1'b1;
assign cover_dropped_count_in = cover_dropped_count + {\=32-wTotalSmiPortsNum=\'d0,trace_capture_event_msg_dropped};

\=u.dffre(32, 'cover_dtwdbg_count', 'cover_dtwdbg_count_in', "32'd0", 'cover_dtwdbg_count_en', 'clk', 'reset_n')=\
assign cover_dtwdbg_count_en = 1'b1;
assign cover_dtwdbg_count_in = cover_dtwdbg_count + {\=32-1=\'d0,trace_capture_dtw_dbg_request_sent};
    property p_capture_buffer_overflow;
        @(posedge clk) disable iff (~reset_n)
            !(trace_capture_buffer_counter_inc & !trace_capture_buffer_counter_dec & trace_capture_buffer_full);
    endproperty

    assert_capture_buffer_overflow: assert property (p_capture_buffer_overflow)
        else begin $error("FUnit:"+MyId+" Capture Buffer overflow error !"); #100 $finish; end

    property p_capture_buffer_underflow;
        @(posedge clk) disable iff (~reset_n)
            !(trace_capture_buffer_counter_dec & (trace_capture_buffer_counter==\=wTraceBufCntr=\'d0));
    endproperty

    assert_capture_buffer_underflow: assert property (p_capture_buffer_underflow)
        else begin $error("FUnit:"+MyId+" Capture Buffer underflow error !"); #100 $finish; end

    property captured_counter;
      @(posedge clk) disable iff (~reset_n) (cover_captured_count );
    endproperty
 
    COVER_ASSERT_CAPTURED_COUNTER           : cover property (captured_counter);

    property dropped_counter;
      @(posedge clk) disable iff (~reset_n) (cover_dropped_count );
    endproperty
 
    COVER_ASSERT_DROPPED_COUNTER            : cover property (dropped_counter);
// coverage on
// pragma synthesis_on
// synthesis_on
`endif
\jsbegin
} \jsend

endmodule
