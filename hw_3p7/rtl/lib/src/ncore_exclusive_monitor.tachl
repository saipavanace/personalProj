
//=============================================================================
// Copyright(C) 2023 Arteris, Inc.
// All rights reserved
//=============================================================================
\jsbegin
// Ncore exclusive monitor for non coherent trasnacation. Instanciated in DMI and DII
// Author: Benjamin Madon
//
// Description:
// ============


// Variables

var u = obj.lib;
var utilFunctions = obj.userLib;

//=============================================================================
// Top Level Parameters
//=============================================================================

var assertOn         = u.getParam('assertOn');
var wAddr            = u.getParam('wAddr');
var wSecurity        = u.getParam('wSecurity');
var wCacheLineOffset = u.getParam('wCacheLineOffset');
var nTaggedMonitors  = u.getParam('nExclusiveEntries');
var wmpf2            = u.getParam('wmpf2');
var wInitiatorId     = u.getParam("wInitiatorId");

//=============================================================================
// Parameters
//=============================================================================
var wSecAddrCl = wSecurity + wAddr - wCacheLineOffset;
var wUnitId = wmpf2-1+wInitiatorId;

//these two paramters are used to slice in an entry
var addr_slice ="["+(wSecAddrCl+wUnitId)+" : "+(wUnitId+1)+"]";
var unit_id_slice ="["+wUnitId+" : 1 ]";

var buffer_entry_size = wSecAddrCl + wUnitId +1;


//=============================================================================
// Ports
//=============================================================================

u.port('input',  'clk',         1);
u.port('input',  'reset_n',     1);

u.port('input',  'valid',             1);
u.port('input',  'lock_op',           1);
u.port('input',  'msg_type_load',     1);
u.port('input',  'msg_type_store',    1);
u.port('input',  'address',           wAddr);
u.port('input',  'mpf2',              wmpf2);
u.port('input',  'initiator_id',      wInitiatorId);
u.port('input',  'security',          wSecurity);
u.port('output', 'ex_pass',  1);
u.port('output', 'exmon_event', 1);

\jsend

module \=obj.lib.getModuleName()=\ (\=obj.lib.getPorts('\n')=\);


\jsbegin
//=============================================================================
// Wires
//=============================================================================
\jsend


wire [\=wSecAddrCl-1=\ : 0]                 addr;
wire [\=wmpf2-1+wInitiatorId-1=\ : 0 ]      unit_id;
wire [\=buffer_entry_size-1=\ : 0 ]         new_entry;
wire [\=buffer_entry_size-1=\  :0 ]         clear_entry;

\jsbegin
for (var i = 0; i<nTaggedMonitors;i++){
\jsend

    wire [ \=wSecAddrCl-1=\ : 0]            entry_\=i=\_addr;
    wire [ \=wUnitId -1=\ : 0 ]             entry_\=i=\_unit_id;
    wire [\=buffer_entry_size-1=\ : 0 ]     entry_\=i=\;


\jsbegin
}
\jsend

wire [\=nTaggedMonitors-1=\ : 0 ]           valid_entries;
wire [\=nTaggedMonitors-1=\ : 0 ]           free_entry_to_allocate;

wire [\=nTaggedMonitors-1=\ :0 ]            occupied_entry_to_allocate;
wire [\=nTaggedMonitors-1=\ :0 ]            next_occupied_entry_to_allocate;
wire                                        en_occupied_entry_to_allocate;

wire                                        full;
wire                                        empty;

wire [\=nTaggedMonitors-1=\ :0 ]            addr_match_vec;
wire [\=nTaggedMonitors-1=\ :0 ]            unit_id_match_vec;
wire [\=nTaggedMonitors-1=\ :0 ]            valid_addr_match_vec;
wire [\=nTaggedMonitors-1=\ :0 ]            valid_unit_id_match_vec;
wire                                        valid_addr_match;
wire                                        valid_unit_id_match;

wire [\=nTaggedMonitors-1=\ :0 ]            address_and_unit_match_vec;
wire                                        address_and_unit_match;

wire [\=nTaggedMonitors-1=\ : 0 ]           en;
wire [\=buffer_entry_size-1=\:0 ]           updated_entry;

wire [ 3 : 0 ]                              conditions;    

\jsbegin
//=============================================================================
// Inputs
//=============================================================================
\jsend

assign addr = { security, address[\=wAddr-1=\:\=wCacheLineOffset=\]};

assign unit_id = {mpf2[\=wmpf2-2=\:0],initiator_id};

assign new_entry = {addr,unit_id,1'b1};
assign clear_entry = \=buffer_entry_size=\'d0;


\jsbegin
//=============================================================================
// Tagged Monitors buffer which stores the adress and the unitId
//=============================================================================
for(let i = 0;i<nTaggedMonitors;i++){
\jsend

    \=u.dffre(buffer_entry_size,"entry_"+i,"updated_entry",buffer_entry_size+"'d0","en["+i+"]","clk","reset_n")=\

    assign entry_\=i=\_addr = entry_\=i+addr_slice=\;

    assign entry_\=i=\_unit_id = entry_\=i+unit_id_slice=\;

\jsbegin
}
\jsend

\jsbegin
//this creates the valid vector
\jsend
assign valid_entries = {
                     \jsbegin
                     for (let i=nTaggedMonitors-1; i>0 ;i--){
                     \jsend
                         entry_\=i=\[0],
                     \jsbegin
                     }
                     \jsend
                        entry_0[0]
                };

assign full = &valid_entries;
assign empty = ~|valid_entries;

\jsbegin
//=============================================================================
// Entry selection for replacement
//it selects either a free entry taking the first index non occupied 
//if the buffer is full and an entry needs ot be replaced, we select an entry and round robin from 
///low to high index.
//=============================================================================
\jsend

\=obj.lib.instance({
    instanceName: 'first_free_entry',
    moduleName: 'find_first_one',
    params: { width : nTaggedMonitors },
    verilogParams: { WIDTH : nTaggedMonitors },
    ports: {
        invec : '~valid_entries', outvec : 'free_entry_to_allocate'
            }
    })=\


\=u.dffre(nTaggedMonitors,"occupied_entry_to_allocate","next_occupied_entry_to_allocate",nTaggedMonitors+"'d1","en_occupied_entry_to_allocate","clk","reset_n")=\

assign next_occupied_entry_to_allocate = occupied_entry_to_allocate[\=nTaggedMonitors-1=\] ? \=nTaggedMonitors=\'d1 : occupied_entry_to_allocate << 1;
assign en_occupied_entry_to_allocate = conditions[1];


\jsbegin
//=============================================================================
//=============================================================================
\jsend

\jsbegin
//=============================================================================
// unit Id and address amtch for the incoming request
//=============================================================================
\jsend
assign unit_id_match_vec = {
                            \jsbegin
                            for (let i=nTaggedMonitors-1;i>0;i--){
                            \jsend
                                entry_\=i=\_unit_id == unit_id,
                            \jsbegin
                            }
                            \jsend
                            entry_0_unit_id == unit_id
                            };

assign addr_match_vec = {
                            \jsbegin
                            for (var i=nTaggedMonitors-1;i>0;i--){
                            \jsend
                                entry_\=i=\_addr == addr,
                            \jsbegin
                            }
                            \jsend
                            entry_0_addr == addr
                            };


assign valid_addr_match_vec = valid_entries & addr_match_vec;
assign valid_unit_id_match_vec = valid_entries & unit_id_match_vec;

assign valid_addr_match = |valid_addr_match_vec;
assign valid_unit_id_match = |valid_unit_id_match_vec;

assign address_and_unit_match_vec = valid_unit_id_match_vec & valid_addr_match_vec;
assign address_and_unit_match = |address_and_unit_match_vec;

\jsbegin
//=============================================================================
// Monitor entry update logic
//conditions[3] : valid exclusive read incoming and unit_id matches in teh buffer
//conditions[2] : valid exclusive read incoming and unit_id does not match in the buffer and the buffer is not full
//conditions[1] : valid exclusive read incoming and unit_id does not match in the buffer and the buffer is full
//conditions[0] : valid write incoming and the addresss matches in teh buffer
//conditions 0,1 and 2 needs to create/replace an entry
//condition 3 needs to clear the amtching entry
//=============================================================================
\jsend

assign conditions = {   valid & msg_type_load & lock_op & valid_unit_id_match,
                        valid & msg_type_load & lock_op & ~valid_unit_id_match & ~full,                        
                        valid & msg_type_load & lock_op & ~valid_unit_id_match & full,
                        valid & msg_type_store & ~lock_op & valid_addr_match |  valid & msg_type_store & lock_op & address_and_unit_match
                        
                    };


assign en =  {\=nTaggedMonitors=\{conditions[3]}} & valid_unit_id_match_vec |
                        {\=nTaggedMonitors=\{conditions[2]}} & free_entry_to_allocate  |
                        {\=nTaggedMonitors=\{conditions[1]}} & occupied_entry_to_allocate|
                        {\=nTaggedMonitors=\{conditions[0]}} & valid_addr_match_vec    
                        ;
                        

// Only need ot set it for loads otherwise entry is all Zeros
assign updated_entry =  {\=buffer_entry_size=\{conditions[3] | conditions[2] | conditions[1]}} & new_entry ;         


\jsbegin
//=============================================================================
//=============================================================================
\jsend


\jsbegin
//=============================================================================
// Pass condition
// Pass asserts for any incoming read, for a non exclusive store or for a store which matches both addresss and unitId in the buffer
//=============================================================================
\jsend


assign ex_pass =    valid & msg_type_load | 
                    valid & msg_type_store & ~lock_op | 
                    valid & msg_type_store & lock_op & address_and_unit_match;


assign exmon_event = conditions[0]; //exmon event for sys_req needs to come from "clearing all matching addresses"  

\jsbegin
//=============================================================================
//=============================================================================
\jsend


\jsbegin
//=============================================================================
// Assertions:
// - A unitId can only match in one entry
// - On a load the allocation vector must be one hot
// - 
//=============================================================================
 /* istanbul ignore else env ncore_3p6 */
 if ( assertOn ) { \jsend
    `ifdef OVL_ASSERT_ON
    // coverage off
    // synthesis off
    // synopsys translate_off
    
    
    
    wire [2:0] fire_free_allocatee;
    ovl_zero_one_hot #(.width(\=nTaggedMonitors=\),.msg("Exclusive monitor :Allocation vector must be one hot")) allocate (
        .clock(clk),
        .reset(reset_n),
        .enable(1'b1),
        .test_expr(     {\=nTaggedMonitors=\{conditions[3]}} & valid_unit_id_match_vec |
                        {\=nTaggedMonitors=\{conditions[2]}} & free_entry_to_allocate  |
                        {\=nTaggedMonitors=\{conditions[1]}} & occupied_entry_to_allocate),
        .fire(fire_free_allocatee)
    );  
    
    wire [2:0] fire_unit_match;
    ovl_zero_one_hot #(.width(\=nTaggedMonitors=\),.msg("Exclusive monitor : Funit_id match must be zero one hot")) funit_match_assert (
        .clock(clk),
        .reset(reset_n),
        .enable(1'b1),
        .test_expr(valid_unit_id_match_vec),
        .fire(fire_unit_match)
    );

    wire [2:0] fire_free_entry_allocate;
    ovl_zero_one_hot #(.width(\=nTaggedMonitors=\),.msg("Exclusive monitor :free entry to allocate must be one hot")) free_entry_to_allocate_assert (
        .clock(clk),
        .reset(reset_n),
        .enable(1'b1),
        .test_expr(free_entry_to_allocate),
        .fire(fire_free_entry_allocate)
    );

    wire [2:0] fire_occupied_entry_to_allocate;
    ovl_one_hot #(.width(\=nTaggedMonitors=\),.msg("Exclusive monitor :Funit_id match must be zero one hot")) occupied_allocate (
        .clock(clk),
        .reset(reset_n),
        .enable(1'b1),
        .test_expr(occupied_entry_to_allocate),
        .fire(fire_occupied_entry_to_allocate)
    );

    wire [2:0] fire_read_write;
    ovl_always #(.property_type(1),.msg("Exclusive monitor :cannot be a read and a write at the same time")) msg_types (
        .clock(clk),
        .reset(reset_n),
        .enable(1'b1),
        .test_expr(msg_type_load^msg_type_store),
        .fire(fire_read_write)
    );


    // synopsys translate_on
    // synthesis on
    // coverage on
    `endif
\js }
endmodule
