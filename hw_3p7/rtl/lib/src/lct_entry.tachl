\jsbegin
//=============================================================================
// Copyright (C) 2017 Arteris, Inc.
// All rights reserved.
//=============================================================================
// Latency Counter Table Entry 
// Author: Ronak Salamat
// //=============================================================================

var u						= obj.lib;
var bundleFunctions				= obj.userLib.bundleFunctions;
var libUtils					= obj.userLib;
var log2ceil = function(n) { return Math.ceil(Math.log(n)/Math.LN2); };

//=============================================================================
// Parameters
//=============================================================================

// No params. wId and wCount can be read from the lctEntryOutInterface
var clkInterface				= libUtils.hierGetParam('clkInterface',u.getParam);

var lctEntryOutInterface			= libUtils.hierGetParam('lctEntryOutInterface', u.getParam);
var lctEntryinInterface				= libUtils.hierGetParam('lctEntryinInterface', u.getParam);

var wLatencyCntr 				= lctEntryOutInterface.signals.count_val;
			

var stateInterface          = { name: "state_", signals: { val: wLatencyCntr } };
var evtTmrInterface         = { name: "evt_", signals: { count: 1, start: 1, stop: 1, reset: 1} };

var local					= {
	limit		: wLatencyCntr,
	mode		: 2,
	en		: 1
};

var nTTEntriesPerCounter = lctEntryinInterface.signals.alloc;
var wId = log2ceil(nTTEntriesPerCounter);

//=============================================================================
// Instantiate Interfaces and port declarations
//=============================================================================

u.interface(clkInterface.name,    'slave' , clkInterface.signals);
u.interface(lctEntryOutInterface.name,    'master' , lctEntryOutInterface.signals);  // { name: "string", signals: {valid, ready, count_val} }
u.interface(lctEntryinInterface.name, 'slave', lctEntryinInterface.signals);

u.port('input', 'latency_ref_count', 1);
u.port('input', 'latency_count_en', 1);

//=============================================================================
// Local Functions 
//=============================================================================
function getModuleLocalPrefixAndInterface (intrface) {
	var modulePrefix		= intrface.name;
	var localPrefix		= intrface.name;
	return { modulePrefix, localPrefix, "interface": intrface.signals };
}


\jsend
module \=u.getModuleName()=\ (\=u.getPorts('\n    ')=\);


//=============================================================================
// Wire declaration
//=============================================================================
\=bundleFunctions.wiresFromInterface("", local, [], obj.lib.bundle)=\

wire [1:0] ST_IDLE  = 2'b00;
wire [1:0] ST_RUN   = 2'b01;
wire [1:0] ST_HALT  = 2'b10;


reg allocated_id_en;
wire [1:0] cur_state;
reg [1:0] nxt_state;
reg sm_en;

reg \=evtTmrInterface.name=\start;
reg \=evtTmrInterface.name=\stop; 
reg \=evtTmrInterface.name=\count;
reg \=evtTmrInterface.name=\reset;

reg st_pipe_valid;

wire st_dealloc;
wire st_pipe_ready; 

//=============================================================================
// Generate st_alloc and st_dealloc signals for the state machine
//=============================================================================
wire st_alloc;
assign st_alloc = |\=lctEntryinInterface.name=\alloc; \jsbegin

//=============================================================================
// FF1 to generate the allocated_id 
//=============================================================================
if (lctEntryinInterface.signals.alloc > 1) { \jsend
  wire [\=nTTEntriesPerCounter-1=\:0] find_first_in;
  wire [\=nTTEntriesPerCounter-1=\:0] allocated_id_one_hot;
  wire [\=wId-1=\:0] conv_allocated_id;
  wire [\=wId-1=\:0] allocated_id;
  assign find_first_in = \=lctEntryinInterface.name=\alloc;

  \=obj.lib.instance({
        instanceName: 'u_allocated_id',
        moduleName: 'find_first_one',
        params: { width : nTTEntriesPerCounter },
        verilogParams: { WIDTH : nTTEntriesPerCounter },
        ports: {
            invec : 'find_first_in', outvec : 'allocated_id_one_hot'
        }
    })=\ \jsbegin 

  var one_hot_2_bin_mux = {};

  for (var i = 0; i < nTTEntriesPerCounter; i++){
    one_hot_2_bin_mux['in'+i] = "{"+ wId+"'d"+i+"}"; 
  }

  one_hot_2_bin_mux['sel'] = "allocated_id_one_hot";
  one_hot_2_bin_mux['out'] = "conv_allocated_id"; \jsend
 
  \=obj.lib.instance({
        instanceName: 'one_hot_2_bin_id_conv',
        moduleName: 'ao_mux',
        params: {
	    nInputs          : nTTEntriesPerCounter,
            wMux             : wId

        },
        verilogParams: {},
        ports: one_hot_2_bin_mux
   })=\ 

  \=u.dffre(wId, "allocated_id",  "conv_allocated_id", wId+"'b0", "allocated_id_en", clkInterface.name+"clk", clkInterface.name+"reset_n")=\ \jsbegin

  var alloc_id = [];
  for (var i = 0; i < nTTEntriesPerCounter; i++) {
    alloc_id.push("allocated_id ==" + wId+"'d"+i);
  } \jsend
  wire [\=nTTEntriesPerCounter-1=\:0] st_alloc_id_one_hot;
  assign st_alloc_id_one_hot = {\=alloc_id.reverse().join(" , ")=\}; 

  assign st_dealloc = |(\=lctEntryinInterface.name=\dealloc & st_alloc_id_one_hot); \jsbegin

} else { \jsend 
  assign st_dealloc = \=lctEntryinInterface.name=\dealloc; \jsbegin
} \jsend


//=============================================================================
// State Machine
//=============================================================================
// 1. If latency_count_en is deasserted before a TT entry is deallocated, its 
// Latency count is discarded.
// 2. Latency count for a TT entry that was deallocated before latency_count_en
// was deasserted, is guaranteed to make forward progress into the quantizer and
// binning counters.


\=u.dffre(2, "cur_state",  "nxt_state", "2'b0", "sm_en", clkInterface.name+"clk", clkInterface.name+"reset_n")=\

        
always @(*) begin

   st_pipe_valid = 1'b0;
   \=evtTmrInterface.name=\start = 1'b0; 
   \=evtTmrInterface.name=\stop  = 1'b0;
   \=evtTmrInterface.name=\count = latency_ref_count;  
   \=evtTmrInterface.name=\reset = 1'b0;
   nxt_state                     = ST_IDLE;
   allocated_id_en               = 1'b0;
 

   case (cur_state)
      ST_RUN: 
        if (latency_count_en) begin
	      st_pipe_valid     = st_dealloc;
          sm_en             = st_dealloc & (~st_alloc | ~st_pipe_ready);
          nxt_state         = st_pipe_ready ? ST_IDLE : ST_HALT;
          \=evtTmrInterface.name=\stop              = st_dealloc & (~st_alloc | ~st_pipe_ready);
          \=evtTmrInterface.name=\reset             = st_dealloc & st_pipe_ready;
          allocated_id_en   = st_dealloc & st_alloc & st_pipe_ready;
        end
        else begin
          sm_en             = 1'b1;
          \=evtTmrInterface.name=\stop              = 1'b1;
          \=evtTmrInterface.name=\reset             = 1'b1;
        end

      ST_HALT: begin
	    if (latency_count_en) begin
	      \=evtTmrInterface.name=\start             = st_alloc & st_pipe_ready;
          nxt_state          = st_alloc ? ST_RUN : ST_IDLE;
          allocated_id_en    = st_alloc & st_pipe_ready;
        end
        
        sm_en                = st_pipe_ready;
	    st_pipe_valid        = 1'b1;
	    \=evtTmrInterface.name=\reset = st_pipe_ready;
      end

      default: begin
	    if (latency_count_en) begin
	      \=evtTmrInterface.name=\start             = st_alloc;
          allocated_id_en                           = st_alloc;
	    end

        nxt_state            = ST_RUN;
        sm_en                = st_alloc & latency_count_en;
      end

    endcase
end

\jsbegin

//=============================================================================
// ID storage
//=============================================================================
if (lctEntryinInterface.signals.alloc > 1) { \jsend
  wire [\=wId-1=\:0] allocated_id_out;
  \=u.dffre(wId, "allocated_id_out",  "allocated_id", wId+"'b0", "allocated_id_en", clkInterface.name+"clk", clkInterface.name+"reset_n")=\ \jsbegin
} \jsend
   
//=============================================================================
//ncore_pmon_tmr instance
//=============================================================================

\=bundleFunctions.wiresFromInterface(stateInterface.name, stateInterface.signals, [], obj.lib.bundle)=\

assign en = 1'b1;
assign mode = 2'd1;
assign limit = \=wLatencyCntr=\'d511;

 \=u.instance({
      instanceName: 'u_ncore_pmon_tmr',
      moduleName: 'ncore_pmon_tmr',
      params: {
          	  "width"		: wLatencyCntr,
		  "internalState"	: true,
		  clkInterface,
		  "stateInterface"	: stateInterface,
		  "evtTmrInterface"	: evtTmrInterface
      },
      ports: {
          	  en    : 'en',
		  mode	: 'mode',
		  limit	: 'limit'     
      },
	  interfaces	: [ clkInterface, stateInterface, evtTmrInterface ].map( getModuleLocalPrefixAndInterface )
  })=\

/////////////////////////////////////////////////////////////////////
//rdy_valid_pipe for timing improvement
/////////////////////////////////////////////////////////////////////

\=u.instance({
      instanceName: 'lct_entry_rdy_vld_pipe',
      moduleName: 'rdy_vld_pipe',
      params: {
          	  "width"		: wLatencyCntr,
		  "depth"		: 1,
		  "pipeForward"		: true,
		  "pipeBackward"	: false
      },
      verilogParams: {},
      ports: {
          	  clk: clkInterface.name+"clk",
		  reset_n :  clkInterface.name+"reset_n",
		  in_valid:  "st_pipe_valid",   
		  in_ready:  "st_pipe_ready",
		  in_data :  stateInterface.name+"val", 
		  out_valid: lctEntryOutInterface.name+"valid", 
		  out_ready: lctEntryOutInterface.name+"ready", 
		  out_data : lctEntryOutInterface.name+"count_val"   
      }
	  
  })=\


endmodule
