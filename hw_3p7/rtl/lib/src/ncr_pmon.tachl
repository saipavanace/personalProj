\jsbegin
//=============================================================================
// Copyright (C) 2017 Arteris, Inc.
// All rights reserved.
//=============================================================================
// Performance Monitor Ncore Unit
// Author: Ronak Salamat
// //=============================================================================
\jsend

\jsbegin

const u							= obj.lib;
const bundleFunctions			= obj.userLib.bundleFunctions;
const libUtils					= obj.userLib;
const getHWPortName				= libUtils.getHWPortName;
const flattenInterface          = libUtils.flattenInterface;
const newToOldStyleInterface	= libUtils.newToOldStyleInterface.bind( null, obj.userLib );

const vlogGen					= libUtils.vlogGen();
const vlogSignal				= vlogGen.vlogSignal;
const vlogConst					= vlogGen.vlogConst;
const cat						= vlogGen.vlogHelper.cat;

//=============================================================================
// Default Parameter Declarations
//=============================================================================
u.paramDefault('nPerfCounters', 'int', 4);
u.paramDefault('interfaces','object',null);
u.paramDefault('inEvtPipeEn','boolean',true);
u.paramDefault('bwEvtMapping', 'object' ,null);
u.paramDefault('nLatencyCounters', 'int',0);

//=============================================================================
// Parameters
//=============================================================================

const nPerfCounters				= libUtils.hierGetParam('nPerfCounters', u.getParam);
const interfaces				= libUtils.hierGetParam('interfaces',u.getParam);
const inEvtPipeEn				= libUtils.hierGetParam('inEvtPipeEn', u.getParam);

const csrOldInterface			= newToOldStyleInterface(interfaces.csrInterface);

var filterAttrInterfaces		= interfaces.filterAttrInterfaces ||  /* istanbul ignore next env ncore_3p4 */ [];

var numFilterAttr        = filterAttrInterfaces.length;


var bwEvtMapping	= libUtils.hierGetParam('bwEvtMapping', u.getParam); //array of bw events number 

//Latency
var nLatencyCounters    = libUtils.hierGetParam('nLatencyCounters', u.getParam);

var latencyInterfaces 	= interfaces.latencyInterfaces ||  /* istanbul ignore next env ncore_3p4 */ []; 

var numLatencyInterface = latencyInterfaces.length;

//JS parameter to generate bases and masks of the quantizer block
var binWidths = [8, 8, 16, 32, 32, 32, 128, 256];
var numBins = binWidths.length; 

 /* istanbul ignore else env ncore_3p4, ncore_3p6, ncore_3p7 */
if (interfaces.masterTriggerInterface) {
  var masterOldInterface = newToOldStyleInterface(interfaces.masterTriggerInterface);
}

// Derived params
const evtWidths		= [];

for (let i = 0; i < interfaces.evtInterfaces.length; i++){
  evtWidths.push(interfaces.evtInterfaces[i].params.width);		
}

const wEvtMax					= Math.max( ...evtWidths );
const wCountMax					= wEvtMax + 1; // + 1 to account for carry bit
const precision					= 8; // Filter precision
var widthLatencyCntrs 				= 9;

//=======================================================================
// Local Functions 
//=============================================================================
// Function that returns wire declarations of a new-style interface
function declareNewStyleInterface ( newStyleInterface ) {
	const oldStyleInterface		= newToOldStyleInterface( newStyleInterface );
	const flatOldInterface		= flattenInterface ( oldStyleInterface );
	return bundleFunctions.wiresFromInterface( flatOldInterface.name, flatOldInterface.signals, [], obj.lib.bundle);
}

function extend( name, width, newWidth) {
  return newWidth != Math.abs(width) ? "{"+(newWidth-Math.abs(width))+"'d0, "+name+"}" :  /* istanbul ignore next env ncore_3p4, ncore_3p6, ncore_3p7 */ name;
}


function csrPort(register, field, type) {
	return interfaces.csrInterface.name + getHWPortName(register, field, type);
}

function csrPortOut( register, field ) {
	return csrPort( register, field, "out");
}

function signalWidth(signals, key){
	return (Math.abs(signals[key]) || /* istanbul ignore next env ncore_3p2 */ 0);
}

function csrPortWidth( register, field, type) {
		return signalWidth(csrOldInterface.signals, getHWPortName( register, field, type ));
}
 

// Returns a vlogSignal object for the "*out" signal from a given register-field 
function vlogCsrPort( register, field, type ) {
	return vlogSignal( csrPortWidth(register, field, type), csrPort( register, field, type) );
}


// Returns synonym tables for *in, *wr, and *out signals that connect to a Pmon timer's cfgValInterface
// The input parameter tmr is expected to be an entry from the tmrEvtMap array
function csrSynonymsFromTmr( tmr ) {
	if( tmr.internalState )				// This handles the case for timers that are not controlled by registers such as stall counters
		return { inputs: [], outputs: [] };

	const register					= tmr.name+"_val";
	const field						= "val";

	const csrOut					= { name: getHWPortName( register, field, "out" ), width: tmr.width };
	const csrIn						= { name: getHWPortName( register, field, "in" ), width: tmr.width };
	const csrWr						= { name: getHWPortName( register, field, "wr" ), width: 1 };
	
	return { inputs: [csrIn, csrWr], outputs: [csrOut] };
};


// This function converts minStallPeriod (coming from CNTCR register) to equivalent value
// to be driven to the pmon_tmr limit input using the relationship limit = 2^MinStallPeriod - 1
// The function assumes minStallPeriod and limit are objects with properties: {expr(string), width(int)} 
function minStallPeriodToLimit( minStallPeriod ) {
	const wLimit		= Math.pow(2, minStallPeriod.width) - 1;
	const limitBits		= [];

	for(let i=wLimit-1; i>=0; i--) {
		const n			= vlogConst( minStallPeriod.width, i );
		limitBits.push( minStallPeriod.cmp(">", n) );
	}

	const limit			= cat(limitBits);
	return limit;
}


// This function converts filterSel bits (coming from CNTCR register) to equivalent value
// to be driven to the alpha input of the LPF block. The function assumes filterSel param
// and returned value alpha are objects with properties: { expr(string), width(int) } 
function filterSelToAlpha( filterSel ) {
	const wAlpha		= Math.pow(2, filterSel.width) - 1;
	const alphaBits		= [];

	for(let i=1; i<=wAlpha; i++) {
		const n			= vlogConst( filterSel.width, i );
		alphaBits.push( filterSel.cmp("==", n) );
	}

	const alpha			= cat(alphaBits);
	return alpha
}

function createStallCounter(name, io) {
	const stallCounter	= {
			name	: name,
			width	: io.limit.width,
			limit	: io.limit.expr || /* istanbul ignore next env ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */ io.limit.name,	// If expr is undefined or empty-string, pick name instead
			start	: "("+name+"_val"+" == 0) & "+ io.inEvent.name, 
			mode	: "2'd0",
			internalState	: true,
 			reset	: "~"+io.inEvent.name, 
			count	: io.inEvent.name, 
			tmrEvt	: io.outEvent.name		//This is a single bit output which will be asserted for a single clock when it rolls over the limit value 
	};

	return { tmrEvtMap: [stallCounter] };
}


function searchSynoymWidth( name, synonyms ) {
    for( var i=0 ; i<synonyms.length; i++){ 
     /* istanbul ignore else env ncore_3p4, ncore_3p6, ncore_3p7 */ 
     if (name == synonyms[i].name)
        return synonyms[i].width;
}
}

function getMaxWidthLatencyInterface (latencyInterfaces ) {

  var k = 0;   // This is the index of the latencyInterface with max allox width

  // latencyInterfaces.forEach ( latencyInterface =>
  for(var i=1; i< latencyInterfaces.length; i++) {
    var widthOfAlloc   = searchSynoymWidth( "alloc", latencyInterfaces[i].synonyms.out );
    var maxWidthOfAlloc = searchSynoymWidth( "alloc", latencyInterfaces[k].synonyms.out );
   
    if(widthOfAlloc > maxWidthOfAlloc)
       k = i;
   }

  return latencyInterfaces[k];
}


function create64BitCounter(name, inputs){

	const tmrEvtMap = [
		{
			name	: name+"LO",
			width	: 32, //width of counter
			mode	: "2'd2",
			en	: inputs.control.enLo,
			reset	: inputs.control.reset,
			count	: inputs.inEvent1.name,
			wCount	: inputs.inEvent1.width,  //input count event width
			ovfEvt	: name+"LO_ovf",
			comment	: "Counter that counts the lower 32-bits of events"
		},
		{
			name	: name+"HI",
			width	: 32,
			mode	: "2'd2",
			en	: inputs.control.enHi, 
			reset	: inputs.control.reset,
			ovfEvt	: name+"HI_ovf",
			count	: inputs.control.mode + " ? " + inputs.inEvent2.name +" : "+ vlogSignal(1,name+"LO_ovf").extend0( inputs.inEvent2.width), 
			wCount	: inputs.inEvent2.width,  //input count event width
			comment	: "Counter that counts every time there's an overflow on the lower 32-bits of events"
		}	
	];

	const ovf_hi			= {
		name			: name+"HI_ovf_out",
		width			: 1, 
		outEvt			: "evtOut_ovf_hi"+"_"+name+"_",
		conditions		: [name+"HI_ovf"]	
	};

	const ovf_lo			= {
		name			: name+"LOW_ovf_out",
		width			: 1, 
		outEvt			: "evtOut_ovf_lo"+"_"+name+"_",
		conditions		: [name+"LO_ovf"]	
	};


	return { tmrEvtMap, evtDefines: [ovf_hi, ovf_lo] };
}


function createLoader(name, inputs) {
	const tmrEvtMap = [
		{
			name		: name,
			width		: 32,
			mode		: "2'd3",  // Load mode
			en			: inputs.control.en,
			reset		: inputs.control.reset,
			count		: inputs.inEvent.name,
			wCount		: inputs.inEvent.width,
			comment		: "Timer in load mode: loads the input count value into register"
		}
	];

	return { tmrEvtMap };
}


function createFilter(name, inputs, params) {
	const tmrEvtMap = [
		{
			name		: name,
			width		: inputs.inEvent.width + params.precision,
			mode		: "2'd3",
			en			: inputs.control.en, 
			reset		: inputs.control.reset,
			count		: inputs.inEvent.name, 
			wCount		: inputs.inEvent.width + params.precision,

			// Filter params and inputs
			filterOn	: true,
			precision	: params.precision,	
		    depth		: inputs.alpha.width+1,
			alpha		: inputs.alpha.expr || inputs.alpha.name,
			comment		: "Counter that counts every time there's an overflow on the lower 32-bits of events"
		}	
	];

	return { tmrEvtMap };
}


function createMax(name, inputs) {
	const state			= csrPortOut(name+"_val", "val");
	const tmrEvtMap = [
			{
				name	: name,
				width	: inputs.inEvent.width,		// Width of counter
				mode	: "2'd3",
				en		: inputs.control.en,
				reset	: inputs.control.reset,
				wCount	: inputs.inEvent.width,
				count	: inputs.inEvent.name + " > "+ state + " ? "+ inputs.inEvent.name+ " : "+ state,
				comment	: "Counter that counts the lower 32-bits of events"
			} 				
	];
	return { tmrEvtMap };
}

// Function to create a flop resource between an input event (inputs.inEvent)
// and an output event (name)
function addFlop( name, inputs ) {
  var zeros				= inputs.inEvent.width+"'b0";
  var mux				= {
		name			: name,
		width			: inputs.inEvent.width,
		reduceOp		: "?",
		conditions		: [ inputs.inEvent.name, zeros ],
		select			: [ "~"+inputs.control.clear, inputs.control.clear ],
		edgeDetect		: "flop",				// This adds a pipe/flop to the output of mux to ease timing
		edgeDetectEn	: [inputs.control.en, inputs.control.clear].join(" | ")
	  };
 
  return { evtDefines: [ mux ] }; 
}

// events = { counter: [array of oldStyle interface], ottEvtEntries: oldStyuleInteface }
// signals = { "signal1": width-of-signal1, "signal2": widt-of-signal2,... }
function generateNcorePmonResourceDefs(events, spclEvents, nPerfCounters){

	const nMuxInputs		= events.length;
	const nCntMode		= 5;
	const wEventMax			= 3;
	const muxConditions		= [];
	const wSel				= csrPortWidth("CNTCR0", "CntEvtFirst", "out"); // libUtils.log2ceil(nMuxInputs);
	const wSelCntCtl 		= csrPortWidth("CNTCR0", "CounterCtl", "out"); // libUtils.log2ceil(nCntMode);
	
	const evtDefines		= [];
	const tmrEvtMap			= [];

	for (let n = 0; n < nPerfCounters; n++) {
	  const muxMultiBitConditions 		= [];
	  const muxAMultiBitSelect			= [];
	  const	muxBMultiBitSelect			= [];
	  const mux1BitConditions			= [];
	  const muxA1BitSelect				= [];
	  const muxB1BitSelect				= [];
	  const muxresSelect				= [];

	  const alphaDecoded = filterSelToAlpha( vlogCsrPort("CNTCR"+n, "FilterSel", "out") );
	  var pmonCounterEn = csrPortOut("CNTCR"+n, "CountEn") ;		
	
	 /* istanbul ignore else env ncore_3p4, ncore_3p6, ncore_3p7 */ 
	if (csrPortWidth("MCNTCR", "LocalCountClear", "out") ) {
		var pmonCounterClr = csrPortOut("CNTCR"+n, "CountClr") + " | " + csrPortOut("MCNTCR", "LocalCountClear"); 
	}


      for (let i=0; i < nMuxInputs; i++)	{
		if(events[i].signals.val > 1) {
		  if (events[i].signals.val != wEvtMax) {
			muxMultiBitConditions.push ("{"+(wEvtMax - events[i].signals.val) +"'d0"+","+ events[i].name+"val"+"}");	
		  } else {
			muxMultiBitConditions.push (events[i].name+"val" );
		  }

		  muxAMultiBitSelect.push( csrPortOut("CNTCR"+n, "CntEvtFirst") +" == "+wSel+"'d"+i );
		  muxBMultiBitSelect.push( csrPortOut("CNTCR"+n, "CntEvtSecond") +" == "+wSel+"'d"+i );

		} else {
		  mux1BitConditions.push (events[i].name+"val" );
		  muxA1BitSelect.push( csrPortOut("CNTCR"+n, "CntEvtFirst") +" == "+wSel+"'d"+i );
		  muxB1BitSelect.push( csrPortOut("CNTCR"+n, "CntEvtSecond") +" == "+wSel+"'d"+i );

		}
      }

	  for (let i=0; i < nCntMode; i++) {
		muxresSelect.push(csrPortOut("CNTCR"+n, "CounterCtl") +" == " +wSelCntCtl+"'d"+i);
	  }


	  const muxA1Bit = 		{
		name			: "muxA_1bit_"+n, //everytime we have to push a new event name
		width			: 1, 
		reduceOp		: "?",
		conditions		: mux1BitConditions,
		select			: muxA1BitSelect 
	  };

	  const muxB1Bit = 		{
		name			: "muxB_1bit_"+n, //everytime we have to push a new event name
		width			: 1, 
		reduceOp		: "?",
		conditions		: mux1BitConditions,
		select			: muxB1BitSelect 
	  };

	  const muxAMultiBit = 		{
		name			: "muxA_multibit_"+n, //everytime we have to push a new event name
		width			: wEvtMax, 
		reduceOp		: "?",
		conditions		: muxMultiBitConditions,
		select			: muxAMultiBitSelect 
	  };

	  const muxBMultiBit = 		{
		name			: "muxB_multibit_"+n, //everytime we have to push a new event name
		width			: wEvtMax, 
		reduceOp		: "?",
		conditions		: muxMultiBitConditions,
		select			: muxBMultiBitSelect 
	  };

	  const selA_valid = 		{
		name			: "selA_valid_"+n, //everytime we have to push a new event name
		width			: 1, 
		reduceOp		: "|",
		conditions		: muxAMultiBitSelect
	  };

	  const selB_valid = 		{
		name			: "selB_valid_"+n, //since the multiplexer selecter is 1-hot, we can |muxBMultiBitSelect
		width			: 1, 
		reduceOp		: "|",
		conditions		: muxBMultiBitSelect
	  };

	  // Generate resources for stall-counter
	  const stallLimit					= minStallPeriodToLimit( vlogCsrPort("CNTCR"+n, "MinStallPeriod", "out") );
	  const ioStallCountA				= { inEvent : muxA1Bit, limit : stallLimit, outEvent: vlogSignal(1, "StallCntA"+n+"_evt_out") };
	  const ioStallCountB				= { inEvent	: muxB1Bit, limit : stallLimit, outEvent: vlogSignal(1, "StallCntB"+n+"_evt_out") };
	  const resourcesStallCountA		= createStallCounter("StallCntA"+n, ioStallCountA);
	  const resourcesStallCountB		= createStallCounter("StallCntB"+n, ioStallCountB);


	  const muxA1vsMultiBit = 		{
		name			: "muxA_1vsmulti_"+n, //everytime we have to push a new event name
		width			: wEvtMax, 
		reduceOp		: "?",
		conditions		: [ ioStallCountA.outEvent.extend0(wEvtMax).expr, muxAMultiBit.name],
		select			: ["~"+selA_valid.name, selA_valid.name]  //select needs to be 1-hot and the entries are the same as conditions array

	  };

 	  const muxB1vsMultiBit = 		{
		name			: "muxB_1vsmulti_"+n, //everytime we have to push a new event name
		width			: wEvtMax, 
		reduceOp		: "?",
		conditions		: [ ioStallCountB.outEvent.extend0(wEvtMax).expr , muxBMultiBit.name],
		select			: ["~"+selB_valid.name, selB_valid.name]
 
	  };

	 const evtFilterEvt = 		{
		name			: "evt_Filter_evt"+n,
		width			: wEvtMax,
		conditions		: [muxA1vsMultiBit.name +" & "+"{"+wEvtMax+"{"+spclEvents.ncrFilterEvts[n].name+"val}}"]			
	};


 	  const aPlusB		= 		{
		name			: "a_plus_b_"+n, //everytime we have to push a new event name
		width			: wEvtMax+1, 
		conditions		: ["{1'b0,"+ evtFilterEvt.name+"} + "+"{1'b0,"+muxB1vsMultiBit.name+"}"]
	  };

	  const muxres = 		{
		name			: "muxres_"+n,
		width			: wCountMax, 	// + 1 to account for carry out
		reduceOp		: "?",
		conditions		: [aPlusB.name, "{1'b0, "+evtFilterEvt.name+" & "+muxB1vsMultiBit.name+"}", "{1'b0, "+evtFilterEvt.name+" ^ "+muxB1vsMultiBit.name+"}", "{1'b0, "+evtFilterEvt.name+"}", "{1'b0, "+ evtFilterEvt.name+ "}"],
		select		    : muxresSelect
	  };
 
	  const muxresclr = {
		name			: "muxresclr_"+n,
		width			: wCountMax, 	// + 1 to account for carry out
		reduceOp		: "?",
		conditions		: [muxres.name, "{"+ wCountMax + "'b0}"],
		select			: ["~("+pmonCounterClr + ")", pmonCounterClr],
		edgeDetect		: "flop",				// This adds a pipe/flop to the output of mux to ease timing
		edgeDetectEn	: "(("+pmonCounterEn+ ") | " + pmonCounterClr+")"

	  };


	  const alpha = {
		name			: "alpha_"+n,
		width			: alphaDecoded.width,
		conditions		: [alphaDecoded.expr],
		edgeDetect		: "flop",
		edgeDetectEn		: pmonCounterEn

};

	  
 

	   evtDefines.push(muxA1Bit, muxB1Bit, muxAMultiBit, muxBMultiBit, selA_valid, selB_valid, muxA1vsMultiBit, muxB1vsMultiBit, muxres, aPlusB, alpha, muxresclr,evtFilterEvt); 

		
	//TODO: gated version need to go through the functions	
	  // Generate resources for 64-bit counter (Two daisy-chained 32-bit counters)
	  const inputs64BitCounter			= { 
		inEvent1	: muxresclr,	// All multi-bit inputs are assumed to be objects with properties: { name, width }
		inEvent2 	: muxB1vsMultiBit,
		control	: {
			enLo	: "( " + pmonCounterEn + ") & ("+ csrPortOut("CNTCR"+n, "CounterCtl")+" != 3'b011)",
			enHi	: "( " + pmonCounterEn + ") & (("+ csrPortOut("CNTCR"+n, "SSRCount")+" == 3'b001) | "+ csrPortOut("CNTCR"+n, "SSRCount")+" == 3'b100)", //
			reset	: pmonCounterClr,
			mode    : csrPortOut("CNTCR"+n, "SSRCount")+" == 3'b100"
		}
	  };
	  const resources32					= create64BitCounter("CoreCount"+n, inputs64BitCounter);


	  //Generate counters for Bins
	 /* istanbul ignore else env ncore_3p4 */
	  if (n < numBins/2 && numLatencyInterface != 0) {
		const inputsBinCounter 			= {
			inEvent1	: {name: spclEvents.binEvts[2*n].name+"val", width : 1},	// All multi-bit inputs are assumed to be objects with properties: { name, width }
			inEvent2 	: {name: spclEvents.binEvts[2*n+1].name+"val", width : 1},
			control	: {
			enLo	: "( " + pmonCounterEn + ") & ("+ csrPortOut("CNTCR"+n, "CounterCtl")+" != 3'b011)",
			enHi	: "( " + pmonCounterEn + ") & (("+ csrPortOut("CNTCR"+n, "SSRCount")+" == 3'b001) | "+ csrPortOut("CNTCR"+n, "SSRCount")+" == 3'b100)", //
			reset	: pmonCounterClr,
			mode    : csrPortOut("CNTCR"+n, "SSRCount")+" == 3'b100"
			}
		};	

		const resourcesbins					= create64BitCounter("CoreBin"+n, inputsBinCounter);
		tmrEvtMap.push( ...resourcesbins.tmrEvtMap );
	}
	


	  // Generate resources for Load-counter
	  const loadInputs					= {
		inEvent	: muxresclr,
		control	: {
			en		: "( " + pmonCounterEn + ") & ("+ csrPortOut("CNTCR"+n, "CounterCtl")+" == 3'b011)",
			reset	: pmonCounterClr
		}
	  };
	  const resourcesLoader				= createLoader("CoreLoad"+n, loadInputs);

	  // Generate resources for IIR filter
	  const filterInputs				= { 
		inEvent	: muxresclr, 
		alpha,
		control	: {
			en		: "( " + pmonCounterEn + ") & ("+ csrPortOut("CNTCR"+n, "SSRCount")+"== 3'b010)", 
			reset	: pmonCounterClr
		}
	  };
	  const resourcesFilter				= createFilter("CoreFilt"+n, filterInputs, { precision });
		
		
	  // Generate resources for Saturation Counter
	  const inputsMax					= {
		inEvent	: muxresclr,
		control	: {
			en		: "( " + pmonCounterEn + ") & ("+ csrPortOut("CNTCR"+n, "SSRCount")+"== 3'b011)",
			reset	: pmonCounterClr
		}
	  };
	  const resourcesMax				= createMax("CoreMax"+n, inputsMax);


	  // Club all resources together
	  [resources32, resourcesStallCountA, resourcesStallCountB, resourcesLoader, resourcesFilter, resourcesMax].forEach( resourceGrp => {
		 /* istanbul ignore else env ncore_3p2, ncore_3p4, ncore_3p6, ncore_3p7 */
	  	if(resourceGrp.tmrEvtMap)
	  		tmrEvtMap.push( ...resourceGrp.tmrEvtMap );
	  	
	  	if(resourceGrp.evtDefines)
	  		evtDefines.push( ...resourceGrp.evtDefines );
	  });
	
	}
	  	
	return { tmrEvtMap, evtDefines};
}

function createPipedEvent( inEvent ) {
  return { name: inEvent.name+"piped_", signals: inEvent.signals };
}

//=============================================================================
// Instantiate Interfaces
//=============================================================================
u.nInterfaces(interfaces);

\jsend
module \=u.getModuleName()=\ (\=u.getPorts('\n    ')=\); \jsbegin

var addlEvents    = {};

addlEvents.ncrFilterEvts   = [];
addlEvents.ovfHiEvts = [];
addlEvents.ovfLoEvts = [];
addlEvents.binEvts  = [];


for(let n=0; n<nPerfCounters; n++) {
   addlEvents.ncrFilterEvts.push({
	name: "ncr_filter_evt_"+n+"_",
	"interface": "InterfaceEvt",
	direction: "slave",
	params: {width: 1}
   });
   addlEvents.ovfHiEvts.push({
	name : "evtOut_ovf_hi_CoreCount"+n+"_",
	"interface": "InterfaceEvt",
	direction: "master",
	params: { width: 1 }
   });
   addlEvents.ovfLoEvts.push({
	name : "evtOut_ovf_lo_CoreCount"+n+"_",
	"interface": "InterfaceEvt",
	direction: "master",
	params: { width: 1 }
   });
}

for (var i = 0; i < numBins; i++){
   addlEvents.binEvts.push({
        name: "bins"+i+"_",
        "interface": "InterfaceEvt",
        direction: "slave",
        params: {width: 1}
   });
}

 /* istanbul ignore else env ncore_3p4 */
if (interfaces.masterTriggerInterface && (interfaces.masterTriggerInterface.direction == "slave")){
   addlEvents.mainTriggerEvt  = {
     name : "main_trigger_",
     "interface": "InterfaceEvt",
     direction: "slave",
     params: { width: 1 }
   };  \jsend

    \=declareNewStyleInterface(addlEvents.mainTriggerEvt)=\ \jsbegin
}  

// Create an pipedAddlEvents object with same keys as 
// addlEvents, but with old-style interface definitions
const pipedAddlEvents = {};

Object.entries(addlEvents).forEach( ([key, value]) => {   // [ [key1, value1], [key2, value2], ... ]
  if( Array.isArray(value) ) {
    pipedAddlEvents[key] = inEvtPipeEn ? value.map(newToOldStyleInterface).map( createPipedEvent ) :  /* istanbul ignore next env ncore_3p4, ncore_3p6, ncore_3p7 */ value.map(newToOldStyleInterface);

  } else {
    pipedAddlEvents[key] = inEvtPipeEn ? createPipedEvent( newToOldStyleInterface(value) ):  /* istanbul ignore next env ncore_3p4, ncore_3p6, ncore_3p7 */ newToOldStyleInterface(value);

  }
});
 
// Generate resources (timer and event defintions) for pmon_stats)core
const evtInterfacesOldStyle			= interfaces.evtInterfaces.map( newToOldStyleInterface );
const pipedEvents					= inEvtPipeEn ? evtInterfacesOldStyle.map( createPipedEvent ) :  /* istanbul ignore next env ncore_3p4, ncore_3p6, ncore_3p7 */ evtInterfacesOldStyle;
const resources						= generateNcorePmonResourceDefs(pipedEvents, pipedAddlEvents, nPerfCounters);

 /* istanbul ignore else env ncore_3p4, ncore_3p6, ncore_3p7 */
if(inEvtPipeEn) {
  // Add events defined for flops on input events to the above resources
  evtInterfacesOldStyle.forEach( (evtInterface,i) => {

    const inputs						= {
      inEvent : { name: evtInterface.name+"val", width: evtInterface.signals.val },
	  //control : { en: csrPortOut("CNTCR"+n, "CountEn"), clear: csrPortOut("CNTCR"+n, "CountClr") }
	  control : { en: "1'b1", clear: "1'b0" }
    };

    const flop						= addFlop( pipedEvents[i].name+"val", inputs );
    resources.evtDefines.push( ...flop.evtDefines );
  });

  Object.entries(addlEvents).forEach( ([ key, value ]) => {
    const evtInterfaces         = Array.isArray( value ) ? value : [value];
    const evtInterfacesOldStyle = evtInterfaces.map( newToOldStyleInterface );
    const pipedEvents                   = evtInterfacesOldStyle.map( createPipedEvent );
    
    evtInterfacesOldStyle.forEach( (evtInterface,i) => {
      const inputs						= {
        inEvent : { name: evtInterface.name+"val", width: evtInterface.signals.val },
	  //control : { en: csrPortOut("CNTCR"+n, "CountEn"), clear: csrPortOut("CNTCR"+n, "CountClr") }
	  control : { en: "1'b1", clear: "1'b0" }
      };

      const flop						= addFlop( pipedEvents[i].name+"val", inputs );
      resources.evtDefines.push( ...flop.evtDefines );
    });
  });
}


// Build csrInterface of pmon_stats_core
const includeOutSynonyms			=[]; // Array of synonym objects to be included in the csrinterface passed to the pmon_stats_core
const includeInSynonyms				=[]; // Array of synonym objects to be included in the csrinterface passed to the pmon_stats_core

resources.tmrEvtMap.forEach( tmr => {
	const synonyms					= csrSynonymsFromTmr( tmr );
	includeInSynonyms.push( ...synonyms.inputs );
	includeOutSynonyms.push( ...synonyms.outputs );
});

const excludeList					=[];

for (let i=0; i < nPerfCounters; i++) {
	excludeList.push( 
		getHWPortName("CNTVR"+i, "CountVal", "in"), 
		getHWPortName("CNTVR"+i, "CountVal", "wr"),
		getHWPortName("CNTSR"+i, "CountSatVal", "in"),
		getHWPortName("CNTSR"+i, "CountSatVal", "wr"), 
	    getHWPortName("CNTCR"+i, "InterruptEn", "out"),
		getHWPortName("CNTVR"+i, "CountVal", "out"),
		getHWPortName("CNTSR"+i, "CountSatVal", "out"),
		getHWPortName("CNTCR"+i, "OverFlowStatus", "in"),
		getHWPortName("CNTCR"+i, "OverFlowStatus", "wr"),
		getHWPortName("CNTCR"+i, "CountClr", "in"),
		getHWPortName("CNTCR"+i, "CountClr", "wr"),
		getHWPortName("CNTCR"+i, "CountEn", "in"),
		getHWPortName("CNTCR"+i, "CountEn", "wr")

	);
}

 excludeList.push(getHWPortName("LCNTCR", "LatencyPreScale", "out"), 
	         getHWPortName("LCNTCR", "LatencyCountEn", "out"),
		 getHWPortName("LCNTCR", "RdWrLatency", "out"),
		 getHWPortName("LCNTCR", "LatencyBinOffset", "out" ),
		 getHWPortName("MCNTCR", "LocalCountClear", "in"),
		 getHWPortName("MCNTCR", "LocalCountClear", "wr")
		 );


const pmonStatsCsrInterface		= {
	name: interfaces.csrInterface.name,
	synonyms: {
		"in": 	interfaces.csrInterface.synonyms["in"].filter( x => !excludeList.includes(x.name) ).concat( includeInSynonyms ),
		"out": 	interfaces.csrInterface.synonyms["out"].filter( x => !excludeList.includes(x.name) ).concat( includeOutSynonyms )
	},
	"interface": "InterfaceGeneric",
	direction: "slave",
	synonymsExpand: true,
	synonymsOn: true
}; \jsend

// Local wire declarations \jsbegin
const local							= {};  // An object (dictionary) of local wire names
var intClkInterface = newToOldStyleInterface(interfaces.clkInterface);


includeInSynonyms.concat( includeOutSynonyms ).forEach( synonym => {
	local[ interfaces.csrInterface.name + synonym.name ]			= synonym.width;
});

for (let i=0; i < nPerfCounters; i++) {
	local["evtOut_ovf_hi"+"_"+"CoreCount"+i+"_val"]	= 1;
	local["evtOut_ovf_lo"+"_"+"CoreCount"+i+"_val"]	= 1;
	local["ncr_filter_evt"+"_"+i+"_val"] = 1; 

} 
for (var i = 0; i< numBins; i++){
    local["bins"+i+"_val"] = 1;	
  } \jsend



\=bundleFunctions.wiresFromInterface("", local, [], obj.lib.bundle)=\
wire local_count_trig;
wire master_count_trig;
wire master_count_posedge;
wire master_count_negedge;
 wire dff_enable = 1'b1;

 \jsbegin
 /* istanbul ignore else env ncore_3p4, ncore_3p6, ncore_3p7 */
if (csrPortWidth("MCNTCR", "LocalCountEnable", "out") != 0) { \jsend
  wire \=csrPortOut("MCNTCR", "LocalCountEnable")=\_prev;
   wire \=csrPortOut("MCNTCR", "LocalCountEnable")=\_posedge;
  wire \=csrPortOut("MCNTCR", "LocalCountEnable")=\_negedge;

  \=u.dffre(1, csrPortOut("MCNTCR", "LocalCountEnable")+"_prev", csrPortOut("MCNTCR", "LocalCountEnable"), "1'b0", 'dff_enable',  intClkInterface.name+"clk",  intClkInterface.name+'reset_n')=\

  assign \=csrPortOut("MCNTCR", "LocalCountEnable")=\_posedge = \=csrPortOut("MCNTCR", "LocalCountEnable")=\ && ~\=csrPortOut("MCNTCR", "LocalCountEnable")=\_prev;
  assign \=csrPortOut("MCNTCR", "LocalCountEnable")=\_negedge = \=csrPortOut("MCNTCR", "LocalCountEnable")=\_prev && ~\=csrPortOut("MCNTCR", "LocalCountEnable")=\;
  assign local_count_trig = \=csrPortOut("MCNTCR", "LocalCountEnable")=\_posedge || \=csrPortOut("MCNTCR", "LocalCountEnable")=\_negedge;  \jsbegin 
}

if (addlEvents.mainTriggerEvt && (addlEvents.mainTriggerEvt.direction == "slave")) { \jsend
  wire \=addlEvents.mainTriggerEvt.name=\val_prev;
  \=u.dffre(1, addlEvents.mainTriggerEvt.name+"val_prev", addlEvents.mainTriggerEvt.name+"val", "1'b0", 'dff_enable',  intClkInterface.name+"clk",  intClkInterface.name+'reset_n')=\
  assign master_count_posedge = ~\=addlEvents.mainTriggerEvt.name=\val_prev && \=addlEvents.mainTriggerEvt.name=\val;
  assign master_count_negedge =  \=addlEvents.mainTriggerEvt.name=\val_prev && ~\=addlEvents.mainTriggerEvt.name=\val; \jsbegin
}
else { \jsend
   
  wire \=csrPortOut("MCNTCR", "MasterCountEnable")=\_prev;
  \=u.dffre(1, csrPortOut("MCNTCR", "MasterCountEnable")+"_prev", csrPortOut("MCNTCR", "MasterCountEnable"), "1'b0", 'dff_enable',  intClkInterface.name+"clk",  intClkInterface.name+'reset_n')=\
  assign master_count_posedge = ~\=csrPortOut("MCNTCR", "MasterCountEnable")=\_prev && \=csrPortOut("MCNTCR", "MasterCountEnable")=\;
  assign master_count_negedge = \=csrPortOut("MCNTCR", "MasterCountEnable")=\_prev && ~\=csrPortOut("MCNTCR", "MasterCountEnable")=\; \jsbegin
  } \jsend

assign master_count_trig = master_count_negedge|| master_count_posedge; \jsbegin

 /* istanbul ignore else env ncore_3p4, ncore_3p6, ncore_3p7 */
if (csrPortWidth("MCNTCR", "LocalCountClear", "out") ) { \jsend

	assign \=csrPort("MCNTCR", "LocalCountClear", "in")=\					= 1'b0;
	assign \=csrPort("MCNTCR", "LocalCountClear", "wr")=\					= \=csrPortOut("MCNTCR", "LocalCountClear")=\; \jsbegin
} 

for(let i=0; i< nPerfCounters; i++) { 
	//generate condition for pmonCounterClr
	 /* istanbul ignore else env ncore_3p4, ncore_3p6, ncore_3p7 */
        if (csrPortWidth("MCNTCR", "LocalCountClear", "out") ) {
          var pmonCounterClr = csrPortOut("CNTCR"+i, "CountClr") + " | " + csrPortOut("MCNTCR", "LocalCountClear"); 
        } \jsend

// Map csrInterface to pmonStatsCsrInterface

	assign \=csrPort("CNTCR"+i, "OverFlowStatus", "in")=\			= ~(\=pmonCounterClr=\); 
	assign \=csrPort("CNTCR"+i, "OverFlowStatus", "wr")=\			= ((evtOut_ovf_hi_CoreCount\=i=\_val && \=csrPortOut("CNTCR"+i, "SSRCount")=\ == 3'b001) | (evtOut_ovf_lo_CoreCount\=i=\_val && \=csrPortOut("CNTCR"+i, "SSRCount")=\ == 3'b000)  | (\=pmonCounterClr=\));
	assign \=csrPort("CNTCR"+i, "CountClr", "in")=\				= 1'b0; 
	assign \=csrPort("CNTCR"+i, "CountClr", "wr")=\				= \=csrPortOut("CNTCR"+i, "CountClr")=\; \jsbegin
	 /* istanbul ignore else env ncore_3p4, ncore_3p6, ncore_3p7 */ 
	if (csrPortWidth("MCNTCR", "LocalCountEnable", "out") != 0) { \jsend
	  assign \=csrPort("CNTCR"+i, "CountEn", "in")=\			= master_count_posedge ? 1'b1 : (master_count_negedge ? 1'b0 : \=csrPortOut("MCNTCR", "LocalCountEnable")=\); \jsbegin 
	} \jsend 

	assign \=csrPort("CNTCR"+i, "CountEn", "wr")=\ 				= local_count_trig | master_count_trig; \jsbegin
	
      
	if (i < (numBins/2) && numLatencyInterface != 0 ) { \jsend

 	  assign \=csrPort("CNTVR"+i, "CountVal", "wr")=\					= \=csrPort("CoreCount"+i+"LO_val", "val", "wr")=\ | \=csrPort("CoreLoad"+i+"_val", "val", 		"wr")=\ | \=csrPort("CoreBin"+i+"LO_val", "val", "wr")=\;
  	  assign \=csrPort("CNTVR"+i, "CountVal", "in")=\					= ~\=csrPortOut("LCNTCR", "LatencyCountEn")=\ ? (\=csrPort("CoreCount"+i+"LO_val", "val", 		"wr")=\		? \=csrPort("CoreCount"+i+"LO_val", "val", "in")=\ : \=csrPort("CoreLoad"+i+"_val", "val", "in")=\) : \=csrPort("CoreBin"+i+"LO_val", "val", "in")=\;
 	  assign \=csrPort("CNTSR"+i, "CountSatVal", "wr")=\				= \=csrPort("CoreCount"+i+"HI_val", "val", "wr")=\ | \=csrPort("CoreFilt"+i+"_val", "val", "wr")=\		 | \=csrPort("CoreMax"+i+"_val", "val", "wr")=\ | \=csrPort("CoreBin"+i+"HI_val", "val", "wr")=\;
	  assign \=csrPort("CNTSR"+i, "CountSatVal", "in")=\				= ~\=csrPortOut("LCNTCR", "LatencyCountEn")=\ ? (\=csrPort("CoreCount"+i+"HI_val", "val", "wr")=\		? \=csrPort("CoreCount"+i+"HI_val", "val", "in")=\ :
																	  \=csrPort("CoreFilt"+i+"_val", "val", "wr")=\			? { \=(32 - wCountMax - precision)=\'d0, \=csrPort("CoreFilt"+i+"_val", "val", "in")=\ } :
																	  \=csrPort("CoreMax"+i+"_val", "val", "wr")=\			? { \=(32 - wCountMax)=\'d0, \=csrPort("CoreMax"+i+"_val", "val", "in")=\} :  32'd0) : \=csrPort("CoreBin"+i+"HI_val", "val", "in")=\; 
	  assign \=csrPort("CoreBin"+i+"LO_val", "val", "out")=\			= \=csrPort("CNTVR"+i, "CountVal", "out")=\;
	  assign \=csrPort("CoreBin"+i+"HI_val", "val", "out")=\			= \=csrPort("CNTSR"+i, "CountSatVal", "out")=\;

		\jsbegin
	} else {\jsend
 	  assign \=csrPort("CNTVR"+i, "CountVal", "wr")=\					= \=csrPort("CoreCount"+i+"LO_val", "val", "wr")=\ | \=csrPort("CoreLoad"+i+"_val", "val", 		"wr")=\;
 	  assign \=csrPort("CNTVR"+i, "CountVal", "in")=\					= \=csrPort("CoreCount"+i+"LO_val", "val", "wr")=\	? \=csrPort("CoreCount"+i+			"LO_val", "val", "in")=\ : \=csrPort("CoreLoad"+i+"_val", "val", "in")=\;
 	  assign \=csrPort("CNTSR"+i, "CountSatVal", "wr")=\				= \=csrPort("CoreCount"+i+"HI_val", "val", "wr")=\ | \=csrPort("CoreFilt"+i+"_val", "val", 			"wr")=\ | \=csrPort("CoreMax"+i+"_val", "val", "wr")=\;
	  assign \=csrPort("CNTSR"+i, "CountSatVal", "in")=\				= \=csrPort("CoreCount"+i+"HI_val", "val", "wr")=\	? \=csrPort("CoreCount"+i+"HI_val", "val", 		"in")=\ :
																	  \=csrPort("CoreFilt"+i+"_val", "val", "wr")=\			? { \=(32 - wCountMax - precision)=\'d0, \=csrPort("CoreFilt"+i+"_val", "val", "in")=\ } :
																	  \=csrPort("CoreMax"+i+"_val", "val", "wr")=\			? { \=(32 - wCountMax)=\'d0, \=csrPort("CoreMax"+i+"_val", "val", "in")=\} : 32'd0; \jsbegin 
	} \jsend

	assign \=csrPort("CoreLoad"+i+"_val", "val", "out")=\			= \=csrPort("CNTVR"+i, "CountVal", "out")=\;
	assign \=csrPort("CoreCount"+i+"LO_val", "val", "out")=\		= \=csrPort("CNTVR"+i, "CountVal", "out")=\;
	assign \=csrPort("CoreCount"+i+"HI_val", "val", "out")=\		= \=csrPort("CNTSR"+i, "CountSatVal", "out")=\; 
	assign \=csrPort("CoreFilt"+i+"_val", "val", "out")=\			= \=csrPort("CNTSR"+i, "CountSatVal", "out")=\[\=(wCountMax+precision-1)=\:0]; 
	assign \=csrPort("CoreMax"+i+"_val", "val", "out")=\			= \=csrPort("CNTSR"+i, "CountSatVal", "out")=\[\=(wCountMax-1)=\:0];  \jsbegin
}

//u.setAttribute("resources", resources);
//u.setAttribute("includeOutSynonyms", includeOutSynonyms);
//u.setAttribute("includeInSynonyms", includeInSynonyms);
//===========================================================================================
//Event Filter block
//===========================================================================================

// Create a list of all filter attributes found in filterAttrInterfaces
var attributes = {}; //attributes is a dictionary {"funit_id": max of funit_id_width, "user": max of user_width}

filterAttrInterfaces.forEach(attrInterface => {
	attrInterface.synonyms["out"].forEach(attr => {
		var width = attributes[attr.name] || 0;

		if (width < attr.width)
			attributes[attr.name] = attr.width;
});
});

// Declare registers and fields required by event-filter blocks
var evtFilterRegisters = [
  { name: "BCNTFR", fields: ["FilterVal", "FilterSel", "FilterEn"] },
  { name: "BCNTMR", fields: ["MaskVal"] }
];

// Function to generate csrInterface for the event-filter block
function genEvtFilterCsrOldInterface( name, registers ) {
  const evtFilterCsrInSynonyms     		= [];

  registers.forEach( reg => {
    reg.fields.forEach( field => {
      evtFilterCsrInSynonyms.push({
	 name: getHWPortName(reg.name, field, "out"),
         width: csrPortWidth(reg.name+"0", field, "out")  // All register field widths are computed from the first set of BW registers
      });
    });
  });

  const evtFilterCsrNewInterface = { 
        name, 
        direction: "slave", 
        "interface": "InterfaceGeneric", 
        synonymsOn: true, 
        synonymsExpand: true, 
        synonyms: {"out": [], "in": evtFilterCsrInSynonyms} 
  };

  return newToOldStyleInterface( evtFilterCsrNewInterface); 
}

// Compute csr module interface for event-filter blocks (This is the same for ever instance)
// whereas the csr local interface is different for each instance of the event-filter block
const evtFilterModuleInterface		= genEvtFilterCsrOldInterface("", evtFilterRegisters);
const evtFilterAttrModuleInterface      = {name: "attr_", signals :attributes};


//create instances of ao_muxes for attributes.length
for (var n = 0; n < nPerfCounters; n++){
if(filterAttrInterfaces.length != 0 ){

  var evtFilterLocalInterface	= genEvtFilterCsrOldInterface("evt_filter_csr"+n+"_", evtFilterRegisters);
  var evtFilterAttrInterface	= {name: "attr"+n+"_", signals: attributes};
  var filterAttrMuxOutInterface   	= libUtils.oldStyleToNewStyleGenericInterface( "master", evtFilterAttrInterface); \jsend


  \=bundleFunctions.wiresFromInterface(evtFilterAttrInterface.name, evtFilterAttrInterface.signals, [], obj.lib.bundle)=\
  \=bundleFunctions.wiresFromInterface(evtFilterLocalInterface.name, evtFilterLocalInterface.signals, [], obj.lib.bundle)=\
  wire [\=numFilterAttr-1=\:0] filter_sel\=n=\;
  wire filter_sel_out_valid\=n=\;  \jsbegin
  
 var intAttrGenericMuxInterface = {
  inInterfaces: filterAttrInterfaces ,
  outInterface: filterAttrMuxOutInterface}; 

 for (var k = 0; k < numFilterAttr; k++){ \jsend
   assign filter_sel\=n=\[\=k=\] = (\=csrPortOut("CNTCR"+n, "CntEvtFirst")=\ == \=csrPortWidth("CNTCR0", "CntEvtFirst", "out")=\'d\=bwEvtMapping[k]=\); \jsbegin 
  } \jsend

  \=obj.lib.nInstance({ 
    instanceName : 'attr_interface_generic_mux'+n,
    moduleName : 'interface_generic_mux',
    params: {
        interfaces:  intAttrGenericMuxInterface   },
    interfaceObj: {
		interfaces: intAttrGenericMuxInterface,
		prefixes: intAttrGenericMuxInterface 
    }, 
    ports: {
        sel: 'filter_sel'+n,
	sel_valid: 'filter_sel_out_valid'+n
    }
})=\  \jsbegin


    // Map local csr interface of event-filter block to ncr_pmon csr interface

  evtFilterRegisters.forEach( reg => {
    reg.fields.forEach( field => { \jsend
      assign \=evtFilterLocalInterface.name=\\=getHWPortName(reg.name, field, "out")=\ = \=csrPortOut(reg.name+n, field)=\; \jsbegin
    });
  });


  var EVT_FILT_INTF = [];
  EVT_FILT_INTF.push({modulePrefix: evtFilterAttrModuleInterface.name, localPrefix: evtFilterAttrInterface.name, interface: evtFilterAttrInterface.signals});
  EVT_FILT_INTF.push({modulePrefix: evtFilterModuleInterface.name, localPrefix: evtFilterLocalInterface.name, interface: evtFilterLocalInterface.signals}); \jsend

   \=obj.lib.instance ({
                instanceName: 'event_filter_'+n,
                moduleName: 'event_filter',
                params : {
			csrInterface:  evtFilterModuleInterface,
 			attrInterface: evtFilterAttrModuleInterface				
                          },
                verilogParams : {},
                ports : {filter_evt : 'ncr_filter_evt_'+n+'_val'},
                interfaces : EVT_FILT_INTF})=\ \jsbegin

} else{ \jsend
  assign ncr_filter_evt_\=n=\_val = 1'b1; \jsbegin 
} } 

//create an instance of interface_generin_mux to generate the inputs to the latency counter block 
//===========================================================================================
//Latency Counter block
//===========================================================================================
 /* istanbul ignore else env ncore_3p4 */
if (latencyInterfaces.length != 0){ \jsend
  wire [\=numLatencyInterface-1=\:0] ao_mux_latency_sel;
  wire ao_mux_sel_out_valid; \jsbegin

  for (var k = 0; k < numLatencyInterface; k++){ \jsend 
    assign ao_mux_latency_sel[\=k=\] =  (\=csrPortOut("LCNTCR", "RdWrLatency")=\) == \=csrPortWidth("LCNTCR", "RdWrLatency", "out")=\'d\=k=\; \jsbegin 
  }


  var maxWidthLatencyInterface   = getMaxWidthLatencyInterface( latencyInterfaces );

  var intGenericMuxInterface = {
    inInterfaces: latencyInterfaces,
    outInterface: {
      name: "latency_counter_in_",
      direction: "master",
      "interface": "InterfaceGeneric",
      synonymsOn: true,
      synonymsExpand: true,
      synonyms: maxWidthLatencyInterface.synonyms } 
  }; 

  var oldStyleInterfaceGenericOutInterface = newToOldStyleInterface( intGenericMuxInterface.outInterface ); \jsend
  \=bundleFunctions.wiresFromInterface(oldStyleInterfaceGenericOutInterface.name, oldStyleInterfaceGenericOutInterface.signals, [], obj.lib.bundle)=\
 
  \=obj.lib.nInstance({ 
    instanceName : 'latency_interface_generic_mux',
    moduleName : 'interface_generic_mux',
    params: {
        interfaces:  intGenericMuxInterface   },
    interfaceObj: {
		interfaces: intGenericMuxInterface,
		prefixes: intGenericMuxInterface 
    }, 
    ports: {
        sel: 'ao_mux_latency_sel',
	sel_valid: 'ao_mux_sel_out_valid'
    }})=\

  \jsbegin
 
//Latency_counter_tablle
 
  var LATENCY_INTF = [];
  LATENCY_INTF.push({modulePrefix: oldStyleInterfaceGenericOutInterface.name, localPrefix: oldStyleInterfaceGenericOutInterface.name, interface: oldStyleInterfaceGenericOutInterface.signals});
  LATENCY_INTF.push({modulePrefix: interfaces.clkInterface.name , localPrefix: intClkInterface.name , interface: intClkInterface.signals}); \jsend

wire [\=widthLatencyCntrs-1=\:0] latency_out_cnt_value;
wire latency_out_dealloc_valid;
wire latency_cnt_table_en;
assign latency_cnt_table_en = \=csrPortOut("LCNTCR", "LatencyCountEn")=\ && \=csrPortOut("MCNTCR", "LocalCountEnable")=\;

  \=obj.lib.instance ({
                instanceName: 'latency_counter_table',
                moduleName: 'latency_counter_table',
                params : {
 			latencyInterface: oldStyleInterfaceGenericOutInterface,
			numLatencyEntries : nLatencyCounters, 
			widthLatencyCntrs : widthLatencyCntrs,
			widthLatencyScale: csrPortWidth("LCNTCR", "LatencyPreScale", "out"),
			clkInterface: intClkInterface				
                          },
                verilogParams : {},
                ports : {
			  latency_scale_csr : csrPortOut("LCNTCR", "LatencyPreScale"),
			  latency_cnt_en : 'latency_cnt_table_en',
			  dealloc_valid: 'latency_out_dealloc_valid',
			  cnt_value: 'latency_out_cnt_value'
			},
                interfaces : LATENCY_INTF})=\  

//generating the input to quantizer block
  wire [\=widthLatencyCntrs-1=\:0] latency_offset_corrected_value;
  wire [\=widthLatencyCntrs-1=\:0] extended_lcntcr_offset;
  assign extended_lcntcr_offset =  \=extend(csrPortOut("LCNTCR", "LatencyBinOffset"), csrPortWidth("LCNTCR", "LatencyBinOffset", "out"), widthLatencyCntrs)=\ ;

assign latency_offset_corrected_value = (latency_out_cnt_value > extended_lcntcr_offset) ? (latency_out_cnt_value - \=extend(csrPortOut("LCNTCR", "LatencyBinOffset"), csrPortWidth("LCNTCR", "LatencyBinOffset", "out"), widthLatencyCntrs)=\) : \=widthLatencyCntrs=\'d0; 
 
//instance of quantizer block
  wire [\=numBins-1=\:0] latency_bins;
  wire qntzr_valid_in;
  assign qntzr_valid_in = latency_out_dealloc_valid && \=csrPortOut("LCNTCR", "LatencyCountEn")=\;

  \=obj.lib.instance ({
                instanceName: 'ncr_quantizer',
                moduleName: 'ncr_quantizer',
                params : {
 			widthInput : widthLatencyCntrs,
			binWidths : binWidths				
                          },
                verilogParams : {},
                ports : {
			 count_in: 'latency_offset_corrected_value',
			valid_in: 'qntzr_valid_in',
			ncr_bins: 'latency_bins'
  }})=\  \jsbegin
 } 

  for (var i = 0; i < numBins; i++){ 
    if (nLatencyCounters != 0) { \jsend
      assign bins\=i=\_val = latency_bins[\=i=\]; \jsbegin
    } else { \jsend
    assign bins\=i=\_val = 1'b0; \jsbegin
  } 
}
//=====================================================================================
 //PMON_STATS_CORE instance
//=====================================================================================
const coreEvtInterfaces			= interfaces.evtInterfaces.slice(); // Shallow copy

Object.keys( addlEvents ).sort().forEach( key => {
  var value = addlEvents[key];

  if(Array.isArray( value )) { 
    coreEvtInterfaces.push( ...value ); 

  } else {
    coreEvtInterfaces.push( value );

  }
});

const coreInterfaces			= {
	clkInterface	: interfaces.clkInterface,
	csrInterface	: pmonStatsCsrInterface,
	evtInterfaces	: coreEvtInterfaces
}; 

if (interfaces.masterTriggerInterface && (interfaces.masterTriggerInterface.direction == "slave")) { \jsend

assign \=addlEvents.mainTriggerEvt.name=\val = \= masterOldInterface.name=\trigger;

\jsbegin
}
else { \jsend
assign \=masterOldInterface.name=\trigger = \=csrPortOut("MCNTCR", "MasterCountEnable")=\; 
\jsbegin
} \jsend



	// Instantiate PMON Stats:
	\=u.nInstance({
      instanceName: 'u_pmon_stats_core',
      moduleName: 'pmon_stats_core',
      params: Object.assign({}, resources, { interfaces: coreInterfaces }),
      interfaceObj: {
		interfaces: coreInterfaces,
		prefixes: coreInterfaces 
      }
	})=\




endmodule
