//=============================================================================
// Copyright (C) 2018 Arteris, Inc.
// All rights reserved.
//=============================================================================
\jsbegin
// Memory FIFO  module
//
// The FIFO is used as an elastic store for data which is stored in an external memory.
//=============================================================================
\jsend

\jsbegin
var u               = obj.lib;
var log2ceil        = function(n) { return Math.ceil(Math.log(n)/Math.LN2); };

//-----------------------------------------------------------------------------
// Default Parameters

u.paramDefault('zerodepth'   , 'int'   , 0);
u.paramDefault('bypass_mode' , 'int'   , 0);
u.paramDefault('fastread'    , 'int'   , 1);

//-----------------------------------------------------------------------------
// Top Level Parameters

var width           = u.getParam('width');
var depth           = u.getParam('depth');
var zerodepth       = u.getParam('zerodepth');
var bypass_mode     = u.getParam('bypass_mode');
var logDepth        = log2ceil(depth);
var logDepthp1      = logDepth + 1;
var logDepthm1      = logDepth - 1;
/* istanbul ignore next env ncore_3p7 */
var wOccCnt         = log2ceil(depth+1);
var fastread        = u.getParam('fastread');
var hoqout          = 'pop_data_array';
var rdptr           = 'rd_ptr';
var memoryInterface = u.getParam('memoryInterface');

//=============================================================================
// Clock and Reset Interface
//=============================================================================

u.port('input', 'clk', 1);
u.port('input', 'reset_n', 1);

//=============================================================================
// FIFO Interface
//=============================================================================

u.port('input',  'push_valid', 1);
u.port('input',  'push_data',  width);
u.port('output', 'push_ready', 1);
u.port('output', 'pop_valid',  1);
u.port('output', 'pop_data',   width);
u.port('input',  'pop_ready',  1);
u.port('output', 'empty',  1);
u.port('output', 'corr_error',  1);
u.port('output', 'ucorr_error',  1);
u.port('input',  'corr_data',  width);
u.port('input',  'corr_mem',  1);
u.port('input',  'ucorr_mem',  1);

//=============================================================================
// External Memory Interface
//=============================================================================

obj.lib.interface('', 'master', memoryInterface);
\jsend

module \=u.getModuleName()=\ (
\=u.getPorts('\n    ')=\
);
\jsbegin
//=============================================================================
// Internal Wires and Registers
//=============================================================================
// This double port FIFO does not support external memory with error correction
\jsend

\jsbegin
// ALways have fastread on.
/* istanbul ignore else env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6 */
if (fastread ) {
\jsend
wire  [\=width-1=\:0]      fr_data;
\js }

wire [\=logDepthp1-1=\:0] rd_ptr;
reg  [\=logDepthp1-1=\:0] rd_ptr_nxt;
wire [\=logDepthp1-1=\:0] wr_ptr;
reg  [\=logDepthp1-1=\:0] wr_ptr_nxt;

reg  [\=width-1=\:0]      pop_data_array;
reg                       r_do_read;
wire                      r_conflict;
wire                      r_empty;

wire                      full;
wire                      do_write;
wire                      do_read;
wire                      pop_readyack;
wire                      s_empty;
wire                      s_empty_nxt;

//-----------------------------------------------------------------------------
// Conflict occurs if there is a write to the same address as a read

\=u.dffre(       1
              , 'r_conflict'
	      , '(do_write & (int_address_write == int_address_read))'
	      , "1'b0"
	      , "1'b1"
	      , 'clk'
	      , 'reset_n')=\
	      
//-----------------------------------------------------------------------------
// External Memory Connections

assign int_chip_en_read  = 1'b1; 
assign int_chip_en_write = do_write;
assign int_data_in       = push_data;
assign int_address_write = wr_ptr[\=logDepthm1=\:0];
assign int_address_read  = (do_read) ? rd_ptr_nxt[\=logDepthm1=\:0] : rd_ptr[\=logDepthm1=\:0];

assign pop_readyack      = pop_ready;

//-----------------------------------------------------------------------------
// Empty Control Logic -> Drives pop_valid, and Full Control Logic -> Drives push_ready
wire r_valid;
assign empty             = ~(r_empty);// | s_empty;
assign s_empty           = (rd_ptr[\=logDepth=\:0] == wr_ptr[\=logDepth=\:0]);
assign s_empty_nxt       = (do_write & do_read) ?  (rd_ptr_nxt[\=logDepth=\:0] == wr_ptr_nxt[\=logDepth=\:0]) :
                           (do_read           ) ?  (rd_ptr_nxt[\=logDepth=\:0] == wr_ptr[\=logDepth=\:0])     :
			   (do_write          ) ?  (rd_ptr[\=logDepth=\:0]     == wr_ptr_nxt[\=logDepth=\:0]) :
			                           (rd_ptr[\=logDepth=\:0]     == wr_ptr[\=logDepth=\:0]);

\=u.dffre(       1
              , 'r_empty'
	      , '~(s_empty | s_empty_nxt)'
	      , "1'b0"
	      , "1'b1"
	      , 'clk'
	      , 'reset_n')=\

\jsbegin
// ALways have fastread on.
/* istanbul ignore else env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
if (fastread) {
\jsend
\=u.dffre(       1
              , 'r_valid'
	      , '~(s_empty | s_empty_nxt) | (do_write & (int_address_write == int_address_read))'
	      , "1'b0"
	      , "1'b1"
	      , 'clk'
	      , 'reset_n')=\
\js } else {
\=u.dffre(       1
              , 'r_valid'
	      , '~(s_empty | s_empty_nxt) & ~(do_write & (int_address_write == int_address_read))'
	      , "1'b0"
	      , "1'b1"
	      , 'clk'
	      , 'reset_n')=\
\js}

\jsbegin
// Have minimum depth of 2
/* istanbul ignore else env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
if (depth > 1) {
\jsend
assign full = (rd_ptr[\=logDepth=\] != wr_ptr[\=logDepth=\]) & (rd_ptr[\=logDepth-1=\:0] == wr_ptr[\=logDepth-1=\:0]);
\jsbegin
} else {
\jsend
assign full = (rd_ptr[\=logDepth=\] != wr_ptr[\=logDepth=\]);
\jsbegin
} //if (depth > 1)

//-----------------------------------------------------------------------------
// pop_valid, push_ready , do_write, and do_read control logic

// Bypass Mode always off
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6 */
if (bypass_mode) {
\jsend
assign pop_valid          = r_empty | push_valid;
assign do_write           = push_ready & push_valid & ~(empty & pop_readyack);
assign do_read            = pop_readyack & ~empty;
\jsbegin
} else {
\jsend
\jsbegin
// ALways have fastread on.
/* istanbul ignore else env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6 */
if (fastread) {
\jsend
assign pop_valid          = r_valid; 
\js } else {
assign pop_valid          = r_valid; 
\js }
assign do_write           = push_ready & push_valid;
assign do_read            = pop_ready & pop_valid;
\jsbegin
} //if (bypass_mode)
\jsend
assign push_ready         = ~full;

//-----------------------------------------------------------------------------
// Read Pointer Logic

\=u.dffre(       logDepthp1
              , 'rd_ptr'
	      , 'rd_ptr_nxt'
	      , '{'+logDepthp1+'{1\'b0}}'
	      , 'do_read'
	      , 'clk'
	      , 'reset_n')=\
\jsbegin
// Minimum Depth of 2
/* istanbul ignore else env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
if (depth > 1) {
\jsend
always @ (*)
        if (rd_ptr[\=logDepthm1=\:0] == \=logDepth=\'d\=depth-1=\)
            rd_ptr_nxt = { ~rd_ptr[\=logDepth=\], \=logDepth=\'b0 };
        else
            rd_ptr_nxt = rd_ptr + \=logDepthp1=\'b1;
\jsbegin
} else {
\jsend
    always @ (*)
            rd_ptr_nxt = rd_ptr + \=logDepthp1=\'b1;
\jsbegin
} // if (depth > 1)
\jsend

//-----------------------------------------------------------------------------
// Write Pointer Logic

always @ (*) begin
        //if (~reset_n)
        //    wr_ptr <= 'b0;
        //else if (do_write)

\jsbegin
// Minimum Depth of 2
/* istanbul ignore else env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
if (depth > 1) {
\jsend
            if (wr_ptr[\=logDepthm1=\:0] == \=logDepth=\'d\=depth-1=\)
                wr_ptr_nxt = { ~wr_ptr[\=logDepth=\], \=logDepth=\'b0 };
            else
                wr_ptr_nxt = wr_ptr + \=logDepthp1=\'b1;
	end
\jsbegin
} else {
\jsend
                wr_ptr_nxt = wr_ptr + \=logDepthp1=\'b1;
	end
\jsbegin
} // if (depth > 1)
\jsend

\=u.dffre(       logDepthp1
              , 'wr_ptr'
	      , 'wr_ptr_nxt'
	      , '{'+logDepthp1+'{1\'b0}}'
	      , 'do_write'
	      , 'clk'
	      , 'reset_n')=\

//-----------------------------------------------------------------------------
// Pop Data Logic - Drived from 
// 1) Memory 
// 2) If fastread is enabled it could come from an internal register if a conflict occurs.

always @(*)
\jsbegin
// Minimum Depth of 2
/* istanbul ignore else env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6 */
if (depth > 1 ) {
\jsend
  begin
	       pop_data_array = int_data_out;
  end
\jsbegin
}

// Bypass mode always off
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
if (bypass_mode) {
\jsend
                assign pop_data = empty ? push_data : \=hoqout=\;
\jsbegin
} else {
\jsend
            \jsbegin
            // Always have fast read on
            /* istanbul ignore else env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
            if (fastread) {
	    \jsend
	        assign {corr_error,ucorr_error,pop_data} = r_conflict ? {2'b0,fr_data} : {corr_mem,ucorr_mem,\=hoqout=\};
	    \js } else {
                assign {corr_error,ucorr_error,pop_data} = {corr_mem,ucorr_error,\=hoqout=\};
	    \js }
\jsbegin
} // if (depth > 1)
\jsend

//-----------------------------------------------------------------------------
// fastread provides a 1 cycle latency at the cost of area and timing.
// - This register holds the push_data to be poped the first cycle of memory lookup

\jsbegin
// Always have fast read on
/* istanbul ignore else env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6 */
if ( fastread ) {
\jsend

\=u.dffre(       width
              , 'fr_data'
	      , 'push_data'
	      , '{'+width+'{1\'b0}}'
	      , "1'b1"
	      , 'clk'
	      , 'reset_n')=\
\js }
				    
endmodule
