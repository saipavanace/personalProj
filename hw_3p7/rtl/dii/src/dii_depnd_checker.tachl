\jsbegin
    var u = obj.lib;
\jsend

\jsbegin

    var log2ceil = function(n) { return Math.ceil(Math.log(n)/Math.LN2); };
    
    var assertOn                         = u.getParam('assertOn');
    var rtt_num_entries                  = u.getParam('nRttEntries');
    var wtt_num_entries                  = u.getParam('nWttEntries');
    var wAddr                            = u.getParam('wAddr');
    var wArid                            = u.getParam('wArid');
    var wAwid                            = u.getParam('wAwid');
    var wAxid                            = Math.max(wArid, wAwid);
    var wCacheLineOffset                 = u.getParam('wCacheLineOffset');
    var waddr                            = wAddr - wCacheLineOffset;
    var rtt_id_width                     = log2ceil(rtt_num_entries);
    var wtt_id_width                     = log2ceil(wtt_num_entries);
    var tt_id_width                      = u.getParam('tt_id_width');
    var init_id_width                    = u.getParam('wFUnitId');
    var wLargestEndpoint                 = u.getParam('wLargestEndpoint');
    var device_size_mask_msb_bit         = 12;
    var wMpf2                            = u.getParam('wMpf2');
    var axi_id_comp_width                = u.getParam('axi_id_comp_width');
    var nExclusiveEntries  = u.getParam('nExclusiveEntries');
    //var wtt_id_width                   = Math.min(log2ceil(wtt_num_entries),wAwid);
    //var rtt_id_width                   = Math.min(log2ceil(rtt_num_entries),wAwid);    
\jsend

\jsbegin
//=============================================================================
// ports
//=============================================================================
    u.port('input',  'clk', 1);
    u.port('input',  'reset_n', 1);
    u.port('input',  'csr_exclude_ro_write_from_wo', 1);
    u.port('input',  'csr_exclude_initiator_from_ordering', 1);
    u.port('input',  'rtt_allocate_new_entry', 1);
    u.port('input',  'wtt_allocate_new_entry', 1);
    u.port('output', 'pmon_address_collision', 1);
    u.port('input',  'req_addr',               wAddr);
    u.port('input',  'req_prot',               3); // Used for ns
    u.port('input',  'req_order',              2); //00 - no order, 01 - ro order, 10 - eo order, 11 - wo order
    u.port('input',  'init_id',                init_id_width);
    u.port('input',  'rtt_next_axi_id',        wArid);
    u.port('input',  'rtt_next_entry_id',      rtt_id_width);    
    u.port('input',  'wtt_next_axi_id',        wAwid);
    u.port('input',  'wtt_next_entry_id',      wtt_id_width);    
    u.port('input',  'rtt_new_axi_id',         wArid);
    u.port('input',  'wtt_new_axi_id',         wAwid);
    u.port('input',  'rtt_muxarb_grant',       rtt_num_entries);
    u.port('input',  'wtt_muxarb_grant',       wtt_num_entries);
    u.port('input',  'rtt_grant_given',        rtt_num_entries);
    u.port('input',  'wtt_grant_given',        wtt_num_entries);
    u.port('input',  'rtt_grant_given_in',     rtt_num_entries);
    u.port('input',  'wtt_grant_given_in',     wtt_num_entries);
    u.port('input',  'rtt_retire_entry_cmo',   rtt_num_entries);
    u.port('input',  'rtt_retire_entry',       rtt_num_entries);
    u.port('input',  'wtt_retire_entry',       wtt_num_entries);
    u.port('output', 'rtt_ro_match_rd',        1);
    u.port('output', 'rtt_ro_match_wr',        1);
    u.port('output', 'rtt_eo_match_rd',        1);
    u.port('output', 'rtt_eo_match_wr',        1);
    u.port('output', 'wtt_addr_ewa_match',     1);
    u.port('output', 'rd_ro_depnd_set',        1);
    u.port('output', 'rd_eo_depnd_set',        1);
    u.port('output', 'rd_axi_depnd_set',       1);
    u.port('output', 'rd_sleep_set',           1);
    u.port('output', 'wtt_ro_match_rd',        1);
    u.port('output', 'wtt_ro_match_wr',        1);
    u.port('output', 'wtt_eo_match_rd',        1);
    u.port('output', 'wtt_eo_match_wr',        1); 
    u.port('output', 'wtt_wo_match_wr',        1);
    u.port('output', 'wr_ro_depnd_set',        1);
    u.port('output', 'wr_eo_depnd_set',        1);
    u.port('output', 'wr_wo_depnd_set',        1);
    u.port('output', 'wr_axi_depnd_set',       1);
    u.port('output', 'wr_sleep_set',           1);
    u.port('output', 'rtt_cmo_match',          1);
    u.port('input',  'tt_cmo',                 1);
    u.port('input',  'tt_lock',                1);
    u.port('input',  'tt_mpf2',                wMpf2);
    u.port('output', 'addr_match_on_wtt',      1);
    u.port('output', 'addr_match_on_rtt',      1);    
    u.port('output', 'addr_match_rtt',         rtt_num_entries);
    u.port('output', 'init_id_match_rtt',      rtt_num_entries);        
    u.port('output', 'rd_ro_depnd_clear',      rtt_num_entries);
    u.port('output', 'rd_eo_depnd_clear',      rtt_num_entries);
    u.port('output', 'rd_axi_depnd_clear',     rtt_num_entries);
    u.port('output', 'rd_sleep_clear',         rtt_num_entries);
    u.port('output', 'addr_match_wtt',         wtt_num_entries);
    u.port('output', 'init_id_match_wtt',      wtt_num_entries);       
    u.port('output', 'wr_ro_depnd_clear',      wtt_num_entries);
    u.port('output', 'wr_eo_depnd_clear',      wtt_num_entries);
    u.port('output', 'wr_wo_depnd_clear',      wtt_num_entries);
    u.port('output', 'wr_axi_depnd_clear',     wtt_num_entries);
    u.port('output', 'wr_sleep_clear',         wtt_num_entries);
    u.port('output', 'rd_axi_depnd_id_entry',  rtt_num_entries);
    u.port('output', 'wr_axi_depnd_id_entry',  wtt_num_entries);
    u.port('output', 'wtt_addr_ewa_match_id',  wtt_num_entries);
    u.port('output', 'rd_ro_depnd_id',         tt_id_width);
    u.port('output', 'rd_eo_depnd_id',         tt_id_width);
    u.port('output', 'rd_axi_depnd_id',        tt_id_width);
    u.port('output', 'wr_ro_depnd_id',         tt_id_width);
    u.port('output', 'wr_eo_depnd_id',         tt_id_width);
    u.port('output', 'wr_wo_depnd_id',         tt_id_width);
    u.port('output', 'wr_axi_depnd_id',        tt_id_width);
    u.port('output', 'wr_axi_id',              wAxid);
    u.port('output', 'rd_axi_id',              wAxid);        
    u.port('output', 'ro_match_rtt_id',        rtt_num_entries);
    u.port('output', 'eo_match_rtt_id',        rtt_num_entries);
    u.port('output', 'ro_match_wtt_id',        wtt_num_entries);
    u.port('output', 'eo_match_wtt_id',        wtt_num_entries);
    u.port('output', 'wo_match_wtt_id',        wtt_num_entries);

for (var i = 0; i < rtt_num_entries; i++) {
    obj.lib.interface('rtt_entry'+i+'_', 'master', obj.lib.getParam('TTentryCtl'), ['oldest','ewa', 'wr_enable', 'clear', 'resp_pending', 'wo_depnd_id', 'wo_depnd', 'youngest_wo','ex_pass']);
 };

for (var i = 0; i < wtt_num_entries; i++) {
    obj.lib.interface('wtt_entry'+i+'_', 'master', obj.lib.getParam('TTentryCtl'), ['oldest','cmo','resp_pending','wr_enable', 'clear'] );
 };

\jsend

module \=u.getModuleName()=\
(
\=u.getPorts('\n    ')=\
);

wire [\=rtt_num_entries-1=\:0]  wo_match_rtt_id;
wire [\=rtt_num_entries-1=\:0]  ro_match_rtt_depnd;
wire [\=rtt_num_entries-1=\:0]  eo_match_rtt_depnd;
wire [\=rtt_num_entries-1=\:0]  wo_match_rtt_depnd;
wire                            axi_new_match_rtt_id;
wire [\=rtt_id_width-1=\:0]     axi_match_rtt_id;
wire [\=rtt_num_entries-1=\:0]  end_device_match_rtt;
wire [\=rtt_num_entries-1=\:0]  rtt_cmo_match_vec;
wire [\=wtt_num_entries-1=\:0]  ro_match_wtt_depnd;
wire [\=wtt_num_entries-1=\:0]  eo_match_wtt_depnd;
wire [\=wtt_num_entries-1=\:0]  wo_match_wtt_depnd;
wire [\=wtt_num_entries-1=\:0]  dont_hit_failed_write;
wire [\=wtt_num_entries-1=\:0]  addr_wtt_match;
wire [\=rtt_num_entries-1=\:0]  addr_rtt_match;
wire                            axi_new_match_wtt_id;
wire [\=wtt_id_width-1=\:0]     axi_match_wtt_id;
wire [\=wtt_num_entries-1=\:0]  end_device_match_wtt;
wire [\=tt_id_width-1=\:0]      read_grant_id;
wire [\=tt_id_width-1=\:0]      write_grant_id;
wire [\=wArid-1=\:0]            read_grant_axid;
wire [\=wAwid-1=\:0]            write_grant_axid;
wire [\=tt_id_width-1=\:0]      read_comp_id;
wire [\=tt_id_width-1=\:0]      cmo_comp_id;
wire [\=tt_id_width-1=\:0]      write_comp_id;
wire [\=rtt_id_width-1=\:0]     axi_match_rtt_id_v1;
wire [\=wtt_id_width-1=\:0]     axi_match_wtt_id_v1;
wire [\=wtt_id_width-1=\:0]     axi_new_match_wtt_entry_id;
wire [\=rtt_id_width-1=\:0]     axi_new_match_rtt_entry_id;
wire [\=tt_id_width-1=\:0]      rtt_ro_depnd_id_v1;
wire [\=tt_id_width-1=\:0]      wtt_ro_depnd_id_v1;
wire [\=tt_id_width-1=\:0]      wtt_eo_depnd_id_v1;
wire [\=wtt_id_width-1=\:0]     wtt_wo_depnd_id_v1;
wire [\=tt_id_width-1=\:0]      rtt_ro_axi_depnd_id_v1;
wire [\=tt_id_width-1=\:0]      wtt_ro_axi_depnd_id_v1;
wire [\=tt_id_width-1=\:0]      rtt_eo_axi_depnd_id_v1;
wire [\=tt_id_width-1=\:0]      wtt_eo_axi_depnd_id_v1;
wire [\=wtt_id_width-1=\:0]     wtt_wo_axi_depnd_id_v1;
wire                            rtt_ro_match;
wire                            rtt_ro_match_depnd;
wire                            rtt_ro_match_depnd_rd;
wire                            rtt_ro_match_depnd_wr;
wire                            wtt_ro_match;
wire                            wtt_ro_match_depnd;
wire                            wtt_ro_match_depnd_rd;
wire                            wtt_ro_match_depnd_wr;
wire                            rtt_eo_match;
wire                            rtt_eo_match_depnd;
wire                            rtt_eo_match_depnd_rd;
wire                            rtt_eo_match_depnd_wr;
wire                            wtt_eo_match;
wire                            wtt_eo_match_depnd;
wire                            wtt_eo_match_depnd_rd;
wire                            wtt_eo_match_depnd_wr;
wire                            wtt_wo_match;
wire                            wtt_wo_match_depnd;
wire                            wtt_wo_match_depnd_wr;
wire                            rtt_grant;
wire                            wtt_grant;
wire                            cmo_retire;
wire                            rtt_retire;
wire                            wtt_retire;
wire                            axi_new_match_wtt;
wire                            axi_new_match_rtt;
wire                            rd_axi_depnd_set_cancel;
wire                            wr_axi_depnd_set_cancel;
wire                            rtt_ro_match_sent;
wire                            rtt_eo_match_sent;
wire                            wtt_ro_match_sent;
wire                            wtt_eo_match_sent;
wire                            wtt_wo_match_sent;
wire                            force_dependency_rtt;
wire                            force_dependency_wtt_eo_ro;
wire                            force_dependency_wtt_ro_wo;
wire                            force_dependency_wtt_eo_wo;

wire                            force_dependency_rtt_eo;
wire                            force_dependency_rtt_ro;
wire                            force_dependency_wtt_eo;
wire                            force_dependency_wtt_ro;
wire                            force_dependency_wtt_wo;

// CONC-5209 - Need to set the dependency if the dependency in question has already sent the transaction AND it matches with anything else. This is needed to keep sleep asserted until that dependency is gone.
assign force_dependency_rtt_eo = (rtt_eo_match & (wtt_ro_match | rtt_ro_match)) & (rtt_eo_match_sent);
assign force_dependency_rtt_ro = (rtt_ro_match & (wtt_eo_match | rtt_eo_match)) & (rtt_ro_match_sent);

assign force_dependency_wtt_eo = (wtt_eo_match & (wtt_eo_match | rtt_ro_match | wtt_wo_match))                & (wtt_eo_match_sent);
assign force_dependency_wtt_ro = (wtt_ro_match & (wtt_eo_match | rtt_eo_match | wtt_wo_match))                & (wtt_ro_match_sent);
assign force_dependency_wtt_wo = (wtt_wo_match & (wtt_eo_match | rtt_ro_match | rtt_eo_match | wtt_ro_match)) & (wtt_wo_match_sent);

//------------------------------------------
// Clock retired read and/or write
//   - These values are used to clear an EO,RO,AXI dependancy in the case that the dependancy
//     is on an entry that retired the cycle the new entry was allocated.
//   - This was a timing fix. Previously there would be no match with an entry that is retiring that cycle.
//     However this made a long path from the AXI responce all the way to the dependancy logic which is already large.
//     So now there can be a match to an entry that just retired but it will be cleared the next cycle.
//   - This adds a cycle of latency to transactions that have a dependancy match to an entry that just retired which is a rare occurence.

wire                       r_rtt_retire;
wire [\=tt_id_width-1=\:0] r_read_comp_id;
wire                       r_wtt_retire;
wire [\=tt_id_width-1=\:0] r_write_comp_id;

// Below will probably not be needed for <1.6GHz
wire                       r_cmo_retire;
wire [\=tt_id_width-1=\:0] r_cmo_comp_id;

\=u.dffre(  1
          , 'r_rtt_retire'
	  , 'rtt_retire'
	  , "1'b0"
	  , "1'b1"
	  , 'clk'
	  , 'reset_n')=\

\=u.dffre(  tt_id_width
          , 'r_read_comp_id'
	  , 'read_comp_id'
	  , '{'+tt_id_width+'{1\'b0}}'
	  , "1'b1"
	  , 'clk'
	  , 'reset_n')=\

\=u.dffre(  1
          , 'r_wtt_retire'
	  , 'wtt_retire'
	  , "1'b0"
	  , "1'b1"
	  , 'clk'
	  , 'reset_n')=\

// Below will probably not be needed for <1.6GHz

\=u.dffre(  tt_id_width
          , 'r_write_comp_id'
	  , 'write_comp_id'
	  , '{'+tt_id_width+'{1\'b0}}'
	  , "1'b1"
	  , 'clk'
	  , 'reset_n')=\

\=u.dffre(  1
          , 'r_cmo_retire'
	  , 'cmo_retire'
	  , "1'b0"
	  , "1'b1"
	  , 'clk'
	  , 'reset_n')=\

\=u.dffre(  tt_id_width
          , 'r_cmo_comp_id'
	  , 'cmo_comp_id'
	  , '{'+tt_id_width+'{1\'b0}}'
	  , "1'b1"
	  , 'clk'
	  , 'reset_n')=\

//RO dependency checking fr RTT entry
\jsbegin
       for (var entry = 0 ; entry < rtt_num_entries ; entry++) {
\jsend

       assign addr_match_rtt[\=entry=\] = ({rtt_entry\=entry=\_prot[1],rtt_entry\=entry=\_addr[ \=wAddr=\ - 1: \=wCacheLineOffset=\]} == {req_prot[1],req_addr[\=wAddr=\ -1: \=wCacheLineOffset=\]});

       assign addr_rtt_match[\=entry=\] = addr_match_rtt[\=entry=\] & rtt_entry\=entry=\_valid & ((req_order == 2'b00) || (req_order == 2'b01));

       assign rtt_cmo_match_vec[\=entry=\]   = addr_match_rtt[\=entry=\] & rtt_entry\=entry=\_cmo & rtt_entry\=entry=\_valid & tt_cmo;

\js if (nExclusiveEntries) {
       assign init_id_match_rtt[\=entry=\] = 1'b1;
\js} else {
       assign init_id_match_rtt[\=entry=\] = csr_exclude_initiator_from_ordering ? 1'b1 : (rtt_entry\=entry=\_init_id == init_id);
\js }

       assign ro_match_rtt_id[\=entry=\] =  ( rtt_entry\=entry=\_youngest_ro & 
                                              addr_match_rtt[\=entry=\] &
					      init_id_match_rtt[\=entry=\] &  
                                              (
					        ((req_order == 2'b10) &  //RO request 
                                                 (rtt_entry\=entry=\_ordering == 2'b10 | rtt_entry\=entry=\_ordering == 2'b11)) |
						((req_order == 2'b11) &  //EO request 
                                                 (rtt_entry\=entry=\_ordering == 2'b10))
                                              )
                                            );

       assign ro_match_rtt_depnd[\=entry=\] = ro_match_rtt_id[\=entry=\];


\jsbegin

              }
\jsend

\js //DONE : Write an assertion to check that there are no multiple matches in ro_match_rtt_id.

      wire rtt_cmo_match_vec_or;
      wire ro_match_rtt_id_or;
      wire ro_match_rtt_depnd_or;
      
      \=u.instance({
        portsDelimiter: '\n    ',
        instanceName: 'u_rtt_cmo_match',
        moduleName:   'logic_tree',
        params: {
          'width' : rtt_num_entries,
          'logic' : '|'},
        ports: {
          'din'  : 'rtt_cmo_match_vec',
          'dout' : 'rtt_cmo_match_vec_or'}})=\

      \=u.instance({
        portsDelimiter: '\n    ',
        instanceName: 'u_rtt_ro_match',
        moduleName:   'logic_tree',
        params: {
          'width' : rtt_num_entries,
          'logic' : '|'},
        ports: {
          'din'  : 'ro_match_rtt_id',
          'dout' : 'ro_match_rtt_id_or'}})=\

      \=u.instance({
        portsDelimiter: '\n    ',
        instanceName: 'u_rtt_ro_match_depnd',
        moduleName:   'logic_tree',
        params: {
          'width' : rtt_num_entries,
          'logic' : '|'},
        ports: {
          'din'  : 'ro_match_rtt_depnd',
          'dout' : 'ro_match_rtt_depnd_or'}})=\

      assign rtt_cmo_match          =  rtt_cmo_match_vec_or;

      assign rtt_ro_match           =  ro_match_rtt_id_or ;
      assign rtt_ro_match_rd        =  ro_match_rtt_id_or & rtt_allocate_new_entry;
      assign rtt_ro_match_wr        =  ro_match_rtt_id_or & wtt_allocate_new_entry;
      assign addr_match_on_rtt      =  (|addr_rtt_match); 

      assign rtt_ro_match_depnd     =  ro_match_rtt_depnd_or;
      assign rtt_ro_match_depnd_rd  =  ro_match_rtt_depnd_or & rtt_allocate_new_entry;
      assign rtt_ro_match_depnd_wr  =  ro_match_rtt_depnd_or & wtt_allocate_new_entry;

      assign rtt_ro_match_sent      = (rtt_ro_match & !rtt_ro_match_depnd);

\jsbegin
var rtt_ro_depnd_id_v1_ports = {};
var rtt_ro_axi_depnd_id_v1_ports = {};

for (i=0; i<rtt_num_entries ;i++) {
         rtt_ro_depnd_id_v1_ports['in'+i] = tt_id_width+"'d"+i;
         rtt_ro_axi_depnd_id_v1_ports['in'+i] = tt_id_width+"'d"+i;
}

rtt_ro_depnd_id_v1_ports['sel']   = "ro_match_rtt_depnd";
rtt_ro_depnd_id_v1_ports['out']   = "rtt_ro_depnd_id_v1";

rtt_ro_axi_depnd_id_v1_ports['sel']   = "ro_match_rtt_id";
rtt_ro_axi_depnd_id_v1_ports['out']   = "rtt_ro_axi_depnd_id_v1";


\jsend
    
\=u.instance({
        instanceName: 'u_rtt_ro_depnd_id_v1',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : rtt_num_entries,
                        wMux             : tt_id_width
        },
        verilogParams: {},
        ports: rtt_ro_depnd_id_v1_ports
})=\

\=u.instance({
        instanceName: 'u_rtt_ro_axi_depnd_id_v1',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : rtt_num_entries,
                        wMux             : tt_id_width
        },
        verilogParams: {},
        ports: rtt_ro_axi_depnd_id_v1_ports
})=\

//RO dependency checking for WTT entry
// 
\jsbegin
       for (var entry = 0 ; entry < wtt_num_entries ; entry++) {
\jsend
       assign addr_match_wtt[\=entry=\]     = ({wtt_entry\=entry=\_prot[1],wtt_entry\=entry=\_addr[ \=wAddr=\ - 1: \=wCacheLineOffset=\]} == {req_prot[1],req_addr[\=wAddr=\ -1: \=wCacheLineOffset=\]});
       
       assign wtt_addr_ewa_match_id[\=entry=\] = addr_match_wtt[\=entry=\] & wtt_entry\=entry=\_ewa;

       assign addr_wtt_match[\=entry=\] = addr_match_wtt[\=entry=\] & wtt_entry\=entry=\_valid & (req_order == 2'b00 || req_order == 2'b01);

\js if (nExclusiveEntries) {
       assign init_id_match_wtt[\=entry=\] = 1'b1;
\js } else {
       assign init_id_match_wtt[\=entry=\] = csr_exclude_initiator_from_ordering ? 1'b1 : (wtt_entry\=entry=\_init_id == init_id);
\js }

       assign ro_match_wtt_id[\=entry=\] =  (wtt_entry\=entry=\_youngest_ro &
                                             addr_match_wtt[\=entry=\] &
					     init_id_match_wtt[\=entry=\] &
                                             (  ((req_order == 2'b01) & (wtt_entry\=entry=\_ordering == 2'b01)) |
					        ((req_order == 2'b10) &  //RO/WO request 
                                                 (wtt_entry\=entry=\_ordering == 2'b10 | wtt_entry\=entry=\_ordering == 2'b11)) |
						((req_order == 2'b11) &  //EO request 
                                                 (wtt_entry\=entry=\_ordering == 2'b10)) 
                                              )
                                        );

       assign ro_match_wtt_depnd[\=entry=\] = ro_match_wtt_id[\=entry=\];



\jsbegin
                }
\jsend

\js //DONE : Write an assertion to check that there are no multiple matches in ro_match_wtt_id.

      wire ro_match_wtt_id_or;
      wire ro_match_wtt_depnd_or;
      wire wtt_addr_ewa_match_id_or;

      \=u.instance({
        portsDelimiter: '\n    ',
        instanceName: 'u_wtt_ro_match',
        moduleName:   'logic_tree',
        params: {
          'width' : wtt_num_entries,
          'logic' : '|'},
        ports: {
          'din'  : 'ro_match_wtt_id',
          'dout' : 'ro_match_wtt_id_or'}})=\

      \=u.instance({
        portsDelimiter: '\n    ',
        instanceName: 'u_wtt_ro_match_depnd',
        moduleName:   'logic_tree',
        params: {
          'width' : wtt_num_entries,
          'logic' : '|'},
        ports: {
          'din'  : 'ro_match_wtt_depnd',
          'dout' : 'ro_match_wtt_depnd_or'}})=\

      \=u.instance({
        portsDelimiter: '\n    ',
        instanceName: 'u_wtt_ewa_match_depnd',
        moduleName:   'logic_tree',
        params: {
          'width' : wtt_num_entries,
          'logic' : '|'},
        ports: {
          'din'  : 'wtt_addr_ewa_match_id',
          'dout' : 'wtt_addr_ewa_match_id_or'}})=\
	  
      assign wtt_ro_match      =  ro_match_wtt_id_or;
      assign wtt_ro_match_rd   =  ro_match_wtt_id_or & rtt_allocate_new_entry;
      assign wtt_ro_match_wr   =  ro_match_wtt_id_or & wtt_allocate_new_entry;
      assign addr_match_on_wtt =  (|addr_wtt_match); 

      assign wtt_ro_match_depnd     =  ro_match_wtt_depnd_or ;
      assign wtt_ro_match_depnd_rd  =  ro_match_wtt_depnd_or & rtt_allocate_new_entry;
      assign wtt_ro_match_depnd_wr  =  ro_match_wtt_depnd_or & wtt_allocate_new_entry;

      assign wtt_ro_match_sent      = (wtt_ro_match & !wtt_ro_match_depnd);
      assign wtt_addr_ewa_match     =  wtt_addr_ewa_match_id_or;
      
\jsbegin
var wtt_ro_depnd_id_v1_ports = {};
var wtt_ro_axi_depnd_id_v1_ports = {};

for (i=0; i<wtt_num_entries ;i++) {
         wtt_ro_depnd_id_v1_ports['in'+i] = tt_id_width+"'d"+i;
         wtt_ro_axi_depnd_id_v1_ports['in'+i] = tt_id_width+"'d"+i;
}

wtt_ro_depnd_id_v1_ports['sel']   = "ro_match_wtt_depnd";
wtt_ro_depnd_id_v1_ports['out']   = "wtt_ro_depnd_id_v1";

wtt_ro_axi_depnd_id_v1_ports['sel']   = "ro_match_wtt_id";
wtt_ro_axi_depnd_id_v1_ports['out']   = "wtt_ro_axi_depnd_id_v1";


\jsend
    
\=u.instance({
        instanceName: 'u_wtt_ro_depnd_id_v1',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : wtt_num_entries,
                        wMux             : tt_id_width
        },
        verilogParams: {},
        ports: wtt_ro_depnd_id_v1_ports
})=\

\=u.instance({
        instanceName: 'u_wtt_ro_axi_depnd_id_v1',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : wtt_num_entries,
                        wMux             : tt_id_width
        },
        verilogParams: {},
        ports: wtt_ro_axi_depnd_id_v1_ports
})=\


//Set the RO dependency to either RTT or WTT entry for reads if there is a hit       
       assign rd_ro_depnd_id =  wtt_ro_match_rd ? wtt_ro_axi_depnd_id_v1:rtt_ro_match_rd ? rtt_ro_axi_depnd_id_v1 :   \=tt_id_width=\'b0; 
       assign rd_ro_depnd_set =  (rtt_ro_match_depnd_rd | wtt_ro_match_rd) | (force_dependency_rtt_ro & rtt_allocate_new_entry);           



//Set the RO dependency to either RTT or WTT entry for writes if there is a hit 
       assign wr_ro_depnd_id =  wtt_ro_match_wr ? wtt_ro_axi_depnd_id_v1 : rtt_ro_match_wr ? rtt_ro_axi_depnd_id_v1 :  \=tt_id_width=\'b0;
       assign wr_ro_depnd_set =  (rtt_ro_match_wr | wtt_ro_match_depnd_wr)  | (force_dependency_wtt_ro & wtt_allocate_new_entry);


//EO dependency checking for RTT entries

\jsbegin
       for (var entry = 0 ; entry < rtt_num_entries ; entry++) {
\jsend

\jsbegin
			/* istanbul ignore if env ncore_3p7 */
		   if(wLargestEndpoint >= wAddr) { \jsend
       assign end_device_match_rtt[\=entry=\] = (rtt_entry\=entry=\_prot[1] == req_prot[1]);
\js } else { 
       assign end_device_match_rtt[\=entry=\] = ({rtt_entry\=entry=\_prot[1],rtt_entry\=entry=\_addr[ \=wAddr=\ - 1: \=wLargestEndpoint=\]} == {req_prot[1],req_addr[\=wAddr=\ -1: \=wLargestEndpoint=\]});
\js }

//      assign eo_match_rtt_id[\=entry=\] =  (
//                                            rtt_entry\=entry=\_muxarb_valid &  rtt_entry\=entry=\_youngest_eo &
//                                            end_device_match_rtt & init_id_match_rtt[\=entry=\] &
//                                           ((req_order == 2'b11) &  //EO request
//                                           (rtt_entry\=entry=\_ordering == 2'b11)
//                                           )
//                                         );

      assign eo_match_rtt_id[\=entry=\] =  (
                                            rtt_entry\=entry=\_youngest_eo &
                                            end_device_match_rtt[\=entry=\] & init_id_match_rtt[\=entry=\] & rtt_entry\=entry=\_youngest_eo &
                                           ((req_order == 2'b11) &  //EO request
                                           (rtt_entry\=entry=\_ordering == 2'b11)
                                           )
                                         );

      assign eo_match_rtt_depnd[\=entry=\] = eo_match_rtt_id[\=entry=\];

\jsbegin
                }
\jsend

\js //DONE : Write an assertion to check that there are no multiple matches in eo_match_rtt_id.

      wire eo_match_rtt_id_or;
      wire eo_match_rtt_depnd_or;

      \=u.instance({
        portsDelimiter: '\n    ',
        instanceName: 'u_rtt_eo_match',
        moduleName:   'logic_tree',
        params: {
          'width' : rtt_num_entries,
          'logic' : '|'},
        ports: {
          'din'  : 'eo_match_rtt_id',
          'dout' : 'eo_match_rtt_id_or'}})=\

      \=u.instance({
        portsDelimiter: '\n    ',
        instanceName: 'u_rtt_eo_match_depnd',
        moduleName:   'logic_tree',
        params: {
          'width' : rtt_num_entries,
          'logic' : '|'},
        ports: {
          'din'  : 'eo_match_rtt_depnd',
          'dout' : 'eo_match_rtt_depnd_or'}})=\
	  
      assign rtt_eo_match           =  eo_match_rtt_id_or;
      assign rtt_eo_match_rd        =  eo_match_rtt_id_or & rtt_allocate_new_entry;
      assign rtt_eo_match_wr        =  eo_match_rtt_id_or & wtt_allocate_new_entry;

      assign rtt_eo_match_depnd     =  eo_match_rtt_depnd_or;
      assign rtt_eo_match_depnd_rd  =  eo_match_rtt_depnd_or & rtt_allocate_new_entry;
      assign rtt_eo_match_depnd_wr  =  eo_match_rtt_depnd_or & wtt_allocate_new_entry;

      assign rtt_eo_match_sent = (rtt_eo_match & !rtt_eo_match_depnd);

\jsbegin
var rtt_eo_axi_depnd_id_v1_ports = {};

for (i=0; i<rtt_num_entries ;i++) {
         rtt_eo_axi_depnd_id_v1_ports['in'+i] = tt_id_width+"'d"+i;
}

rtt_eo_axi_depnd_id_v1_ports['sel']   = "eo_match_rtt_id";
rtt_eo_axi_depnd_id_v1_ports['out']   = "rtt_eo_axi_depnd_id_v1";

\jsend
    
\=u.instance({
        instanceName: 'u_rtt_eo_axi_depnd_id_v1',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : rtt_num_entries,
                        wMux             : tt_id_width
        },
        verilogParams: {},
        ports: rtt_eo_axi_depnd_id_v1_ports
})=\

//EO dependency checking for WTT entries

\jsbegin
       for (var entry = 0 ; entry < wtt_num_entries ; entry++) {
\jsend

\jsbegin
			/* istanbul ignore if env ncore_3p7 */
		   if(wLargestEndpoint >= wAddr) { \jsend
     assign end_device_match_wtt[\=entry=\] = (wtt_entry\=entry=\_prot[1] == req_prot[1]);
\js } else {
     assign end_device_match_wtt[\=entry=\] = ({wtt_entry\=entry=\_prot[1],wtt_entry\=entry=\_addr[ \=wAddr=\ - 1: \=wLargestEndpoint=\]} == {req_prot[1],req_addr[\=wAddr=\ -1: \=wLargestEndpoint=\]});
\js }

//      assign eo_match_wtt_id[\=entry=\] =  (
//                                             wtt_entry\=entry=\_muxarb_valid &  wtt_entry\=entry=\_youngest_eo &
//                                               ((req_order == 2'b11) &  //EO request
//                                                 end_device_match_wtt & init_id_match_wtt[\=entry=\] &
//                                                (wtt_entry\=entry=\_ordering == 2'b11)
//                                               )
//                                           );

      assign eo_match_wtt_id[\=entry=\] =  (   
                                               ((req_order == 2'b11) &  wtt_entry\=entry=\_youngest_eo & //EO request
                                                 end_device_match_wtt[\=entry=\] & init_id_match_wtt[\=entry=\]  &
                                                (wtt_entry\=entry=\_ordering == 2'b11)
                                               )
                                           );


      assign eo_match_wtt_depnd[\=entry=\] = eo_match_wtt_id[\=entry=\];


\jsbegin
                }
\jsend

\js //DONE : Add assertOn parameter.
  
\js // SVA : No two bits are asserted at the same time inside eo_match_wtt_id
\js //genvar gv_eo_wtt_id_bit;
\js //generate
\js //for (gv_eo_wtt_id_bit = 0; gv_eo_wtt_id_bit < \=wtt_num_entries=\; gv_eo_wtt_id_bit++) begin
\js //  eo_match_wtt_id_single_assert: assert property (@(posedge eo_match_wtt_id[gv_eo_wtt_id_bit]) (!eo_match_wtt_id[gv_eo_wtt_id_bit] | &(~(eo_match_wtt_id & ~(1'b1 << gv_eo_wtt_id_bit))))); 
\js //end
\js //endgenerate

      wire eo_match_wtt_id_or;
      wire eo_match_wtt_depnd_or;

      \=u.instance({
        portsDelimiter: '\n    ',
        instanceName: 'u_wtt_eo_match',
        moduleName:   'logic_tree',
        params: {
          'width' : wtt_num_entries,
          'logic' : '|'},
        ports: {
          'din'  : 'eo_match_wtt_id',
          'dout' : 'eo_match_wtt_id_or'}})=\

      \=u.instance({
        portsDelimiter: '\n    ',
        instanceName: 'u_wtt_eo_match_depnd',
        moduleName:   'logic_tree',
        params: {
          'width' : wtt_num_entries,
          'logic' : '|'},
        ports: {
          'din'  : 'eo_match_wtt_depnd',
          'dout' : 'eo_match_wtt_depnd_or'}})=\


      assign wtt_eo_match     =  eo_match_wtt_id_or;
      assign wtt_eo_match_rd  =  eo_match_wtt_id_or & rtt_allocate_new_entry;
      assign wtt_eo_match_wr  =  eo_match_wtt_id_or & wtt_allocate_new_entry;

      assign wtt_eo_match_depnd     =  eo_match_wtt_depnd_or ;
      assign wtt_eo_match_depnd_rd  =  eo_match_wtt_depnd_or & rtt_allocate_new_entry;
      assign wtt_eo_match_depnd_wr  =  eo_match_wtt_depnd_or & wtt_allocate_new_entry;

      assign wtt_eo_match_sent      = (wtt_eo_match & !wtt_eo_match_depnd );

\jsbegin
var wtt_eo_depnd_id_v1_ports = {};
var wtt_eo_axi_depnd_id_v1_ports = {};

for (i=0; i<wtt_num_entries ;i++) {
         wtt_eo_depnd_id_v1_ports['in'+i] = tt_id_width+"'d"+i;
         wtt_eo_axi_depnd_id_v1_ports['in'+i] = tt_id_width+"'d"+i;
}

wtt_eo_depnd_id_v1_ports['sel']   = "eo_match_wtt_depnd";
wtt_eo_depnd_id_v1_ports['out']   = "wtt_eo_depnd_id_v1";

wtt_eo_axi_depnd_id_v1_ports['sel']   = "eo_match_wtt_id";
wtt_eo_axi_depnd_id_v1_ports['out']   = "wtt_eo_axi_depnd_id_v1";

\jsend
    
\=u.instance({
        instanceName: 'u_wtt_eo_depnd_id_v1',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : wtt_num_entries,
                        wMux             : tt_id_width
        },
        verilogParams: {},
        ports: wtt_eo_depnd_id_v1_ports
})=\

\=u.instance({
        instanceName: 'u_wtt_eo_axi_depnd_id_v1',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : wtt_num_entries,
                        wMux             : tt_id_width
        },
        verilogParams: {},
        ports: wtt_eo_axi_depnd_id_v1_ports
})=\


//Set the EO dependency to either RTT or WTT entry for reads if there is a hit
       assign rd_eo_depnd_id =  rtt_eo_match_rd ? rtt_eo_axi_depnd_id_v1 : wtt_eo_match_rd ? wtt_eo_axi_depnd_id_v1 :  \=tt_id_width=\'b0;
       assign rd_eo_depnd_set =  (rtt_eo_match_depnd_rd | wtt_eo_match_rd) | (force_dependency_rtt_eo & rtt_allocate_new_entry);


//Set the EO dependency to either RTT or WTT entry for writes if there is a hit
       assign wr_eo_depnd_id =  rtt_eo_match_wr ? rtt_eo_axi_depnd_id_v1 : wtt_eo_match_wr ? wtt_eo_axi_depnd_id_v1 :  \=tt_id_width=\'b0;
       assign wr_eo_depnd_set =  (rtt_eo_match_wr | wtt_eo_match_depnd_wr)  | (force_dependency_wtt_eo  & wtt_allocate_new_entry);



//WO dependency checking for WTT entries

\jsbegin
       for (var entry = 0 ; entry < wtt_num_entries ; entry++) {
\jsend

      assign wo_match_wtt_id[\=entry=\] =  (
                                           ((~csr_exclude_ro_write_from_wo & (req_order == 2'b10)) | req_order == 2'b11 | (req_order == 2'b01)) & init_id_match_wtt[\=entry=\] &
                                            wtt_entry\=entry=\_youngest_wo &  //WO request
                                           ((~csr_exclude_ro_write_from_wo & (wtt_entry\=entry=\_ordering == 2'b10)) | wtt_entry\=entry=\_ordering == 2'b11 | wtt_entry\=entry=\_ordering == 2'b01)
                                           );


      assign wo_match_wtt_depnd[\=entry=\] = wo_match_wtt_id[\=entry=\];

\jsbegin
                }
\jsend

\js //DONE : Write an assertion to check that there are no multiple matches in wo_match_wtt_id.

      wire wo_match_wtt_id_or;
      wire wo_match_wtt_depnd_or;

      \=u.instance({
        portsDelimiter: '\n    ',
        instanceName: 'u_wtt_wo_match',
        moduleName:   'logic_tree',
        params: {
          'width' : wtt_num_entries,
          'logic' : '|'},
        ports: {
          'din'  : 'wo_match_wtt_id',
          'dout' : 'wo_match_wtt_id_or'}})=\

      \=u.instance({
        portsDelimiter: '\n    ',
        instanceName: 'u_wtt_wo_match_depnd',
        moduleName:   'logic_tree',
        params: {
          'width' : wtt_num_entries,
          'logic' : '|'},
        ports: {
          'din'  : 'wo_match_wtt_depnd',
          'dout' : 'wo_match_wtt_depnd_or'}})=\
	  
      assign wtt_wo_match     =  wo_match_wtt_id_or;
      assign wtt_wo_match_wr  =  wo_match_wtt_id_or & wtt_allocate_new_entry;

      assign wtt_wo_match_depnd     =  wo_match_wtt_depnd_or;
      assign wtt_wo_match_depnd_wr  =  wo_match_wtt_depnd_or & wtt_allocate_new_entry;

      assign wtt_wo_match_sent      = (wtt_wo_match & !wtt_wo_match_depnd );

\jsbegin
var wtt_wo_depnd_id_v1_ports = {};
var wtt_wo_axi_depnd_id_v1_ports = {};

for (i=0; i<wtt_num_entries ;i++) {
         wtt_wo_depnd_id_v1_ports['in'+i] = wtt_id_width+"'d"+i;
         wtt_wo_axi_depnd_id_v1_ports['in'+i] = wtt_id_width+"'d"+i;
}

wtt_wo_depnd_id_v1_ports['sel']   = "wo_match_wtt_depnd";
wtt_wo_depnd_id_v1_ports['out']   = "wtt_wo_depnd_id_v1";

wtt_wo_axi_depnd_id_v1_ports['sel']   = "wo_match_wtt_id";
wtt_wo_axi_depnd_id_v1_ports['out']   = "wtt_wo_axi_depnd_id_v1";

\jsend
    
\=u.instance({
        instanceName: 'u_wtt_wo_depnd_id_v1',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : wtt_num_entries,
                        wMux             : wtt_id_width
        },
        verilogParams: {},
        ports: wtt_wo_depnd_id_v1_ports
})=\

\=u.instance({
        instanceName: 'u_wtt_wo_axi_depnd_id_v1',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : wtt_num_entries,
                        wMux             : wtt_id_width
        },
        verilogParams: {},
        ports: wtt_wo_axi_depnd_id_v1_ports
})=\


//Set the WO dependency to WTT entry for writes if there is a hit
       \js if (tt_id_width == wtt_id_width) {
       assign wr_wo_depnd_id  =  wtt_wo_match_wr ?    wtt_wo_axi_depnd_id_v1 :  \=tt_id_width=\'b0;
       \js } else {
       assign wr_wo_depnd_id  =  wtt_wo_match_wr ?  {\=tt_id_width-wtt_id_width=\'b0,wtt_wo_axi_depnd_id_v1} :  \=tt_id_width=\'b0;       
       \js }
       
       assign wr_wo_depnd_set =  wtt_wo_match_depnd_wr | (force_dependency_wtt_wo& wtt_allocate_new_entry);

//AXI dependency checking
//Set AXI dependency only if the write request is either dependent on an older RO or EO request. If the write request is dependent on more than one EO ,RO or WO write request or on a read request, it is put to sleep. The requests that have axi dependencies can be issued with the same AXI ID  after the older request is issued.
// The AXI dependancy can also be set if all AXI IDs are in use. The RTT entry will have an AXI dependancy on the youngest entry with  a matching AXI ID. 
//For requests that are put to sleep, they can be woken up only when the request/s on which it is dependent on, completes.

       assign rd_axi_depnd_set =  axi_new_match_rtt;

       // This just needs to match the youngest entry with the selected axi
       \js if (tt_id_width == rtt_id_width) {
       assign rd_axi_depnd_id = axi_match_rtt_id_v1; 
       \js } else {
       assign rd_axi_depnd_id = {\=tt_id_width-rtt_id_width=\'b0,axi_match_rtt_id_v1};        
       \js }
       
       assign rd_axi_depnd_id_entry =  (ro_match_rtt_id |  eo_match_rtt_id );


       assign wr_axi_depnd_set =  axi_new_match_wtt;

       // This just needs to match the youngest entry with the selected axi
       \js if (tt_id_width == wtt_id_width) {
       assign wr_axi_depnd_id =  axi_match_wtt_id_v1;
       \js } else {
       assign wr_axi_depnd_id =  {\=tt_id_width-wtt_id_width=\'b0,axi_match_wtt_id_v1};       
       \js }
       
       assign wr_axi_depnd_id_entry =   ( ro_match_wtt_id |  eo_match_wtt_id | wo_match_wtt_id );
   
//Sleep
       assign rd_sleep_set = (rtt_ro_match & rtt_eo_match) | (wtt_ro_match | wtt_eo_match) | (tt_lock & (rtt_ro_match | rtt_eo_match));
       
       assign wr_sleep_set = (wtt_ro_match & wtt_eo_match) | (wtt_ro_match & wtt_wo_match) | (wtt_eo_match & wtt_wo_match) |
                             (rtt_ro_match | rtt_eo_match) | (tt_lock & (wtt_ro_match | wtt_wo_match | wtt_eo_match));

//Oldest entry set

//Calculating the tt id of the read that was given a mux grant and was issued

\jsbegin
var read_grant_ports = {};
var cmo_comp_ports = {};
var read_comp_ports = {};

for (i=0; i<rtt_num_entries ;i++) {
         read_grant_ports['in'+i] = tt_id_width+"'d"+i;
         cmo_comp_ports['in'+i] = tt_id_width+"'d"+i;
         read_comp_ports['in'+i] = tt_id_width+"'d"+i;
}

read_grant_ports['sel']   = "rtt_muxarb_grant";
read_grant_ports['out']   = "read_grant_id";

cmo_comp_ports['sel']   = "rtt_retire_entry_cmo";
cmo_comp_ports['out']   = "cmo_comp_id";

read_comp_ports['sel']   = "rtt_retire_entry";
read_comp_ports['out']   = "read_comp_id";

\jsend
    
\=u.instance({
        instanceName: 'u_read_grant',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : rtt_num_entries,
                        wMux             : tt_id_width
        },
        verilogParams: {},
        ports: read_grant_ports
})=\

\=u.instance({
        instanceName: 'u_cmo_comp',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : rtt_num_entries,
                        wMux             : tt_id_width
        },
        verilogParams: {},
        ports: cmo_comp_ports
})=\

\=u.instance({
        instanceName: 'u_read_comp',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : rtt_num_entries,
                        wMux             : tt_id_width
        },
        verilogParams: {},
        ports: read_comp_ports
})=\

\jsbegin
var read_axid_ports = {};

for (i=0; i<rtt_num_entries ;i++) {
         read_axid_ports['in'+i] = "rtt_entry"+i+"_axi_id["+wArid+"-1:0]";	 
}
read_axid_ports['sel']   = "rtt_muxarb_grant";
read_axid_ports['out']   = "read_grant_axid";
\jsend

\=u.instance({
        instanceName: 'u_read_axid',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : rtt_num_entries,
                        wMux             : wArid
        },
        verilogParams: {},
        ports: read_axid_ports
})=\

\jsbegin
var write_grant_ports = {};
var write_comp_ports = {};
var write_axid_ports = {};

for (i=0; i<wtt_num_entries ;i++) {
         write_grant_ports['in'+i] = tt_id_width+"'d"+i;
         write_comp_ports['in'+i] = tt_id_width+"'d"+i;
         write_axid_ports['in'+i] = "wtt_entry"+i+"_axi_id["+wAwid+"-1:0]";	 
}

write_grant_ports['sel']   = "wtt_muxarb_grant";
write_grant_ports['out']   = "write_grant_id";

write_comp_ports['sel']   = "wtt_retire_entry";
write_comp_ports['out']   = "write_comp_id";

write_axid_ports['sel']   = "wtt_muxarb_grant";
write_axid_ports['out']   = "write_grant_axid";
\jsend
    
\=u.instance({
        instanceName: 'u_write_grant',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : wtt_num_entries,
                        wMux             : tt_id_width
        },
        verilogParams: {},
        ports: write_grant_ports
})=\


\=u.instance({
        instanceName: 'u_write_comp',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : wtt_num_entries,
                        wMux             : tt_id_width
        },
        verilogParams: {},
        ports: write_comp_ports
})=\


\=u.instance({
        instanceName: 'u_write_axid',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : wtt_num_entries,
                        wMux             : wAwid
        },
        verilogParams: {},
        ports: write_axid_ports
})=\
// Logic OR Trees to indicate WTT add RTT entries either being granted or retired

\=u.instance({
   portsDelimiter: '\n    ',
   instanceName: 'u_rtt_grant',
   moduleName:   'logic_tree',
   params: {
          'width' : rtt_num_entries,
          'logic' : '|'},
   ports: {
          'din'  : 'rtt_muxarb_grant',
          'dout' : 'rtt_grant'}
})=\

\=u.instance({
   portsDelimiter: '\n    ',
   instanceName: 'u_rtt_retire',
   moduleName:   'logic_tree',
   params: {
          'width' : rtt_num_entries,
          'logic' : '|'},
   ports: {
          'din'  : 'rtt_retire_entry',
          'dout' : 'rtt_retire'}
})=\

\=u.instance({
   portsDelimiter: '\n    ',
   instanceName: 'u_cmo_retire',
   moduleName:   'logic_tree',
   params: {
          'width' : rtt_num_entries,
          'logic' : '|'},
   ports: {
          'din'  : 'rtt_retire_entry_cmo',
          'dout' : 'cmo_retire'}
})=\

\=u.instance({
   portsDelimiter: '\n    ',
   instanceName: 'u_wtt_grant',
   moduleName:   'logic_tree',
   params: {
          'width' : wtt_num_entries,
          'logic' : '|'},
   ports: {
          'din'  : 'wtt_muxarb_grant',
          'dout' : 'wtt_grant'}
})=\

\=u.instance({
   portsDelimiter: '\n    ',
   instanceName: 'u_wtt_retire',
   moduleName:   'logic_tree',
   params: {
          'width' : wtt_num_entries,
          'logic' : '|'},
   ports: {
          'din'  : 'wtt_retire_entry',
          'dout' : 'wtt_retire'}
})=\

//Dependency clear
//RO dependency for a read is cleared if the request was dependent on another read and if that read gets issued.
//RO dependency for a read is cleared if the request was dependent on another write and if that write completes.

\jsbegin
       for (var entry = 0 ; entry < rtt_num_entries ; entry++) {
\jsend


       assign rd_ro_depnd_clear[\=entry=\] =  ( 
                                                 (rtt_entry\=entry=\_ro_depnd[1]  & ~rtt_entry\=entry=\_sleep & 
						  (rtt_entry\=entry=\_axi_id[\=wAwid=\-1:0] == read_grant_axid) &
                                                  (rtt_entry\=entry=\_ro_depnd_id ==  read_grant_id) & rtt_grant
                                                 ) |
                                                 ((rtt_entry\=entry=\_ro_depnd == 2'b10) &
                                                  (rtt_entry\=entry=\_ro_depnd_id ==  read_comp_id) & rtt_retire 
                                                 ) |
                                                 ((rtt_entry\=entry=\_ro_depnd == 2'b11) & 
                                                  (rtt_entry\=entry=\_ro_depnd_id ==  write_comp_id) & wtt_retire
                                                 ) |
                                                 ((rtt_entry\=entry=\_ro_depnd == 2'b10) &  
                                                  (rtt_entry\=entry=\_ro_depnd_id ==  r_read_comp_id) & r_rtt_retire 
                                                 ) |
                                                 ((rtt_entry\=entry=\_ro_depnd == 2'b11) & 
                                                  (rtt_entry\=entry=\_ro_depnd_id ==  r_write_comp_id) & r_wtt_retire
                                                 ) 
                                              );

       assign rd_eo_depnd_clear[\=entry=\] =  ( 
                                                 (rtt_entry\=entry=\_eo_depnd[1] & ~rtt_entry\=entry=\_sleep &
						  (rtt_entry\=entry=\_axi_id[\=wAwid=\-1:0] == read_grant_axid) &
                                                  (rtt_entry\=entry=\_eo_depnd_id ==  read_grant_id) & rtt_grant
                                                 ) |
                                                 ((rtt_entry\=entry=\_eo_depnd == 2'b10) &
                                                  (rtt_entry\=entry=\_eo_depnd_id ==  read_comp_id) & rtt_retire 
                                                 ) |
                                                 ((rtt_entry\=entry=\_eo_depnd == 2'b11) & 
                                                  (rtt_entry\=entry=\_eo_depnd_id ==  write_comp_id) & wtt_retire
                                                 ) |
						 ((rtt_entry\=entry=\_eo_depnd == 2'b10) & 
                                                  (rtt_entry\=entry=\_eo_depnd_id ==  r_read_comp_id) & r_rtt_retire 
                                                 ) |
                                                 ((rtt_entry\=entry=\_eo_depnd == 2'b11) & 
                                                  (rtt_entry\=entry=\_eo_depnd_id ==  r_write_comp_id) & r_wtt_retire
                                                 )
                                              );

       assign rd_axi_depnd_clear[\=entry=\] =  (rtt_entry\=entry=\_valid & rtt_entry\=entry=\_axi_depnd & ((rtt_entry\=entry=\_axi_depnd_id ==  read_comp_id) & rtt_retire) |
                                                                                                          ((rtt_entry\=entry=\_axi_depnd_id ==  r_read_comp_id) & r_rtt_retire) |
                                                                                                          ((rtt_entry\=entry=\_axi_depnd_id ==  r_cmo_comp_id)  & r_cmo_retire));


       assign rd_sleep_clear[\=entry=\]  =  ~(rtt_entry\=entry=\_ro_depnd[1] | rtt_entry\=entry=\_eo_depnd[1])    ;


\jsbegin

                }
\jsend

//Clearing write dependencies

\jsbegin
       for (var entry = 0 ; entry < wtt_num_entries ; entry++) {
\jsend


       assign wr_ro_depnd_clear[\=entry=\] =  (
                                                 (wtt_entry\=entry=\_ro_depnd[1]  & ~wtt_entry\=entry=\_sleep &
						  (wtt_entry\=entry=\_axi_id[\=wAwid=\-1:0] == write_grant_axid) &
                                                  (wtt_entry\=entry=\_ro_depnd_id ==  write_grant_id) & wtt_grant
                                                 ) |
                                                 ((wtt_entry\=entry=\_ro_depnd == 2'b10) &
                                                  (wtt_entry\=entry=\_ro_depnd_id ==  read_comp_id) & rtt_retire 
                                                 ) |
                                                 ((wtt_entry\=entry=\_ro_depnd == 2'b11) & 
                                                  (wtt_entry\=entry=\_ro_depnd_id ==  write_comp_id) & wtt_retire
                                                 ) |
                                                 ((wtt_entry\=entry=\_ro_depnd == 2'b10) &
                                                  (wtt_entry\=entry=\_ro_depnd_id ==  r_read_comp_id) & r_rtt_retire 
                                                 ) |
                                                 ((wtt_entry\=entry=\_ro_depnd == 2'b11) & 
                                                  (wtt_entry\=entry=\_ro_depnd_id ==  r_write_comp_id) & r_wtt_retire
                                                 ) 
                                              );

       assign wr_eo_depnd_clear[\=entry=\] =  ( 
                                                 (wtt_entry\=entry=\_eo_depnd[1] & ~wtt_entry\=entry=\_sleep &
						  (wtt_entry\=entry=\_axi_id[\=wAwid=\-1:0] == write_grant_axid) &
                                                  (wtt_entry\=entry=\_eo_depnd_id ==  write_grant_id) & wtt_grant
                                                 ) |
                                                 ((wtt_entry\=entry=\_eo_depnd == 2'b10) & 
                                                  (wtt_entry\=entry=\_eo_depnd_id ==  read_comp_id) & rtt_retire 
                                                 ) |
                                                 ((wtt_entry\=entry=\_eo_depnd == 2'b11) &
                                                  (wtt_entry\=entry=\_eo_depnd_id ==  write_comp_id) & wtt_retire
                                                 ) |
                                                 ((wtt_entry\=entry=\_eo_depnd == 2'b10) & 
                                                  (wtt_entry\=entry=\_eo_depnd_id ==  r_read_comp_id) & r_rtt_retire 
                                                 ) |
                                                 ((wtt_entry\=entry=\_eo_depnd == 2'b11) & 
                                                  (wtt_entry\=entry=\_eo_depnd_id ==  r_write_comp_id) & r_wtt_retire
                                                 ) 
                                              );

       // CONC-12880 - Need to add ID Check since WO matching isnt based on address. 
       assign wr_wo_depnd_clear[\=entry=\] =  (
                                                 (wtt_entry\=entry=\_wo_depnd  &  ~wtt_entry\=entry=\_sleep &
						 (wtt_entry\=entry=\_axi_id[\=wAwid=\-1:0] == write_grant_axid) &
                                                  (wtt_entry\=entry=\_wo_depnd_id ==  write_grant_id) & wtt_grant
                                                 ) |
                                                 (wtt_entry\=entry=\_wo_depnd  &  
                                                  (wtt_entry\=entry=\_wo_depnd_id ==  write_comp_id) & wtt_retire
                                                 ) |
                                                 (wtt_entry\=entry=\_wo_depnd  & 
                                                  (wtt_entry\=entry=\_wo_depnd_id ==  r_write_comp_id) & r_wtt_retire
                                                 )
                                              );

//
       assign wr_axi_depnd_clear[\=entry=\] =  (wtt_entry\=entry=\_valid & wtt_entry\=entry=\_axi_depnd & ((wtt_entry\=entry=\_axi_depnd_id ==  write_comp_id)   & wtt_retire) |
                                                                                                          ((wtt_entry\=entry=\_axi_depnd_id ==  r_write_comp_id) & r_wtt_retire));


       assign wr_sleep_clear[\=entry=\]  =  ~(wtt_entry\=entry=\_ro_depnd[1] | wtt_entry\=entry=\_eo_depnd[1] | wtt_entry\=entry=\_wo_depnd);


\jsbegin

                }
\jsend

//AXI Dependancy for the in the RTT
wire [\=rtt_num_entries=\-1:0] one_hot_entry_select_next_rtt;
wire [\=rtt_num_entries=\-1:0] one_hot_entry_select_new_rtt;

\js for (entry=0; entry < rtt_num_entries; entry++) {
assign one_hot_entry_select_next_rtt[\=entry=\] = (rtt_entry\=entry=\_axi_id[\=wArid=\-1:0] == rtt_next_axi_id[\=wArid=\-1:0]) & rtt_entry\=entry=\_youngest_axi;
assign one_hot_entry_select_new_rtt[\=entry=\]  = (rtt_entry\=entry=\_axi_id[\=wArid=\-1:0] == rtt_new_axi_id[\=wArid=\-1:0])  & rtt_entry\=entry=\_youngest_axi;
\js }


\jsbegin
var axi_match_rtt_id_ports = {};
var axi_new_match_rtt_id_ports = {};

for (i=0; i<rtt_num_entries ;i++) {
         axi_match_rtt_id_ports['in'+i] = rtt_id_width+"'d"+i;
         axi_new_match_rtt_id_ports['in'+i] = rtt_id_width+"'d"+i;	 
}

axi_match_rtt_id_ports['sel']   = "one_hot_entry_select_next_rtt";
axi_match_rtt_id_ports['out']   = "axi_match_rtt_id";

axi_new_match_rtt_id_ports['sel']   = "one_hot_entry_select_new_rtt";
axi_new_match_rtt_id_ports['out']   = "axi_new_match_rtt_entry_id";
\jsend
  
\=u.instance({
        instanceName: 'u_axi_match_rtt',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : rtt_num_entries,
                        wMux             : rtt_id_width
        },
        verilogParams: {},
        ports: axi_match_rtt_id_ports
})=\

\=u.instance({
        instanceName: 'u_new_axi_match_rtt',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : rtt_num_entries,
                        wMux             : rtt_id_width
        },
        verilogParams: {},
        ports: axi_new_match_rtt_id_ports
})=\

assign axi_new_match_rtt_id = |(one_hot_entry_select_new_rtt);
assign axi_match_rtt_id_v1 = axi_new_match_rtt_entry_id;

\jsbegin
// AwId always == to ArId
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p4,ncore_3p6,ncore_3p7 */
if(wAxid > wArid) {
\jsend
assign rd_axi_id           = {\=wAxid-wArid=\'b0,rtt_new_axi_id};
\js } else {
assign rd_axi_id           = rtt_new_axi_id[\=wArid=\-1:0];
\js }

assign axi_new_match_rtt   = axi_new_match_rtt_id;
		
//AXI Dependancy for the in the WTT

wire [\=wtt_num_entries=\-1:0] one_hot_entry_select_next_wtt;
wire [\=wtt_num_entries=\-1:0] one_hot_entry_select_new_wtt;

\js for (entry=0; entry < wtt_num_entries; entry++) {
assign one_hot_entry_select_next_wtt[\=entry=\] = (wtt_entry\=entry=\_axi_id[\=wAwid=\-1:0] == wtt_next_axi_id[\=wAwid=\-1:0]) & wtt_entry\=entry=\_youngest_axi;
assign one_hot_entry_select_new_wtt[\=entry=\]  = (wtt_entry\=entry=\_axi_id[\=wAwid=\-1:0] == wtt_new_axi_id[\=wAwid=\-1:0])  & wtt_entry\=entry=\_youngest_axi;
\js }


\jsbegin
var axi_match_wtt_id_ports = {};
var axi_new_match_wtt_id_ports = {};

for (i=0; i<wtt_num_entries ;i++) {
         axi_match_wtt_id_ports['in'+i] = wtt_id_width+"'d"+i;
         axi_new_match_wtt_id_ports['in'+i] = wtt_id_width+"'d"+i;	 
}

axi_match_wtt_id_ports['sel']   = "one_hot_entry_select_next_wtt";
axi_match_wtt_id_ports['out']   = "axi_match_wtt_id";

axi_new_match_wtt_id_ports['sel']   = "one_hot_entry_select_new_wtt";
axi_new_match_wtt_id_ports['out']   = "axi_new_match_wtt_entry_id";
\jsend
  
\=u.instance({
        instanceName: 'u_axi_match_wtt',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : wtt_num_entries,
                        wMux             : wtt_id_width
        },
        verilogParams: {},
        ports: axi_match_wtt_id_ports
})=\

\=u.instance({
        instanceName: 'u_new_axi_match_wtt',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : wtt_num_entries,
                        wMux             : wtt_id_width
        },
        verilogParams: {},
        ports: axi_new_match_wtt_id_ports
})=\

assign axi_new_match_wtt_id = |(one_hot_entry_select_new_wtt);
assign axi_match_wtt_id_v1 = axi_new_match_wtt_entry_id;

\jsbegin
// AwId always == to ArId
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p4,ncore_3p6,ncore_3p7 */
if(wAxid > wAwid) {
\jsend
assign wr_axi_id           = {\=wAxid-wAwid=\'b0,wtt_new_axi_id};
\js } else {
assign wr_axi_id           = wtt_new_axi_id[\=wAwid=\-1:0];
\js }

assign axi_new_match_wtt   = axi_new_match_wtt_id;

assign pmon_address_collision = ((|addr_match_rtt) | (|addr_match_wtt)) & (rtt_allocate_new_entry | wtt_allocate_new_entry);

\js if (assertOn) {
// synopsys translate_off   

    property p_ro_match_rtt_id_onehot0;
        @(posedge clk) disable iff (~reset_n)
            $onehot0(ro_match_rtt_id);
    endproperty

    assert_ro_match_rtt_id_onehot0: assert property (p_ro_match_rtt_id_onehot0)
        else begin $error("ro_match_rtt_id must be onehot0 !"); #100 $finish; end

    property p_ro_match_wtt_id_onehot0;
        @(posedge clk) disable iff (~reset_n)
            $onehot0(ro_match_wtt_id);
    endproperty

    assert_ro_match_wtt_id_onehot0: assert property (p_ro_match_wtt_id_onehot0)
        else begin $error("ro_match_wtt_id must be onehot0 !"); #100 $finish; end

    property p_eo_match_rtt_id_onehot0;
        @(posedge clk) disable iff (~reset_n)
            $onehot0(eo_match_rtt_id);
    endproperty

    assert_eo_match_rtt_id_onehot0: assert property (p_eo_match_rtt_id_onehot0)
        else begin $error("eo_match_rtt_id must be onehot0 !"); #100 $finish; end

    property p_eo_match_wtt_id_onehot0;
        @(posedge clk) disable iff (~reset_n)
            $onehot0(eo_match_wtt_id);
    endproperty

    assert_eo_match_wtt_id_onehot0: assert property (p_eo_match_wtt_id_onehot0)
        else begin $error("eo_match_wtt_id must be onehot0 !"); #100 $finish; end

    property p_wo_match_wtt_id_onehot0;
        @(posedge clk) disable iff (~reset_n)
            $onehot0(wo_match_wtt_id);
    endproperty

    assert_wo_match_wtt_id_onehot0: assert property (p_wo_match_wtt_id_onehot0)
        else begin $error("wo_match_wtt_id must be onehot0 !"); #100 $finish; end

// synopsys translate_on
\js }

endmodule

