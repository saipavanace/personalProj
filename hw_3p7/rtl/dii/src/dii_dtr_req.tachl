\jsbegin
    var u = obj.lib;

    var log2ceil = function(n) { return Math.ceil(Math.log(n)/Math.LN2); };
    var rtt_num_entries      = u.getParam('nRttEntries');
    var rtt_id_width         = log2ceil(rtt_num_entries);
    var rtt_num_entries      = u.getParam('nRttEntries');
    var rtt_id_width         = log2ceil(rtt_num_entries);
    var wMsgId               = u.getParam('DTRReqInterface', 'r_message_id');
    var dtr_id_num           = Math.min(u.getParam('nDtrId'), Math.pow(2,wMsgId));
    var dtr_id_width         = log2ceil(dtr_id_num);
    var data_width           = u.getParam('wData');
    var rresp_width          = u.getParam('wRresp');
    var axi_id_width         = u.getParam('axi_id_width');
    var ruser_width          = 0; //u.getParam('ruser_width');    
    var read_resp_width      = u.getParam('read_resp_width');
    var tid_width            = u.getParam('wMsgId');
    var init_id_width        = wFUnitId;
    var cm_type_width        = u.getParam('wCmType');
    var h_prot_width         = u.getParam('wHProt');
    var t_tier_width         = u.getParam('wTtier');
    var steering_width       = u.getParam('wSteering');
    var priority_width       = u.getParam('wPriority');
    var addr_width           = u.getParam('wAddr');
    var size_width           = u.getParam('wSize');
    var intfsize_width       = u.getParam('wIntfSize');
    var ql_width             = u.getParam('wQl');
    var qos_width            = u.getParam('wQos');    
    var wTOF                 = u.getParam('wTOF');
    var cm_status_width      = u.getParam('DTRReqInterface', 'cm_status');    
    var dtr_mpf1_width       = u.getParam('DTRReqInterface', 'mpf1');
    var dtr_m_prot_width     = u.getParam('DTRReqInterface', 'm_prot');
    var dtr_dprot_width      = u.getParam('DTRReqInterface', 'dprot');
    var dtr_dwid_width       = u.getParam('DTRReqInterface', 'dwid');    
    var be_width             = u.getParam('DTRReqInterface', 'be');
    var dbad_width           = u.getParam('DTRReqInterface', 'dbad');
    var c_user_width         = u.getParam('DTRReqInterface', 'user');        
    var unit_id_width        = u.getParam('unit_id_width');
    var port_id_width        = u.getParam('port_id_width');
    var max_beat_width       = log2ceil((64*8)/data_width);
    var dii_dw               = data_width / 64;
    var dii_dw_b             = data_width / 8;    
    var assertOn             = u.getParam('assertOn');
    var wMpf1                = u.getParam('wMpf1');
    var wFUnitId             = u.getParam('wFUnitId');
    var wFPortId             = obj.lib.getParam('wFPortId');
    var DtrReq               = u.getParam('cmType','DtrReq'); 
    var aruser_width         = u.getParam('aruser_width');
    var wAux		     = u.getParam('wAux');
    var nExclusiveEntries  = u.getParam('nExclusiveEntries');

    var id_width = axi_id_width;
    var nsd_width = dtr_dwid_width + priority_width + ql_width + qos_width + rresp_width + 3;
// Cant have a DII with a 32bit Width. (Shim implimented externally)
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */
if (dii_dw == 0 ) {
var numBeats = 16;
} else {
var numBeats = 8/dii_dw;
}

for (var i = 0; i < rtt_num_entries; i++) {
    u.port('input',  'rtt_entry'+i+'_valid'     , 1);
    u.port('input',  'rtt_entry'+i+'_oldest'    , 1);
    u.port('input',  'rtt_entry'+i+'_axi_id'    , axi_id_width);
    u.port('input',  'rtt_entry'+i+'_addr'      , addr_width);
    u.port('input',  'rtt_entry'+i+'_size'      , size_width);
    u.port('input',  'rtt_entry'+i+'_intfsize'  , intfsize_width);
    u.port('input',  'rtt_entry'+i+'_tid'       , tid_width);
    u.port('input',  'rtt_entry'+i+'_init_id'   , wFUnitId);
    u.port('input',  'rtt_entry'+i+'_mpf1'      , wMpf1);
    u.port('input',  'rtt_entry'+i+'_tof'       , wTOF);
    u.port('input',  'rtt_entry'+i+'_qos'       , qos_width);    
    u.port('input',  'rtt_entry'+i+'_priority'  , priority_width);    
    u.port('input',  'rtt_entry'+i+'_ql'        , ql_width);    
    u.port('input',  'rtt_entry'+i+'_narrow'    , 1);
    u.port('input',  'rtt_entry'+i+'_lock'      , 1);
    u.port('input',  'rtt_entry'+i+'_prot'      , 3);    
    u.port('input',  'rtt_entry'+i+'_st'        , 1);
    u.port('input',  'rtt_entry'+i+'_ch'        , 1);
    u.port('input',  'rtt_entry'+i+'_ca'        , 1);
    u.port('input',  'rtt_entry'+i+'_tm'        , 1); 
    u.port('input',  'rtt_entry'+i+'_user'      , aruser_width);   

    
}   
if (aruser_width != 0) {
    u.port('output',  'pmon_dtr_req_user_bits'      , wAux); 	
}

    u.port('input',  'clk'                      , 1);
    u.port('input',  'reset_n'                  , 1);
    u.port('input',  'read_resp_data'           , read_resp_width);
    u.port('input',  'read_resp_valid'          , 1);
    u.port('input',  'read_resp_data_uc'        , 1);

    u.port('input',  'dtr_rsp_UCE'              , 1);

    u.port('input',  'my_f_unit_id'             , wFUnitId);
    u.port('output', 'read_resp_ready'          , 1);
    u.port('output', 'rtt_retire_entry'         , rtt_num_entries); 
    u.port('output', 'axi_id_match'             , rtt_num_entries);
    u.port('output', 'rd_axi_id_retire'         , 1);
    u.port('output', 'rd_axi_id_comp'           , axi_id_width);

    u.port('output', 'rresp_addr'               , addr_width);
    u.port('output', 'rresp_valid'              , 1);
    u.port('output', 'rresp_ns'                 , 1);    
    u.port('output', 'rresp'                    , 2);

    u.port('output', 'dtr_busy'                 , 1);

    u.port('input',  'dtr_req_has_credits'      , 1);

    obj.lib.interface('dtr_req_mst_', 'master',  obj.lib.getParam('DTRReqInterface'));
    obj.lib.interface('dtr_rsp_slv_', 'slave',   obj.lib.getParam('DTRRspInterface'));

\jsend

module \=u.getModuleName()=\ (\=u.getPorts('\n    ')=\);

wire [\=rtt_num_entries-1=\:0]          axi_id_match_oldest;
wire [\=rtt_num_entries-1=\:0]          axi_id_match_unqual;
wire [\=rtt_num_entries-1=\:0]          axi_id_match_oldest_unqual;
wire [\=rtt_id_width-1=\:0]             axi_id_match_count;
wire [\=dtr_id_num-1=\:0]               valid_dtr_ids;
wire [\=dtr_id_num-1=\:0]               invalid_dtr_ids;
wire [\=dtr_id_num-1=\:0]               valid_dtr_ids_in;
wire [\=dtr_id_num-1=\:0]               dtr_req_mst_message_id_decoded;
wire [\=dtr_id_num-1=\:0]               dtr_id_next;
wire [\=dtr_id_num-1=\:0]               comp_dtr_id_num;
wire [\=dtr_id_width-1=\:0]             dtr_id_next_encoded;
wire [\=dtr_id_width-1=\:0]             dtr_req_mst_message_id_d1;
wire [\=dtr_id_width-1=\:0]             dtr_req_mst_message_id_trim = dtr_req_mst_message_id[\=dtr_id_width-1=\:0];
wire                                    use_new_dtr_id;
wire                                    use_new_dtr_id_d1;
wire                                    all_dtr_ids_in_use;
wire                                    dtr_done_d1;
wire                                    dtr_done;
wire                                    dtr_id_retire;
wire                                    dtr_in_progress;
wire                                    update_valid_dtr_ids;
wire                                    trans_done;
wire                                    dtr_req_mst_attrv;

wire                                    shifter_in_valid;
wire                                    shifter_in_last;
wire [\=data_width-1=\:0]               shifter_in_data;
wire [\=(data_width/8)-1=\:0]           shifter_in_error;
wire [\=nsd_width-1=\:0]                shifter_in_nsd;
wire                                    shifter_in_ready;
wire                                    shifter_out_valid;
wire                                    shifter_out_last;
wire [\=data_width-1=\:0]               shifter_out_data;
wire [\=(data_width/8)-1=\:0]           shifter_out_error;
wire [\=nsd_width-1=\:0]                shifter_out_nsd;
wire                                    shifter_out_ready;
\js if (data_width > 64) {
wire [\=log2ceil(data_width/64)-1=\ :0] shift_amount;
\js }

wire [\=tid_width-1=\:0]                dtr_rid;
wire [\=tid_width-1=\:0]                rob_dtr_rid;
wire [\=wFUnitId-1=\:0]                 dtr_hdr_init_id;
wire [\=wFUnitId-1=\:0]                 rob_hdr_init_id;
reg  [\=tid_width-1=\:0]                new_dtr_id;

wire [\=data_width-1=\:0]               rob_data;
wire                                    rob_valid;
wire                                    rob_ready;
wire                                    rob_last;

reg  [3:0]                              beat_count_in;
wire [3:0]                              beat_count;
reg  [3:0]                              beat_count_done_in;
wire [3:0]                              beat_count_done;
reg  [3:0]                              rob_beat_count_in;
wire [3:0]                              rob_beat_count;
reg  [2:0]                              start_dw;
wire [3:0]                              start_beat;
wire [8:0]                              total_beats_cmd_size;
wire [8:0]                              total_beats;

reg [\=dtr_dwid_width-1=\:0]            r_dw_id;
reg [\=dtr_dwid_width-1=\:0]            r_dw_base;
reg [2:0]                               r_dw_id_offset;

wire                                    use_fifo_data;
wire                                    fill_valid;
wire [8:0]                              trans_size_bytes;
wire                                    trans_last;
wire                                    trans_lock;
wire                                    narrow_done;
wire [\=dtr_mpf1_width=\-1:0]           R_trans_mpf1;
wire                                    R_trans_narrow;

wire                                    rob_has_valid_data;

reg                                     last_fifo_beat_in;
wire                                    last_fifo_beat;

reg [\=data_width-1=\:0] beat_arb_data;
reg [\=(data_width/8)-1=\:0] beat_arb_error_data;

reg                      beat_valid;
reg                      beat_last;
reg                      write_beat_valid;

reg  [3:0]               beat_number_in_trans_mask;
wire [3:0]               beat_number_in_trans;

wire [6:0]               rob_start_beat;
wire [6:0]               r_start_beat;

reg  [6:0]               r_start_beat_size;
reg  [6:0]               r_start_byte_size;

wire  [6:0]               r_start_beat_native;
wire  [6:0]               r_start_beat_native_sa;

wire  [6:0]               r_start_byte_native_offset;
wire  [6:0]               r_start_byte_native_offset_sa;
wire  [6:0]               r_start_byte_native_offset_wa;

wire                                    R_trans_valid;

wire                        incoming_msg_target_mismatch;
assign                      incoming_msg_target_mismatch = (dtr_rsp_slv_target_id != {my_f_unit_id,\=wFPortId=\'b0});
\jsbegin
	var axi_rsp_id_lsb = 1;
	var axi_rsp_id_msb = axi_id_width;
	var axi_rsp_rresp_lsb = axi_id_width + 1;
	var axi_rsp_rresp_msb = axi_id_width + rresp_width;
	var axi_rsp_data_lsb  = axi_id_width + rresp_width + 1;
	var axi_rsp_data_msb  = axi_id_width + rresp_width + data_width;
	var axi_rsp_user_lsb  = axi_id_width + rresp_width + data_width + 1;
	var axi_rsp_user_msb  = axi_id_width + rresp_width + data_width + ruser_width;

\jsend

\jsbegin
       for (var entry = 0 ; entry < rtt_num_entries ; entry++) {
\jsend

       assign axi_id_match_unqual[\=entry=\] =  rtt_entry\=entry=\_valid &  (rtt_entry\=entry=\_axi_id[\=id_width=\-1:0] == read_resp_data[\=id_width=\:1] ); 
      
       assign axi_id_match_oldest_unqual[\=entry=\] =  axi_id_match_unqual[\=entry=\] & rtt_entry\=entry=\_oldest;
       
       assign axi_id_match[\=entry=\] =  rtt_entry\=entry=\_valid &  (rtt_entry\=entry=\_axi_id[\=id_width=\-1:0] == read_resp_data[\=id_width=\:1] ) & read_resp_valid; 
      
       assign axi_id_match_oldest[\=entry=\] =  axi_id_match[\=entry=\] & rtt_entry\=entry=\_oldest;

\jsbegin
                }
\jsend

wire [6:0]                    r_trans_addr;
wire [\=size_width-1=\:0]     r_trans_size;
wire [\=intfsize_width-1=\:0] r_trans_intfsize;
wire [\=addr_width-1=\:0]     r_rresp_addr;
wire                          r_rresp_ns;
wire [\=wMpf1-1=\:0]          rtt_mpf1;
wire [\=wTOF-1=\:0]           rtt_tof;
wire                          rtt_st;
wire                          rtt_ca;
wire                          rtt_ch;
wire                          rtt_tm;
wire                          rtt_narrow;
wire [\=rtt_id_width=\-1:0]   rtt_entry_id;
wire                          rtt_wrap;
wire                          rtt_lock;

\jsbegin
if (aruser_width != 0) { \jsend
wire [\=wAux-1=\:0] rtt_cmd_user; \jsbegin
}

// No ql for this release
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */
if (ql_width != 0) {
\jsend
wire [\=ql_width=\-1:0] rtt_ql;
\js }

\js if (qos_width != 0) {
wire [\=qos_width=\-1:0] rtt_qos;
\js }

\js if (priority_width != 0) {
wire [\=priority_width=\-1:0] rtt_priority;
\js }

wire                         trans_narrow;
wire                         trans_wrap;

\jsbegin
// No ruser for this release
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */
if (ruser_width != 0) {
\jsend
wire [\=ruser_width-1=\:0]   ruser = read_resp_data[\=axi_rsp_user_msb=\:\=axi_rsp_user_lsb=\];
\js }

//Retire axi id only if there are no other outstanding entries with the same axi id
assign rd_axi_id_retire =  |(axi_id_match[\=rtt_num_entries-1=\:0])  & (~|(axi_id_match[\=rtt_num_entries-1=\:0] ^ axi_id_match_oldest[\=rtt_num_entries-1=\:0])) & read_resp_data[0];
assign rd_axi_id_comp   = read_resp_data[\=axi_rsp_id_msb=\:1];

// Clock in a Read AXI Error. Creates a long path.
\js var rresp_info_width = addr_width + 2 + rresp_width;
wire [\=rresp_info_width=\-1:0] r_rresp_info,rresp_info;

\js if (nExclusiveEntries) {
wire [1:0]                      fifo_rresp  = read_resp_data[\=axi_rsp_id_msb+rresp_width=\:\=axi_rsp_id_msb+1=\];
wire [1:0]                      dtr_rresp   = (read_resp_valid & (fifo_rresp != 2'd2)) ? (fifo_rresp | {1'b0,trans_lock}) : 
                                              (read_resp_valid                       ) ?  fifo_rresp                      :
                                                                                         {1'b0, trans_lock};
\js } else {
wire [1:0]                      dtr_rresp = (read_resp_valid) ?  read_resp_data[\=axi_rsp_id_msb+rresp_width=\:\=axi_rsp_id_msb+1=\] : 2'h0;
\js }
 
assign {
     rresp_ns,  
     rresp_addr,
     rresp_valid,
     rresp
   } = r_rresp_info;

assign rresp_info = {
    r_rresp_ns,  
    r_rresp_addr,
    read_resp_valid,
    read_resp_data[\=axi_rsp_id_msb+rresp_width=\:\=axi_rsp_id_msb+1=\]
};
  
\=u.dffre(  rresp_info_width
          , 'r_rresp_info'
	  , 'rresp_info'
	  , rresp_info_width + "'b0"
	  , "1'b1"
	  , 'clk'
	  , 'reset_n')=\

// Entry Selection for DTR Req

\jsbegin
var wAuxLocal; 
if (aruser_width != 0) {
  wAuxLocal = wAux;
} else {
  wAuxLocal = 0;
}
var total_width = tid_width +
                  wFUnitId +
		  1 +
		  addr_width +
		  7 +
		  size_width +
		  intfsize_width +
		  wTOF +
		  wMpf1 +
		  1 +
		  1 +
		  1 +
		  1 +
		  1 +
                  1 +
		  rtt_id_width +
		  ql_width +
		  qos_width +
		  priority_width + 
		  wAuxLocal;	

var rtt_lookup_ports = {};

for (i=0; i<rtt_num_entries ;i++) {
         rtt_lookup_ports['in'+i] = "rtt_entry_"+i+"_combined";
}

rtt_lookup_ports['sel']   = "axi_id_match_oldest";
rtt_lookup_ports['out']   = "selected_entry_combined";
\jsend

\js for (i=0; i<rtt_num_entries ;i++) { 
\jsbegin if (aruser_width != 0) { \jsend
   wire [\=wAux-1=\:0] rtt_entry\=i=\_cmd_user;
   assign rtt_entry\=i=\_cmd_user = rtt_entry\=i=\_user[\=wAux-1=\:0]; \jsbegin 
} \jsend
  wire [\=total_width=\-1:0] rtt_entry_\=i=\_combined = {
                          rtt_entry\=i=\_lock,
  			  \jsbegin
                          // No ql for this release
                          /* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */
                          if (ql_width != 0) {
			  \jsend
			  rtt_entry\=i=\_ql,			                            
                          \js }
                          \js if (qos_width != 0) {
			  rtt_entry\=i=\_qos,			                            
                          \js }
                          \js if (priority_width != 0) {
			  rtt_entry\=i=\_priority,			                            
                          \js }	
                          rtt_entry\=i=\_tid,
                          rtt_entry\=i=\_init_id,
			  rtt_entry\=i=\_prot[1],	  			  			  
			  rtt_entry\=i=\_addr,			  
			  rtt_entry\=i=\_addr[6:0],	  
			  rtt_entry\=i=\_size,
			  rtt_entry\=i=\_intfsize,
			  rtt_entry\=i=\_tof,			  
			  rtt_entry\=i=\_mpf1,
			  rtt_entry\=i=\_st,
			  rtt_entry\=i=\_ca,
			  rtt_entry\=i=\_ch,
			  rtt_entry\=i=\_tm,		  
			  rtt_entry\=i=\_narrow,
			  \js if (aruser_width != 0) {
 			  rtt_entry\=i=\_cmd_user,
			  \js }			  
			  \=rtt_id_width=\'d\=i=\
  };
\js }

wire [\=total_width=\-1:0] selected_entry_combined;

assign {
                          rtt_lock,
			  \jsbegin
                          // No ql for this release
                          /* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */
                          if (ql_width != 0) {
			  \jsend
			  rtt_ql,  		                            
                          \js }
                          \js if (qos_width != 0) {
			  rtt_qos,      			                            
                          \js }
                          \js if (priority_width != 0) {
			  rtt_priority,   			                            
                          \js }	
                          dtr_rid,         
                          dtr_hdr_init_id, 
			  r_rresp_ns,        			  			  
			  r_rresp_addr,    	  			  
			  r_trans_addr,    	  
			  r_trans_size,    
			  r_trans_intfsize, 
			  rtt_tof,          			  
			  rtt_mpf1,   
			  rtt_st,     
			  rtt_ca,         
			  rtt_ch,         
			  rtt_tm,      		  
			  rtt_narrow, 
			  \js if (aruser_width !=0 ) {
			    rtt_cmd_user,
			  \js }    		  
			  rtt_entry_id   
} = selected_entry_combined;

\=u.instance({
        instanceName: 'u_rtt_lookup',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : rtt_num_entries,
                        wMux             : total_width
        },
        verilogParams: {},
        ports: rtt_lookup_ports
})=\

wire transform_chi_wrap_to_incr = rtt_st & (rtt_tof == \=wTOF=\'b1);

wire mpf1_valid        = (rtt_st & (rtt_mpf1[7:6] != 2'b10) & ~rtt_ca & (rtt_tof != 1)) | transform_chi_wrap_to_incr;

\js //RMesage ID of the DTR request is the TID of the read request                
assign dtr_req_mst_r_message_id                                            = rob_dtr_rid;
\js //Target ID of the DTR request is the initiator ID of the read request
assign dtr_req_mst_target_id                                               = {rob_hdr_init_id,{\=wFPortId=\{1'b0}}};
\js //Initaitor ID of the DTR request is the ID of DII deiven at MyID port 
assign dtr_req_mst_initiator_id                                            = {my_f_unit_id,{\=wFPortId=\{1'b0}}};
\js //CMD type for DTR request is 8'h80 which indicates DTR invalid
assign dtr_req_mst_cm_type                                                 = \=DtrReq=\; 

\js //DTR TID generation
assign invalid_dtr_ids = ~(valid_dtr_ids[\=dtr_id_num-1=\:0] );
assign all_dtr_ids_in_use = &(valid_dtr_ids[\=dtr_id_num-1=\:0] );

  \=u.instance({
        instanceName : 'u_dii_dtr_id_gen',
        moduleName   : 'dii_req_id_gen',
        params       : {id_num : dtr_id_num},
        verilogParams: {},
        ports        :  {
        invec        : 'invalid_dtr_ids',
        outvec       : 'dtr_id_next'
        }
  })=\

\=u.instance({
        instanceName: 'u_dtr_id_next',
        moduleName: 'encoder',
        params: { width : dtr_id_num},
        verilogParams: {},
        ports: {
            invector : 'dtr_id_next', outdecode : 'dtr_id_next_encoded'
        }
})=\

\=u.dffre(  1
          , 'use_new_dtr_id_d1'
	  , 'use_new_dtr_id'
	  , "1'b0"
	  , "1'b1"
	  , 'clk'
	  , 'reset_n')=\

\=u.dffre(  1
          , 'dtr_done_d1'
	  , 'dtr_done'
	  , "1'b0"
	  , "1'b1"
	  , 'clk'
	  , 'reset_n')=\

\=u.dffre(  dtr_id_width
          , 'dtr_req_mst_message_id_d1'
	  , 'dtr_req_mst_message_id_trim'
	  , '{'+dtr_id_width+'{1\'b0}}'
	  , "1'b1"
	  , 'clk'
	  , 'reset_n')=\

 assign dtr_req_mst_message_id[\=dtr_id_width-1=\:0] =  (use_new_dtr_id_d1 & dtr_req_mst_valid) ? dtr_id_next_encoded : dtr_req_mst_message_id_d1;

\js if (wMsgId > dtr_id_width)  {
 assign dtr_req_mst_message_id[\=wMsgId-1=\:\=dtr_id_width=\] = \=wMsgId-dtr_id_width=\'h0;
\js }

\js //Calculating valid IDs
 assign dtr_id_retire = dtr_rsp_slv_valid & ~incoming_msg_target_mismatch & ~dtr_rsp_UCE;
 assign dtr_rsp_slv_ready = dtr_rsp_slv_valid ;

 assign comp_dtr_id_num[\=dtr_id_num-1=\:0]  = (\=dtr_id_num=\'b1 << (dtr_rsp_slv_r_message_id)) &  {\=dtr_id_num=\{dtr_id_retire}};

 wire  dtr_req_unblocked = rob_ready & dtr_req_has_credits;
 assign dtr_in_progress = dtr_req_mst_valid & ~( dtr_req_mst_last  &  dtr_req_mst_ready);
 
 assign dtr_req_mst_message_id_decoded =  (\=dtr_id_num=\'b1 << dtr_req_mst_message_id) & {\=dtr_id_num=\{dtr_req_mst_valid}};  

\js //Fix for bug 4074
assign dtr_done = (dtr_req_mst_valid  & dtr_req_mst_last  & dtr_req_mst_ready) | (dtr_done_d1 & ~dtr_req_mst_valid) ;
\js //assign dtr_done = (dtr_req_mst_valid &  dtr_req_mst_last  & dtr_req_mst_ready) ;

 assign use_new_dtr_id = dtr_done; 

\js //Drive dtr req user bits coming from associated cmd req
\jsbegin
if (aruser_width != 0) { \jsend
\=u.dffre(   wAux
          , 'pmon_dtr_req_user_bits'
	  , 'rtt_cmd_user'
	  , wAux+ "'b0"
	  , 'dtr_in_progress'
	  , 'clk'
	  , 'reset_n')=\ \jsbegin
} \jsend



 
 assign valid_dtr_ids_in = (valid_dtr_ids | dtr_req_mst_message_id_decoded) &  ~comp_dtr_id_num ;
 assign update_valid_dtr_ids = (use_new_dtr_id & dtr_req_mst_valid & dtr_req_mst_ready) | dtr_id_retire;

\=u.dffre(   dtr_id_num
          , 'valid_dtr_ids'
	  , 'valid_dtr_ids_in'
	  , '{'+dtr_id_num+'{1\'b0}}'
	  , 'update_valid_dtr_ids'
	  , 'clk'
	  , 'reset_n')=\

assign dtr_busy = (|valid_dtr_ids) | rob_has_valid_data;

\jsbegin
///////////////////////////////////////////////////////////////////
//
//
//   Narrow Read Beat Handling Logic
//
//
\jsend

wire [\=data_width-1=\:0]     narrow_mask;
wire [\=(data_width/8)-1=\:0] byte_narrow_mask;

wire [\=log2ceil(data_width)-1=\:0] mask_start_offset_in; 
wire [\=log2ceil(data_width)-1=\:0] mask_start_offset; 

wire [2:0]                mpf1_asize;
wire [2:0]                mpf1_alen;

// Indication the mask has reached the end of the data width. Must be masked for the first beat for unaligned narrow wraps.
wire                      end_of_narrow_beat;
wire                      end_of_narrow_beat_offset;

// Offset of the mask for the current beat
wire [8:0]                mask_offset;
wire [5:0]                byte_mask_offset;

// Address Aligned to asize
reg  [5:0]                asize_aligned_address;
reg  [5:0]                 size_aligned_address;

// Offset withion the beat where the first beat of data will be
wire  [\=log2ceil(data_width)-1=\:0]                data_beat_offset_address;

reg [\=data_width-1=\:0] size_mask;
reg [\=(data_width/8)-1=\:0] byte_size_mask;

wire incoming_beat        =  rob_valid & rob_ready;

wire first_transaction;
wire first_transaction_in = (first_transaction) ? ~(incoming_beat & ~fill_valid) | rob_last : rob_last;

\=u.dffre(   1
          , 'first_transaction'
	  , 'first_transaction_in'
	  , "1'b1"
	  , 'incoming_beat'
	  , 'clk'
	  , 'reset_n')=\

\jsbegin
// Cannot have width == 32
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */
if(data_width == 32) {
\jsend
  assign  data_beat_offset_address = {3'b0,asize_aligned_address[1:0]};
  assign  mask_offset              = {4'b0,mask_start_offset[1:0],3'b0};
  assign  byte_mask_offset         = {4'b0,mask_start_offset[1:0]};
\js } else if (data_width ==  64) {
  assign  data_beat_offset_address = {3'b0,asize_aligned_address[2:0]};
  assign  mask_offset              = {3'b0,mask_start_offset[2:0],3'b0};
  assign  byte_mask_offset         = {3'b0,mask_start_offset[2:0]};
\js } else if (data_width ==  128) {
  assign  data_beat_offset_address = {3'b0,asize_aligned_address[3:0]};
  assign  mask_offset              = {2'b0,mask_start_offset[3:0],3'b0};
  assign  byte_mask_offset         = {2'b0,mask_start_offset[3:0]};  
\js } else {
  assign  data_beat_offset_address = {3'b0,asize_aligned_address[4:0]};
  assign  mask_offset              = {1'b0,mask_start_offset[4:0],3'b0};
  assign  byte_mask_offset         = {1'b0,mask_start_offset[4:0]};  
\js }

assign narrow_mask = (R_trans_narrow & ~first_transaction & ~fill_valid) ? (size_mask << mask_offset) : {\=data_width=\{1'b1}};

assign byte_narrow_mask = (R_trans_narrow & ~first_transaction & ~fill_valid) ? (byte_size_mask << byte_mask_offset) : {\=(data_width/8)=\{1'b1}};

assign mpf1_asize  = rtt_mpf1[5:3];
assign mpf1_alen   = rtt_mpf1[2:0];

always @ (*) begin
  case(R_trans_mpf1[5:3])
    3'b000 : begin
       size_mask = {{\=data_width-8=\{1'b0}},{8{1'b1}}};
       byte_size_mask = {{\=(data_width/8)-1=\{1'b0}},{1{1'b1}}};
    end
    3'b001 : begin
       size_mask = {{\=data_width-16=\{1'b0}},{16{1'b1}}};
       byte_size_mask = {{\=(data_width/8)-2=\{1'b0}},{2{1'b1}}};
    end      
    3'b010 : begin
       size_mask = {{\=data_width-32=\{1'b0}},{32{1'b1}}};
       byte_size_mask = {{\=(data_width/8)-4=\{1'b0}},{4{1'b1}}};
    end
   \js if(data_width > 64) {           
    3'b011 : begin
       size_mask = {{\=data_width-64=\{1'b0}},{64{1'b1}}};
       byte_size_mask = {{\=(data_width/8)-8=\{1'b0}},{8{1'b1}}};       
    end
   \js }
   \js if(data_width > 128) {              
    3'b100 : begin
       size_mask = {{\=data_width-128=\{1'b0}},{128{1'b1}}};
       byte_size_mask = {{\=(data_width/8)-16=\{1'b0}},{16{1'b1}}};       
    end
    \js }
    \jsbegin
    // Cannot have a size > 256 for this release.
    /* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */
    if(data_width > 256) {
    \jsend
    3'b101 : begin
       size_mask = {{\=data_width-256=\{1'b0}},{256{1'b1}}};
       byte_size_mask = {{\=(data_width/8)-32=\{1'b0}},{32{1'b1}}};       
    end
    \js }    
    default: begin
       size_mask = {\=data_width=\{1'b1}};
       byte_size_mask = {\=(data_width/8)=\{1'b1}};       
    end
  endcase
end

always @ (*) begin
  case(mpf1_asize)
    3'b000 : begin
       asize_aligned_address =  r_trans_addr[5:0];       
    end 
    3'b001 : begin
       asize_aligned_address =  {r_trans_addr[5:1],1'b0};              
    end     
    3'b010 : begin
       asize_aligned_address =  {r_trans_addr[5:2],2'b0};              
    end
   \js if(data_width > 64) {           
    3'b011 : begin
       asize_aligned_address =  {r_trans_addr[5:3],3'b0};              
    end
   \js }
   \js if(data_width > 128) {              
    3'b100 : begin
       asize_aligned_address =  {r_trans_addr[5:4],4'b0};              
    end
    \js }
    \jsbegin
    // Cannot have a size > 256 for this release.
    /* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */
    if(data_width > 256) {
    \jsend    
    3'b101 : begin
       asize_aligned_address =  {r_trans_addr[5],5'b0};              
    end
    \js }    
    default: begin
       asize_aligned_address =  6'h0;              
    end
  endcase
end

\js // This can only occur from a 64 bit init to a 256bit DII since narrows cannot be taken in from inits
\js if (data_width == 256) {
wire sub_beat_narrow_wrap = (mpf1_alen == 1) && (mpf1_asize == 3) & shift_amount[0] & rtt_wrap;
\js } else {
wire sub_beat_narrow_wrap = 1'h0;
\js }

assign mask_start_offset_in = (read_resp_data[0] & read_resp_valid)   ?   \=log2ceil(data_width)=\'h0 :
                              (sub_beat_narrow_wrap)                  ?   data_beat_offset_address[\=log2ceil(data_width)-1=\:0] - (\=log2ceil(data_width)-1=\'h1 << mpf1_asize) : 
                              (first_transaction)                     ?   data_beat_offset_address[\=log2ceil(data_width)-1=\:0] + (\=log2ceil(data_width)-1=\'h1 << mpf1_asize) : 
                                                                          mask_start_offset + (\=log2ceil(data_width)-1=\'h1 << mpf1_asize);


\=u.dffre(   log2ceil(data_width)
          , 'mask_start_offset'
	  , 'mask_start_offset_in'
	  , '{'+log2ceil(data_width)+'{1\'b0}}'
	  , 'incoming_beat'
	  , 'clk'
	  , 'reset_n')=\

\js // Need to mask first beat of unaligned narrow wrap as it is not finished yet.
wire wrap_first_narrow_beat;
wire wrap_first_narrow_beat_in = (wrap_first_narrow_beat) ? ~(rob_valid & rob_ready & rob_last)  :
                                                             (end_of_narrow_beat_offset & trans_narrow) & ~(rob_valid & rob_ready & rob_last);

\=u.dffre(   1
          , 'wrap_first_narrow_beat'
	  , 'wrap_first_narrow_beat_in'
	  , "1'b0"
	  , 'incoming_beat'
	  , 'clk'
	  , 'reset_n')=\


\jsbegin
// Cannot have a size == 32 for this release.
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7*/
if(data_width == 32) {
\jsend
  assign  end_of_narrow_beat_offset = ~(|mask_start_offset_in[1:0]) | fill_valid;
\js } else if (data_width ==  64) {
  assign  end_of_narrow_beat_offset = ~(|mask_start_offset_in[2:0]) | fill_valid;
\js } else if (data_width ==  128) {
  assign  end_of_narrow_beat_offset = ~(|mask_start_offset_in[3:0]) | fill_valid;
\js } else {
  assign  end_of_narrow_beat_offset = ~(|mask_start_offset_in[4:0]) | fill_valid ;
\js } 

  assign  end_of_narrow_beat = (trans_wrap & trans_narrow & (data_beat_offset_address != 0)) ? (end_of_narrow_beat_offset & wrap_first_narrow_beat) : end_of_narrow_beat_offset;
         
\jsbegin
//////////////////////////////////////////////////////////////////
\jsend

                         
wire [\=size_width + intfsize_width + wFUnitId + tid_width + 11 + dtr_mpf1_width + ql_width + qos_width + priority_width + 1=\:0] R_trans_in;
wire [\=size_width + intfsize_width + wFUnitId + tid_width + 11 + dtr_mpf1_width + ql_width + qos_width + priority_width + 1=\:0] R_trans;
	      
assign                          R_trans_valid            = R_trans[0];
wire [6:0]                      R_trans_addr             = R_trans[7:1];
wire [\=size_width-1=\:0]       R_trans_size             = R_trans[\=size_width+8-1=\:8];
wire [\=intfsize_width-1=\:0]   R_trans_intfsize         = R_trans[\=size_width+intfsize_width+8-1=\:\=size_width+8=\];
wire                            R_trans_mpf1_valid       = R_trans[\=size_width+intfsize_width+8=\];
wire [\=wFUnitId-1=\:0]         R_trans_dtr_hdr_init_id  = R_trans[\=size_width+intfsize_width+wFUnitId+9-1=\:\=size_width+intfsize_width+9=\];
wire [\=tid_width-1=\:0]        R_trans_dtr_rid          = R_trans[\=size_width+intfsize_width+wFUnitId+tid_width+9-1=\:\=size_width+intfsize_width+wFUnitId+9=\];
assign                          R_trans_narrow           = R_trans[\=size_width+intfsize_width+wFUnitId+tid_width+9=\];
wire                            R_trans_tm               = R_trans[\=size_width+intfsize_width+wFUnitId+tid_width+10=\];
wire                            R_trans_wrap             = R_trans[\=size_width+intfsize_width+wFUnitId+tid_width+11=\];
wire                            R_trans_lock             = R_trans[\=size_width+intfsize_width+wFUnitId+tid_width+12=\];
assign                          R_trans_mpf1             = R_trans[\=size_width+intfsize_width+wFUnitId+tid_width+12+dtr_mpf1_width=\:\=size_width+intfsize_width+wFUnitId+tid_width+13=\];
\js if (qos_width != 0) {
wire [\=qos_width=\-1:0]        R_trans_qos              = R_trans[\=size_width+intfsize_width+wFUnitId+tid_width+12+dtr_mpf1_width+qos_width=\:\=size_width+intfsize_width+wFUnitId+tid_width+13+dtr_mpf1_width=\];
\js}
\js if (priority_width != 0) {
wire [\=priority_width=\-1:0]   R_trans_priority         = R_trans[\=size_width+intfsize_width+wFUnitId+tid_width+12+dtr_mpf1_width+qos_width+priority_width=\:\=size_width+intfsize_width+wFUnitId+tid_width+13+dtr_mpf1_width+qos_width=\];
\js}

\jsbegin
// No ql for this release
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
if (ql_width != 0) {
\jsend
wire [\=ql_width=\-1:0]         R_trans_ql               = R_trans[\=size_width+intfsize_width+wFUnitId+tid_width+11+dtr_mpf1_width+qos_width+priority_width+ql_width=\:\=size_width+intfsize_width+wFUnitId+tid_width+12+dtr_mpf1_width+qos_width+priority_width=\];
\js}

assign                            rtt_wrap                 = (rtt_mpf1[7:6] == 2'b10);

wire                          trans_mpf1_valid      = (R_trans_valid) ? R_trans_mpf1_valid       : mpf1_valid;
wire [6:0]                    trans_addr            = (R_trans_valid) ? R_trans_addr             : r_trans_addr;
wire [\=size_width-1=\:0]     trans_size            = (R_trans_valid) ? R_trans_size             : r_trans_size;
wire [\=intfsize_width-1=\:0] trans_intfsize        = (R_trans_valid) ? R_trans_intfsize         : r_trans_intfsize;
wire [\=wFUnitId-1=\:0]       trans_dtr_hdr_init_id = (R_trans_valid) ? R_trans_dtr_hdr_init_id  : dtr_hdr_init_id;
wire [\=tid_width-1=\:0]      trans_dtr_rid         = (R_trans_valid) ? R_trans_dtr_rid          : dtr_rid;
wire                          trans_tm              = (R_trans_valid) ? R_trans_tm               : rtt_tm;
wire [\=dtr_mpf1_width=\-1:0] trans_mpf1            = (R_trans_valid) ? R_trans_mpf1             : rtt_mpf1;
assign                        trans_wrap            = (R_trans_valid) ? R_trans_wrap             : (rtt_mpf1[7:6] == 2'b10);
assign                        trans_lock            = (R_trans_valid) ? R_trans_lock             : rtt_lock;
assign                        trans_narrow          = (R_trans_valid) ? R_trans_narrow           : rtt_narrow;
\js if (qos_width != 0) {
wire [\=qos_width=\-1:0]      trans_qos             = (R_trans_valid) ? R_trans_qos              : rtt_qos;   
\js}
\js if (priority_width != 0) {
wire [\=priority_width=\-1:0] trans_priority        = (R_trans_valid) ? R_trans_priority         : rtt_priority;     
\js}

\jsbegin
// No ql for this release
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */
if (ql_width != 0) {
\jsend
wire [\=ql_width=\-1:0]       trans_ql              = (R_trans_valid) ? R_trans_ql               : rtt_ql;        
\js}

always @ (*) begin
  case(trans_size)
    3'b000 : begin
       size_aligned_address =  trans_addr[5:0];       
    end
    3'b001 : begin
       size_aligned_address =  {trans_addr[5:1],1'b0};              
    end
    3'b010 : begin
       size_aligned_address =  {trans_addr[5:2],2'b0};              
    end
    3'b011 : begin
       size_aligned_address =  {trans_addr[5:3],3'b0};              
    end
    3'b100 : begin
       size_aligned_address =  {trans_addr[5:4],4'b0};              
    end
    3'b101 : begin
       size_aligned_address =  {trans_addr[5],5'b0};              
    end
    default: begin
       size_aligned_address =  6'h0;              
    end
  endcase
end

wire [4:0] total_beats_m1 = ({1'b0,total_beats[3:0]} - 5'd1);

assign trans_size_bytes = (9'd1 << trans_size);
assign trans_done       = ({1'b0,beat_count_done} == total_beats_m1) & (rob_valid & rob_ready) & narrow_done;
assign trans_last       = ({1'b0,beat_count_done} == total_beats_m1) & narrow_done;

assign R_trans_in = {
                     \jsbegin
                     // No ql this release.
                     /* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */
                     if (ql_width != 0) {
		     \jsend
                     rtt_ql,
		     \js } 
                     \js if (priority_width != 0) {		     
                     rtt_priority,
		     \js }
                     \js if (qos_width != 0) {		     
		     rtt_qos,
		     \js }
		     rtt_mpf1,
                     rtt_lock,
		     rtt_wrap,
		     rtt_tm,
		     rtt_narrow,
		     dtr_rid,
		     dtr_hdr_init_id,
		     mpf1_valid,
		     r_trans_intfsize,
		     r_trans_size,
		     r_trans_addr,
		     !trans_done};
		     
wire   R_trans_en = (~R_trans_valid & rob_valid) | trans_done;

\=u.dffre(   1 + size_width + intfsize_width + wFUnitId + tid_width + 11 + dtr_mpf1_width + ql_width + qos_width + priority_width + 1
          , 'R_trans'
	  , 'R_trans_in'
	  , '{'+'1 +' + size_width + '+' + intfsize_width + '+' + dtr_mpf1_width + '+' + wFUnitId + '+' + priority_width + '+' + ql_width + '+' + qos_width + '+' +  tid_width + ' + 12'+'{1\'b0}}'
	  , 'R_trans_en'
	  , 'clk'
	  , 'reset_n')=\

wire [\=rtt_id_width=\-1:0]    R_rtt_entry_id;
reg  [\=rtt_num_entries=\-1:0] R_rtt_entry_id_vec;

wire [\=rtt_id_width-1=\:0]    trans_rtt_entry_id = (R_trans_valid) ?  R_rtt_entry_id : rtt_entry_id;

always @ (*) begin
   R_rtt_entry_id_vec = \=rtt_num_entries=\'h0;
   R_rtt_entry_id_vec[trans_rtt_entry_id] = 1'b1;
end

\=u.dffre(   rtt_id_width
          , 'R_rtt_entry_id'
	  , 'rtt_entry_id'
	  , '{'+rtt_id_width+'{1\'b0}}'
	  , 'R_trans_en'
	  , 'clk'
	  , 'reset_n')=\

reg [8:0] dii_beats_to_fill_native_intfSize;

reg       cmd_size_lt_intfsize;
always @ (*) begin
  case(trans_intfsize)
       \=intfsize_width=\'d0: begin // 1 DW
           cmd_size_lt_intfsize              =  trans_size < 3;
	   dii_beats_to_fill_native_intfSize =  9'd1;
       end
       \=intfsize_width=\'d1: begin // 2 DW
           cmd_size_lt_intfsize              =  trans_size < 4;
	   dii_beats_to_fill_native_intfSize =  9'd\=(dii_dw > 2) ? 1 : (2/dii_dw)=\;
       end
       default : begin // 4 DW
           cmd_size_lt_intfsize              =  trans_size < 5;
	   dii_beats_to_fill_native_intfSize =  9'd\=(4/dii_dw)=\;
       end	   
  endcase
end

\jsbegin
// No width less than a dw this release.
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */
if ( dii_dw < 1 ) {
\jsend
assign   total_beats_cmd_size = (trans_size > 2) ? (trans_size_bytes >> 2) : 9'h1;
\js } else if( dii_dw == 1 ) {
assign   total_beats_cmd_size = (trans_size > 3) ? (trans_size_bytes >> 3) : 9'h1;
\js } else if (dii_dw == 2) {
assign   total_beats_cmd_size = (trans_size > 4) ? (trans_size_bytes >> 4) : 9'h1;
\js } else {
assign   total_beats_cmd_size = (trans_size > 5) ? (trans_size_bytes >> 5) : 9'h1;
\jsbegin
} 
\jsend


assign total_beats = total_beats_cmd_size + {2'b0,r_start_beat_native_sa}; //(cmd_size_lt_intfsize & (r_start_beat_native_sa != 0)) ? dii_beats_to_fill_native_intfSize[8:0] : total_beats_cmd_size;

assign narrow_done = read_resp_data[0] | !trans_narrow | last_fifo_beat;

always@(*)begin
   if(trans_done)
      beat_count_in = 4'h0;
   else if(rob_valid & rob_ready & (~trans_narrow | end_of_narrow_beat_offset))
      beat_count_in = beat_count + 1'b1;
   else
      beat_count_in = beat_count;
end
	  
\=u.dffre(   4
          , 'beat_count'
	  , 'beat_count_in'
	  , '4\'b0'
	  , "1'b1"
	  , 'clk'
	  , 'reset_n')=\

always@(*)begin
   if(trans_done)
      beat_count_done_in = 4'h0;
   else if(rob_valid & rob_ready & (~trans_narrow | end_of_narrow_beat))
      beat_count_done_in = beat_count_done + 1'b1;
   else
      beat_count_done_in = beat_count_done;
end
	  
\=u.dffre(   4
          , 'beat_count_done'
	  , 'beat_count_done_in'
	  , '4\'b0'
	  , "1'b1"
	  , 'clk'
	  , 'reset_n')=\
	  

always@(*)begin
   if(trans_done)
      last_fifo_beat_in = 1'h0;
   else if(read_resp_valid & read_resp_ready & read_resp_data[0])
      last_fifo_beat_in = 1'b1;
   else
      last_fifo_beat_in = last_fifo_beat;
end

\=u.dffre(  1
          , 'last_fifo_beat'
	  , 'last_fifo_beat_in'
	  , "1'b0"
	  , "1'b1"
	  , 'clk'
	  , 'reset_n')=\

wire entry_cleared;
wire entry_cleared_in;

assign entry_cleared_in = (entry_cleared) ? ~(rob_valid & rob_ready & rob_last) :  |rtt_retire_entry & ~(rob_valid & rob_ready & rob_last);

\=u.dffre(  1
          , 'entry_cleared'
	  , 'entry_cleared_in'
	  , "1'b0"
	  , "1'b1"
	  , 'clk'
	  , 'reset_n')=\

////////////////////////////////////////////////////////////////////////////
//
//  Assign Padded Data Into ROB
//

    assign fill_valid               = ((beat_count < r_start_beat[3:0]) & (trans_mpf1_valid)) | (beat_count < r_start_beat_native_sa[3:0]) | last_fifo_beat;
    assign rtt_retire_entry         = R_rtt_entry_id_vec & {\=rtt_num_entries=\{read_resp_valid & read_resp_data[0]}} & {\=rtt_num_entries=\{~entry_cleared}} ;
    assign rob_data                 = (~fill_valid) ? read_resp_data[\=axi_rsp_data_msb=\:\=axi_rsp_data_lsb=\] : 'h0;
    assign rob_valid                = dtr_req_has_credits & (read_resp_valid | fill_valid);
    assign rob_last                 = trans_last & (read_resp_valid | last_fifo_beat);
    assign read_resp_ready          = dtr_req_unblocked & ~(fill_valid & rob_valid & rob_ready);

////////////////////////////////////////////////////////////////////////////
//
//  In Beat Shift
//

reg [2:0] r_shift_amount;
always @ (*) begin
 case(trans_intfsize)
   \js if (data_width >= 128) {
   \=intfsize_width=\'d0: begin
          r_shift_amount = {1'b0,trans_addr[4:3]};
	 end
   \js }
   \js if (data_width >= 256) {   
   \=intfsize_width=\'d1: begin
          r_shift_amount = {1'b0,trans_addr[4],1'b0}; 
   end
   \js }   
   default: begin
          r_shift_amount = {3'b0};   
   end
  endcase
end

\js if (data_width > 64) {
assign shift_amount = r_shift_amount[\=log2ceil(data_width/64)=\-1:0];
\js }

////////////////////////////////////////////////////////////////////////////
//
//  Reorder Logic
//

assign r_start_byte_native_offset      = trans_addr[6:0]                  & (7'b0111111 >> (2'b11  - trans_intfsize));
assign r_start_byte_native_offset_sa   = {1'b0,size_aligned_address[5:0]} & (7'b0111111 >> (2'b11  - trans_intfsize));
assign r_start_byte_native_offset_wa   = {trans_addr[6:3],3'b0}           & (7'b0111111 >> (2'b11  - trans_intfsize));

\jsbegin
// Always >= 1 for this release
/* istanbul ignore else env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */
if(dii_dw >= 1) {
\jsend
assign r_start_beat_native          = (r_start_byte_native_offset >> (\=log2ceil(dii_dw)+1=\ + 2));
assign r_start_beat_native_sa       = (r_start_byte_native_offset_sa >> (\=log2ceil(dii_dw)+1=\ + 2));
\js } else {
assign r_start_beat_native          = (r_start_byte_native_offset >> 2);
assign r_start_beat_native_sa       = (r_start_byte_native_offset_sa >> 2);
\js } 

assign r_start_beat                 = r_start_beat_native;
assign rob_start_beat               = r_start_beat;

wire [3:0] beat_number_in_trans_sub = trans_mpf1_valid ? (beat_count[3:0] - r_start_beat_native_sa[3:0]) : ((beat_count[3:0] + r_start_beat[3:0]) - r_start_beat_native_sa[3:0]);

always @ (*) begin
 \jsbegin
 // Always >= 1 for this release. (no 512b width)
 /* istanbul ignore else env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */
 if(numBeats > 1) {
 \jsend
  case(total_beats_cmd_size[4:0])
\js for(let beat = 2; beat <= numBeats ; beat++){
         5'd\=beat=\ : begin
	          beat_number_in_trans_mask = {{\=4-(log2ceil(beat))=\{1'b0}},{\=log2ceil(beat)=\{1'b1}}};
	 end
\js }
	 5'd1 : begin
	          beat_number_in_trans_mask = 4'b0000;
	 end	 
	 default : begin
	          beat_number_in_trans_mask = 4'b0001;
	 end
\js } else {
	          beat_number_in_trans_mask = 4'b0001;
\js }
  endcase
end

assign beat_number_in_trans = (beat_count[3:0] < r_start_beat_native_sa[3:0])   ?  beat_count[3:0]  :
                                                                                  (beat_number_in_trans_sub & beat_number_in_trans_mask) + r_start_beat_native_sa[3:0];

always@(*)begin
   if(shifter_in_valid & shifter_in_ready & shifter_in_last)
      rob_beat_count_in = 4'h0;
   else if(shifter_in_valid & shifter_in_ready)
      rob_beat_count_in = rob_beat_count + 1'b1;
   else
      rob_beat_count_in = rob_beat_count;
end

\=u.dffre(   4
          , 'rob_beat_count'
	  , 'rob_beat_count_in'
	  , '4\'b0'
	  , "1'b1"
	  , 'clk'
	  , 'reset_n')=\
	  
\js if (data_width > 64) {
wire bypass_rob = (r_start_beat == 0) & ~rob_has_valid_data & ~trans_narrow & (shift_amount == 0);
\js } else {
wire bypass_rob = (r_start_beat == 0) & ~rob_has_valid_data & ~trans_narrow;
\js }

wire dbad_in    = (read_resp_data_uc | (dtr_rresp[1]));
wire clear_rob  = shifter_in_valid & shifter_in_ready & shifter_in_last;

wire error_occured = (read_resp_data_uc | (dtr_rresp[1]));

\js for(let beat = 0; beat < numBeats ; beat++){
     wire                      clear_entry\=beat=\ = shifter_in_valid & shifter_in_ready & (\=beat=\ == rob_beat_count);
     wire [\=data_width-1=\:0] beat_\=beat=\_reg;
     wire [\=data_width-1=\:0] beat_\=beat=\_mask_and_accumulate;

     assign beat_\=beat=\_mask_and_accumulate = (rob_data & narrow_mask) | (beat_\=beat=\_reg & ~narrow_mask);

     wire beat_\=beat=\_reg_enable = (beat_number_in_trans == \=beat=\ & rob_valid & rob_ready);
	      
     \=u.dffre(  data_width
              , 'beat_'+beat+'_reg'
	      , 'beat_'+beat+'_mask_and_accumulate'
	      , data_width + "'b0"
	      , 'beat_'+beat+'_reg_enable'
	      , 'clk'
	      , 'reset_n')=\


     wire [\=(data_width/8)-1=\:0] beat_\=beat=\_error_reg;
     wire [\=(data_width/8)-1=\:0] beat_\=beat=\_error_mask_and_accumulate;

     assign beat_\=beat=\_error_mask_and_accumulate = ({\=data_width/8=\{error_occured}} & byte_narrow_mask) | (beat_\=beat=\_error_reg & ~byte_narrow_mask);
	      
     \=u.dffre(  (data_width/8)
              , 'beat_'+beat+'_error_reg'
	      , 'beat_'+beat+'_error_mask_and_accumulate'
	      , (data_width/8) + "'b0"
	      , 'beat_'+beat+'_reg_enable'
	      , 'clk'
	      , 'reset_n')=\

     wire beat_\=beat=\_last;

     wire last\=beat=\ = (total_beats_m1 == {1'b0,beat_number_in_trans});
     \=u.dffre(  1
              , 'beat_'+beat+'_last'
	      , 'last'+beat
	      , "1'b0"
	      , 'beat_'+beat+'_reg_enable'
	      , 'clk'
	      , 'reset_n')=\

     wire   beat_\=beat=\_valid_in;
     wire   beat_\=beat=\_valid;
     assign beat_\=beat=\_valid_in         =  (~trans_narrow | end_of_narrow_beat | rob_last) &    ((beat_\=beat=\_reg_enable & rob_ready) | ~(shifter_in_valid & shifter_in_ready & (\=beat=\ == rob_beat_count)));
     wire   beat_\=beat=\_reg_valid_enable =                                         ~bypass_rob & ((beat_\=beat=\_reg_enable & rob_ready) |  (shifter_in_valid & shifter_in_ready & (\=beat=\ == rob_beat_count)));

     \=u.dffre(  1
              , 'beat_'+beat+'_valid'
	      , 'beat_'+beat+'_valid_in'
	      , "1'b0"
	      , 'beat_'+beat+'_reg_valid_enable'
	      , 'clk'
	      , 'reset_n')=\

     wire [\=tid_width=\-1:0]     beat_\=beat=\_dtr_id;
     wire [\=wFUnitId=\-1:0]      beat_\=beat=\_init_id;
     wire [\=rresp_width=\-1:0]   beat_\=beat=\_rresp;
     wire                         beat_\=beat=\_dbad;
     wire                         beat_\=beat=\_tm;
     
     \jsbegin
     // No rruser for this release 
     /* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */
     if (ruser_width != 0) {
     \jsend
     wire [\=ruser_width=\-1:0]   beat_\=beat=\_ruser;    
     \js }

     \js if (qos_width != 0) {
     wire [\=qos_width=\-1:0]     beat_\=beat=\_qos;    
     \js }

     \js if (priority_width != 0) {
     wire [\=priority_width=\-1:0] beat_\=beat=\_priority;    
     \js }

     \jsbegin
     // No ql for this release
     /* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */
     if (ql_width != 0) {
     \jsend
     wire [\=ql_width=\-1:0]      beat_\=beat=\_ql;    
     \js }

     wire [3-1:0]                 beat_\=beat=\_addr;
     wire [3-1:0]                 beat_\=beat=\_beats;
     
     \js if (data_width > 64) {
     wire [\=log2ceil(data_width/64)=\-1:0] beat_\=beat=\_shift;
     \js }
     wire [\=intfsize_width=\-1:0] beat_\=beat=\_intfsize;
     wire [\=size_width-1=\:0]     beat_\=beat=\_size;
     
     \=u.dffre(  wFUnitId
              , 'beat_'+beat+'_init_id'
	      , 'trans_dtr_hdr_init_id'
	      ,  wFUnitId + "'b0"
	      , 'beat_'+beat+'_reg_enable'
	      , 'clk'
	      , 'reset_n')=\

     \=u.dffre(  tid_width
              , 'beat_'+beat+'_dtr_id'
	      , 'trans_dtr_rid'
	      ,  tid_width + "'b0"
	      , 'beat_'+beat+'_reg_enable'
	      , 'clk'
	      , 'reset_n')=\

     wire [\=rresp_width-1=\:0] rresp_merged_\=beat=\ = (dtr_rresp == 1)           ? ((beat_\=beat=\_rresp == 0) ? \=rresp_width=\'h1 : beat_\=beat=\_rresp) :
                                                        (beat_\=beat=\_rresp == 1) ? dtr_rresp :
							                            (dtr_rresp | beat_\=beat=\_rresp);
										     
     wire [\=rresp_width=\-1:0] rresp_in_\=beat=\ = rresp_merged_\=beat=\  & ~{\=rresp_width=\{clear_entry\=beat=\}};

     \=u.dffre(  rresp_width
              , 'beat_'+beat+'_rresp'
	      , 'rresp_in_'+beat
	      ,  rresp_width+ "'b0"
	      , 'beat_'+beat+'_reg_enable | clear_entry'+beat
	      , 'clk'
	      , 'reset_n')=\

     \=u.dffre(  1
              , 'beat_'+beat+'_tm'
	      , 'trans_tm'
	      ,  "1'b0"
	      , 'beat_'+beat+'_reg_enable'
	      , 'clk'
	      , 'reset_n')=\

     \jsbegin
     // No ruser for this release
     /* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */
     if (ruser_width != 0) {
     \jsend
     \=u.dffre(  ruser_width
              , 'beat_'+beat+'_ruser'
	      , 'ruser'
	      ,  ruser_width+ "'b0"
	      , 'beat_'+beat+'_reg_enable'
	      , 'clk'
	      , 'reset_n')=\
     \js }

     \js if (qos_width != 0) {
     \=u.dffre(  qos_width
              , 'beat_'+beat+'_qos'
	      , 'trans_qos'
	      ,  qos_width+ "'b0"
	      , 'beat_'+beat+'_reg_enable'
	      , 'clk'
	      , 'reset_n')=\
     \js }

     \js if (priority_width != 0) {
     \=u.dffre(  priority_width
              , 'beat_'+beat+'_priority'
	      , 'trans_priority'
	      ,  priority_width+ "'b0"
	      , 'beat_'+beat+'_reg_enable'
	      , 'clk'
	      , 'reset_n')=\
     \js }

     \jsbegin
     // No ql for this release
     /* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */
     if (ql_width != 0) {
     \jsend
     \=u.dffre(  ql_width
              , 'beat_'+beat+'_ql'
	      , 'trans_ql'
	      ,  ql_width+ "'b0"
	      , 'beat_'+beat+'_reg_enable'
	      , 'clk'
	      , 'reset_n')=\
     \js }

     
     \=u.dffre(  3
              , 'beat_'+beat+'_addr'
	      , 'trans_addr[5:3]'
	      ,  "3'b0"
	      , 'beat_'+beat+'_reg_enable'
	      , 'clk'
	      , 'reset_n')=\

     \=u.dffre(  3
              , 'beat_'+beat+'_beats'
	      , 'total_beats_cmd_size[2:0]'
	      ,  "3'b0"
	      , 'beat_'+beat+'_reg_enable'
	      , 'clk'
	      , 'reset_n')=\

     \=u.dffre(  intfsize_width
              , 'beat_'+beat+'_intfsize'
	      , 'trans_intfsize'
	      ,  intfsize_width+"'b0"
	      , 'beat_'+beat+'_reg_enable'
	      , 'clk'
	      , 'reset_n')=\

     \=u.dffre(  size_width
              , 'beat_'+beat+'_size'
	      , 'trans_size'
	      ,  size_width+"'b0"
	      , 'beat_'+beat+'_reg_enable'
	      , 'clk'
	      , 'reset_n')=\

     wire dbad_in_\=beat=\ = (dbad_in | beat_\=beat=\_dbad) & ~clear_entry\=beat=\;

     \=u.dffre(  1
              , 'beat_'+beat+'_dbad'
	      , 'dbad_in_'+beat
	      , "1'b0"
	      , 'beat_'+beat+'_reg_enable | clear_entry'+beat
	      , 'clk'
	      , 'reset_n')=\


    \js if (data_width > 64) {
     \=u.dffre(  log2ceil(data_width/64)
              , 'beat_'+beat+'_shift'
	      , 'shift_amount'
	      ,  log2ceil(data_width/64) + "'b0"
	      , 'beat_'+beat+'_reg_enable'
	      , 'clk'
	      , 'reset_n')=\
    \js } 

\js }

assign rob_has_valid_data = 1'b0 
\js for(let beat = 0; beat < numBeats; beat++){
  | beat_\=beat=\_valid
\js}
;

always @ (*) begin
  case(beat_number_in_trans[\=log2ceil(numBeats)=\-1:0])
  \js for(let beat = 1; beat < numBeats; beat++){
         \=log2ceil(numBeats)=\'d\=beat=\ : begin
 	    write_beat_valid    = beat_\=beat=\_valid; 	    
	 end
  \js }
	 default : begin
	    write_beat_valid    = beat_0_valid;
	 end
  endcase
end

wire                                         wrap_within_subbeat;
wire                                         shifter_wrap_within_subbeat;

reg [\=tid_width=\-1:0]                      beat_dtr_id;
reg [\=wFUnitId=\-1:0]                       beat_init_id;
reg [\=rresp_width=\-1:0]                    beat_rresp;
reg                                          beat_tm;

\jsbegin
// No rruser for this release
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */
if (ruser_width != 0) {
\jsend
reg [\=ruser_width=\-1:0]                    beat_ruser;
\js }

reg                                          beat_dbad;
\js if (data_width > 64) {
reg [\=log2ceil(data_width/64)=\-1:0]        beat_shift;
\js }
reg [3-1:0]                                  beat_addr;
reg [3-1:0]                                  beat_beats;
reg [\=intfsize_width=\-1:0]                 beat_intfsize;
reg [\=size_width-1=\:0]                     beat_size;

\js if (qos_width != 0) {
reg [\=qos_width=\-1:0]     beat_qos;    
\js }

\js if (priority_width != 0) {
reg [\=priority_width=\-1:0] beat_priority;    
\js }

\jsbegin
// No ql for this release
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */ 
if (ql_width != 0) {
\jsend
reg [\=ql_width=\-1:0]      beat_ql;    
\js }

\js if (data_width > 64) {
reg [\=rresp_width=\-1:0]                    next_rresp;
reg                                          next_dbad;
reg [\=rresp_width=\-1:0]                    merge_rresp;
reg                                          merge_dbad;
reg [\=rresp_width=\-1:0]                    final_rresp;
\js }

always @ (*) begin
  case(rob_beat_count[\=log2ceil(numBeats)=\-1:0])
  \js for(let beat = 1; beat < numBeats; beat++){
         \=log2ceil(numBeats)=\'d\=beat=\ : begin
	    beat_last     = beat_\=beat=\_last;
	    
            \js if (data_width > 64) {
	    beat_shift    = (bypass_rob) ? shift_amount                     : beat_\=beat=\_shift;
	    \js }
	    
	    \js if (data_width > 64) {
	    \js if (beat < numBeats - 1) {
	    next_rresp    = beat_\=beat+1=\_rresp;
	    next_dbad     = beat_\=beat+1=\_dbad;
	    \js } else {
	    next_rresp    = beat_0_rresp;
	    next_dbad     = beat_0_dbad;	    
	    \js }
	    
	    merge_rresp   = (beat_last & |beat_shift) ? beat_0_rresp :
	                    (|beat_shift            ) ? next_rresp   : \=rresp_width=\'h0;
	    merge_dbad    = (beat_last & |beat_shift) ? beat_0_dbad  :
	                    (|beat_shift            ) ? next_dbad    : 1'h0;

            final_rresp   = (beat_\=beat=\_rresp == 1) ? merge_rresp         :
	                    (merge_rresp         == 1) ? beat_\=beat=\_rresp :
			                                (beat_\=beat=\_rresp | merge_rresp);  
			        			    
	    beat_rresp    = (bypass_rob) ?  dtr_rresp                           : final_rresp;
	    beat_dbad     = (bypass_rob) ? (read_resp_data_uc | (dtr_rresp[1])) : (beat_\=beat=\_dbad  | merge_dbad);
	    \js } else {
	    beat_rresp    = (bypass_rob) ?  dtr_rresp                           : beat_\=beat=\_rresp;
	    beat_dbad     = (bypass_rob) ? (read_resp_data_uc | (dtr_rresp[1])) : beat_\=beat=\_dbad;
	    \js }
	    
	    beat_arb_data = beat_\=beat=\_reg;
	    beat_arb_error_data = beat_\=beat=\_error_reg;
	    beat_valid    = beat_\=beat=\_valid;
	   	    	   
	    \jsbegin
            // No rruser for this release
            /* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */ 
            if (ruser_width != 0) {
	    \jsend
	    beat_ruser    = (bypass_rob) ? ruser                            : beat_\=beat=\_ruser;
	    \js }
            \js if (qos_width != 0) {
	    beat_qos      = (bypass_rob) ? trans_qos                        : beat_\=beat=\_qos;
	    \js }
            \js if (priority_width != 0) {
	    beat_priority = (bypass_rob) ? trans_priority                   : beat_\=beat=\_priority;
	    \js }
	    \jsbegin
            // No ql for this release
            /* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */ 
            if (ql_width != 0) {
	    \jsend
	    beat_ql       = (bypass_rob) ? trans_ql                         : beat_\=beat=\_ql;
	    \js }	    
    	    beat_dtr_id   = (bypass_rob) ? trans_dtr_rid                    : beat_\=beat=\_dtr_id;
	    beat_init_id  = (bypass_rob) ? trans_dtr_hdr_init_id            : beat_\=beat=\_init_id;
	    beat_addr     = (bypass_rob) ? trans_addr[5:3]                  : beat_\=beat=\_addr;
	    beat_beats    = (bypass_rob) ? total_beats_cmd_size[2:0]        : beat_\=beat=\_beats;	    
	    beat_intfsize = (bypass_rob) ? trans_intfsize                   : beat_\=beat=\_intfsize;
	    beat_size     = (bypass_rob) ? trans_size                       : beat_\=beat=\_size;	    
	    beat_tm       = (bypass_rob) ? trans_tm                         : beat_\=beat=\_tm;
	 end
  \js }
	 default : begin
	    beat_last     = beat_0_last;
	    
            \js if (data_width > 64) {	    
	    beat_shift    = (bypass_rob) ? shift_amount                              : beat_0_shift;
	    \js }
	    
	    \js if (data_width > 64) {
	    next_rresp    = beat_1_rresp;
	    next_dbad     = beat_1_dbad;

            final_rresp   = \=rresp_width=\'h0;  
	    
	    merge_rresp   = (beat_last & |beat_shift) ? beat_0_rresp :
	                    (|beat_shift            ) ? next_rresp   : \=rresp_width=\'h0;
	    merge_dbad    = (beat_last & |beat_shift) ? beat_0_dbad  :
	                    (|beat_shift            ) ? next_dbad    : 1'h0;

	    beat_rresp    = (bypass_rob) ?  dtr_rresp                                : (beat_0_rresp | merge_rresp);
	    beat_dbad     = (bypass_rob) ? (read_resp_data_uc | (dtr_rresp[1]))      : (beat_0_dbad  | merge_dbad);
	    \js } else {
	    beat_rresp    = (bypass_rob) ?  dtr_rresp                                : beat_0_rresp;
	    beat_dbad     = (bypass_rob) ? (read_resp_data_uc | (dtr_rresp[1]))      : beat_0_dbad;
	    \js }
	    
	    beat_arb_data       = beat_0_reg;
	    beat_arb_error_data = beat_0_error_reg;
	    beat_valid          = beat_0_valid;
	    
	    \jsbegin
            // No rruser for this release
            /* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */ 	    	    
            if (ruser_width != 0) {
	    \jsend
	    beat_ruser    = (bypass_rob) ? ruser                                     : beat_0_ruser;
	    \js }
	    \js if (qos_width != 0) {
	    beat_qos      = (bypass_rob) ? trans_qos                                 : beat_0_qos;
	    \js }
            \js if (priority_width != 0) {
	    beat_priority = (bypass_rob) ? trans_priority                            : beat_0_priority;
	    \js }
	    \jsbegin
            // No ql for this release
            /* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */ 	    
            if (ql_width != 0) {
	    \jsend
	    beat_ql       = (bypass_rob) ? trans_ql                                  : beat_0_ql;
	    \js }
    	    beat_dtr_id   = (bypass_rob) ? trans_dtr_rid                             : beat_0_dtr_id;
	    beat_init_id  = (bypass_rob) ? trans_dtr_hdr_init_id                     : beat_0_init_id;	    
	    beat_addr     = (bypass_rob) ? trans_addr[5:3]                           : beat_0_addr;
	    beat_beats    = (bypass_rob) ? total_beats_cmd_size[2:0]                 : beat_0_beats;	    
	    beat_intfsize = (bypass_rob) ? trans_intfsize                            : beat_0_intfsize;
	    beat_size     = (bypass_rob) ? trans_size                                : beat_0_size;	    
	    beat_tm       = (bypass_rob) ? trans_tm                                  : beat_0_tm;	    
	 end
  endcase
end

\js var num_of_dw = data_width/64;

\js for(let beat = 0; beat < numBeats; beat++){
    \js for (let dw = num_of_dw-1; dw >= 0 ; dw--) {
      \jsbegin
      // No ql for this release
      /* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */ 
      if(num_of_dw == 0) {
      \jsend
       reg [2:0]                         dw_\=beat=\_\=dw=\;            
      \js } else {
       reg [2+\=log2ceil(num_of_dw)=\:0] dw_\=beat=\_\=dw=\;      
      \js }
       reg                                wrap_\=beat=\_\=dw=\;
    \js }
\js }


reg [2:0] dw_boundary;

always @ (*) begin
  case(beat_intfsize)
     0: begin
       r_dw_id_offset =  beat_addr[2:0];
     end
     1: begin
       r_dw_id_offset = {beat_addr[2:1],1'b0};
     end
     default: begin
       r_dw_id_offset = {beat_addr[2],2'b0};
     end
  endcase
end

\jsbegin
var dw_beat_width = 3+log2ceil(num_of_dw);
\jsend

\js if (log2ceil(num_of_dw) != 0) {
  wire [(\=dw_beat_width=\)-1:0] dw_wrap_beats = (wrap_within_subbeat) ?  \=dw_beat_width=\'d2 : {beat_beats,\=log2ceil(num_of_dw)=\'b0};
\js } else {
  wire [(\=dw_beat_width=\)-1:0] dw_wrap_beats = (wrap_within_subbeat) ?  \=dw_beat_width=\'d2 : beat_beats;  
\js }

always @ (*) begin
  case(beat_beats)
     1: begin
      \js if (num_of_dw == 1) {
       dw_boundary = beat_addr[2:0];
      \js } else if (num_of_dw == 2) {
       dw_boundary = {beat_addr[2:1],1'b0};      
      \js } else {
       dw_boundary = (wrap_within_subbeat) ? {beat_addr[2:1],1'b0} : {beat_addr[2],2'b0}; // Kjeld fix. 5/6/2021. CONC-7066           
      \js }
     end
     2: begin
      \js if (num_of_dw == 1) {
       dw_boundary = {beat_addr[2:1],1'b0};            
      \js } else if (num_of_dw == 2) {
       dw_boundary = {beat_addr[2],2'b0};                  
      \js } else {
       dw_boundary = 3'h0;            
      \js }     
     end
     \js if (data_width <= 128) {
     4: begin
      \js if (num_of_dw == 1) {
       dw_boundary = {beat_addr[2],2'b0};                                     
      \js } else {
       dw_boundary = 3'h0;            
      \js }       
     end
     \js }
     default: begin
       dw_boundary = 3'h0;                 
     end
endcase
  
  \js for(let beat = 0; beat < numBeats; beat++){
     \js for (let dw = num_of_dw-1; dw>= 0; dw--) {
         \js if (log2ceil(num_of_dw) != 0) {
         wrap_\=beat=\_\=dw=\ = (\=dw_beat_width=\'d\=(beat * num_of_dw) + dw =\ + {\=log2ceil(num_of_dw)=\'b0,r_dw_id_offset}) >= ({\=log2ceil(num_of_dw)=\'b0,dw_boundary} + dw_wrap_beats);
         dw_\=beat=\_\=dw=\   = (wrap_\=beat=\_\=dw=\) ?
	                                                                              (3'd\=(beat*num_of_dw) + dw=\ + {\=log2ceil(num_of_dw)=\'b0,r_dw_id_offset}) - dw_wrap_beats :
										       3'd\=(beat*num_of_dw) + dw=\ + {\=log2ceil(num_of_dw)=\'b0,r_dw_id_offset};
	 \js } else {
	 wrap_\=beat=\_\=dw=\ = (\=dw_beat_width+1=\'d\=(beat * num_of_dw) + dw =\ + {1'b0,r_dw_id_offset}) >= ({1'b0,dw_boundary} + {1'b0,dw_wrap_beats});
         dw_\=beat=\_\=dw=\   = (wrap_\=beat=\_\=dw=\) ?
	                                                                              (3'd\=(beat*num_of_dw) + dw=\ + r_dw_id_offset) - dw_wrap_beats :
										       3'd\=(beat*num_of_dw) + dw=\ + r_dw_id_offset;
	 \js }
     \js }
  \js }
  
  case(rob_beat_count)
  \js for(let beat = 1; beat < numBeats; beat++){
    4'd\=beat=\ : begin
      r_dw_id = {
       \js for (let dw = num_of_dw-1; dw>= 1; dw--) {
       dw_\=beat=\_\=dw=\[2:0],   
       \js }
       dw_\=beat=\_0[2:0]
      };
    end
  \js }  
    default: begin
      r_dw_id = {
      \js for (let dw = num_of_dw-1; dw >= 1; dw--) {
       dw_0_\=dw=\[2:0],   
       \js }
       dw_0_0[2:0]
      };
    end
  endcase
end

assign rob_hdr_init_id          = beat_init_id;
assign rob_dtr_rid              = beat_dtr_id;

\jsbegin
// No ruser for this release
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */  
if (ruser_width != 0) {
\jsend
wire [\=ruser_width-1=\:0] u_shifter_in_data;
assign u_shifter_in_data        = beat_ruser;
\js }

\js if(data_width == 256) {
assign                  wrap_within_subbeat           = (beat_size == 4 & beat_shift[0]);
wire [\=data_width=\-1:0]     pre_subbeat_data           = (bypass_rob) ? rob_data              : beat_arb_data;
assign shifter_in_data          = pre_subbeat_data;

wire [\=(data_width/8)=\-1:0] pre_subbeat_error          = (bypass_rob) ? {\=data_width/8=\{error_occured}}              : beat_arb_error_data;
assign shifter_in_error          = pre_subbeat_error;
\js } else {
assign wrap_within_subbeat      = 1'h0;
assign shifter_in_data          = (bypass_rob) ? rob_data              : beat_arb_data;
assign shifter_in_error         = (bypass_rob) ? {\=data_width/8=\{error_occured}}              : beat_arb_error_data;
\js }


assign shifter_in_valid         = (bypass_rob) ? rob_valid             : beat_valid;
assign shifter_in_last          = (bypass_rob) ? rob_last              : beat_last;

assign shifter_in_nsd           = {wrap_within_subbeat,
                                   r_dw_id,
                                   beat_rresp,
				   \js if (qos_width != 0) {
				   beat_qos,
				   \js }
				   \jsbegin
                                   // No ql for this release
                                   /* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */
				   if (ql_width != 0) {
				   \jsend
				   beat_ql,
				   \js }
				   \js if (priority_width != 0) {				   
				   beat_priority,
				   \js }
				   beat_dbad,
				   beat_tm};

assign rob_ready                = (bypass_rob) ? shifter_in_ready      : ~write_beat_valid;


\js if(data_width > 64) {
\=u.instance({
        instanceName: 'u_dtr_inbeat_shifter',
        moduleName: 'shift_buffer',
        params:
	   {
	      wData             : data_width,
	      wShiftGranularity : 64,
	      wNsd              : nsd_width
	   },
        verilogParams: {},
        ports: {
	    clk          : 'clk',
	    reset_n      : 'reset_n',
            in_valid     : 'shifter_in_valid',
	    in_last      : 'shifter_in_last',
            in_data      : 'shifter_in_data',
	    in_ready     : 'shifter_in_ready',
	    in_nsd       : 'shifter_in_nsd',
            out_valid    : 'shifter_out_valid',
	    out_last     : 'shifter_out_last',
            out_data     : 'shifter_out_data',
	    out_ready    : 'shifter_out_ready',
	    out_nsd      : 'shifter_out_nsd',
	    shift_amount : 'beat_shift',    
        }
})=\

wire ready_s_nc, valid_s_nc, last_s_nc;
\=u.instance({
        instanceName: 'u_dtr_inbeat_error_shifter',
        moduleName: 'shift_buffer',
        params:
	   {
	      wData             : (data_width/8),
	      wShiftGranularity : 8
	   },
        verilogParams: {},
        ports: {
	    clk          : 'clk',
	    reset_n      : 'reset_n',
            in_valid     : 'shifter_in_valid',
	    in_last      : 'shifter_in_last',
            in_data      : 'shifter_in_error',
	    in_ready     : 'ready_s_nc',
            out_valid    : 'valid_s_nc',
	    out_last     : 'last_s_nc',
            out_data     : 'shifter_out_error',
	    out_ready    : 'shifter_out_ready',
	    shift_amount : 'beat_shift',    
        }
})=\
  
  \jsbegin
  // No ruser for this release
  /* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */  
  if (ruser_width != 0) {
  \jsend
  \=u.instance({
        instanceName: 'u_dtr_inbeat_user_shifter',
        moduleName: 'shift_buffer',
        params:
	   {
	      wData             : ruser_width,
	      wShiftGranularity : ruser_width/(data_width/64)
	   },
        verilogParams: {},
        ports: {
	    clk          : 'clk',
	    reset_n      : 'reset_n',
            in_valid     : 'shifter_in_valid',
	    in_last      : 'shifter_in_last',
            in_data      : 'u_shifter_in_data',
	    in_ready     : 'ready_nc',
            out_valid    : 'valid_nc',
	    out_last     : 'last_nc',
            out_data     : 'u_shifter_out_data',
	    out_ready    : 'shifter_out_ready',
	    shift_amount : 'beat_shift',    
        }
  })=\
  \js }

\js } else {
            assign shifter_out_valid   = shifter_in_valid;
	    assign shifter_out_last    = shifter_in_last;
            assign shifter_out_data    = shifter_in_data;
	    assign shifter_out_error   = shifter_in_error;
            assign shifter_out_nsd     = shifter_in_nsd;
	    
	    assign shifter_in_ready    = shifter_out_ready;

 \jsbegin
 // No ruser for this release
 /* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */  
 if (ruser_width != 0) {
 \jsend
            assign u_shifter_out_data  = u_shifter_in_data;
 \js }
 
\js }


wire [\=dtr_dwid_width=\-1:0] shifter_dw_id;
wire [\=rresp_width=\-1:0] shifter_rresp;

\js if (qos_width != 0) {
wire [\=qos_width=\-1:0] shifter_qos;
\js }

\jsbegin
// No ql for this release
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */
if (ql_width != 0) {
\jsend
wire [\=ql_width=\-1:0] shifter_ql;
\js }

\js if (priority_width != 0) {				   
wire [\=priority_width=\-1:0] shifter_priority;
\js }

wire shifter_dbad;
wire shifter_tm;

assign {shifter_wrap_within_subbeat,
        shifter_dw_id,
        shifter_rresp,
	\js if (qos_width != 0) {
	shifter_qos,
	\js }
        \jsbegin
        // No ql for this release
        /* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */	
	if (ql_width != 0) {
	\jsend
	shifter_ql,
	\js }
	\js if (priority_width != 0) {				   
	shifter_priority,
	\js }
	shifter_dbad,
	shifter_tm} = shifter_out_nsd;
				   
\js if(data_width == 256) {
assign dtr_req_mst_data         = (shifter_wrap_within_subbeat) ? {128'b0,shifter_out_data[255:192],shifter_out_data[63:0]} :
                                  shifter_out_data;
\js} else {
assign dtr_req_mst_data         = shifter_out_data;
\js}

 \jsbegin
 // No ruser for this release
 /* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */ 
 if (c_user_width != 0 & c_user_width != undefined) {
 \jsend
 
 \jsbegin
 // No ruser for this release
 /* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */ 
 if (ruser_width != 0) {
 \jsend
    assign dtr_req_mst_user     = 'h0; //u_shifter_out_data; 
 \js } else {
    assign dtr_req_mst_user     = 'h0;  
 \js }
\js }

assign dtr_req_mst_valid        = shifter_out_valid & ~all_dtr_ids_in_use;
assign dtr_req_mst_last         = shifter_out_last;
assign shifter_out_ready        = dtr_req_mst_ready & ~all_dtr_ids_in_use;

//
\js if (u.getParam('DTRReqInterface', 'h_prot')) {
    assign dtr_req_mst_h_prot       = \=u.getParam('DTRReqInterface', 'h_prot')=\'h0;
\js }

\jsbegin
// No t_tier for this release
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */ 
if (u.getParam('DTRReqInterface', 't_tier')) {
\jsend
    assign dtr_req_mst_t_tier       = 'h0;
\js }

\jsbegin
// No steer for this release
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */ 
if (u.getParam('DTRReqInterface', 'steering')) {
\jsend
    assign dtr_req_mst_steering     = 'h0;
\js }

\js if (u.getParam('DTRReqInterface', 'priority')) {
    assign dtr_req_mst_priority     = shifter_priority;
\js }

\jsbegin
// No ql for this release
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */ 
if (u.getParam('DTRReqInterface', 'ql')) {
\jsend
    assign dtr_req_mst_ql           = shifter_ql;
\js }

\jsbegin
// No dtr.qos for this release. Not in CPR
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */
if (u.getParam('DTRReqInterface').qos != undefined & u.getParam('DTRReqInterface').qos != 0) {
\jsend
    assign dtr_req_mst_qos          = shifter_qos;
\js }

\jsbegin
// No ruser for this release
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6, ncore_3p7 */ 
if (u.getParam('DTRReqInterface', 'aux')) {
\jsend
    assign dtr_req_mst_aux          = 'h0;
\js }

    assign dtr_req_mst_attrv        = 1'h0;
    assign dtr_req_mst_mpf1         = \=dtr_mpf1_width=\'h0;
    assign dtr_req_mst_be           = (shifter_rresp == 2'b10) ? \=be_width=\'h0 :
                                      (shifter_rresp == 2'b11) ? \=be_width=\'h0 : (\=be_width=\'h0 - \=be_width=\'d1);
    assign dtr_req_mst_dwid         = shifter_dw_id;
    
    // Must do every transformation the data does:
    \js if(data_width == 256) {
    wire [\=(data_width/8)=\-1:0] error_wrap_within_sub_beat = (shifter_wrap_within_subbeat) ? {16'b0,shifter_out_error[31:24],shifter_out_error[7:0]} : shifter_out_error;
    \js } else {
    wire [\=(data_width/8)=\-1:0] error_wrap_within_sub_beat = shifter_out_error;
    \js }
    
    // Assign the bytes
    assign dtr_req_mst_dbad         = {
					\js for (let i = dbad_width-1; i > 0; i--) {
					(|error_wrap_within_sub_beat[((\=i=\+1)*8)-1:(\=i=\*8)]),
					\js }
					(|error_wrap_within_sub_beat[7:0])
                                      };

    assign dtr_req_mst_cm_status    = (read_resp_data_uc)   ? \=cm_status_width=\'b10000011 :
                                      (shifter_rresp == 2'b01) ? \=cm_status_width=\'b00000001 :    
                                      (shifter_rresp == 2'b10) ? \=cm_status_width=\'b10000011 :
                                      (shifter_rresp == 2'b11) ? \=cm_status_width=\'b10000100 : \=cm_status_width=\'d0; 
    assign dtr_req_mst_tm           = shifter_tm;
    assign dtr_req_mst_rl           = 2'h1;

\js if(dtr_m_prot_width != 0) {
    assign dtr_req_mst_m_prot       = \=dtr_m_prot_width=\'h0;
\js }

\js if(dtr_dprot_width != 0) {
    assign dtr_req_mst_dprot        = \=dtr_dprot_width=\'h0;
\js }

endmodule
 
