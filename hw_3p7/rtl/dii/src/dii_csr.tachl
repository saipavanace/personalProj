// Copyright (C) 2017 Arteris, Inc.
// All rights reserved.
//=============================================================================
\jsbegin
// This module defines dii csr registers
//
//=============================================================================
\jsend

\jsbegin
var u                          = obj.lib;
var m                          = obj.userLib;
var bundleFunctions            = obj.userLib.bundleFunctions;

var wFPortId                   = u.getParam('wFPortId');
var wFUnitId                   = u.getParam('wFUnitId');
var wNUnitId                   = u.getParam('wNUnitId');
var wRpn                       = u.getParam('wRpn');
var wNrri                      = u.getParam('wNrri');

var wAddr                      = u.getParam('wAddr');

var engVerId                   = obj.lib.getParam('engVerId');
var implVerId                  = obj.lib.getParam('implVerId');

var traceRegInterface          = obj.lib.getParam('traceRegInterface');
var pmonRegInterface           = obj.lib.getParam('pmonRegInterface');

var useExternalMemory          = obj.lib.getParam('useExternalMemory');
var useResiliency              = obj.lib.getParam('useResiliency');
var fnErrDetectCorrect         = obj.lib.getParam('fnErrDetectCorrect');
var ResilienceInfo             = obj.lib.getParam('ResilienceInfo');

var skidBufferSRAM             = obj.lib.getParam('skidBufferSRAM');

var hasCorrectableRegisters    = skidBufferSRAM | ((fnErrDetectCorrect == "ecc") & (useExternalMemory == 1)) | ((ResilienceInfo.fnResiliencyProtectionType == "ecc") & (useResiliency == 1));
var CONC_RX_INTF               = obj.lib.getParam('CONC_RX_INTF');

var CSR                        = obj.lib.getParam('csr');

var clkInterface               = obj.lib.getParam('clkInterface');
var apbInterface               = obj.lib.getParam('apbInterface');
var apbInterfaceName           = obj.lib.getParam('apbInterfaceName');
var internalFaultInterface     = obj.lib.getParam('internalFaultInterface');
var regProtectionInterface     = obj.lib.getParam('regProtectionInterface');
var regProtectionInterfaceName = obj.lib.getParam('regProtectionInterfaceName');
var regProtectionStyle         = obj.lib.getParam('regProtectionStyle');

var useAddrTranslation          = u.getParam('useAddrTranslation');
var nAddrTransRegisters         = u.getParam('nAddrTransRegisters');
var csrAddrTransInterface       = u.getParam('csrAddrTransInterface');
var nPerfCounters               = u.getParam('nPerfCounters');

var nSkidBufSize                = u.getParam('nSkidBufSize');
var nSkidBufArb                 = u.getParam('nSkidBufArb');

var wEventTimeout    = u.getParam('wEventTimeout');
var wProtocolTimeout = u.getParam('wProtocolTimeout');
var wSkidEntry       = u.getParam('wSkidEntry');


//=============================================================================
// Clk, ID, and IRQ Interfaces
//=============================================================================

// Clock Interface
obj.lib.interface('', 'slave', clkInterface);

// Engineering Debug Register
u.port('output', 'csr_force_arid_low', 1);
u.port('output', 'csr_force_awid_low', 1);
u.port('output', 'csr_force_ro_vz_hi', 1);
u.port('output', 'csr_force_eo_vz_hi', 1);
u.port('output', 'csr_exclude_ro_write_from_wo', 1);
u.port('output', 'csr_exclude_initiator_from_ordering', 1);

// Id Signals
u.port('input', 'my_f_unit_id', wFUnitId);
u.port('input', 'my_n_unit_id', wNUnitId)
u.port('input', 'my_csr_rpn'  , wRpn);
u.port('input', 'my_csr_nrri' , wNrri);

// Skid Errors - Two skid buffer content for 1 interface, however very unlikely two ucerrs happen same cycle.
// - Already have presidence for not counting multiple cerr a cycle

u.port('input','skid_cerr'     , 1);
u.port('input','skid_ucerr'    , 1);
u.port('input','skid_cerr_entry'    , wSkidEntry);
u.port('input','skid_ucerr_entry'   , wSkidEntry);

// Write Resp Errors
u.port('input','bresp_valid'     , 1);
u.port('input','bresp_addr'      , wAddr);
u.port('input','bresp'           , 2);
u.port('input','bresp_ns'        , 1);

// Read Resp Errors
u.port('input','rresp_valid'     , 1);
u.port('input','rresp_addr'      , wAddr);
u.port('input','rresp'           , 2);
u.port('input','rresp_ns'        , 1);

// Read Resp Errors
u.port('input','rb_valid'     , 1);
u.port('input','rb_ready'     , 1);

// Interrupt Signals
u.port('output','c'           , 1);
u.port('output','uc'          , 1);

// Debug/Bist Enable
u.port('input','dii_en_debug_bist'   , 1);

// Target Mismatch Indication
u.port('output','target_mismatch'    , 1);

// Interrupt Signals
u.port('output','cerr_threshold'     , 32);

// Trace Registers
obj.lib.interface('dii_', 'master', traceRegInterface);

// PMON Registers
obj.lib.interface('dii_', 'master', pmonRegInterface);

// Signals used to indicate activity.
u.port('input', 'cmd_req_fifo_empty' ,1);
u.port('input', 'wtt_busy' , 1);
u.port('input', 'rtt_busy' , 1);
u.port('input', 'cmux_busy' , 1);
u.port('input', 'dtr_busy' , 1);
u.port('input', 'str_busy' , 1);

u.port('output', 'csr_protocol_timeout_value', wProtocolTimeout);
u.port('output', 'csr_sys_evt_sender_enable', 1);
u.port('input',  'csr_sys_evt_sender_err_vld', 1);
u.port('input',  'csr_sys_evt_sender_err_f_unit_id', wFUnitId);
u.port('input',  'csr_sys_evt_sender_err_protocol_sys', 1);
u.port('input',  'csr_sys_evt_sender_err_protocol_timeout', 1);
u.port('input',  'csr_sys_evt_sender_err_event_timeout', 1);


for (let i=0; i<CONC_RX_INTF.length; i++) {
    u.port('input', CONC_RX_INTF[i].name+'initiator_id' ,CONC_RX_INTF[i].signals.initiator_id );
    u.port('input', CONC_RX_INTF[i].name+'target_id' , CONC_RX_INTF[i].signals.target_id);
    u.port('input', CONC_RX_INTF[i].name+'UCE' , 1);    
    u.port('input', CONC_RX_INTF[i].name+'valid' , 1);
    u.port('input', CONC_RX_INTF[i].name+'ready' , 1);

  if(CONC_RX_INTF[i].signals.addr != null) {
    u.port('input', CONC_RX_INTF[i].name+'addr' , CONC_RX_INTF[i].signals.addr);
  }
}

// Addr Translation Interface
	u.interface('',   'master',   csrAddrTransInterface);

	var num_rx_channels = CONC_RX_INTF.length;

	// Fault Signaling
	obj.lib.interface('', 'slave', internalFaultInterface);

	//=============================================================================
	// APB Interface
	//=============================================================================

	obj.lib.interface(apbInterfaceName, 'slave', apbInterface);

	//
// generate csrHwPorts
//
var diiCSR           = new m.CreateCSRObj(CSR);
var regs             = diiCSR.spaceBlock[0].registers;
var csrHwPorts       = diiCSR.getHWPorts();
var regFldsIn        = diiCSR.getRegFldsIn();
var regFldsOut       = diiCSR.getRegFldsOut();

var rfSwWdata = {};
regs.forEach( function (r) {
    r.fields.forEach( function (f) {
    var rf        = r.name+"_"+f.name+"_"+"sw_wdata";
    
    if ( rf.includes("Rsv") ) {
    }else {
          rfSwWdata[rf] = f.bitWidth;
    }
    
    });
});
var rfSwWr = regs.map( r => r.name+"_sw_wr");

Object.keys(rfSwWdata).forEach(rf => { csrHwPorts[rf] = rf; });

rfSwWr.forEach(r => { csrHwPorts[r] = r; });

    for(var reg=0; reg < CSR.spaceBlock[0].registers.length; reg++)
        { var reg_name = CSR.spaceBlock[0].registers[reg].name ;
          for(var field=0; field < CSR.spaceBlock[0].registers[reg].fields.length ; field++) {
               var entry =CSR.spaceBlock[0].registers[reg].fields[field]       ;
                    if(reg_name == "DIIUSBSIR" && entry.name == "SkidBufArb") {
                        var wSkidBufArb = entry.bitWidth;
                    }
                    if(reg_name == "DIIUSBSIR" && entry.name == "SkidBufSize") {
                        var wSkidBufSize = entry.bitWidth;
                    }

                  }
        }

\jsend

module \=u.getModuleName()=\ (\=u.getPorts('\n    ')=\);

//=============================================================================
// Target ID Errors
//=============================================================================
reg                                                 target_id_error;
reg [\=CONC_RX_INTF[0].signals.initiator_id -1=\:0] target_id_error_source_id;
reg [\=wAddr-1=\:0]                                 target_id_error_addr;

wire                                                 r_target_id_error;
wire [\=CONC_RX_INTF[0].signals.initiator_id -1=\:0] r_target_id_error_source_id;
wire [\=wAddr-1=\:0]                                 r_target_id_error_addr;

wire r_cmux_UCE, r_cmux_CE;

always @ (*) begin
\js for (let i=0; i<CONC_RX_INTF.length; i++) {
  \js if(i == 0) {
  if ( \=CONC_RX_INTF[i].name=\UCE | ((\=CONC_RX_INTF[i].name=\target_id[\=CONC_RX_INTF[i].signals.target_id=\-1:\=wFPortId=\] != my_f_unit_id) & \=CONC_RX_INTF[i].name=\valid & \=CONC_RX_INTF[i].name=\ready) ) begin
  \js } else {
  else if ( \=CONC_RX_INTF[i].name=\UCE | ((\=CONC_RX_INTF[i].name=\target_id[\=CONC_RX_INTF[i].signals.target_id=\-1:\=wFPortId=\] != my_f_unit_id)  & \=CONC_RX_INTF[i].name=\valid & \=CONC_RX_INTF[i].name=\ready) ) begin
  \js }
     target_id_error           = 1'b1;
     target_id_error_source_id = \=CONC_RX_INTF[i].name=\initiator_id;

     \js if(CONC_RX_INTF[i].signals.addr != null & CONC_RX_INTF[i].signals.addr != 0) {
     target_id_error_addr      =  \=CONC_RX_INTF[i].name=\addr;
     \js } else {
     target_id_error_addr      = \=wAddr=\'h0;
     \js}
  end
\js }
  else begin
     target_id_error           = 1'h0;
     target_id_error_source_id = \=CONC_RX_INTF[0].signals.initiator_id=\'h0;
     target_id_error_addr      = \=wAddr=\'h0;
  end
end

assign target_mismatch = target_id_error;

wire cmux_CE  = (cmux_cmd_req_CE | cmux_dtr_rsp_CE | cmux_str_rsp_CE | cmux_dtw_req_CE);

\=u.dffre(       1
              , 'r_cmux_CE'
	      , 'cmux_CE'
	      , "1'b0"
	      , "1'b1"
	      , 'clk'
	      , 'reset_n')=\

\=u.dffre(       1
              , 'r_cmux_UCE'
	      , 'cmux_UCE'
	      , "1'b0"
	      , "1'b1"
	      , 'clk'
	      , 'reset_n')=\


\=u.dffre(       1
              , 'r_target_id_error'
	      , 'target_id_error'
	      , "1'b0"
	      , "1'b1"
	      , 'clk'
	      , 'reset_n')=\

\=u.dffre(       CONC_RX_INTF[0].signals.initiator_id
              , 'r_target_id_error_source_id'
	      , 'target_id_error_source_id'
	      , '{'+CONC_RX_INTF[0].signals.initiator_id+'{1\'b0}}'
	      , "1'b1"
	      , 'clk'
	      , 'reset_n')=\


\=u.dffre(      wAddr 
              , 'r_target_id_error_addr'
	      , 'target_id_error_addr'
	      , '{'+wAddr+'{1\'b0}}'
	      , "1'b1"
	      , 'clk'
	      , 'reset_n')=\

//=============================================================================
// Widths
//=============================================================================

\jsbegin
var instance_ports_for_dmi_csr_gen = {};
var DIIUCECR_ErrThreshold_width = 0;
var DIIUUESR0_ErrType_width = 0;
var DIIUUESR0_ErrInfo_width = 0;
var DIIUCESR0_ErrType_width = 0;
var DIIUCESR0_ErrInfo_width = 0;
var DIIUCELR0_ErrEntry_width = 20;
var DIIUCELR0_ErrWay_width = 6;
var DIIUCELR0_ErrWord_width = 6;
var DIIUCELR1_ErrAddr_width = 0;
var DIIUUELR0_ErrEntry_width = 20;
var DIIUUELR0_ErrWay_width = 6;
var DIIUUELR0_ErrWord_width = 6;
var DIIUUELR1_ErrAddr_width = 0;
var DIIUCRTR_ResThreshold_width = 0;
var DIIUUESR0_ErrCount_width = 0;
var DIIUCESR0_ErrCount_width = 0;

    for(var reg=0; reg < CSR.spaceBlock[0].registers.length; reg++)
        { var reg_name = CSR.spaceBlock[0].registers[reg].name ;
          for(var field=0; field < CSR.spaceBlock[0].registers[reg].fields.length ; field++) {
               var entry =CSR.spaceBlock[0].registers[reg].fields[field];
	             if(reg_name == "DIIUCRTR" && entry.name == "ResThreshold") {
                         DIIUCRTR_ResThreshold_width = entry.bitWidth;
                     }	       
	             if(reg_name == "DIIUCECR" && entry.name == "ErrThreshold") {
                         DIIUCECR_ErrThreshold_width = entry.bitWidth;
                     }
                     if(reg_name == "DIIUCESR" && entry.name == "ErrType") {
                         DIIUCESR0_ErrType_width = entry.bitWidth;
                     }
                     if(reg_name == "DIIUCESR" && entry.name == "ErrCount") {
                         DIIUCESR0_ErrCount_width = entry.bitWidth;
                     }
                     if(reg_name == "DIIUUESR" && entry.name == "ErrType") {
                         DIIUUESR0_ErrType_width = entry.bitWidth;
                     }
                     if(reg_name == "DIIUCESR" && entry.name == "ErrInfo") {
                         DIIUCESR0_ErrInfo_width = entry.bitWidth;
                     }
                     if(reg_name == "DIIUUESR" && entry.name == "ErrInfo") {
                         DIIUUESR0_ErrInfo_width = entry.bitWidth;
                     }
                     if(reg_name == "DIIUCELR1" && entry.name == "ErrAddr") {
                         DIIUCELR1_ErrAddr_width = entry.bitWidth;
                     }
                     if(reg_name == "DIIUUELR1" && entry.name == "ErrAddr") {
                         DIIUUELR1_ErrAddr_width = entry.bitWidth;
                     }
                  }
        }
	
var correctable_count_width = DIIUCECR_ErrThreshold_width;
\jsend

//=============================================================================
// Wires
//=============================================================================

\js var wide_width = DIIUUELR0_ErrEntry_width + DIIUUELR0_ErrWay_width + DIIUUELR0_ErrWord_width + DIIUUELR1_ErrAddr_width;

wire [\=wide_width=\-1:0] r_target_id_error_addr_wide;
wire [\=wide_width=\-1:0] bresp_addr_wide;
wire [\=wide_width=\-1:0] rresp_addr_wide;

\jsbegin
if (wAddr >= wide_width) {
\jsend
     assign r_target_id_error_addr_wide = r_target_id_error_addr[\=wide_width-1=\:0];

     assign rresp_addr_wide = rresp_addr[\=wide_width-1=\:0];
     assign bresp_addr_wide = bresp_addr[\=wide_width-1=\:0];

\js } else {
     assign r_target_id_error_addr_wide = {\=wide_width-wAddr=\'b0,r_target_id_error_addr};

     assign rresp_addr_wide = {\=wide_width-wAddr=\'b0,rresp_addr};
     assign bresp_addr_wide = {\=wide_width-wAddr=\'b0,bresp_addr};
\js } 

\js Object.keys(rfSwWdata).forEach(rf => {
wire [\=rfSwWdata[rf]-1=\:0] \=rf=\;
\js });
\js rfSwWr.forEach(r => {
wire \=r=\;
\js });

\js for (var rf in regFldsIn) {
wire [\=regFldsIn[rf]-1=\:0] \=rf=\;
\js }

\js for (var rf in regFldsOut) {
wire [\=regFldsOut[rf]-1=\:0] \=rf=\;
\js }

wire irq_c_sig;
wire irq_uc_sig;
wire irq_c_q;
wire irq_uc_q;

wire corr_err_exceed_threshold;

\js if ( hasCorrectableRegisters == 1 ){
wire [\=correctable_count_width-1=\:0] s_CECR_ErrThreshold;
wire [\=correctable_count_width-1=\:0] s_CESR_ErrCount;
wire [\=correctable_count_width-1=\:0] in_CESR_ErrCount;
wire corr_err_vld;
wire [\=DIIUCESR0_ErrType_width-1=\:0]  corr_err_type;
wire [\=DIIUCESR0_ErrInfo_width-1=\:0]  corr_err_info;
wire [\=DIIUCELR0_ErrWord_width-1=\:0] corr_err_word;
wire [\=DIIUCELR0_ErrWay_width-1=\:0]  corr_err_way;
wire [\=DIIUCELR0_ErrEntry_width-1=\:0]corr_err_entry;
wire [\=DIIUCELR1_ErrAddr_width-1=\:0] corr_err_erraddr;
\js }

wire uncorr_err_vld;
wire [\=DIIUUESR0_ErrType_width-1=\:0]  uncorr_err_type;
wire [\=DIIUUESR0_ErrInfo_width-1=\:0]  uncorr_err_info;
wire [\=DIIUUELR0_ErrWord_width-1=\:0] uncorr_err_word;
wire [\=DIIUUELR0_ErrWay_width-1=\:0]  uncorr_err_way;
wire [\=DIIUUELR0_ErrEntry_width-1=\:0]uncorr_err_entry;
wire [\=DIIUUELR1_ErrAddr_width-1=\:0] uncorr_err_erraddr;

wire [30:0] csr_timeout_threshold;

//=============================================================================
// Logic
//=============================================================================

wire dff_enable = 1'b1;

//=============================================================================
// Register Functionality
//=============================================================================

//----------------------------------------------------------------------------
// Assign Trace Registers

\=m.bundleFunctions.assignByBundle('dii_' , 'DII', traceRegInterface, ['CCTRLR_ndn0Tx_out','CCTRLR_ndn0Rx_out','CCTRLR_ndn1Tx_out','CCTRLR_ndn1Rx_out','CCTRLR_ndn2Tx_out','CCTRLR_ndn2Rx_out','CCTRLR_dn0Tx_out','CCTRLR_dn0Rx_out'], u.bundle)=\
assign dii_CCTRLR_ndn0Tx_out = DIICCTRLR_ndn0Tx_out && dii_en_debug_bist;
assign dii_CCTRLR_ndn0Rx_out = DIICCTRLR_ndn0Rx_out && dii_en_debug_bist;
assign dii_CCTRLR_ndn1Tx_out = DIICCTRLR_ndn1Tx_out && dii_en_debug_bist;
assign dii_CCTRLR_ndn1Rx_out = DIICCTRLR_ndn1Rx_out && dii_en_debug_bist;
assign dii_CCTRLR_ndn2Tx_out = DIICCTRLR_ndn2Tx_out && dii_en_debug_bist;
assign dii_CCTRLR_ndn2Rx_out = DIICCTRLR_ndn2Rx_out && dii_en_debug_bist;
assign dii_CCTRLR_dn0Tx_out = DIICCTRLR_dn0Tx_out && dii_en_debug_bist;
assign dii_CCTRLR_dn0Rx_out = DIICCTRLR_dn0Rx_out && dii_en_debug_bist;
\=m.bundleFunctions.assignByBundle('dii_' , 'DII', pmonRegInterface, [], u.bundle)=\

//-----------------------------------------------------------------------------
// Active Signal

assign DIIUTAR_TransActv_in =
                          ~cmd_req_fifo_empty     | // Empty Command FIFO
                          str_busy                | // All STRs Completed
                          dtr_busy                | // All DTRs COmpleted
                          rtt_busy                | // No Valid RTT Entries
                          wtt_busy                ; // No Valid WTT Entries

assign DIIUTAR_TransActv_wr = 1'b1;

//-----------------------------------------------------------------------------
// ID and other Static Registers
\jsbegin
// Width of fUnitId wont get up to 16
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
if( wFUnitId == 16) {
\jsend
assign DIIUFUIDR_FUnitId_in = my_f_unit_id;
\js } else {
assign DIIUFUIDR_FUnitId_in = {\=16-wFUnitId=\'b0,my_f_unit_id};
\js }

\jsbegin
// Width of nUnitId wont get up to 12
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
if( wNUnitId == 12) {
\jsend
assign DIIUIDR_NUnitId_in = my_n_unit_id;
\js } else {
assign DIIUIDR_NUnitId_in = {\=12-wNUnitId=\'b0,my_n_unit_id};
\js }

assign DIIUIDR_RPN_in        = my_csr_rpn;
assign DIIUIDR_NRRI_in       = my_csr_nrri;
assign DIIUIDR_Valid_in      = 1'b0;
assign DIIUUEVIR_EngVerId_in = 32'd0;
assign DIIUINFOR_ImplVer_in  = 16'd0;
assign DIIUINFOR_UT_in       = 4'b0;
assign DIIUINFOR_Valid_in    = 1'b0;
assign DIIUINFOR_UST_in      = 4'h0;

// Correctable Errors
\js if (hasCorrectableRegisters == 1) {
assign corr_err_exceed_threshold = (DIIUCESR_ErrCount_out == DIIUCECR_ErrThreshold_out);

assign DIIUCESR_ErrVld_in   = DIIUCESAR_sw_wr                                                   ?  DIIUCESAR_ErrVld_sw_wdata                         :
                             (DIIUCESR_sw_wr & DIIUCESR_ErrVld_out)                             ?(~DIIUCESR_ErrVld_sw_wdata[0] & DIIUCESR_ErrVld_out)   :
                             (corr_err_vld & corr_err_exceed_threshold & DIIUCECR_ErrDetEn_out) ?  1'b1                                              : 
                              DIIUCESR_ErrVld_out;

assign DIIUCESR_ErrType_in  = DIIUCESAR_sw_wr                                                   ? DIIUCESAR_ErrType_sw_wdata    :
                             (corr_err_vld & ~DIIUCESR_ErrVld_out & DIIUCECR_ErrDetEn_out)      ? corr_err_type                 : 
                              DIIUCESR_ErrType_out;

assign DIIUCESR_ErrInfo_in  = DIIUCESAR_sw_wr                                                   ? DIIUCESAR_ErrInfo_sw_wdata    :
                             (corr_err_vld & ~DIIUCESR_ErrVld_out & DIIUCECR_ErrDetEn_out)      ? corr_err_info                 : 
                              DIIUCESR_ErrInfo_out;
			      
assign DIIUCESR_ErrVld_wr         = DIIUCESAR_sw_wr | DIIUCESR_sw_wr | (corr_err_vld & corr_err_exceed_threshold & DIIUCECR_ErrDetEn_out);
assign DIIUCESR_ErrType_wr        = DIIUCESAR_sw_wr | (corr_err_vld & ~DIIUCESR_ErrVld_out & DIIUCECR_ErrDetEn_out); 
assign DIIUCESR_ErrInfo_wr        = DIIUCESAR_sw_wr | (corr_err_vld & ~DIIUCESR_ErrVld_out & DIIUCECR_ErrDetEn_out);

\js // error count
assign DIIUCESR_ErrCount_in = DIIUCESAR_sw_wr                            ? DIIUCESAR_ErrCount_sw_wdata :
                             (DIIUCESR_sw_wr & DIIUCESR_ErrVld_sw_wdata) ? \=regFldsIn[`DIIUCESR_ErrCount_in`]=\'b0 : (DIIUCESR_ErrCount_out + 1'b1); 
assign DIIUCESR_ErrCount_wr = DIIUCESAR_sw_wr |
                             (DIIUCESR_sw_wr & DIIUCESR_ErrVld_sw_wdata & DIIUCESR_ErrVld_out) |
                             (corr_err_vld & DIIUCECR_ErrDetEn_out & ~corr_err_exceed_threshold);
assign DIIUCESR_ErrCountOverflow_in = DIIUCESAR_sw_wr                        ? DIIUCESAR_ErrCountOverflow_sw_wdata :
                             (DIIUCESR_sw_wr & DIIUCESR_ErrVld_sw_wdata) ? 1'b0 : 1'b1;
assign DIIUCESR_ErrCountOverflow_wr =DIIUCESAR_sw_wr |
                             ((DIIUCESR_sw_wr & DIIUCESR_ErrVld_sw_wdata) | (corr_err_vld & ~DIIUCESR_ErrCountOverflow_out & DIIUCECR_ErrDetEn_out)) & DIIUCESR_ErrVld_out;
\js } else {
wire DIIUCESR_ErrVld_out = 1'h0;
\js }


// Uncorrectable Errors


assign DIIUUESR_ErrVld_in   = DIIUUESAR_sw_wr                               ?  DIIUUESAR_ErrVld_sw_wdata:
                             (DIIUUESR_sw_wr & DIIUUESR_ErrVld_out)         ?(~DIIUUESR_ErrVld_sw_wdata[0] & DIIUUESR_ErrVld_out)  :
                             (uncorr_err_vld )    ? 1'b1                                                                        : 
                              DIIUUESR_ErrVld_out;

assign DIIUUESR_ErrType_in  = DIIUUESAR_sw_wr                                                   ? DIIUUESAR_ErrType_sw_wdata    :
                             (uncorr_err_vld & ~DIIUUESR_ErrVld_out) ? uncorr_err_type               : 
                              DIIUUESR_ErrType_out;

assign DIIUUESR_ErrInfo_in  = DIIUUESAR_sw_wr                                                   ? DIIUUESAR_ErrInfo_sw_wdata    :
                             (uncorr_err_vld & ~DIIUUESR_ErrVld_out) ? uncorr_err_info               : 
                              DIIUUESR_ErrInfo_out;

assign DIIUUESR_ErrVld_wr          = DIIUUESAR_sw_wr | DIIUUESR_sw_wr | (uncorr_err_vld);
assign DIIUUESR_ErrType_wr         = DIIUUESAR_sw_wr | (uncorr_err_vld & ~DIIUUESR_ErrVld_out); 
assign DIIUUESR_ErrInfo_wr         = DIIUUESAR_sw_wr | (uncorr_err_vld & ~DIIUUESR_ErrVld_out);


\js if(useResiliency == 1){
reg [31:0] r_cerr_threshold;

always @(*) begin
  r_cerr_threshold[31:\=DIIUCRTR_ResThreshold_width=\] = \=32-DIIUCRTR_ResThreshold_width=\'h0;
  r_cerr_threshold[\=DIIUCRTR_ResThreshold_width-1=\:0] = DIIUCRTR_ResThreshold_out;
end

assign cerr_threshold = r_cerr_threshold;
\js } else {
assign cerr_threshold = 'h0;
\js }

wire bresp_err = bresp[1] & bresp_valid; 
wire rresp_err = rresp[1] & rresp_valid;

wire rbuc_err = 1'b0; //rb_valid & rb_ready & read_buffer_UCE;

\js if (hasCorrectableRegisters == 1) {
  wire rbc_err  = 1'b0; //rb_valid & rb_ready & read_buffer_CE;

  assign corr_err_vld       = (rbc_err | r_cmux_CE | skid_cerr)            ; 
  assign corr_err_type      = (r_cmux_CE          ) ? \=DIIUCESR0_ErrType_width=\'h8   : \=DIIUCESR0_ErrType_width=\'h0;
  assign corr_err_info      = 
                              \js if (wSkidEntry > 1) {
                              (skid_cerr          ) ? ((skid_cerr_entry[\=wSkidEntry-1=\]) ? \=DIIUCESR0_ErrInfo_width=\'d6 : \=DIIUCESR0_ErrInfo_width=\'d5)  :
                              \js }
			      \jsbegin
                  /* istanbul ignore else env ncore_3p6,ncore_3p7 */
                  if (10 > wFUnitId) { \jsend
			      (r_cmux_CE          ) ?  {\=10 - wFUnitId=\'b0,r_target_id_error_source_id[\=wFPortId+wFUnitId-1=\:\=wFPortId=\],6'b0} : \=DIIUCESR0_ErrInfo_width=\'d0;			      
			      \js } else /* istanbul ignore next env ncore_3p2,ncore_3p0,ncore_3p4 */  {
			      (r_cmux_CE          ) ?  {r_target_id_error_source_id[\=wFPortId+12-1=\:\=wFPortId=\]                           ,6'b0} : \=DIIUCESR0_ErrInfo_width=\'d0;			      			      			      
			      \js }  
  assign corr_err_entry     = \=DIIUCELR0_ErrEntry_width=\'h0;
  assign corr_err_way       = \=DIIUCELR0_ErrWay_width=\'h0; 
  assign corr_err_word      = \=DIIUCELR0_ErrWord_width=\'h0; 
  assign corr_err_erraddr   = \=DIIUCELR1_ErrAddr_width=\'h0;

  \js let total_addr_width = DIIUCELR0_ErrEntry_width + DIIUCELR0_ErrWay_width + DIIUCELR0_ErrWord_width;

  assign DIIUCELR0_ErrAddr_wr   =(corr_err_vld & ~DIIUCESR_ErrVld_out & DIIUCECR_ErrDetEn_out);
  assign DIIUCELR1_ErrAddr_wr   =(corr_err_vld & ~DIIUCESR_ErrVld_out & DIIUCECR_ErrDetEn_out);
  
  \js if ( wSkidEntry == 1) {
  assign DIIUCELR0_ErrAddr_in   = {corr_err_word,corr_err_way,corr_err_entry};
  \js } else {
  assign DIIUCELR0_ErrAddr_in   = (skid_cerr          ) ?  {\=(total_addr_width-wSkidEntry)+1=\'h0,skid_cerr_entry[\=wSkidEntry-2=\:0]} : {corr_err_word,corr_err_way,corr_err_entry}; 
  \js }

  assign DIIUCELR1_ErrAddr_in   = (skid_cerr          ) ?  \=DIIUCELR1_ErrAddr_width=\'h0                                               :  corr_err_erraddr; 
\js }

wire transport_error = r_target_id_error | r_cmux_UCE;

\js //gate uncorrectable errors with interrupt enable
wire uncorr_mem_err_int = DIIUUEIR_MemErrIntEn_out & DIIUUESR_ErrVld_out & (DIIUUESR_ErrType_out == \=DIIUUESR0_ErrType_width=\'h0);
wire uncorr_prot_err_int = DIIUUEIR_ProtErrIntEn_out & DIIUUESR_ErrVld_out & (DIIUUESR_ErrType_out == \=DIIUUESR0_ErrType_width=\'h2 | DIIUUESR_ErrType_out == \=DIIUUESR0_ErrType_width=\'h3);
wire uncorr_trans_err_int = DIIUUEIR_TransErrIntEn_out & DIIUUESR_ErrVld_out & (DIIUUESR_ErrType_out == \=DIIUUESR0_ErrType_width=\'h8);
wire uncorr_timeout_err_int = DIIUUEIR_TimeoutErrIntEn_out & DIIUUESR_ErrVld_out & (DIIUUESR_ErrType_out == \=DIIUUESR0_ErrType_width=\'ha);

\js //remove unused logic
wire uncorr_err_vld_int     = \jsbegin
                              // Not using external memories
                              /* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
                              if (useExternalMemory == 1) {
                              \jsend
                              (rbuc_err & DIIUUEIR_MemErrIntEn_out) |
			      \js }
                              (skid_ucerr & DIIUUEIR_MemErrIntEn_out) |			      
                              (bresp_err & DIIUUEIR_ProtErrIntEn_out) |
			      (rresp_err & DIIUUEIR_ProtErrIntEn_out) |
			      (transport_error & DIIUUEIR_TransErrIntEn_out);
			      
assign uncorr_err_vld       =  \jsbegin
                               // Not usining external memories
                               /* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
                               if (useExternalMemory == 1) {
			       \jsend
			       1'b0 | //(read_buffer_UCE & DIIUUEDR_MemErrDetEn_out) |
			       \js }
                              (skid_ucerr & DIIUUEDR_MemErrDetEn_out) |			       
                              (bresp_err & DIIUUEDR_ProtErrDetEn_out) |
			      (rresp_err & DIIUUEDR_ProtErrDetEn_out) |
			      (transport_error & DIIUUEDR_TransErrDetEn_out) |
			      (csr_sys_evt_sender_err_vld & (csr_sys_evt_sender_err_protocol_timeout | csr_sys_evt_sender_err_event_timeout) & DIIUUEDR_TimeoutErrDetEn_out);
assign uncorr_err_type      = // read_buffer_UCE ? \=DIIUUESR0_ErrType_width=\'d1 :
                              skid_ucerr      ? \=DIIUUESR0_ErrType_width=\'d0 :
                              bresp_err       ? \=DIIUUESR0_ErrType_width=\'d2 :
			      rresp_err       ? \=DIIUUESR0_ErrType_width=\'d3 :
			      transport_error ? \=DIIUUESR0_ErrType_width=\'d8 : 
			      csr_sys_evt_sender_err_vld ? \=DIIUUESR0_ErrType_width=\'ha : \=DIIUUESR0_ErrType_width=\'d0;
assign uncorr_err_info      = bresp_err       ? {\=DIIUUESR0_ErrInfo_width-3=\'b0, bresp_ns, bresp} :
			      rresp_err       ? {\=DIIUUESR0_ErrInfo_width-3=\'b0, rresp_ns, rresp} :
			      \js if (wSkidEntry > 1) {
                              skid_ucerr      ? ((skid_ucerr_entry[\=wSkidEntry-1=\]) ? \=DIIUUESR0_ErrInfo_width=\'d6 :  \=DIIUUESR0_ErrInfo_width=\'d5) :
                              \js }
			      csr_sys_evt_sender_err_vld ? (csr_sys_evt_sender_err_event_timeout ? {\=DIIUUESR0_ErrInfo_width-1=\'b0, 1'b1} : {\=DIIUUESR0_ErrInfo_width=\'b0} ) :  \jsbegin	
				
			      // Initiator ID will always be able to fit inside ErrInfo Field
			      /* istanbul ignore else env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
			      if (12 > wFUnitId) {
			      \jsend
			      transport_error ? {\=12 - wFUnitId=\'b0,r_target_id_error_source_id[\=wFPortId+wFUnitId-1=\:\=wFPortId=\],7'b0,cmux_UCE} : \=DIIUUESR0_ErrInfo_width=\'d0;			      
			      \js } else /* istanbul ignore next env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */  {
			      transport_error ? {r_target_id_error_source_id[\=wFPortId+12-1=\:\=wFPortId=\],7'b0,cmux_UCE} : \=DIIUUESR0_ErrInfo_width=\'d0;			      			      			      
			      \js }
assign uncorr_err_entry     = bresp_err       ? bresp_addr_wide[\=DIIUUELR0_ErrEntry_width-1=\:0] :
                              rresp_err       ? rresp_addr_wide[\=DIIUUELR0_ErrEntry_width-1=\:0] :
			      r_target_id_error ? r_target_id_error_addr_wide[\=DIIUUELR0_ErrEntry_width-1=\:0] : \=DIIUUELR0_ErrEntry_width=\'b0;
assign uncorr_err_way       = bresp_err       ? bresp_addr_wide[\=DIIUUELR0_ErrEntry_width + DIIUUELR0_ErrWay_width-1=\:\=DIIUUELR0_ErrEntry_width=\] :
                              rresp_err       ? rresp_addr_wide[\=DIIUUELR0_ErrEntry_width + DIIUUELR0_ErrWay_width-1=\:\=DIIUUELR0_ErrEntry_width=\] :
			      r_target_id_error ? r_target_id_error_addr_wide[\=DIIUUELR0_ErrEntry_width + DIIUUELR0_ErrWay_width-1=\:\=DIIUUELR0_ErrEntry_width=\] : \=DIIUUELR0_ErrWay_width=\'b0;
assign uncorr_err_word      = bresp_err       ? bresp_addr_wide[\=DIIUUELR0_ErrEntry_width + DIIUUELR0_ErrWay_width + DIIUUELR0_ErrWord_width-1=\:\=DIIUUELR0_ErrEntry_width + DIIUUELR0_ErrWay_width=\] :
                              rresp_err       ? rresp_addr_wide[\=DIIUUELR0_ErrEntry_width + DIIUUELR0_ErrWay_width + DIIUUELR0_ErrWord_width-1=\:\=DIIUUELR0_ErrEntry_width + DIIUUELR0_ErrWay_width=\] :
			      r_target_id_error ? r_target_id_error_addr_wide[\=DIIUUELR0_ErrEntry_width + DIIUUELR0_ErrWay_width + DIIUUELR0_ErrWord_width-1=\:\=DIIUUELR0_ErrEntry_width + DIIUUELR0_ErrWay_width=\]: 6'h0;
\js var final_width = DIIUUELR0_ErrEntry_width + DIIUUELR0_ErrWay_width + DIIUUELR0_ErrWord_width;
assign uncorr_err_erraddr   = bresp_err       ? bresp_addr_wide[\=DIIUUELR1_ErrAddr_width+final_width-1=\:\=final_width=\] :
                              rresp_err       ? rresp_addr_wide[\=DIIUUELR1_ErrAddr_width+final_width-1=\:\=final_width=\] :
			      r_target_id_error ? r_target_id_error_addr_wide[\=DIIUUELR1_ErrAddr_width+final_width-1=\:\=final_width=\] : \=DIIUUELR1_ErrAddr_width=\'b0;
									      

assign DIIUUELR0_ErrAddr_wr   =(uncorr_err_vld & ~DIIUUESR_ErrVld_out);
assign DIIUUELR1_ErrAddr_wr   =(uncorr_err_vld & ~DIIUUESR_ErrVld_out);

\js let total_addr_width = DIIUUELR0_ErrEntry_width + DIIUUELR0_ErrWay_width + DIIUUELR0_ErrWord_width;

\js if (wSkidEntry == 1) {
assign DIIUUELR0_ErrAddr_in   = {uncorr_err_word, uncorr_err_way, uncorr_err_entry};
\js } else {
assign DIIUUELR0_ErrAddr_in   = (skid_ucerr          ) ?  {\=(total_addr_width-wSkidEntry)+1=\'h0,skid_ucerr_entry[\=wSkidEntry-2=\:0]} : {uncorr_err_word, uncorr_err_way, uncorr_err_entry};
\js}

assign DIIUUELR1_ErrAddr_in   = (skid_ucerr          ) ?  \=DIIUUELR1_ErrAddr_width=\'h0                                                :  uncorr_err_erraddr; \jsbegin


// PMON Regs
if (nPerfCounters) { \jsend
wire [\=nPerfCounters-1=\:0] corr_pmon_ovf_int; \jsbegin
} 
for(let i=0; i<nPerfCounters; i++) { \jsend
assign corr_pmon_ovf_int[\=i=\] = DIICNTCR\=i=\_InterruptEn_out & DIICNTCR\=i=\_OverFlowStatus_out; \jsbegin
} \jsend

wire corr_pmon_int; \jsbegin
 
if (nPerfCounters) { \jsend
assign corr_pmon_int = |corr_pmon_ovf_int; \jsbegin
} else { \jsend
assign corr_pmon_int = 1'b0; \jsbegin
} \jsend
// Interrupts

\js if (hasCorrectableRegisters == 1) {
assign irq_c_sig  = corr_pmon_int | (DIIUCECR_ErrIntEn_out & (DIIUCESR_ErrVld_out & !((DIIUCESR_ErrType_out == \=DIIUUESR0_ErrType_width=\'d2) | (DIIUCESR_ErrType_out == \=DIIUUESR0_ErrType_width=\'d3))));
\js } else {
assign irq_c_sig  = corr_pmon_int;
\js }

assign irq_uc_sig = uncorr_prot_err_int		| 
					uncorr_mem_err_int		|
					uncorr_trans_err_int	|
					uncorr_timeout_err_int	;

\=obj.lib.dffre(1, 'irq_c_q',  'irq_c_sig',  "1'b0", 'dff_enable', 'clk', 'reset_n')=\
\=obj.lib.dffre(1, 'irq_uc_q', 'irq_uc_sig', "1'b0", 'dff_enable', 'clk', 'reset_n')=\

assign c = irq_c_q;
assign uc = irq_uc_q;

//=============================================================================
// Skidbuffer Info
//=============================================================================

assign DIIUSBSIR_SkidBufArb_in  = \=wSkidBufArb=\'h0; 
assign DIIUSBSIR_SkidBufSize_in = \=wSkidBufSize=\'h0;
assign DIIUSBSIR_Valid_in       = 1'b0; \jsbegin

//=============================================================================
// System Event and Coherency Registers
//=============================================================================
\jsend

assign csr_timeout_threshold = DIIUTOCR_TimeOutThreshold_out; 

assign csr_protocol_timeout_value  = {|{DIIUSEPTOCR_TimeOutThreshold_out}} ? ({|{DIIUSEPTOCR_TimeOutThreshold_out[30:8]}} ? {\=wProtocolTimeout=\{1'b1}} : {DIIUSEPTOCR_TimeOutThreshold_out[7:0], {12{1'b0}}}) : {\=wProtocolTimeout=\{1'b0}};
assign csr_sys_evt_sender_enable   = ~DIIUTCR_EventDisable_out; \jsbegin




//=============================================================================
// Addr Translation Interface
//=============================================================================
\jsend
\js if(useAddrTranslation) {
    \js for(var i = 0; i < nAddrTransRegisters; i++) {
assign csr_ATER_\=i=\_Valid   = DIIUATER\=i=\_Valid_out;
assign csr_ATER_\=i=\_Mask    = DIIUATER\=i=\_Mask_out;
assign csr_RFAR_\=i=\_FromAddr= DIIURFAR\=i=\_FromAddr_out;
assign csr_RTAR_\=i=\_ToAddr  = DIIURTAR\=i=\_ToAddr_out;
    \js }
\js }

\jsbegin
//=============================================================================
// DII CSR Instance
//=============================================================================

//-----------------------------------------------------------------------------
// CSR Control Interfaces

var reg_interfaces = [];

reg_interfaces.push({
        modulePrefix: 'a_',
        localPrefix: '',
        interface: clkInterface
});

reg_interfaces.push({
        modulePrefix: apbInterfaceName,
        localPrefix: apbInterfaceName,
        interface: apbInterface
});

// Dont have register flop protection
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
if(regProtectionStyle != null) {
  /* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
  if(regProtectionStyle.protection != "none") {
    reg_interfaces.push({
        modulePrefix: regProtectionInterfaceName,
        localPrefix: regProtectionInterfaceName,
        interface: regProtectionInterface
    });
  }
}

\jsend

\=u.instance({
            instanceName: 'dii_csr_gen' ,
            moduleName: 'apb_csr',
            params: {
                clkInterface          : {"name" : 'a_'              ,         "signals" : clkInterface},
                cfgInterface          : {"name" : apbInterfaceName,           "signals" : apbInterface},
                protectionInterface   : {"name" : regProtectionInterfaceName, "signals" : regProtectionInterface},
                protectionStyle       : regProtectionStyle,
                flopAPB               : "yes",
                csr                   : CSR
            } ,
            verilogParams: {},
            ports: csrHwPorts,
            interfaces : reg_interfaces,
            portsDelimiter: '\n    '
        })=\

assign csr_force_arid_low = DIIUENGDBR_ForceArIdZeros_out;
assign csr_force_awid_low = DIIUENGDBR_ForceAwIdZeros_out;
assign csr_force_ro_vz_hi = DIIUENGDBR_ForceROLateWriteResponse_out;
assign csr_force_eo_vz_hi = DIIUENGDBR_ForceEOLateWriteResponse_out;
assign csr_exclude_ro_write_from_wo = DIIUENGDBR_ExcludeROWriteFromWO_out;
assign csr_exclude_initiator_from_ordering = DIIUENGDBR_ExcludeInitiatorFromOrdering_out;

endmodule
