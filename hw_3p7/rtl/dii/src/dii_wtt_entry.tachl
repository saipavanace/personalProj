//=============================================================================
// Copyright (C) 2017 Arteris, Inc.
// All rights reserved.
//=============================================================================

\jsbegin
    var u = obj.lib;
    var addr_width           =  u.getParam('wAddr');
    var tid_width            =  u.getParam('wMsgId');
    var tt_id_width          =  u.getParam('tt_id_width');
    var init_id_width        =  u.getParam('wInitiatorId'); 
    var axi_id_width         =  u.getParam('axi_id_width');
    var cmd_intfsize_width   =  u.getParam('wIntfSize');
    var cmd_mpf1_width       =  u.getParam('wMpf1');
    var cmd_mpf2_width       =  u.getParam('wMpf2');
    var cmd_tof_width        =  u.getParam('wTOF');
    var wQl                  =  u.getParam('wQl');
    var wPri                 =  u.getParam('wPri');
    var wQos                 =  u.getParam('wQos');          
    var arprot_width         =  u.getParam('arprot_width');
    var aruser_width         =  u.getParam('aruser_width');
    var wFUnitId             =  u.getParam('wFUnitId');
    var wFPortId             =  u.getParam('wFPortId');
\jsend

\jsbegin
//=============================================================================
// ports
//=============================================================================
    u.port('input', 'clk', 1);
    u.port('input', 'reset_n', 1);
    u.port('input', 'wtt_allocate_new_entry', 1);
    u.port('input', 'rtt_allocate_new_entry', 1);
    u.port('input', 'addr_in', addr_width);
    u.port('input', 'size_in', 3);
    u.port('input', 'tof_in', cmd_tof_width);
    u.port('input', 'qos_in', wQos);
    u.port('input', 'ordering_in', 2);
    u.port('input', 'prot_in', 3);
    u.port('input', 'lock_in', 1);
    if (aruser_width > 0) {
      u.port('input', 'user_in', aruser_width);
    }
    u.port('input', 'intfsize_in', cmd_intfsize_width);
    u.port('input', 'narrow_in', 1);  
    u.port('input', 'ex_pass_in', 1);
    u.port('input', 'st_in', 1);
    u.port('input', 'ca_in', 1);
    u.port('input', 'ac_in', 1);
    u.port('input', 'vz_in', 1);
    u.port('input', 'tm_in', 1);
    u.port('input', 'ch_in', 1);
    u.port('input', 'cmo_in' , 1);
    u.port('input', 'ql_in'  , wQl);
    u.port('input', 'priority_in' , wPri);        
    u.port('input', 'mpf1_in', cmd_mpf1_width);
    u.port('input', 'mpf2_in', cmd_mpf2_width);
    u.port('input', 'tid_in', tid_width);
    u.port('input', 'init_id_in', wFUnitId);
    u.port('input', 'axi_id_in', axi_id_width);
    u.port('input', 'wr_enable',   1);
    u.port('input', 'ro_depnd_set',   1);
    u.port('input', 'eo_depnd_set',   1);
    u.port('input', 'wo_depnd_set',   1);
    u.port('input', 'axi_depnd_set',  1);
    u.port('input', 'sleep_set',  1);
    u.port('input', 'oldest_entry_set',  1);
    u.port('input', 'ro_depnd_clear', 1);
    u.port('input', 'eo_depnd_clear', 1);
    u.port('input', 'wo_depnd_clear', 1);
    u.port('input', 'axi_depnd_clear',1);
    u.port('input', 'oldest_entry_clear',1);
    u.port('input', 'sleep_clear',1);
    u.port('input', 'valid_clear',1);
    u.port('input', 'ro_depnd_id_in',  tt_id_width);
    u.port('input', 'eo_depnd_id_in',  tt_id_width);
    u.port('input', 'axi_depnd_id_in', tt_id_width);
    u.port('input', 'wo_depnd_id_in',  tt_id_width);
    u.port('input', 'cmo_halt_set'           , 1);
    u.port('output', 'cmo_halt'               , 1);
    u.port('input', 'cmo_halt_id_in'         , tt_id_width);
    u.port('output', 'cmo_halt_id'            , tt_id_width);
    u.port('input', 'dtw_tid_in',  tid_width);
    u.port('input', 'dtw_priority_in',  wPri);
    u.port('input', 'dtw_ql_in',  wQl);
    u.port('input', 'wtt_str_grant', 1);
    u.port('input', 'wtt_grant', 1);
    u.port('input', 'data_rcvd', 1);
    u.port('input', 'wtt_ro_match_wr', 1);
    u.port('input', 'wtt_eo_match_wr', 1);
    u.port('input', 'wtt_wo_match_wr', 1);
    u.port('input', 'new_wtt_ro_depnd', 1);
    u.port('input', 'new_wtt_eo_depnd', 1);
    u.port('input', 'new_wtt_wo_depnd', 1);
    u.port('input', 'wtt_dbad_in', 1);    
    u.port('output', 'str_sent_out', 1);
    u.port('output', 'wtt_entry_muxarb_valid', 1);
    u.port('input',  'ewa_sent_set',  1);
    u.port('output', 'data_pending_out', 1);
    u.port('output', 'axi_depnd_in',  1);
    u.port('output', 'wtt_grant_given', 1);
    u.port('output', 'wtt_grant_given_in', 1);
    u.port('output', 'ewa', 1);
    u.port('input',  'axi_depnd_sent', 1);

    // ET: CLEANUP
    u.port('output', 'valid', 1);
    u.port('output', 'sleep', 1);

    u.port('output', 'priority_out', wPri);

obj.lib.interface('', 'master', obj.lib.getParam('TTentry2'), ['cmo','resp_pending','clear','ewa','wr_enable','muxarb_valid','valid','sleep','narrow']);
obj.lib.interface('', 'master', obj.lib.getParam('TT1'),      ['resp_pending','mpf2', 'attr','cmo','prot','tof','priority','ex_pass','lock']);

\jsend


module \=u.getModuleName()=\ (
\=u.getPorts('\n    ')=\
);

wire [1:0] ro_depnd_in;
wire [1:0] eo_depnd_in;
wire wo_depnd_in;
wire response_pending;
wire data_pending_in;
wire wtt_entry_write;
wire valid_set;
wire valid_in;
wire wtt_entry_muxarb_valid_set;
wire wtt_entry_muxarb_valid_clear;
wire wtt_entry_muxarb_valid_in;
wire ewa_sent_in;
wire ewa_sent_en;
wire ro_depnd_en;
wire eo_depnd_en;
wire wo_depnd_en;
wire axi_depnd_en;
wire oldest_entry_in;
wire youngest_axi_entry_set;
wire youngest_axi_entry_clear;
wire youngest_axi_in;
wire youngest_ro_entry_set;
wire youngest_ro_entry_clear;
wire youngest_ro_in;
wire youngest_eo_entry_set;
wire youngest_eo_entry_clear;
wire youngest_eo_in;
wire youngest_wo_entry_set;
wire youngest_wo_entry_clear;
wire youngest_wo_in;
wire response_pending_set;
wire response_pending_clear;
wire response_pending_in;
wire sleep_in;
wire data_pending_set;
wire data_pending_clear;
wire str_sent_set;
wire str_sent_clear;
wire str_sent_in;
wire cmo_halt_clear;
wire cmo_halt_in;

assign ewa = !vz & valid;

// 
wire [\=cmd_mpf2_width=\-1:0] mpf2;

assign wtt_entry_write = wtt_allocate_new_entry & wr_enable;

//WTT valid
assign valid_set = wtt_entry_write;

assign valid_in =  valid_set | (valid & ~valid_clear);

\=u.dffre(       1
              , 'valid'
	      , 'valid_in'
	      , "1'b0"
	      , "1'b1" 
	      , 'clk'
	      , 'reset_n')=\
	      
//WTT entry  not having any dependencies valid for arbitration

wire axi_depnd_for_muxarb = (wtt_entry_write ? axi_depnd_in : axi_depnd);

assign wtt_entry_muxarb_valid_set =  (valid_in & ~data_pending_in) & ~(ro_depnd_in[1] | eo_depnd_in[1] | wo_depnd_in | (axi_depnd_for_muxarb & ~axi_depnd_sent)) & ~(wtt_grant_given | wtt_grant_given_in) ;

assign wtt_entry_muxarb_valid_clear = wtt_grant;

assign wtt_entry_muxarb_valid_in =  wtt_entry_muxarb_valid_set | (wtt_entry_muxarb_valid & ~wtt_entry_muxarb_valid_clear);

\=u.dffre(       1
              , 'wtt_entry_muxarb_valid'
	      , 'wtt_entry_muxarb_valid_in'
	      , "1'b0"
	      , "1'b1" 
	      , 'clk'
	      , 'reset_n')=\

assign wtt_grant_given_in =  wtt_grant;

wire wtt_grant_given_d =  valid_set ? 1'b0 : ((wtt_entry_muxarb_valid & wtt_grant) | wtt_grant_given);

\=u.dffre(       1
              , 'wtt_grant_given'
	      , 'wtt_grant_given_d'
	      , "1'b0"
	      , "1'b1" 
	      , 'clk'
	      , 'reset_n')=\

\=u.dffre(       addr_width
              , 'addr'
	      , 'addr_in'
	      , '{'+addr_width+'{1\'b0}}'
	      , 'wtt_entry_write' 
	      , 'clk'
	      , 'reset_n')=\

\=u.dffre(       3
              , 'size'
	      , 'size_in'
	      , "3'b0"
	      , 'wtt_entry_write'
	      , 'clk'
	      , 'reset_n')=\

\=u.dffre(       cmd_tof_width
              , 'tof'
	      , 'tof_in'
	      , '{'+cmd_tof_width+'{1\'b0}}'
	      , 'wtt_entry_write'
	      , 'clk'
	      , 'reset_n')=\

\jsbegin
if(wQos != 0) {
\jsend
\=u.dffre(       wQos
              , 'qos'
	      , 'qos_in'
	      , '{'+wQos+'{1\'b0}}'
	      , 'wtt_entry_write'
	      , 'clk'
	      , 'reset_n')=\

\jsbegin
}
\jsend

\=u.dffre(       2
              , 'ordering'
	      , 'ordering_in'
	      , "2'b0"
	      , 'wtt_entry_write'
	      , 'clk'
	      , 'reset_n')=\

\=u.dffre(       3
              , 'prot'
	      , 'prot_in'
	      , '{'+3+'{1\'b0}}'
	      , 'wtt_entry_write'
	      , 'clk'
	      , 'reset_n')=\

\=u.dffre(       1
              , 'lock'
	      , 'lock_in'
	      , "1'b0"
	      , 'wtt_entry_write'
	      , 'clk'
	      , 'reset_n')=\

\js if (aruser_width > 0) {
\=u.dffre(       aruser_width
              , 'user'
	      , 'user_in'
	      , '{'+aruser_width+'{1\'b0}}'
	      , 'wtt_entry_write'
	      , 'clk'
	      , 'reset_n')=\
\js }

\=u.dffre(       1
              , 'narrow'
	      , 'narrow_in'
	      , "1'b0"
	      , 'wtt_entry_write'
	      , 'clk'
	      , 'reset_n')=\
	      
\=u.dffre(       1
              , 'st'
	      , 'st_in'
	      , "1'b0"
	      , 'wtt_entry_write'
	      , 'clk'
	      , 'reset_n')=\

\=u.dffre(       cmd_intfsize_width
              , 'intfsize'
	      , 'intfsize_in'
	      , '{'+cmd_intfsize_width+'{1\'b0}}'
	      , 'wtt_entry_write'
	      , 'clk'
	      , 'reset_n')=\

\js if (wPri != 0) {
\=u.dffre(       wPri
              , 'priority_out'
	      , 'priority_in'
	      , '{'+wPri+'{1\'b0}}'
	      , 'wtt_entry_write'
	      , 'clk'
	      , 'reset_n')=\

\=u.dffre(       wPri
              , 'dtw_priority'
	      , 'dtw_priority_in'
	      , '{'+wPri+'{1\'b0}}'
	      , 'data_rcvd'
	      , 'clk'
	      , 'reset_n')=\
\js }

\jsbegin
// No ql for this release
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
if (wQl != 0) {
\jsend
\=u.dffre(       wQl
              , 'ql'
	      , 'ql_in'
	      , '{'+wQl+'{1\'b0}}'
	      , 'wtt_entry_write'
	      , 'clk'
	      , 'reset_n')=\

\=u.dffre(       wQl
              , 'dtw_ql'
	      , 'dtw_ql_in'
	      , '{'+wQl+'{1\'b0}}'
	      , 'data_rcvd'
	      , 'clk'
	      , 'reset_n')=\
\js }

\=u.dffre(       cmd_mpf1_width
              , 'mpf1'
	      , 'mpf1_in'
	      , '{'+cmd_mpf1_width+'{1\'b0}}'
	      , 'wtt_entry_write'
	      , 'clk'
	      , 'reset_n')=\

\=u.dffre(       cmd_mpf2_width
              , 'mpf2'
	      , 'mpf2_in'
	      , '{'+cmd_mpf2_width+'{1\'b0}}'
	      , 'wtt_entry_write'
	      , 'clk'
	      , 'reset_n')=\

\=u.dffre(       1
              , 'ca'
	      , 'ca_in'
	      , "1'b0"
	      , 'wtt_entry_write'
	      , 'clk'
	      , 'reset_n')=\

\=u.dffre(       1
              , 'ac'
	      , 'ac_in'
	      , "1'b0"
	      , 'wtt_entry_write'
	      , 'clk'
	      , 'reset_n')=\

\=u.dffre(       1
              , 'vz'
	      , 'vz_in'
	      , "1'b0"
	      , 'wtt_entry_write'
	      , 'clk'
	      , 'reset_n')=\

\=u.dffre(       1
              , 'ch'
	      , 'ch_in'
	      , "1'b0"
	      , 'wtt_entry_write'
	      , 'clk'
	      , 'reset_n')=\

\=u.dffre(       1
              , 'tm'
	      , 'tm_in'
	      , "1'b0"
	      , 'wtt_entry_write'
	      , 'clk'
	      , 'reset_n')=\

\=u.dffre(       1
              , 'ex_pass'
	      , 'ex_pass_in'
	      , "1'b0"
	      , 'wtt_entry_write'
	      , 'clk'
	      , 'reset_n')=\
	      
assign ewa_sent_in    =   wtt_entry_write ? 1'b0 : 1'b1;
assign ewa_sent_en    =   wtt_entry_write | ewa_sent_set;

\=u.dffre(       1
              , 'ewa_sent'
	      , 'ewa_sent_in'
	      , "1'b0"
	      , 'ewa_sent_en'
	      , 'clk'
	      , 'reset_n')=\

\=u.dffre(       tid_width
              , 'tid'
	      , 'tid_in'
	      , '{'+tid_width+'{1\'b0}}'
	      , 'wtt_entry_write'
	      , 'clk'
	      , 'reset_n')=\

\=u.dffre(       wFUnitId
              , 'init_id'
	      , 'init_id_in'
	      , '{'+wFUnitId+'{1\'b0}}'
	      , 'wtt_entry_write'
	      , 'clk'
	      , 'reset_n')=\

\=u.dffre(       axi_id_width
              , 'axi_id'
	      , 'axi_id_in'
	      , '{'+axi_id_width+'{1\'b0}}'
	      , 'wtt_entry_write'
	      , 'clk'
	      , 'reset_n')=\

//RO dependency

assign ro_depnd_in[1] =  (ro_depnd_set & wtt_entry_write)  | ro_depnd[1] & ~ro_depnd_clear;

// Set this bit to 0 if collision with read, set to 1 if collision with write
assign ro_depnd_in[0] =  (wtt_ro_match_wr & ro_depnd_set & wtt_entry_write) | (ro_depnd[0] & ~ro_depnd_clear) ;
assign ro_depnd_en = wtt_entry_write | ro_depnd_clear;

\=u.dffre(       2
              , 'ro_depnd'
	      , 'ro_depnd_in'
	      , "2'b0"
	      , 'ro_depnd_en'
	      , 'clk'
	      , 'reset_n')=\

\=u.dffre(       tt_id_width
              , 'ro_depnd_id'
	      , 'ro_depnd_id_in'
	      , '{'+tt_id_width+'{1\'b0}}'
	      , 'wtt_entry_write'
	      , 'clk'
	      , 'reset_n')=\

//EO dependency

assign eo_depnd_in[1] =  (eo_depnd_set & wtt_entry_write)  | eo_depnd[1] & ~eo_depnd_clear;

// Set this bit to 0 if collision with read, set to 1 if collision with write
assign eo_depnd_in[0] =  (wtt_eo_match_wr & eo_depnd_set & wtt_entry_write) |  (eo_depnd[0] & ~eo_depnd_clear);

assign eo_depnd_en = wtt_entry_write | eo_depnd_clear;

\=u.dffre(       2
              , 'eo_depnd'
	      , 'eo_depnd_in'
	      , "2'b0"
	      , 'eo_depnd_en'
	      , 'clk'
	      , 'reset_n')=\

\=u.dffre(       tt_id_width
              , 'eo_depnd_id'
	      , 'eo_depnd_id_in'
	      , '{'+tt_id_width+'{1\'b0}}'
	      , 'wtt_entry_write'
	      , 'clk'
	      , 'reset_n')=\
	      
//WO dependency

assign wo_depnd_in =  (wo_depnd_set & wtt_entry_write)  | wo_depnd & ~wo_depnd_clear;
assign wo_depnd_en = wtt_entry_write | wo_depnd_clear;

\=u.dffre(       1
              , 'wo_depnd'
	      , 'wo_depnd_in'
	      , "1'b0"
	      , 'wo_depnd_en'
	      , 'clk'
	      , 'reset_n')=\

\=u.dffre(       tt_id_width
              , 'wo_depnd_id'
	      , 'wo_depnd_id_in'
	      , '{'+tt_id_width+'{1\'b0}}'
	      , 'wtt_entry_write'
	      , 'clk'
	      , 'reset_n')=\
	      
//AXI dependency
//
                   
assign axi_depnd_in =  (wtt_entry_write) ? axi_depnd_set : 1'b0;
assign axi_depnd_en = wtt_entry_write | axi_depnd_clear;

\=u.dffre(       1
              , 'axi_depnd'
	      , 'axi_depnd_in'
	      , "1'b0"
	      , 'axi_depnd_en'
	      , 'clk'
	      , 'reset_n')=\

\=u.dffre(       tt_id_width
              , 'axi_depnd_id'
	      , 'axi_depnd_id_in'
	      , '{'+tt_id_width+'{1\'b0}}'
	      , 'wtt_entry_write'
	      , 'clk'
	      , 'reset_n')=\
	      
//Oldest entry

assign oldest_entry_in = oldest_entry_set | (oldest & ~oldest_entry_clear);

\=u.dffre(       1
              , 'oldest'
	      , 'oldest_entry_in'
	      , "1'b0"
	      , "1'b1" 
	      , 'clk'
	      , 'reset_n')=\
	      
//Youngest AXI entry
assign youngest_axi_entry_set =  // New Entry is allocated. Only set youngest for passed transaction. Failed TXNs wont see a response to update the AXI chain.  
                              (wtt_allocate_new_entry & wr_enable) & ex_pass_in;

assign youngest_axi_entry_clear =  // New Entry is allocated and is dependent on this AXI ID. Do not change youngest bit for failed txn as response wont come back to update chain.
                              ((wtt_allocate_new_entry & ~wr_enable) & ex_pass_in  & (axi_id_in == axi_id) | valid_clear);

assign youngest_axi_in = youngest_axi_entry_set | (youngest_axi & ~youngest_axi_entry_clear);

\=u.dffre(       1
              , 'youngest_axi'
	      , 'youngest_axi_in'
	      , "1'b0"
	      , "1'b1" 
	      , 'clk'
	      , 'reset_n')=\
	      
//Youngest RO entry
assign youngest_ro_entry_set =  // New Entry is allocated  
                                 (wtt_allocate_new_entry & wr_enable);

assign youngest_ro_entry_clear =  // New Entry is allocated and is dependent on this read. Dont release if its the 0 ordering chain
                              ( ((wtt_allocate_new_entry & ~wr_enable & ~(ordering == 1 && ordering_in != 1)) | (rtt_allocate_new_entry & (ordering != 1))) & new_wtt_ro_depnd | valid_clear);

assign youngest_ro_in = youngest_ro_entry_set | (youngest_ro & ~youngest_ro_entry_clear);

\=u.dffre(       1
              , 'youngest_ro'
	      , 'youngest_ro_in'
	      , "1'b0"
	      , "1'b1" 
	      , 'clk'
	      , 'reset_n')=\
	      
//Youngest EO entry

assign youngest_eo_entry_set =  // Entry is allocated
                              (wtt_allocate_new_entry & wr_enable);

assign youngest_eo_entry_clear =  // Entry is allocated and is dependent on earlier read
                              ( ((wtt_allocate_new_entry & ~wr_enable) | rtt_allocate_new_entry) & new_wtt_eo_depnd | valid_clear);

assign youngest_eo_in = youngest_eo_entry_set | (youngest_eo & ~youngest_eo_entry_clear);

\=u.dffre(       1
              , 'youngest_eo'
	      , 'youngest_eo_in'
	      , "1'b0"
	      , "1'b1" 
	      , 'clk'
	      , 'reset_n')=\
	      
//Youngest WO entry

assign youngest_wo_entry_set =  // Entry is allocated
                              (wtt_allocate_new_entry & wr_enable );

assign youngest_wo_entry_clear =  // Entry is allocated and is dependent on earlier read
                              (wtt_allocate_new_entry &  ~wr_enable & new_wtt_wo_depnd | valid_clear);

assign youngest_wo_in = youngest_wo_entry_set | (youngest_wo & ~youngest_wo_entry_clear);

\=u.dffre(       1
              , 'youngest_wo'
	      , 'youngest_wo_in'
	      , "1'b0"
	      , "1'b1" 
	      , 'clk'
	      , 'reset_n')=\
	      
//Response pending
assign response_pending_set = valid & wtt_grant ;
assign response_pending_clear = valid_clear;

assign response_pending_in = response_pending_set | (response_pending & ~response_pending_clear);

\=u.dffre(       1
              , 'response_pending'
	      , 'response_pending_in'
	      , "1'b0"
	      , "1'b1" 
	      , 'clk'
	      , 'reset_n')=\
	      
//Sleep

assign sleep_in = (sleep_set & wtt_entry_write) | (sleep & ~sleep_clear);

\=u.dffre(       1
              , 'sleep'
	      , 'sleep_in'
	      , "1'b0"
	      , "1'b1" 
	      , 'clk'
	      , 'reset_n')=\
	      
//Data pending 
assign data_pending_set = wtt_entry_write;  
assign data_pending_clear = valid & data_rcvd;
 
assign data_pending_in = data_pending_set | (data_pending_out & ~data_pending_clear);

\=u.dffre(       1
              , 'data_pending_out'
	      , 'data_pending_in'
	      , "1'b0"
	      , "1'b1" 
	      , 'clk'
	      , 'reset_n')=\

//DBAD 
wire dbad_set   = wtt_dbad_in;
wire dbad_clear = wtt_entry_write;

wire dbad_in = dbad_set | (dbad  & ~dbad_clear);

\=u.dffre(       1
              , 'dbad'
	      , 'dbad_in'
	      , "1'b0"
	      , "1'b1" 
	      , 'clk'
	      , 'reset_n')=\
	      
//STR sent
assign str_sent_set =  wtt_str_grant;
assign str_sent_clear = wtt_entry_write;

assign str_sent_in = str_sent_set | (str_sent_out  & ~str_sent_clear);

\=u.dffre(       1
              , 'str_sent_out'
	      , 'str_sent_in'
	      , "1'b0"
	      , "1'b1" 
	      , 'clk'
	      , 'reset_n')=\
//CMO Halt 
assign cmo_halt_clear = valid_clear;

assign cmo_halt_in    = (valid & cmo_halt_set & rtt_allocate_new_entry & cmo_in & ~cmo_halt_clear) | (cmo_halt & ~cmo_halt_clear);

\=u.dffre(       1
              , 'cmo_halt'
	      , 'cmo_halt_in'
	      , "1'b0"
	      , "1'b1" 
	      , 'clk'
	      , 'reset_n')=\
	      
// Only set the ID on the first hit it sees out of the CMDReq FIFO. Ignore subsequent hits. 
wire cmo_halt_id_set = cmo_halt_set & ~cmo_halt;

\=u.dffre(       tt_id_width
              , 'cmo_halt_id'
	      , 'cmo_halt_id_in'
	      , '{'+tt_id_width+'{1\'b0}}'
	      , 'cmo_halt_id_set'
	      , 'clk'
	      , 'reset_n')=\
	      
//DTW TID

\=u.dffre(       tid_width
              , 'dtw_tid'
	      , 'dtw_tid_in'
	      , '{'+tid_width+'{1\'b0}}'
	      , 'data_rcvd'
	      , 'clk'
	      , 'reset_n')=\
	      
endmodule
 
