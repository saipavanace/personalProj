\jsbegin
//=============================================================================
// Copyright(C) 2025 Arteris, Inc.
// All rights reserved
//=============================================================================
//GIU Unit
// Author: Benjamin Madon
//=============================================================================



var m = obj.userLib;
var u=obj.lib;
var utilFunctions = m.lib_utils;

var p =u.getParam();

u.nInterfaces(p.interfaces);
\jsend

module \=u.getModuleName()=\ (\=u.getPorts('\n')=\);



wire [511:0] data_match;
wire GIULCSTR_MatchStatus;
wire GIULCSTR_MatchStatus_en;

wire [3:0] GIULCSTR_MismatchPosition;
wire GIULCSTR_MismatchPosition_en ;

wire [16:0] GIULCSTR_LoopCycleCounter;
wire GIULCSTR_LoopCycleCounter_en;
wire GIULCSTR_LoopCycleCounter_carry;


reg loop_out_cxs_in_int_valid;
reg [1:0] next_state;
wire [1:0] current_state;

wire next_packet_number_carry;
wire [3:0] next_packet_num,current_packet_num;
wire packet_num_en;

wire next_flit_num_received_carry;
wire [1:0] next_flit_num_received,current_flit_num_received;
wire flit_num_received_en;

wire packet_received;
wire packet_sent;

wire [3:0] current_receive_packet_num,next_receive_packet_num;
wire next_receive_packet_number_carry;
wire receive_packet_num_en;

wire next_flit_number_carry;
wire [1:0] next_flit_num,current_flit_num;
wire flit_num_en;

wire GIULDSR_LoopStartDataValue_out_plus_one_carry;
wire [31:0] current_data_send, next_data_send;
wire [31:0] GIULDSR_LoopStartDataValue_out_plus_one_out,GIULDSR_LoopStartDataValue_out_plus_one;
wire data_send_en;
wire plus_one_en;

wire next_data_receive_StartDataValue_out_plus_one_carry;
wire [31:0] current_data_receive, next_data_receive;
wire [31:0] next_data_receive_StartDataValue_out_plus_one,current_data_receive_StartDataValue_out_plus_one;
wire data_receive_en;
wire data_receive_plus_one_en;


wire [7:0] delay_counter,next_delay_counter;
wire next_delay_counter_carry;
wire delay_counter_en;


wire packet_pending_set,packet_pending_reset;
wire packet_pending_en;
wire packet_pending_in, packet_pending;

assign cxs_out_loop_in_ready = 1'b1;

assign data_match = (cxs_out_loop_in_data ^ {16{current_data_receive}});

assign GIULCSTR_MatchStatus = ~|data_match;
assign GIULCSTR_MatchStatus_en = cxs_out_loop_in_valid & loop_out_cxs_in_ready; 

\=u.dffre(1,"GIULCSTR_MatchStatus_in","GIULCSTR_MatchStatus","1'b1","GIULCSTR_MatchStatus_en", p.interfaces["clkInt"].name+"clk",p.interfaces["clkInt"].name+"reset_n")=\
\=u.dffre(1,"GIULCSTR_MatchStatus_wr","~GIULCSTR_MatchStatus","1'b0","GIULCSTR_MatchStatus_en", p.interfaces["clkInt"].name+"clk",p.interfaces["clkInt"].name+"reset_n")=\

assign GIULCSTR_MismatchPosition = packet_received ? 4'd0 : (4'd1 << current_flit_num) | GIULCSTR_MismatchPosition_in;
assign GIULCSTR_MismatchPosition_en = cxs_out_loop_in_valid & loop_out_cxs_in_ready & (|data_match);

\=u.dffre(4,"GIULCSTR_MismatchPosition_in","GIULCSTR_MismatchPosition","4'd0","GIULCSTR_MismatchPosition_en", p.interfaces["clkInt"].name+"clk",p.interfaces["clkInt"].name+"reset_n")=\
\=u.dffre(1,"GIULCSTR_MismatchPosition_wr","GIULCSTR_MismatchPosition_en","1'b0","GIULCSTR_MismatchPosition_en", p.interfaces["clkInt"].name+"clk",p.interfaces["clkInt"].name+"reset_n")=\



//packet pending logic

\=u.dffre(1,"packet_pending","packet_pending_in","1'b0","packet_pending_en", p.interfaces["clkInt"].name+"clk",p.interfaces["clkInt"].name+"reset_n")=\


assign packet_pending_set = packet_sent;  
assign packet_pending_reset = packet_received;
assign packet_pending_en = packet_pending_set | packet_pending_reset;

assign packet_pending_in = packet_pending_set | (packet_pending & ~packet_pending_reset);


assign GIULCSTR_LoopCycleCounter_en = packet_pending | (packet_pending_set & ~packet_pending);
assign {GIULCSTR_LoopCycleCounter_carry,GIULCSTR_LoopCycleCounter} = (packet_pending_set & ~packet_pending) ?  19'd1 : 
                                                                                                            ((packet_pending& ~packet_pending_reset) ? GIULCSTR_LoopCycleCounter_in + 1'b1 : 
                                                                                                                              19'd1 );

\=u.dffre(17,"GIULCSTR_LoopCycleCounter_in","GIULCSTR_LoopCycleCounter","17'd1","GIULCSTR_LoopCycleCounter_en", p.interfaces["clkInt"].name+"clk",p.interfaces["clkInt"].name+"reset_n")=\

assign GIULCSTR_LoopCycleCounter_wr = packet_pending & packet_pending_reset;




\jsbegin 
for (var i=0;i<16;i++){
\jsend
    assign GIULDMSR\=i=\_FirstMismatchValue_in = cxs_out_loop_in_data[\=i+1=\*32-1:\=i=\*32];
    assign GIULDMSR\=i=\_FirstMismatchValue_wr = cxs_out_loop_in_valid & loop_out_cxs_in_ready & (|data_match);
\jsbegin
}
\jsend
// State machine
//00 : idle, wait before two packets.
//01 : send and receive : in this mode new packet are generated while older one may be received
//10 : receive only : All teh packet have been sent and it is pending receiving the last packet
//11 : finished. waits for LoopBackEn to deassert to go to teh idle mode.

\=u.dffre(2,"current_state","next_state","2'b11","state_en", p.interfaces["clkInt"].name+"clk",p.interfaces["clkInt"].name+"reset_n")=\

assign state_en = 1'b1;

always@(*) begin
    case (current_state)
        2'b00 : begin loop_out_cxs_in_int_valid = 1'b0; next_state =(GIULCSTR_LoopBackEn_out & (((delay_counter == 8'd16 )  & (GIULCSTR_DelayCounter_out == 2'b00)) |
                                                                                                ((delay_counter == 8'd32)   & (GIULCSTR_DelayCounter_out == 2'b01)) |
                                                                                                ((delay_counter == 8'd64)   & (GIULCSTR_DelayCounter_out == 2'b10)) |   
                                                                                                ((delay_counter == 8'd128)  & (GIULCSTR_DelayCounter_out == 2'b11))                                                           
                                                                                                                        )) ? 2'b01 : 2'b00; end
        2'b01 : begin 
                        loop_out_cxs_in_int_valid =  1'b1; 
                        next_state = packet_num_en ?  ({2{GIULCSTR_RepeatMode_out & packet_received  & ~GIULCSTR_LoopBackEn_out & (GIULCSTR_NumberOfTest_out == 2'b00) }} & 2'b11   |
                                                       {2{GIULCSTR_RepeatMode_out & ~packet_received & ~GIULCSTR_LoopBackEn_out & (GIULCSTR_NumberOfTest_out == 2'b00) }} & 2'b10   |
                                                       {2{(~GIULCSTR_RepeatMode_out & packet_received)                    }} & 2'b11   |
                                                       {2{(~GIULCSTR_RepeatMode_out & ~packet_received)                    }} & 2'b10   |
                                                       {2{GIULCSTR_RepeatMode_out & (GIULCSTR_NumberOfTest_out == 2'b00)                            }} & 2'b00   |
                                                       {2{GIULCSTR_RepeatMode_out & (GIULCSTR_NumberOfTest_out == 2'b01) & (current_packet_num == 4'd3)}} & 2'b10   |
                                                       {2{GIULCSTR_RepeatMode_out & (GIULCSTR_NumberOfTest_out == 2'b10) & (current_packet_num == 4'd7)}} & 2'b10   |
                                                       {2{GIULCSTR_RepeatMode_out & (GIULCSTR_NumberOfTest_out == 2'b11) & (current_packet_num == 4'd15)}}  & 2'b10   |
                                                       {2{~(
                                                            (GIULCSTR_RepeatMode_out &  GIULCSTR_NumberOfTest_out == 2'b00)                           |
                                                            (GIULCSTR_RepeatMode_out & (GIULCSTR_NumberOfTest_out == 2'b01) & (next_packet_num == 4'd4 )) |
                                                            (GIULCSTR_RepeatMode_out & (GIULCSTR_NumberOfTest_out == 2'b10) & (next_packet_num == 4'd8 )) |
                                                            (GIULCSTR_RepeatMode_out & (GIULCSTR_NumberOfTest_out == 2'b11) & next_packet_number_carry)
                                                                                                                            )}} & 2'b00) :
                                                                                                         2'b01;    

                    end
        2'b10 : begin loop_out_cxs_in_int_valid = 1'b0; next_state = (packet_received)  ? 2'b11 : 2'b10; end
        2'b11 : begin loop_out_cxs_in_int_valid = 1'b0; next_state = ~GIULCSTR_LoopBackEn_out ? 2'b00 : 2'b11; end
        default : begin loop_out_cxs_in_int_valid = 1'b0; next_state = 2'b00; end
    endcase
end
assign loop_out_cxs_in_valid = loop_out_cxs_in_int_valid;



//delay_counter
\=u.dffre(8,"delay_counter","next_delay_counter","2'd0","delay_counter_en", p.interfaces["clkInt"].name+"clk",p.interfaces["clkInt"].name+"reset_n")=\

assign {next_delay_counter_carry,next_delay_counter} = next_state == 2'b01 ? 7'd0 : (delay_counter+1'b1) ;
assign delay_counter_en = current_state == 2'b00;





//Flit number counter

\=u.dffre(2,"current_flit_num","next_flit_num","2'd0","flit_num_en", p.interfaces["clkInt"].name+"clk",p.interfaces["clkInt"].name+"reset_n")=\

assign {next_flit_number_carry,next_flit_num} = (current_state == 2'b11 & ~GIULCSTR_LoopBackEn_out) ? 3'd0 :
                                                                                                    current_flit_num + 1'b1;
assign flit_num_en = (current_state == 2'b11 & ~GIULCSTR_LoopBackEn_out) | ( loop_out_cxs_in_valid & loop_out_cxs_in_ready & (current_state == 2'b01));


//Flit receive number counter

\=u.dffre(2,"current_flit_num_received","next_flit_num_received","2'd0","flit_num_received_en", p.interfaces["clkInt"].name+"clk",p.interfaces["clkInt"].name+"reset_n")=\

assign {next_flit_num_received_carry,next_flit_num_received} = (current_state == 2'b11 & ~GIULCSTR_LoopBackEn_out)? 3'd0 : 
                                                                                                                current_flit_num_received + 1'b1;
assign flit_num_received_en = (current_state == 2'b11 & ~GIULCSTR_LoopBackEn_out) | (cxs_out_loop_in_ready & cxs_out_loop_in_valid);


assign packet_received = next_flit_num_received_carry;

//packet number 

\=u.dffre(4,"current_packet_num","next_packet_num","4'd0","packet_num_en", p.interfaces["clkInt"].name+"clk",p.interfaces["clkInt"].name+"reset_n")=\

assign {next_packet_number_carry,next_packet_num} = (current_state == 2'b11 & ~GIULCSTR_LoopBackEn_out) ? 5'd0 :
                                                                                                        current_packet_num + 1'b1;
assign packet_num_en = (current_state == 2'b11 & ~GIULCSTR_LoopBackEn_out) | (next_flit_number_carry & (current_state == 2'b01));

assign packet_sent = next_flit_number_carry & (current_state == 2'b01);
//packet receive number 

\=u.dffre(4,"current_receive_packet_num","next_receive_packet_num","4'd0","receive_packet_num_en", p.interfaces["clkInt"].name+"clk",p.interfaces["clkInt"].name+"reset_n")=\

assign {next_receive_packet_number_carry,next_receive_packet_num} = (current_state == 2'b11 & ~GIULCSTR_LoopBackEn_out) ? 5'd0:
                                                                                                                        current_receive_packet_num + 1'b1;
assign receive_packet_num_en = (current_state == 2'b11 & ~GIULCSTR_LoopBackEn_out) | (next_flit_num_received_carry & flit_num_received_en);



//data to send logic

\=u.dffre(32,"current_data_send","next_data_send","32'd0","data_send_en", p.interfaces["clkInt"].name+"clk",p.interfaces["clkInt"].name+"reset_n")=\

\=u.dffre(32,"GIULDSR_LoopStartDataValue_out_plus_one_out","GIULDSR_LoopStartDataValue_out_plus_one","32'd0","plus_one_en", p.interfaces["clkInt"].name+"clk",p.interfaces["clkInt"].name+"reset_n")=\

assign plus_one_en = ((current_state == 2'b01 ) & packet_num_en) | ((current_state == 2'b11) & (next_state == 2'b00)) ;

assign {GIULDSR_LoopStartDataValue_out_plus_one_carry,GIULDSR_LoopStartDataValue_out_plus_one} = ((current_state == 2'b11) & (next_state == 2'b00))? GIULDSR_LoopStartDataValue_out : GIULDSR_LoopStartDataValue_out_plus_one_out+1'b1 ;

assign next_data_send =     ({32{(current_state == 2'b11) & (next_state == 2'b00)                                }}  & GIULDSR_LoopStartDataValue_out                      )| 
                            ({32{(current_state == 2'b01 ) & packet_num_en                                       }}  & GIULDSR_LoopStartDataValue_out_plus_one             )| 
                            ({32{(current_state == 2'b01 ) & (GIULCSTR_ShiftStart_out == 2'b00) & ~packet_num_en}}  & current_data_send                                   )|
                            ({32{(current_state == 2'b01 ) & (GIULCSTR_ShiftStart_out == 2'b01) & ~packet_num_en}}  & {current_data_send[27:0],current_data_send[31:28]}  )|
                            ({32{(current_state == 2'b01 ) & (GIULCSTR_ShiftStart_out == 2'b10) & ~packet_num_en}}  & {current_data_send[23:0],current_data_send[31:24]}  )|
                            ({32{(current_state == 2'b01 ) & (GIULCSTR_ShiftStart_out == 2'b11) & ~packet_num_en}}  & {current_data_send[15:0],current_data_send[31:15]}  ) ;


assign data_send_en = ( (current_state == 2'b11) & (next_state == 2'b00) ) | flit_num_en;
assign loop_out_cxs_in_data = {16{current_data_send}};




//data receive logic

\=u.dffre(32,"current_data_receive","next_data_receive","32'd0","data_receive_en", p.interfaces["clkInt"].name+"clk",p.interfaces["clkInt"].name+"reset_n")=\

\=u.dffre(32,"current_data_receive_StartDataValue_out_plus_one","next_data_receive_StartDataValue_out_plus_one","32'd0","data_receive_plus_one_en", p.interfaces["clkInt"].name+"clk",p.interfaces["clkInt"].name+"reset_n")=\

assign data_receive_plus_one_en = (receive_packet_num_en) | ((current_state == 2'b11) & (next_state == 2'b00)) ;

assign {next_data_receive_StartDataValue_out_plus_one_carry,next_data_receive_StartDataValue_out_plus_one} = ( (current_state == 2'b11) & (next_state == 2'b00) )? GIULDSR_LoopStartDataValue_out + 1'b1 : current_data_receive_StartDataValue_out_plus_one+1'b1 ;

assign next_data_receive =  ({32{(current_state == 2'b11) & (next_state == 2'b00)                                                  }}  & GIULDSR_LoopStartDataValue_out                               )| 
                            ({32{ receive_packet_num_en   & ~((current_state == 2'b11) & (next_state == 2'b00)) }}  & current_data_receive_StartDataValue_out_plus_one                                )| 
                            ({32{ (GIULCSTR_ShiftStart_out == 2'b00) & ~receive_packet_num_en}}  & current_data_receive                                                                               )|
                            ({32{ (GIULCSTR_ShiftStart_out == 2'b01) & ~receive_packet_num_en}}  & {current_data_receive[27:0],current_data_receive[31:28]}                                           )|
                            ({32{ (GIULCSTR_ShiftStart_out == 2'b10) & ~receive_packet_num_en}}  & {current_data_receive[23:0],current_data_receive[31:24]}                                           )|
                            ({32{ (GIULCSTR_ShiftStart_out == 2'b11) & ~receive_packet_num_en}}  & {current_data_receive[15:0],current_data_receive[31:15]}) ;

assign data_receive_en =( (current_state == 2'b11) & (next_state == 2'b00) ) | (cxs_out_loop_in_ready & cxs_out_loop_in_valid);



\js if ( p.assertOn ) {

    `ifdef OVL_ASSERT_ON
    // synthesis_off
    // pragma synthesis_off
    // coverage off
    wire [2:0] data_match_assert_fire;
     ovl_never #(.msg("no error was inserted but the data did not match")) data_match_assert ( .clock(\=p.interfaces.clkInt.name=\clk),
                                                                                         .reset(\=p.interfaces.clkInt.name=\reset_n),
                                                                                         .enable(1'b1), 
                                                                                         .test_expr((cxs_out_loop_in_ready & cxs_out_loop_in_valid & (current_data_receive != cxs_out_loop_in_data[15:0]))), 
                                                                                         .fire(data_match_assert_fire)
                                                                                        );

    // coverage on
    // pragma synthesis_on
    // synthesis_on
    `endif
\js }

endmodule