\jsbegin
//=============================================================================
// Copyright(C) 2024 Arteris, Inc.
// All rights reserved
//=============================================================================
//GIU Unit
// Author: Benjamin Madon
//=============================================================================



var m = obj.userLib;
var u=obj.lib;
var newToOldStyleInterface	= m.newToOldStyleInterface.bind( null, m );
var utilFunctions   = m.lib_utils;

var p =u.getParam();

var Generic_rdy_valid ={ "params": {},
                                  "_SKIP_": false,
                                  "interface": "InterfaceGenRdyVld",
                                  "blkClkGateOn": true
                                  };

var InterfaceGenVld = { "params" : {},
                                  "_SKIP_": false,
                                  "interface": "InterfaceGenVld",
                                  "blkClkGateOn": true}

var InterfaceGenData = { "params" : {},
                                  "_SKIP_": false,
                                  "interface": "InterfaceGenData",
                                  "blkClkGateOn": true};

                                  
var Active = {   params :  {wIn :1, wOut:0},
                synonyms: { in: [ {name : "active", width : 1} ], out: [] },
                 name: '',
                 _SKIP_: false,
                 interface: 'InterfaceGeneric',
                 direction: undefined,
                 synonymsOn: true,
                 synonymsExpand: true};

var Active_array=[];


function wire(prefix,NewInterface,exclude){
  return m.bundleFunctions.wiresFromInterface(prefix+NewInterface.name,        newToOldStyleInterface(NewInterface).signals,       exclude,  u.bundle)
}

u.nInterfaces(p.interfaces);

var cxs_rx_func_int_ = m.deepCopy(p.interfaces["cxsRxInt"]);
cxs_rx_func_int_.name="cxs_rx_func_int_"

var cxs_tx_func_int_ = m.deepCopy(p.interfaces["cxsTxInt"]);
cxs_tx_func_int_.name="cxs_tx_func_int_"
\jsend


module \=u.getModuleName()=\ (\=u.getPorts('\n')=\);

\=wire("",cxs_rx_func_int_,[])=\
\=wire("",cxs_tx_func_int_,[])=\
wire giu_active;
\jsbegin


///////////////////////////////////////////////////////////////////////////
//
//GIU_VC_credit_control instanciation.
//Takes a credit return interface /VC  to restore a credit. 
//Takes a credit use interface /VC which allows to consume up to 4 credits in one cycle
//Takes a Credit status interface /VC to report how many credits are available.
///////////////////////////////////////////////////////////////////////////


var GIU_VC_credit_control_interfaces = {};

for (var vc=0;vc<p.vc_descriptor["nVC"];vc++){

var message_credit_return_ = m.deepCopy(p.Generic_interfaces["InterfaceGenVld"]);
message_credit_return_["params"]["wData"] = p.packet_descriptor.CreditReturnBits[vc]["values"][2];
message_credit_return_["name"] = "message_credit_return_VC_"+vc+"_";
message_credit_return_["direction"] = "slave";

GIU_VC_credit_control_interfaces["message_credit_return_VC_"+vc] =message_credit_return_;


var message_credit_use_ = m.deepCopy(p.Generic_interfaces["InterfaceGenVld"]);
message_credit_use_["params"]["wData"] = p.packet_descriptor.CreditReturnBits[vc]["values"][2];
message_credit_use_["name"] = "message_credit_use_VC_"+vc+"_";
message_credit_use_["direction"] = "slave";
GIU_VC_credit_control_interfaces["message_credit_use_VC_"+vc] =message_credit_use_;

var message_credit_status_ = m.deepCopy(p.Generic_interfaces["InterfaceGenData"]);
message_credit_status_["params"]["wData"] = p.vc_descriptor["wCredit"];
message_credit_status_["name"] = "message_credit_status_VC_"+vc+"_";
message_credit_status_["direction"] = "master";
GIU_VC_credit_control_interfaces["message_credit_status_VC_"+vc] = message_credit_status_;


var credit_return_ = m.deepCopy(p.Generic_interfaces["InterfaceGenVld"]);
credit_return_["params"]["wData"] = p.packet_descriptor.CreditReturnBits[vc]["values"][2];
credit_return_["name"] = "credit_return_VC_"+vc+"_";
credit_return_["direction"] = "slave";

GIU_VC_credit_control_interfaces["credit_return_VC_"+vc] =credit_return_;

var credit_use_ = m.deepCopy(p.Generic_interfaces["InterfaceGenVld"]);
credit_use_["params"]["wData"] = p.packet_descriptor.CreditReturnBits[vc]["values"][2];
credit_use_["name"] = "credit_use_VC_"+vc+"_";
credit_use_["direction"] = "slave";
GIU_VC_credit_control_interfaces["credit_use_VC_"+vc] =credit_use_;

var credit_status_ = m.deepCopy(p.Generic_interfaces["InterfaceGenData"]);
credit_status_["params"]["wData"] = p.vc_descriptor["wCredit"];
credit_status_["name"] = "credit_status_VC_"+vc+"_";
credit_status_["direction"] = "master";
GIU_VC_credit_control_interfaces["credit_status_VC_"+vc] = credit_status_;

}
GIU_VC_credit_control_interfaces["clkInt"] = m.deepCopy(p.interfaces ["clkInt"]);
GIU_VC_credit_control_interfaces["clkInt"].params["wTestEn"] =0;

GIU_VC_credit_control_interfaces["clkInt"].name ="GIU_VC_Credit_control_cg_";

GIU_VC_credit_control_interfaces["active"] = m.deepCopy(Active);
GIU_VC_credit_control_interfaces["active"].name = "GIU_VC_Credit_control_";
GIU_VC_credit_control_interfaces["active"].direction = "slave";

Active_array.push(GIU_VC_credit_control_interfaces["active"].name+'active');

var GIU_VC_credit_control_parameters = {};
GIU_VC_credit_control_parameters["interfaces"] = GIU_VC_credit_control_interfaces;
GIU_VC_credit_control_parameters["vc_descriptor"] = p["vc_descriptor"];
GIU_VC_credit_control_parameters["assertOn"] = p.system["AssertionEnable"];
\jsend

\jsbegin
for(var vc = 0 ; vc<p.vc_descriptor["nVC"] ; vc++){
\jsend
\= wire("",GIU_VC_credit_control_interfaces["credit_return_VC_"+vc],[]) =\
\= wire("",GIU_VC_credit_control_interfaces["credit_use_VC_"+vc],[]) =\
\= wire("",GIU_VC_credit_control_interfaces["credit_status_VC_"+vc],[]) =\
\= wire("",GIU_VC_credit_control_interfaces["message_credit_return_VC_"+vc],[]) =\
\= wire("",GIU_VC_credit_control_interfaces["message_credit_use_VC_"+vc],[]) =\
\= wire("",GIU_VC_credit_control_interfaces["message_credit_status_VC_"+vc],[]) =\
\jsbegin
}
\jsend

\= wire("",GIU_VC_credit_control_interfaces["clkInt"],[]) =\
\= wire("",GIU_VC_credit_control_interfaces["active"],[]) =\

  \=u.nInstance({
      instanceName: 'GIU_VC_Credit_control',
      moduleName: 'GIU_VC_Credit_control',
      params: GIU_VC_credit_control_parameters, 
      interfaceObj: {
      interfaces: GIU_VC_credit_control_interfaces,
      prefixes: GIU_VC_credit_control_interfaces
    }
  })=\


  \=u.instance ({
               instanceName : 'GIU_VC_Credit_control_cg',
               moduleName : 'cg',
               params : {
                           width : 1
                         },
               ports : {
                        clk_in : p.interfaces["clkInt"].name+'clk',
                        clk_out : GIU_VC_credit_control_interfaces["clkInt"].name+'clk',
                        test_en :  p.interfaces["clkInt"].name+'test_en',
                        en : "giu_active"
                        }               
               })=\

assign \=GIU_VC_credit_control_interfaces["clkInt"].name=\reset_n = \=p.interfaces["clkInt"].name=\reset_n;

\jsbegin

///////////////////////////////////////////////////////////////////////////
//
//Deframer Instanciation
//It takes an Internal 64B ready valid interface and provide SMI messages
///////////////////////////////////////////////////////////////////////////
var GIU_Deframer_interface ={};

for(var vc = 0 ; vc<p.vc_descriptor["nVC"] ; vc++){
  var VC = m.deepCopy(p.Generic_interfaces["InterfaceGenRdyVld"]);
  VC["params"]["wData"]= p.vc_descriptor["MessageSizeInGranule"][vc] * p.packet_descriptor["GranuleSizeInBytes"] * 8;
  VC["name"]= "VC_"+vc+"_from_deframer_";
  VC["direction"]= "master";
  GIU_Deframer_interface["VC_"+vc] = VC;

  var credit_return_ = m.deepCopy(InterfaceGenVld);
  credit_return_["params"]["wData"] = p.packet_descriptor.CreditReturnBits[vc]["values"][2];
  credit_return_["name"] = "credit_return_VC_"+vc+"_";
  credit_return_["direction"] = "master";
  
  GIU_Deframer_interface["credit_return_VC_"+vc] =credit_return_;


  var message_credit_return_ = m.deepCopy(p.Generic_interfaces["InterfaceGenVld"]);
  message_credit_return_["params"]["wData"] =  p.packet_descriptor.CreditReturnBits[vc]["values"][2];
  message_credit_return_["name"] = "message_credit_return_VC_"+vc+"_";
  message_credit_return_["direction"] = "master";
  GIU_Deframer_interface["message_credit_return_VC_"+vc] = message_credit_return_;
}

GIU_Deframer_interface["clkInt"] = p.interfaces ["clkInt"];
GIU_Deframer_interface["clkInt"] = m.deepCopy(p.interfaces ["clkInt"]);
GIU_Deframer_interface["clkInt"].params["wTestEn"] =0;
GIU_Deframer_interface["clkInt"].name ="giu_deframer_cg_";

GIU_Deframer_interface["active"] = m.deepCopy(Active);
GIU_Deframer_interface["active"].name = "giu_deframer_";
GIU_Deframer_interface["active"].direction = "slave";

Active_array.push(GIU_Deframer_interface["active"].name+'active');

var cxs_out_deframer_in_ = m.deepCopy(p.Generic_interfaces["InterfaceGenRdyVld"]);
cxs_out_deframer_in_["params"]["wData"] = 512;
cxs_out_deframer_in_["name"] = "cxs_out_deframer_in_";
cxs_out_deframer_in_["direction"] = "slave";

GIU_Deframer_interface["cxs_out_deframer_in_"] = cxs_out_deframer_in_;


var GIU_Deframer_parameters ={}
GIU_Deframer_parameters["interfaces"] = GIU_Deframer_interface;
GIU_Deframer_parameters["packet_descriptor"] = p.packet_descriptor;
GIU_Deframer_parameters["vc_descriptor"] = p.vc_descriptor;
GIU_Deframer_parameters["assertOn"] = p.system.AssertionEnable;
\jsend

\= wire("",cxs_out_deframer_in_,[])=\
\jsbegin
for(var vc = 0 ; vc<p.vc_descriptor["nVC"] ; vc++){
\jsend
\= wire("",GIU_Deframer_interface["VC_"+vc],[]) =\
\jsbegin
}
\jsend

\= wire("",GIU_Deframer_interface["clkInt"],[]) =\
\= wire("",GIU_Deframer_interface["active"],[]) =\

\=u.nInstance({
      instanceName: 'giu_deframer',
      moduleName: 'giu_deframer',
      params: GIU_Deframer_parameters, 
      interfaceObj: {
      interfaces: GIU_Deframer_interface,
      prefixes: GIU_Deframer_interface
    }
  })=\



\=u.instance ({
               instanceName : 'giu_deframer_cg',
               moduleName : 'cg',
               params : {
                           width : 1
                         },
               ports : {
                        clk_in : p.interfaces["clkInt"].name+'clk',
                        clk_out : GIU_Deframer_interface["clkInt"].name+'clk',
                        test_en :  p.interfaces["clkInt"].name+'test_en',
                        en : 'giu_active'
                        }               
               })=\
assign \=GIU_Deframer_interface["clkInt"].name=\reset_n = \=p.interfaces["clkInt"].name=\reset_n;

\jsbegin
///////////////////////////////////////////////////////////////////////////
//
//GIU_VC_to_Smi Instanciation
//It converts the SMI message into ready valid with padding to fit the number of granule 
//inside MessageSizeInGranule.
// The order for teh packing is provided by SMI_ndp_packing_order and SMI_dp_packing_order
// It always pack ndp before dp
//It always assume 1 beat dp.
///////////////////////////////////////////////////////////////////////////
  var GIU_VC_to_Smi_interfaces ={};
  var smitx = m.deepCopy(p.interfaces["smiTxInt"]);

  for (var smi in smitx){
    smitx[smi].name = p.interfaces["smiTxInt"][smi].name +"to_smi_processor_";
    GIU_VC_to_Smi_interfaces["smiTxInt"] = smitx;

  }

  for(var vc = 0 ; vc<p.vc_descriptor["nVC"] ; vc++){
    var VC = m.deepCopy(p.Generic_interfaces["InterfaceGenRdyVld"]);
    VC["params"]["wData"]= p.vc_descriptor["MessageSizeInGranule"][vc] * p.packet_descriptor["GranuleSizeInBytes"] * 8;
    VC["name"]= "VC_"+vc+"_from_deframer_";
    VC["direction"]= "slave";
    GIU_VC_to_Smi_interfaces["VC_"+vc] = VC;
  }
  
  GIU_VC_to_Smi_interfaces["active"] = m.deepCopy(Active);
  GIU_VC_to_Smi_interfaces["active"].name = "GIU_VC_to_Smi_";
  GIU_VC_to_Smi_interfaces["active"].direction = "slave";

  Active_array.push(GIU_VC_to_Smi_interfaces["active"].name+'active');

  var GIU_VC_to_Smi_parameters = {}

   GIU_VC_to_Smi_parameters["interfaces"]=GIU_VC_to_Smi_interfaces;
   GIU_VC_to_Smi_parameters["packet_descriptor"] = p.packet_descriptor;
   GIU_VC_to_Smi_parameters["vc_descriptor"]=p.vc_descriptor;

  \jsend

  \jsbegin
  for (var smi in smitx){
  \jsend
    \= wire("",GIU_VC_to_Smi_interfaces["smiTxInt"][smi]) =\
  \jsbegin 
  }
  \jsend

  \=wire("",GIU_VC_to_Smi_interfaces["active"],[]) =\

  \=u.nInstance({
        instanceName: 'giu_VC_to_SMI',
        moduleName: 'giu_VC_to_SMI',
        params: GIU_VC_to_Smi_parameters, 
        interfaceObj: {
        interfaces: GIU_VC_to_Smi_interfaces,
        prefixes: GIU_VC_to_Smi_interfaces
        }
    })=\
  




  \jsbegin

///////////////////////////////////////////////////////////////////////////
//
//giu_smi_rx2_demux Instanciation
// decodes teh dtwdbg response for trace capture
///////////////////////////////////////////////////////////////////////////

  var giu_smi_rx2_demux_interfaces = {};
  var smirx_in = m.deepCopy(p.interfaces["smirx_trace"]);
  var smirx_out = m.deepCopy(p.interfaces["smirx_trace"]);
  var smirx_trace = m.deepCopy(p.interfaces["smirx_trace"]);
  smirx_in.name = p.interfaces["smiRxInt"][2].name
  smirx_in["direction"] ="slave";

  smirx_out.name ="smi_rx2_demux_func_";
  smirx_trace.name ="smi_rx2_demux_trace_";
  giu_smi_rx2_demux_interfaces["smirx_in"] = smirx_in;
  giu_smi_rx2_demux_interfaces["smirx_out"] = smirx_out;
  giu_smi_rx2_demux_interfaces["smirx_trace"] = smirx_trace;



  giu_smi_rx2_demux_interfaces["active"] = m.deepCopy(Active);
  giu_smi_rx2_demux_interfaces["active"].name = "giu_smi_rx2_demux_";
  giu_smi_rx2_demux_interfaces["active"].direction = "slave";

  var giu_smi_rx2_demux_parameters ={interfaces :giu_smi_rx2_demux_interfaces,
                                      cmType : p.cmType
  }

  \jsend
\=wire("",smirx_out,[])=\

\= wire("",giu_smi_rx2_demux_interfaces["active"],[]) =\

      \=u.nInstance({
          instanceName: 'giu_smi_rx2_demux',
          moduleName: 'giu_smi_rx2_demux',
          params: giu_smi_rx2_demux_parameters, 
          interfaceObj: {
          interfaces: giu_smi_rx2_demux_interfaces,
          prefixes: giu_smi_rx2_demux_interfaces
        }
      })=\
\jsbegin
///////////////////////////////////////////////////////////////////////////
//
//GIU_Smi_to_VC Instanciation
//It converts the the padded SMI message back ot its original format
// The order for teh packing is provided by SMI_ndp_packing_order and SMI_dp_packing_order
// It always pack ndp before dp
//It always assumes 1 beat dp.
///////////////////////////////////////////////////////////////////////////
var GIU_Smi_to_VC_interfaces ={};
GIU_Smi_to_VC_interfaces["smiRxInt"] = m.deepCopy(p.interfaces  ["smiRxInt"]);
GIU_Smi_to_VC_interfaces["smiRxInt"][2].name = "smi_rx2_demux_func_";
for(var i = 0 ; i<p.vc_descriptor["nVC"]; i++){
  var VC = m.deepCopy(p.Generic_interfaces["InterfaceGenRdyVld"]);
  VC["params"]["wData"]= p.vc_descriptor["MessageSizeInGranule"][i] * p.packet_descriptor["GranuleSizeInBytes"] * 8;
  VC["name"]= "VC_"+i+"_to_framer_";
  VC["direction"]= "master";
  GIU_Smi_to_VC_interfaces["VC_"+i] = VC;

}


  GIU_Smi_to_VC_interfaces["active"] = m.deepCopy(Active);
  GIU_Smi_to_VC_interfaces["active"].name = "giu_SMI_to_VC_";
  GIU_Smi_to_VC_interfaces["active"].direction = "slave";


var GIU_Smi_to_VC_parameters = {}

 GIU_Smi_to_VC_parameters["interfaces"]=GIU_Smi_to_VC_interfaces;
 GIU_Smi_to_VC_parameters["vc_descriptor"] = p.vc_descriptor;
 GIU_Smi_to_VC_parameters["packet_descriptor"]=p.packet_descriptor;

\jsend


\jsbegin
  for(var vc = 0 ; vc<p.vc_descriptor["nVC"] ; vc++){
\jsend

\=wire("",GIU_Smi_to_VC_interfaces["VC_"+vc],[])=\

\jsbegin
  }
\jsend


\=wire("",GIU_Smi_to_VC_interfaces["active"],[]) =\

\=u.nInstance({
      instanceName: 'giu_SMI_to_VC',
      moduleName: 'giu_SMI_to_VC',
      params: GIU_Smi_to_VC_parameters, 
      interfaceObj: {
      interfaces: GIU_Smi_to_VC_interfaces,
      prefixes: GIU_Smi_to_VC_interfaces
    }
  })=\





\jsbegin


///////////////////////////////////////////////////////////////////////////
//
//Framer Instanciation
//It multiple VCs and provides a packed 64B internal ready valid itnerface
///////////////////////////////////////////////////////////////////////////
  var GIU_Framer_interfaces ={};

  for(var vc = 0 ; vc<p.vc_descriptor["nVC"] ; vc++){
    var VC = m.deepCopy(p.Generic_interfaces["InterfaceGenRdyVld"]);
    VC["params"]["wData"]= p.vc_descriptor["MessageSizeInGranule"][vc] * p.packet_descriptor["GranuleSizeInBytes"] * 8;
    VC["name"]= "VC_"+vc+"_to_framer_";
    VC["direction"]= "slave";
    GIU_Framer_interfaces["VC_"+vc] = VC;
    var credit_use_ = m.deepCopy(p.Generic_interfaces["InterfaceGenVld"]);
    credit_use_["params"]["wData"] = p.packet_descriptor.CreditReturnBits[vc]["values"][2];
    credit_use_["name"] = "credit_use_VC_"+vc+"_";
    credit_use_["direction"] = "master";
    GIU_Framer_interfaces["credit_use_VC_"+vc] =credit_use_;

    var message_credit_use_ = m.deepCopy(p.Generic_interfaces["InterfaceGenVld"]);
    message_credit_use_["params"]["wData"] = p.packet_descriptor.CreditReturnBits[vc]["values"][2];
    message_credit_use_["name"] = "message_credit_use_VC_"+vc+"_";
    message_credit_use_["direction"] = "master";
    GIU_Framer_interfaces["message_credit_use_VC_"+vc] =message_credit_use_;
  
    var credit_status_ = m.deepCopy(p.Generic_interfaces["InterfaceGenData"]);
    credit_status_["params"]["wData"] = p.vc_descriptor.wCredit;
    credit_status_["name"] = "credit_status_VC_"+vc+"_";
    credit_status_["direction"] = "slave";
    GIU_Framer_interfaces["credit_status_"+vc] =credit_status_;

    var message_credit_status_ = m.deepCopy(p.Generic_interfaces["InterfaceGenData"]);
    message_credit_status_["params"]["wData"] = p.vc_descriptor.wCredit;
    message_credit_status_["name"] = "message_credit_status_VC_"+vc+"_";
    message_credit_status_["direction"] = "slave";
    GIU_Framer_interfaces["message_credit_status_"+vc] =message_credit_status_;
  
  }

  GIU_Framer_interfaces["clkInt"] = m.deepCopy(p.interfaces ["clkInt"]);
    GIU_Framer_interfaces["clkInt"].params["wTestEn"]=0;
  GIU_Framer_interfaces["clkInt"].name ="GIU_Framer_";

  GIU_Framer_interfaces["active"] = m.deepCopy(Active);
  GIU_Framer_interfaces["active"].name = "giu_framer_";
  GIU_Framer_interfaces["active"].direction = "slave";

  var framer_out_cxs_in_ = m.deepCopy(p.Generic_interfaces["InterfaceGenRdyVld"]);
  framer_out_cxs_in_["params"]["wData"] = 512;
  framer_out_cxs_in_["name"] = "framer_out_cxs_in_";
  framer_out_cxs_in_["direction"] = "master";
  GIU_Framer_interfaces["framer_out_cxs_in_"] = framer_out_cxs_in_;
  var GIU_Framer_parameters ={};
  GIU_Framer_parameters["interfaces"] = GIU_Framer_interfaces ;
  GIU_Framer_parameters["packet_descriptor"] = p.packet_descriptor ;
  GIU_Framer_parameters["vc_descriptor"] = p.vc_descriptor ;
  GIU_Framer_parameters["Generic_interfaces"] = p.Generic_interfaces;
  \jsend
  

\=wire("",GIU_Framer_interfaces["framer_out_cxs_in_"])=\
\=wire("",GIU_Framer_interfaces["active"])=\
\=wire("",GIU_Framer_interfaces["clkInt"])=\



  \=u.nInstance({
        instanceName: 'giu_framer',
        moduleName: 'giu_framer',
        params: GIU_Framer_parameters, 
        interfaceObj: {
        interfaces: GIU_Framer_interfaces,
        prefixes: GIU_Framer_interfaces
      }
    })=\




\=u.instance ({
               instanceName : 'giu_framer_cg',
               moduleName : 'cg',
               params : {
                           width : 1
                         },
               ports : {
                        clk_in : p.interfaces["clkInt"].name+'clk',
                        clk_out : GIU_Framer_interfaces["clkInt"].name+'clk',
                        test_en :  p.interfaces["clkInt"].name+'test_en',
                        en : 'giu_active'
                        }               
               })=\

assign \=GIU_Framer_interfaces["clkInt"].name=\reset_n = \=p.interfaces["clkInt"].name=\reset_n;


\jsbegin

///////////////////////////////////////////////////////////////////////////
//
//CXS Instanciation
//It operates the conversion between internal 64B ready valid itnerface into CXS formated messages
///////////////////////////////////////////////////////////////////////////

    var GIU_CXS_interfaces = {};


   var cxs_out_ = m.deepCopy(p.Generic_interfaces["InterfaceGenRdyVld"]);
    cxs_out_["params"]["wData"] = 512;
    cxs_out_["name"] = "cxs_out_";
    cxs_out_["direction"] = "master";

  var cxs_in_ = m.deepCopy(p.Generic_interfaces["InterfaceGenRdyVld"]);
    cxs_in_["params"]["wData"] = 512;
    cxs_in_["name"] = "cxs_in_";
    cxs_in_["direction"] = "slave";


    GIU_CXS_interfaces["cxs_out_"] = cxs_out_;    
    GIU_CXS_interfaces["cxs_in_"] = cxs_in_;


    GIU_CXS_interfaces["GIUCXSLR"] = p.interfaces["GIUCXSLR"];

    GIU_CXS_interfaces["cxsTxInt"]  = m.deepCopy(p.interfaces["cxsTxInt"]);
    GIU_CXS_interfaces["cxsTxInt"].name = "cxs_tx_func_";

    GIU_CXS_interfaces["cxsRxInt"]  = m.deepCopy(p.interfaces["cxsRxInt"]);
    GIU_CXS_interfaces["cxsRxInt"].name = "cxs_rx_func_"

  GIU_CXS_interfaces["active"] = m.deepCopy(Active);
  GIU_CXS_interfaces["active"].name = "GIU_CXS_";
  GIU_CXS_interfaces["active"].direction = "slave";
  Active_array.push(GIU_CXS_interfaces["active"].name+"active");

  GIU_CXS_interfaces["clkInt"]  = m.deepCopy(p.interfaces["clkInt"]);
  GIU_CXS_interfaces["clkInt"].params["wTestEn"]=0;
  GIU_CXS_interfaces["clkInt"].name ="GIU_CXS_cg_";

\jsend

  \=wire("",cxs_out_,"")=\
  \=wire("",cxs_in_,"")=\
  \=wire("",GIU_CXS_interfaces["cxsTxInt"],"")=\
  \=wire("",GIU_CXS_interfaces["cxsRxInt"],"")=\
  \=wire("", GIU_CXS_interfaces["active"],"")=\
  \=wire("", GIU_CXS_interfaces["clkInt"],"")=\


  \=u.nInstance({
      instanceName: 'GIU_CXS',
      moduleName: 'GIU_CXS',
      params: {interfaces : GIU_CXS_interfaces}, 
      interfaceObj: {
      interfaces: GIU_CXS_interfaces,
      prefixes: GIU_CXS_interfaces
    }
  })=\


  \=u.instance ({
               instanceName : 'GIU_CXS_cg',
               moduleName : 'cg',
               params : {
                           width : 1
                         },
               ports : {
                        clk_in : p.interfaces["clkInt"].name+'clk',
                        clk_out : GIU_CXS_interfaces["clkInt"].name+'clk',
                        test_en :  p.interfaces["clkInt"].name+'test_en',
                        en : 'giu_active'
                        }               
               })=\

assign \=GIU_CXS_interfaces["clkInt"].name=\reset_n = \=p.interfaces["clkInt"].name=\reset_n;

\jsbegin

///////////////////////////////////////////////////////////////////////////
//Loopback muxes
//sends output of teh CXS block to teh loopback controller and sets input from teh controlelr
///////////////////////////////////////////////////////////////////////////

\jsend

assign cxs_out_deframer_in_valid = cxs_out_valid & ~GIULCSTR_LoopBackEn_out;
assign cxs_out_loop_in_valid = cxs_out_valid & GIULCSTR_LoopBackEn_out;

assign cxs_out_loop_in_data = cxs_out_data;
assign cxs_out_deframer_in_data = cxs_out_data;

assign cxs_out_ready = (cxs_out_loop_in_ready & GIULCSTR_LoopBackEn_out) | (cxs_out_deframer_in_ready & ~GIULCSTR_LoopBackEn_out);

assign cxs_in_valid = (framer_out_cxs_in_valid & ~GIULCSTR_LoopBackEn_out) | (loop_out_cxs_in_valid & GIULCSTR_LoopBackEn_out);

assign framer_out_cxs_in_ready = cxs_in_ready & ~GIULCSTR_LoopBackEn_out;
assign loop_in_cxs_in_ready = cxs_in_ready & GIULCSTR_LoopBackEn_out;

assign cxs_in_data = GIULCSTR_LoopBackEn_out ?  loop_out_cxs_in_data : framer_out_cxs_in_data;
assign loop_out_cxs_in_ready = cxs_in_ready;

\jsbegin
  ///////////////////////////////////////////////////////////////////////////
  //
  //CXS loopback mux
  //
  //Loop TX into RX when LB is enable and teh location is inside teh GIU
  ///////////////////////////////////////////////////////////////////////////
\jsend


\jsbegin

var giu_cxs_mux_fe_interfaces ={};

giu_cxs_mux_fe_interfaces["cxs_tx_out_"] = m.deepCopy(p.interfaces["cxsTxInt"]);
giu_cxs_mux_fe_interfaces["cxs_tx_out_"].direction = "master";

giu_cxs_mux_fe_interfaces["cxs_tx_in_"] = m.deepCopy(cxs_tx_func_int_);
giu_cxs_mux_fe_interfaces["cxs_tx_in_"].direction = "slave";

giu_cxs_mux_fe_interfaces["cxs_rx_in_"] = m.deepCopy(p.interfaces["cxsRxInt"]);
giu_cxs_mux_fe_interfaces["cxs_rx_in_"].direction = "slave";


giu_cxs_mux_fe_interfaces["cxs_rx_out_"] = m.deepCopy(cxs_rx_func_int_);
giu_cxs_mux_fe_interfaces["cxs_rx_out_"].direction = "master";

giu_cxs_mux_fe_interfaces["sel"] = { "params": {
                                              "wIn" : 1,
                                              "wOut" : 0
                                              },
                                      "synonyms": {
                                        "in": [{"name" : "sel", "width" :1}],
                                        "out": []
                                      },
                                      "name": "giu_cxs_mux_fe_",
                                      "interface": "InterfaceGeneric",
                                      "_SKIP_": false,
                                      "interfaceObjType": "",
                                      "synonymsOn": true,
                                      "synonymsExpand": true,
                                      "direction": "master",
                                      "nativePortIndex": -1
                                    };

  giu_cxs_mux_fe_interfaces["active"] = m.deepCopy(Active);
  giu_cxs_mux_fe_interfaces["active"].name = "giu_cxs_mux_fe_";
  giu_cxs_mux_fe_interfaces["active"].direction = "slave";

  Active_array.push(giu_cxs_mux_fe_interfaces["active"].name+"active");
 

var giu_cxs_mux_fe_params = {interfaces : giu_cxs_mux_fe_interfaces};

\jsend

\=wire("",giu_cxs_mux_fe_interfaces["active"],"")=\

assign giu_cxs_mux_fe_sel = GIULCSTR_FarLoopEn_out;

  \=u.nInstance({
        instanceName: 'giu_cxs_mux_fe',
        moduleName: 'giu_cxs_mux',
        params: giu_cxs_mux_fe_params, 
        interfaceObj: {
        interfaces: giu_cxs_mux_fe_interfaces,
        prefixes: giu_cxs_mux_fe_interfaces
      }
    })=\



\jsbegin


  ///////////////////////////////////////////////////////////////////////////
  //
  //CXS loopback mux
  //
  //Loop TX into RX when LB is enable and teh location is inside teh GIU
  ///////////////////////////////////////////////////////////////////////////
var giu_cxs_mux_ne_interfaces ={};

giu_cxs_mux_ne_interfaces["cxs_tx_out_"] = m.deepCopy(cxs_tx_func_int_);
giu_cxs_mux_ne_interfaces["cxs_tx_out_"].direction = "master";

giu_cxs_mux_ne_interfaces["cxs_tx_in_"] = m.deepCopy(GIU_CXS_interfaces["cxsTxInt"]);
giu_cxs_mux_ne_interfaces["cxs_tx_in_"].direction = "slave";

giu_cxs_mux_ne_interfaces["cxs_rx_in_"] = m.deepCopy(cxs_rx_func_int_);
giu_cxs_mux_ne_interfaces["cxs_rx_in_"].direction = "slave";


giu_cxs_mux_ne_interfaces["cxs_rx_out_"] = m.deepCopy(GIU_CXS_interfaces["cxsRxInt"]);
giu_cxs_mux_ne_interfaces["cxs_rx_out_"].direction = "master";

giu_cxs_mux_ne_interfaces["sel"] = { "params": {
                                              "wIn" : 1,
                                              "wOut" : 0
                                              },
                                      "synonyms": {
                                        "in": [{"name" : "sel", "width" :1}],
                                        "out": []
                                      },
                                      "name": "giu_cxs_mux_ne_",
                                      "interface": "InterfaceGeneric",
                                      "_SKIP_": false,
                                      "interfaceObjType": "",
                                      "synonymsOn": true,
                                      "synonymsExpand": true,
                                      "direction": "master",
                                      "nativePortIndex": -1
                                    };

  giu_cxs_mux_ne_interfaces["active"] = m.deepCopy(Active);
  giu_cxs_mux_ne_interfaces["active"].name = "giu_cxs_mux_ne_";
  giu_cxs_mux_ne_interfaces["active"].direction = "slave";
  Active_array.push(giu_cxs_mux_ne_interfaces["active"].name+"active");


var giu_cxs_mux_ne_params = {interfaces : giu_cxs_mux_ne_interfaces};

\jsend

\=wire("",giu_cxs_mux_ne_interfaces["active"],"")=\

assign giu_cxs_mux_ne_sel = GIULCSTR_NearLoopEn_out ;

  \=u.nInstance({
        instanceName: 'giu_cxs_mux_ne',
        moduleName: 'giu_cxs_mux',
        params: giu_cxs_mux_ne_params, 
        interfaceObj: {
        interfaces: giu_cxs_mux_ne_interfaces,
        prefixes: giu_cxs_mux_ne_interfaces
      }
    })=\


\jsbegin
  ///////////////////////////////////////////////////////////////////////////
  //
  //GIU_SMI0_processing instanciation.
  //Updates CmdReq with the proper destinations after doing anaddress decoding
  //
  //
  ///////////////////////////////////////////////////////////////////////////
  
  var GIU_SMI0_processing_interfaces = {};

  var smitx_in = m.deepCopy(p.interfaces["smiTxInt"]);
  var smitx_out = m.deepCopy(p.interfaces["smiTxInt"]);

  for (var smi in smitx){
    if (p.interfaces["smiTxInt"][smi].name == "smi_tx0_"){
        var smitx_in = m.deepCopy(p.interfaces["smiTxInt"][smi]);
        var smitx_out = m.deepCopy(p.interfaces["smiTxInt"][smi]);
        smitx_in["direction"] ="slave";
        smitx_in.name ="smi_tx0_to_smi_processor_";
        GIU_SMI0_processing_interfaces["smiTxInt_in"] = smitx_in;
        GIU_SMI0_processing_interfaces["smiTxInt_out"] = smitx_out;
    }

  }

  for (var reg=0; reg< p.system["nGPWindows"]; reg++){
    GIU_SMI0_processing_interfaces["GIUGPRAR"+reg] = p.interfaces["GIUGPRAR"+reg];
    GIU_SMI0_processing_interfaces["GIUGPRBLR"+reg] = p.interfaces["GIUGPRBLR"+reg];
    GIU_SMI0_processing_interfaces["GIUGPRBHR"+reg] = p.interfaces["GIUGPRBHR"+reg];
    }

  GIU_SMI0_processing_interfaces["GIUNRSBHR"] = p.interfaces["GIUNRSBHR"];
  GIU_SMI0_processing_interfaces["GIUNRSBLR"] = p.interfaces["GIUNRSBLR"];
  GIU_SMI0_processing_interfaces["GIUNRSBAR"] = p.interfaces["GIUNRSBAR"];

  GIU_SMI0_processing_interfaces["GIUBRBLR"] = p.interfaces["GIUBRBLR"];
  GIU_SMI0_processing_interfaces["GIUBRBHR"] = p.interfaces["GIUBRBHR"];


  GIU_SMI0_processing_interfaces["GIUBRAR"] = m.deepCopy(p.interfaces["GIUBRAR"]);

  GIU_SMI0_processing_interfaces["DMIMIFSR"] = m.deepCopy(p.interfaces["DMIMIFSR"]);
  GIU_SMI0_processing_interfaces["DMIAMIGR"] = m.deepCopy(p.interfaces["DMIAMIGR"]);

  GIU_SMI0_processing_interfaces["clkInt"]  = m.deepCopy(p.interfaces["clkInt"]);
  GIU_SMI0_processing_interfaces["clkInt"].params["wTestEn"]=0;
  GIU_SMI0_processing_interfaces["clkInt"].name ="GIU_SMI0_processing_cg_";


  GIU_SMI0_processing_interfaces["active"] = m.deepCopy(Active);
  GIU_SMI0_processing_interfaces["active"].name = "GIU_SMI0_processing_";
  GIU_SMI0_processing_interfaces["active"].direction = "slave";
  Active_array.push(GIU_SMI0_processing_interfaces["active"].name+"active");


  GIU_SMI0_processing_interfaces["uIdInt"] = p.interfaces["uIdInt"][0];
  GIU_SMI0_processing_interfaces["uChipletIdInt"]  = p.interfaces ["uChipletIdInt"];

  GIU_SMI0_processing_interfaces["uSysDmiIdInt"] = p.interfaces["uSysDmiIdInt"];
  GIU_SMI0_processing_interfaces["uSysDmiIdInt"] = p.interfaces["uSysDmiIdInt"];
  GIU_SMI0_processing_interfaces["uSysDiiIdInt"] = p.interfaces["uSysDiiIdInt"];
  GIU_SMI0_processing_interfaces["uSysDceIdInt"] = p.interfaces["uSysDceIdInt"];
  
  var GIU_SMI0_processing_parameters = {};
  GIU_SMI0_processing_parameters["interfaces"] = GIU_SMI0_processing_interfaces;
  GIU_SMI0_processing_parameters["system"] = p.system;
  GIU_SMI0_processing_parameters["concParams"] = p.concParams;
  GIU_SMI0_processing_parameters["CsrInfo"] = p.CsrInfo;
  GIU_SMI0_processing_parameters["InterleaveInfo"] = p.InterleaveInfo;
  GIU_SMI0_processing_parameters["Generic_interfaces"] = p.Generic_interfaces;

  \jsend
  

  \=wire("", GIU_SMI0_processing_interfaces["active"],"")=\
  \=wire("", GIU_SMI0_processing_interfaces["clkInt"],"")=\


      \=u.nInstance({
          instanceName: 'giu_SMI0_processing',
          moduleName: 'giu_SMI0_processing',
          params: GIU_SMI0_processing_parameters, 
          interfaceObj: {
          interfaces: GIU_SMI0_processing_interfaces,
          prefixes: GIU_SMI0_processing_interfaces
        }
      })=\
    

  \=u.instance ({
               instanceName : 'GIU_SMI0_processing_cg',
               moduleName : 'cg',
               params : {
                           width : 1
                         },
               ports : {
                        clk_in : p.interfaces["clkInt"].name+'clk',
                        clk_out : GIU_SMI0_processing_interfaces["clkInt"].name+'clk',
                        test_en :  p.interfaces["clkInt"].name+'test_en',
                        en : 'giu_active'
                        }               
               })=\

assign \=GIU_SMI0_processing_interfaces["clkInt"].name=\reset_n = \=p.interfaces["clkInt"].name=\reset_n;

      \jsbegin
      ///////////////////////////////////////////////////////////////////////////
      //
      //GIU_SMI1_processing instanciation.
      //nothing happens in this block
      //
      //
      ///////////////////////////////////////////////////////////////////////////
      
      var GIU_SMI1_processing_interfaces = {};
    
      var smitx_in = m.deepCopy(p.interfaces["smiTxInt"]);
      var smitx_out = m.deepCopy(p.interfaces["smiTxInt"]);
    
      for (var smi in smitx){
        if (p.interfaces["smiTxInt"][smi].name == "smi_tx1_"){
            var smitx_in = m.deepCopy(p.interfaces["smiTxInt"][smi]);
            var smitx_out = m.deepCopy(p.interfaces["smiTxInt"][smi]);
            smitx_in["direction"] ="slave";
            smitx_in.name ="smi_tx1_to_smi_processor_";
            GIU_SMI1_processing_interfaces["smiTxInt_in"] = smitx_in;
            GIU_SMI1_processing_interfaces["smiTxInt_out"] = smitx_out;
        }
    
      }
    
  GIU_SMI1_processing_interfaces["clkInt"]  = m.deepCopy(p.interfaces["clkInt"]);
  GIU_SMI1_processing_interfaces["clkInt"].params["wTestEn"]=0;
  GIU_SMI1_processing_interfaces["clkInt"].name ="GIU_SMI1_processing_cg_";


  GIU_SMI1_processing_interfaces["active"] = m.deepCopy(Active);
  GIU_SMI1_processing_interfaces["active"].name = "GIU_SMI1_processing_";
  GIU_SMI1_processing_interfaces["active"].direction = "slave";


  Active_array.push(GIU_SMI1_processing_interfaces["active"].name+"active");

  var GIU_SMI1_processing_parameters ={interfaces : GIU_SMI1_processing_interfaces};

      \jsend
      
          \=u.nInstance({
              instanceName: 'giu_SMI1_processing',
              moduleName: 'giu_SMI1_processing',
              params: GIU_SMI1_processing_parameters, 
              interfaceObj: {
              interfaces: GIU_SMI1_processing_interfaces,
              prefixes: GIU_SMI1_processing_interfaces
            }
          })=\


  \=u.instance ({
               instanceName : 'GIU_SMI1_processing_cg',
               moduleName : 'cg',
               params : {
                           width : 1
                         },
               ports : {
                        clk_in : p.interfaces["clkInt"].name+'clk',
                        clk_out : GIU_SMI1_processing_interfaces["clkInt"].name+'clk',
                        test_en :  p.interfaces["clkInt"].name+'test_en',
                        en : 'giu_active'
                        }               
               })=\

assign \=GIU_SMI1_processing_interfaces["clkInt"].name=\reset_n = \=p.interfaces["clkInt"].name=\reset_n;

      \jsbegin
      ///////////////////////////////////////////////////////////////////////////
      //
      //GIU_SMI2_processing instanciation.
      //nothing happens in this block
      //
      //
      ///////////////////////////////////////////////////////////////////////////
      
      var GIU_SMI2_processing_interfaces = {};
    
      var smitx_in = m.deepCopy(p.interfaces["smiTxInt"]);
      var smitx_out = m.deepCopy(p.interfaces["smiTxInt"]);
    
      for (var smi in smitx){
        if (p.interfaces["smiTxInt"][smi].name == "smi_tx2_"){
            var smitx_in = m.deepCopy(p.interfaces["smiTxInt"][smi]);
            var smitx_out = m.deepCopy(p.interfaces["smiTxInt"][smi]);
            smitx_in["direction"] ="slave";
            smitx_in.name ="smi_tx2_to_smi_processor_";
            GIU_SMI2_processing_interfaces["smiTxInt_in"] = smitx_in;
            GIU_SMI2_processing_interfaces["smiTxInt_out"] = smitx_out;
        }
    
      }
    
    
  GIU_SMI2_processing_interfaces["clkInt"]  = m.deepCopy(p.interfaces["clkInt"]);
  GIU_SMI2_processing_interfaces["clkInt"].params["wTestEn"]=0;
  GIU_SMI2_processing_interfaces["clkInt"].name ="GIU_SMI2_processing_cg_";


  GIU_SMI2_processing_interfaces["active"] = m.deepCopy(Active);
  GIU_SMI2_processing_interfaces["active"].name = "GIU_SMI2_processing_";
  GIU_SMI2_processing_interfaces["active"].direction = "slave";


  Active_array.push(GIU_SMI2_processing_interfaces["active"].name+"active");      
  
  var GIU_SMI2_processing_parameters ={interfaces : GIU_SMI2_processing_interfaces}
    
      \jsend

\=wire("",GIU_SMI2_processing_interfaces["active"],"")=\
\=wire("",GIU_SMI2_processing_interfaces["clkInt"],"")=\

          \=u.nInstance({
              instanceName: 'giu_SMI2_processing',
              moduleName: 'giu_SMI2_processing',
              params: GIU_SMI2_processing_parameters, 
              interfaceObj: {
              interfaces: GIU_SMI2_processing_interfaces,
              prefixes: GIU_SMI2_processing_interfaces
            }
          })=\


  \=u.instance ({
               instanceName : 'GIU_SMI2_processing_cg',
               moduleName : 'cg',
               params : {
                           width : 1
                         },
               ports : {
                        clk_in : p.interfaces["clkInt"].name+'clk',
                        clk_out : GIU_SMI2_processing_interfaces["clkInt"].name+'clk',
                        test_en :  p.interfaces["clkInt"].name+'test_en',
                        en : 'giu_active'
                        }               
               })=\

assign \=GIU_SMI2_processing_interfaces["clkInt"].name=\reset_n = \=p.interfaces["clkInt"].name=\reset_n;



      \jsbegin
      ///////////////////////////////////////////////////////////////////////////
      //
      //GIU_SMI3_processing instanciation.
      //There is some trace functionality inside
      //
      //
      ///////////////////////////////////////////////////////////////////////////
              
      var GIU_SMI3_processing_interfaces = {};
              
      var smitx_in = m.deepCopy(p.interfaces["smiTxInt"]);
      var smitx_out = m.deepCopy(p.interfaces["smiTxInt"]);
              
      for (var smi in smitx){
        if (p.interfaces["smiTxInt"][smi].name == "smi_tx3_"){
            var smitx_in = m.deepCopy(p.interfaces["smiTxInt"][smi]);
            var smitx_out = m.deepCopy(p.interfaces["smiTxInt"][smi]);
            smitx_in["direction"] ="slave";
            smitx_in.name ="smi_tx3_to_smi_processor_";
            GIU_SMI3_processing_interfaces["smiTxInt_in"] = smitx_in;
            GIU_SMI3_processing_interfaces["smiTxInt_out"] = smitx_out;
        }
      
      }
      GIU_SMI3_processing_interfaces["smi_tx_trace_"] = p.interfaces["smi_tx_trace_"];
      GIU_SMI3_processing_interfaces["clkInt"]  = m.deepCopy(p.interfaces["clkInt"]);
      GIU_SMI3_processing_interfaces["clkInt"].params["wTestEn"]=0;
      GIU_SMI3_processing_interfaces["clkInt"].name ="GIU_SMI3_processing_cg_";


      GIU_SMI3_processing_interfaces["active"] = m.deepCopy(Active);
      GIU_SMI3_processing_interfaces["active"].name = "GIU_SMI3_processing_";
      GIU_SMI3_processing_interfaces["active"].direction = "slave";
      Active_array.push(GIU_SMI3_processing_interfaces["active"].name+"active");      

      var GIU_SMI3_processing_parameters ={interfaces : GIU_SMI3_processing_interfaces,
                                           system : p.system
      }

      \jsend
    \=wire("",GIU_SMI3_processing_interfaces["active"],"")=\
    \=wire("",GIU_SMI3_processing_interfaces["clkInt"],"")=\          
    
    \=u.nInstance({
              instanceName: 'giu_SMI3_processing',
              moduleName: 'giu_SMI3_processing',
              params: GIU_SMI3_processing_parameters, 
              interfaceObj: {
              interfaces: GIU_SMI3_processing_interfaces,
              prefixes: GIU_SMI3_processing_interfaces
            }
          })=\


  \=u.instance ({
               instanceName : 'GIU_SMI3_processing_cg',
               moduleName : 'cg',
               params : {
                           width : 1
                         },
               ports : {
                        clk_in : p.interfaces["clkInt"].name+'clk',
                        clk_out : GIU_SMI3_processing_interfaces["clkInt"].name+'clk',
                        test_en :  p.interfaces["clkInt"].name+'test_en',
                        en : 'giu_active'
                        }               
               })=\

assign \=GIU_SMI3_processing_interfaces["clkInt"].name=\reset_n = \=p.interfaces["clkInt"].name=\reset_n;


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


assign giu_active = \=Active_array.join("|")=\;
\jsbegin
///////////////////////////////////////////////////////////////////////////
//
//PMA
//
//
//
///////////////////////////////////////////////////////////////////////////
          

if(0) {

var giu_pma_interfaces = {};

giu_pma_interfaces['clkInt'] = p.interfaces["clkInt"];

giu_pma_interfaces['masterInt'] = p.interfaces["qInt"];

giu_pma_interfaces['pmaControlInt'] = {
                                    name: 'pma_ctl_',
                                    params: {},
                                    direction: 'master',
                                    interface: 'InterfacePMAControl',
                                    _SKIP_ : "false"
                                  };


var giu_pma_params ={
                      channel       : 'Q',
	                    interfaces          : giu_pma_interfaces,
		                  pipeActive          : true,
                      syncReq             : false
                        };
\jsend

          \=u.nInstance({
              instanceName: 'giu_pma',
              moduleName: 'pma_slave',
              params: giu_pma_params, 
              interfaceObj: {
              interfaces: giu_pma_interfaces,
              prefixes: giu_pma_interfaces
            }
          })=\

  assign pma_ctl_asleep =1'b0;
  assign pma_ctl_goto_sleep = pma_ctl_goto_sleep;
  assign pma_ctl_busy = giu_active;
  assign pma_ctl_abort = 1'b0;


\jsbegin
 }
\jsend


endmodule