\jsbegin
//=============================================================================
// Copyright(C) 2024 Arteris, Inc.
// All rights reserved
//=============================================================================
//GIU
// Author: Benjamin Madon
// There are four interfaces for each VC:
// - 1 valid interface controls the return of credits credit_return_ . it contains a valid and the number of credits returned.
// - 1 valid interface controls the consumtion of credits credit_use_. It contains a valid and the number of credit consumed.
// - 1 valid interface indicate that a message was consumed in one of teh VC buffers credit_return_
// - 1 valid interface indicate how many credit were sent to the other side. credit_sent_
// - A status interface credit_status_  which contains the number of credit available to be used.
// - A status interface credit_return_status_ wich indicates how many credit can be returned to the other side
// - a clock interface
// The module implements a counter of width wCredit for the credit that it can use to send message to the other side. At boot, this value is 0.
// It also implements another coutner of width wCredit that keeps track of how many credit needs to be sent back to the other side. Its reset value is NumberOfCredit.
//=============================================================================


var utilFunctions   = obj.userLib.lib_utils;
var m = obj.userLib;
var u=obj.lib;

var p =u.getParam();

u.nInterfaces(p.interfaces);
\jsend


module \=u.getModuleName()=\ (\=u.getPorts('\n')=\);

 
\jsbegin

//those coutners are counting the number of messages that this GIU can send to the remote. 
for (var vc=0; vc< p.vc_descriptor["nVC"];vc++){
\jsend

wire message_credit_counter_\=vc=\_en;
wire [\=p.vc_descriptor["wCredit"]-1=\ : 0] next_message_credit_status_VC_\=vc=\_data;
wire message_credit_counter_overflow_\=vc=\ ;
\=u.dffre(p.vc_descriptor["wCredit"],"message_credit_status_VC_"+vc+"_data","next_message_credit_status_VC_"+vc+"_data",p.vc_descriptor["wCredit"]+"'d0","message_credit_counter_"+vc+"_en",p.interfaces.clkInt.name+"clk",p.interfaces.clkInt.name+"reset_n")=\
assign message_credit_counter_\=vc=\_en = message_credit_return_VC_\=vc=\_valid | message_credit_use_VC_\=vc=\_valid ;
assign {message_credit_counter_overflow_\=vc=\,next_message_credit_status_VC_\=vc=\_data} = message_credit_status_VC_\=vc=\_data - ( {\=p.vc_descriptor["wCredit"]=\{message_credit_use_VC_\=vc=\_valid}} &
                                                                                            {\=p.vc_descriptor["wCredit"]-p.interfaces["message_credit_use_VC_"+vc].params["wData"]=\'d0,message_credit_use_VC_\=vc=\_data} )
                                                                                        +  ({\=p.vc_descriptor["wCredit"]=\{message_credit_return_VC_\=vc=\_valid}} & 
                                                                                            {\=p.vc_descriptor["wCredit"]-p.interfaces["message_credit_return_VC_"+vc].params["wData"]=\'d0,message_credit_return_VC_\=vc=\_data})
                                                                                           ;
\jsbegin
}
\jsend


\jsbegin
//those coutners are counting the number of credit that can be sent to the remote GIU. 
for (var vc=0; vc< p.vc_descriptor["nVC"];vc++){
\jsend

wire credit_counter_\=vc=\_en;
wire credit_counter_overflow_\=vc=\;
wire [\=p.vc_descriptor["wCredit"]-1=\ : 0] next_credit_status_VC_\=vc=\_data;
\=u.dffre(p.vc_descriptor["wCredit"],"credit_status_VC_"+vc+"_data","next_credit_status_VC_"+vc+"_data",p.vc_descriptor["wCredit"]+"'d"+p.vc_descriptor.NumberOfCredit[vc],"credit_counter_"+vc+"_en",p.interfaces.clkInt.name+"clk",p.interfaces.clkInt.name+"reset_n")=\
assign credit_counter_\=vc=\_en = credit_use_VC_\=vc=\_valid | credit_return_VC_\=vc=\_valid ;
assign {credit_counter_overflow_\=vc=\,next_credit_status_VC_\=vc=\_data} = credit_status_VC_\=vc=\_data - (  {\=p.vc_descriptor["wCredit"]=\{credit_use_VC_\=vc=\_valid}} &
                                                                             {\=p.vc_descriptor["wCredit"]-p.interfaces["credit_use_VC_"+vc].params["wData"]=\'d0,credit_use_VC_\=vc=\_data} )
                                                                        +  ( {\=p.vc_descriptor["wCredit"]=\{credit_return_VC_\=vc=\_valid}} & 
                                                                             {\=p.vc_descriptor["wCredit"]-p.interfaces["credit_return_VC_"+vc].params["wData"]=\'d0,credit_return_VC_\=vc=\_data})
                                                                            ;
\jsbegin
}
\jsend

assign \=p.interfaces["active"].name=\active = 1'b1;

\js if (p.assertOn) {

    `ifdef OVL_ASSERT_ON
    
    //coverage off
    //pragma synthesis_off
    \jsbegin
    for (var vc=0; vc< p.vc_descriptor["nVC"];vc++){
    \jsend
    wire [2:0] fire_counter_overflow\=vc=\;
    ovl_range #(.width(\=p.vc_descriptor["wCredit"]=\),
            .min(0),
            .max(\=p.vc_descriptor.NumberOfCredit[vc]=\), 
            .msg("VC counter out of range")) vc_counter_overflow_\=vc=\ (\=p.interfaces.clkInt.name=\clk, \=p.interfaces.clkInt.name=\reset_n, 1'b1, credit_status_VC_\=vc=\_data, fire_counter_overflow\=vc=\);
    
    wire [2:0] credit_counter_overflow_\=vc=\_assert_fire;
    ovl_never #(.msg("vc credit counter overflow")) credit_counter_overflow_\=vc=\_assert (.clock(\=p.interfaces.clkInt.name=\clk),
                                                                .reset(\=p.interfaces.clkInt.name=\reset_n),
                                                                .enable(1'b1), 
                                                                .test_expr(credit_counter_overflow_\=vc=\),
                                                                .fire(credit_counter_overflow_\=vc=\_assert_fire)
                                                            );

    wire [2:0] message_credit_counter_overflow_\=vc=\_assert_fire;
    ovl_never #(.msg("vc credit counter overflow")) message_credit_counter_overflow_\=vc=\_assert (.clock(\=p.interfaces.clkInt.name=\clk),
                                                                .reset(\=p.interfaces.clkInt.name=\reset_n),
                                                                .enable(1'b1), 
                                                                .test_expr(message_credit_counter_overflow_\=vc=\),
                                                                .fire(message_credit_counter_overflow_\=vc=\_assert_fire));
    
    
            \jsbegin
    }
    \jsend  
    //pragma synthesis_on
    //coverage on
    
    `endif
    
    \js }
endmodule