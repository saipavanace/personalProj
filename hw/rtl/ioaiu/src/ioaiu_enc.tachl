\jsbegin
///////////////////////////////////////////////////////////////////////////
// Arteris Inc. 2021
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
// NCore 3.2
// Author : Nabil
// Date   : May 2021
//
// Description : IOAIU enc.
//
//////////////////////////////////////////////////////////////////////////
var u = obj.lib;
var m = obj.userLib;
var log2ceil = function(n) { return Math.ceil(Math.log(n)/Math.LN2); };

u.paramDefault('NW', 'int', 16);
u.paramDefault('NO_VALID_OUT', 'int', 0);
u.paramDefault('NO_INDEX_OUT', 'int', 0);
u.paramDefault('NO_BV_OUT', 'int', 0);

var DW = u.getParam('DW');
var BE = u.getParam('BE');
var NW = u.getParam('NW');
var NO_VALID_OUT = u.getParam('NO_VALID_OUT');
var NO_INDEX_OUT = u.getParam('NO_INDEX_OUT');
var NO_BV_OUT = u.getParam('NO_BV_OUT');
var assertOn = u.getParam('assertOn');

// This is only used for the OTT, and the OTT maximum size for 3.7 is 128
// AW max is then 7
// FW max is always 4 since NW is always 16
//    DW        N0        N1        N2
//     4,        1,        0,        0
//     8,        1,        0,        0
//    16,        1,        0,        0
//    32,        2,        1,        0
//    64,        4,        1,        0
//   128,        8,        1,        0
//   256,       16,        1,        0
//   512,       32,        2,        1
var AW = log2ceil(DW);
var FW = log2ceil(NW);
var N0 = Math.floor(DW/NW) + ((DW%NW>0)?1:0);
var N1 = (N0 > 1) ? Math.floor(N0/NW) + ((N0%NW>0)?1:0) : 0;
/* istanbul ignore next env ncore_3p7 */
var N2 = (N1 > 1) ? Math.floor(N1/NW) + ((N1%NW>0)?1:0) : 0;

u.paramDefault('clkAssertInterface', 'object', null);
var clkAssertInterface     = m.hierGetParam('clkAssertInterface', u.getParam);
u.interface(clkAssertInterface.name, 'slave', clkAssertInterface.signals);

u.port('input','bv_i',DW);
if (!NO_VALID_OUT) {
u.port('output','valid_o',1);
}
if (!NO_INDEX_OUT) {
u.port('output','index_o',AW);
}
if (!NO_BV_OUT) {
u.port('output','bv_o',DW);
}

\jsend

module \=u.getModuleName()=\ (
\=u.getPorts('\n    ')=\
);

\js if (NO_VALID_OUT) {
wire valid_o;
\js }
\js if (NO_INDEX_OUT) {
wire [\=AW-1=\:0] index_o;
\js }
\js if (NO_BV_OUT) {
wire [\=DW-1=\:0] bv_o;
\js }

wire [\=N0*NW-1=\:0]t_n0_bv, t_bv;
wire [\=N0-1=\:0]	w_n0_val;
wire [\=FW-1=\:0]	w_n0_off[0:\=N0-1=\], t_n0_addr;
wire [\=N1*NW=\:0]	t_n1_bv;
wire [\=N1=\:0]	w_n1_val;
wire [\=FW-1=\:0]	w_n1_off[0:\=N1=\], t_n1_addr;
wire [\=N2*NW=\:0]	t_n2_bv;
wire [\=N2=\:0]	w_n2_val;
wire [\=FW-1=\:0]	w_n2_off[0:\=N2=\], t_n2_addr;
wire [\=3*FW-1=\:0]	t_n_addr;
wire [\=AW-1=\:0]	t_index;
wire [\=NW-1=\:0]	w_n0_bv[\=N0-1=\:0];
\jsbegin
/* istanbul ignore if env ncore_3p7 */
if ((N1-1)>0) {
var W_N1_BV_NDX = (N-1);
} else {
var W_N1_BV_NDX = 0;
} \jsend
wire [\=NW-1=\:0]	w_n1_bv[\=W_N1_BV_NDX=\:0];
wire [\=NW-1=\:0]	w_n2_bv[\=N2=\:0];

assign valid_o = (| bv_i);
assign index_o = t_index;
assign bv_o = t_bv[\=DW-1=\:0]; 		//(({DW{1'b1}}>>(DW-1)) << t_index);
\js for (let n=0; n<N0; n=n+1) {
assign t_bv[\=n*NW=\ +: \=NW=\] = w_n0_bv[\=n=\] & 
				{\=NW=\{(\=N1=\==0) | w_n1_bv[\=Math.floor(n/NW)=\][\=n%NW=\]}} &
				{\=NW=\{(\=N2=\==0) | w_n2_bv[\=Math.floor(n/NW/NW)=\][\=Math.floor(n/NW)%NW=\]}};
\js }

assign t_n_addr = {t_n2_addr, t_n1_addr, t_n0_addr};
\jsbegin
// log2(DW) > 3*4 only possible if DW==8192
/* istanbul ignore if env ncore_3p7 */
    if(AW>3*FW) { \jsend
	assign t_index = {{\=(AW-3*FW)=\{1'b0}},t_n_addr};
\js } else {
	assign t_index = t_n_addr[\=AW-1=\:0];
\js }

\js for (let i=0; i<N0*NW; i=i+1) {
assign t_n0_bv[\=i=\] = (\=i=\>=\=DW=\) ? 1'b0 : bv_i[\=i%DW=\];
\js }

\js for (let i=0; i<N0; i=i+1) {
\=u.instance({
	moduleName: 'ioaiu_encoder',
	instanceName: 'n0_'+i,
	params: {
		DW:		NW,
		BE:		BE,
                clkAssertInterface: clkAssertInterface,
                assertOn : assertOn
        },
	ports: {
		bv_i:		't_n0_bv['+i*NW+' +: '+NW+']',
		valid_o:	'w_n0_val['+i+']',
		index_o:	'w_n0_off['+i+']',
		bv_o:		'w_n0_bv['+i+']'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\

\js }
wire [\=2*FW-1=\:0] t_n12_addr = {t_n2_addr, t_n1_addr};
\js if (N0==1) {
assign t_n0_addr = w_n0_off[0];
\js } else {
\jsbegin
/* istanbul ignore else env ncore_3p7 */
if (log2ceil(N0)) {
var W_N0_OFF_NDX = log2ceil(N0);
} else {
var W_N0_OFF_NDX = 1;
} \jsend
assign t_n0_addr = w_n0_off[t_n12_addr[\=W_N0_OFF_NDX-1=\:0]];
\js }

\js if (N1*NW+1>N0) {
assign t_n1_bv = {{\=(N1*NW+1-N0)=\{1'b0}}, w_n0_val};
\js } else {
assign t_n1_bv = w_n0_val;
\js }
\js if (N1>0) {
\js for (let i=0; i<N1; i=i+1) {
\=u.instance({
	moduleName: 'ioaiu_encoder',
	instanceName: 'n1_'+i,
	params: {
		DW:		NW,
		BE:		BE,
                clkAssertInterface: clkAssertInterface,
                assertOn : assertOn
        },
	ports: {
		bv_i:		't_n1_bv['+i*NW+' +: '+NW+']',
		valid_o:	'w_n1_val['+i+']',
		index_o:	'w_n1_off['+i+']',
		bv_o:		'w_n1_bv['+i+']'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\
\js }
\js } else {
assign w_n1_bv[0] = {\=NW=\{1'b0}};
\js }

\js if(N1==0) {
assign t_n1_addr = {\=FW=\{1'b0}};
\js } else {
assign t_n1_addr = w_n1_off[t_n2_addr[\=log2ceil(N1+1)-1=\:0]];
\js }

\jsbegin
// Only used if nOTT>256
/* istanbul ignore if env ncore_3p7 */
    if(N1>1) { \jsend
	assign t_n2_bv = {\=(N2*NW+1)=\{1'b0}} | w_n1_val;  //N2*NW >= N1
\js } else {
	assign t_n2_bv = {\=(N2*NW+1)=\{1'b0}} | w_n1_val[\=N2*NW=\:0];
\js }

\jsbegin
// Only used if nOTT>256
/* istanbul ignore if env ncore_3p7 */
    if (N2>0) { \jsend
\js for (let i=0; i<N2; i=i+1) {
\=u.instance({
	moduleName: 'ioaiu_encoder',
	instanceName: 'n2_'+i,
	params: {
		DW:		NW,
		BE:		BE,
                clkAssertInterface: clkAssertInterface,
                assertOn : assertOn
        },
	ports: {
		bv_i:		't_n2_bv['+i*NW+' +: '+NW+']',
		valid_o:	'w_n2_val['+i+']',
		index_o:	'w_n2_off['+i+']',
		bv_o:		'w_n2_bv['+i+']'
	},
        interfaces: [ {modulePrefix: '', localPrefix: '', interface: clkAssertInterface.signals} ],
	portsDelimiter: '\n\t'
})=\
\js }
\js } else {
assign w_n2_bv[0] = {\=NW=\{1'b0}};
\js }
assign t_n2_addr = (\=N2=\==0) ? {\=FW=\{1'b0}} : w_n2_off[0];

assign w_n1_val[\=N1=\] = 1'b0;
assign w_n1_off[\=N1=\] = {\=FW=\{1'b0}};
assign w_n2_off[\=N2=\] = {\=FW=\{1'b0}};

/////////////////////////////////////////////////////////////////////////
\jsbegin
/* istanbul ignore else env ncore_3p6,ncore_3p7 */
if (assertOn) { \jsend
`ifdef OVL_ASSERT_ON
// pragma synthesis_off
// synopsys translate_off
// coverage off

assert_proposition #(0) assert_parameters(
	.reset_n	(valid_o),
	.test_expr	((\=DW=\<=\=(NW*NW*NW)=\) & (\=DW=\<=\=2**12=\) & (\=N2=\<2))
);

assert_never #(0) assert_enc(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	((valid_o & ~bv_i[index_o]) |
			 (valid_o & (bv_o != (({\=DW=\{1'b1}}>>\=(DW-1)=\)<<index_o))) |
			 ((\=BE=\>0)  & (| (bv_i &  ({\=DW=\{1'b1}}<<(index_o+1))))) |
			 ((\=BE=\==0) & (| (bv_i & ~({\=DW=\{1'b1}}<<index_o)))))
);

// coverage on
// synopsys translate_on
// pragma synthesis_on
`endif
\js }
endmodule
