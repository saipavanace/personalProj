\jsbegin
///////////////////////////////////////////////////////////////////////////
// Arteris Inc. 2021
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
// NCore 3.2
// Author : Nabil
// Date   : May 2021
//
// Description : IOAIU credit.
//
//////////////////////////////////////////////////////////////////////////
var u = obj.lib;
var log2ceil = function(n) { return Math.ceil(Math.log(n)/Math.LN2); };
var ioaiu_power2 = function(n) { return ((n & (n-1)) == 0) ? 1 : 0; };

var DRST = u.getParam('DRST');
var assertOn = u.getParam('assertOn');
var clkAssertInterface = u.getParam('clkAssertInterface');

var DECT = u.getParam('DECT');
var TINW = u.getParam('TINW');
var FIDW = u.getParam('FIDW');
var NUM = u.getParam('NUM');
var MAXK = u.getParam('MAXK');
var TOTAL = u.getParam('TOTAL');
var WRITE = u.getParam('WRITE');
var SHARE =u.getParam('SHARE') ;

var TA = log2ceil(MAXK) + ioaiu_power2(MAXK);

\jsend

module \=u.getModuleName()=\ (
	clk_i,
	reset_ni,
	cfg_adj_i,
	cfg_share_i,
	fids_i,
	inc_i,
	inc_wr_i,
	inc_tin_i,
	inc_tin_o,
	dec_i,
	dec_fid_i,
	bok_o,
	wok_o,
	idle_o
);

input		clk_i;
input		reset_ni;
input [3:0]	cfg_adj_i;	//Credits adjustment:
				//	- Limit maximum up to config value.
				// 		0x1: Maximum credit is 1.
				// 		0x2: Maximum credit is 2.
				// 		0x3: Maximum credit is 3.
				//	- Reduce total to minimum of 1.
				// 		0x5: Minus 1.
				// 		0x6: Minus 2.
				// 		0x7: Minus 3.
				//	- Special cases
				// 		0x9: 1 read only. Others write.
				// 		0xa: Reserve 1 write if possible
				// 		0xb: Let it rip. No limit at all
				//	- Increase write reservation to max-1
				//		0xd: 1 extra reserved writes
				//		0xe: 2 extra reserved writes
				//		0xf: 3 extra reserved writes
input			cfg_share_i;
input [\=NUM*FIDW-1=\:0]	fids_i;
input			inc_i;
input			inc_wr_i;
input [\=TINW-1=\:0]	inc_tin_i;
output [\=TINW-1=\:0]	inc_tin_o;
input			dec_i;
input [\=FIDW-1=\:0]	dec_fid_i;
output [\=NUM-1=\:0]	bok_o, wok_o;
output			idle_o;


wire [\=NUM-1=\:0]	t_room_rd, t_room_wr;
wire [\=NUM-1=\:0]	t_share_rd, t_share_wr;
wire [\=TINW-1=\:0]	w_inc_id;
wire [\=NUM-1=\:0]	w_inc_bv, w_dec_bv;
wire [\=NUM-1=\:0]	t_incs, t_decs;
wire [\=NUM-1=\:0]	t_idles;
wire [\=TA-1=\:0]	t_count[\=NUM-1=\:0];
reg [\=TA=\:0]	t_max_rd[\=NUM-1=\:0], t_max_wr[\=NUM-1=\:0];

wire [\=TA-1=\:0]	q_count[\=NUM-1=\:0];

assign idle_o = (& t_idles);
assign inc_tin_o =
\js if (SHARE>0) {
                   w_inc_id;
\js } else {
                   inc_tin_i;
\js }

\js for (let i=0; i<NUM; i=i+1) {

wire		t_inc\=i=\, t_dec\=i=\;

always @ (*) begin
	casez (cfg_adj_i)
		{2'h0, 2'h1}: begin
			t_max_wr[\=i=\] = \=TA+1=\'d1;
			t_max_rd[\=i=\] = \=TA+1=\'d1;
		end
		{2'h0, 2'h2}: begin
			t_max_wr[\=i=\] =
\js if (TOTAL[i]>2) {
                                         \=TA+1=\'d2;
\js } else {
                                         \=TA+1=\'d\=TOTAL[i]=\;
\js }
			t_max_rd[\=i=\] = t_max_wr[\=i=\] -
\js if (WRITE[i]>1) {
                                                            \=TA+1=\'d1;
\js } else {
                                                            \=TA+1=\'d0;
\js }
		end
		{2'h0, 2'h3}: begin
			t_max_wr[\=i=\] = 
\js if (TOTAL[i]>3) {
                                          \=TA+1=\'d3;
\js } else {
                                          \=TA+1=\'d\=TOTAL[i]=\;
\js }
			t_max_rd[\=i=\] = t_max_wr[\=i=\] -
\js if (WRITE[i]>2) {
                                                            \=TA+1=\'d2;
\js } else {
						            \=TA+1=\'d\=WRITE[i]=\;
\js }
		end
		{2'h1, 2'h1}: begin
			t_max_wr[\=i=\] = 
\js if (TOTAL[i]>1) {
                                          \=TA+1=\'d\=TOTAL[i]-1=\;
\js } else {
                                          \=TA+1=\'d1;
\js }
			t_max_rd[\=i=\] = t_max_wr[\=i=\] -
\js if (WRITE[i]>0) {
                                                            \=TA+1=\'d\=WRITE[i]-1=\;
\js } else {
							    \=TA+1=\'d\=WRITE[i]=\;
\js }
		end
		{2'h1, 2'h2}: begin
			t_max_wr[\=i=\] = 
\js if (TOTAL[i]>2) {
                                          \=TA+1=\'d\=TOTAL[i]-2=\;
\js } else {
                                          \=TA+1=\'d1;
\js }
			t_max_rd[\=i=\] = t_max_wr[\=i=\] -
\js if (WRITE[i]>1) {
                                                            \=TA+1=\'d\=WRITE[i]-2=\;
\js } else if (WRITE[i]>0) { 
                                                            \=TA+1=\'d\=WRITE[i]-1=\;
\js } else {
							    \=TA+1=\'d\=WRITE[i]=\;
\js }
		end
		{2'h1, 2'h3}: begin
			t_max_wr[\=i=\] = 
\js if (TOTAL[i]>3) { 
                                          \=TA+1=\'d\=TOTAL[i]-3=\;
\js } else {
                                          \=TA+1=\'d1;
\js }
			t_max_rd[\=i=\] = t_max_wr[\=i=\] -
\js if (WRITE[i]>2) {
                                          \=TA+1=\'d\=WRITE[i]-3=\;
\js } else if (WRITE[i]>1) {
                                          \=TA+1=\'d\=WRITE[i]-2=\;
\js } else if (WRITE[i]>0) {
                                          \=TA+1=\'d\=WRITE[i]-1=\;
\js } else {
					  \=TA+1=\'d\=WRITE[i]=\;
\js }
		end
		{2'h2, 2'h1}: begin
			t_max_wr[\=i=\] = \=TA+1=\'d\=TOTAL[i]=\;
			t_max_rd[\=i=\] = \=TA+1=\'d1;
		end
		{2'h2, 2'h2}: begin
			t_max_wr[\=i=\] = \=TA+1=\'d\=TOTAL[i]=\;
			t_max_rd[\=i=\] = 
\js if (TOTAL[i]>1) {
                                          \=TA+1=\'d\=TOTAL[i]-1=\;
\js } else {
                                          \=TA+1=\'d1;
\js }
		end
		{2'h2, 2'h3}: begin
			t_max_wr[\=i=\] = {\=(TA+1)=\{1'b1}};
			t_max_rd[\=i=\] = {\=(TA+1)=\{1'b1}};
		end
		{2'h3, 2'h1}: begin
			t_max_wr[\=i=\] = \=TA+1=\'d\=TOTAL[i]=\;
			t_max_rd[\=i=\] = \=TA+1=\'d\=TOTAL[i] - WRITE[i]=\ -
\js if ((TOTAL[i]-WRITE[i])>1) {
                                          \=TA+1=\'d1;
\js } else {
				          \=TA+1=\'d0;
\js }
		end
		{2'h3, 2'h2}: begin
			t_max_wr[\=i=\] = \=TA+1=\'d\=TOTAL[i]=\;
			t_max_rd[\=i=\] = \=TA+1=\'d\=TOTAL[i] - WRITE[i]=\ -
\js if ((TOTAL[i]-WRITE[i])>2) { 
                                          \=TA+1=\'d2;
\js } else if ((TOTAL[i]-WRITE[i])>1) { 
                                          \=TA+1=\'d1;
\js } else {
				  	  \=TA+1=\'d0;
\js }
		end
		{2'h3, 2'h3}: begin
			t_max_wr[\=i=\] = \=TA+1=\'d\=TOTAL[i]=\;
			t_max_rd[\=i=\] = \=TA+1=\'d\=TOTAL[i] - WRITE[i]=\ -
\js if ((TOTAL[i]-WRITE[i])>3) { 
                                          \=TA+1=\'d3;
\js } else if ((TOTAL[i]-WRITE[i])>2) {
                                          \=TA+1=\'d2;
\js } else if ((TOTAL[i]-WRITE[i])>1) {
                                          \=TA+1=\'d1;
\js } else {
					  \=TA+1=\'d0;
\js }
		end
		default: begin
			t_max_wr[\=i=\] = \=TA+1=\'d\=TOTAL[i]=\;
			t_max_rd[\=i=\] = \=TA+1=\'d\=TOTAL[i] - WRITE[i]=\;
		end
	endcase
end

assign t_room_rd[\=i=\] = ({1'b0,q_count[\=i=\]} < t_max_rd[\=i=\]);
assign t_room_wr[\=i=\] = ({1'b0,q_count[\=i=\]} < t_max_wr[\=i=\]);

assign bok_o[\=i=\] = t_room_rd[\=i=\] | (| (t_share_rd & ({\=NUM=\{1'b1}}<<\=(i+1)=\)));
assign wok_o[\=i=\] = t_room_wr[\=i=\] | (| (t_share_wr & ({\=NUM=\{1'b1}}<<\=(i+1)=\)));

assign t_inc\=i=\ = inc_i & (
\js if (SHARE>0) {
                        w_inc_bv[\=i=\];
\js } else {
			(inc_tin_i == \=TINW=\'d\=i=\));
\js }
assign t_dec\=i=\ = dec_i & (
\js if (SHARE>0) { 
                        w_dec_bv[\=i=\];
\js } else if (DECT>0) {
                       (dec_fid_i == \=FIDW=\'d\=i=\);
\js } else {
		       (dec_fid_i == fids_i[\=i*FIDW=\ +: \=FIDW=\]));
\js }

wire [\=TA-1=\:0] q_count_in = ( t_inc\=i=\ & ~t_dec\=i=\) ? q_count[\=i=\] + 1'b1 :
			   (~t_inc\=i=\ &  t_dec\=i=\) ? q_count[\=i=\] - 1'b1 :
					       q_count[\=i=\];

wire [\=TA-1=\:0] q_count\=i=\;
assign q_count[\=i=\] = q_count\=i=\;
\=u.dffre(TA, `q_count`+i, `q_count_in`, `{`+TA+`{1'b0}}`, `1'b1`, `clk_i`, `reset_ni`)=\

assign t_incs[\=i=\] = t_inc\=i=\;
assign t_decs[\=i=\] = t_dec\=i=\;
assign t_count[\=i=\] = q_count[\=i=\];
assign t_idles[\=i=\] = (~| q_count[\=i=\]);

\js }

\js if (SHARE) {

wire [\=NUM-1=\:0]	t_avails, t_actives;

\js for (let i=0; i<NUM; i=i+1) {
assign t_share_rd[\=i=\] = ~cfg_share_i & ((q_count[\=i=\]+1'b1) < t_max_rd[\=i=\]);
assign t_share_wr[\=i=\] = ~cfg_share_i & ((q_count[\=i=\]+1'b1) < t_max_wr[\=i=\]);
\js }

assign t_avails = ({\=NUM=\{1'b1}} << inc_tin_i) &
		  (inc_wr_i ? (t_room_wr | t_share_wr) :
			      (t_room_rd | t_share_rd));

\=u.instance({
	moduleName: 'ioaiu_enc',
	instanceName: 'pri_inc',
	params: {
                 DW:             NUM,
                 BE:             0,
                 clkAssertInterface: clkAssertInterface,
                 assertOn: assertOn
        },
	ports: {
		bv_i:		't_avails',
		valid_o:	'',
		index_o:	'w_inc_id',
		bv_o:		'w_inc_bv'
	},
	portsDelimiter: '\n\t'
})=\

assign t_actives = dec_i ? ({\=NUM=\{1'b1}} << dec_fid_i) & ~t_idles : {\=NUM=\{1'b0}};

\=u.instance({
	moduleName: 'ioaiu_enc',
	instanceName: 'pri_dec',
	params: {
                 DW:             NUM,
                 BE:             0,
                 clkAssertInterface: clkAssertInterface,
                 assertOn: assertOn
        },
	ports: {
		bv_i:		't_actives',
		valid_o:	'',
		index_o:	'',
		bv_o:		'w_dec_bv'
	},
	portsDelimiter: '\n\t'
})=\

\js } else {

assign t_share_rd = {\=NUM=\{1'b0}};
assign t_share_wr = {\=NUM=\{1'b0}};
assign w_inc_id = {\=TINW=\{1'b0}};
assign w_inc_bv = {\=NUM=\{1'b0}};
assign w_dec_bv = {\=NUM=\{1'b0}};

\js }

/////////////////////////////////////////////////////////////////
\jsbegin
/* istanbul ignore else env ncore_3p6,ncore_3p7 */
if (assertOn) { \jsend
`ifdef OVL_ASSERT_ON
// pragma synthesis_off
// synopsys translate_off  
// coverage off

assert_never #(0) assert_param(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	(((\=SHARE=\>0) & (\=DECT=\==0)) |
			 (\=TINW=\ < \=log2ceil(NUM)=\))
);

wire [\=NUM-1=\:0]	g_fulls;
\js for (let i=0; i<NUM; i=i+1) {
assign g_fulls[\=i=\] = (q_count[\=i=\] == \=TOTAL[i]=\);

assert_never #(0) assert_cparam(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	((\=TOTAL[i]=\ <= \=WRITE[i]=\) | 
			 (\=TOTAL[i]=\ > \=MAXK=\))
);
assert_never #(0) assert_credit(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	((bok_o[\=i=\] & ~wok_o[\=i=\]) |
			 (~| t_max_wr[\=i=\]) |
			 (~| t_max_rd[\=i=\]) |
			 (~(cfg_adj_i==4'hb) & (
				(t_incs[\=i=\] & (t_count[\=i=\] == \=TOTAL[i]=\))|
				(t_count[\=i=\] > \=TOTAL[i]=\) |
				(t_decs[\=i=\] & (~| t_count[\=i=\])))))
);
\js }

assert_never #(0) assert_control(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	((cfg_share_i & dec_i & ~t_decs[dec_fid_i]) |
			 (cfg_share_i & inc_i & ~t_incs[dec_fid_i]) |
			 (inc_i & (& g_fulls) & (cfg_adj_i != 4'hb)) |
			 (inc_i & (~| t_incs)) |
			 ((\=SHARE=\>0) & dec_i & (~| t_decs)) |
			 ((\=SHARE=\>0) & dec_i & (& t_idles)) |
			 (ioaiu_sum(t_incs)>1) |
			 (ioaiu_sum(t_decs)>1))
);

// coverage on
// synopsys translate_on 
// pragma synthesis_on
`endif

\js }

endmodule
