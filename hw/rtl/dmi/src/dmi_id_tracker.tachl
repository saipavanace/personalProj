\jsbegin
//=============================================================================
// Copyright (C) 2017 Arteris, Inc.
// All rights reserved.
//=============================================================================
// ID tracker
// Aurthor: Tso-Wei Chang
//
// This module tracks same id requests ordering.
// The entry index is returned when searchId matches entryId and it is
// the head of the id.
//=============================================================================
\jsend

\jsbegin

// default is bypass
var log2ceil = function(n) { return Math.ceil(Math.log(n)/Math.LN2); };
var width = obj.lib.getParam('width');
var numEntries = obj.lib.getParam('numEntries');
var lookup_bypass_mode = obj.lib.getParam('lookup_bypass_mode');
var logNumEntries   = log2ceil(numEntries);
var assertOn = obj.lib.getParam('assertOn');

\jsend   
\jsbegin
// clock interface
obj.lib.interface('', 'slave', obj.lib.getParam('clkInterface'));
// alloc/dealloc interface
obj.lib.port('input',  'allocEn',  1);
obj.lib.port('input',  'allocId',  width);
obj.lib.port('input',  'allocIdx', numEntries);
obj.lib.port('input',  'deallocEn',1);
// index search interface
obj.lib.port('input',  'searchId', width);
obj.lib.port('output', 'searchIdx',numEntries);
\jsend

module \=obj.lib.getModuleName()=\ (\=obj.lib.getPorts('\n')=\);
\jsbegin   
    //
    // Wires
    //

    // Entry Fields
\jsend


\jsbegin
    /* istanbul ignore if env ncore_3p0,ncore_3p2,ncore_3p4 ,ncore_3p6, ncore_3p7*/
    if ( lookup_bypass_mode ) {
\jsend
assign searchIdx = \=numEntries=\'b1 << searchId; 

\js } else {
    wire [\=numEntries-1=\:0] valid;
    wire [\=numEntries-1=\:0] head;
    wire [\=numEntries-1=\:0] tail;
\js for(var i = 0; i < numEntries; i++) {
    wire [\=numEntries-1=\:0] ptr\=i=\;
    wire [\=width-1=\:0] entryId\=i=\;
\js }
    wire [\=numEntries-1=\:0] validIn;
    wire [\=numEntries-1=\:0] headIn;
    wire [\=numEntries-1=\:0] tailIn;
    wire [\=numEntries-1=\:0] ptrIn;

    wire validEn;
    wire headEn;
    wire tailEn;
    wire [\=numEntries-1=\:0] validSet;
    wire [\=numEntries-1=\:0] validClr;
    wire [\=numEntries-1=\:0] headAllocSet;
    wire [\=numEntries-1=\:0] headDeallocSet;
    wire [\=numEntries-1=\:0] headClr;
    wire [\=numEntries-1=\:0] tailSet;
    wire [\=numEntries-1=\:0] tailClr;    

    wire [\=numEntries-1=\:0] searchIdxPtrCAM;
    wire [\=numEntries-1=\:0] allocIdCAM;
    wire [\=numEntries-1=\:0] searchIdCAM;
    \jsbegin
    // Id CAM, handling same id alloc & dealloc at the same cycle
    \jsend

\js for(var j=0; j < numEntries; j++) {
    assign allocIdCAM[\=j=\] = (entryId\=j=\ == allocId) & ~(searchIdx[\=j=\] & deallocEn);
    assign searchIdCAM[\=j=\] = (entryId\=j=\ == searchId); 
     assign searchIdxPtrCAM[\=j=\] = (ptr\=j=\ == searchIdx); 
\js }

\jsbegin
    // 
    // Valid flops
    //
\jsend

    \=obj.lib.dffre(numEntries, 'valid', 'validIn', numEntries+"'d0", 'validEn', 'clk', 'reset_n')=\
 
    assign validIn  = validSet | (valid & ~validClr);
    assign validSet = allocEn ? allocIdx : \=numEntries=\'d0;
    assign validClr = deallocEn ? (searchIdCAM & head) : \=numEntries=\'d0;
    assign validEn  = allocEn | deallocEn;
\jsbegin
    //
    // ID flops
    //
\jsend
\js for (var entry = 0; entry < numEntries; entry++) {
    \=obj.lib.dffre(width, 'entryId'+entry, 'allocId', width+"'d0", 'validSet['+entry+']', 'clk', 'reset_n')=\
\js }
\jsbegin
    //
    // ptr flops
    //
\jsend
\js for (var entry = 0; entry < numEntries; entry++) {
    \=obj.lib.dffre(numEntries, 'ptr'+entry, 'ptrIn', numEntries+"'d0", 'validSet['+entry+']', 'clk', 'reset_n')=\
\js }

    assign ptrIn = valid & tail & allocIdCAM;
\jsbegin
    // 
    // Head flops
    // 
\jsend

    \=obj.lib.dffre(numEntries, 'head', 'headIn', numEntries+"'d0", 'headEn', 'clk', 'reset_n')=\

    assign headIn         = headAllocSet| headDeallocSet | (head & ~headClr);
    assign headAllocSet   = allocEn & ~(|(valid & allocIdCAM))? allocIdx : \=numEntries=\'d0;
    assign headDeallocSet = deallocEn ? (valid & searchIdxPtrCAM) : \=numEntries=\'d0;
    assign headClr        = deallocEn ? searchIdCAM : \=numEntries=\'d0;
    assign headEn         = allocEn | deallocEn;
    assign searchIdx      = valid & head & searchIdCAM;     
\jsbegin
    //
    // Tail flops
    //
\jsend

    \=obj.lib.dffre(numEntries, 'tail', 'tailIn', numEntries+"'d0", 'tailEn', 'clk', 'reset_n')=\

    assign tailIn  = tailSet | (tail & ~tailClr);
    assign tailSet = allocEn? allocIdx: \=numEntries=\'d0;
    assign tailClr = allocEn? (valid & tail & allocIdCAM) : \=numEntries=\'d0;
    assign tailEn  = allocEn;
    
    \js if (assertOn) {
    `ifdef OVL_ASSERT_ON
    // coverge off
    // synthesis off
    // synopsys translate_off
    assert_implication #(0) assert_onehot_dealloc(
        .clk(clk),
        .reset_n(reset_n),
        .antecedent_expr(deallocEn),
        .consequent_expr($onehot(searchIdx))
    );
    assert_implication #(0) assert_onehot_alloc(
        .clk(clk),
        .reset_n(reset_n),
        .antecedent_expr(allocEn),
        .consequent_expr($onehot(allocIdx))
    );
    assert_implication #(0) assert_all_valid_no_alloc(
        .clk(clk),
        .reset_n(reset_n),
        .antecedent_expr((&valid)),
        .consequent_expr(~allocEn)
    );
    assert_implication #(0) assert_none_valid_no_dealloc(
        .clk(clk),
        .reset_n(reset_n),
        .antecedent_expr(~(|valid)),
        .consequent_expr(~deallocEn)
    );
    // synopsys translate_on
    // synthesis on
    // coverage on
    `endif
    \js }

\js }
endmodule
