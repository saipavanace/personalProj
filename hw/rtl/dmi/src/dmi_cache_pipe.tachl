//=============================================================================
// Copyright (C) 2018 Arteris, Inc.
// All rights reserved.
//=============================================================================
\jsbegin
// Dmi Cache Pipe
// Author: Steve Kromer
// 
// Track accesses that are active in the ccp pipeline.
// Input new entry when ccp accepts and track until hit/miss stage
// then keep tracking until cache data access is finished
// (hit or write full allocate)
// 
//=========================================================================

var u                   = obj.lib;
var bundleFunctions     = obj.userLib.bundleFunctions;
var wMntOpCode          = u.getParam('wMntOpCode');
var addrInterface       = u.getParam('addrInterface');
var wAddr               = u.getParam('addrInterface','addr');
var wData               = u.getParam('wData');
var cmType              = u.getParam('cmType');
var wCmType             = u.getParam('addrInterface','cm_type');
var wAddrInterface      = bundleFunctions.getBundleWidth(addrInterface, ['valid', 'ready'], u.bundle);
var nRttCtrlEntries     = u.getParam('nRttCtrlEntries');
var wRttId              = Math.ceil(Math.log2(nRttCtrlEntries));
var nWays               = u.getParam('nWays');
var wWays               = Math.ceil(Math.log2(nWays));
var wSets               = u.getParam('wSets');
var wCacheLineOffset    = u.getParam('wCacheLineOffset');
var wBeats              = u.getParam('wBeats');
var wayBase             = wCacheLineOffset + wSets;
var useScratchpad       = u.getParam('useScratchpad');
var mntOpReqInterface   = u.getParam('mntOpReqInterface');
var readOpInterface     = u.getParam('readOpInterface');
var wReadOpInterface    = bundleFunctions.getBundleWidth(readOpInterface, ['valid', 'ready'], u.bundle);
var writeOpInterface    = u.getParam('writeOpInterface');
var wWriteOpInterface   = bundleFunctions.getBundleWidth(writeOpInterface, ['valid', 'ready'], u.bundle);
var wMntOpReqInterface  = bundleFunctions.getBundleWidth(mntOpReqInterface, ['valid', 'ready'], u.bundle);

var nBeatsPerBank = u.getParam("nBeatsPerBank");
// minimum of 3, 2 would be crippling, 1 could cause lockup
// conc4240,conc4241,conc4242, needs to be at least 5 or causes overflow assert below

var DataBankSelBits     = u.getParam('DataBankSelBits');
var nDataBanks          = u.getParam('nDataBanks');
var wDataIndex          = u.getParam('wDataIndex');
var replayQueueSize     = 8;
var wRepId              = Math.ceil(Math.log2(replayQueueSize));
var wDwid               = readOpInterface.cdw;
var assertOn            = u.getParam('assertOn');
var clkInterface        = u.getParam('clkInterface');

var UseTagRamOutputFlop = u.getParam('UseTagRamOutputFlop');
var UseTagRamInputFlop = u.getParam('UseTagRamInputFlop');

var ccpOpQueueSize      = nBeatsPerBank*7+(UseTagRamOutputFlop?1:0)+(UseTagRamInputFlop?1:0);
var wOpQueueSize        = Math.ceil(Math.log2(ccpOpQueueSize+1))

var useAtomic = u.getParam("useAtomic");
//=========================================================================
// ports
//=========================================================================
u.interface('', 'slave', u.getParam('clkInterface'));

// new access
u.interface('read_addr_s_',  'slave',   addrInterface,     []);
u.interface('write_addr_s_', 'slave',   addrInterface,     []);
u.interface('',              'slave',   mntOpReqInterface, []);
u.interface('ccp_p2_',       'master',  addrInterface);

u.port('output', 'ccp_p0_valid',                1);
u.port('input',  'ccp_p0_ready',                1);
u.port('output', 'ccp_p0_addr',                 wAddr);
u.port('output', 'ccp_p0_ns',                   1);
u.port('input',  'ccp_p0_lookup_en',            1);
u.port('output', 'ccp_p1_addr',                 wAddr);
u.port('output', 'ccp_p2_lookup_en',            1);
// hit/miss stage
u.port('input',  'ccp_p2_uce_send_rd_opq',      1);
u.port('input',  'ccp_p2_uce_send_wr_opq',      1);
u.port('input',  'ccp_p2_send_opq',             1);
u.port('input',  'ccp_p2_send_miss',            1);
u.port('input',  'ccp_p2_send_p0',              1);
u.port('output',  'recycle_failed',             1);
u.port('input',  'wr_ccp_p2_drop',              1);
u.port('input',  'ccp_p2_way',                  nWays);
u.port('input',  'ccp_p2_kill_ac',              1);
u.port('input',  'ccp_p2_hit',                  1);
u.port('input',  'ccp_p2_hitdirty',             1);
u.port('input',  'new_evict',                   1);
u.port('output', 'ccp_p2_atomic',               1);
u.port('output', 'ccp_p2_atm_error',            1);
u.port('output', 'ccp_p2_mnt',                  1);
u.port('output', 'ccp_p2_mnt_op_req_msg',       wMntOpCode);
u.port('output', 'ccp_p2_mnt_op_req_way',       wWays);
u.port('output', 'ccp_p2_mnt_op_req_security',  1);
u.port('output', 'ccp_p2_mnt_op_req_addr',      wAddr);

// p1 way partitioning info
u.port('output', 'ccp_p1_aiu_trans_id', u.getParam('addrInterface', 'aiu_trans_id'));
u.port('input',  'ccp_p1_wp_way', nWays);
u.port('input',  'ccp_p1_wp_no_rsvd_way', 1);
u.port('input',  'ccp_p2_ce_nack', 1);
u.port('input',  'ccp_p2_way_fwd', 1);
u.port('input',  'ccp_p2_tag_uce', 1);
u.port('output', 'ccp_p2_ways_busy',  nWays);
u.port('output', 'ccp_p2_ways_stale', nWays);
u.port('output', 'ccp_p2_to_replay',  1);
u.port('input',  'ccp_op_scratch',    1);
u.port('output', 'pmon_cache_replay', 1);
if(useAtomic){
    u.port("input","nb_atomic",3);
}
u.port('output', 'ccp_p1_valid',      1);
u.port('output', 'read_write_addr_s_pop_ready_p1',1);

if (useScratchpad) {
u.port('input',  'scratch_addr_offset_low',  wAddr-wCacheLineOffset+1);
u.port("input","interleaving_function_type_out",5);
u.port("input","interleaving_function_id_out",3);
}
u.interface('ccp_op_',    'master', readOpInterface, []);

u.interface('read_cam_',  'master', obj.lib.getParam('camAddrInterface'));
u.port('input', 'read_cam_match_fill', 1);
u.interface('rtt_cam_',   'master', obj.lib.getParam('camRttVectorInterface'));
u.interface('write_cam_', 'master', obj.lib.getParam('camAddrInterface'));
u.interface('', 'slave', obj.lib.getParam('pipeScratchInterface'));
if (useScratchpad) {
u.interface('pipe_', 'master', obj.lib.getParam('scratchOpInterface'));
}

u.interface('rd_miss_', 'master', addrInterface, ['cm_type']);
u.port('output', 'rd_miss_cm_typeq', wCmType);
u.port('output', 'rd_miss_bus_valid', 1);
u.port('output', 'rd_miss_fill', 1);
u.interface('wr_miss_', 'master', addrInterface,        ['vz']);
u.port('output', 'wr_miss_vz_qual', 1);
u.port('output', 'wr_miss_full',    1);
u.port('output', 'wr_miss_sel',     1);


// write data
u.port('input', 'write_through',      1);
u.interface('wr_op_',   'master', writeOpInterface, []);

u.port('input', 'write_addr_s_nc_sel', 1);

u.port('input', 'read_alloc_id', wRttId);
u.port('input',  'rtt_dealloc_valid', 1);
u.port('input',  'rtt_dealloc_vec',   obj.lib.getParam('nRttCtrlEntries'));
u.port('input',  'rtt_dealloc_id',    wRttId);
u.port('input',  'rtt_lookup_id',     wRttId);
u.port('output', 'rtt_lookup_way',    nWays);
u.port('input',  'wtt_dealloc_valid', 1);
u.port('input', 'mntop_active',    1);
u.port('output', 'cache_pipe_busy', 1);
u.port('output', 'ccp_p1_aiu_id', u.getParam('addrInterface', 'aiu_id'));

u.port('output', 'scratch_p1_valid', 1);

\jsend

module \=u.getModuleName()=\ (\=u.getPorts('\n')=\);

localparam ROW_MASK  = {\=wAddr-wSets=\'b0, {\=wSets=\{1'b1}}} << \=wCacheLineOffset=\;
localparam LINE_MASK = ~(((\=wAddr=\'b1) << \=wCacheLineOffset=\)-1);

localparam RD_ATM   = \=cmType['CmdRdAtm']=\;
localparam WR_ATM   = \=cmType['CmdWrAtm']=\;
localparam CM_ATM   = \=cmType['CmdCompAtm']=\;
localparam SW_ATM   = \=cmType['CmdSwapAtm']=\;

localparam RD_WSCLN = \=cmType['MrdRdWSCln']=\;
localparam RD_WUCLN = \=cmType['MrdRdWUCln']=\;
localparam RD_WUNIQ = \=cmType['MrdRdWU']=\;
localparam RD_WINV  = \=cmType['MrdRdWInv']=\;
localparam RD_PREF  = \=cmType['MrdPref']=\;
localparam RD_CLEAN = \=cmType['MrdCln']=\;
localparam RD_INV   = \=cmType['MrdInv']=\;
localparam RD_FLUSH = \=cmType['MrdFlush']=\;
localparam HN_READ  = \=cmType['HntRead']=\;
localparam NC_CMDRD = \=cmType['CmdRdNC']=\;
localparam NC_CLEAN = \=cmType['CmdClnVld']=\;
localparam NC_PRSST = \=cmType['CmdClnShPsist']=\;
localparam NC_FLUSH = \=cmType['CmdClnInv']=\;
localparam NC_MKINV = \=cmType['CmdMkInv']=\;
localparam NC_PREF  = \=cmType['CmdPref']=\;

localparam WR_NDATA = \=cmType['DtwNullData']=\;
localparam WR_CLEAN = \=cmType['DtwDataFullCln']=\;
localparam WR_PARTL = \=cmType['DtwDataPtlDty']=\;
localparam WR_DIRTY = \=cmType['DtwDataFullDty']=\;

localparam WM_INV   = \=cmType['DtwMrgMrdInv']=\;
localparam WM_RSCLN = \=cmType['DtwMrgMrdSCln']=\;
localparam WM_RSDTY = \=cmType['DtwMrgMrdSDty']=\;
localparam WM_RUCLN = \=cmType['DtwMrgMrdUCln']=\;
localparam WM_RUDTY = \=cmType['DtwMrgMrdUDty']=\;

  function automatic is_atomic;
    input [\=wCmType-1=\:0] cm_type;
    begin
        is_atomic = (cm_type == RD_ATM) | (cm_type == WR_ATM) |
                    (cm_type == CM_ATM) | (cm_type == SW_ATM);
    end
  endfunction

  function automatic is_read;
    input [\=wCmType-1=\:0] cm_type;
    begin
        is_read = (cm_type == RD_WSCLN) | (cm_type == RD_WUCLN) |  is_cacheop(cm_type) |
                  (cm_type == RD_WUNIQ) | (cm_type == RD_WINV)  |
                  (cm_type == NC_CMDRD) | is_atomic(cm_type) | is_dtwmergemrd(cm_type);
    end
  endfunction

  function automatic is_write;
    input [\=wCmType-1=\:0] cm_type;
    begin
        is_write = (cm_type == WR_NDATA) | (cm_type == WR_CLEAN) | is_cacheop(cm_type) |
                   (cm_type == WR_PARTL) | (cm_type == WR_DIRTY) | is_dtwmergemrd(cm_type);
    end
  endfunction


  function automatic is_cacheop;
    input [\=wCmType-1=\:0] cm_type;
    begin
        is_cacheop = (cm_type == RD_PREF)  | (cm_type == NC_PREF)  | 
                     (cm_type == RD_FLUSH) | (cm_type == NC_FLUSH) |
                     (cm_type == RD_CLEAN) | (cm_type == NC_CLEAN) | (cm_type == NC_PRSST) | 
                     (cm_type == RD_INV)   | (cm_type == NC_MKINV);
    end
  endfunction

  function automatic is_cmdcacheop;
    input [\=wCmType-1=\:0] cm_type;
    begin
        is_cmdcacheop = (cm_type == NC_FLUSH) |
                        (cm_type == NC_CLEAN) | (cm_type == NC_PRSST) | 
                        (cm_type == NC_MKINV);
    end
  endfunction

  function automatic is_dtwmergemrd;
    input [\=wCmType-1=\:0] cm_type;
    begin
        is_dtwmergemrd = (cm_type == WM_INV)   |
                         /*(cm_type == WM_RSCLN) | (cm_type == WM_RSDTY) |*/
                         (cm_type == WM_RUCLN) | (cm_type == WM_RUDTY);
    end
  endfunction

\jsbegin
//=================================================================================
// Wires
//=================================================================================
\jsend
    wire wr_miss_vz;
    wire ccp_p2_drop;
    wire ccp_p2_dtwmergemrd;
    wire ccp_p0_write_nc_sel;
    wire ccp_p0_push_valid;
    wire ccp_p0_push_ready;
    wire ccp_p0_pop_valid;
    wire ccp_p0_pop_ready;
    wire new_evict_q;
//    wire [\=wMntOpReqInterface-1=\:0] mnt_ccp_p0;

    wire ccp_p0_en;
    wire [\=wAddrInterface-1=\:0] rd_ccp_p0_in;    
    wire [\=wAddrInterface-1=\:0] wr_ccp_p0_in;
    wire [\=wAddrInterface-1=\:0] rd_wr_ccp_p0_in;
    wire [\=wAddrInterface-1=\:0] rd_wr_ccp_p0;

    wire [\=wAddrInterface=\:0] ccp_p0;
    wire [\=wAddrInterface=\:0] ccp_p0_plus;
    wire [\=wAddrInterface=\:0] ccp_p1_minus;
    wire [\=wAddrInterface=\:0] ccp_p1;
    wire [\=wAddrInterface=\:0] ccp_p2;
    wire [\=wAddrInterface=\:0] ccp_p1_d;
    wire [\=wAddrInterface=\:0] ccp_p2_recycle;
    \=bundleFunctions.wiresFromInterface('ccp_p0_', addrInterface, ['valid', 'ready', 'addr', 'ns'], u.bundle)=\
    \=bundleFunctions.wiresFromInterface('ccp_p0_plus_', addrInterface,[] ,u.bundle)=\
    \=bundleFunctions.wiresFromInterface('ccp_p1_minus_', addrInterface,[] ,u.bundle)=\
    \=bundleFunctions.wiresFromInterface('ccp_p1_', addrInterface, ['addr', 'valid', 'ready', 'aiu_trans_id', 'aiu_id'], u.bundle)=\
    wire ccp_p1_conflict;
    wire ccp_p1_no_way;
    wire ccp_p1_to_replay;
    wire ccp_p1_mnt;
    wire ccp_p1_is_recycle;
    wire ccp_p1_minus_is_recycle;
    wire ccp_p1_minus_is_replay;
    wire ccp_p0_plus_is_recycle;
    wire ccp_p0_plus_is_replay;
    wire replay_valid;
    wire recycle_valid;
    wire recycle_valid_in;
    wire recycle_pend;
    wire recycle_p1;
    wire recycle_p1_fail;
    wire recycle_p1_failed_in_p1_minus;
    wire recycle_p1_minus_failed;
    wire recycle_p1_minus_failed_in_p0_plus;
    wire recycle_p0_fail;
    wire recycle_p0_plus_failed;
    wire recycle_p0_plus_failed_in_p0;
    wire [\=wAddrInterface-1=\:0] replay_cmd;
    \=bundleFunctions.wiresFromInterface('repq_cam_', obj.lib.getParam('camAddrInterface'), [], u.bundle)=\
    wire set_p0_plus_valid;
    wire set_p1_minus_valid; 
    wire p0_plus_replay_flag;
    wire ccp_p0_plus_lookup_en;
    wire read_write_addr_s_pop_ready_p0_plus;
    wire p1_minus_replay_flag_from_p0_plus;
    wire ccp_p1_minus_lookup_en;
    wire p1_minus_replay_flag;
    wire p1_replay_flag_from_p1_minus;
    wire set_p1_valid;
    wire set_p2_valid;
    wire ccp_p2_match;
    wire ccp_p2_match_rw;
    wire ccp_miss_match;
    wire ccp_p2_rdval;
    wire ccp_p2_wrval;
    wire ccp_p1_is_rd;
    wire ccp_p1_is_wr;
    wire ccp_p1_atomic;
    wire ccp_p1_pref;
    wire ccp_p1_minus_mnt;
    wire ccp_p1_minus_is_rd;
    wire ccp_p1_minus_is_wr;
    wire ccp_p1_minus_atomic;
    wire read_write_addr_s_pop_ready_p1_minus;
    wire ccp_p1_minus_pref;
    wire ccp_p2_pref;
    wire ccp_p2_cacheop;
    wire [\=wDwid-1=\:0] ccp_p2_cdw;
    wire scratch_p1_ready;
    wire [\=nWays-1=\:0] ccp_p1_ways_busy, ccp_p1_ways_busy_d;
    wire [\=nWays-1=\:0] ccp_p1_stale_way, ccp_p1_stale_way_d;
    wire ccp_p2_is_rd;
    wire ccp_p2_is_wr;
    wire ccp_p2_nc_op;
    wire missq_pref;
    wire missq_is_rd;
    wire missq_is_wr;
    wire repq_empty;
    wire repq_avail;
    wire mrg_block_wr;
    wire mrg_block_rd;
    wire mrg_block_p0;
    wire mrg_or_atm_p2;
    wire [\=wRttId-1=\:0] ccp_p2_alloc_id;
    // read address gets priority 
    // if see both read and write, then let write have next grant
    wire write_addr_sel;
    wire read_addr_next;
    wire read_addr_next_d;
    wire mnt_op_block_pipe;
    wire mnt_op_block_pipe_d;
    wire mnt_op_block_pipe_en;
    wire cache_pipe_idle;
    wire mnt_op_req_sel;
    wire [1:0] ccp_valid;
    wire [1:0] ccp_valid_d;
    wire ccp_p1_lookup_en;
    wire ccp_p1_lookup_en_d;
    wire set_p0p_scratch_v;
    wire scratch_p0p_valid,scratch_p1m_valid;
    wire ccp_p0_replay;
    wire         rd_miss_sent;
    wire         wr_miss_sent;
    wire         rd_missq;
    wire         wr_missq;
    \=bundleFunctions.wiresFromInterface('missq_', addrInterface, ['valid', 'ready'], u.bundle)=\
    wire [\=wAddrInterface-1=\:0] rd_miss;
    wire [\=wCmType-1=\:0] rd_miss_cm_type;
    wire rd_miss_acq;
    wire rd_miss_bus;
    wire rd_miss_atm_error;
    wire [\=wAddrInterface-1=\:0] wr_miss;
    \=bundleFunctions.wiresFromInterface('rd_op_', readOpInterface, ['valid', 'ready'], u.bundle)=\
    wire rd_op_push_valid;
    wire rd_op_push_ready;
    \=bundleFunctions.wiresFromInterface('sp_op_', readOpInterface, ['valid', 'ready'], u.bundle)=\
    wire sp_op_push_valid;
    wire sp_op_push_ready;
    wire wr_op_push_valid;
    wire wr_op_push_ready;
    wire wr_op_push_vz;
    wire [\=obj.lib.getParam('writeOpInterface', 'beat')-1=\:0] wr_op_push_beat;
    wire [\=wAddrInterface-1=\:0] missq;
    wire missq_en;
    wire missq_atm_error;
    wire missq_v;
    wire missq_v_d;
    wire miss_p2_v;
    wire miss_p2_d;
    wire rd_opq_avail;
    wire sp_opq_avail;
    wire wr_opq_avail;
    wire p2_save_way;
    wire [\=nWays-1=\:0] rd_miss_way;
    wire [\=nWays-1=\:0] miss_p2_way;
    wire [\=nWays-1=\:0] missq_way;
    wire miss_p2_acq;
    wire missq_acq;
    wire ccp_p2_acq;
    wire ccp_p2_bus;
    wire wr_hit;
    wire miss_p2_bus;
    wire missq_bus;
    wire [\=(nWays+3)-1=\:0] missq_way_q;
    wire [\=(nWays+3)-1=\:0] miss_p2_way_q;
    wire miss_p2_atm_error;
    wire [\=wAddrInterface-1=\:0] ccp_p2_miss_q_d;
    wire [1:0] send_miss_q;
    wire missq_sent;
    wire p2_miss_pend;
\js // hold p2 info if correctible error happens
    wire read_write_addr_s_valid;
    wire read_write_addr_s_ready;
    wire read_write_addr_s_pop_valid;
    wire read_write_addr_s_pop_ready;
   // wire read_write_addr_s_pop_ready_p0;
    wire ccp_hold_valid;
    wire ccp_hold_valid_d;
    wire ccp_hold_valid_q;
    wire ccp_p2_to_replay_unqual;
    \=u.dffre(1, 'read_addr_next',     'read_addr_next_d',    "1'b0", "1'b1",                 'clk', 'reset_n')=\ 
    \=u.dffre(1, 'mnt_op_block_pipe',   'mnt_op_block_pipe_d',  "1'b0", 'mnt_op_block_pipe_en', 'clk', 'reset_n')=\ 
    \=u.dffre(1, 'ccp_hold_valid',      'ccp_hold_valid_d',     "1'b0", "1'b1",                 'clk', 'reset_n')=\ 
    \=u.dffre(1, 'ccp_hold_valid_q',      'ccp_hold_valid',     "1'b0", "1'b1",                 'clk', 'reset_n')=\ 

    assign ccp_p2_to_replay = ccp_p2_to_replay_unqual & ~ccp_hold_valid_q;
\js // MntOp can only be served when there's no other active reuqest in pipe.
    assign cache_pipe_idle              = ~ccp_p1_valid & ~ccp_p2_valid & ~ccp_p1_minus_valid \=UseTagRamInputFlop?"& ~ccp_p0_plus_valid":""=\ & repq_empty;
    assign mnt_op_block_pipe_d          = (mnt_op_req_valid & ~mnt_op_req_ready & ~mnt_op_block_pipe);
    assign mnt_op_block_pipe_en         = (mnt_op_req_valid & ~mnt_op_req_ready & ~mnt_op_block_pipe) | (mnt_op_req_valid & mnt_op_req_ready & mnt_op_block_pipe);
    assign read_addr_next_d            = (write_addr_s_valid &  write_addr_s_ready  &  read_addr_s_valid) |
                                          (read_addr_next   &  read_addr_s_valid & ~read_addr_s_ready);
    assign write_addr_sel                = ~(read_addr_next & read_addr_s_valid)   &  write_addr_s_valid;
    assign mnt_op_req_sel               = mnt_op_req_valid & cache_pipe_idle;
    
    assign read_write_addr_s_pop_ready  = ccp_p0_en & ccp_p0_ready & ~recycle_valid & ~replay_valid & repq_avail & ~mnt_op_req_sel; 

    assign rd_ccp_p0_in                 = \=bundleFunctions.packetizeBundle('read_addr_s_',  addrInterface,    ['ready','valid'], u.bundle)=\;
    assign wr_ccp_p0_in                 = \=bundleFunctions.packetizeBundle('write_addr_s_', addrInterface,    ['ready','valid'], u.bundle)=\;
//    assign mnt_ccp_p0                   = \=bundleFunctions.packetizeBundle('',              mntOpReqInterface,['mnt_op_req_ready','mnt_op_req_valid'], u.bundle)=\; 

    assign rd_wr_ccp_p0_in              = write_addr_sel ? wr_ccp_p0_in: rd_ccp_p0_in ;

    \jsbegin
    if (UseTagRamInputFlop){
    \jsend
        \=u.dffre(1, 'read_write_addr_s_pop_ready_p0_plus',           'read_write_addr_s_pop_ready',          "1'b0", "1'b1",                 'clk', 'reset_n')=\ 
    \jsbegin
    } else {
    \jsend
        assign read_write_addr_s_pop_ready_p0_plus = read_write_addr_s_pop_ready;
    \jsbegin
    }
    if (UseTagRamOutputFlop){
    \jsend
        \=u.dffre(1, 'read_write_addr_s_pop_ready_p1_minus',           'read_write_addr_s_pop_ready_p0_plus',          "1'b0", "1'b1",                 'clk', 'reset_n')=\ 
    \jsbegin
    } else {
    \jsend
        assign read_write_addr_s_pop_ready_p1_minus = read_write_addr_s_pop_ready_p0_plus;
    \jsbegin
    }
    \jsend
    \=u.dffre(1, 'read_write_addr_s_pop_ready_p1',           'read_write_addr_s_pop_ready_p1_minus',          "1'b0", "1'b1",                 'clk', 'reset_n')=\ 


\js // bypassable FIFO to cut ccp_p0_ready
\jsbegin

var ccpP0RdWrFifoParams = {
    width           : wAddrInterface+1,
    depth           : 1,
    zerodepth       : 0,
    bypass_mode     : 1
};

var ccpP0RdWrFifoInterfaces = [];
ccpP0RdWrFifoInterfaces.push({modulePrefix: '',         localPrefix: '',        interface: clkInterface});

var ccpP0RdWrFifoPorts = {
    push_valid      : 'read_write_addr_s_valid',
    push_ready      : 'read_write_addr_s_ready',
    push_data       : '{write_addr_s_nc_sel, rd_wr_ccp_p0_in}',
    pop_valid       : 'read_write_addr_s_pop_valid',
    pop_ready       : 'read_write_addr_s_pop_ready',
    pop_data        : '{ccp_p0_write_nc_sel, rd_wr_ccp_p0}'
};

\jsend

assign read_write_addr_s_valid = read_addr_s_valid | write_addr_s_valid;
assign read_addr_s_ready =  ~write_addr_sel & read_write_addr_s_ready;
assign write_addr_s_ready = write_addr_sel & read_write_addr_s_ready;

\=obj.lib.instance({
    instanceName    : 'ccp_p0_rd_wr_fifo',
    moduleName      : 'fifo',
    params          : ccpP0RdWrFifoParams,
    interfaces      : ccpP0RdWrFifoInterfaces,
    ports           : ccpP0RdWrFifoPorts
})=\

\js //TODO: handle replay when mntOp is ongoing
\js // assume mntOp will never be replayed? seems possible?
\js // p0 arbitration


\jsbegin
//p0 logic
//In the P0 stage the request ccp_p0 presented to ccp is selected based on a priority arbitration scheme
// with the folowing priority Recycle > Replay >MntOp > lookup
// ccp_p0_en controls if a request can proceed. It checks for the folowing : 
//-there is no transaction in the miss queue
//-there is a landing spot for the transaction in the opq fifos (rd,spad,wr)
//-The request in p0 is a dtwmrgmrd and there is already one in the pipe
// P0 valid is calculated based on which request was selected (ccp_p0) 
// It also makes sure that :
// - The pipe is empty before it starts a maintenance operation
// - The replay queue has room for an extra request and there are no active maintenance operation for cache look ups.
\jsend
assign ccp_p0               =   recycle_valid ? ccp_p2_recycle :
                                replay_valid  ?     {1'b0, replay_cmd} :
                                mnt_op_req_sel ?    {1'b1, mnt_op_req_addr, mnt_op_req_security, \=wAddrInterface-wMntOpReqInterface=\'b0, mnt_op_req_way, mnt_op_req_msg} : 
                                                    {1'b0, rd_wr_ccp_p0};

assign \=bundleFunctions.packetizeBundle('ccp_p0_', addrInterface,      ['valid', 'ready'], u.bundle)=\ = ccp_p0[\=wAddrInterface-1=\:0];

assign ccp_p0_replay    = ccp_p0_valid & ccp_p0_ready & replay_valid & ~recycle_valid;

assign ccp_p0_en        = ~missq_v & ~missq_en & rd_opq_avail & wr_opq_avail & sp_opq_avail & ~mrg_block_p0;

assign ccp_p0_valid     = ccp_p0_en & (recycle_valid | replay_valid | mnt_op_req_valid & cache_pipe_idle |
                                        (~mntop_active & repq_avail & read_write_addr_s_pop_valid));
\js // set ccp_p0_en when resources are all available, maybe further optimize: accept rd when wr_missq is valid
\js // currently pipe is not accepting things if there's anything in miss_q.  

assign mnt_op_req_ready             = ccp_p0_en & ccp_p0_ready &  mnt_op_req_sel  & ~recycle_valid & ~replay_valid & repq_avail;
assign recycle_p0_fail = ccp_p2_ce_nack; 
assign set_p0_plus_valid     = ccp_p0_valid & ccp_p0_ready & ~ccp_p2_ce_nack;
\jsbegin
//p0_plus signals
//if the p0 plus exists then flops the p0 signal oherwise this stage is just a passthrough
if(UseTagRamInputFlop){
\jsend
    
    \=u.dffre(1, 'scratch_p0p_valid',          'set_p0p_scratch_v',     "1'b0"  , "1'b1", 'clk', 'reset_n')=\ 
    \=u.dffre(wAddrInterface+1, 'ccp_p0_plus',          'ccp_p0',     (wAddrInterface+1)+"'b0"  , 'set_p0_plus_valid', 'clk', 'reset_n')=\ 
    \=u.dffre(1,                'ccp_p0_plus_valid',   'set_p0_plus_valid',   "1'b0"           , "1'b1", 'clk', 'reset_n')=\ 
    \=u.dffre(1,                'ccp_p0_plus_lookup_en','ccp_p0_lookup_en',   "1'b0"            , 'set_p0_plus_valid', 'clk', 'reset_n')=\ 
    \=u.dffre(1,                'ccp_p0_plus_is_replay', "ccp_p0_replay",  "1'b0"            , 'set_p0_plus_valid', 'clk', 'reset_n')=\
    \=u.dffre(1,                 'ccp_p0_plus_is_recycle',             'recycle_valid & set_p0_plus_valid',"1'b0",  "1'b1","clk","reset_n")=\
    \=u.dffre(1,                 "recycle_p0_plus_failed_in_p0",    "recycle_p0_fail", "1'b0","set_p0_plus_valid","clk","reset_n")=\
    assign recycle_p0_plus_failed = ccp_p2_ce_nack | recycle_p0_plus_failed_in_p0;
    assign \=bundleFunctions.packetizeBundle('ccp_p0_plus_', addrInterface,      ['valid', 'ready'], u.bundle)=\ = ccp_p0_plus[\=wAddrInterface-1=\:0];
    assign p0_plus_replay_flag = recycle_valid |(missq_v | missq_en)| ccp_p2_ce_nack | ccp_p1_to_replay & ~ccp_p0_plus_is_replay | new_evict | new_evict_q;
    assign set_p1_minus_valid = ccp_p0_plus_valid;
\jsbegin   
} else {
\jsend
    assign scratch_p0p_valid = set_p0p_scratch_v;
    assign set_p1_minus_valid = set_p0_plus_valid;
    assign ccp_p0_plus_valid = set_p0_plus_valid;
    assign ccp_p0_plus = ccp_p0;
    assign p0_plus_replay_flag = 1'b0;
    assign ccp_p0_plus_lookup_en = ccp_p0_lookup_en;
    assign ccp_p0_plus_is_replay = ccp_p0_replay;
    assign ccp_p0_plus_is_recycle = recycle_valid;
    assign recycle_p0_plus_failed = recycle_p0_fail;

\jsbegin
}



//p1_minus signals
\jsend

    \=u.dffre(1, 'scratch_p1m_valid',          'scratch_p0p_valid',     "1'b0"  , "1'b1", 'clk', 'reset_n')=\ 
    \=u.dffre(wAddrInterface+1, 'ccp_p1_minus',                         'ccp_p0_plus',   (wAddrInterface+1)+"'b0",      'set_p1_minus_valid', 'clk', 'reset_n')=\ 
    \=u.dffre(1,                'p1_minus_replay_flag_from_p0_plus',    'p0_plus_replay_flag',      "1'b0",             'set_p1_minus_valid', 'clk', 'reset_n')=\ 
    \=u.dffre(1,                'ccp_p1_minus_lookup_en',               'ccp_p0_plus_lookup_en',    "1'b0",             'set_p1_minus_valid', 'clk', 'reset_n')=\ 
    \=u.dffre(1,                'ccp_p1_minus_valid',                   'set_p1_minus_valid',       "1'b0",             "1'b1", 'clk', 'reset_n')=\ 
    \=u.dffre(1,                'ccp_p1_minus_is_replay', "ccp_p0_plus_is_replay",  "1'b0"            , 'set_p1_minus_valid', 'clk', 'reset_n')=\
    \=u.dffre(1,                 'ccp_p1_minus_is_recycle',             'ccp_p0_plus_is_recycle',"1'b0"        , "1'b1","clk","reset_n")=\
    \=u.dffre(1,                 "recycle_p1_minus_failed_in_p0_plus",    "recycle_p0_plus_failed", "1'b0","set_p1_minus_valid","clk","reset_n")=\


    assign \=bundleFunctions.packetizeBundle('ccp_p1_minus_', addrInterface,      ['valid', 'ready'], u.bundle)=\ = ccp_p1_minus[\=wAddrInterface-1=\:0];
    assign ccp_p1_minus_is_rd     = is_read( ccp_p1_minus_cm_type) & ~ccp_p1_minus_mnt;
    assign ccp_p1_minus_is_wr     = (is_write(ccp_p1_minus_cm_type) | ccp_p1_minus_atomic) & ~ccp_p1_minus_mnt;
    assign ccp_p1_minus_atomic    = is_atomic(ccp_p1_minus_cm_type) & ~ccp_p1_minus_mnt;
    assign ccp_p1_minus_mnt = ccp_p1_minus[\=wAddrInterface=\];
    assign ccp_p1_minus_pref      = (ccp_p1_minus_cm_type == RD_PREF) | (ccp_p1_minus_cm_type == NC_PREF);
    assign set_p1_valid = ccp_p1_minus_valid;
    assign recycle_p1_minus_failed = ccp_p2_ce_nack | recycle_p1_minus_failed_in_p0_plus;

\jsbegin
//p1 signals

if(UseTagRamOutputFlop){
\jsend
assign p1_minus_replay_flag = (missq_v | missq_en)| p1_minus_replay_flag_from_p0_plus | ccp_p2_ce_nack | ccp_p1_to_replay & ~ccp_p1_minus_is_replay | recycle_valid | ccp_p0_plus_is_recycle | new_evict | new_evict_q ;

    \=u.dffre(1, 'scratch_p1_valid',          'scratch_p1m_valid',     "1'b0"  , "1'b1", 'clk', 'reset_n')=\ 
    \=u.dffre(wAddrInterface+1, 'ccp_p1',   'ccp_p1_minus',   (wAddrInterface+1)+"'b0", 'set_p1_valid', 'clk', 'reset_n')=\
    \=u.dffre(1, 'ccp_p1_is_rd',    'ccp_p1_minus_is_rd',   "1'b0", 'set_p1_valid', 'clk', 'reset_n')=\ 
    \=u.dffre(1, 'ccp_p1_is_wr',    'ccp_p1_minus_is_wr',   "1'b0", 'set_p1_valid', 'clk', 'reset_n')=\ 
    \=u.dffre(1, 'ccp_p1_atomic',   'ccp_p1_minus_atomic',  "1'b0", 'set_p1_valid', 'clk', 'reset_n')=\
    \=u.dffre(1, 'ccp_p1_mnt',      'ccp_p1_minus_mnt',     "1'b0", 'set_p1_valid', 'clk', 'reset_n')=\ 
    \=u.dffre(1, 'ccp_p1_lookup_en',      'ccp_p1_minus_lookup_en',     "1'b0", 'set_p1_valid', 'clk', 'reset_n')=\ 

    \=u.dffre(1, 'ccp_p1_pref',      'ccp_p1_minus_pref',     "1'b0", 'set_p1_valid', 'clk', 'reset_n')=\ 
    \=u.dffre(1, 'p1_replay_flag_from_p1_minus',   'p1_minus_replay_flag',   "1'b0", 'set_p1_valid', 'clk', 'reset_n')=\ 
    \=u.dffre(1, 'ccp_p1_valid',                   'set_p1_valid',       "1'b0",             "1'b1", 'clk', 'reset_n')=\ 
    \=u.dffre(1, 'ccp_p1_is_recycle',             'ccp_p1_minus_is_recycle',"1'b0"        , "1'b1","clk","reset_n")=\
    \=u.dffre(1,                 "recycle_p1_failed_in_p1_minus",    "recycle_p1_minus_failed", "1'b0","set_p1_valid","clk","reset_n")=\

    assign recycle_p1_fail = (ccp_p2_ce_nack | recycle_p1_failed_in_p1_minus) & ccp_p1_is_recycle;
 
assign \=bundleFunctions.packetizeBundle('ccp_p1_', addrInterface,      ['valid', 'ready'], u.bundle)=\ = ccp_p1[\=wAddrInterface-1=\:0];


\jsbegin
}else{
\jsend
    assign p1_minus_replay_flag = p1_minus_replay_flag_from_p0_plus ;
    assign scratch_p1_valid = scratch_p1m_valid ;
    assign ccp_p1_mnt = ccp_p1_minus_mnt;
    assign ccp_p1_lookup_en = ccp_p1_minus_lookup_en;
    assign ccp_p1 = ccp_p1_minus;
    assign ccp_p1_is_rd = ccp_p1_minus_is_rd;
    assign ccp_p1_is_wr = ccp_p1_minus_is_wr;
    assign ccp_p1_atomic = ccp_p1_minus_atomic;
    assign ccp_p1_pref = ccp_p1_minus_pref;
    assign p1_replay_flag_from_p1_minus = p1_minus_replay_flag;
    assign \=bundleFunctions.packetizeBundle('ccp_p1_', addrInterface,      ['valid', 'ready'], u.bundle)=\ = ccp_p1[\=wAddrInterface-1=\:0];
    assign ccp_p1_valid = set_p1_valid;
    assign ccp_p1_is_recycle = ccp_p1_minus_is_recycle ;
    assign recycle_p1_fail = recycle_p1_minus_failed & ccp_p1_minus_is_recycle;

\jsbegin
}
\jsend

    assign ccp_p1_conflict  = ccp_p1_valid & ~ccp_p1_is_recycle &
                            ( ccp_p2_match_rw | ccp_miss_match | repq_cam_match | (ccp_p2_send_p0 | recycle_valid ) | new_evict | new_evict_q |
                            (scratch_p1_valid & ~scratch_p1_ready) |
                            (ccp_p1_is_rd & write_cam_match) |
                            ccp_p1_no_way & ~ccp_p1_wp_no_rsvd_way |
                            (ccp_p1_is_rd &  read_cam_match & read_cam_match_fill) |
                            (ccp_p1_is_wr &  read_cam_match) |
                            p1_replay_flag_from_p1_minus  
                            \js if (useAtomic) {
                                | (is_atomic(ccp_p1_cm_type) & nb_atomic > 3'b010 ) 
                            \js } 
                             );
    \jsbegin
    //    assign ccp_p1_to_replay = (ccp_p1_conflict & (~ccp_p1_is_hn | (ccp_p2_send_p0 | recycle_valid))) | (ccp_p1_valid & ccp_p2_ce_nack);
    \jsend

    assign ccp_p1_to_replay = ccp_p1_conflict  | (ccp_p1_valid & ccp_p2_ce_nack  & ~ccp_p1_is_recycle);


//p2 signals
    \=u.dffre(1,                 "recycle_failed",    "recycle_p1_fail", "1'b0","1'b1","clk","reset_n")=\
    \=u.dffre(wAddrInterface+1, 'ccp_p2',   'ccp_p1_d', (wAddrInterface+1)+"'b0", 'set_p2_valid', 'clk', 'reset_n')=\
    \=u.dffre(1, 'ccp_p2_valid',   'set_p2_valid', "1'b0", "1'b1", 'clk', 'reset_n')=\
    \=u.dffre(1, 'scratch_p2_valid',          '~ccp_p1_to_replay & scratch_p1_valid',     "1'b0"  , "1'b1", 'clk', 'reset_n')=\ 

    assign \=bundleFunctions.packetizeBundle('ccp_p2_', addrInterface,      ['valid', 'ready'], u.bundle)=\ = ccp_p2[\=wAddrInterface-1=\:0];


    assign ccp_hold_valid_d = ccp_p2_ce_nack & ccp_p2_valid & ~ccp_p2_to_replay;
    assign ccp_p1_d         = ccp_hold_valid ? ccp_p2 : ccp_p1;
    assign set_p2_valid     = ccp_p1_valid & ~ccp_p1_to_replay & ~ccp_p2_ce_nack | ccp_hold_valid;
    assign ccp_p2_is_rd     = is_read(ccp_p2_cm_type)  & (~ccp_p2_cacheop | ccp_p2_pref) & ~ccp_p2_mnt;
    assign ccp_p2_is_wr     = is_write(ccp_p2_cm_type) & ~ccp_p2_pref & ~ccp_p2_mnt;

    assign ccp_p2_atomic    = is_atomic(ccp_p2_cm_type)& ~ccp_p2_mnt;
    assign ccp_p2_pref      = (ccp_p2_cm_type == RD_PREF) | (ccp_p2_cm_type == NC_PREF);
    assign ccp_p2_cacheop   = is_cacheop(ccp_p2_cm_type);

    \=u.dffre(1, 'ccp_p2_lookup_en',           'ccp_p1_lookup_en_d',          "1'b0", "1'b1",                 'clk', 'reset_n')=\ 






    assign set_p0p_scratch_v = scratch_p0_valid & ccp_p0_ready & ~ccp_p2_ce_nack;
    assign ccp_p1_lookup_en_d = ccp_hold_valid ? ccp_p2_lookup_en : ccp_p1_lookup_en;
   
    assign ccp_p1_no_way    = ((ccp_p1_atomic | ccp_p1_pref & ccp_p1_ac ) &
                              (&ccp_p1_ways_busy) & ~scratch_p1_valid & ~(&scratch_ways));
\jsbegin
    // atomic non-allocation error
    // force ac at p0 to flag this error, then see what it is in p2 to trigger response
    // write data gets dropped, non data error sent with cmd response
\jsend
    assign ccp_p2_atm_error = ccp_p2_valid & ccp_p2_atomic & ~scratch_p2_valid & (~ccp_p2_lookup_en | &scratch_ways);
    assign ccp_p2_match     = ccp_p1_valid & ccp_p2_valid & (((ccp_p1_addr ^ ccp_p2_addr) & LINE_MASK) == 0);
    assign ccp_p2_match_rw  = ccp_p2_match & ((ccp_p1_is_rd & (ccp_p2_is_wr | ccp_p2_ac | is_atomic(ccp_p2_cm_type))) |
                                              (ccp_p1_is_wr & (ccp_p2_is_rd | ~ccp_p2_hit)));


    assign ccp_p2_mnt_op_req_addr = ccp_p2_addr;
    assign ccp_p2_mnt_op_req_security = ccp_p2_ns;
    assign {ccp_p2_mnt_op_req_way, ccp_p2_mnt_op_req_msg} = ccp_p2[\=wWays+wMntOpCode-1=\:0];

    assign ccp_p2_mnt = ccp_p2[\=wAddrInterface=\]; 

    assign ccp_p2_miss_q_d = ccp_p2[\=(wAddrInterface-1)=\:0];

    \=u.dffre(wAddrInterface, 'missq', 'ccp_p2_miss_q_d', wAddrInterface+"'b0", 'missq_en', 'clk', 'reset_n')=\ 

    assign ccp_miss_match   = missq_v      & (((ccp_p1_addr ^  missq_addr) & LINE_MASK) == 0);


    assign missq_pref       = ( missq_cm_type == RD_PREF) | ( missq_cm_type == NC_PREF);
    assign missq_is_rd      = is_read(  missq_cm_type) & (~is_cacheop(missq_cm_type) | missq_pref);
    assign missq_is_wr      = is_write( missq_cm_type) & ~missq_pref & ~(missq_cm_type == WM_RUDTY);

    assign write_cam_addr = ccp_p1_addr;
    assign write_cam_ns   = ccp_p1_ns;
    assign write_cam_mask = ~LINE_MASK;
    assign read_cam_addr  = ccp_p1_addr;
    assign read_cam_ns    = ccp_p1_ns;
    assign read_cam_mask  = ~LINE_MASK;
    assign rtt_cam_addr   = ccp_p1_addr;
    assign rtt_cam_mask   = ~ROW_MASK;
    assign repq_cam_addr  = ccp_p1_addr;
    assign repq_cam_ns    = ccp_p1_ns;
    assign repq_cam_mask  = ~LINE_MASK;

    \=u.dffre(wAddrInterface+1, 'ccp_p2_recycle',   'ccp_p2',   (wAddrInterface+1)+"'b0", 'ccp_p2_send_p0', 'clk', 'reset_n')=\ 
    \=u.dffre(1, 'recycle_valid', 'recycle_valid_in', "1'b0", '1\'b1', 'clk', 'reset_n')=\ 
    \=u.dffre(1, 'recycle_pend', 'recycle_valid', "1'b0", '1\'b1', 'clk', 'reset_n')=\ 

    assign recycle_valid_in = ccp_p2_send_p0 | ((recycle_valid & ~ccp_p0_ready));
    assign recycle_p1    = recycle_pend & ccp_p1_valid;

    assign rd_miss_sent  = (rd_miss_valid & rd_miss_ready);
    assign wr_miss_sent  = (wr_miss_valid & wr_miss_ready);
    assign missq_sent    = ( rd_missq & rd_miss_sent) | ( wr_missq & wr_miss_sent);
    assign p2_miss_pend  = (ccp_p2_rdval & ~(ccp_p2_pref & ccp_p2_kill_ac) & (rd_missq | ~rd_miss_ready)) |
                           (ccp_p2_wrval & (wr_missq | ~wr_miss_ready));

    assign rd_miss       = rd_missq ? missq : ccp_p2[\=wAddrInterface-1=\:0];
    assign wr_miss       = wr_missq ? missq : ccp_p2[\=wAddrInterface-1=\:0];

    assign rd_miss_valid = ~mrg_block_rd & (rd_missq | ccp_p2_rdval & ~(ccp_p2_pref & ccp_p2_kill_ac));
    assign wr_miss_valid = ~mrg_block_wr & (wr_missq | ccp_p2_wrval);
\jsbegin
    // select the write miss address instead of the evict address if there is any valid write waiting for WTT accept
    \jsend
    assign wr_miss_sel   = (wr_missq | ccp_p2_wrval);


    assign rd_missq      = missq_v & missq_is_rd;
    assign wr_missq      = missq_v & missq_is_wr;

    assign \=bundleFunctions.packetizeBundle('rd_miss_', addrInterface, ['valid', 'ready'], u.bundle)=\ = rd_miss;
    assign rd_miss_cm_typeq  = rd_miss_atm_error ? RD_ATM : rd_miss_cm_type;
    assign rd_miss_bus_valid = rd_miss_valid & rd_miss_bus;
\js // fill bit means we are going to see data on the fill port
    assign rd_miss_fill      = rd_miss_acq;
    assign \=bundleFunctions.packetizeBundle('wr_miss_', addrInterface, ['valid', 'ready'], u.bundle)=\ = wr_miss;
    assign \=bundleFunctions.packetizeBundle('missq_',   addrInterface, ['valid', 'ready'], u.bundle)=\ = missq;

    assign {miss_p2_v, missq_v} = send_miss_q;

    \=u.dffre(2, 'send_miss_q', '{miss_p2_d, missq_v_d}', "2'b0", '1\'b1', 'clk', 'reset_n')=\ 

    assign missq_v_d   = missq_v ? ~missq_sent : p2_miss_pend;
    assign miss_p2_d   = (ccp_p2_send_miss | miss_p2_v) & p2_miss_pend & missq_v;
    assign missq_en    = ~missq_v & p2_miss_pend;

    \=u.dffre((nWays+3), 'missq_way_q',    '{rd_miss_acq, rd_miss_way, rd_miss_bus, rd_miss_atm_error}', (nWays+3)+"'b0", 'missq_en',      'clk', 'reset_n')=\ 
    \=u.dffre((nWays+3), 'miss_p2_way_q',  '{ccp_p2_acq, ccp_p2_way, ccp_p2_bus, ccp_p2_atm_error}',     (nWays+3)+"'b0", 'p2_save_way',   'clk', 'reset_n')=\

    assign {missq_acq, missq_way, missq_bus, missq_atm_error} = missq_way_q;
    assign {miss_p2_acq, miss_p2_way, miss_p2_bus, miss_p2_atm_error} = miss_p2_way_q;

    assign p2_save_way = ccp_p2_send_miss & ~missq_en & ccp_p2_valid;
    assign rd_miss_way = rd_missq ? missq_way : (ccp_p2_valid ? ccp_p2_way : miss_p2_way);
    assign rd_miss_acq = rd_missq ? missq_acq : (ccp_p2_valid ? ccp_p2_acq : miss_p2_acq);
    assign rd_miss_bus = rd_missq ? missq_bus : (ccp_p2_valid ? ccp_p2_bus : miss_p2_bus);
    assign wr_hit      =~(wr_missq? missq_bus : (ccp_p2_valid ? ccp_p2_bus : miss_p2_bus));
    assign ccp_p2_acq  = (ccp_p2_ac & ~ccp_p2_kill_ac);
    assign ccp_p2_bus  = ~ccp_p2_hit;
    assign rd_miss_atm_error = rd_missq ? missq_atm_error : (ccp_p2_valid ? ccp_p2_atm_error : miss_p2_atm_error);
    assign ccp_p2_rdval = ((ccp_p2_valid & ccp_p2_send_miss) | miss_p2_v) & ccp_p2_is_rd;
    assign ccp_p2_wrval = ((ccp_p2_valid & ccp_p2_send_miss) | miss_p2_v) & ccp_p2_is_wr & ~(is_dtwmergemrd(ccp_p2_cm_type) & rd_miss_acq) & ~(ccp_p2_cm_type == WM_RUDTY);
\jsbegin
    // dtwmergemrd is complicated in that miss requires a read, but may not require a write.
    // Miss allocate will not need a write because it's managed by the merge buffer, 
    // but miss no allocate requires an AXI write. To prevent multiple corner cases when
    // need a write, force the read and write to go out the same time when both are ready.

    // if the wr_miss is mrg, block it if  
    // 1. non-dtwmrg rd_miss ahead or
    // 2. mrg allocating (suppress write to AXI)  or 
    // 3. rd_miss is not ready
\jsend
    assign mrg_block_wr =  is_dtwmergemrd(wr_miss_cm_type) &
                         ((rd_missq | ccp_p2_rdval ) & ~is_dtwmergemrd(rd_miss_cm_type) |  rd_miss_acq | ~rd_miss_ready);
\jsbegin
    // if the rd_miss is mrg, block it if  
    // 1. non-dtwmrg wr_miss & a write required (not WM_UDTY & not acq) ahead or
    // 2. mrg is not allocating and not type MrgDdty (implies a write to AXI) and wr_miss is not ready
\jsend
    assign mrg_block_rd =  is_dtwmergemrd(rd_miss_cm_type) &
                         (((wr_missq | ccp_p2_wrval) & ~is_dtwmergemrd(wr_miss_cm_type) | ~wr_miss_ready) & (~rd_miss_acq & ~(rd_miss_cm_type == WM_RUDTY))); 

    assign mrg_block_p0 =   is_dtwmergemrd(ccp_p0_cm_type) & 
                            (   \jsbegin
                                if(UseTagRamInputFlop){
                                \jsend
                                    (is_dtwmergemrd(ccp_p0_plus_cm_type) & ccp_p0_plus_valid )|
                                \jsbegin
                                }
                                if(UseTagRamOutputFlop){
                                \jsend
                                        (is_dtwmergemrd(ccp_p1_minus_cm_type) & ccp_p1_minus_valid) |
                                \jsbegin
                                }
                                \jsend
                                (is_dtwmergemrd(ccp_p1_cm_type) & ccp_p1_valid) |
                                (is_dtwmergemrd(ccp_p2_cm_type) & ccp_p2_valid)
                                );

   \js // vz bit for dtwmergmrd means late response for read portion only
    assign wr_miss_vz_qual = ~is_dtwmergemrd(wr_miss_cm_type) & wr_miss_vz;

  \js  // force full size for mrd evicts and write through
    assign wr_miss_full    = wr_hit & (is_cacheop(wr_miss_cm_type) | (wr_miss_vz & (wr_miss_cm_type == WR_DIRTY) | (wr_miss_cm_type == WR_PARTL)));

   \js //
    \js// CCP Op Queue
   \js //
    wire rd_op_valid;
    wire rd_op_ready;

    \=u.instance({
        instanceName: 'rd_opq',
        moduleName: 'fifo',
        params: {
            width: wReadOpInterface,
            depth: ccpOpQueueSize,
            zerodepth: 0,
            bypass_mode: 0
        },
        interfaces: [{ modulePrefix: '', localPrefix: '', interface: u.getParam('clkInterface') }],
        ports: {
            push_valid: 'rd_op_push_valid',
            push_ready: 'rd_op_push_ready',
            push_data:  bundleFunctions.packetizeBundle('ccp_p2_', readOpInterface, ['ready','valid'], obj.lib.bundle),
            pop_valid:  'rd_op_valid',
            pop_ready:  'rd_op_ready', 
            pop_data:   bundleFunctions.packetizeBundle('rd_op_', readOpInterface, ['ready','valid'], obj.lib.bundle)
        },
        portsDelimiter: '\n        '
    })=\
    assign rd_op_ready      = ccp_op_ready & ~ccp_op_scratch;
    assign ccp_p2_cdw       = ccp_p2_addr[\=wCacheLineOffset-1=\:\=wCacheLineOffset-wDwid=\];

    assign ccp_p2_alloc_id = read_alloc_id;

    assign mrg_or_atm_p2    = is_dtwmergemrd(ccp_p2_cm_type) | ccp_p2_atomic;
    assign rd_op_push_valid = (ccp_p2_send_opq & ~scratch_p2_valid & (mrg_or_atm_p2 ? ccp_p2_hit : ccp_p2_is_rd) & ~ccp_p2_cacheop) | ccp_p2_uce_send_rd_opq & ~ccp_p2_to_replay;

 \js   // Track number of entries in opq to prevent overflow
  \js  // May not be needed if opq is appropriately sized
    wire [\=wOpQueueSize-1=\:0] rd_opq_size;
    wire [\=wOpQueueSize-1=\:0] rd_opq_size_next;
    wire rd_opq_size_chg;

    \=u.dffre(wOpQueueSize, 'rd_opq_size', 'rd_opq_size_next', wOpQueueSize+"'b0", 'rd_opq_size_chg', 'clk', 'reset_n')=\ 

    assign rd_opq_avail     = rd_opq_size <  \=wOpQueueSize=\'d\=ccpOpQueueSize-2-(UseTagRamOutputFlop?1:0)-(UseTagRamInputFlop?1:0)=\;
    assign rd_opq_size_chg  = rd_op_push_valid ^  rd_op_ready;
    assign rd_opq_size_next = (rd_op_push_valid & rd_opq_size_chg) ? (rd_opq_size + 1'b1)  :
                              (rd_op_ready      & rd_opq_size_chg) ? (rd_opq_size - 1'b1)  :
                                                                      rd_opq_size;

    wire [\=wOpQueueSize-1=\:0] wr_opq_size;
    wire [\=wOpQueueSize-1=\:0] wr_opq_size_next;
    wire wr_opq_size_chg;

    \=u.dffre(wOpQueueSize, 'wr_opq_size', 'wr_opq_size_next', wOpQueueSize+"'b0", 'wr_opq_size_chg', 'clk', 'reset_n')=\ 

   \js // quicker signal to make timing
    assign wr_opq_avail     = wr_opq_size < \=wOpQueueSize=\'d\=ccpOpQueueSize-2-(UseTagRamOutputFlop?1:0)-(UseTagRamInputFlop?1:0)=\ ;

    assign wr_opq_size_chg  = wr_op_push_valid ^ wr_op_ready;
    assign wr_opq_size_next = (wr_op_push_valid & wr_opq_size_chg) ? (wr_opq_size + 1'b1)  :
                              (wr_op_ready      & wr_opq_size_chg) ? (wr_opq_size - 1'b1)  :
                                                                      wr_opq_size;
    
    \js// atomics are pushed on wr_op because that's how write data gets steered to atomic engine
    assign wr_op_push_valid = ccp_p2_send_opq & (ccp_p2_is_wr | ccp_p2_atomic | ccp_p2_cacheop) | ccp_p2_uce_send_wr_opq & ~ccp_p2_to_replay;
    assign wr_op_push_beat  = ccp_p2_addr[\=wCacheLineOffset-1=\:\=wCacheLineOffset - wBeats=\];

    // if bypass, then clear vz so don't issue response when done in ccp, issue reponse later
    assign wr_op_push_vz = ccp_p2_vz & ~ccp_p2_send_miss;

    assign ccp_p2_nc_op  = is_cmdcacheop(ccp_p2_cm_type);

    \js// This queue holds writes to track data going in to ccp.
    \=u.instance({
        instanceName: 'wr_opq',
        moduleName: 'fifo_bundle',
        params: {
            width: wWriteOpInterface,
            depth: ccpOpQueueSize,
            zerodepth: 0,
            bypass_mode: 0,
            interface: writeOpInterface
        },
        interfaces: [{ modulePrefix: '',        localPrefix: '',        interface: u.getParam('clkInterface') },
                     { modulePrefix: 'push_',   localPrefix: 'ccp_p2_', interface: writeOpInterface, exclude:['valid','vz', 'ready', 'beat', 'scratch', 'through', 'bypass']},
                     { modulePrefix: 'pop_',    localPrefix: 'wr_op_',  interface: writeOpInterface}
        ],
        ports: {
            push_valid: 'wr_op_push_valid',
            push_ready: 'wr_op_push_ready',
            push_drop:  'wr_ccp_p2_drop',
            push_through: 'write_through',
            push_bypass: '~ccp_p2_lookup_en & ~scratch_p2_valid',
            push_scratch: 'scratch_p2_valid',
            push_beat:  'wr_op_push_beat',
            push_vz:    'wr_op_push_vz'
        },
        portsDelimiter: '\n        '
    })=\

    assign ccp_p2_dtwmergemrd = is_dtwmergemrd(ccp_p2_cm_type);
    assign ccp_p2_drop        = wr_ccp_p2_drop | ccp_p2_atm_error;
\jsbegin
    //
    // Scratchpad Control
    //
\jsend
\js if (useScratchpad) {
    wire sp_op_valid, sp_op_ready;
    wire [\=wAddr-1=\:0] ccp_p1_addr_out;

    \js if (DataBankSelBits.length > 0) {
    wire [\=DataBankSelBits.length-1=\:0] scratch_bank_sel;
    \js }

    \js if (DataBankSelBits.length > 0) {
    assign scratch_bank_sel                 = ccp_p1_addr_out[\=DataBankSelBits.length+wDataIndex+wCacheLineOffset-1=\:\=wDataIndex+wCacheLineOffset=\];
    assign pipe_scratch_op_bank_sel_onehot  = \=nDataBanks=\'b1 << scratch_bank_sel;
    \js } else {
    assign pipe_scratch_op_bank_sel_onehot  = 1'b1;
    \js }

    assign scratch_p1_ready            = pipe_scratch_op_ready;
    assign pipe_scratch_op_valid       = scratch_p1_valid & ~ccp_p1_conflict & ~(ccp_p1_cm_type==WR_CLEAN) & ~is_cacheop(ccp_p1_cm_type) & ~ccp_p2_ce_nack;
\js//    assign pipe_scratch_op_way_num     = ccp_p1_addr[\=wayBase+wWays-1=\:\=wayBase=\];

    wire [\=wAddr-wCacheLineOffset=\:0] scratch_addr_offset;
    wire [\=wAddr-wCacheLineOffset=\:0] scratch_addr_offset_shifted;
    wire [\=wAddr-wCacheLineOffset+1=\:0] scratch_addr_offset_minus;
    \js  var InterleaveInfo= obj.lib.getParam("InterleaveInfo");

    \=obj.lib.instance( {       
        instanceName: 'dmi_spad_addr_bit_sel',
        moduleName: 'dmi_spad_addr_bit_sel',
        params: {InterleaveInfo: u.getParam("InterleaveInfo"), wAddr : wAddr}  ,
        verilogParams: {},
        ports: {Addr_in : "ccp_p1_addr",
                Addr_out : "ccp_p1_addr_out",
                interleaving_function_type : "interleaving_function_type_out",
                interleaving_function_id : "interleaving_function_id_out"
       },
        interfaces: [],
        portsDelimiter: '\n        '
})=\

    assign scratch_addr_offset         = {ccp_p1_ns, ccp_p1_addr_out[\=wAddr-1=\:\=wCacheLineOffset=\]};
    assign scratch_addr_offset_minus   = {1'b0, scratch_addr_offset} - {1'b0, scratch_addr_offset_low};
    assign scratch_addr_offset_shifted = scratch_addr_offset_minus[\=wAddr-wCacheLineOffset=\:0] >> \=wAddr-wCacheLineOffset+1=\'d\=wSets=\; 
    assign pipe_scratch_op_way_num     = scratch_addr_offset_shifted[\=wWays-1=\:0]; 

    assign pipe_scratch_op_index_addr  = ccp_p1_addr_out[\=wDataIndex+wCacheLineOffset-1=\:\=wCacheLineOffset=\];
    assign pipe_scratch_op_beat_num    = ccp_p1_addr_out[\=wCacheLineOffset-1=\:\=wCacheLineOffset-wBeats=\];
    assign pipe_scratch_op_read_data   = ccp_p1_is_rd | is_dtwmergemrd(ccp_p1_cm_type);
    assign pipe_scratch_op_write_data  = ccp_p1_is_wr & ~ccp_p1_atomic;

    wire   scratch_axi_wrap;
    assign scratch_axi_wrap           = is_dtwmergemrd(ccp_p1_cm_type) & 
                                        (ccp_p1_size < \=addrInterface.size=\ 'd\=wCacheLineOffset=\) &
                                       |(ccp_p1_addr[\=wCacheLineOffset-1=\:0] & ({\=wCacheLineOffset=\{1'b1}} << \=wCacheLineOffset=\'d\=wCacheLineOffset-wBeats=\) &
                                        ((\=wCacheLineOffset=\'b1 << ccp_p1_size) - 1'b1));

    wire [\=wBeats-1=\:0] burst_len;
    assign burst_len                  = (ccp_p1_size == \=wCacheLineOffset=\) ? {\=wBeats=\{1'b1}} :
                                        (ccp_p1_size >  \=Math.log2(wData/8)=\) ? (\=wBeats=\'b1 << (ccp_p1_size - \=Math.log2(wData/8)=\) - \=wBeats=\'b1)
                                                           : \=wBeats=\'b0;
    assign pipe_scratch_op_burst_len  = scratch_axi_wrap ? ~\=wBeats=\'b0 :
                                       (ccp_p1_cm_type == CM_ATM) ? burst_len >> \=wBeats=\'b1
                                                                  : burst_len;

    assign pipe_scratch_op_write_full = (ccp_p1_cm_type == WR_CLEAN) | (ccp_p1_cm_type == WR_DIRTY);
\js // ccp_p2_tag_uce should never happen for a scratchpad access 
    \=u.instance({
        instanceName: 'sp_opq',
        moduleName: 'fifo',
        params: {
            width: wReadOpInterface,
            depth: ccpOpQueueSize,
            zerodepth: 0,
            bypass_mode: 0
        },
        interfaces: [{ modulePrefix: '', localPrefix: '', interface: u.getParam('clkInterface') }],
        ports: {
            push_valid: 'sp_op_push_valid',
            push_ready: 'sp_op_push_ready',
            push_data:  bundleFunctions.packetizeBundle('ccp_p2_', readOpInterface, ['ready','valid'], obj.lib.bundle),
            pop_valid:  'sp_op_valid',
            pop_ready:  'sp_op_ready', 
            pop_data:   bundleFunctions.packetizeBundle('sp_op_', readOpInterface, ['ready','valid'], obj.lib.bundle)
        },
        portsDelimiter: '\n        '
    })=\
    assign sp_op_ready      = ccp_op_ready &  ccp_op_scratch;
    assign scratch_rd_req   = sp_op_valid;

    assign sp_op_push_valid = ccp_p2_send_opq & scratch_p2_valid & (mrg_or_atm_p2 ? ccp_p2_hit : ccp_p2_is_rd) & ~ccp_p2_cacheop;

\js    // Track number of entries in opq to prevent overflow
\js    // May not be needed if opq is appropriately sized
    wire [\=wOpQueueSize-1=\:0] sp_opq_size;
    wire [\=wOpQueueSize-1=\:0] sp_opq_size_next;
    wire sp_opq_size_chg;

    \=u.dffre(wOpQueueSize, 'sp_opq_size', 'sp_opq_size_next', wOpQueueSize+"'b0", 'sp_opq_size_chg', 'clk', 'reset_n')=\ 

    assign sp_opq_avail     = sp_opq_size < \=wOpQueueSize=\'d\=ccpOpQueueSize-2-(UseTagRamOutputFlop?1:0)-(UseTagRamInputFlop?1:0)=\ ;
    assign sp_opq_size_chg  =  sp_op_push_valid ^ sp_op_ready;
    assign sp_opq_size_next = (sp_op_push_valid & sp_opq_size_chg) ? (sp_opq_size + 1'b1)  :
                              (sp_op_ready      & sp_opq_size_chg) ? (sp_opq_size - 1'b1)  :
                                                                      sp_opq_size;

    assign \=bundleFunctions.packetizeBundle('ccp_op_', readOpInterface, ['ready'], obj.lib.bundle)=\ =
           ccp_op_scratch ? \=bundleFunctions.packetizeBundle('sp_op_', readOpInterface, ['ready'], obj.lib.bundle)=\ 
                          : \=bundleFunctions.packetizeBundle('rd_op_', readOpInterface, ['ready'], obj.lib.bundle)=\;

\js } else {
    assign scratch_p1_ready           = 1'b1;
    assign sp_opq_avail               = 1'b1;

    assign sp_op_push_valid           = 1'b0;
    assign sp_op_push_ready           = 1'b0;
    assign scratch_rd_req             = 1'b0;

    assign \=bundleFunctions.packetizeBundle('ccp_op_', readOpInterface, ['ready'], obj.lib.bundle)=\ =
                            \=bundleFunctions.packetizeBundle('rd_op_', readOpInterface, ['ready'], obj.lib.bundle)=\;
\js }
\jsbegin
    //
    // Replay Queue
    //
 \jsend
    \=obj.lib.instance({
        instanceName: 'replay_queue',
        moduleName: 'dmi_replay_queue',
        params: {
            UseTagRamInputFlop : UseTagRamInputFlop,
            UseTagRamOutputFlop : UseTagRamOutputFlop,
            clkInterface:     obj.lib.getParam('clkInterface'),
            addrInterface:    addrInterface,
            camAddrInterface: obj.lib.getParam('camAddrInterface')},
        interfaces: [{modulePrefix: '', localPrefix: '', interface: obj.lib.getParam('clkInterface')},
                     {modulePrefix: 'repq_cam_', localPrefix: 'repq_cam_', interface: obj.lib.getParam('camAddrInterface')}],
        ports: {
                 ccp_p0_replay:     'ccp_p0_replay',
                 ccp_p1:            'ccp_p1['+(wAddrInterface-1)+':0]',
                 ccp_p1_to_replay:  'ccp_p1_to_replay',
                 ccp_p1_wait_rd:    'read_cam_match',
                 ccp_p1_wait_wr:    'write_cam_match',
                 rtt_dealloc_valid: 'rtt_dealloc_valid',
                 wtt_dealloc_valid: 'wtt_dealloc_valid',
                 repq_avail:        'repq_avail',
                 repq_empty:        'repq_empty',
                 replay_valid:      'replay_valid',
                 replay_cmd:        'replay_cmd',
                 ccp_p2_to_replay:  'ccp_p2_to_replay_unqual'}
    })=\

    wire pmon_cache_replay_in;
    assign pmon_cache_replay_in = ccp_p1_to_replay && ccp_p1_valid;
     \=u.dffre(1, 'pmon_cache_replay', 'pmon_cache_replay_in', "1'b0", "1'b1", 'clk', 'reset_n')=\   


  \js  // Tracking outstanding ways
    wire [\=nRttCtrlEntries-1=\:0] save_way_en;
    assign save_way_en     = (rd_miss_valid & rd_miss_ready) ? (\=nRttCtrlEntries=\'b1  << read_alloc_id)   : \=nRttCtrlEntries=\'d0;

 \js   // Row Match Entries
\js for (var entry = 0; entry < nRttCtrlEntries; entry++) {
    wire [\=nWays-1=\:0] rtt\=entry=\way;
    \=u.dffre(nWays, 'rtt'+entry+'way', 'rd_miss_way', nWays+"'b0", 'save_way_en['+entry+']', 'clk', 'reset_n')=\ 
\js }

    wire [\=nRttCtrlEntries-1=\:0] rtt_lookup_id_match_vec; 
    \jsbegin
    var waylookup_ports = {};
    for (var i = 0; i < nRttCtrlEntries; i++) { 
         waylookup_ports['in'+i] = "rtt"+i+"way";
    }
    waylookup_ports['sel']   = "rtt_lookup_id_match_vec";
    waylookup_ports['out']   = "rtt_lookup_way";

    for (var i = 0; i < nRttCtrlEntries; i++) { \jsend
    assign rtt_lookup_id_match_vec[\=i=\] = (rtt_lookup_id == \=wRttId=\'d\=i=\);
    \jsbegin
    } \jsend
\=u.instance({
        instanceName: 'u_waylookup',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : nRttCtrlEntries,
                        wMux             : nWays
        },
        verilogParams: {},
        ports: waylookup_ports
})=\
    
\js //TODO: move some of the logics(ccp_p2_way_fwd, scratch_ways)to p2 if timing cannot be met
    
    assign ccp_p1_ways_busy = (rtt_cam_match[\=0=\] ? rtt\=0=\way : \=nWays=\'b0)
\js for (var i = 1; i < nRttCtrlEntries; i++) {
                            | (rtt_cam_match[\=i=\] ? rtt\=i=\way : \=nWays=\'b0)
\js }
                            | (ccp_p2_way_fwd ? ccp_p2_way : \=nWays=\'b0)
                            | scratch_ways
                            | (ccp_p1_mnt? \=nWays=\'b0 : ~ccp_p1_wp_way);


    \=u.dffre(nWays, 'ccp_p2_ways_busy', 'ccp_p1_ways_busy_d', nWays+"'b0", 'set_p2_valid', 'clk', 'reset_n')=\ 

    assign ccp_p1_ways_busy_d = ccp_hold_valid ? ccp_p2_ways_busy : ccp_p1_ways_busy;

\js // this should exclude WP csrs, hit entry in rtt (possible for atomic).

    assign ccp_p1_stale_way = (rtt_cam_match[\=0=\] & rtt_cam_bus[\=0=\] ? rtt\=0=\way : \=nWays=\'d0)
\js for (var i = 1; i < nRttCtrlEntries; i++) {
                            | (rtt_cam_match[\=i=\] & rtt_cam_bus[\=i=\] ? rtt\=i=\way : \=nWays=\'d0)
\js }
                            | (ccp_p2_way_fwd ? ccp_p2_way : \=nWays=\'d0)
                            | scratch_ways;

    \=u.dffre(nWays, 'ccp_p2_ways_stale', 'ccp_p1_stale_way_d', nWays+"'d0", 'set_p2_valid', 'clk', 'reset_n')=\ 

    assign ccp_p1_stale_way_d = ccp_hold_valid ? ccp_p2_ways_stale : ccp_p1_stale_way;
\jsbegin
    // ways stale is the same for DMI
    // Stale ways are used to suppress the hit for stale tags.
    // may lose some performance cause losing read hit (? why, request in
    // flight is going to write to the same index/way, eviction has already
    // happened so no hit should happen)
    
    // cache pipe busy
\jsend
    assign cache_pipe_busy = rd_op_valid |
                             wr_op_valid |
\js if(useScratchpad){
                             sp_op_valid |
\js }
                             ccp_p1_valid|
                             ccp_p2_valid|
                            ~repq_empty;
                             
    \=obj.lib.dffre(1, 'new_evict_q', 'new_evict', "1'b0", "1'b1", 'clk', 'reset_n')=\
\jsbegin
//=============================================================================
// Assertions
//=============================================================================
\jsend
\js if ( assertOn ) {
    `ifdef OVL_ASSERT_ON
    // coverage off
    // synthesis off
    // synopsys translate_off
    // should never send to opq if full (means opq undersized)
    assert_implication #(0) assert_rd_opq_overflow(
        .clk(clk),
        .reset_n(reset_n),
        .antecedent_expr(rd_op_push_valid),
        .consequent_expr(rd_op_push_ready)
    );
    assert_implication #(0) assert_sp_opq_overflow(
        .clk(clk),
        .reset_n(reset_n),
        .antecedent_expr(sp_op_push_valid),
        .consequent_expr(sp_op_push_ready)
    );
    assert_implication #(0) assert_wr_opq_overflow(
        .clk(clk),
        .reset_n(reset_n),
        .antecedent_expr(wr_op_push_valid),
        .consequent_expr(wr_op_push_ready)
    );
    assert_implication #(0) assert_replay_and_not_replay(
        .clk(clk),
        .reset_n(reset_n),
        .antecedent_expr(ccp_p2_to_replay),
        .consequent_expr(~(ccp_p2_send_opq | ccp_p2_send_miss))
    );
    // recycle not accepted on p0 but tries to save new recycle transaction
    assert_implication #(0) assert_recycle_not_seen(
        .clk(clk),
        .reset_n(reset_n),
        .antecedent_expr(recycle_valid & ~ccp_p0_ready),
        .consequent_expr(~ccp_p2_send_p0)
    );
    // synopsys translate_on
    // synthesis on
    // coverage on
    `endif
\js }
endmodule

