\jsbegin
//=============================================================================
// Copyright(C) 2020 Arteris, Inc.
// All rights reserved
//=============================================================================
// DMI Write Data FIFO
// Author: Tso-Wei Chang
// Description: 
//=============================================================================

//=============================================================================
// Variables
//=============================================================================
var u                   = obj.lib;
var m                   = obj.userLib;
var bundleFunctions     = obj.userLib.bundleFunctions;
var log2ceil            = function(n) { return Math.ceil(Math.log(n)/Math.LN2); };
var clkInterface        = u.getParam('clkInterface');
var memoryInterface     = u.getParam('memoryInterface');
var dataReqInterface    = u.getParam('dataReqInterface');
var depth               = u.getParam('depth');
var wIndex              = log2ceil(depth);
var memParam            = u.getParam('memParam');
var memGen              = u.getParam('memGen');
var memType             = memGen.MemType;
var protType            = u.getParam('memProtType');
var assertOn            = u.getParam('assertOn');
var nPorts              = u.getParam('nPorts');
var nBanks              = u.getParam('nBanks');
var wBanks              = log2ceil(nBanks);
var nBeats              = u.getParam('nBeats');
var width               = u.getParam('width');
var addr_w              = log2ceil(depth / nBanks);
var wEcc                = (protType === 'SECDED') ? m.getEccWidth(width+memParam.sramAddressProtectionWidth) : (protType === 'PARITYENTRY')? 1 : 0;
var widthWithEcc        = memParam.width;
var memEccBlocks        = memParam.eccBlocks;
var memPrefix           = memGen.rtlPrefixString;
var fastRead            = u.getParam('fastRead');
//=============================================================================
// Interfaces & Ports
//=============================================================================
u.interface('',                   'slave',          clkInterface);
u.interface('data_req_in_',       'slave',          dataReqInterface);
u.interface('data_req_out_',      'master',         dataReqInterface);
//var reqDataInfo = 
//{
//     be      : dataReqInterface.be,
//     dwid    : dataReqInterface.dwid,
//     user    : dataReqInterface.user,
//     dbad    : dataReqInterface.dbad,
//     last    : 1
// }
// var reqHeader = {};
// Object.keys(dataReqInterface).forEach(function (signal) {
//     if ((!(signal in reqDataInfo) && (signal !== 'data') && (signal !== 'valid') && (signal !== 'ready'))) {
//         reqHeader[signal] = dataReqInterface[signal];
//     }
// });
// var wHeader = bundleFunctions.getBundleWidth(reqHeader, [], obj.lib.bundle) 
// var wDataInfo = bundleFunctions.getBundleWidth(reqDataInfo, [], obj.lib.bundle)

u.port('input', 'rd_ptr',                   wIndex+1);
u.port('input',"rd_en",                   1);
u.port('input','wr_ptr',                   wIndex+1);
u.port('input',"wr_en",                      1);
u.port('output', 'read_ready',              1);
u.port('output',"rd_wr_bank_conflict",      1);



if ( memType !== 'NONE' ) {
u.interface('',                   'master',         memoryInterface);
}

if ( protType !== 'NONE' ) {
u.port('output', 'mem_uce_valid',                   1);
u.port('output', 'mem_uce_index',                   wIndex);
}

if ( protType === 'SECDED' ) {
u.port('output', 'mem_ce_valid',                    1);
u.port('output', 'mem_ce_index',                    wIndex);            
}

u.port('input', 'csr_CECR_ErrDetEn',      1);
u.port('input', 'csr_UEDR_MemErrDetEn',   1);

u.port('output', 'active',   1);

\jsend

module \=obj.lib.getModuleName()=\ (\=obj.lib.getPorts('\n')=\);

\jsbegin
//=============================================================================
// Wires
//=============================================================================
\jsend
wire [\=width-1=\:0] write_data_pkt; 
wire [\=width-1=\:0] read_data_pkt; 
wire [\=width-1=\:0] mem_ce_data_pkt;

wire [\=width-1=\:0] mem_data_pkt;
wire [\=width-1=\:0] mem_data_pkt_d1;
\=bundleFunctions.wiresFromInterface('data_req_out_int_',     dataReqInterface, ['valid', 'ready'],  obj.lib.bundle)=\


\js for (var i = 0 ; i < nBanks ; i++) {
wire [\=addr_w-1=\:0] data_bank_\=i=\_address;
wire data_bank_\=i=\_chip_en;
wire data_bank_\=i=\_write_en;
wire [\=width-1=\:0] data_bank_\=i=\_data_in;
wire [\=width-1=\:0] data_bank_\=i=\_data_out;
\js }

assign write_data_pkt = \=bundleFunctions.packetizeBundle('data_req_in_', dataReqInterface, ['valid', 'ready'], obj.lib.bundle)=\;

assign \=bundleFunctions.packetizeBundle('data_req_out_int_', dataReqInterface, ['valid', 'ready'], obj.lib.bundle)=\ = read_data_pkt;


\jsbegin
//=============================================================================
// Pointer Management
//=============================================================================

//wire wr_en, rd_en;
//wire [\=wIndex=\:0] wr_ptr;
//wire [\=wIndex=\:0] rd_ptr;
\jsend
wire [\=wIndex-1=\:0] rd_ptr_d1, rd_ptr_d2; 
//wire full;
//wire empty;
//wire almost_empty;
//wire almost_full;

//wire rd_wr_bank_conflict;
wire mem_read;
//wire mem_read_pre;
wire push_mem_data_valid;
wire push_mem_data_ready;
wire push_mem_uce_ready;
wire pop_mem_uce_valid;
wire pop_mem_data_valid;
wire pop_mem_data_ready;
wire mem_data_almost_full;
wire [\=width-1=\:0] push_mem_data_pkt;
wire [\=width-1=\:0] pop_mem_data_pkt;
wire mem_ce;
wire mem_uce;
wire pop_mem_data_uce;
wire mem_uce_d1;
wire mem_ce_d1;
wire mem_ce_d2;
wire [\=addr_w-1=\:0] rd_index_ack;
wire [\=addr_w-1=\:0] rd_index_ack_d1;
wire [\=addr_w-1=\:0] rd_index_ack_d2;
\js for (var i = 0 ; i < nBanks ; i++) {
wire [\=addr_w-1=\:0] rd_index_ack_\=i=\;
wire rd_bank_sel_ack_\=i=\;
wire rd_bank_sel_ack_\=i=\_d1;
wire rd_bank_sel_ack_\=i=\_d2;
wire data_bank_\=i=\_read_en;
wire data_bank_\=i=\_chip_en_read_ack;
\js }

wire [2:0] pipe_credit, d_pipe_credit;
wire en_pipe_credit, credit_inc, credit_dec;
\jsbegin
// wire push_mem_header_valid, push_mem_header_ready;
// wire pop_mem_header_valid, pop_mem_header_ready;
// wire [wHeader-1:0] push_mem_header_pkt, pop_mem_header_pkt;
\jsend
\js for (var i = 0 ; i < nBanks ; i++) {
wire rd_bank_sel_\=i=\, wr_bank_sel_\=i=\;

wire data_bank\=i=\_uce;
wire data_bank\=i=\_ce;
wire [\=width-1=\:0]data_bank\=i=\_cor_data;

\js if ( protType !== 'SECDED' ) {
assign data_bank\=i=\_ce = 1'b0;
assign data_bank\=i=\_cor_data = \=width=\'b0;
\js     }

\js if ( protType === 'NONE' ) {
assign data_bank\=i=\_uce = 1'b0;
\js     }
\js }
\jsbegin
//assign almost_empty = (wr_ptr == rd_ptr_next);
//assign almost_full  = (wr_ptr_next[\=wIndex=\] != rd_ptr[\=wIndex=\]) & (wr_ptr_next[\=wIndex-1=\:0] == rd_ptr[\=wIndex-1=\:0]);

//assign empty    = (wr_ptr == rd_ptr);
// empty = 1'b0;
//assign full     = (wr_ptr[\=wIndex=\] != rd_ptr[\=wIndex=\]) & (wr_ptr[\=wIndex-1=\:0] == rd_ptr[\=wIndex-1=\:0]);
//assign full = 1'b0;
//assign wr_en = data_req_in_valid & data_req_in_ready;

//\=u.dffre(wIndex+1, 'wr_ptr',       'wr_ptr_next',  (wIndex+1)+"'b0", 'wr_en', 'clk', 'reset_n')=\

//assign wr_ptr_next = (wr_ptr[\=wIndex-1=\:0] == \=wIndex=\'d\=depth-1=\)? {~wr_ptr[\=wIndex=\], \=wIndex=\'d0} : wr_ptr + \=wIndex+1=\'d1;
//assign rd_ptr_next = (rd_ptr[\=wIndex-1=\:0] == \=wIndex=\'d\=depth-1=\)? {~rd_ptr[\=wIndex=\], \=wIndex=\'d0} : rd_ptr + \=wIndex+1=\'d1;

//assign rd_en = mem_read_pre;// & ~mem_ce_d1; // fastRead: (wr_flop & data_req_out_ready & ~pop_mem_data_valid);
//assign data_req_in_ready   =~full & ~rd_wr_bank_conflict & (push_mem_header_ready | ~data_req_in_first);
\jsend
assign rd_wr_bank_conflict = (rd_ptr[\=wBanks-1=\:0] == wr_ptr[\=wBanks-1=\:0]) ;

assign data_req_in_ready = 1'b1;

\js for (var i = 0 ; i < nBanks ; i++) {
assign rd_bank_sel_\=i=\ = (rd_ptr[\=wBanks-1=\:0] == \=wBanks=\'d\=i=\);
assign wr_bank_sel_\=i=\ = (wr_ptr[\=wBanks-1=\:0] == \=wBanks=\'d\=i=\);
assign data_bank_\=i=\_address = rd_bank_sel_\=i=\ & rd_en ? rd_ptr[\=wIndex-1=\:\=wBanks=\] : wr_ptr[\=wIndex-1=\:\=wBanks=\];
assign data_bank_\=i=\_read_en =(rd_bank_sel_\=i=\ & rd_en);
assign data_bank_\=i=\_chip_en = data_bank_\=i=\_read_en | (wr_bank_sel_\=i=\ & wr_en);
assign data_bank_\=i=\_write_en=(wr_bank_sel_\=i=\ & wr_en);
assign data_bank_\=i=\_data_in = write_data_pkt;
\js }

\js for (var i = 0 ; i < nBanks ; i++) {
\=u.dffre(1,        'rd_bank_sel_ack_'+i+'_d1',         'rd_bank_sel_ack_'+i,                "1'b0",           "1'b1",  'clk', 'reset_n')=\
\js }

assign data_req_out_valid = pop_mem_data_valid;

assign mem_read = data_bank_0_chip_en_read_ack //& ~data_bank0_ce
\js for (var i = 1 ; i < nBanks ; i++) {
                 |data_bank_\=i=\_chip_en_read_ack //& ~data_bank\=i=\_ce
\js }
                  ;
\jsbegin
// assign mem_read_pre = data_bank_0_read_en
// \js for (var i = 1 ; i < nBanks ; i++) {
//                  |data_bank_\=i=\_read_en
// \js }
//                   ;
\jsend
assign read_data_pkt = pop_mem_data_pkt;

assign mem_data_pkt = ({\=width=\{rd_bank_sel_ack_0}} & data_bank_0_data_out
\js     for (var i = 1 ; i < nBanks ; i++) {
                      |{\=width=\{rd_bank_sel_ack_\=i=\}} & data_bank_\=i=\_data_out

\js     }
                      );
 
wire collide_valid, collide_valid_q;

assign push_mem_data_pkt = mem_ce_d1        ? mem_ce_data_pkt :
                           collide_valid_q  ? mem_data_pkt_d1 : mem_data_pkt;

assign push_mem_data_valid = mem_ce_d1 | (mem_read & ~mem_ce) | collide_valid_q;

assign collide_valid  = mem_ce_d1       & (mem_read & ~mem_ce)| 
                        collide_valid_q & (mem_read & ~mem_ce);
\js // TODO: assert never see mem_cd_d1 & collide_valid same cycle


\js if ( protType === 'SECDED' ) {
\=u.dffre(1,        'collide_valid_q',         'collide_valid',                 "1'b0",           "1'b1",  'clk', 'reset_n')=\

\=u.dffre(width,    'mem_data_pkt_d1',         'mem_data_pkt',                  width+"'b0",      "1'b1",  'clk', 'reset_n')=\

\=u.dffre(1,        'mem_ce_d1',               'mem_ce',                        "1'b0",           "1'b1",  'clk', 'reset_n')=\
\=u.dffre(1,        'mem_ce_d2',               'mem_ce_d1',                     "1'b0",           "1'b1",  'clk', 'reset_n')=\

\=u.dffre(1,        'rd_bank_sel_ack_1_d2',    'rd_bank_sel_ack_1_d1',          "1'b0",           "1'b1",  'clk', 'reset_n')=\
\=u.dffre(addr_w,   'rd_index_ack_d2',         'rd_index_ack_d1',               addr_w+"'b0",     "1'b1",  'clk', 'reset_n')=\

assign mem_ce = data_bank_0_chip_en_read_ack & data_bank0_ce
\js for (var i = 1 ; i < nBanks ; i++) {
               |data_bank_\=i=\_chip_en_read_ack & data_bank\=i=\_ce
\js }
                ;



assign mem_ce_data_pkt = {\=width=\{rd_bank_sel_ack_0_d1}} & data_bank0_cor_data[\=width-1=\:0]
\js     for (var i = 1 ; i < nBanks ; i++) {
                        |{\=width=\{rd_bank_sel_ack_\=i=\_d1}} & data_bank\=i=\_cor_data[\=width-1=\:0]

\js     }
                        ;  

\js } else {
assign mem_ce_data_pkt = \=width=\'b0;
assign mem_data_pkt_d1 = \=width=\'b0;
assign mem_ce_d1 = 1'b0;
assign mem_ce = 1'b0;
assign collide_valid_q = 1'b0;
\js }

\js if ( protType !== 'NONE' ) {
\=u.dffre(1,        'mem_uce_d1',               'mem_uce',                  "1'b0",           "1'b1",  'clk', 'reset_n')=\
\=u.dffre(addr_w,   'rd_index_ack_d1',          'rd_index_ack',             addr_w+"'d0",     "1'b1",  'clk', 'reset_n')=\

assign rd_index_ack = rd_index_ack_0 & {\=addr_w=\{data_bank_0_chip_en_read_ack}}
\js for (var i = 1 ; i < nBanks ; i++) {
                     |rd_index_ack_\=i=\ & {\=addr_w=\{data_bank_\=i=\_chip_en_read_ack}}
\js }
                ;

assign mem_uce = data_bank_0_chip_en_read_ack & data_bank0_uce
\js for (var i = 1 ; i < nBanks ; i++) {
                |data_bank_\=i=\_chip_en_read_ack & data_bank\=i=\_uce
\js }
                ; 

assign mem_uce_valid = mem_uce_d1 & csr_UEDR_MemErrDetEn;
assign mem_uce_index = {rd_index_ack_d1,rd_bank_sel_ack_1_d1};

\js } else {
assign rd_ptr_d1 = \=wIndex=\'d0;
assign rd_ptr_d2 = \=wIndex=\'d0;
assign mem_uce = 1'b0;
\js }

\js if ( protType === 'SECDED' ) {
assign mem_ce_valid = mem_ce_d2 & csr_CECR_ErrDetEn;
assign mem_ce_index = {rd_index_ack_d2,rd_bank_sel_ack_1_d2};
\js }
assign read_ready = ~(pipe_credit == 3'd0);
assign credit_inc = pop_mem_data_valid & pop_mem_data_ready;
assign credit_dec = rd_en;
assign d_pipe_credit = ( credit_inc & ~credit_dec) ? pipe_credit + 3'd1 :
                       (~credit_inc &  credit_dec) ? pipe_credit - 3'd1 : pipe_credit;
assign en_pipe_credit = credit_inc | credit_dec;

\=u.dffre(3, 'pipe_credit',  'd_pipe_credit',  "3'b111", 'en_pipe_credit', 'clk', 'reset_n')=\


\=obj.lib.instance({
    instanceName: 'mem_data_fifo',
    moduleName: 'fifo',
    params: {
        width: width,
        depth: 7,
        zerodepth: 0,
        bypass_mode: 0,
        almostFull: 1
    },
    ports: {
        clk         : 'clk',
        reset_n     : 'reset_n',
        push_valid  : 'push_mem_data_valid',
        push_ready  : 'push_mem_data_ready',
        push_data   : 'push_mem_data_pkt',
        pop_valid   : 'pop_mem_data_valid',
        pop_ready   : 'pop_mem_data_ready',
        pop_data    : 'pop_mem_data_pkt',
        almost_full : 'mem_data_almost_full'
    }
})=\

\=obj.lib.instance({
    instanceName: 'mem_data_uce_fifo',
    moduleName: 'fifo',
    params: {
        width: 1,
        depth: 7,
        zerodepth: 0,
        bypass_mode: 0,
        almostFull: 0
    },
    ports: {
        clk         : 'clk',
        reset_n     : 'reset_n',
        push_valid  : 'push_mem_data_valid',
        push_ready  : 'push_mem_uce_ready',
        push_data   : 'mem_uce',
        pop_valid   : 'pop_mem_uce_valid',
        pop_ready   : 'pop_mem_data_ready',
        pop_data    : 'pop_mem_data_uce',
    }
})=\

\jsbegin
if (dataReqInterface.dbad!=null) { \jsend
assign data_req_out_dbad = pop_mem_data_uce ? {\=dataReqInterface.dbad=\{1'b1}} : data_req_out_int_dbad;
\jsbegin
} \jsend
\jsbegin
//If uncorrectable error occurs, drive 'Data Error' on response field
if (dataReqInterface.resp!=null) { \jsend
assign data_req_out_resp = pop_mem_data_uce ? 2'b10 : data_req_out_int_resp;
\jsbegin
} \jsend

\=bundleFunctions.assignByBundle('data_req_out_', 'data_req_out_int_', dataReqInterface, ["valid","ready","dbad","resp"], obj.lib.bundle)=\


assign pop_mem_data_ready = data_req_out_ready;
\jsbegin
//\=u.dffre(wIndex+1, 'rd_ptr',       'rd_ptr_next',  (wIndex+1)+"'b0", 'rd_en', 'clk', 'reset_n')=\
\jsend
\jsbegin
//=============================================================================
// Memories
//=============================================================================
\jsend

\jsbegin
var memParams = {
    clkInterface    : clkInterface,
    memoryInterface : memoryInterface,
    nBanks          : nBanks,
    width           : width,
    wEcc            : wEcc,
    depth           : depth,
    memType         : memType,
    protType        : protType,
    assertOn        : assertOn,
    nPorts          : nPorts,
    memEccBlocks    : memEccBlocks,
    memParam        : memParam
};
// TODO: replace this with pure interface
var memPorts = {};
if ( memType !== 'NONE' ) {
    for (var i = 0 ; i < nBanks ; i++) {
        memPorts['int_address_'+i]  = memPrefix+i+'_int_address';
        memPorts['int_chip_en_'+i]  = memPrefix+i+'_int_chip_en';
        memPorts['int_write_en_'+i] = memPrefix+i+'_int_write_en';
        memPorts['int_data_in_'+i]  = memPrefix+i+'_int_data_in';
        memPorts['int_data_out_'+i] = memPrefix+i+'_int_data_out';
    }
}

for ( var i = 0 ; i < nBanks; i++ ) {
    if ( protType !== 'NONE' ) {
        memPorts['data_bank'+i+'_uce'] = 'data_bank'+i+'_uce'; 
        if ( protType === 'SECDED' ) {
        memPorts['data_bank'+i+'_cor_data'] = 'data_bank'+i+'_cor_data';
        memPorts['data_bank'+i+'_ce'] = 'data_bank'+i+'_ce';
        } 
    }
};

for ( var i = 0 ; i < nBanks; i++ ) {
    memPorts['data_bank_'+i+'_chip_en_read'] = 'data_bank_'+i+'_read_en';
    memPorts['rd_bank_sel_'+i] = 'rd_bank_sel_'+i;
    memPorts['data_bank_'+i+'_chip_en_read_ack'] = 'data_bank_'+i+'_chip_en_read_ack';
    memPorts['rd_bank_sel_ack_'+i] = 'rd_bank_sel_ack_'+i;
    memPorts['rd_index_ack_'+i] = 'rd_index_ack_'+i;

};

for (var i = 0 ; i < nBanks ; i++) {
    memPorts['data_bank'+i+'_address']  = 'data_bank_'+i+'_address';
    memPorts['data_bank'+i+'_chip_en']  = 'data_bank_'+i+'_chip_en';
    memPorts['data_bank'+i+'_write_en'] = 'data_bank_'+i+'_write_en';
    memPorts['data_bank'+i+'_data_in']  = 'data_bank_'+i+'_data_in';
    memPorts['data_bank'+i+'_data_out'] = 'data_bank_'+i+'_data_out';
}

var memInterfaces = [];
memInterfaces.push({modulePrefix: '',    localPrefix: '',    interface: clkInterface});

\jsend

\=u.instance({
    instanceName:'mem_inst',
    moduleName  :'dmi_write_data_memory',
    params      : memParams,
    ports       : memPorts,
    interfaces  : memInterfaces
})=\

assign active = pipe_credit != 3'b111;

\jsbegin
//=============================================================================
// Assertions
//=============================================================================
\jsend

\js if ( assertOn ) {
    `ifdef OVL_ASSERT_ON
    // coverage off
    // synthesis off
    // synopsys translate_off
//    property DTW_OVERFLOW;
//        !(data_req_in_valid & full);
//    endproperty assert property (DTW_OVERFLOW);
//
    // assert_implication #(0) valid_data_must_has_valid_data_info(
    //     .clk(clk),
    //     .reset_n(reset_n),
    //     .antecedent_expr(pop_mem_data_valid),
    //     .consequent_expr(pop_mem_data_info_valid)
    // );   
    // assert_implication #(0) valid_data_must_has_valid_header_info(
    //     .clk(clk),
    //     .reset_n(reset_n),
    //     .antecedent_expr(pop_mem_data_valid),
    //     .consequent_expr(pop_mem_header_valid)
    // );  
    // synopsys translate_on
    // synthesis on
    // coverage on
    `endif
\js }

endmodule
