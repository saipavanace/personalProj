//=============================================================================
// Copyright(C) 2018 Arteris, Inc.
// All rights reserved
//=============================================================================
\jsbegin
// DMI NC Write Buffer
// Author: Tso-Wei Chang
//=============================================================================

//=============================================================================
// Variables
//=============================================================================
var u = obj.lib;
var m = obj.userLib;
var log2ceil = function(n) { return Math.ceil(Math.log(n)/Math.LN2); };
var bundleFunctions     = m.bundleFunctions;

var ASILB = u.getParam("ASILB");
var rbidBuffer= obj.lib.getParam("rbidBuffer");

var dataBuffer = obj.lib.getParam("dataBuffer");
dataBuffer["valid"] = 1;
dataBuffer["ready"] = 1;
var nDmiRbEntries       = u.getParam('nDmiRbEntries');
var wDmiRbEntries    = log2ceil(nDmiRbEntries);
var wCacheLineOffset    = u.getParam('wCacheLineOffset');
var RBReqInterface      = u.getParam('RBReqInterface');
var DTWReqInterface     = u.getParam('DTWReqInterface');
var writeProtInterface  = u.getParam('writeProtInterface');
var writeDataInterface  = u.getParam('writeDataInterface');
var clkInterface        = u.getParam('clkInterface');
var useQos              =u.getParam('useQos');
var priorityThreshold   =u.getParam('priorityThreshold');
var wAddr               = RBReqInterface.addr;
var wRbid               = DTWReqInterface.rb_id;
var nBeats              = (1<<wCacheLineOffset) / (DTWReqInterface.data/8);
var wBeats              = Math.log2(nBeats);
var dataBufferSize      = nBeats * nDmiRbEntries;
var wDataBufferSize     = log2ceil(dataBufferSize);
var wCmType             = DTWReqInterface.cm_type;
var cmType              = u.getParam('cmType');
var wData               = DTWReqInterface.data;
var nDWsPerBeat         = wData/64;
var wDwid               = DTWReqInterface.dwid/nDWsPerBeat;
var wIntfSize           = DTWReqInterface.intf_size;
var wSize               = RBReqInterface.size;
var wQos                = writeProtInterface.qos;
var wMsgId              = RBReqInterface.message_id;
var wDataUser           = (DTWReqInterface.user == undefined)?  /* istanbul ignore next env ncore_3p2,ncore_3p4,ncore_3p6, ncore_3p7 */ 0 : DTWReqInterface.user;
// Add ports and logic for atomic support
var atomic_op           = u.getParam('atomic_op');
var address_match       = u.getParam('address_match');
var wAddrCAM            = u.getParam('wAddrCAM');
var rdQDepth            = u.getParam('rdQDepth');
var wMpf2               = u.getParam('wMpf2');
var sameWidthSystem     = 1;
var wStarvThreshold     = u.getParam("wStarvThreshold")
var useRoundRobin       = 1;
var assertOn            = u.getParam('assertOn');
// default is non-coherent
var coherent            = m.ParamDefaultGet(u, 'coherent',               'int',    0);


var dtwRobInfo = Object.assign({}, dataBuffer);
['data', 'be', 'poison', 'last', 'valid', 'ready', 'dwid', 'user'].forEach(e => delete dtwRobInfo[e]);

var wRbidBuffer = bundleFunctions.getBundleWidth(rbidBuffer, [], u.bundle);
var wDataBuffer = bundleFunctions.getBundleWidth(dataBuffer, ['valid', 'ready'], u.bundle);
//=============================================================================
// Ports & Interfaces
//=============================================================================

u.interface('rb_req_',      'slave',    RBReqInterface, ['m_prot']);
u.interface('dtw_req_',     'slave',    DTWReqInterface);
u.interface('',             'slave',    clkInterface);
u.interface('write_prot_',  'master',   writeProtInterface);
u.interface('write_protd_', 'master',   writeDataInterface);

//ASILB always 0 in 3.7
/* istanbul ignore if env ncore_3p7 */
if (ASILB){
    var rb_buffer_flop_bundle = u.getParam("rb_buffer_flop_bundle");
    u.interface(''    ,          'master', rb_buffer_flop_bundle);
    var data_buffer_flop_bundle = u.getParam("data_buffer_flop_bundle");
    u.interface(''    ,          'master', data_buffer_flop_bundle);
}

if(useQos & priorityThreshold){
u.port('input', "rb_req_h_priority",                                   1);
u.port('input', 'WTT_threshold_reached',                              1);
u.port('input', 'WttQoSRsv',                                          8);
u.port('output','wDataBuffer_threshold_reached',                       1);
u.port('input','starv_threshold',wStarvThreshold);
u.port('input','starv_en',1);
}
u.port('input',  'rb_req_intf_size',                          wIntfSize);
u.port('input',  'rb_req_es',                                         1);
u.port('input',  'rb_req_mpf2',                                   wMpf2);
if (u.getParam("nExclusiveEntries")>0){
u.port("input","rb_req_ex_pass",                                      1);
}
u.port('output', 'write_prot_rb_done',                                1);
u.port('output', 'write_prot_rb_id',                              wRbid);
u.port('output', 'write_prot_initiator_id', RBReqInterface.initiator_id);
u.port('output', 'write_protd_orig_trans_id',                    wMsgId);

u.port('output', 'write_data_initiator_id', RBReqInterface.initiator_id);
u.port('output', 'active',                                            1);
u.port('input',  'cam_addr',                                      wAddr);
u.port('input',  'cam_ns',                                            1);
u.port('output', 'cam_match_vec',                         nDmiRbEntries);
u.port('output', 'cam_match_vec_pmon',                         nDmiRbEntries);

u.port('input',  'rdq_dealloc_idx',                            rdQDepth);
u.port('input',  'rdq_dealloc_en',                                    1);

u.port('input',  'rdq_cam_match_vec',                          rdQDepth);
u.port('output', 'rb_id_dealloc_idx',                     nDmiRbEntries);
u.port('output', 'rb_id_dealloc_en',                                  1);
u.port('output', 'rb_id_retire',                          nDmiRbEntries);
u.port('output', 'rb_id_retire_valid',                                1);
\jsend
module \=u.getModuleName()=\ (\=u.getPorts('\n')=\);

//=============================================================================
// Functions & Local params
//=============================================================================

localparam RD_ATM   = \=cmType['CmdRdAtm']=\;
localparam WR_ATM   = \=cmType['CmdWrAtm']=\;
localparam CM_ATM   = \=cmType['CmdCompAtm']=\;
localparam SW_ATM   = \=cmType['CmdSwapAtm']=\;

function automatic is_atomic;
    input [\=wCmType-1=\:0] cm_type;
    begin
        is_atomic = (cm_type == RD_ATM) | (cm_type == WR_ATM) |
                    (cm_type == CM_ATM) | (cm_type == SW_ATM);
    end
endfunction

localparam WM_INV   = \=cmType['DtwMrgMrdInv']=\;
localparam WM_RSCLN = \=cmType['DtwMrgMrdSCln']=\;
localparam WM_RSDTY = \=cmType['DtwMrgMrdSDty']=\;
localparam WM_RUCLN = \=cmType['DtwMrgMrdUCln']=\;
localparam WM_RUDTY = \=cmType['DtwMrgMrdUDty']=\;

//=============================================================================
// Wires
//=============================================================================
\js var wrProtExclude = ['rl', 'mpf1', 'valid', 'ready', 'cm_type', 'initiator_id', 'rb_id', 'mpf2', 'cm_status', 'message_id', 'poison', 'intf_size', 'tm', 'dwid', 'user'];
\=bundleFunctions.wiresFromInterface('write_prot_',     dataBuffer, wrProtExclude,  u.bundle)=\
\=bundleFunctions.wiresFromInterface('rb_id_buffer_',   rbidBuffer, [],             u.bundle)=\
\=bundleFunctions.wiresFromInterface('dtw_pop_',        dataBuffer, ['valid'],      u.bundle)=\
wire                                        dtw_drb_sent_d;
wire                                        dtw_drb_sent_en;
wire                                        dtw_drb_sent;
wire                                        write_prot_valid_data;
wire                                        rb_id_error;
wire                                        cam_addr_match;
wire                                        dtw_req_poison;
wire                                        wr_valid;
reg  [\=dataBufferSize-1=\:0]               rob_grant_beat_dec;
wire [\=dataBufferSize-1=\:0]               data_valid;
wire [\=dataBufferSize-1=\:0]               d_data_valid;
wire                                        data_valid_en;
reg  [\=nDmiRbEntries-1=\:0]                req_data_valid;
wire [\=nDmiRbEntries-1=\:0]                d_rb_id_valid;
wire [\=nDmiRbEntries-1=\:0]                set_rb_id_valid;
wire [\=nDmiRbEntries-1=\:0]                clr_rb_id_valid;
wire [\=nDmiRbEntries-1=\:0]                rb_id_valid;

wire                                        rb_reserve;
wire                                        rb_release;
wire                                        write_drb;
wire                                        rb_id_valid_en;
wire                                        rb_id_alloc_en;
wire [\=wAddrCAM-wCacheLineOffset=\-1:0]    rb_id_order_link_alloc_id;
wire [\=nDmiRbEntries-1=\:0]                rb_id_alloc_idx;
wire [\=nDmiRbEntries-1=\:0]                rb_id_valid_head_vec;
wire [\=nDmiRbEntries-1=\:0]                no_dep;
wire [\=nDmiRbEntries-1=\:0]                rob_grant_idx;
wire [\=nDmiRbEntries-1=\:0]                rob_sel_idx;
wire [\=nDmiRbEntries-1=\:0]                write_prot_grant_idx;
wire [\=nDmiRbEntries-1=\:0]                rob_qual_idx;
reg  [\=nDmiRbEntries-1=\:0]                first_beat_valid;
wire [\=nDmiRbEntries-1=\:0]                dep_vec_en;

wire                                        rob_in_valid;
wire                                        rob_in_ready;
wire [\=DTWReqInterface.dwid-1=\:0]         rob_dwid;
wire [\=wSize-1=\:0]                        rob_in_size;
wire [\=wSize-1=\:0]                        rob_size_q;
wire [\=wDwid-1=\:0]                        rob_in_cdw;
wire [\=wDwid-1=\:0]                        rob_cdw_q;
\=bundleFunctions.wiresFromInterface('rob_',            dtwRobInfo, ['dwid'],       u.bundle)=\

wire [\=wIntfSize-1=\:0]                    fixed_intfSize = \=wIntfSize=\'d\=Math.log2(wData/64)=\;
wire [\=wDataBuffer-1=\:0]                  data_buffer_grant;
wire [\=wDataBuffer-1=\:0]                  buffer_wrdata;
wire [\=wDataBufferSize-1=\:0]              wr_ptr;
wire [\=wDataBufferSize-1=\:0]              wr_ptr_inc;
wire [\=wDataBufferSize-1=\:0]              wr_ptr_inc_d;
wire [\=wDataBufferSize-1=\:0]              wr_ptr_start;
wire [\=dataBufferSize-1=\:0]               wr_ptr_dec;
wire [\=dataBufferSize-1=\:0]               rd_ptr_dec;
wire [\=dataBufferSize-1=\:0]               buffer_valid_set;
wire                                        wr_ptr_sel_inc;
wire                                        wr_ptr_sel_inc_d;
wire                                        dtw_req_en;
wire                                        write_prot_first;
wire                                        d_write_prot_first;
wire                                        en_write_prot_first;
wire                                        write_prot_data_first;
wire                                        d_write_prot_data_first;
wire                                        en_write_prot_data_first;

wire [\=wRbidBuffer-1=\:0]                  d_rb_id_buffer;
wire [\=wRbidBuffer-1=\:0]                  rb_id_buffer_rd;

wire [\=nDmiRbEntries-1=\:0]                higher_pri_req;
wire                                        write_prot_mw;
\js for (var i = 0; i < dataBufferSize; i++) {
wire [\=wDataBuffer-1=\:0]                  data_buffer_\=i=\;
\js }
\js for (var i = 0; i < nDmiRbEntries; i++) {
wire [\=rdQDepth-1=\:0]                     dep_vec\=i=\;
wire [\=rdQDepth-1=\:0]                     d_dep_vec\=i=\;
wire [\=wRbidBuffer-1=\:0]                  rb_id_buffer_\=i=\;
\=bundleFunctions.wiresFromInterface('rb_id_buffer_'+i+"_",   rbidBuffer, [],             u.bundle)=\
wire [\=wAddr-1=\:0]                        rb_id_addr_\=i=\;
wire                                        rb_id_ns_\=i=\;

\js }

wire                                        dtw_pop_first;
wire                                        d_dtw_pop_first;
wire                                        dtw_pop_last_en;

wire [\=dataBufferSize-1=\:0]               rd_ptr_next;
wire [\=dataBufferSize-1=\:0]               rd_ptr_next_d;
wire                                        rd_ptr_busy;
wire                                        rd_ptr_busy_d;
wire                                        rd_ptr_en;
wire                                        rd_ptr_busy_en;
wire [\=wDataBufferSize-wBeats-1=\:0]       rob_grant_idx_enc;
wire                                        rob_bypass = 1'b0;
wire                                        write_prot_ready_data;
\jsbegin
    // ncore3.2 does not use w_user field
    /* istanbul ignore if env ncore_3p0,ncore_3p2,ncore_3p4,ncore_3p6, ncore_3p7 */
    if( wDataUser != 0 ) {
\jsend
wire [\=wDataUser-1=\:0]                    write_prot_data_user;
\js }
wire                                        rob_busy_info_en;

wire                                        rob_granted;
wire                                        rob_grant_set;
wire                                        rob_grant_clr;
wire                                        rob_grant_en;
wire                                        rob_grant_in;
//=============================================================================
// RBID Buffer
//=============================================================================

assign active             = (|rb_id_valid) | (|data_valid);
assign d_rb_id_buffer     = \=bundleFunctions.packetizeBundle('rb_req_', rbidBuffer, [''], u.bundle)=\;

assign rb_id_dealloc_idx  = rb_id_retire;
assign rb_id_dealloc_en   = rb_id_retire_valid;
assign write_prot_rb_done = 1'b0; // unused
assign rb_id_valid_en     = (rb_req_valid  & rb_req_ready) | rb_id_retire_valid;
assign d_rb_id_valid      = set_rb_id_valid | (rb_id_valid & ~clr_rb_id_valid);
assign rb_reserve         = rb_req_valid & rb_req_ready &  rb_req_r_type;
assign rb_release         = rb_req_valid & rb_req_ready & ~rb_req_r_type;
assign set_rb_id_valid    =  rb_reserve ? rb_id_alloc_idx   : \=nDmiRbEntries=\'b0;
assign clr_rb_id_valid    = (rb_release         ? rb_id_alloc_idx   : \=nDmiRbEntries=\'b0)|
                            (rb_id_retire_valid ? rb_id_dealloc_idx : \=nDmiRbEntries=\'b0);
assign rb_id_alloc_en     = rb_reserve;
assign rb_id_alloc_idx    = (\=nDmiRbEntries=\'d1 << rb_req_rb_id);
assign rb_id_order_link_alloc_id = rb_req_addr[\=wAddrCAM-1=\:\=wCacheLineOffset=\];

assign rb_req_ready = 1'b1;

\=u.dffre(nDmiRbEntries, 'rb_id_valid',  'd_rb_id_valid',  nDmiRbEntries+"'b0", 'rb_id_valid_en', 'clk', 'reset_n')=\


\jsbegin 
if (useQos & priorityThreshold){
\jsend

//counts the number of available entry


//record the priority level of the entries
wire [\=nDmiRbEntries-1=\:0] rb_h_priority;
wire [\=nDmiRbEntries-1=\:0] d_rb_h_priority;
wire [\=wDmiRbEntries=\:0] Nb_free_rb_entries;
wire [\=wDmiRbEntries=\:0] d_Nb_free_rb_entries;



\jsbegin
//Starvation logic
\jsend
wire starv_count_en;
wire entry_starv_overflow_en;
wire[\=wStarvThreshold-1=\:0] starv_count,starv_count_d;
wire[\=nDmiRbEntries-1=\:0] entry_starv_overflow, entry_starv_overflow_d;
wire starv_overflow_event;


assign starv_count_d = (starv_count[\=wStarvThreshold-1=\:0] == starv_threshold) ? \=wStarvThreshold=\'d0 : starv_count + 1'b1;

assign starv_count_en = rb_id_retire_valid & starv_en | starv_overflow_event ;

assign starv_overflow_event = (starv_count[\=wStarvThreshold-1=\:0] == starv_threshold) & (starv_threshold != \=wStarvThreshold=\'b0) & starv_en;

assign entry_starv_overflow_d = (entry_starv_overflow & ~clr_rb_id_valid )   | ( rb_id_valid_head_vec & no_dep & first_beat_valid[\=nDmiRbEntries-1=\:0] & {\=nDmiRbEntries=\{starv_overflow_event}});
assign entry_starv_overflow_en = starv_count_en | (rb_release & starv_en | starv_overflow_event);


\=u.dffre(wStarvThreshold,    'starv_count',            'starv_count_d',              wStarvThreshold+"'d0",    'starv_count_en',           'clk',  'reset_n')=\
\=u.dffre(nDmiRbEntries,        'entry_starv_overflow',   'entry_starv_overflow_d',     nDmiRbEntries+"'d0",        'entry_starv_overflow_en',  'clk',  'reset_n')=\


\jsbegin
//end Starvation logic
\jsend




assign d_rb_h_priority      = (set_rb_id_valid & {\=nDmiRbEntries=\{rb_req_h_priority}}) | (rb_h_priority & ~clr_rb_id_valid) | (rb_id_valid & entry_starv_overflow & {\=nDmiRbEntries=\{starv_overflow_event}}) ;

\=u.dffre(nDmiRbEntries,'rb_h_priority','d_rb_h_priority', nDmiRbEntries+"'b0", 'rb_id_valid_en | starv_overflow_event', 'clk', 'reset_n')=\

\jsbegin
//=============================================================================
// Counts the number of free RB entries
//=============================================================================
\jsend


assign d_Nb_free_rb_entries = Nb_free_rb_entries - {\=wDmiRbEntries=\'d0,|set_rb_id_valid} + {\=wDmiRbEntries=\'d0,|clr_rb_id_valid};
\=u.dffre(wDmiRbEntries+1,'Nb_free_rb_entries','d_Nb_free_rb_entries', (wDmiRbEntries+1)+"'d"+nDmiRbEntries, 'rb_id_valid_en', 'clk', 'reset_n')=\
\jsbegin
//assign d_starv_count = WTT_threshold_reached & ~starv_count[7] ? starv_count+8'd1 : 8'd0;

//\=u.dffre(8,'starv_count','d_starv_count', "8'd0", 'WTT_threshold_reached', 'clk', 'reset_n')=\
\jsend
\jsbegin 
// ncore3 allows max 64 DmiRb credits: 256 not allowed
/* istanbul ignore if env ncore_3p4,ncore_3p6, ncore_3p7 */
if (wDmiRbEntries > 7){
\jsend
    assign wDataBuffer_threshold_reached = ~|(Nb_free_rb_entries[\=wDmiRbEntries=\:8]) & Nb_free_rb_entries[7:0] < WttQoSRsv;
\jsbegin 
    }
    // ncore3 allows max 64 DmiRb credits: 128 not allowed
    /* istanbul ignore next env ncore_3p4,ncore_3p6, ncore_3p7 */
    else if (wDmiRbEntries == 7) {
\jsend
assign wDataBuffer_threshold_reached = Nb_free_rb_entries < WttQoSRsv[\=wDmiRbEntries=\:0];

\jsbegin
    } else {
\jsend
assign wDataBuffer_threshold_reached = |(WttQoSRsv[7:\=wDmiRbEntries+1=\]) | Nb_free_rb_entries < WttQoSRsv[\=wDmiRbEntries=\:0];

\jsbegin
    }
}

//ASILB always 0 in 3.7
/* istanbul ignore if env ncore_3p7 */
if(ASILB){
    \jsend
        assign      en_rb_buffer_vec = set_rb_id_valid ;
    
        \js for(var i =0; i<nDmiRbEntries;i++){
    
            assign      d_rb_buffer_vec[\=i*wRbidBuffer=\ +: \=wRbidBuffer=\] = d_rb_id_buffer;
            assign      rb_id_buffer_\=i=\ = q_rb_buffer_vec[\=i*wRbidBuffer=\ +: \=wRbidBuffer=\];
            assign \=bundleFunctions.packetizeBundle('rb_id_buffer_'+i+"_", rbidBuffer, [], u.bundle)=\ = rb_id_buffer_\=i=\;
            assign rb_id_addr_\=i=\ = rb_id_buffer_\=i=\_addr;
            assign rb_id_ns_\=i=\ = rb_id_buffer_\=i=\_ns;

    \jsbegin
        }   
    } else {
    \jsend
            \js for (var i = 0; i < nDmiRbEntries; i++) {
    
                \=u.dffre(wRbidBuffer, 'rb_id_buffer_'+i,      'd_rb_id_buffer',       wRbidBuffer+"'b0",  'set_rb_id_valid['+i+']', 'clk', 'reset_n')=\
                assign \=bundleFunctions.packetizeBundle('rb_id_buffer_'+i+"_", rbidBuffer, [], u.bundle)=\ = rb_id_buffer_\=i=\;
                assign rb_id_addr_\=i=\ = rb_id_buffer_\=i=\_addr;
                assign rb_id_ns_\=i=\ = rb_id_buffer_\=i=\_ns;
           
           \js }
    \jsbegin
    }
    \jsend

assign rb_id_buffer_rd = (rb_id_buffer_0 & {\=wRbidBuffer=\{write_prot_grant_idx[0]}})
\js for (var i = 1; i < nDmiRbEntries; i++) {
                        |(rb_id_buffer_\=i=\ & {\=wRbidBuffer=\{write_prot_grant_idx[\=i=\]}})
\js }
                        ;

assign \=bundleFunctions.packetizeBundle('rb_id_buffer_', rbidBuffer, [], u.bundle)=\ = rb_id_buffer_rd;

\jsbegin
//=============================================================================
// DTW Buffer
//=============================================================================
\jsend
assign wr_valid         = |(rd_ptr_dec & data_valid);

assign dtw_pop_last_en  = wr_valid & dtw_pop_ready;
assign d_dtw_pop_first  = wr_valid & dtw_pop_ready & dtw_pop_last;
assign dtw_req_poison   = |dtw_req_dbad;
assign buffer_wrdata    = \=bundleFunctions.packetizeBundle('dtw_req_', dataBuffer, ['ready', 'valid'], u.bundle)=\;
assign dtw_req_en       = dtw_req_valid & dtw_req_ready;
assign write_drb        = wr_valid & dtw_pop_ready; 

\jsbegin
//ASILB always 0 in 3.7
/* istanbul ignore if env ncore_3p7 */
if(ASILB){
    \jsend
        assign      d_data_buffer_vec = buffer_wrdata;            
        assign      en_data_buffer_vec = buffer_valid_set;

        \js for(var i =0; i<dataBufferSize;i++){
    
            assign      data_buffer_\=i=\ = q_data_buffer_vec[\=i*wDataBuffer=\ +: \=wDataBuffer=\];

    \jsbegin
        }   
    } else {
    \jsend
            \js for (var i = 0; i < dataBufferSize; i++) {  
                \=u.dffre(wDataBuffer,      'data_buffer_'+i,   'buffer_wrdata',          wDataBuffer+"'b0",        'buffer_valid_set['+i+']',  'clk', 'reset_n')=\     
           \js }
    \jsbegin
    }
    \jsend

\=u.dffre(dataBufferSize,   'data_valid',       'd_data_valid',           dataBufferSize+"'b0",     'data_valid_en',    'clk', 'reset_n')=\
\=u.dffre(wDataBufferSize,  'wr_ptr_inc',       'wr_ptr_inc_d',           wDataBufferSize+"'b0",    'dtw_req_en',       'clk', 'reset_n')=\
\=u.dffre(1,                'wr_ptr_sel_inc',   'wr_ptr_sel_inc_d',       "1'b0",                   'dtw_req_en',       'clk', 'reset_n')=\
\=u.dffre(1,                'dtw_pop_first',    'd_dtw_pop_first',        "1'b1",                   'dtw_pop_last_en',  'clk', 'reset_n')=\

\js // Write
assign wr_ptr_start     = {dtw_req_rb_id[\=wDataBufferSize-wBeats-1=\:0] , \=wBeats=\'b0};
assign wr_ptr_sel_inc_d =~dtw_req_last;
assign wr_ptr_inc_d     = wr_ptr + \=wDataBufferSize=\'b1;
assign wr_ptr           = wr_ptr_sel_inc ? wr_ptr_inc : wr_ptr_start;
assign wr_ptr_dec       = (\=dataBufferSize=\'d1 << wr_ptr);
assign buffer_valid_set = dtw_req_en? wr_ptr_dec : \=dataBufferSize=\'b0;
assign data_buffer_grant = (data_buffer_0 & {\=wDataBuffer=\{rd_ptr_dec[0]}})
\js for (var i = 1; i < dataBufferSize; i++) {
                          |(data_buffer_\=i=\ & {\=wDataBuffer=\{rd_ptr_dec[\=i=\]}})
\js }
                          ;
assign \=bundleFunctions.packetizeBundle('dtw_pop_', dataBuffer, ['ready','valid'], u.bundle)=\ = data_buffer_grant;
assign d_data_valid = (wr_ptr_dec & {\=dataBufferSize=\{dtw_req_en}}) | (data_valid & ~(rd_ptr_dec & {\=dataBufferSize=\{write_drb}}));

assign data_valid_en =  dtw_req_en | write_drb;
\js // STRReq for nc_write can be issued as long as there is available RBID
\js // always ready to received dtws
assign dtw_req_ready = 1'b1;

assign rd_ptr_en        = (wr_valid & dtw_pop_ready);
assign rd_ptr_busy_en   = rd_ptr_en;

assign rd_ptr_busy_d    =~(rd_ptr_en & dtw_pop_last);
assign rd_ptr_next_d    = rd_ptr_en ? rd_ptr_dec << 1: rd_ptr_dec;
assign rd_ptr_dec       = (rd_ptr_busy ? rd_ptr_next :  rob_grant_beat_dec);

\=u.dffre(dataBufferSize,   'rd_ptr_next',   'rd_ptr_next_d',   dataBufferSize+"'b0",  'rd_ptr_busy_en', 'clk', 'reset_n')=\
\=u.dffre(1,                'rd_ptr_busy',   'rd_ptr_busy_d',                 "1'b0",  'rd_ptr_busy_en', 'clk', 'reset_n')=\


always@(*) begin
\js for ( var i = 0; i < nDmiRbEntries; i++) {
    rob_grant_beat_dec[\=nBeats*(i+1)-1=\:\=nBeats*i=\] = {\=nBeats-1=\'b0, rob_grant_idx[\=i=\]};
\js }
end

\=obj.lib.instance({
    instanceName: 'grant_idx_encoder',
    moduleName: 'encoder',
    params: {
        width: nDmiRbEntries,
    },
    verilogParams: {},
    ports: {
        invector:   'rob_grant_idx',
        outdecode:  'rob_grant_idx_enc',
    },
    interfaces: [],
    portsDelimiter: '\n        '
})=\

\jsbegin
//=============================================================================
// Write Ordering Link
//=============================================================================
\jsend

\js // To maintain order of same address write
\=obj.lib.instance({
    instanceName: 'rb_id_order_link',
    moduleName: 'dep_link',
    params: {
        width: wAddrCAM-wCacheLineOffset,
        depth: nDmiRbEntries,
        clkInterface: clkInterface
    },
    verilogParams: {},
    ports: {
        alloc_en:   'rb_id_alloc_en',
        alloc_id:   'rb_id_order_link_alloc_id',
        alloc_idx:  'rb_id_alloc_idx',
        dealloc_en: 'rb_id_dealloc_en',
        dealloc_idx:'rb_id_dealloc_idx',
        valid_head_vec: 'rb_id_valid_head_vec'
    },
    interfaces: [
        {modulePrefix: '',      localPrefix: '',                interface: clkInterface},
    ],
    portsDelimiter: '\n        '
})=\

\js // not used
\jsbegin
//=============================================================================
// DTW ROB
//=============================================================================
\jsend
\jsbegin 
if (useQos & priorityThreshold){
\jsend
assign rob_qual_idx = rb_id_valid_head_vec & no_dep & first_beat_valid & ((WTT_threshold_reached) ? rb_h_priority :{\=nDmiRbEntries=\{1'b1}}) & ~rob_sel_idx;

\jsbegin
}else{
\jsend
assign rob_qual_idx = rb_id_valid_head_vec & no_dep & first_beat_valid & ~rob_sel_idx;
\jsbegin
}
\jsend
always@(*) begin
\js for ( var i = 0; i < nDmiRbEntries; i++ ) {
    first_beat_valid[\=i=\] = data_valid[\=i*nBeats=\];
\js }
end
\jsbegin
// Always use roundrobin for 3.2, tied off at top.
/* istanbul ignore else env ncore_3p0,ncore_3p2,ncore_3p4,ncore_3p6, ncore_3p7 */
    if ( useRoundRobin ) { 
\jsend
wire [\=nDmiRbEntries-1=\:0] park_point;
wire [\=nDmiRbEntries-1=\:0] park_point_therm;
wire [\=nDmiRbEntries-1=\:0] park_point_d;
wire                         park_point_en;

wire rob_sel_idx_en;
wire [\=nDmiRbEntries-1=\:0] d_rob_sel_idx;

\=obj.lib.instance({
    instanceName: 'req_rr_arb',
    moduleName: 'dmi_arb_comb_therm',
    params: { 
                num_inputs : nDmiRbEntries 
            },
    ports: {
                req        : 'rob_qual_idx',
                park_point : 'park_point',
                grant      : 'd_rob_sel_idx'
           },
    portsDelimiter: '\n    '
})=\

\=obj.lib.instance({
        instanceName: 'u_park_point_therm',
        moduleName: 'thermo_fast',
        params: {
            width   : nDmiRbEntries
        },
        verilogParams: {
        },
        ports: {
            invec       : 'park_point_d',
            outvec      : 'park_point_therm'
        }
})=\

\=u.dffre(nDmiRbEntries, 'park_point',  'park_point_therm',  nDmiRbEntries+"'d1", 'park_point_en', 'clk', 'reset_n')=\
assign park_point_d = rob_grant_idx;
assign park_point_en = wr_valid & dtw_pop_ready & dtw_pop_first;



assign rob_sel_idx_en = (rob_grant_set & rob_grant_clr | rob_granted & rob_grant_clr | ~write_prot_valid & ~rob_granted & dtw_pop_first) ;
\=u.dffre(nDmiRbEntries,'rob_sel_idx','d_rob_sel_idx', nDmiRbEntries+"'d0", 'rob_sel_idx_en', 'clk', 'reset_n')=\

assign rob_grant_set = write_prot_valid & ~rob_granted;
assign rob_grant_clr = wr_valid & dtw_pop_ready;
assign rob_grant_en  = rob_grant_set | rob_grant_clr;
assign rob_grant_in  = rob_grant_set & ~rob_grant_clr;
\=u.dffre(1, 'rob_granted',  'rob_grant_in',  "1'd0", 'rob_grant_en', 'clk', 'reset_n')=\

assign rob_grant_idx = rob_sel_idx;

\js }

assign write_prot_late_resp_id = \=writeProtInterface.late_resp_id=\'b0;

\jsbegin

var DtwDrbParams = { 
    clkInterface        : clkInterface,
    width               : wData,
    wDwid               : wDwid,
    wIntfSize           : wIntfSize,
    wTransSize          : wSize,
    dataInfoInterface   : dtwRobInfo,
    nBeats              : nBeats,
    wrData              : 1,
    bypassable          : 0,
    wUser               : wDataUser,
    nRbs                : nDmiRbEntries,
    assertOn            : assertOn
};

var DtwDrbPorts = {  
    critical_dw         : 'rob_in_cdw',
    intf_size           : 'fixed_intfSize',
    data_beat_in        : 'dtw_pop_data',
    data_beat_in_valid  : 'rob_in_valid',
    data_beat_in_last   : 'dtw_pop_last',
    data_beat_in_dwid   : 'dtw_pop_dwid',
    data_beat_in_be     : 'dtw_pop_be',
    data_beat_in_dbad   : 'dtw_pop_dbad',
    trans_size          : 'rob_in_size',
    
    data_beat_out_ready : 'write_prot_ready_data',
    data_beat_out       : 'write_prot_data',
    data_beat_out_be    : 'write_prot_be',
    data_beat_out_dbad  : 'write_prot_dbad',
    data_beat_out_valid : 'write_prot_valid_data',
    data_beat_out_last  : 'write_prot_last',
    data_beat_out_dwid  : 'rob_dwid',
    data_beat_in_ready  : 'rob_in_ready',
    
    rb_id_retire        : 'rb_id_retire',
    rb_id_retire_valid  : 'rb_id_retire_valid'

};
// ncore3.2 does not use w_user field
/* istanbul ignore if env ncore_3p0,ncore_3p2,ncore_3p4,ncore_3p6, ncore_3p7 */
if ( wDataUser != 0 ) {
DtwDrbPorts['data_beat_in_user']    = 'dtw_pop_user';
DtwDrbPorts['data_beat_out_user']   = 'write_prot_data_user';
}

var dtwDrbInterfaces = [];
dtwDrbInterfaces.push({modulePrefix: '',         localPrefix: '',             interface: clkInterface       });
dtwDrbInterfaces.push({modulePrefix: 'alloc_',   localPrefix: 'dtw_pop_',     interface: dtwRobInfo         });
dtwDrbInterfaces.push({modulePrefix: 'lookup_',  localPrefix: 'rob_',         interface: dtwRobInfo         });

\jsend

    \=obj.lib.instance({
        instanceName:'nc_dtw_drb',
        moduleName  :'dmi_drb',
        params      : DtwDrbParams,
        ports       : DtwDrbPorts,
        interfaces  : dtwDrbInterfaces,
    })=\


\js // clear over set.
    assign dtw_drb_sent_d           =(rob_in_valid & rob_in_ready) &~(wr_valid & dtw_pop_ready);
    assign dtw_drb_sent_en          =(rob_in_valid & rob_in_ready) | (wr_valid & dtw_pop_ready);
    \=obj.lib.dffre(1, 'dtw_drb_sent',  'dtw_drb_sent_d',  "1'b0", 'dtw_drb_sent_en', 'clk', 'reset_n')=\

    assign dtw_pop_ready            = (rob_in_ready | dtw_drb_sent) & (write_prot_ready | ~write_prot_first);
    assign rob_in_valid             = wr_valid & ~dtw_drb_sent;
    
    assign rob_in_size              = rd_ptr_busy ? rob_size_q : write_prot_size;
    assign rob_in_cdw               = rd_ptr_busy ? rob_cdw_q  : write_prot_addr[\=wCacheLineOffset-1=\:\=wCacheLineOffset-wDwid=\];

    \=obj.lib.dffre(wSize, 'rob_size_q', 'write_prot_size',  wSize+"'b0", 'rob_busy_info_en', 'clk', 'reset_n')=\
    \=obj.lib.dffre(wDwid, 'rob_cdw_q',  'write_prot_addr['+(wCacheLineOffset-1)+':'+(wCacheLineOffset-wDwid)+']',  wDwid+"'b0", 'rob_busy_info_en', 'clk', 'reset_n')=\

    assign rob_busy_info_en = write_prot_valid & write_prot_ready;
    
    assign write_prot_aiu_id        = dtw_pop_initiator_id;
    assign write_prot_aiu_trans_id  = dtw_pop_message_id; // with protd
    assign write_data_initiator_id  = dtw_pop_initiator_id;
    assign write_prot_trans_id      = \=writeProtInterface.trans_id=\'d0; //dtw_pop_message_id; // with prot
    assign write_prot_rb_id         = \=wRbid=\'d0; //rob_grant_idx_enc;
    assign write_prot_grant_idx     = rob_grant_idx;
    assign write_protd_orig_trans_id= rob_message_id;

\js     if (atomic_op) {
\js // if atomic op, put the atomic cmd on the write address bus, and the argv on the data bus
    assign write_prot_cm_type   = is_atomic(rb_id_buffer_cm_type) ? rb_id_buffer_cm_type : dtw_pop_cm_type;
    assign write_protd_mpf1     = \=writeProtInterface.mpf1=\'d0; // unused, this is piped in protocol control
    assign write_prot_es        = is_atomic(rb_id_buffer_cm_type) ? 1'b0 : rb_id_buffer_es;
\js // for atomics, vz should be forced to 0.
    assign write_prot_vz        = is_atomic(rb_id_buffer_cm_type) ? 1'b0 : rb_id_buffer_vz;
    assign write_prot_mpf1      = rb_id_buffer_mpf1; // this has to carry atomic opcode
\js     } else {
    assign write_prot_cm_type   = dtw_pop_cm_type;
    assign write_protd_mpf1     = \=writeProtInterface.mpf1=\'d0;
    assign write_prot_vz        = rb_id_buffer_vz;
    assign write_prot_mpf1      = \=writeProtInterface.mpf1=\'d0;
    assign write_prot_es        = rb_id_buffer_es;
\js }

\js if ( wQos != 0 ) {
    assign write_prot_qos       = rb_id_buffer_qos;
\js }
    assign write_prot_size      = dtw_pop_primary ? rb_id_buffer_size : \=wSize=\'d\=wCacheLineOffset=\;
    assign write_prot_tm        = dtw_pop_tm;
    assign rb_id_error          = write_prot_rb_id >= \=nDmiRbEntries=\;
    assign write_prot_primary   = dtw_pop_primary;
    assign write_protd_poison   = |write_prot_dbad;

//=============================================================================
// Address handling
//=============================================================================

\js for (var i = 0; i < nDmiRbEntries; i++) {
assign no_dep[\=i=\] = ~|dep_vec\=i=\;
assign d_dep_vec\=i=\ = (dep_vec\=i=\ & ~rdq_dealloc_idx & {\=rdQDepth=\{rdq_dealloc_en}}) | 
                        ((rdq_cam_match_vec & ~(rdq_dealloc_idx & {\=rdQDepth=\{rdq_dealloc_en}})) & {\=rdQDepth=\{rb_id_alloc_en & rb_id_alloc_idx[\=i=\]}});
assign dep_vec_en[\=i=\] = (rb_id_alloc_idx[\=i=\] & rb_id_alloc_en) | rdq_dealloc_en;
\=u.dffre(rdQDepth, 'dep_vec'+i,  'd_dep_vec'+i,  rdQDepth+"'b0", 'dep_vec_en['+i+']', 'clk', 'reset_n')=\
\js }

\js   for (var i = 0; i < nDmiRbEntries; i++) {
assign cam_match_vec[\=i=\] = rb_id_valid[\=i=\] & ((rb_id_buffer_\=i=\_addr[\=wAddrCAM-1=\:\=wCacheLineOffset=\] ^ cam_addr[\=wAddrCAM-1=\:\=wCacheLineOffset=\]) == 0);

assign cam_match_vec_pmon[\=i=\] = rb_id_valid[\=i=\] & ((rb_id_buffer_\=i=\_addr[\=wAddrCAM-1=\:\=wCacheLineOffset=\] ^ cam_addr[\=wAddrCAM-1=\:\=wCacheLineOffset=\]) == 0 & (rb_id_buffer_\=i=\_ns ^ cam_ns) == 0);

\js   }
assign cam_addr_match = |cam_match_vec;

//=============================================================================
// Output
//=============================================================================
\jsbegin
/* istanbul ignore if env ncore_3p0 */
    if(writeProtInterface.user != 0) {
\jsend
    assign write_prot_user = rb_id_buffer_aux;
\js }

\=bundleFunctions.assignByBundle('write_prot_', 'rb_id_buffer_', rbidBuffer, ['es', 'cm_type', 'valid', 'vz', 'mpf1', 'size', 'aux', 'qos'], obj.lib.bundle)=\

assign write_prot_valid  = (dtw_drb_sent | (|rob_sel_idx)) & write_prot_first;
assign write_protd_valid = write_prot_valid_data;
assign write_prot_ready_data = write_protd_ready;

\=bundleFunctions.assignByBundle('write_protd_', 'write_prot_', writeDataInterface, ['valid','ready','mpf1', 'user', 'poison'], obj.lib.bundle)=\
\jsbegin
// ncore3.2 does not use w_user field
/* istanbul ignore if env ncore_3p0,ncore_3p2,ncore_3p4,ncore_3p6, ncore_3p7 */
    if ( wDataUser != 0 ) {
\jsend
assign write_protd_user = write_prot_data_user;

\js }

\=obj.lib.dffre(1, 'write_prot_first',  'd_write_prot_first',  "1'b1", 'en_write_prot_first', 'clk', 'reset_n')=\
assign d_write_prot_first  =  wr_valid & dtw_pop_ready & dtw_pop_last;
assign en_write_prot_first = (write_prot_valid & write_prot_ready) | (wr_valid & dtw_pop_ready);

\=obj.lib.dffre(1, 'write_prot_data_first',  'd_write_prot_data_first',  "1'b1", 'en_write_prot_data_first', 'clk', 'reset_n')=\
assign d_write_prot_data_first  =  write_protd_valid & write_protd_ready & write_protd_last;
assign en_write_prot_data_first = (write_protd_valid & write_protd_ready);

\js if ( assertOn ) {
    `ifdef OVL_ASSERT_ON
    // synthesis_off
    // pragma synthesis_off
    // coverage off
    \js if (useQos){
    
    wire [2:0] fire_nc_write_starv_asserted;
    wire [2:0] fire_nc_write_full_asserted;
    wire [2:0] fire_priority_check;
    
    ovl_always #(.severity_level(0), .msg("a low priority request was selected while threshold is asserted")) nc_priority_check (
        .clock(clk),
        .reset(reset_n),
        .enable(1'b1),
        .test_expr(WTT_threshold_reached ? |(d_rob_sel_idx & rb_h_priority) | ~(|d_rob_sel_idx) : 1'b1),
        .fire(fire_priority_check)
    );
    
    
    ovl_coverage #(.severity_level(3),.coverage_level(15),.property_type(2)) nc_write_starv_asserted (.clock(clk),
    .reset(reset_n),
    .enable(1'b1),
    .test_expr(starv_count[7]),
    .fire(fire_nc_write_starv_asserted)
    );
    
    ovl_coverage #(.severity_level(3),.coverage_level(15),.property_type(2)) nc_write_full_asserted (.clock(clk),
    .reset(reset_n),
    .enable(1'b1),
    .test_expr(&rb_req_valid),
    .fire(fire_nc_write_full_asserted)
    );
    
    \js }
    assert property (@(posedge clk) park_point_en |-> $onehot(park_point_d));
    
    // coverage on
    // pragma synthesis_on
    // synthesis_on
    `endif
    \js }
endmodule
