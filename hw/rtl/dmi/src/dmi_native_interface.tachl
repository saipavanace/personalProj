\jsbegin
//=============================================================================
// Copyright(C) 2018 Arteris, Inc.
// All rights reserved
//=============================================================================
// DMI Native Interface Block
// Author: Tso-Wei Chang
//=============================================================================
\jsend
\jsbegin
//
// Variables
//
var u               = obj.lib;
var m               = obj.userLib;
var bundleFunctions = m.bundleFunctions;
var axiAwIdWidth    = u.getParam('AXIInterface').aw_.id;
var axiArIdWidth    = u.getParam('AXIInterface').ar_.id;
var axiArLenWidth   = u.getParam('AXIInterface').ar_.len;
var wLen            = u.getParam('AXIInterface').ar_.len;
var wSize           = u.getParam('AXIInterface').ar_.size;
var wBurst          = u.getParam('AXIInterface').ar_.burst;
var wAddr           = u.getParam('AXIInterface').ar_.addr;
var wQos            = u.getParam('AXIInterface').ar_.qos;
var wCache          = u.getParam('AXIInterface').ar_.cache;
var wRegion         = u.getParam('AXIInterface').ar_.region;
// TODO: change this when software change is done
var wUser           = u.getParam('AXIInterface').ar_.user;
var wDataUser       = u.getParam('AXIInterface').w_.user; 
var wBUser          = u.getParam('AXIInterface').b_.user;
var nBytesPerBeat   = u.getParam('wData') / 8;
var wBytesPerBeat   = Math.log2(nBytesPerBeat);
var enOutputBuffer  = u.getParam('enOutputBuffer');
var enableReadDataInterleaving  = u.getParam('enableReadDataInterleaving');

var b_reverse = {};
var r_reverse = {};

Object.keys(obj.lib.getParam('AXIInterface', 'b_')).forEach(function (signal) {
        b_reverse[signal] = -1 * obj.lib.getParam('AXIInterface', 'b_', signal);
    }
);

Object.keys(obj.lib.getParam('AXIInterface', 'r_')).forEach(function (signal) {
        r_reverse[signal] = -1 * obj.lib.getParam('AXIInterface', 'r_', signal);
    }
);

\jsend

\jsbegin
//
// Interfaces
//
// Inputs
obj.lib.interface('',               'slave', u.getParam('clkInterface'));
obj.lib.interface('read_trans_',    'slave', u.getParam('readTransactionInterface'));
obj.lib.interface('write_trans_',   'slave', u.getParam('writeTransactionInterface'));
obj.lib.interface('write_data_',    'slave', u.getParam('writeDataInterface'));
// Outputs
obj.lib.interface('read_data_',     'master',u.getParam('readDataInterface'));
obj.lib.interface('write_resp_',    'slave', u.getParam('AXIInterface','b_'), ['id']);
obj.lib.port('output', 'write_resp_id', axiAwIdWidth);

// AXI Interface
obj.lib.interface('',               'master',u.getParam('AXIInterface'));
obj.lib.interface('',               'master',u.getParam('ntvCsrInterface'));
\jsend


module \=obj.lib.getModuleName()=\ (\=obj.lib.getPorts('\n')=\);
\jsbegin
//===========================================================
// Wires
//===========================================================
\jsend
wire                 q_read_data_first;
\jsbegin
if(!enableReadDataInterleaving) { \jsend
wire                 d_read_data_first;
wire                 en_read_data_first;
\jsbegin
} \jsend
wire [\=wAddr-1=\:0] read_addr_mask;
wire [\=wAddr-1=\:0] write_addr_mask;

\=bundleFunctions.wiresFromInterface('push_ar_', obj.lib.getParam('AXIInterface', 'ar_'), [], obj.lib.bundle)=\
\=bundleFunctions.wiresFromInterface('push_aw_', obj.lib.getParam('AXIInterface', 'aw_'), [], obj.lib.bundle)=\

\=bundleFunctions.wiresFromInterface('push_w_',  obj.lib.getParam('AXIInterface', 'w_'), [], obj.lib.bundle)=\
\=bundleFunctions.wiresFromInterface('pop_r_',   obj.lib.getParam('AXIInterface', 'r_'), [], obj.lib.bundle)=\
\=bundleFunctions.wiresFromInterface('pop_b_',   obj.lib.getParam('AXIInterface', 'b_'), [], obj.lib.bundle)=\

\jsbegin
//===========================================================
// Read Channel
//===========================================================
\jsend
\js // address needs to be aligned to data bus size for wrap transfers
assign read_addr_mask   = {\=wAddr-wBytesPerBeat=\'d0 ,{\=wBytesPerBeat=\{1'b1}}};
assign write_addr_mask  = {\=wAddr-wBytesPerBeat=\'d0 ,{\=wBytesPerBeat=\{1'b1}}};
\js // Drive AR from read_trans
assign push_ar_valid    = read_trans_valid;
assign push_ar_addr     = read_trans_addr[\=wAddr-1=\:0] & ~read_addr_mask;
\js // length is the number of beats in transfer, the transaction size divided by data bus width
\js // TODO: can synth handle this? because there may be an easy way
assign push_ar_len = (read_trans_size < \=wBytesPerBeat=\) ? \=wLen=\'h0 : ((\=wLen=\'b1 << read_trans_size) >> \=wBytesPerBeat=\) - \=wLen=\'b1;
\js // size is # bytes in a transfer, the data bus width
assign push_ar_size     = \=u.getParam('AXIInterface').ar_.size=\'d\=Math.log2(obj.lib.getParam('wData') / 8)=\;
assign push_ar_burst    = (|push_ar_len) ? \=wBurst=\'b10 : \=wBurst=\'b01;

\jsbegin
if(obj.lib.getParam("nExclusiveEntries") == 0){
\jsend
    assign push_ar_lock     = read_trans_es;
\jsbegin
}else{
\jsend
    assign push_ar_lock = 1'b0;
\jsbegin
}
\jsend
assign push_ar_prot     = {1'b0, read_trans_ns, read_trans_pr};
assign push_ar_id       = read_trans_id;
\jsbegin
// ar_region fixed to 0 for ncore3.2
/* istanbul ignore if env ncore_3p0,ncore_3p2,ncore_3p4,ncore_3p6, ncore_3p7 */
if ( wRegion != 0 ) {
\jsend
assign push_ar_region   = \=wRegion=\'d0;
\js }
assign push_ar_cache    = \=wCache=\'b0010;
\jsbegin
/* istanbul ignore if env ncore_3p0 */
    if( wUser != 0 ) {
\jsend
assign push_ar_user     = read_trans_user;
\js }

\js if (wQos != 0) {
assign push_ar_qos      = read_trans_qos;
\js }

assign read_trans_ready = push_ar_ready;

\js // Drive read_data from AXI R
assign read_data_valid  = pop_r_valid;
assign read_data_last   = pop_r_last;
assign read_data_first  = q_read_data_first;
assign read_data_id     = pop_r_id;
assign read_data_data   = pop_r_data;
assign read_data_resp   = pop_r_resp;
assign pop_r_ready      = read_data_ready;

\jsbegin
// ncore3.2 does not use w_user field
/* istanbul ignore if env ncore_3p0,ncore_3p2,ncore_3p4,ncore_3p6, ncore_3p7 */
    if( wDataUser != 0 ) {
\jsend
assign read_data_user   = pop_r_user;
\js }

\jsbegin
// read data first counter logic
// If read data interleaving is enabled, beats can come out of order and first is unable to
// calculate here. Will calculate first beat after read data buffer instead.
if(enableReadDataInterleaving) { \jsend
assign q_read_data_first = 1'b0;
\jsbegin
} else {\jsend
\=obj.lib.dffre(1, 'q_read_data_first', 'd_read_data_first', "1'b1", 'en_read_data_first', 'clk', 'reset_n')=\      
assign d_read_data_first = read_data_valid & read_data_ready & read_data_last;
assign en_read_data_first = read_data_valid & read_data_ready;
\jsbegin
} \jsend

\jsbegin
//===========================================================
// Write Channel
//===========================================================
\jsend
\js // Drive AXI AW from write_trans
assign push_aw_valid    = write_trans_valid;
assign write_trans_ready= push_aw_ready;
assign push_aw_addr     = write_trans_addr[\=wAddr-1=\:0] & ~write_addr_mask;
assign push_aw_len      = (write_trans_size < \=wBytesPerBeat=\) ? \=wLen=\'h0 : ((\=wLen=\'b1 << write_trans_size) >> \=wBytesPerBeat=\) - \=wLen=\'b1;
assign push_aw_size     = \=wSize=\'d\=Math.log2(obj.lib.getParam('wData') / 8)=\;
assign push_aw_burst    = (|push_aw_len) ? \=wBurst=\'b10 : \=wBurst=\'b01;
\jsbegin
if(obj.lib.getParam("nExclusiveEntries") ==0){
\jsend

assign push_aw_lock     = write_trans_es;
\jsbegin
}else{
\jsend
   assign push_aw_lock = 1'b0;
\jsbegin
}
\jsend

assign push_aw_prot     = {1'b0, write_trans_ns, write_trans_pr};
assign push_aw_id       = write_trans_id;
\js // this need to be 0010 for supporting mrd_flush with cache and evict
assign push_aw_cache    = \=wCache=\'b0010;
\jsbegin
// ar_region fixed to 0 for ncore3.2
/* istanbul ignore if env ncore_3p0,ncore_3p2,ncore_3p4,ncore_3p6, ncore_3p7 */
if ( wRegion != 0 ) {
\jsend
assign push_aw_region   = 'd0;
\js }
\jsbegin
/* istanbul ignore if env ncore_3p0 */
    if(obj.lib.getParam('AXIInterface','aw_', 'user') != 0) {
\jsend
assign push_aw_user     = write_trans_user;
\js }

\js if (wQos != 0) {
assign push_aw_qos      = write_trans_qos;
\js }

\js // Drive AXI W from write_data
assign push_w_valid     = write_data_valid;
assign write_data_ready = push_w_ready;
assign push_w_last      = write_data_last;
assign push_w_data      = write_data_data;
assign push_w_strb      = write_data_be & {\=nBytesPerBeat=\{~write_data_poison}};
\jsbegin
// ncore3.2 does not use w_user field
/* istanbul ignore if env ncore_3p0,ncore_3p2,ncore_3p4,ncore_3p6, ncore_3p7 */
    if( u.getParam('writeDataInterface', 'user') != 0) {
\jsend
assign push_w_user      = write_data_user;
\js } else /* istanbul ignore next env ncore_3p0,ncore_3p2,ncore_3p4,ncore_3p6, ncore_3p7 */ if( wDataUser != 0 ) {
assign push_w_user      = 'b0;
\js }

\js // Drive write_resp from AXI B 
assign write_resp_valid = pop_b_valid;
assign write_resp_id    = pop_b_id;
assign write_resp_resp  = pop_b_resp;
assign pop_b_ready      = write_resp_ready;

\js // FIXME
\jsbegin
    // ncore3.2 does not use w_user field
    /* istanbul ignore if env ncore_3p0,ncore_3p2,ncore_3p4,ncore_3p6, ncore_3p7 */
    if( wBUser != 0) {
\jsend
assign write_resp_user  = pop_b_user;
\js }

\js // Optional Ouput buffers: May be needed to cut long path from address translation

\=obj.lib.instance({
    instanceName: 'ar_fifo',
    moduleName: 'fifo_bundle',
    params: {
        width: bundleFunctions.getBundleWidth(obj.lib.getParam('AXIInterface', 'ar_'), ['valid', 'ready'], obj.lib.bundle),
        depth: 2,
        zerodepth: enOutputBuffer ? 0 : /* istanbul ignore next env ncore_3p2,ncore_3p4,ncore_3p6, ncore_3p7 */ 1,
        bypass_mode: enOutputBuffer ? 0 : /* istanbul ignore next env ncore_3p2,ncore_3p4,ncore_3p6, ncore_3p7 */ 1,
        interface: obj.lib.getParam('AXIInterface', 'ar_')
    },
    verilogParams: {},
    ports: {
        push_valid: 'push_ar_valid',
        push_ready: 'push_ar_ready',
        pop_valid: 'ar_valid',
        pop_ready: 'ar_ready'
    },
    interfaces: [
        {modulePrefix: '',      localPrefix: '',            interface: obj.lib.getParam('clkInterface')},
        {modulePrefix: 'push_', localPrefix: 'push_ar_',    interface: obj.lib.getParam('AXIInterface', 'ar_')},
        {modulePrefix: 'pop_',  localPrefix: 'ar_',         interface: obj.lib.getParam('AXIInterface', 'ar_')}
    ],
    portsDelimiter: '\n        '
})=\

\=obj.lib.instance({
    instanceName: 'aw_fifo',
    moduleName: 'fifo_bundle',
    params: {
        width: bundleFunctions.getBundleWidth(obj.lib.getParam('AXIInterface', 'aw_'), ['valid', 'ready'], obj.lib.bundle),
        depth: 2,
        zerodepth: enOutputBuffer ? 0 : /* istanbul ignore next env ncore_3p2,ncore_3p4,ncore_3p6, ncore_3p7 */ 1,
        bypass_mode: enOutputBuffer ? 0 : /* istanbul ignore next env ncore_3p2,ncore_3p4,ncore_3p6, ncore_3p7 */ 1,
        interface: obj.lib.getParam('AXIInterface', 'aw_')
    },
    verilogParams: {},
    ports: {
        push_valid: 'push_aw_valid',
        push_ready: 'push_aw_ready',
        pop_valid:  'aw_valid',
        pop_ready:  'aw_ready'
    },
    interfaces: [
        {modulePrefix: '',      localPrefix: '',            interface: obj.lib.getParam('clkInterface')},
        {modulePrefix: 'push_', localPrefix: 'push_aw_',    interface: obj.lib.getParam('AXIInterface', 'aw_')},
        {modulePrefix: 'pop_',  localPrefix: 'aw_',         interface: obj.lib.getParam('AXIInterface', 'aw_')}
    ],
    portsDelimiter: '\n        '
})=\

\=obj.lib.instance({
    instanceName: 'w_fifo',
    moduleName: 'fifo_bundle',
    params: {
        width: bundleFunctions.getBundleWidth(obj.lib.getParam('AXIInterface', 'w_'), ['valid', 'ready'], obj.lib.bundle),
        depth: 2,
        zerodepth: enOutputBuffer ? 0 : /* istanbul ignore next env ncore_3p2,ncore_3p4,ncore_3p6, ncore_3p7 */ 1,
        bypass_mode: enOutputBuffer ? 0 : /* istanbul ignore next env ncore_3p2,ncore_3p4,ncore_3p6, ncore_3p7 */ 1,
        interface: obj.lib.getParam('AXIInterface', 'w_')
    },
    verilogParams: {},
    ports: {
        push_valid: 'push_w_valid',
        push_ready: 'push_w_ready',
        pop_valid:  'w_valid',
        pop_ready:  'w_ready'
    },
    interfaces: [
        {modulePrefix: '',      localPrefix: '',            interface: obj.lib.getParam('clkInterface')},
        {modulePrefix: 'push_', localPrefix: 'push_w_',    interface: obj.lib.getParam('AXIInterface', 'w_')},
        {modulePrefix: 'pop_',  localPrefix: 'w_',         interface: obj.lib.getParam('AXIInterface', 'w_')}
    ],
    portsDelimiter: '\n        '
})=\

\=obj.lib.instance({
    instanceName: 'r_fifo',
    moduleName: 'fifo_bundle',
    params: {
        width: -bundleFunctions.getBundleWidth(obj.lib.getParam('AXIInterface', 'r_'), ['valid', 'ready'], obj.lib.bundle),
        depth: 4,
        zerodepth: enOutputBuffer ? 0 : /* istanbul ignore next env ncore_3p2,ncore_3p4,ncore_3p6, ncore_3p7 */ 1,
        bypass_mode: enOutputBuffer ? 0 : /* istanbul ignore next env ncore_3p2,ncore_3p4,ncore_3p6, ncore_3p7 */ 1,
        interface: r_reverse
    },
    verilogParams: {},
    ports: {
        push_valid: 'r_valid',
        push_ready: 'r_ready',
        pop_valid:  'pop_r_valid',
        pop_ready:  'pop_r_ready'
    },
    interfaces: [
        {modulePrefix: '',      localPrefix: '',            interface: obj.lib.getParam('clkInterface')},
        {modulePrefix: 'push_', localPrefix: 'r_',          interface: obj.lib.getParam('AXIInterface', 'r_')},
        {modulePrefix: 'pop_',  localPrefix: 'pop_r_',      interface: obj.lib.getParam('AXIInterface', 'r_')}
    ],
    portsDelimiter: '\n        '
})=\

\=obj.lib.instance({
    instanceName: 'b_fifo',
    moduleName: 'fifo_bundle',
    params: {
        width: -bundleFunctions.getBundleWidth(obj.lib.getParam('AXIInterface', 'b_'), ['valid', 'ready'], obj.lib.bundle),
        depth: 4,
        zerodepth: enOutputBuffer ? 0 : /* istanbul ignore next env ncore_3p2,ncore_3p4,ncore_3p6, ncore_3p7 */ 1,
        bypass_mode: enOutputBuffer ? 0 : /* istanbul ignore next env ncore_3p2,ncore_3p4,ncore_3p6, ncore_3p7 */ 1,
        interface: b_reverse
    },
    verilogParams: {},
    ports: {
        push_valid: 'b_valid',
        push_ready: 'b_ready',
        pop_valid:  'pop_b_valid',
        pop_ready:  'pop_b_ready'
    },
    interfaces: [
        {modulePrefix: '',      localPrefix: '',            interface: obj.lib.getParam('clkInterface')},
        {modulePrefix: 'push_', localPrefix: 'b_',          interface: obj.lib.getParam('AXIInterface', 'b_')},
        {modulePrefix: 'pop_',  localPrefix: 'pop_b_',      interface: obj.lib.getParam('AXIInterface', 'b_')}
    ],
    portsDelimiter: '\n        '
})=\
endmodule
