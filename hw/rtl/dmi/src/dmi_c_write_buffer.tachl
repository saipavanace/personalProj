//=============================================================================
// Copyright(C) 2018 Arteris, Inc.
// All rights reserved
//=============================================================================
\jsbegin
// DMI NC Write Buffer
// Author: Tso-Wei Chang
//=============================================================================

//=============================================================================
// Variables
//=============================================================================
var u = obj.lib;
var m = obj.userLib;

var ASILB = u.getParam("ASILB");
var rbidBuffer= obj.lib.getParam("rbidBuffer");

var wChipletId = u.getParam("wChipletId");
var wLinkId = u.getParam("wLinkId");
var log2ceil = function(n) { return Math.ceil(Math.log(n)/Math.LN2); };
var bundleFunctions     = m.bundleFunctions;
var nDmiRbEntries       = u.getParam('nDmiRbEntries');
var wDmiRbEntries    = log2ceil(nDmiRbEntries);
var wCacheLineOffset    = u.getParam('wCacheLineOffset');
var wStarvThreshold     = u.getParam("wStarvThreshold")
var RBReqInterface      = u.getParam('RBReqInterface');
var RBRRespInterface      = u.getParam('RBRRespInterface');
var DTWReqInterface     = u.getParam('DTWReqInterface');
var writeProtInterface  = u.getParam('writeProtInterface');
var writeDataInterface  = u.getParam('writeDataInterface');
var clkInterface        = u.getParam('clkInterface');
var useQos              =u.getParam('useQos');
var priorityThreshold   =u.getParam('priorityThreshold');
var wAddr               = RBReqInterface.addr;
var wRbid               = DTWReqInterface.rb_id;
var nBeats              = (1<<wCacheLineOffset) / (DTWReqInterface.data/8);
var wBeats              = Math.log2(nBeats);
var dataBufferSize      = nBeats * nDmiRbEntries;
var wDataBufferSize     = log2ceil(dataBufferSize);
var wCmType             = DTWReqInterface.cm_type;
var cmType              = u.getParam('cmType');
var wData               = DTWReqInterface.data;
var nDWsPerBeat         = wData/64;
var wDwid               = DTWReqInterface.dwid/nDWsPerBeat;
var wIntfSize           = DTWReqInterface.intf_size;
var wSize               = RBReqInterface.size;
var wQos                = writeProtInterface.qos;
var wMsgId              = RBReqInterface.message_id;
var wDataUser           = (DTWReqInterface.user == undefined)?  /* istanbul ignore next env ncore_3p2, ncore_3p4,ncore_3p6,ncore_3p7 */ 0 : DTWReqInterface.user;
// Add ports and logic for atomic support
var wMpf2               = u.getParam('wMpf2');
var assertOn            = u.getParam('assertOn');
var wPriority           =u.getParam("wPriority");
var nQos                        = Math.pow(2, wQos);

var wTm              =  1;
var wFUnitId         = u.getParam('wFUnitId');
var wFPortId = u.getParam('wFPortId');

if (wPriority){
    var QosInfo                     = u.getParam('QosInfo');
}


var dataBuffer = {
    intf_size:    DTWReqInterface['intf_size'],
    aux:          DTWReqInterface['aux'],
    initiator_id: DTWReqInterface['initiator_id'],
    message_id:   DTWReqInterface['message_id'],
    cm_type:      DTWReqInterface['cm_type'],
    rb_id :       DTWReqInterface['rb_id']-1,
    cm_status:    DTWReqInterface['cm_status'],
    rl:           DTWReqInterface['rl'],
    primary:      DTWReqInterface['primary'],
    mpf2:         DTWReqInterface['mpf2'],
    dwid:         DTWReqInterface['dwid'],
    dbad:         DTWReqInterface['dbad'],
    tm:           DTWReqInterface['tm']
};


Object.keys(u.getParam('writeDataInterface')).forEach(function (signal) {
    if ( signal !== 'poison') {
        dataBuffer[signal] = u.getParam('writeDataInterface',signal);
    }
});


var dtwRobInfo = Object.assign({}, dataBuffer);
['data', 'be', 'poison', 'last', 'valid', 'ready', 'dwid', 'user'].forEach(e => delete dtwRobInfo[e]);


dtwRobInfo['mw'] = 1;
dtwRobInfo['rb_initiator_id'] = RBReqInterface['initiator_id'];

if ( wQos != 0 ) {
dtwRobInfo['qos'] = RBReqInterface['qos'];
}
dtwRobInfo['RBGen'] = 1;
dtwRobInfo['tm'] = wTm;



var wRbidBuffer = bundleFunctions.getBundleWidth(rbidBuffer, [''], u.bundle);
var wDataBuffer = bundleFunctions.getBundleWidth(dataBuffer, ['valid', 'ready'], u.bundle);
var wRbrResp    =bundleFunctions.getBundleWidth(RBRRespInterface,["message_id","initiator_id","cm_status","m_prot","h_prot","t_tier","steering","ql","cm_type","valid","ready","priority"],u.bundle)
//=============================================================================
// Ports & Interfaces
//=============================================================================

var wrBufferProtType = u.getParam('wrBufferProtType');
var cWrDataGen       = u.getParam('cWrDataGen');
var cWrDataParam     = u.getParam('cWrDataParam');
 var memoryInterface  = u.getParam('wrDataBufferMemoryInterface');
var useExWrDataMem   = u.getParam('useExWrDataMem');
var prefix = cWrDataGen.rtlPrefixString;
    
if(useExWrDataMem) {
        u.interface('', 'master', memoryInterface);
 } 

    var wMemIndex        = log2ceil(dataBufferSize);

if ( wrBufferProtType !== 'NONE' ) {
    u.port('output', 'mem_uce',               1);
    u.port('output', 'mem_uce_index',         wMemIndex);
    }
    
    if ( wrBufferProtType === 'SECDED' ) {
    u.port('output', 'mem_ce',                1);
    u.port('output', 'mem_ce_index',          wMemIndex);
    }

u.port('input', 'csr_CECR_ErrDetEn',      1);
u.port('input', 'csr_UEDR_MemErrDetEn',   1);
        
u.interface('rb_req_',      'slave',    RBReqInterface, ['m_prot']);
u.interface('rb_rsp_',      'master',   RBRRespInterface, []);
u.interface('dtw_req_',     'slave',    DTWReqInterface);
u.interface('',             'slave',    clkInterface);
u.interface('write_prot_',  'master',   writeProtInterface);
u.interface('write_protd_', 'master',   writeDataInterface);

//Put in place for partial duplication. Nor used.
/* istanbul ignore if env ncore_3p7 */
if (ASILB){
    var rb_buffer_flop_bundle = u.getParam("rb_buffer_flop_bundle");
    u.interface(''    ,          'master', rb_buffer_flop_bundle);
}



obj.lib.port('input', 'MyId',                                   wFUnitId);

if(u.getParam("nGius")){
    var uChipletIdIntInterface = u.getParam("uChipletIdIntInterface");
    u.interface(uChipletIdIntInterface.name, uChipletIdIntInterface.direction,uChipletIdIntInterface.getSignalsBundle())
    }
if(useQos & priorityThreshold){
u.port('input', 'WTT_threshold_reached',                              1);
u.port('input', 'WttQoSRsv',                                          8);
u.port("input","QoSThVal",wQos);
u.port('input','starv_threshold',wStarvThreshold);
u.port('input','starv_en',1);
}


u.port('output', 'write_prot_initiator_id', RBReqInterface.initiator_id);
u.port('output', 'write_protd_orig_trans_id',                    wMsgId);

u.port('output', 'write_data_initiator_id', RBReqInterface.initiator_id);
u.port('output', 'active',                                            1);


\jsend
module \=u.getModuleName()=\ (\=u.getPorts('\n')=\);

//=============================================================================
// Functions & Local params
//=============================================================================

function automatic is_dtwmergemrd;
input [\=wCmType-1=\:0] cm_type;
begin
    is_dtwmergemrd = (cm_type == \=cmType['DtwMrgMrdInv']=\)   |
                     (cm_type == \=cmType['DtwMrgMrdUCln']=\) | (cm_type == \=cmType['DtwMrgMrdUDty']=\);
end
endfunction

\js if(wPriority) {
    function automatic [\=wPriority-1=\:0] pri_gen;
        input [\=wQos-1=\:0] qos;
        reg   [\=nQos-1=\:0] qos_one_hot;
        begin
            qos_one_hot = \=nQos=\'b1 << qos;
            pri_gen     = 
    \js for (let bucket_vec of QosInfo.qosMap) {
            |(qos_one_hot & \=bucket_vec=\)? \=wPriority=\'d\=QosInfo.qosMap.indexOf(bucket_vec)=\ : 
    \js }
            \=wPriority=\'d0;
        end
    endfunction
    \js }

//=============================================================================
// Wires
//=============================================================================
\js var wrProtExclude = ['rl', 'mpf1', 'valid', 'ready', 'cm_type', 'initiator_id', 'rb_id', 'mpf2', 'cm_status', 'message_id', 'intf_size', 'tm', 'user'];
\=bundleFunctions.wiresFromInterface('write_prot_',     dataBuffer, wrProtExclude,  u.bundle)=\

\jsbegin
for (var i=0;i<nDmiRbEntries;i++){
\jsend
    \=bundleFunctions.wiresFromInterface('rb_id_buffer_'+i+"_",   rbidBuffer, [],             u.bundle)=\
    wire [\=wRbidBuffer-1=\:0]                  rb_id_buffer_\=i=\;
    wire  [\=wRbidBuffer-1=\:0] d_rb_id_buffer_\=i=\;

    \jsbegin
    if(useQos){
    \jsend
        wire  [\=wRbidBuffer-1=\:0] d_rb_id_buffer_starvation_\=i=\;
        \=bundleFunctions.wiresFromInterface('d_rb_id_buffer_starvation_'+i+"_",   rbidBuffer, [],             u.bundle)=\
    \jsbegin
    }
    \jsend


\jsbegin
}
\jsend
\=bundleFunctions.wiresFromInterface('rb_id_buffer_pre_read_',   rbidBuffer, [],             u.bundle)=\
wire [\=wDmiRbEntries-1=\:0] rb_id_buffer_pre_read_rb_id;
\=bundleFunctions.wiresFromInterface('rb_pop_',   rbidBuffer, ["tm"],             u.bundle)=\
wire [\=wDmiRbEntries-1=\:0]   rb_pop_rb_id;
\=bundleFunctions.wiresFromInterface('dtw_pop_',        dataBuffer, [],      u.bundle)=\


wire [\=nDmiRbEntries-1=\:0] data_generation_id,d_data_generation_id,rb_data_generation_id_compare,rb_generation_id;
wire generation_id_enable;
wire                                        rb_id_buffer_pre_read_ready;
wire                                        already_valid;
wire                                        rb_pop_valid;
wire                                        data_fifo_active;
wire                                        rd_wr_bank_conflict;
wire                                        dtw_drb_sent_d;
wire                                        dtw_drb_sent_en;
wire                                        dtw_drb_sent;
wire                                        write_prot_valid_data;
wire                                        rb_id_error;
wire                                        dtw_req_poison;
wire                                        wr_valid;
wire  [\=dataBufferSize-1=\:0]               rob_grant_beat_dec;
wire [\=dataBufferSize-1=\:0]               data_valid;
wire [\=dataBufferSize-1=\:0]               d_data_valid;
wire                                        data_valid_en;
wire [\=dataBufferSize-1=\:0]               data_last;
wire [\=dataBufferSize-1=\:0]               d_data_last;
reg  [\=nDmiRbEntries-1=\:0]                req_data_valid;
wire [\=nDmiRbEntries-1=\:0]                d_rb_id_valid;
wire [\=nDmiRbEntries-1=\:0]                set_rb_id_valid;
wire [\=nDmiRbEntries-1=\:0]                clr_rb_id_valid;
wire [\=nDmiRbEntries-1=\:0]                rb_id_valid;
wire [\=RBReqInterface['initiator_id']-1=\:0] rb_id_retire_initiator_id;
wire                                        rb_release;
wire                                        write_drb;
wire                                        rb_id_valid_en;
wire                                        rb_id_alloc_en;
wire [\=nDmiRbEntries-1=\:0]                rb_id_alloc_idx;
wire [\=nDmiRbEntries-1=\:0]                rb_id_valid_head_vec;
wire [\=nDmiRbEntries-1=\:0]                rob_grant_idx;
wire [\=nDmiRbEntries-1=\:0]                write_prot_grant_idx;
wire [\=nDmiRbEntries-1=\:0]                rob_qual_idx;

\jsbegin
if(useQos){
\jsend
wire rb_req_h_priority;
wire [\=nDmiRbEntries-1=\:0] rb_h_priority;
wire [\=nDmiRbEntries-1=\:0] d_rb_h_priority;
wire starv_count_en;
wire entry_starv_overflow_en;
wire[\=wStarvThreshold-1=\:0] starv_count,starv_count_d;
wire[\=nDmiRbEntries-1=\:0] entry_starv_overflow, entry_starv_overflow_d;
wire starv_overflow_event;
\jsbegin
}
\jsend

wire  [\=nDmiRbEntries-1=\:0]               first_beat_valid;


wire                                        rob_in_valid;
wire                                        rob_in_ready;
wire [\=DTWReqInterface.dwid-1=\:0]         rob_dwid;
wire [\=wSize-1=\:0]                        rob_in_size;
wire [\=wSize-1=\:0]                        rob_size_q;
wire [\=wDwid-1=\:0]                        rob_in_cdw;
wire [\=wDwid-1=\:0]                        rob_cdw_q;
\=bundleFunctions.wiresFromInterface('rob_',            dtwRobInfo, ['dwid',"RBGen"],       u.bundle)=\

wire [\=wIntfSize-1=\:0]                    fixed_intfSize = \=wIntfSize=\'d\=Math.log2(wData/64)=\;
wire [\=nDmiRbEntries-1=\:0]                dtw_rb_id_1h;
wire [\=wDataBufferSize-1=\:0]              wr_ptr;
wire [\=wDataBufferSize-1=\:0]              wr_ptr_inc;
wire [\=wDataBufferSize-1=\:0]              wr_ptr_inc_d;
wire [\=wDataBufferSize-1=\:0]              wr_ptr_start;
wire [\=dataBufferSize-1=\:0]               wr_ptr_dec;
wire [\=dataBufferSize-1=\:0]               rd_ptr_dec;
wire                                        wr_ptr_sel_inc;
wire                                        wr_ptr_sel_inc_d;
wire                                        dtw_req_en;
wire                                        write_prot_first;
wire                                        d_write_prot_first;
wire                                        en_write_prot_first;
wire                                        write_prot_data_first;
wire                                        d_write_prot_data_first;
wire                                        en_write_prot_data_first;

wire [\=wRbidBuffer-1=\:0]                  d_rb_id_buffer;
wire [\=wRbidBuffer-1=\:0]                  rb_id_buffer_pre_read;

wire                                        write_prot_mw;

wire                                        dtw_pop_first;
wire                                        d_dtw_pop_first;
wire                                        dtw_pop_last_en;

wire [\=dataBufferSize-1=\:0]               rd_ptr_next;
wire [\=dataBufferSize-1=\:0]               rd_ptr_next_d;
wire                                        rd_ptr_busy;
wire                                        rd_ptr_busy_d;
wire                                        rd_ptr_en;
wire                                        rd_ptr_busy_en;


wire                                        write_prot_ready_data;
wire                                        write_prot_poison;

wire [\=wDataBufferSize-1=\:0]              rob_grant_idx_enc;
wire                                        rob_bypass = 1'b0;
wire                                        rob_busy_info_en;
wire                                        rb_id_retire_RBGen;


wire [\=wFUnitId+u.getParam("wChipletId")=\ : 0] myid_shift;
wire rb_id_retire_valid;
\jsbegin
if (wQos>1){
\jsend
    wire [\=wQos-1=\:0]                         rb_id_retire_qos;
    wire [\=wQos-1=\:0]                         rb_rsp_qos;
\jsbegin
}
\jsend
wire [\=nDmiRbEntries-1=\ : 0] rb_id_retire;
wire [\=wTm-1=\ : 0] rb_id_retire_tm;
wire rb_req_generation_id;



wire push0_valid;
wire push0_ready;
wire [\=wRbrResp+wQos=\:0] push0_data ;
wire push1_valid;
wire push1_ready;
wire[\=wRbrResp+wQos=\:0]  push1_data ;
wire pop_valid  ;
wire pop_ready  ;
wire [\=wRbrResp+wQos=\:0] pop_data   ;
wire [\=log2ceil(nDmiRbEntries)-1=\ :0] rb_id_retire_bin;

wire [\=log2ceil(nDmiRbEntries)-1=\:0] pop_index;
wire pop_en;

wire push_rb_dealloc_valid;
wire push_rb_dealloc_ready;
wire [\=log2ceil(nDmiRbEntries)-1=\:0] push_rb_dealloc_rb_id;
wire pop_rb_dealloc_valid;
wire pop_rb_dealloc_ready;
wire [\=log2ceil(nDmiRbEntries)-1=\:0]  pop_rb_dealloc_rb_id;
//=============================================================================
// RBID Buffer
//=============================================================================

assign active             = data_fifo_active | (|data_valid) | write_prot_valid_data | pop_valid | rb_req_valid;

assign rb_req_generation_id = rb_req_rb_id[\=wRbid-1=\];


assign d_rb_id_buffer    = \=bundleFunctions.packetizeBundle('rb_req_', rbidBuffer, [], u.bundle)=\;

assign rb_id_valid_en     = (rb_req_valid  & rb_req_ready) | rb_id_retire_valid ;

assign d_rb_id_valid      = set_rb_id_valid | (rb_id_valid & ~clr_rb_id_valid);

assign rb_id_alloc_idx    = {\=nDmiRbEntries=\{rb_req_valid}} & (\=nDmiRbEntries=\'d1 << rb_req_rb_id[\=wRbid-2=\:0]);

assign set_rb_id_valid    =  rb_id_alloc_idx ;
assign clr_rb_id_valid    =  rb_id_retire & {\=nDmiRbEntries=\{rb_id_retire_valid}};

assign rb_id_alloc_en     = rb_req_valid;

\=u.dffre(nDmiRbEntries, 'rb_id_valid',  'd_rb_id_valid',  nDmiRbEntries+"'b0", 'rb_id_valid_en', 'clk', 'reset_n')=\

//the release is now when the buffer is valid but the request has a different generationID
assign rb_release = rb_req_ready & already_valid;

\jsbegin 
if (useQos){
\jsend

    wire [\=wPriority-1=\:0]  rb_priority;
    assign rb_priority    = pri_gen(rb_req_qos);
    assign rb_req_h_priority = ~(rb_req_qos < QoSThVal);
    \jsbegin
    //Starvation logic
    \jsend

    assign starv_count_d = (starv_count[\=wStarvThreshold-1=\:0] == starv_threshold) ? \=wStarvThreshold=\'d0 : starv_count + 1'b1;

    assign starv_count_en = rb_id_retire_valid & starv_en | starv_overflow_event ;

    assign starv_overflow_event = (starv_count[\=wStarvThreshold-1=\:0] == starv_threshold) & (starv_threshold != \=wStarvThreshold=\'b0) & starv_en;

    assign entry_starv_overflow_d = (entry_starv_overflow & ~clr_rb_id_valid )   | ( rb_id_valid_head_vec & first_beat_valid[\=nDmiRbEntries-1=\:0] & {\=nDmiRbEntries=\{starv_overflow_event}});
    assign entry_starv_overflow_en = starv_count_en | (rb_release & starv_en | starv_overflow_event);



    \=u.dffre(wStarvThreshold,    'starv_count',            'starv_count_d',              wStarvThreshold+"'d0",    'starv_count_en',           'clk',  'reset_n')=\
    \=u.dffre(nDmiRbEntries,        'entry_starv_overflow',   'entry_starv_overflow_d',     nDmiRbEntries+"'d0",        'entry_starv_overflow_en',  'clk',  'reset_n')=\


    \jsbegin
    //end Starvation logic
    \jsend

    assign d_rb_h_priority      = (set_rb_id_valid & {\=nDmiRbEntries=\{rb_req_h_priority}}) | (rb_h_priority & ~clr_rb_id_valid) | (rb_id_valid & entry_starv_overflow & {\=nDmiRbEntries=\{starv_overflow_event}}) ;

    \=u.dffre(nDmiRbEntries,'rb_h_priority','d_rb_h_priority', nDmiRbEntries+"'b0", 'rb_id_valid_en | starv_overflow_event', 'clk', 'reset_n')=\

\jsbegin
for (var i=0;i<nDmiRbEntries;i++){
\jsend

    assign d_rb_id_buffer_starvation_\=i=\  = \=bundleFunctions.packetizeBundle("d_rb_id_buffer_starvation_"+i+"_", rbidBuffer, [], u.bundle)=\;
    \=bundleFunctions.assignByBundle("d_rb_id_buffer_starvation_"+i+"_","rb_id_buffer_"+i+"_",rbidBuffer,["priority"],u.bundle)=\

    assign d_rb_id_buffer_starvation_\=i=\_priority = \=wPriority=\'d0;
    assign d_rb_id_buffer_\=i=\     = (rb_id_valid[\=i=\] & entry_starv_overflow[\=i=\]  & starv_overflow_event) ? d_rb_id_buffer_starvation_\=i=\: d_rb_id_buffer;

\jsbegin
}
\jsend


\jsbegin
} else {
    for (var i=0;i<nDmiRbEntries;i++){
\jsend

        assign d_rb_id_buffer_\=i=\     = d_rb_id_buffer;

\jsbegin
    }
}
\jsend 

\jsbegin
//Put in place for partial duplication. Nor used.
/* istanbul ignore if env ncore_3p7 */
if(ASILB){
\jsend
    assign      en_rb_buffer_vec = set_rb_id_valid ;

    \js for(var i =0; i<nDmiRbEntries;i++){

        assign      d_rb_buffer_vec[\=i*wRbidBuffer=\ +: \=wRbidBuffer=\] = d_rb_id_buffer_\=i=\;
        assign      rb_id_buffer_\=i=\ = q_rb_buffer_vec[\=i*wRbidBuffer=\ +: \=wRbidBuffer=\];
        assign \=bundleFunctions.packetizeBundle('rb_id_buffer_'+i+"_", rbidBuffer, [], u.bundle)=\ = rb_id_buffer_\=i=\;
\jsbegin
    }   
} else {
\jsend
        \js for (var i = 0; i < nDmiRbEntries; i++) {

        \=u.dffre(wRbidBuffer, 'rb_id_buffer_'+i,      'd_rb_id_buffer_'+i,       wRbidBuffer+"'b0",  'set_rb_id_valid['+i+']', 'clk', 'reset_n')=\
        assign \=bundleFunctions.packetizeBundle('rb_id_buffer_'+i+"_", rbidBuffer, [], u.bundle)=\ = rb_id_buffer_\=i=\;
       
       \js }
\jsbegin
}
\jsend


assign rb_id_buffer_pre_read = (rb_id_buffer_0 & {\=wRbidBuffer=\{rob_grant_idx[0]}})
                    \js for (var i = 1; i < nDmiRbEntries; i++) {
                                            |(rb_id_buffer_\=i=\ & {\=wRbidBuffer=\{rob_grant_idx[\=i=\]}})
                    \js }
                                            ; 
                                            
                                            
 assign \=bundleFunctions.packetizeBundle('rb_id_buffer_pre_read_', rbidBuffer, [], u.bundle)=\ = rb_id_buffer_pre_read;

 \=u.instance({
    instanceName: 'Rb_id_pre_read',
    moduleName: 'encoder',
    params: {
        width: nDmiRbEntries,
    },
    verilogParams: {},
    ports: {
        invector:   'rob_grant_idx',
        outdecode:  'rb_id_buffer_pre_read_rb_id',
    },
    interfaces: [],
    portsDelimiter: '\n        '
})=\



assign already_valid = |(rb_id_valid & rb_id_alloc_idx) & rb_req_valid;       

\jsbegin
//=============================================================================
// DTW Buffer
//=============================================================================
\jsend



assign dtw_pop_last_en  = dtw_pop_valid & dtw_pop_ready;
assign d_dtw_pop_first  = dtw_pop_valid & dtw_pop_ready & dtw_pop_last;
assign dtw_req_poison   = |dtw_req_dbad;
assign dtw_req_en       = dtw_req_valid & dtw_req_ready;
assign write_drb        = dtw_pop_valid & dtw_pop_ready; 


\=u.dffre(dataBufferSize,   'data_valid',       'd_data_valid',           dataBufferSize+"'b0",     'data_valid_en',    'clk', 'reset_n')=\
\=u.dffre(dataBufferSize,   'data_last',       'd_data_last',           dataBufferSize+"'b0",     'dtw_req_en',    'clk', 'reset_n')=\
\=u.dffre(wDataBufferSize,  'wr_ptr_inc',       'wr_ptr_inc_d',           wDataBufferSize+"'b0",    'dtw_req_en',       'clk', 'reset_n')=\
\=u.dffre(1,                'wr_ptr_sel_inc',   'wr_ptr_sel_inc_d',       "1'b0",                   'dtw_req_en',       'clk', 'reset_n')=\
\=u.dffre(1,                'dtw_pop_first',    'd_dtw_pop_first',        "1'b1",                   'dtw_pop_last_en',  'clk', 'reset_n')=\

\jsbegin
 // Write
\jsend


assign dtw_rb_id_1h     = \=nDmiRbEntries=\'d1 << dtw_req_rb_id[\=wRbid-2=\:0];

assign wr_ptr_start     = {dtw_req_rb_id[\=wDataBufferSize-wBeats-1=\:0] , \=wBeats=\'b0};
assign wr_ptr_sel_inc_d =~dtw_req_last;
assign wr_ptr_inc_d     = wr_ptr + \=wDataBufferSize=\'b1;
assign wr_ptr           = wr_ptr_sel_inc ? wr_ptr_inc : wr_ptr_start;
assign wr_ptr_dec       = (\=dataBufferSize=\'d1 << wr_ptr);

assign d_data_valid = (wr_ptr_dec & {\=dataBufferSize=\{dtw_req_en}}) | (data_valid & ~(rd_ptr_dec & {\=dataBufferSize=\{rd_ptr_en}}));
assign d_data_last = (data_valid & data_last ) | (wr_ptr_dec & {\=dataBufferSize=\{dtw_req_last}});

assign data_valid_en =  dtw_req_en | rd_ptr_en;

wire read_ready;
assign wr_valid         = dtw_pop_valid & read_ready;

\jsbegin
// generation ID storage for data
//and creation of a vector comapring the rb entry generation id and the data generation id
\jsend


assign d_data_generation_id = ( \=nDmiRbEntries=\'d1 << dtw_req_rb_id[\=wRbid-2=\:0] & {\=nDmiRbEntries=\{dtw_req_en & dtw_req_rb_id[\=wRbid-1=\]}} ) | (first_beat_valid & data_generation_id)  ;
assign generation_id_enable = dtw_req_en & ~wr_ptr_sel_inc;
\=u.dffre(nDmiRbEntries,   'data_generation_id',       'd_data_generation_id',           nDmiRbEntries+"'b0",     'generation_id_enable',    'clk', 'reset_n')=\

//this creates a vector from the buffer entry
assign rb_generation_id =  {rb_id_buffer_\=nDmiRbEntries-1=\_generation_id
\jsbegin
for(var i=nDmiRbEntries-2;i>-1;i--){
\jsend
                            ,rb_id_buffer_\=i=\_generation_id
\jsbegin
}
\jsend
                        };


assign rb_data_generation_id_compare = rb_generation_id ~^ data_generation_id ;

assign rd_ptr_en        = |(rd_ptr_dec & data_valid )& ~(dtw_req_en & rd_wr_bank_conflict ) & read_ready;


wire [\=wDataBufferSize-1=\: 0 ] rd_ptr, rd_ptr_n,rd_ptr_dec_n;

assign rd_ptr_busy_en   = rd_ptr_en;

assign rd_ptr_busy_d    =~(rd_ptr_en & |(data_last & rd_ptr_dec));
assign rd_ptr_next_d    = rd_ptr_en ? rd_ptr_dec << 1: rd_ptr_dec;
assign rd_ptr_dec       = (rd_ptr_busy ? rd_ptr_next :  rob_grant_beat_dec);


assign rd_ptr_n = rd_ptr_en ? rd_ptr_dec_n + \=wDataBufferSize=\'d1 : rd_ptr_dec_n;
assign rd_ptr_dec_n = rd_ptr_busy ? rd_ptr: rob_grant_idx_enc;

\=u.dffre(wDataBufferSize,   "rd_ptr",   "rd_ptr_n",   wDataBufferSize+"'b0",  'rd_ptr_busy_en', 'clk', 'reset_n')=\

\=u.dffre(dataBufferSize,   'rd_ptr_next',   'rd_ptr_next_d',   dataBufferSize+"'b0",  'rd_ptr_busy_en', 'clk', 'reset_n')=\
\=u.dffre(1,                'rd_ptr_busy',   'rd_ptr_busy_d',                 "1'b0",  'rd_ptr_busy_en', 'clk', 'reset_n')=\


wire rd_busy_en, rd_busy_d,rd_busy;


assign rd_busy_en   = dtw_pop_valid & dtw_pop_ready;
assign rd_busy_d    =~(dtw_pop_valid & dtw_pop_ready& dtw_pop_last);
\=u.dffre(1,                'rd_busy',   'rd_busy_d',                 "1'b0",  'rd_busy_en', 'clk', 'reset_n')=\
\jsbegin

for ( var i = 0; i < nDmiRbEntries; i++) {
\jsend
    assign rob_grant_beat_dec[\=nBeats*(i+1)-1=\:\=nBeats*i=\] = {\=nBeats-1=\'b0, rob_grant_idx[\=i=\]};
\jsbegin
 }
\jsend


\=u.instance({
    instanceName: 'grant_idx_encoder',
    moduleName: 'encoder',
    params: {
        width: nDmiRbEntries*nBeats,
    },
    verilogParams: {},
    ports: {
        invector:   'rob_grant_beat_dec',
        outdecode:  'rob_grant_idx_enc',
    },
    interfaces: [],
    portsDelimiter: '\n        '
})=\



assign rb_id_valid_head_vec = rb_id_valid ; 




\jsbegin
//=============================================================================
// DTW ROB
//=============================================================================
\jsend

\jsbegin 
if (useQos & priorityThreshold){
\jsend

    assign rob_qual_idx = rb_data_generation_id_compare & rb_id_valid_head_vec & first_beat_valid[\=nDmiRbEntries-1=\:0] & ((WTT_threshold_reached) ? rb_h_priority :{\=nDmiRbEntries=\{1'b1}});

\jsbegin 
}
else{
\jsend
    assign rob_qual_idx = rb_data_generation_id_compare & rb_id_valid_head_vec  & first_beat_valid[\=nDmiRbEntries-1=\:0] ;
    
\jsbegin 
    }

    for ( var i = 0; i < nDmiRbEntries; i++ ) {
\jsend
    assign first_beat_valid[\=i=\] = data_valid[\=i*nBeats=\];
\jsbegin
 }
 \jsend

\jsbegin

var ArbiterParams ={
    assertOn : assertOn,
    usePipe : 1,
    pipeOption : 0,
    useOnehotIndex: 0,
    nPorts: nDmiRbEntries,
    wPorts: log2ceil(nDmiRbEntries),
    nEntries : nDmiRbEntries+1
}
if (useQos) {
    ArbiterParams["nPrio"]= 2**wPriority
    ArbiterParams["wPrio"]= wPriority
}

var ArbiterPort={};
ArbiterPort["clk"]="clk";
ArbiterPort["reset_n"]="reset_n";
ArbiterPort["push_en"]="rb_req_valid";
ArbiterPort["push_index"]="rb_id_alloc_idx";
ArbiterPort["pop_en"]="pop_en"    
ArbiterPort["pop_index"]="pop_index" ;
if (useQos>0) {
for (var i = 0; i < nDmiRbEntries; i++) {
    ArbiterPort["req"+i+"_prio"]="rb_id_buffer_"+i+"_priority";
    }
}
ArbiterPort["req_vec"]="rob_qual_idx";
ArbiterPort["grant"]="";
ArbiterPort["grant_ack"]="rd_ptr_en & ~rd_ptr_busy";
ArbiterPort["grant_vec"]="rob_grant_idx";
ArbiterPort["grant_index"]="";
ArbiterPort["valid_vec"]="";
ArbiterPort["empty"]="";
ArbiterPort["full"]="";


if (useQos) {
\jsend
    \=u.instance({
        instanceName : "Arbiter",
        moduleName:"com_arb_qos_age",
        params:ArbiterParams,
        ports: ArbiterPort
    })=\
\jsbegin
} else {
\jsend
\=u.instance({
        instanceName: 'Arbiter',
        moduleName: 'com_arb_age_buf',
        params: ArbiterParams,
        ports: ArbiterPort,
        portsDelimiter: '\n        '
    })=\
\jsbegin
}
\jsend


assign write_prot_late_resp_id = \=writeProtInterface.late_resp_id=\'d0;

\jsbegin

var DtwDrbParams = { 
    clkInterface        : clkInterface,
    width               : wData,
    wDwid               : wDwid,
    wIntfSize           : wIntfSize,
    wTransSize          : wSize,
    dataInfoInterface   : dtwRobInfo,
    nBeats              : nBeats,
    wrData              : 1,
    bypassable          : 0,
    wUser               : wDataUser,
    nRbs                : nDmiRbEntries,
    coherent            : 1,
    wMsgId              :wMsgId,
    assertOn            : assertOn
};

var DtwDrbPorts = {  
    critical_dw         : 'rob_in_cdw',
    intf_size           : 'fixed_intfSize',
    data_beat_in        : 'dtw_pop_data',
    data_beat_in_valid  : 'rob_in_valid',
    data_beat_in_last   : 'dtw_pop_last',
    data_beat_in_dwid   : 'dtw_pop_dwid',
    data_beat_in_be     : 'dtw_pop_be',
    data_beat_in_dbad   : 'dtw_pop_dbad',
    trans_size          : 'rob_in_size',
    alloc_RBGen    : "rb_pop_generation_id",
    
    data_beat_out_ready : 'write_prot_ready_data',
    data_beat_out       : 'write_prot_data',
    data_beat_out_be    : 'write_prot_be',
    data_beat_out_dbad  : 'write_prot_dbad',
    data_beat_out_valid : 'write_prot_valid_data',
    data_beat_out_last  : 'write_prot_last',
    data_beat_out_dwid  : 'rob_dwid',
    data_beat_in_ready  : 'rob_in_ready',
    
    rb_id_retire        : 'rb_id_retire',
    rb_id_retire_valid  : 'rb_id_retire_valid'

};

var offsetrbid = (wRbid-1)==wDmiRbEntries ? "" : ((wRbid-1) -wDmiRbEntries)+"'d0,"
    DtwDrbPorts["rb_id_retire_RBGen"]="rb_id_retire_RBGen";
    DtwDrbPorts['rb_id_retire_tm'] = 'rb_id_retire_tm';
    DtwDrbPorts["rb_id_retire_initiator_id"]= "rb_id_retire_initiator_id";
    DtwDrbPorts['alloc_mw'] = 'rb_pop_mw';
    DtwDrbPorts['alloc_rb_initiator_id'] = 'rb_pop_initiator_id';
    DtwDrbPorts["alloc_rb_id"] = "{"+ offsetrbid+"rb_pop_rb_id}";
if ( wQos != 0 ) {
        DtwDrbPorts['alloc_qos'] = 'rb_pop_qos';
        DtwDrbPorts['rb_id_retire_qos'] = 'rb_id_retire_qos'
}


var dtwDrbInterfaces = [];
dtwDrbInterfaces.push({modulePrefix: '',         localPrefix: '',             interface: clkInterface       });
dtwDrbInterfaces.push({modulePrefix: 'lookup_',  localPrefix: 'rob_',         interface: dtwRobInfo,exclude:["RBGen"] });
dtwDrbInterfaces.push({modulePrefix: 'alloc_',   localPrefix: 'dtw_pop_',     interface: dtwRobInfo , exclude :['mw', 'rb_initiator_id','qos',"RBGen","rb_id"]        });

\jsend

    \=u.instance({
        instanceName:'dtw_drb',
        moduleName  :'dmi_drb',
        params      : DtwDrbParams,
        ports       : DtwDrbPorts,
        interfaces  : dtwDrbInterfaces,
    })=\


\js // clear over set.
    assign dtw_drb_sent_d           =(rob_in_valid & rob_in_ready) &~(dtw_pop_valid & dtw_pop_ready);
    assign dtw_drb_sent_en          =(rob_in_valid & rob_in_ready) | (dtw_pop_valid & dtw_pop_ready);
    \=u.dffre(1, 'dtw_drb_sent',  'dtw_drb_sent_d',  "1'b0", 'dtw_drb_sent_en', 'clk', 'reset_n')=\

    assign dtw_pop_ready            = (rob_in_ready | dtw_drb_sent) & (write_prot_ready | ~write_prot_first);
    assign rob_in_valid             = dtw_pop_valid & ~dtw_drb_sent;

    assign rob_in_size              = rd_busy ? rob_size_q : (dtw_pop_primary ? rb_pop_size : \=wSize=\'d\=wCacheLineOffset=\);
    assign rob_in_cdw               = rd_busy ? rob_cdw_q  : write_prot_addr[\=wCacheLineOffset-1=\:\=wCacheLineOffset-wDwid=\];



    \=u.dffre(wSize, 'rob_size_q', 'write_prot_size',  wSize+"'b0", 'rob_busy_info_en', 'clk', 'reset_n')=\
    \=u.dffre(wDwid, 'rob_cdw_q',  'write_prot_addr['+(wCacheLineOffset-1)+':'+(wCacheLineOffset-wDwid)+']',  wDwid+"'b0", 'rob_busy_info_en', 'clk', 'reset_n')=\

    assign rob_busy_info_en = write_prot_valid & write_prot_ready;
    assign write_prot_grant_idx     = rob_grant_idx;




assign write_prot_poison        =|write_prot_dbad;
assign write_prot_aiu_id        = is_dtwmergemrd(dtw_pop_cm_type) ?
                                                                        {\=u.getParam("nGius") >0 ? "dtw_pop_initiator_id["+(wFUnitId+wChipletId+wLinkId-1)+":"+(wFUnitId+wChipletId)+"]," : ""=\dtw_pop_mpf1[\=(wFUnitId+wChipletId-1)=\:0], \=wFPortId=\'d0} : 
                                                                        dtw_pop_initiator_id;
assign write_prot_aiu_trans_id  = is_dtwmergemrd(dtw_pop_cm_type) ? dtw_pop_mpf2[\=wMsgId-1=\:0] : dtw_pop_message_id;
assign write_data_initiator_id  = dtw_pop_initiator_id;
assign write_prot_trans_id      = \=writeProtInterface.trans_id=\'d0;
assign write_prot_primary       = dtw_pop_primary;
assign write_protd_orig_trans_id= rob_message_id;  
assign write_prot_cm_type       = dtw_pop_cm_type;
assign write_protd_mpf1         = \=writeProtInterface.mpf1=\'d0;
assign write_prot_vz            = is_dtwmergemrd(dtw_pop_cm_type) ? (dtw_pop_rl == 2'b11) : rb_pop_vz;
assign write_prot_intf_size     = is_dtwmergemrd(dtw_pop_cm_type) ? dtw_pop_intf_size : \=writeProtInterface.intf_size=\'b0;
assign write_prot_mpf1          = dtw_pop_mpf1;
assign write_prot_dwid          = dtw_pop_dwid;
assign write_prot_es            = \=writeProtInterface.es=\'d0;
\jsbegin
if(obj.lib.getParam("nExclusiveEntries")>0){
\jsend
    assign write_prot_ex_pass       = 1'b1;
\jsbegin
}
\jsend

assign write_prot_mpf2          = \=writeProtInterface.mpf2=\'d0;
assign write_prot_size      = dtw_pop_primary ? rb_pop_size : \=wSize=\'d\=wCacheLineOffset=\;


\js if ( wQos != 0 ) {
    assign write_prot_qos       = rb_pop_qos;
\js }
    assign write_prot_tm        = dtw_pop_tm;
    assign rb_id_error          = rb_pop_rb_id >= \=nDmiRbEntries=\;
    assign write_protd_poison   = |write_prot_dbad;

\jsbegin
//=============================================================================
// Output
//=============================================================================

if(writeProtInterface.user != 0) {
\jsend
    assign write_prot_user = rb_pop_aux;
\jsbegin
} 
\jsend

\=bundleFunctions.assignByBundle('write_prot_', 'rb_pop_', rbidBuffer, ['es', 'cm_type', 'valid', 'vz', 'mpf1', 'size',  'qos',"tm","aux","message_id","priority","generation_id"], u.bundle)=\



assign write_prot_valid  = (dtw_drb_sent | dtw_pop_valid) & write_prot_first;
assign write_protd_valid = write_prot_valid_data;
assign write_prot_ready_data = write_protd_ready;

\=bundleFunctions.assignByBundle('write_protd_', 'write_prot_', writeDataInterface, ['valid','ready','mpf1', 'user', 'poison'], u.bundle)=\



\=u.dffre(1, 'write_prot_first',  'd_write_prot_first',  "1'b1", 'en_write_prot_first', 'clk', 'reset_n')=\
assign d_write_prot_first  =  dtw_pop_valid & dtw_pop_ready & dtw_pop_last;
assign en_write_prot_first = (write_prot_valid & write_prot_ready) | (dtw_pop_valid & dtw_pop_ready);

\=u.dffre(1, 'write_prot_data_first',  'd_write_prot_data_first',  "1'b1", 'en_write_prot_data_first', 'clk', 'reset_n')=\
assign d_write_prot_data_first  =  write_protd_valid & write_protd_ready & write_protd_last;
assign en_write_prot_data_first = (write_protd_valid & write_protd_ready);






\jsbegin
var rb_fifo_bundle = rbidBuffer
rb_fifo_bundle["valid"]=1;
rb_fifo_bundle["ready"]=-1;
rb_fifo_bundle["addr"]=wAddr;
rb_fifo_bundle["rb_id"]=wDmiRbEntries;
delete rb_fifo_bundle["tm"];
var rb_FifoInterfaces = [];
rb_FifoInterfaces.push({modulePrefix: '', localPrefix: '',            interface: clkInterface,  exclude: []               });
rb_FifoInterfaces.push({modulePrefix: 'push_',  localPrefix: 'rb_id_buffer_pre_read_',    interface: rb_fifo_bundle, exclude:["valid"] });
rb_FifoInterfaces.push({modulePrefix: 'pop_',  localPrefix: 'rb_pop_',    interface: rb_fifo_bundle, exclude: ["ready"] });
var rb_FifoPorts ={ 
    push_valid :" read_ready & rd_ptr_en & ~rd_ptr_busy ",
    pop_ready : "dtw_pop_valid & dtw_pop_ready & dtw_pop_first"
}

    
    var rb_FifoParams = {
        width           : bundleFunctions.getBundleWidth(rb_fifo_bundle, ['valid', 'ready'], u.bundle),
        depth           : 9,
        zerodepth       : 0,
        bypass_mode     : 0,
        interface       : rb_fifo_bundle
    }

\jsend
    
    \=u.instance({
        instanceName    : 'rb_fifo',
        moduleName      : 'fifo_bundle',
        params          : rb_FifoParams,
        verilogParams   : {},
        ports           : rb_FifoPorts,
        interfaces      : rb_FifoInterfaces,
     })=\


\jsbegin

var dataFifoPorts= {
    csr_UEDR_MemErrDetEn: 'csr_UEDR_MemErrDetEn',
    csr_CECR_ErrDetEn   : 'csr_CECR_ErrDetEn',
    active : 'data_fifo_active'
};
var dataFifoParams = {
    clkInterface    : clkInterface,
    memoryInterface : memoryInterface,
    dataReqInterface: dataBuffer,
    depth           : dataBufferSize,
    width           : bundleFunctions.getBundleWidth( dataBuffer, ['valid', 'ready'], u.bundle),
    memParam        : cWrDataParam,
    memGen          : cWrDataGen,
    memProtType     : wrBufferProtType,
    assertOn        : assertOn,
    nPorts          : cWrDataParam.nPorts,
    nBanks          : cWrDataParam.nBanks,
    fastRead        : 0,
    nBeats          : nBeats
};

var dataFifoInterfaces = [];
dataFifoInterfaces.push({modulePrefix: '',                  localPrefix: '',            interface: clkInterface,    exclude: []});
dataFifoInterfaces.push({modulePrefix: 'data_req_in_',      localPrefix: 'dtw_req_',    interface: dataBuffer,      exclude: ["rb_id"]});    
dataFifoInterfaces.push({modulePrefix: 'data_req_out_',     localPrefix: 'dtw_pop_',    interface: dataBuffer,      exclude: ["ready"]});
if ( useExWrDataMem ) {
    dataFifoInterfaces.push({modulePrefix: '',                  localPrefix: '',            interface: memoryInterface, exclude: []});
};

if ( wrBufferProtType !== 'NONE' ) {
    dataFifoPorts['mem_uce_valid'] = 'mem_uce';
    dataFifoPorts['mem_uce_index'] = 'mem_uce_index';
};

if ( wrBufferProtType === 'SECDED' ) {
    dataFifoPorts['mem_ce_valid'] = 'mem_ce';
    dataFifoPorts['mem_ce_index'] = 'mem_ce_index';
};
dataFifoPorts["data_req_in_rb_id"] =  "dtw_req_rb_id[" + (wRbid-2) + ":0]";

dataFifoPorts["data_req_out_ready"] =  "dtw_pop_ready";
dataFifoPorts["rd_ptr"] =  "{1'b0,rd_ptr_dec_n}";
dataFifoPorts["rd_en"] =  "rd_ptr_en";
dataFifoPorts["wr_ptr"] =  "{1'b0,wr_ptr}";
dataFifoPorts["wr_en"] =  "dtw_req_en";
dataFifoPorts["read_ready"] =  "read_ready";
dataFifoPorts["rd_wr_bank_conflict"] = "rd_wr_bank_conflict"


\jsend
\=u.instance({
    instanceName: 'data_fifo',
    moduleName  : 'dmi_write_data_fifo',
    params      : dataFifoParams,
    ports       : dataFifoPorts,
    interfaces  : dataFifoInterfaces
})=\

\jsbegin
//Rbr resp generation.
//An rbr_resp is generated when :
// - an entry is allocated on a valid rb_id buffer and the generation ID do not match (release)
// - An entry is freed by a successfull write (data was received)
// We will store both response in a dual port fifo to avoid stalling one of the two path
\jsend


\=u.instance({
    instanceName: 'rb_id_retire_encode',
    moduleName: 'encoder',
    params: {
        width: nDmiRbEntries,
    },
    verilogParams: {},
    ports: {
        invector:   'rb_id_retire',
        outdecode:  'rb_id_retire_bin',
    },
    interfaces: [],
    portsDelimiter: '\n        '
})=\


wire pop_need_clear;
assign push0_valid = rb_req_valid & already_valid;
assign rb_req_ready = push0_ready;
assign push0_data = {1'b0,\=wQos? "rb_req_qos," : ""=\rb_req_initiator_id, ~rb_req_rb_id[\=wRbid-1=\],rb_req_rb_id[\=wRbid-2=\:0], rb_req_tm};

assign push1_valid =rb_id_retire_valid;
assign push1_data = {1'b1,\=wQos? "rb_id_retire_qos\," :"" =\rb_id_retire_initiator_id,rb_id_retire_RBGen,\= (wRbid-1-log2ceil(nDmiRbEntries) > 0) ? (wRbid-log2ceil(nDmiRbEntries)-1) + "'d0\," :""=\rb_id_retire_bin, rb_id_retire_tm};


\=u.instance({moduleName: "multiport_fifo",
            instanceName: "rbr_rsp_fifo",
            params :{   depth: 2*nDmiRbEntries+1,
                        number_of_inputs : 2,
                        width : 1+wRbrResp+wQos},
            ports:  {   push0_valid : "push0_valid",
                        push0_ready : "push0_ready",
                        push0_data  : "push0_data",
                        push1_valid : "push1_valid",
                        push1_ready : "push1_ready",
                        push1_data  : "push1_data",
                        pop_valid   : "pop_valid",
                        pop_ready   : "pop_ready",
                        pop_data    : "pop_data",
                        clk: "clk",
                        reset_n:"reset_n"}
        })=\

assign {pop_need_clear,\=wQos? "rb_rsp_qos,":""=\rb_rsp_target_id,rb_rsp_rb_id,rb_rsp_tm}=pop_data ;

assign rb_rsp_valid          = pop_valid & ~(push0_valid & push0_ready & pop_need_clear);
assign pop_ready = rb_rsp_ready & ~(push0_valid & push0_ready & pop_need_clear);

\js if(wPriority) {
assign rb_rsp_priority = pri_gen(rb_rsp_qos);
\js }

assign myid_shift                   = {\=u.getParam("nGius") >0 ? uChipletIdIntInterface.name+"my_chiplet_id," : ""=\MyId, {\=wFPortId=\{1'b0}}} ;
assign rb_rsp_initiator_id   = \=u.getParam("nGius") >0 ? "{"+wLinkId+"'d0,myid_shift}" : "myid_shift"=\ ;
assign rb_rsp_cm_type        = \=cmType['RbrRsp']=\;
assign rb_rsp_message_id     =  \=u.getParam('RBRRespInterface').message_id=\'d0;
assign rb_rsp_cm_status      = \=u.getParam('RBRRespInterface').cm_status=\'d0;
\js if (u.getParam('RBRRespInterface').m_prot > 0 ) {
assign rb_rsp_m_prot         = \=u.getParam('RBRRespInterface').m_prot=\'d0;
\js }

\js if(u.getParam('RBRRespInterface').h_prot > 0) {
assign rb_rsp_h_prot         = \=u.getParam('RBRRespInterface').h_prot=\'d0;
\js }



\jsbegin
// adds a fifo to serialize the clearing of the entry in the arbiter. If an rb_req wants to clear at the same time as an rb_id retires,
// then the rb_req is cleared first and the rb_id_retires is sent to the fifo
// the fifo is ready whenever there is no rb_req trying to clear the buffer
var rb_deallocPorts ={ 
    push_valid : "push_rb_dealloc_valid",
    push_ready : "push_rb_dealloc_ready",
    push_data :  "push_rb_dealloc_rb_id",
    pop_valid : "pop_rb_dealloc_valid",
    pop_ready : "pop_rb_dealloc_ready",
    pop_data :  "pop_rb_dealloc_rb_id",
    clk : "clk",
    reset_n : "reset_n"
}

    
    var rb_deallocParams = {
        width           : log2ceil(nDmiRbEntries) ,
       depth           : nDmiRbEntries ,
        zerodepth       : 0,
        bypass_mode     : 1
    }

\jsend

assign pop_en = (push0_valid & push0_ready) | (pop_need_clear & rb_rsp_valid & rb_rsp_ready);

assign pop_index =  (rb_req_rb_id[\=log2ceil(nDmiRbEntries)-1=\:0] & {\=log2ceil(nDmiRbEntries)=\{push0_valid & push0_ready}} ) | 
                        (rb_rsp_rb_id[\=log2ceil(nDmiRbEntries)-1=\:0] & {\=log2ceil(nDmiRbEntries)=\{pop_need_clear & rb_rsp_valid}}) ;



\js if ( assertOn ) {
    `ifdef OVL_ASSERT_ON
    // synthesis_off
    // pragma synthesis_off
    // coverage off
    \js if(useQos){
        wire [2:0] fire_c_write_starv_asserted;
        wire [2:0] fire_rb_req_full_asserted;
        wire [2:0] fire_Threshold;
        wire [2:0] fire_wrong_counter;
        wire [7:0] q2_ttQoSRsv;
        wire [2:0] fire_priority_check;
        wire [2:0] fire_rb_check;


    
    \=u.dffre(8,"q2_ttQoSRsv","q_ttQoSRsv","8'b0","1'b1","clk","reset_n")=\

    ovl_implication #(.severity_level(0), .msg("c buffer threshold has the wrong value"), .coverage_level(15) ) c_Threshold (   .clock(clk), 
                                                    .reset(reset_n), 
                                                    .enable(1'b1),
                                                    .antecedent_expr(1'b0),
                                                    .consequent_expr( wDataBuffer_threshold_reached | q_ttQoSRsv != q2_ttQoSRsv),
                                                    .fire(fire_Threshold));

    ovl_always #(.severity_level(0), .msg("c buffer free entry counter is out of sync"), .coverage_level(15) ) c_rb_coutner (   .clock(clk), 
                                                    .reset(reset_n), 
                                                    .enable(1'b1),
                                                    .test_expr(1'b1),
                                                    .fire(fire_wrong_counter));

 wire WTT_threshold_reached_q;

  \=u.dffre(1, 'WTT_threshold_reached_q',  'WTT_threshold_reached',  "1'b0", "1'b1", 'clk', 'reset_n')=\
                                                
 ovl_always #(.severity_level(0), .msg("a low priority request was selected while threshold is asserted")) priority_check (
                                                     .clock(clk),
                                                     .reset(reset_n),
                                                     .enable(1'b1),
                                                     .test_expr(WTT_threshold_reached_q ? |(rob_grant_idx & rb_h_priority) | ~(|rob_grant_idx) : 1'b1),
                                                     .fire(fire_priority_check)
                                                 );

    ovl_always #(.severity_level(0), .msg("An rbr request with a different generation id came while the previous received data and was not finished")) rb_check (
                                                        .clock(clk),
                                                        .reset(reset_n),
                                                        .enable(1'b1),
                                                        .test_expr($test$plusargs("smi_ndp_err_inj") ? 1'b1 : ~(rb_req_valid & (already_valid & (|(rb_data_generation_id_compare & rb_id_valid_head_vec & first_beat_valid[\=nDmiRbEntries-1=\:0] & rb_id_alloc_idx) ) ) )  ),
                                                        .fire(fire_rb_check)
                                                    );                                                

     ovl_coverage #(.severity_level(3),.coverage_level(15),.property_type(2)) rb_req_full_asserted (.clock(clk),
                                                    .reset(reset_n),
                                                    .enable(1'b1),
                                                    .test_expr(&rb_req_valid),
                                                    .fire(fire_rb_req_full_asserted)
                                                   );


                                                                                        
\js }
wire [2:0] dtw_ready;
        ovl_implication #(.severity_level(0), .msg("a dtw is valid but the buffer is not ready"), .coverage_level(15) ) assert_dtw_ready (   .clock(clk), 
        .reset(reset_n), 
        .enable(1'b1),
        .antecedent_expr(dtw_req_valid),
        .consequent_expr( dtw_req_ready),
        .fire(dtw_ready));

        wire [2:0] rbr_rsp_0;
ovl_implication #(.severity_level(0), .msg("a dtw is valid but the buffer is not ready"), .coverage_level(15) ) Push0implication (   .clock(clk), 
                                                       .reset(reset_n), 
                                                       .enable(1'b1),
                                                       .antecedent_expr(push0_valid),
                                                       .consequent_expr( push0_ready),
                                                       .fire(rbr_rsp_0));
    
         wire [2:0] rbr_rsp_1;
ovl_implication #(.severity_level(0), .msg("a dtw is valid but the buffer is not ready"), .coverage_level(15) ) push1_implication (   .clock(clk), 
                                                                                                      .reset(reset_n), 
                                                                                                      .enable(1'b1),
                                                                                                      .antecedent_expr(push1_valid),
                                                                                                      .consequent_expr( push1_ready),
                                                                                                      .fire(rbr_rsp_1));
    
    // assert_implication #(0) assert_rb_fifo_overflow (
    //     .clk(clk),
    //     .reset_n(reset_n),
    //     .consequent_expr(read_ready & rd_ptr_en & ~rd_ptr_busy),
    //     .antecedent_expr(dtw_pop_valid & dtw_pop_ready & dtw_pop_first)
    // );
    // coverage on
    // pragma synthesis_on
    // synthesis_on
    `endif
    \js }
endmodule
