//=============================================================================
// Copyright (C) 2018 Arteris, Inc.
// All rights reserved.
//=============================================================================
\jsbegin
// DMI Write Response
// Author: Steve Kromer
// 
// Issue responses for writes.
// Early response as soon as writes leaves protocol control.
// Late response for some writes come from AXI b response.
// Very late response for dtwmergemrd only
// 
// Features:
// - buffer to hold info for very late response
// - mux between early and late responses
//
// Future:
// - buffer can handle all late writes and not just dtw_mergemrd,
//   instead of storing aiu_id/aiu_trans_id in wtt just need trans_id
//=========================================================================

var u = obj.lib;
var bundleFunctions   = obj.userLib.bundleFunctions;

var clkInterface      = u.getParam('clkInterface');
var respInterface     = u.getParam('respInterface');
var DTWRespInterface  = u.getParam('DTWRespInterface');
var wData             = u.getParam('wData');
var wCmstatus         = DTWRespInterface['cm_status'];
var wId               = u.getParam('wTransId');
var depth             = u.getParam('depth');
var wIndex            = Math.ceil(Math.log2(depth));
var wQos              = respInterface.qos;
var wTm               = (DTWRespInterface.tm != undefined) ? 1 :  /* istanbul ignore next env ncore_3p2,ncore_3p4,ncore_3p6, ncore_3p7 */ 0;
var nQos              = Math.pow(2, wQos);
var wPriority         = DTWRespInterface.priority;
var useQos            = (wQos != 0);
// DTR interface
var wMessageId        = u.getParam('wMessageId');
var QosInfo           = u.getParam('QosInfo');
var assertOn          = u.getParam('assertOn');
//=========================================================================
// ports
//=========================================================================
u.interface('',          'slave',                clkInterface);

// smi input
u.port('input',          'msg_valid',            1);
u.port('output',         'msg_ready',            1);
u.port('input',          'msg_last',             1);
u.port('input',          'msg_drop',             1);
u.port('input',          'msg_error',            2);
u.port('input',          'msg_vz',               1);
u.port('input',          'msg_late',             1);
u.port('input',          'msg_data',             wData);

// downstream
u.port('output',         'req_valid',             1);
u.port('output',         'req_trans_id',          wId);
u.port('input',          'req_ready',             1);

// late resp
u.port('input',          'resp_valid',            1);
u.port('output',         'resp_ready',            1);
u.port('input',          'resp_vz',               1);
u.port('input',          'resp_resp',             2);
u.port('input',          'resp_data',             wData);

// very late resp
u.port('input',          'dtr_req_valid',         1);
u.port('input',          'dtr_req_ready',         1);
u.port('input',          'dtr_req_last',          1);
u.port('input',          'dtr_req_rd_type',       1);
u.port('input',          'dtr_req_message_id',    wMessageId);
u.port('input',          'dtr_req_late',          1);
u.port('input',          'dtr_req_trans_id',      wId);

u.port('input',          'dtr_resp_valid',        1);
u.port('output',         'dtr_resp_ready',        1);
u.port('input',          'dtr_resp_r_message_id', wMessageId);
u.port('output',         'pre_dtr_resp_vlate_match',  1);
u.port('input',          'pre_dtr_resp_r_message_id',wMessageId)

u.port('output',         'active',   1);

// resp output
u.interface('dtw_resp_', 'master',                DTWRespInterface, ['initiator_id']);

\jsend

module \=u.getModuleName()=\ (\=u.getPorts('\n')=\);

parameter SLV_ERR = 0, 
          DEC_ERR = 1;

\js if ( wPriority != 0 ) {
function automatic [\=wPriority-1=\:0] pri_gen;
    input [\=wQos-1=\:0] qos;
    reg   [\=nQos-1=\:0] qos_one_hot;
    begin
        qos_one_hot = \=nQos=\'b1 << qos;
        pri_gen     = 
\js for (var bucket_vec of QosInfo.qosMap) {
        |(qos_one_hot & \=bucket_vec=\)? \=wPriority=\'d\=QosInfo.qosMap.indexOf(bucket_vec)=\ : 
\js }
        \=wPriority=\'d0;
    end
endfunction
\js }

localparam NULL_ID = \=wId=\'d0;

    //
    // Wires
    //
    wire req_late;

    wire pre_alloc_valid;
    wire pre_alloc_ready;
    wire alloc_valid;
    wire alloc_ready;
    wire [\=wId-1=\:0] alloc_id;

    wire dealloc_valid;
    wire [\=wId-1=\:0] dealloc_id;

    wire vlate_valid;
    wire [\=wIndex-1=\:0] vlate_resp_id;

    wire late_valid;
    wire late_ready;

    wire early_en;
    wire early_valid;
    wire need_early_resp;

    wire rmsg_valid;
    wire rmsg_ready;
    wire [\=wData-1=\:0] rmsg_data;

    wire msg_droperr;
    wire msg_en;
    wire [1:0] resp_error;
    wire [1:0] late_resp_error;
    wire       late_resp_exokay;
    wire [1:0] rmsg_error;
    wire [1:0] dtw_resp_error;
    wire       dtw_resp_exokay;
    wire       rmsg_exokay;
    wire late_priority;
    wire early_sel;
    wire vlate_ready;
    wire dtw_resp_last;

\js if ( wQos != 0 ) {
    wire [\=wQos-1=\:0] dtw_resp_qos;
\js }


\js if (DTWRespInterface.m_prot != 0) {
    assign dtw_resp_m_prot     = \=DTWRespInterface.m_prot=\'d0;
\js }

\js if (DTWRespInterface.h_prot != 0) {
    assign dtw_resp_h_prot     =  \=DTWRespInterface.h_prot=\'d0;
\js }
\jsbegin
// ncore3 does not implement tier/steering/ql
/* istanbul ignore if env ncore_3p0,ncore_3p2,ncore_3p4,ncore_3p6, ncore_3p7 */
    if (DTWRespInterface.steering != 0) {
\jsend
    assign dtw_resp_steering   =  \=DTWRespInterface.steering=\'d0;
\js }
\jsbegin
// ncore3 does not implement tier/steering/ql
/* istanbul ignore if env ncore_3p0,ncore_3p2,ncore_3p4,ncore_3p6, ncore_3p7 */
    if (DTWRespInterface.t_tier != 0) {
\jsend
    assign dtw_resp_t_tier     =  \=DTWRespInterface.t_tier=\'d0;
\js }

\jsbegin
// ncore3 does not implement tier/steering/ql
/* istanbul ignore if env ncore_3p0,ncore_3p2,ncore_3p4,ncore_3p6, ncore_3p7 */
    if (DTWRespInterface.ql != 0) {
\jsend
    assign dtw_resp_ql         = \=DTWRespInterface.ql=\'d0;
\js }

//    wire 

    //
    // Allocate
    //
    \=u.instance({
        instanceName: 'alloc_flm',
        moduleName: 'dmi_flm',
        params: { clkInterface: clkInterface,
                  idNum: depth,
                  idWidth: wId 
                },
        verilogParams: {},
        interfaces: [{modulePrefix: '', localPrefix: '', interface: clkInterface}],
        ports: {  pre_alloc_valid: 'pre_alloc_valid',
                  pre_alloc_ready: 'pre_alloc_ready',
                  pre_alloc_last:  'msg_last',
                  alloc_valid:     'alloc_valid',
                  alloc_ready:     'alloc_ready',
                  alloc_id:        'alloc_id',
                  dealloc_valid:   'dealloc_valid',
                  dealloc_id:      'dealloc_id'
               },
        portsDelimiter: '\n        '
    })=\

    // if late  response, alloc to assign id and save in buffer. 
    //    So far, this only applies to dtw_mergemrd, where late response delayed until dtrrsp.
    //    Writes may have late response, but this is handled outside of this module.
    // if early response, don't allocate and use the NULL_ID
    assign req_late        = msg_late;
    assign msg_droperr     = msg_drop | (|msg_error);
    assign need_early_resp = msg_last & ((~msg_vz & ~msg_late) | msg_droperr);
    assign pre_alloc_valid = msg_valid &  msg_late;
    assign msg_en          = need_early_resp ? early_en : ~(msg_late & ~pre_alloc_ready);
    assign msg_ready       = (req_ready | msg_droperr) & msg_en;

    assign req_valid       = msg_valid & ~msg_droperr  & msg_en;
    assign req_trans_id    = req_late ? alloc_id    : NULL_ID;
    assign alloc_ready     = req_ready;

    //
    // Msg attribute Buffer
    //
    // currently only use buffer for late response info
    wire [\=wData-1=\:0] vlate_rmsg_info;
    wire [\=depth-1=\:0] msg_info_en;

    assign msg_info_en = (alloc_valid & alloc_ready) ? (\=depth=\'b1 << alloc_id) : \=depth=\'b0;

    \js for (var entry = 0; entry < depth; entry++) {
    wire [\=wData-1=\:0] msg_info_\=entry=\;
    \=u.dffre(wData,      'msg_info_'+entry,   'msg_data',  wData+"'b0", 'msg_info_en['+entry+']', 'clk', 'reset_n')=\

    \js }

    wire [\=depth-1=\ : 0] msg_info_sel;

    \jsbegin
    
        var vlate_rmsg_info_ports = {};
    
        for (i=0; i<depth ;i++) {
            vlate_rmsg_info_ports['in'+i] = "msg_info_"+i;
        \jsend
        assign msg_info_sel[\=i=\] = (vlate_resp_id == \=wIndex=\'d\=i=\);
        \jsbegin
        }
        
        vlate_rmsg_info_ports['sel']   = "msg_info_sel";
        vlate_rmsg_info_ports['out']   = "vlate_rmsg_info";
    \jsend  
          
    
        
        \=u.instance({
                instanceName: 'u_write_oid',
                moduleName: 'ao_mux',
                params: {
                                nInputs          : depth,
                                wMux             : wData
                },
                verilogParams: {},
                ports: vlate_rmsg_info_ports
        })=\
    
    // 
    // Late Response Buffer
    //
    wire late_valid_d;
    wire late_push_valid;
    wire [\=wData-1=\:0] late_resp_data;
    \=u.dffre(wData,  'late_resp_data',   'resp_data',  wData+"'b0",  'late_push_valid', 'clk', 'reset_n')=\
    \=u.dffre(2,      'late_resp_error',  'resp_error',      "2'b0",  'late_push_valid', 'clk', 'reset_n')=\
    \=u.dffre(1,      'late_resp_exokay', 'resp_resp[0]',    "1'b0",  'late_push_valid', 'clk', 'reset_n')=\

    \=u.dffre(1,      'late_priority',    '~resp_ready',     "1'b0",  '1\'b1', 'clk', 'reset_n')=\
    \=u.dffre(1,      'late_valid',       'late_valid_d',    "1'b0",  '1\'b1', 'clk', 'reset_n')=\

    assign late_valid_d    = late_push_valid | (late_valid & ~late_ready);
    assign late_push_valid = resp_valid & resp_vz & resp_ready;

    // if already have a late response and can't send it downstream, then backpressure
    assign resp_ready      = ~(late_valid & ~late_ready);

    assign resp_error      = {(resp_resp == 2'b11), (resp_resp == 2'b10)}; 

    //
    // Early/Late Response Mux
    // 
    // vlate has highest priority
    // early gets next prioirty unless
    // late gets priority if have a late in buffer and didn't go first cycle
    // late_priority comes out of a flop for timing reasons

    assign early_en        = ~late_priority & ~vlate_valid & rmsg_ready; 
    assign early_valid     = early_en & msg_valid & msg_ready & need_early_resp;
    assign early_sel       = early_en & msg_valid & need_early_resp;

    assign rmsg_valid      = vlate_valid | late_valid | early_valid;
    assign rmsg_data       = vlate_valid ? vlate_rmsg_info :
                             early_sel   ? msg_data :
                                           late_resp_data;
    assign rmsg_error      = vlate_valid ? 2'b0 :
                             early_sel   ? msg_error : late_resp_error;
    assign rmsg_exokay     = vlate_valid ? 1'b0 :
                             early_sel   ? 1'b0 : late_resp_exokay; 
                                            
    assign vlate_ready     = rmsg_ready;
    assign late_ready      = rmsg_ready & ~vlate_valid & ~early_sel;

    assign dealloc_valid   = vlate_valid & vlate_ready;
\jsbegin
//waived for 3.7 dues to the change of teh mrd size which modified the transise
/* istanbul ignore if env ncore_3p0,ncore_3p7 */
    if ( wId > wIndex ) {
\jsend
    assign dealloc_id      = {{\=wId-wIndex=\{1'b0}}, vlate_resp_id};
\js } else {
    assign dealloc_id      = vlate_resp_id;
\js }
    //
    // Very Late for DTWMergMRD
    // 
    // First save trans_id in buffer corresponding to dtr message id
    wire valid_new;
    wire valid_en;
    wire [\=depth-1=\:0] valid_set;
    wire [\=depth-1=\:0] valid_clr;
    wire [\=depth-1=\:0] valid_d;
    wire [\=depth-1=\:0] valid;
    wire [\=wMessageId-1=\:0] index_d;
    wire [\=wMessageId-1=\:0] index[\=depth-1=\:0];
    wire [\=wIndex-1=\:0] vlate_match_id;

    reg  [\=depth-1=\:0]  vlate_match_vector;
    reg [\=depth-1=\:0]   pre_vlate_match;
    assign index_d         =  dtr_req_message_id;
    assign valid_new       =  dtr_req_valid  & dtr_req_ready & ~dtr_req_rd_type & dtr_req_late & dtr_req_last;
    assign valid_en        = (dtr_resp_valid & dtr_resp_ready) | valid_new;
    assign valid_set       =  valid_new ? \=depth=\'b1 << dtr_req_trans_id : \=depth=\'d0;
    assign valid_clr       = (dtr_resp_valid & dtr_resp_ready) ? vlate_match_vector : \=depth=\'d0;
    assign valid_d         = valid_set | (valid & ~valid_clr);

    \=u.dffre(depth,      'valid',   'valid_d',   depth+"'b0", 'valid_en', 'clk', 'reset_n')=\

    // Index Buffer
    \js for (var entry = 0; entry < depth; entry++) {
    wire [\=wMessageId-1=\:0] index_\=entry=\;
    assign index[\=entry=\] = index_\=entry=\;
    \=u.dffre(wMessageId,      'index_'+entry,   'index_d',   wMessageId+"'b0", 'valid_set['+entry+']', 'clk', 'reset_n')=\

    \js }


    // Cam resp r_message_id with index to select buffer #
    integer i;
    always @(*) begin
        for (i = 0; i < \=depth=\; i = i + 1) begin
            pre_vlate_match[i] =  valid[i] & (index[i] == pre_dtr_resp_r_message_id);
            vlate_match_vector[i] = (valid[i] & (index[i] == dtr_resp_r_message_id)) & dtr_resp_valid & dtr_resp_ready;
        end
    end
   
    assign vlate_match_id = \=wIndex=\'d0 & {\=wIndex=\{vlate_match_vector[0]}}
\js for(var i = 1; i< depth; i++) {
    | (\=wIndex=\'d\=i=\ & {\=wIndex=\{vlate_match_vector[\=i=\]}}) 
\js }
    ;



    // Very Late Response Buffer
    // When dtr_resp returns, use message to read index, and save to very late buffer
    // Buffer is just one entry to ease timing
    //
    wire vlate_valid_d;
    wire vlate_push_valid;
    \=u.dffre(wIndex, 'vlate_resp_id', 'vlate_match_id', wIndex+"'b0", 'vlate_push_valid', 'clk', 'reset_n')=\
    \=u.dffre(1,      'vlate_valid',   'vlate_valid_d',  "1'b0", '1\'b1', 'clk', 'reset_n')=\

    assign vlate_valid_d    = vlate_push_valid | (vlate_valid & ~vlate_ready);
    assign vlate_push_valid = |vlate_match_vector;

    // dtr resp ready should never back pressure if dtw resp sized to credits because vlate gets top priority
    assign dtr_resp_ready  = ~(vlate_valid & ~vlate_ready);
    assign pre_dtr_resp_vlate_match =  |pre_vlate_match;
    //
    // Push to DTW Resp Skid buffer
    //
\jsbegin
var dtwRespFifoPorts = {
        push_valid: 'rmsg_valid',
        push_ready: 'rmsg_ready', 
        push_data:  '{rmsg_exokay, rmsg_error, rmsg_data}',
        pop_valid:  'dtw_resp_valid',
        pop_ready:  'dtw_resp_ready'
}

if ( wQos != 0 ) {
/* istanbul ignore else env ncore_3p2,ncore_3p4,ncore_3p6, ncore_3p7 */
    if (wTm) { 
dtwRespFifoPorts['pop_data'] = '{dtw_resp_exokay, dtw_resp_error, dtw_resp_tm, dtw_resp_target_id, dtw_resp_r_message_id, dtw_resp_qos}';
    } else {
dtwRespFifoPorts['pop_data'] = '{dtw_resp_exokay, dtw_resp_error, dtw_resp_target_id, dtw_resp_r_message_id, dtw_resp_qos}';
    }
} else {
/* istanbul ignore else env ncore_3p2,ncore_3p4,ncore_3p6, ncore_3p7 */
    if (wTm) {
dtwRespFifoPorts['pop_data'] = '{dtw_resp_exokay, dtw_resp_error, dtw_resp_tm, dtw_resp_target_id, dtw_resp_r_message_id}';
    } else {
dtwRespFifoPorts['pop_data'] = '{dtw_resp_exokay, dtw_resp_error, dtw_resp_target_id, dtw_resp_r_message_id}';
    }
}

\jsend
    \=u.instance({
        instanceName: 'dtw_resp_fifo',
        moduleName: 'fifo',
        params: {
            width: wData+2+1,
            depth: u.getParam('respBufferSize'),
            zerodepth: 0,
            bypass_mode: 0
        },
        interfaces: [{
            modulePrefix: '',
            localPrefix: '',
            interface: u.getParam('clkInterface')
        }],
        ports: dtwRespFifoPorts,
        portsDelimiter: '\n        '
    })=\

    assign dtw_resp_last       = 1'b1;
    assign dtw_resp_cm_type    = \=u.getParam('DTWRsp')=\;
    assign dtw_resp_message_id =  \=DTWRespInterface.message_id=\'d0;

\js if ( wPriority != 0 ) {
    assign dtw_resp_priority   = pri_gen(dtw_resp_qos);
\js }
    assign dtw_resp_rl         =  \=DTWRespInterface.rl=\'d0;
    // data error currently only for atomics that can't allocate
    assign dtw_resp_cm_status  = dtw_resp_error[SLV_ERR] ? \=wCmstatus=\'b10000011 :
                                 dtw_resp_error[DEC_ERR] ? \=wCmstatus=\'b10000100 : 
                                 {\=wCmstatus-1=\'b0, dtw_resp_exokay};
    assign active = dtw_resp_valid | rmsg_valid;

\js if ( assertOn ) {
    `ifdef OVL_ASSERT_ON
    // coverage off
    // synthesis off
    // synopsys translate_off
    // should never send downstream if not valid/ready at source
    assert_implication #(0) assert_extra_data_pulse (
        .clk(clk),
        .reset_n(reset_n),
        .antecedent_expr(req_valid & req_ready),
        .consequent_expr(msg_valid & msg_ready)
    );
    assert_zero_one_hot #(0,\=depth=\,1, "vlate match is not 1 hot") assert_vlate_match_one_hot (
        .clk(clk),
        .reset_n(reset_n),
        .test_expr(vlate_match_vector)
    );
    // synopsys translate_on
    // synthesis on
    // coverage on
    `endif
\js }
endmodule

