//=============================================================================
// Copyright (C) 2021 Arteris, Inc.
// All rights reserved.
//=============================================================================
\jsbegin
// DVE Trace & Debug Accumulator
//=============================================================================
\jsend

\jsbegin
var u = obj.lib;

var log2ceil = function(n) { return Math.ceil(Math.log(n)/Math.LN2); };


var assertOn           = obj.lib.getParam('assertOn');
var nMainTraceBufSize  = obj.lib.getParam('nMainTraceBufSize');
var nTraceBanks        = obj.lib.getParam('nTraceBanks');
var wMainTraceBufSize  = Math.max(1, log2ceil(nMainTraceBufSize));
var wTraceBanks        = Math.max(1, log2ceil(nTraceBanks));
var wDvmReqAiuId       = obj.lib.getParam('wDvmReqAiuId');
var wDvmReqData        = obj.lib.getParam('wDvmReqData');

var memErrType = obj.lib.getParam('memErrType');
var memErrWidth = obj.lib.getParam('memErrWidth');
var EW = obj.userLib.lib_utils.getEccWidth(64);

var wTraceBanks        = Math.max(1, log2ceil(nTraceBanks));

\jsend

\jsbegin
//=============================================================================
// ports
//=============================================================================
u.port('input', 'clk', 1);
u.port('input', 'reset_n', 1);

u.port('input', 'ungated_clk', 1);
u.port('input', 'ungated_reset_n', 1);

u.port('output', 'dve_trace_busy', 1);
u.port('output', 'dve_trace_packets_dropped', 1);
u.port('output', 'dve_trace_packets_accepted', 1);

u.port('output', 'dve_init_in_progress', 1);

obj.lib.port('input', 'dvm_dtwreq_valid',    1);
obj.lib.port('input', 'dvm_dtwreq_ready',    1);
//obj.lib.port('input', 'dvm_dtwreq_cm_type',  8);
obj.lib.port('input', 'dvm_dtwreq_last',     1);
obj.lib.port('input', 'dvm_dtwreq_aiuid',    wDvmReqAiuId);
obj.lib.port('input', 'dvm_dtwreq_data',     wDvmReqData);
obj.lib.port('output', 'dvm_dtwreq_cmstatus_new', 8);

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// CSR interface
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
obj.lib.port('input', 'csr_DVETASCR_BufferIsCircular',     1);
obj.lib.port('input', 'csr_DVETASCR_BufferClear',        1);
obj.lib.port('input', 'csr_DVETASCR_BufferRead',         1);

obj.lib.port('output', 'dve_trace_buffer_empty',          1);
obj.lib.port('output', 'dve_trace_buffer_full',           1);
obj.lib.port('output', 'dve_trace_funit_id',              8);
obj.lib.port('output', 'dve_trace_read_data_valid',       1);
obj.lib.port('output', 'dve_trace_timestamp',            32);
for (let i=0;i<16;i++) {
obj.lib.port('output', 'dve_trace_capture_data_valid'+i,  1);
obj.lib.port('output', 'dve_trace_capture_data'+i,       32);
}

obj.lib.port('output', 'dve_trace_hdr_ecc_sb_error',          1);
obj.lib.port('output', 'dve_trace_hdr_ecc_db_error',          1);

obj.lib.port('output', 'dve_trace_hdr_ecc_addr',          wMainTraceBufSize);

obj.lib.port('output', 'dve_trace_data_ecc_sb_error',          1);
obj.lib.port('output', 'dve_trace_data_ecc_db_error',          1);

obj.lib.port('output', 'dve_trace_data_ecc_addr',          wMainTraceBufSize+wTraceBanks);

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Trace & Debug ram interface
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
obj.lib.port('output', 'f_cen_hdr',                      1);
obj.lib.port('output', 'f_wen_hdr',                      1);
obj.lib.port('output', 'f_caddr_hdr',    wMainTraceBufSize);
obj.lib.port('output', 'f_wdata_hdr',                   64+memErrWidth);
obj.lib.port('input',  'f_rdata_hdr',                   64+memErrWidth);

obj.lib.port('output', 'f_cen_data',                     1);
obj.lib.port('output', 'f_wen_data',                     1);
obj.lib.port('output', 'f_caddr_data',   wMainTraceBufSize+wTraceBanks);
obj.lib.port('output', 'f_wdata_data',                  64+memErrWidth);
obj.lib.port('input',  'f_rdata_data',                  64+memErrWidth);

\jsend

module \=u.getModuleName()=\ (\=u.getPorts('\n    ')=\);

parameter MEMORY = 0;
parameter PROT = 2;
parameter LATENCY = 1;
parameter WIDTH = 64;
parameter DRST = 1'b0;
parameter XO = 1'b0;

\jsbegin
//=============================================================================
// signal declarations
//=============================================================================
\jsend

wire dtwreq_first,dtwreq_first_in;
wire trace_valid, trace_valid_first,trace_valid_last,trace_valid_qual,trace_valid_last_qual;
wire [31:0] frc,frc_in;
wire [63:0] header;
wire [\=wMainTraceBufSize+wTraceBanks-1=\:0] wptr_accum_in,wptr_accum;
wire [\=wMainTraceBufSize-1=\:0] rptr_accum_in,rptr_accum;
wire rptr_accum_en;
wire [\=nMainTraceBufSize-1=\:0] occupied_in,occupied;

wire [63:0] wdata_hdr,wdata_data;
wire [\=63+memErrWidth=\:0] f_rdata_hdr_p2,f_rdata_data_p2;

\js // Read Engine
wire [3:0] read_sm,read_sm_in,read_sm_p1,read_sm_p2;
wire read_sm_en;
wire read_start,read_start_p1,read_start_p2;
wire read_blocked,read_blocked_p1,read_blocked_p2;
wire full,full_in;

wire read_starting;
wire dve_trace_packets_dropped_in;
wire dve_trace_packets_accepted_in;

wire buffer_clear_start;

\jsbegin
//=============================================================================
// Debug/Trace Accumulation
//=============================================================================
\jsend

\js // Busy is read or invalidate state machines in progress
wire dve_trace_busy_in = csr_DVETASCR_BufferRead | read_starting | (|read_sm);
\=u.dffre(1, 'dve_trace_busy', 'dve_trace_busy_in', "1'b0", "1'b1", 'clk', 'reset_n')=\

\js // Event dropped occurs wen the buffer is (1) full, (2) not Circular, (3) and a new message arrives
assign dve_trace_packets_dropped_in = trace_valid_first & full & ~(csr_DVETASCR_BufferIsCircular & dve_trace_read_data_valid);
\=u.dffre(1, 'dve_trace_packets_dropped', 'dve_trace_packets_dropped_in', "1'b0", "1'b1", 'clk', 'reset_n')=\
assign dve_trace_packets_accepted_in = trace_valid_first & (csr_DVETASCR_BufferIsCircular | ~full);
\=u.dffre(1, 'dve_trace_packets_accepted', 'dve_trace_packets_accepted_in', "1'b0", "1'b1", 'clk', 'reset_n')=\

assign trace_valid       = dvm_dtwreq_valid & dvm_dtwreq_ready;
assign trace_valid_first = trace_valid & dtwreq_first;
assign trace_valid_last  = trace_valid & dvm_dtwreq_last;

assign dtwreq_first_in = (dvm_dtwreq_valid & dvm_dtwreq_ready) ? (dvm_dtwreq_last ? 1'b1 : 1'b0) : dtwreq_first;
\=u.dffre(1, 'dtwreq_first', 'dtwreq_first_in', "1'b1", "1'b1", 'clk', 'reset_n')=\

wire trace_in_progress,trace_in_progress_in;
wire trace_reject_in_progress,trace_reject_in_progress_in;

assign trace_in_progress_in = trace_valid_first | (trace_in_progress & ~trace_valid_last);
assign trace_reject_in_progress_in = (trace_in_progress_in & (buffer_clear_start | (full & ~csr_DVETASCR_BufferIsCircular))) | (trace_reject_in_progress & ~trace_valid_last);

\=u.dffre(1, 'trace_in_progress', 'trace_in_progress_in', "1'b0", "1'b1", 'clk', 'reset_n')=\
\=u.dffre(1, 'trace_reject_in_progress', 'trace_reject_in_progress_in', "1'b0", "1'b1", 'clk', 'reset_n')=\

assign trace_valid_qual = trace_valid & ~trace_reject_in_progress & ~(buffer_clear_start | (full & ~csr_DVETASCR_BufferIsCircular));
assign trace_valid_last_qual = trace_valid_last & ~trace_reject_in_progress;

\js // Free Running Counter (frc)
assign frc_in = frc + 32'h1;
\=u.dffre(32, 'frc', 'frc_in', "32'b0", "1'b1", 'ungated_clk', 'ungated_reset_n')=\

\js //-----------------------------------------------------------------------------
\js // Clear engine
\js //-----------------------------------------------------------------------------

wire buffer_clear_in_progress_in,buffer_clear_in_progress;
wire buffer_clear_test = 1'b0;
\js //wire buffer_clear_test = trace_valid & (wptr_accum == \=wMainTraceBufSize+wTraceBanks=\'h12);

assign buffer_clear_start = csr_DVETASCR_BufferClear | buffer_clear_test;
assign buffer_clear_in_progress_in = buffer_clear_start | (buffer_clear_in_progress & trace_in_progress);
\=u.dffre(1, 'buffer_clear_in_progress', 'buffer_clear_in_progress_in', "1'b0", "1'b1", 'clk', 'reset_n')=\

wire init_done;
wire init_in_progress;
wire init_in_progress_in = (~init_done & ~init_in_progress) ? 1'b1 : (init_in_progress & ~init_done);
\=u.dffre(1, 'init_in_progress', 'init_in_progress_in', "1'b0", "1'b1", 'clk', 'reset_n')=\
wire [\=wMainTraceBufSize+wTraceBanks-1=\:0] init_count;
wire [\=wMainTraceBufSize+wTraceBanks-1=\:0] init_count_in = init_in_progress ? init_count+\=wMainTraceBufSize+wTraceBanks=\'b1 : init_count;
wire init_count_en = ~init_done;
\=u.dffre(wMainTraceBufSize+wTraceBanks, 'init_count', 'init_count_in', (wMainTraceBufSize+wTraceBanks)+"'b0", 'init_count_en', 'clk', 'reset_n')=\
assign init_done = init_count == \=wMainTraceBufSize+wTraceBanks=\'d\=Math.pow(2,wMainTraceBufSize+wTraceBanks)-1=\;

assign dve_init_in_progress = init_in_progress;

\js //-----------------------------------------------------------------------------
\js // Receive engine
\js //-----------------------------------------------------------------------------

wire wen_data;
wire wptr_accum_en;

\js // Collecting the trace message
\js // Beat 0 needs to store both header and data
\js // Beats 1-7 only store data
assign header = { \=32-wDvmReqAiuId=\'b0, dvm_dtwreq_aiuid, frc };

assign full_in = ((wptr_accum_in[\=wMainTraceBufSize+wTraceBanks-1=\:\=wTraceBanks=\] != wptr_accum[\=wMainTraceBufSize+wTraceBanks-1=\:\=wTraceBanks=\]) & 
                  (wptr_accum_in[\=wMainTraceBufSize+wTraceBanks-1=\:\=wTraceBanks=\] == rptr_accum) &
                  trace_valid_last_qual & ~dve_trace_read_data_valid) | (full & ~buffer_clear_in_progress & ~dve_trace_read_data_valid);
\=u.dffre(1, 'full', 'full_in', "1'b0", "1'b1",       'clk', 'reset_n')=\
assign wptr_accum_in = buffer_clear_in_progress ? \=wMainTraceBufSize+wTraceBanks=\'b0 : (~csr_DVETASCR_BufferIsCircular & full) ? wptr_accum : wptr_accum + \=wMainTraceBufSize+wTraceBanks=\'b1;

assign wptr_accum_en = buffer_clear_in_progress | trace_valid_qual;
\=u.dffre(wMainTraceBufSize+wTraceBanks, 'wptr_accum', 'wptr_accum_in', wMainTraceBufSize+wTraceBanks+"'b0", 'wptr_accum_en',       'clk', 'reset_n')=\

assign wdata_hdr  = init_in_progress ? 64'b0 : header;
assign wdata_data = init_in_progress ? 64'b0 : dvm_dtwreq_data;

\js //
\js // This is the register implementation of the writing of the trace message into the capture arrays
\js //

\js // Write address for a data bank is the write pointer, not including the bank bits.
wire [\=wMainTraceBufSize+wTraceBanks-1=\:0] waddr_data = init_in_progress ? init_count : wptr_accum[\=wMainTraceBufSize+wTraceBanks-1=\:0];
wire [\=wMainTraceBufSize-1=\:0] waddr_hdr  = init_in_progress ? init_count[\=wMainTraceBufSize+wTraceBanks-1=\:\=wTraceBanks=\] : waddr_data[\=wMainTraceBufSize+wTraceBanks-1=\:\=wTraceBanks=\];


wire [\=wMainTraceBufSize+wTraceBanks-1=\:0] raddr_data = {rptr_accum[\=wMainTraceBufSize-1=\:0],read_sm[\=wTraceBanks-1=\:0]};
wire [\=wMainTraceBufSize-1=\:0] raddr_hdr  = raddr_data[\=wMainTraceBufSize+wTraceBanks-1=\:\=wTraceBanks=\];

assign wen_data = init_in_progress | (trace_valid_qual & ~(~csr_DVETASCR_BufferIsCircular & full));

wire [\=nTraceBanks-1=\:0] wen_data_bank;
wire [\=nTraceBanks-1=\:0] ren_data_bank;

\js // Write enable for the hdr is equivalent to the write enable for data bank 0
wire wen_hdr = init_in_progress | (wen_data_bank[0] & ~(~csr_DVETASCR_BufferIsCircular & full));
wire ren_hdr = read_start;

wire ren_data = (read_start | (read_sm!=4'd0)) & ~read_blocked;

\js for (let i=0;i<nMainTraceBufSize;i++) {
assign occupied_in[\=i=\] = ((wptr_accum[\=wMainTraceBufSize+wTraceBanks-1=\:\=wTraceBanks=\] == \=wMainTraceBufSize=\'d\=i=\) & trace_valid_last_qual) | (occupied[\=i=\] & ~((rptr_accum == \=wMainTraceBufSize=\'d\=i=\) & dve_trace_read_data_valid));
\js }
\=u.dffre(nMainTraceBufSize, 'occupied', 'occupied_in', nMainTraceBufSize+"'b0", "1'b1", 'clk', 'reset_n')=\

\js for (let i=0;i<nTraceBanks;i++) {

\js // Write enable for a data bank is the write pointer lower bits that designate bank
assign wen_data_bank[\=i=\] = wen_data & (wptr_accum[\=wTraceBanks-1=\:0] == \=wTraceBanks=\'d\=i=\);

\js // Read enable for a data bank is the read state machine value
assign ren_data_bank[\=i=\] = (read_sm==4'd\=i=\) & ((read_sm==4'd0) ? read_start : 1'b1);

wire [63:0] rdata_data_bank\=i=\;

\js }

\js //-----------------------------------------------------------------------------
\js // SRAM
\js //-----------------------------------------------------------------------------

wire cen_hdr;
wire [\=wMainTraceBufSize-1=\:0] caddr_hdr;

\jsbegin
// memory protection always present on 3.4
/* istanbul ignore else env ncore_3p4,ncore_3p6,ncore_3p7 */
    if (memErrType == "SECDED" || /* istanbul ignore next env ncore_3p4,ncore_3p6,ncore_3p7 */ memErrType == "PARITYENTRY") { \jsend
wire [\=memErrWidth-1=\:0] wdata_hdr_ecc;
\js }

\jsbegin
// Ncore3.2 protection is single bit protection, double bit detection
/* istanbul ignore else env ncore_3p2,ncore_3p4,ncore_3p6,ncore_3p7 */
    if (memErrType == "SECDED") { \jsend
\=u.instance({
        moduleName: 'ecc_enc',
        instanceName: 'ecc_hdr_enc',
        params: {
                data_width:     64+wMainTraceBufSize
        },
        ports: {
                data:           '{waddr_hdr,wdata_hdr}',
                ecc:            'wdata_hdr_ecc'
        },
        portsDelimiter: '\n\t'
})=\
\js } else if (memErrType=="PARITYENTRY") {
assign wdata_hdr_ecc = ^{waddr_hdr,wdata_hdr};
\js }

wire [63:0] rdata_hdr_p2;
wire [63:0] rdata_hdr;
wire [\=memErrWidth-1=\:0] rdata_hdr_ecc_p1;
wire [\=memErrWidth-1=\:0] rdata_hdr_ecc_p2;
wire [\=memErrWidth-1=\:0] rdata_hdr_ecc;
wire [\=memErrWidth-1=\:0] rdata_hdr_syn;
wire rdata_hdr_sb,rdata_hdr_db;
wire [\=wMainTraceBufSize-1=\:0] caddr_hdr_p1;
wire [\=wMainTraceBufSize-1=\:0] caddr_hdr_p2;

\jsbegin
// Ncore3.2 protection is single bit protection, double bit detection
/* istanbul ignore else env ncore_3p2,ncore_3p4,ncore_3p6,ncore_3p7 */
    if (memErrType=="SECDED") { \jsend
\=u.instance({
        moduleName: 'ecc_dec',
        instanceName: 'ecc_hdr_dec',
        params: {
                data_width:     64+wMainTraceBufSize
        },
        ports: {
                data:           '{caddr_hdr_p2,rdata_hdr_p2}',
                ecc:            'rdata_hdr_ecc_p2',
                syndrome:       'rdata_hdr_syn',
                err_sb:         'rdata_hdr_sb',
                err_db:         'rdata_hdr_db'
        },
        portsDelimiter: '\n\t'
})=\

wire [\=wMainTraceBufSize-1=\:0] caddr_hdr_corr_p2;

\=u.instance({
        moduleName: 'ecc_cor',
        instanceName: 'ecc_hdr_cor',
        params: {
                data_width:     64+wMainTraceBufSize
        },
        ports: {
                data_in:        '{caddr_hdr_p2,rdata_hdr_p2}',
                ecc_in:         'rdata_hdr_ecc_p2',
                syndrome:       'rdata_hdr_syn',
                data_out:       '{caddr_hdr_corr_p2,rdata_hdr}',
                ecc_out:        'rdata_hdr_ecc',
        },
        portsDelimiter: '\n\t'
})=\

wire addr_corr_mismatch_hdr = caddr_hdr_corr_p2[\=wMainTraceBufSize-1=\:0] != caddr_hdr_p2;
\js } else if (memErrType=="PARITYENTRY") {
assign rdata_hdr_sb = 1'b0;
assign rdata_hdr_db = ^{rdata_hdr_ecc_p2,caddr_hdr_p2,rdata_hdr_p2};
assign addr_corr_mismatch_hdr = 1'b0;
\js } else {
assign rdata_hdr_sb = 1'b0;
assign rdata_hdr_db = 1'b0;
assign addr_corr_mismatch_hdr = 1'b0;
\js }

wire wen_hdr_last;
wire [\=wMainTraceBufSize-1=\:0] waddr_hdr_last;
wire [\=64+memErrWidth-1=\:0] wdata_hdr_last;

\=u.dffre(1, 'wen_hdr_last', 'wen_hdr', "1'b0", "1'b1", 'clk', 'reset_n')=\
\=u.dffre(wMainTraceBufSize, 'waddr_hdr_last', 'waddr_hdr', wMainTraceBufSize+"'b0", "1'b1", 'clk', 'reset_n')=\
\jsbegin
// memory protection always present on 3.4
/* istanbul ignore else env ncore_3p4,ncore_3p6,ncore_3p7 */
    if (memErrType == "SECDED" || /* istanbul ignore next env ncore_3p4,ncore_3p6,ncore_3p7 */ memErrType == "PARITYENTRY") { \jsend
\=u.dffre(64+memErrWidth, 'wdata_hdr_last', '{wdata_hdr_ecc,wdata_hdr}', "{"+(64+memErrWidth)+"{1'b0}}", "1'b1", 'clk', 'reset_n')=\
\js } else {
\=u.dffre(64,             'wdata_hdr_last', '{              wdata_hdr}', "{"+(64            )+"{1'b0}}", "1'b1", 'clk', 'reset_n')=\
\js }

assign f_cen_hdr = wen_hdr_last | ren_hdr;
assign f_wen_hdr = wen_hdr_last;
assign f_caddr_hdr = wen_hdr_last ? waddr_hdr_last : raddr_hdr;
assign f_wdata_hdr = wdata_hdr_last;
\=u.dffre(64+memErrWidth, 'f_rdata_hdr_p2', 'f_rdata_hdr', "{"+(64+memErrWidth)+"{1'b0}}", "1'b1", 'clk', 'reset_n')=\
assign {rdata_hdr_ecc_p2,rdata_hdr_p2} = f_rdata_hdr_p2;

wire cen_data;
wire [\=wMainTraceBufSize+wTraceBanks-1=\:0] caddr_data;

\jsbegin
// memory protection always present on 3.4
/* istanbul ignore else env ncore_3p4,ncore_3p6,ncore_3p7 */
    if (memErrType == "SECDED" || /* istanbul ignore next env ncore_3p4,ncore_3p6,ncore_3p7 */ memErrType == "PARITYENTRY") { \jsend
wire [\=memErrWidth-1=\:0] wdata_data_ecc;
\js }

\jsbegin
// Ncore3.2 protection is single bit protection, double bit detection
/* istanbul ignore else env ncore_3p2,ncore_3p4,ncore_3p6,ncore_3p7 */
    if (memErrType=="SECDED") { \jsend
\=u.instance({
        moduleName: 'ecc_enc',
        instanceName: 'ecc_data_enc',
        params: {
                data_width:     64+wMainTraceBufSize+wTraceBanks
        },
        ports: {
                data:           '{waddr_data,wdata_data}',
                ecc:            'wdata_data_ecc'
        },
        portsDelimiter: '\n\t'
})=\
\js } else if (memErrType=="PARITYENTRY") {
assign wdata_data_ecc = ^{waddr_data,wdata_data};
\js }

wire [63:0] rdata_data_p2;
wire [63:0] rdata_data;
wire [\=memErrWidth-1=\:0] rdata_data_ecc_p1;
wire [\=memErrWidth-1=\:0] rdata_data_ecc_p2;
wire [\=memErrWidth-1=\:0] rdata_data_ecc;
wire [\=memErrWidth-1=\:0] rdata_data_syn;
wire rdata_data_sb,rdata_data_db;
wire [\=wMainTraceBufSize+wTraceBanks-1=\:0]             caddr_data_p1;
wire [\=wMainTraceBufSize+wTraceBanks-1=\:0]             caddr_data_p2;

\jsbegin
// Ncore3.2 protection is single bit protection, double bit detection
/* istanbul ignore else env ncore_3p2,ncore_3p4,ncore_3p6,ncore_3p7 */
    if (memErrType=="SECDED") { \jsend
\=u.instance({
        moduleName: 'ecc_dec',
        instanceName: 'ecc_data_dec',
        params: {
                data_width:     64+wMainTraceBufSize+wTraceBanks
        },
        ports: {
                data:           '{caddr_data_p2,rdata_data_p2}',
                ecc:            'rdata_data_ecc_p2',
                syndrome:       'rdata_data_syn',
                err_sb:         'rdata_data_sb',
                err_db:         'rdata_data_db'
        },
        portsDelimiter: '\n\t'
})=\

wire [\=wMainTraceBufSize+wTraceBanks-1=\:0] caddr_data_corr_p2;

\=u.instance({
        moduleName: 'ecc_cor',
        instanceName: 'ecc_cor',
        params: {
                data_width:     64+wMainTraceBufSize+wTraceBanks
        },
        ports: {
                data_in:        '{caddr_data_p2,rdata_data_p2}',
                ecc_in:         'rdata_data_ecc_p2',
                syndrome:       'rdata_data_syn',
                data_out:       '{caddr_data_corr_p2,rdata_data}',
                ecc_out:        'rdata_data_ecc',
        },
        portsDelimiter: '\n\t'
})=\

wire addr_corr_mismatch_data = caddr_data_corr_p2[\=wMainTraceBufSize+wTraceBanks-1=\:0] != caddr_data_p2;
\js } else if (memErrType=="PARITYENTRY") {
assign rdata_data_sb = 1'b0;
assign rdata_data_db = ^{rdata_data_ecc_p2,caddr_data_p2,rdata_data_p2};
assign addr_corr_mismatch_data = 1'b0;
\js } else {
assign rdata_data_sb = 1'b0;
assign rdata_data_db = 1'b0;
assign addr_corr_mismatch_data = 1'b0;
\js }

wire ren_hdr_p1;
wire ren_hdr_p2;
wire ren_data_p1,wen_data_last;
wire ren_data_p2;
wire dve_trace_hdr_ecc_sb_error_in,dve_trace_hdr_ecc_db_error_in;
wire dve_trace_data_ecc_sb_error_in,dve_trace_data_ecc_db_error_in;

\=u.dffre(1, 'ren_hdr_p1', 'ren_hdr & ~wen_hdr_last', "1'b0", "1'b1", 'clk', 'reset_n')=\
\=u.dffre(1, 'ren_hdr_p2', 'ren_hdr_p1', "1'b0", "1'b1", 'clk', 'reset_n')=\

\=u.dffre(1, 'ren_data_p1', 'ren_data & ~wen_data_last', "1'b0", "1'b1", 'clk', 'reset_n')=\
\=u.dffre(1, 'ren_data_p2', 'ren_data_p1', "1'b0", "1'b1", 'clk', 'reset_n')=\

\=u.dffre(wMainTraceBufSize, 'caddr_hdr_p1', 'f_caddr_hdr', wMainTraceBufSize+"'b0", "1'b1", 'clk', 'reset_n')=\
\=u.dffre(wMainTraceBufSize, 'caddr_hdr_p2', 'caddr_hdr_p1', wMainTraceBufSize+"'b0", "1'b1", 'clk', 'reset_n')=\
\=u.dffre(wMainTraceBufSize, 'dve_trace_hdr_ecc_addr', 'caddr_hdr_p2', wMainTraceBufSize+"'b0", "1'b1", 'clk', 'reset_n')=\
\=u.dffre(wMainTraceBufSize+wTraceBanks, 'caddr_data_p1', 'f_caddr_data', wMainTraceBufSize+wTraceBanks+"'b0", "1'b1", 'clk', 'reset_n')=\
\=u.dffre(wMainTraceBufSize+wTraceBanks, 'caddr_data_p2', 'caddr_data_p1', wMainTraceBufSize+wTraceBanks+"'b0", "1'b1", 'clk', 'reset_n')=\
\=u.dffre(wMainTraceBufSize+wTraceBanks, 'dve_trace_data_ecc_addr', 'caddr_data_p2', wMainTraceBufSize+wTraceBanks+"'b0", "1'b1", 'clk', 'reset_n')=\

assign dve_trace_hdr_ecc_sb_error_in = ren_hdr_p2 & (rdata_hdr_sb & ~addr_corr_mismatch_hdr);
assign dve_trace_data_ecc_sb_error_in = ren_data_p2 & (rdata_data_sb & ~addr_corr_mismatch_data);

assign dve_trace_hdr_ecc_db_error_in = ren_hdr_p2 & (rdata_hdr_db | addr_corr_mismatch_hdr);
assign dve_trace_data_ecc_db_error_in = ren_data_p2 & (rdata_data_db | addr_corr_mismatch_data);

\=u.dffre(1, 'dve_trace_hdr_ecc_sb_error', 'dve_trace_hdr_ecc_sb_error_in', "1'b0", "1'b1", 'clk', 'reset_n')=\
\=u.dffre(1, 'dve_trace_hdr_ecc_db_error', 'dve_trace_hdr_ecc_db_error_in', "1'b0", "1'b1", 'clk', 'reset_n')=\

\=u.dffre(1, 'dve_trace_data_ecc_sb_error', 'dve_trace_data_ecc_sb_error_in', "1'b0", "1'b1", 'clk', 'reset_n')=\
\=u.dffre(1, 'dve_trace_data_ecc_db_error', 'dve_trace_data_ecc_db_error_in', "1'b0", "1'b1", 'clk', 'reset_n')=\

wire wen_data_last_nc;
wire [\=wMainTraceBufSize+wTraceBanks-1=\:0] waddr_data_last;
wire [71:0] wdata_data_last;

\=u.dffre(1, 'wen_data_last', 'wen_data', "1'b0", "1'b1", 'clk', 'reset_n')=\
\=u.dffre(wMainTraceBufSize+wTraceBanks, 'waddr_data_last', 'waddr_data', wMainTraceBufSize+wTraceBanks+"'b0", "1'b1", 'clk', 'reset_n')=\
\jsbegin
// memory protection always present on 3.4
/* istanbul ignore else env ncore_3p4,ncore_3p6,ncore_3p7 */
    if (memErrType == "SECDED" || /* istanbul ignore next env ncore_3p4,ncore_3p6,ncore_3p7 */ memErrType == "PARITYENTRY") { \jsend
\=u.dffre(64+memErrWidth, 'wdata_data_last', '{wdata_data_ecc,wdata_data}', "{"+(64+memErrWidth)+"{1'b0}}", "1'b1", 'clk', 'reset_n')=\
\js } else {
\=u.dffre(64,             'wdata_data_last', '{               wdata_data}', "{"+(64            )+"{1'b0}}", "1'b1", 'clk', 'reset_n')=\
\js }

assign f_cen_data = wen_data_last | ren_data;
assign f_wen_data = wen_data_last;
assign f_caddr_data = wen_data_last ? waddr_data_last : raddr_data;
assign f_wdata_data = wdata_data_last;
\=u.dffre(64+memErrWidth, 'f_rdata_data_p2', 'f_rdata_data', "{"+(64+memErrWidth)+"{1'b0}}", "1'b1", 'clk', 'reset_n')=\
assign {rdata_data_ecc_p2,rdata_data_p2} = f_rdata_data_p2;

\js //-----------------------------------------------------------------------------
\js // CSR Read engine
\js //-----------------------------------------------------------------------------
wire read_starting_in,read_starting_complete;
wire read_restart;

assign read_starting_complete = read_starting & ~trace_valid_qual;
assign read_starting_in = ((csr_DVETASCR_BufferRead | read_restart) & ~dve_trace_buffer_empty) | (read_starting & read_blocked);
\=u.dffre(1, 'read_starting', 'read_starting_in', "1'b0", "1'b1", 'clk', 'reset_n')=\

\js // Block a read if a write is happening in the same cycle.
assign read_blocked = wen_data | wen_data_last;

\js // Reads re initiated by software write to the DVETASCR[BufferRead].
assign read_start = (read_sm == 4'b0) & read_starting;

assign read_restart = |read_sm & (wptr_accum[\=wMainTraceBufSize+wTraceBanks-1=\:\=wTraceBanks=\] == rptr_accum[\=wMainTraceBufSize-1=\:0]) & trace_valid_qual & ~dve_trace_buffer_empty & ~(~csr_DVETASCR_BufferIsCircular & full);

wire read_ptr_adjust = csr_DVETASCR_BufferIsCircular & full & trace_valid_qual & (wptr_accum[\=wMainTraceBufSize+wTraceBanks-1=\:\=wTraceBanks=\] == rptr_accum[\=wMainTraceBufSize-1=\:0]);

assign rptr_accum_in = buffer_clear_in_progress ? \=wMainTraceBufSize=\'b0 : read_ptr_adjust ? (wptr_accum[\=wMainTraceBufSize+wTraceBanks-1=\:\=wTraceBanks=\] + \=wMainTraceBufSize=\'b1) : rptr_accum + \=wMainTraceBufSize=\'b1;

assign rptr_accum_en = buffer_clear_in_progress | dve_trace_read_data_valid | read_ptr_adjust;
\=u.dffre(wMainTraceBufSize, 'rptr_accum', 'rptr_accum_in', wMainTraceBufSize+"'b0", 'rptr_accum_en',       'clk', 'reset_n')=\

\js // If the write side is receiving a data packet, then hold off reading until the write is done.
assign read_sm_en = read_restart | ((read_start | (read_sm != 4'b0)) & ~read_blocked);
assign read_sm_in = ((read_sm == 4'd\=nTraceBanks-1=\) | read_restart) ? 4'b0 : trace_valid_qual ? read_sm : read_sm + 4'b1;
\=u.dffre(4, 'read_sm', 'read_sm_in', "4'b0", 'read_sm_en', 'clk', 'reset_n')=\
\=u.dffre(4, 'read_sm_p1', 'read_sm', "4'b0", "1'b1", 'clk', 'reset_n')=\
\=u.dffre(4, 'read_sm_p2', 'read_sm_p1', "4'b0", "1'b1", 'clk', 'reset_n')=\
\=u.dffre(1, 'read_start_p1', 'read_start', "1'b0", "1'b1", 'clk', 'reset_n')=\
\=u.dffre(1, 'read_start_p2', 'read_start_p1', "1'b0", "1'b1", 'clk', 'reset_n')=\
\=u.dffre(1, 'read_blocked_p1', 'read_blocked', "1'b0", "1'b1", 'clk', 'reset_n')=\
\=u.dffre(1, 'read_blocked_p2', 'read_blocked_p1', "1'b0", "1'b1", 'clk', 'reset_n')=\

\js // This validation of the csr capture data is valid for both register and sram implemenations.
\js // Data is captured on the following cycles of the state machine:
\js //  0: DVETAD1R/DVETAD0R
\js //  1: DVETAD3R/DVETAD2R
\js //  2: DVETAD5R/DVETAD4R
\js //  3: DVETAD7R/DVETAD6R
\js //  4: DVETAD9R/DVETAD8R
\js //  5: DVETAD11R/DVETAD10R
\js //  6: DVETAD13R/DVETAD12R
\js //  7: DVETAD15R/DVETAD14R
\js for (let i=0;i<nTraceBanks;i++) {
assign { dve_trace_capture_data\=i*2+1=\, dve_trace_capture_data\=i*2=\} = rdata_data;
assign dve_trace_capture_data_valid\=i*2=\ = ~read_blocked_p2 & (read_sm_p2==4'd\=i=\) & ((read_sm_p2==4'd0) ? read_start_p2 : 1'b1);
assign dve_trace_capture_data_valid\=i*2+1=\ = ~read_blocked_p2 & (read_sm_p2==4'd\=i=\) & ((read_sm_p2==4'd0) ? read_start_p2 : 1'b1);
\js }

\js // The register implementation is validated on the last cycle of the state machine to guarantee that all other regs have been updated
assign dve_trace_funit_id = rdata_hdr[39:32];
assign dve_trace_timestamp = rdata_hdr[31:0];
assign dve_trace_read_data_valid = ~read_blocked_p2 & (read_sm_p2==4'd\=nTraceBanks-1=\);

\js //-----------------------------------------------------------------------------
\js // Miscellaneous
\js //-----------------------------------------------------------------------------

\js // Software readable bit to indicate that the trace buffer is empty
\js //assign dve_trace_buffer_empty = ~(|occupied);
assign dve_trace_buffer_empty = (wptr_accum[\=wMainTraceBufSize+wTraceBanks-1=\:\=wTraceBanks=\] == rptr_accum) & ~full;

assign dve_trace_buffer_full  = full;

\js // The cmstatus for the DTWrsp is formed by comparing the timetamp in
\js // the message with the local frc.
wire [31:0] delta1 = frc[31:0] - dvm_dtwreq_data[31:0];
wire [31:0] delta2 = dvm_dtwreq_data[31:0] - frc[31:0];
wire delta_is_negative = (dvm_dtwreq_data[31:4] <  frc[31:4]);
wire delta_is_zero     = (dvm_dtwreq_data[31:4] == frc[31:4]);
wire [7:0] dvm_dtwreq_cmstatus_new_in = {
              ( delta_is_negative | delta_is_zero),
              ((delta_is_zero                    ) ? 7'b0 : delta_is_negative ? (|delta1[31:11]) ? 7'b1111111 : delta1[10:4] 
                                                                              : (|delta2[31:11]) ? 7'b1111111 : delta2[10:4])};

\=u.dffre(8, 'dvm_dtwreq_cmstatus_new', 'dvm_dtwreq_cmstatus_new_in', "8'b0", "trace_valid_first", 'clk', 'reset_n')=\

\js if (assertOn) {
//=========================================================================
// Coverage Properties
//=========================================================================
`ifdef OVL_ASSERT_ON
// synthesis_off
// pragma synthesis_off
// coverage off

FULL_AND_WRITE:           cover property ( @(posedge clk) ((&occupied) & trace_valid));
FULL_AND_READ:            cover property ( @(posedge clk) ((&occupied) & read_start));
FULL_AND_READ_AND_WRITE:  cover property ( @(posedge clk) ((&occupied) & read_start & trace_valid));
READ_BLOCKED:             cover property ( @(posedge clk) ( read_starting & read_blocked ));
READ_RESTART:             cover property ( @(posedge clk) ( read_restart ));
VALID_AND_NOT_READY:      cover property ( @(posedge clk) ( dvm_dtwreq_valid & ~dvm_dtwreq_ready ));

// coverage on
// pragma synthesis_on
// synthesis_on
`endif

\js }

endmodule
