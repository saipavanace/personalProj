\jsbegin
    var u = obj.lib;
    var bundleFunctions = obj.userLib.bundleFunctions;
    var log2ceil = function(n) { return Math.ceil(Math.log(n)/Math.LN2); };

    var  doublePortReadBuffer  = obj.lib.getParam('doublePortReadBuffer');

    var   data_width            = u.getParam('wData');//Math.abs(u.getParam('AXI_Interface', 'r_', 'data'))
    var   wDataWidth            = log2ceil(data_width);
    var   data_width_bytes      = data_width/8;
    var   wDataWidthBytes       = log2ceil(data_width_bytes);
    var   axi_id_width          = u.getParam('axi_id_width');
    var   wtt_id_width          = u.getParam('wtt_id_width');
    var   memDepth              = u.getParam('memDepth');   
    var   bresp_width           = Math.abs(u.getParam('AXI_Interface', 'b_', 'resp'));

    var   arlen_width           = Math.abs(u.getParam('AXI_Interface', 'ar_', 'len'));
    var   arburst_width         = Math.abs(u.getParam('AXI_Interface', 'ar_', 'burst')); 
    var   arlock_width          = Math.abs(u.getParam('AXI_Interface', 'ar_', 'lock'));
    var   arcache_width         = Math.abs(u.getParam('AXI_Interface', 'ar_', 'cache'));
    var   arprot_width          = Math.abs(u.getParam('AXI_Interface', 'ar_', 'prot'));
    var   arregion_width        = Math.abs(u.getParam('AXI_Interface', 'ar_', 'region'));
    var   aruser_width          = Math.abs(u.getParam('AXI_Interface', 'ar_', 'user'));
    var   araddr_width          = Math.abs(u.getParam('AXI_Interface', 'ar_', 'addr'));

    var   ruser_width           = Math.abs(u.getParam('AXI_Interface', 'r_',  'user'));

    var   awlen_width           = Math.abs(u.getParam('AXI_Interface', 'aw_', 'len'));
    var   awburst_width         = Math.abs(u.getParam('AXI_Interface', 'aw_', 'burst'));
    var   awlock_width          = Math.abs(u.getParam('AXI_Interface', 'aw_', 'lock'));
    var   awcache_width         = Math.abs(u.getParam('AXI_Interface', 'aw_', 'cache'));
    var   awprot_width          = Math.abs(u.getParam('AXI_Interface', 'aw_', 'prot'));
    var   awregion_width        = Math.abs(u.getParam('AXI_Interface', 'aw_', 'region'));
    var   awuser_width          = Math.abs(u.getParam('AXI_Interface', 'aw_', 'user'));
    var   awaddr_width          = Math.abs(u.getParam('AXI_Interface', 'aw_', 'addr'));

    var   be_width              = u.getParam('be_width');
    var   axi_write_resp_width  = bresp_width + axi_id_width;
    var   cmd_addr_width        = u.getParam('wAddr');
    var   cmd_size_width        = 3 ;
    var   wQos                  = u.getParam('wQos');
    var   cmd_qos_width         = u.getParam('wQos');
    var   addr_offset_width     = u.getParam('wCacheLineOffset');
    var   read_req_width        = u.getParam('read_req_width');  
    var   read_resp_width       = u.getParam('read_resp_width');
    var   axi_addr_width        = cmd_addr_width ;
    var   write_req_width       = u.getParam('write_req_width');
    var   ordering_width        = u.getParam('ordering_width');
    var   cmd_mpf1_width        = u.getParam('wMpf1');

    var   useAddrTranslation    = u.getParam('useAddrTranslation');
    var   nAddrTransRegisters   = u.getParam('nAddrTransRegisters');
    var   csrAddrTransInterface = u.getParam('csrAddrTransInterface');
	   
    var   wTOF                  = u.getParam('wTOF');

    var   memory_width          = u.getParam('memory_width');

    var   hasQos                = Math.abs(u.getParam('AXI_Interface', 'aw_', 'qos')) != 0;

    var   memoryInterface       = obj.lib.getParam('memoryInterface');
    var   axiInterface          = obj.lib.getParam('AXI_Interface');
    var   nExclusiveEntries     = obj.lib.getParam('nExclusiveEntries');   
 
    u.port('input',  'clk'                         , 1);
    u.port('input',  'reset_n'                     , 1);
    u.port('input',  'read_req_valid'              , 1);
    u.port('input',  'read_req_data'               , read_req_width);
    u.port('input',  'read_resp_ready'             , 1);
    u.port('input',  'write_req_valid'             , 1);
    u.port('input',  'write_req_data'              , write_req_width);
    u.port('input',  'write_resp_ready'            , 1);
    u.port('input',  'dtw_data_done'               , 1);

    u.port('input',  'rtt_has_muxarb_valid_entry'  , 1);

    u.port('output', 'read_resp_fifo_in_valid'     , 1);
    u.port('output', 'read_req_fifo_ready'         , 1);
    u.port('output', 'write_req_fifo_ready'        , 1);
    u.port('output', 'use_new_axi_id'              , 1);

    u.port('output', 'read_resp_valid'             , 1);
    u.port('output', 'read_resp_fifo_ready'        , 1);
    u.port('output', 'read_resp_data'              , read_resp_width);

    u.port('output', 'read_resp_data_uc'           , 1);
    u.port('output', 'read_resp_data_c'            , 1);
    u.port('input',  'mem_data_uc'                 , 1);
    u.port('input',  'mem_data_c'                  , 1);
    u.port('input',  'corr_data'                   , read_resp_width);

    u.port('output', 'write_resp_data'             , axi_write_resp_width);
    u.port('output', 'write_resp_valid'            , 1);

    u.port('output', 'write_req_fifo_out_valid'    , 1);
    u.port('output', 'write_req_rb_id'             , wtt_id_width);
    u.port('output', 'write_req_ex_pass'           , 1);    
    u.port('output', 'out_write_req_ready'         , 1);

// AXI Interface
obj.lib.interface('axi_mst_'     , 'master', axiInterface    , ['w_','r_']);
obj.lib.interface('axi_mst_r_',   'master',  obj.lib.getParam('AXI_Interface', 'r_'), ['data']);
u.port('input', 'axi_mst_r_data'      , data_width);
// Read Data Buffer Memory
obj.lib.interface('mem_read_buffer_', 'master', memoryInterface);
// Addr Translation
obj.lib.interface('', 'slave', csrAddrTransInterface);

\jsend

module \=u.getModuleName()=\
(
\=u.getPorts('\n    ')=\
);

wire [\=cmd_addr_width-1=\:0]                   read_wrap_addr_mask;
wire [\=cmd_addr_width-1=\:0]                   write_wrap_addr_mask;
reg  [\=cmd_addr_width-1=\:0]                   size_wrap_addr_mask;
reg  [\=cmd_addr_width-1=\:0]                   read_size_wrap_addr_mask;

wire [\=read_req_width-1=\:0]                   read_req_fifo_out_data;
wire [\=write_req_width-1=\:0]                  write_req_fifo_out_data;
wire [\=read_resp_width-1=\:0]                  read_resp_fifo_in_packet;
wire [\=read_resp_width-1=\:0]                  read_resp_fifo_out_packet;
wire                                            read_req_fifo_out_valid;
wire                                            read_resp_fifo_out_valid;
wire                                            write_resp_fifo_ready;
wire                                            write_resp_fifo_out_valid;
wire [\=axi_write_resp_width-1=\:0]             write_resp_fifo_in_packet;
wire [\=axi_write_resp_width-1=\:0]             write_resp_fifo_out_packet;
wire [\=cmd_size_width-1=\:0]                   read_access_size;
wire [\=cmd_size_width-1=\:0]                   write_access_size;
wire [\=arlen_width-1=\:0]                      arlen;
wire [\=awlen_width-1=\:0]                      awlen;
wire [\=cmd_mpf1_width-1=\:0]                   cmd_mpf1_rd;
wire [\=cmd_mpf1_width-1=\:0]                   cmd_mpf1_wr;
wire [7:0]                                      access_size_per_burst;
wire [7:0]                                      wr_access_size_per_burst;
wire [\=Math.max(1,log2ceil(data_width))-1=\:0] bus_width_encoded;
wire [2:0]                                      axi_bus_width_encoded;
wire [2:0]                                      dwid_next;
wire [2:0]                                      dwid;
wire                                            awdone;
wire                                            awdone_d1;
wire                                            read_resp_fifo_empty;
wire                                            push_d1;
wire                                            dtw_data_done_d1;
wire                                            write_req_fifo_empty;
wire                                            write_resp_fifo_in_valid;
wire                                            out_write_resp_ready;
wire                                            write_resp_fifo_empty;

\jsbegin

 var axi_id_lsb = cmd_addr_width ;
 var axi_id_msb = cmd_addr_width + axi_id_width - 1;

 var cmd_size_lsb = cmd_addr_width + axi_id_width;
 var cmd_size_msb = cmd_addr_width + axi_id_width + cmd_size_width - 1;

 var cmd_qos_lsb = cmd_addr_width + axi_id_width + cmd_size_width ;
 var cmd_qos_msb = cmd_addr_width + axi_id_width + cmd_size_width + cmd_qos_width - 1;

 var axi_prot_lsb = cmd_addr_width + axi_id_width + cmd_size_width + cmd_qos_width;
 var axi_prot_msb = cmd_addr_width + axi_id_width + cmd_size_width + cmd_qos_width + arprot_width - 1; 

 var mpf1_lsb = cmd_addr_width + axi_id_width + cmd_size_width + cmd_qos_width + arprot_width;
 var mpf1_msb = cmd_addr_width + axi_id_width + cmd_size_width + cmd_qos_width + arprot_width + cmd_mpf1_width -1;

 var lock_lsb = cmd_addr_width + axi_id_width + cmd_size_width + cmd_qos_width + arprot_width + cmd_mpf1_width;
 var lock_msb = cmd_addr_width + axi_id_width + cmd_size_width + cmd_qos_width + arprot_width + cmd_mpf1_width + awlock_width -1;

 var user_lsb = cmd_addr_width + axi_id_width + cmd_size_width + cmd_qos_width + arprot_width + cmd_mpf1_width + awlock_width ;
 var user_msb = cmd_addr_width + axi_id_width + cmd_size_width + cmd_qos_width + arprot_width + cmd_mpf1_width + awlock_width + awuser_width -1;

 var ordering_lsb   = cmd_addr_width + axi_id_width + cmd_size_width + cmd_qos_width + arprot_width + cmd_mpf1_width + awlock_width + awuser_width;
 var ordering_msb   = cmd_addr_width + axi_id_width + cmd_size_width + cmd_qos_width + arprot_width + cmd_mpf1_width + awlock_width + awuser_width + ordering_width - 1;
 
 var ch   = cmd_addr_width + axi_id_width + cmd_size_width + cmd_qos_width + arprot_width + cmd_mpf1_width + awlock_width + awuser_width + ordering_width;
 var vz   = cmd_addr_width + axi_id_width + cmd_size_width + cmd_qos_width + arprot_width + cmd_mpf1_width + awlock_width + awuser_width + ordering_width + 1;
 var ac   = cmd_addr_width + axi_id_width + cmd_size_width + cmd_qos_width + arprot_width + cmd_mpf1_width + awlock_width + awuser_width + ordering_width + 2;
 var ca   = cmd_addr_width + axi_id_width + cmd_size_width + cmd_qos_width + arprot_width + cmd_mpf1_width + awlock_width + awuser_width + ordering_width + 3;
 var st   = cmd_addr_width + axi_id_width + cmd_size_width + cmd_qos_width + arprot_width + cmd_mpf1_width + awlock_width + awuser_width + ordering_width + 4;
 
 var narrow   = cmd_addr_width + axi_id_width + cmd_size_width + cmd_qos_width + arprot_width + cmd_mpf1_width + awlock_width + awuser_width + ordering_width + 5;
 var tof_lsb   = cmd_addr_width + axi_id_width + cmd_size_width + cmd_qos_width + arprot_width + cmd_mpf1_width + awlock_width + awuser_width + ordering_width + 6;
 var tof_msb   = cmd_addr_width + axi_id_width + cmd_size_width + cmd_qos_width + arprot_width + cmd_mpf1_width + awlock_width + awuser_width + ordering_width + 6 + wTOF - 1;

 var wtt_id_lsb = cmd_addr_width + axi_id_width + cmd_size_width + cmd_qos_width + arprot_width + cmd_mpf1_width + awlock_width + awuser_width + ordering_width + 6 + wTOF;
 var wtt_id_msb = cmd_addr_width + axi_id_width + cmd_size_width + cmd_qos_width + arprot_width + cmd_mpf1_width + awlock_width + awuser_width + ordering_width + 6 + wTOF + wtt_id_width - 1;

 var wtt_rotate  = cmd_addr_width + axi_id_width + cmd_size_width + cmd_qos_width + arprot_width + cmd_mpf1_width + awlock_width + awuser_width + ordering_width + 6 + wTOF + wtt_id_width;
 var wtt_ex_pass = cmd_addr_width + axi_id_width + cmd_size_width + cmd_qos_width + arprot_width + cmd_mpf1_width + awlock_width + awuser_width + ordering_width + 6 + wTOF + wtt_id_width + 1;

\jsend

//=============================================================================
// DII Memory Bus Fit
//=============================================================================
wire [\=read_resp_width-1=\:0] int_data_out_fit;

\jsbegin
// Only will not be equal if extrnal memory is used.
/* istanbul ignore else env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */ 
if( read_resp_width == memory_width ) {
\jsend
   assign int_data_out_fit                 = mem_read_buffer_int_data_out;
\jsbegin
} else {
\jsend
   assign int_data_out_fit                 = mem_read_buffer_int_data_out[\=read_resp_width-1=\:0];
\js }

wire transform_chi_wrap_to_incr = read_req_fifo_out_data[\=st=\] & (read_req_fifo_out_data[\=tof_msb=\:\=tof_lsb=\] == \=wTOF=\'b1);

//=============================================================================
// READS
//=============================================================================

reg  [2:0] rd_mpf1_size;
reg  [9:0] rd_mpf1_trans_size;
wire [2:0] rd_mpf1_asize;
wire [9:0] rd_mpf1_alength;
wire       rd_mpf1_valid;
wire       rd_one_beat;
wire [\=wDataWidthBytes=\:0] bus_width_bytes;

wire out_read_req_ready;
wire read_req_fifo_empty;
wire out_read_resp_fifo_ready;

wire rd_narrow = read_req_fifo_out_data[\=narrow=\];

assign rd_mpf1_asize        = cmd_mpf1_rd[5:3];
assign rd_mpf1_alength      = {7'b0,cmd_mpf1_rd[2:0]};

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Address Alignemnt and Size Modification

wire [9:0] rd_mpf1_end_address;
wire [9:0] rd_width_aligned_address;
reg  [9:0] rd_asize_aligned_address;
reg  [9:0] rd_cap_aligned_address;
wire [6:0] rd_mpf1_dii_size;
reg  [5:0] size_aligned_address;
reg  [6:0] chi_device_end_address;
wire [5:0] chi_device_trans_size;

always @ (*) begin
 case(rd_mpf1_asize)
   3'b000: begin
         rd_mpf1_trans_size         =  (rd_mpf1_alength + 10'd1) << 10'd0;
         rd_asize_aligned_address   =  read_req_fifo_out_data[9:0];	 
   end
   3'b001: begin
         rd_mpf1_trans_size         =  (rd_mpf1_alength + 10'd1) << 10'd1;
         rd_asize_aligned_address   =  {read_req_fifo_out_data[9:1],1'b0};	 	 
   end
   3'b010: begin
         rd_mpf1_trans_size         =  (rd_mpf1_alength + 10'd1) << 10'd2;
         rd_asize_aligned_address   =  {read_req_fifo_out_data[9:2],2'b0};	 	 	  
   end
   3'b011: begin
         rd_mpf1_trans_size         =  (rd_mpf1_alength + 10'd1) << 10'd3;
         rd_asize_aligned_address   =  {read_req_fifo_out_data[9:3],3'b0};	 	 	  	 
   end
   3'b100: begin
         rd_mpf1_trans_size         =  (rd_mpf1_alength + 10'd1) << 10'd4;
         rd_asize_aligned_address   =  {read_req_fifo_out_data[9:4],4'b0};	 	 	  	 	 
   end
   3'b101: begin
         rd_mpf1_trans_size         =  (rd_mpf1_alength + 10'd1) << 10'd5;
         rd_asize_aligned_address   =  {read_req_fifo_out_data[9:5],5'b0};	 	 	  	 	 
   end
   default: begin
         rd_mpf1_trans_size         =  (rd_mpf1_alength + 10'd1) << 10'd6;
         rd_asize_aligned_address   =  {read_req_fifo_out_data[9:6],6'b0};	 	 	  	 	 
   end
 endcase
end

always @ (*) begin
 case(rd_mpf1_asize)
   3'b000: begin
         rd_cap_aligned_address   =  read_req_fifo_out_data[9:0];	 
   end
   3'b001: begin
         rd_cap_aligned_address   =  {read_req_fifo_out_data[9:1],1'b0};	 	 
   end
   3'b010: begin
         rd_cap_aligned_address   =  {read_req_fifo_out_data[9:2],2'b0};	 	 	  
   end
   3'b011: begin
         rd_cap_aligned_address   =  {read_req_fifo_out_data[9:3],3'b0};
   end
   3'b100: begin
       \js if(data_width == 64) {
         rd_cap_aligned_address   =  {read_req_fifo_out_data[9:3],3'b0};
       \js } else {
         rd_cap_aligned_address   =  {read_req_fifo_out_data[9:4],4'b0};       
       \js }
   end
   default: begin
       \js if(data_width == 64) {
         rd_cap_aligned_address   =  {read_req_fifo_out_data[9:3],3'b0};
       \js } else if (data_width == 128) {
         rd_cap_aligned_address   =  {read_req_fifo_out_data[9:4],4'b0};       
       \js } else {
         rd_cap_aligned_address   =  {read_req_fifo_out_data[9:5],5'b0};
       \js }	 	 	  	 	 
   end
 endcase
end

\jsbegin
// data_width will not be 32 or above 256. It will be 64 with external AXI Shim.
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
if(data_width == 32) {
\jsend
  assign  rd_width_aligned_address = {read_req_fifo_out_data[9:2],2'b0}; 
\js } else if (data_width ==  64) {
  assign  rd_width_aligned_address = {read_req_fifo_out_data[9:3],3'b0}; 
\js } else if (data_width ==  128) {
  assign  rd_width_aligned_address = {read_req_fifo_out_data[9:4],4'b0};
\jsbegin
 } else {
\jsend
  assign  rd_width_aligned_address = {read_req_fifo_out_data[9:5],5'b0};
\js } 

always @ (*) begin
  case(read_access_size)
   3'b000: begin
	 size_aligned_address   =  read_req_fifo_out_data[5:0];
         chi_device_end_address =  {1'b0,size_aligned_address} + 7'd1;	 
   end
   3'b001: begin
	 size_aligned_address =   {read_req_fifo_out_data[5:1],1'b0};
         chi_device_end_address = {1'b0,size_aligned_address} + 7'd2;	 	 
   end
   3'b010: begin
	 size_aligned_address =  {read_req_fifo_out_data[5:2],2'b0};
         chi_device_end_address = {1'b0,size_aligned_address} + 7'd4;	 	 
   end
   3'b011: begin
	 size_aligned_address =  {read_req_fifo_out_data[5:3],3'b0};
         chi_device_end_address = {1'b0,size_aligned_address} + 7'd8;	 	 
   end
   3'b100: begin
	 size_aligned_address =  {read_req_fifo_out_data[5:4],4'b0};
         chi_device_end_address = {1'b0,size_aligned_address} + 7'd16;	 	 
   end
   3'b101: begin
	 size_aligned_address =  {read_req_fifo_out_data[5],5'b0};
         chi_device_end_address = {1'b0,size_aligned_address} + 7'd32;	 	 
   end
   default: begin
	 size_aligned_address =  6'h0;
         chi_device_end_address = {1'b0,size_aligned_address} + 7'd64;	 	 
   end
  endcase
end

// At most align to bus. However if a Wrap is one beat the address must be aligned to the size of the transfer and the transaction must be changed to an incriment. 
always@(*) begin
 case (read_access_size) 
    \=cmd_size_width=\'d0:  read_size_wrap_addr_mask = {\=cmd_addr_width=\{1'b1}};
    \=cmd_size_width=\'d1:  read_size_wrap_addr_mask = {{\=cmd_addr_width-Math.min(log2ceil( 2),log2ceil(data_width/8))=\{1'b1}},{\=Math.min(log2ceil( 2),log2ceil(data_width/8))=\{1'b0}}};
    \=cmd_size_width=\'d2:  read_size_wrap_addr_mask = {{\=cmd_addr_width-Math.min(log2ceil( 4),log2ceil(data_width/8))=\{1'b1}},{\=Math.min(log2ceil( 4),log2ceil(data_width/8))=\{1'b0}}};
    \=cmd_size_width=\'d3:  read_size_wrap_addr_mask = {{\=cmd_addr_width-Math.min(log2ceil( 8),log2ceil(data_width/8))=\{1'b1}},{\=Math.min(log2ceil( 8),log2ceil(data_width/8))=\{1'b0}}};
    \=cmd_size_width=\'d4:  read_size_wrap_addr_mask = {{\=cmd_addr_width-Math.min(log2ceil(16),log2ceil(data_width/8))=\{1'b1}},{\=Math.min(log2ceil(16),log2ceil(data_width/8))=\{1'b0}}};
    \=cmd_size_width=\'d5:  read_size_wrap_addr_mask = {{\=cmd_addr_width-Math.min(log2ceil(32),log2ceil(data_width/8))=\{1'b1}},{\=Math.min(log2ceil(32),log2ceil(data_width/8))=\{1'b0}}}; 
    default              :  read_size_wrap_addr_mask = {{\=cmd_addr_width-Math.min(log2ceil(64),log2ceil(data_width/8))=\{1'b1}},{\=Math.min(log2ceil(64),log2ceil(data_width/8))=\{1'b0}}};
 endcase
end

always@(*) begin
 case (rd_mpf1_dii_size) 
    7'd1:       rd_mpf1_size = 3'b000;
    7'd2:       rd_mpf1_size = 3'b001;
    7'd4:       rd_mpf1_size = 3'b010;
    7'd8:       rd_mpf1_size = 3'b011;
    \js if ( data_width <= 64 ) {
    7'd16:      rd_mpf1_size = 3'b011;
    7'd32:      rd_mpf1_size = 3'b011;
    7'd64:      rd_mpf1_size = 3'b011;
    default:     rd_mpf1_size = 3'b011;
    \js } else if (data_width <= 128) {
    7'd16:      rd_mpf1_size = 3'b100;
    7'd32:      rd_mpf1_size = 3'b100;
    7'd64:      rd_mpf1_size = 3'b100;
    default:     rd_mpf1_size = 3'b100;
    \js } else {
    7'd16:      rd_mpf1_size = 3'b100;
    7'd32:      rd_mpf1_size = 3'b101;
    7'd64:      rd_mpf1_size = 3'b101;
    default:     rd_mpf1_size = 3'b101;
    \js }
 endcase
end

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Signals needed for AXI Tranaction

assign rd_mpf1_end_address  = (rd_asize_aligned_address + rd_mpf1_trans_size);
assign rd_mpf1_dii_size     = (rd_mpf1_end_address[6:0] - rd_cap_aligned_address[6:0]);
assign rd_mpf1_valid        = read_req_fifo_out_data[\=st=\] & (cmd_mpf1_rd[7:6] != 2'b10) & ~read_req_fifo_out_data[\=ca=\] & ~read_req_fifo_out_data[\=ch=\] & (read_req_fifo_out_data[\=tof_msb=\:\=tof_lsb=\] != \=wTOF=\'b1);
assign rd_one_beat          = ((arlen == 1) & !rd_narrow);  //(axi_mst_ar_len == 'h0);
assign bus_width_bytes      = \=wDataWidthBytes+1=\'d\=data_width_bytes=\;
assign cmd_mpf1_rd          = read_req_fifo_out_data[\=mpf1_msb=\:\=mpf1_lsb=\]; //{BT,ASize,ALength}
assign read_wrap_addr_mask  = {{\=cmd_addr_width-log2ceil(data_width_bytes)=\{1'b1}},{\=log2ceil(data_width_bytes)=\{1'b0}}};
assign read_access_size     =  read_req_fifo_out_data[\=cmd_size_msb=\:\=cmd_size_lsb=\];
assign  use_new_axi_id      =  axi_mst_ar_valid & axi_mst_ar_ready;

assign    access_size_per_burst = (transform_chi_wrap_to_incr) ? ({1'b0,chi_device_end_address} - {2'b0,rd_width_aligned_address[5:0]}) :                   
                                  (rd_mpf1_valid | rd_narrow)  ?  {1'b0,rd_mpf1_dii_size} : (8'd1 << {\=8-cmd_size_width=\'b0,read_access_size});    
assign    axi_bus_width_encoded = (bus_width_encoded > \=Math.max(1,log2ceil(data_width))=\'b111) ? 3'b111 : bus_width_encoded[2:0];

\jsbegin
// data_width will not be 32 or above 256. It will be 64 with external AXI Shim.
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
if(data_width == 32) {
\jsend
  assign  arlen = (access_size_per_burst >> 2) + {\=arlen_width-1=\'b0,|access_size_per_burst[1:0]}; 
\js } else if (data_width ==  64) {
  assign  arlen = (access_size_per_burst >> 3) + {\=arlen_width-1=\'b0,|access_size_per_burst[2:0]}; 
\js } else if (data_width ==  128) {
  assign  arlen = (access_size_per_burst >> 4) + {\=arlen_width-1=\'b0,|access_size_per_burst[3:0]};
\jsbegin
} else {
\jsend
  assign  arlen = (access_size_per_burst >> 5) + {\=arlen_width-1=\'b0,|access_size_per_burst[4:0]};
\js } 

reg [\=awcache_width-1=\:0] rd_cache;
always@(*) begin
 case ({read_req_fifo_out_data[\=st=\],
	read_req_fifo_out_data[\=vz=\],
	read_req_fifo_out_data[\=ordering_msb=\:\=ordering_lsb=\]}) 
    {1'b1,
     1'b1,
     2'b11}:
       rd_cache = 4'b0000;
    {1'b1,
     1'b0,
     2'b11}:
       rd_cache = 4'b0000;
    {1'b0,
     1'b1,
     2'b10}:
       rd_cache = 4'b0010;
    {1'b0,
     1'b0,
     2'b10}:
       rd_cache = 4'b0010;
    {1'b0,
     1'b1,
     2'b01}:
       rd_cache = 4'b0010;
    {1'b0,
     1'b0,
     2'b01}:
       rd_cache = 4'b0010;
    {1'b0,
     1'b0,
     2'b00}:
       rd_cache = 4'b0010;
    {1'b0,
     1'b0,
     2'b11}:
       rd_cache = 4'b0010;
    {1'b0,
     1'b1,
     2'b00}:
       rd_cache = 4'b0010;
    {1'b0,
     1'b1,
     2'b11}:
       rd_cache = 4'b0010;
    default:
       rd_cache = 4'h0;
 endcase
end

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Flow Control

assign  axi_mst_ar_valid    = read_req_fifo_out_valid ;
assign  out_read_req_ready  = axi_mst_ar_ready ;

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// AXI Transaction


wire [\=cmd_addr_width=\-1:0] axi_mst_ar_addr_cmd;
assign    axi_mst_ar_addr_cmd = (rd_mpf1_valid | transform_chi_wrap_to_incr | rd_narrow) ? read_req_fifo_out_data[\=cmd_addr_width-1=\:0]:
                                (rd_one_beat)                                            ? read_req_fifo_out_data[\=cmd_addr_width-1=\:0] & read_size_wrap_addr_mask[\=cmd_addr_width-1=\:0] : read_req_fifo_out_data[\=cmd_addr_width-1=\:0] & read_wrap_addr_mask[\=cmd_addr_width-1=\:0];

\jsbegin
// SMI Addr Width == AXI Addr Width
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
if (araddr_width > cmd_addr_width) {
\jsend
 assign axi_mst_ar_addr = {\=araddr_width-cmd_addr_width=\'b0,axi_mst_ar_addr_cmd};
\js } else {
 assign axi_mst_ar_addr = axi_mst_ar_addr_cmd[\=araddr_width=\-1:0];
\js }
			      
assign    axi_mst_ar_id      = read_req_fifo_out_data[\=axi_id_msb=\:\=axi_id_lsb=\];

\js if (hasQos) {
  \jsbegin
  // QoS always exists in conjunction with SmiQoS
  /* istanbul ignore else env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */ 
  if( wQos != 0 ){
  \jsend
    assign    axi_mst_ar_qos     = read_req_fifo_out_data[\=cmd_qos_msb=\:\=cmd_qos_lsb=\];
  \jsbegin
  } else  /* istanbul ignore next env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */  {
  \jsend
    assign    axi_mst_ar_qos     = 'h0;
  \js }
\js }

\js // Always have ARPROT
\jsbegin
/* istanbul ignore else env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
if (arprot_width != undefined & arprot_width != 0) {
\jsend
assign    axi_mst_ar_prot    = read_req_fifo_out_data[\=axi_prot_msb=\:\=axi_prot_lsb=\]; //{Priv, Security, 0};
\jsbegin
} 
\jsend



assign    axi_mst_ar_burst   = (rd_one_beat | transform_chi_wrap_to_incr)                       ? 2'b01  :
                               (~rd_mpf1_valid)                                                 ? 2'b10  : cmd_mpf1_rd[7:6];
			       
assign    axi_mst_ar_len     = (rd_narrow)     ? rd_mpf1_alength[\=arlen_width=\-1:0] : arlen - \=arlen_width=\'d1;

\js // 7 is from the max transaction size of 64B
\jsbegin
// We wont have bus width of 512b for now.
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
if (7 == (wDataWidthBytes+1)) {
\jsend
wire      ar_access_smaller_than_bus_width = (7'd1 << {\=7-cmd_size_width=\'b0,read_access_size}) < bus_width_bytes;
\js } else  {
wire      ar_access_smaller_than_bus_width = (7'd1 << {\=7-cmd_size_width=\'b0,read_access_size}) < {\=7-(wDataWidthBytes+1)=\'b0,bus_width_bytes};
\js } 

assign    axi_mst_ar_size    = (rd_narrow    ) ?  rd_mpf1_asize :
                               (rd_mpf1_valid) ? ((rd_mpf1_dii_size < {{7-\=wDataWidthBytes+1=\{1'b0}},bus_width_bytes})   ? rd_mpf1_size     : axi_bus_width_encoded):
                                                 ((ar_access_smaller_than_bus_width)                                       ? read_access_size : axi_bus_width_encoded);
		
\js if (nExclusiveEntries > 0) {
assign    axi_mst_ar_lock    = 1'b0;
\js } else {	       
assign    axi_mst_ar_lock    = read_req_fifo_out_data[\=lock_msb=\:\=lock_lsb=\];
\js }

assign    axi_mst_ar_cache   = rd_cache;

\js if (aruser_width != 0){
assign    axi_mst_ar_user    = read_req_fifo_out_data[\=user_msb=\:\=user_lsb=\];
\js }

\jsbegin
// Dont have region signaling
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
if (arregion_width != 0){
\jsend
assign    axi_mst_ar_region  = 'h0;
\js }

\=u.instance({
        instanceName: 'u_bus_width',
        moduleName: 'encoder',
        params: { width : data_width },
        verilogParams: {},
        ports: {
            invector : data_width + '\'d' + data_width_bytes , outdecode : 'bus_width_encoded'
        }
    })=\


//Read Request Output FIFO
//    Replaced to test timing optimization : push_valid      : 'read_req_valid',

// Read Address Compression

wire [\=read_req_width-1=\:0] read_req_data_comp;

assign read_req_data_comp[\=read_req_width-1=\:\=cmd_addr_width=\] = read_req_data[\=read_req_width-1=\:\=cmd_addr_width=\];

  \=u.instance({
        instanceName: 'dii_rd_addr_comp',
        moduleName: 'dii_addr_translation',
        params: {
	   wAddr                 : cmd_addr_width,
	   useAddrTranslation    : useAddrTranslation,
	   nAddrTransRegisters   : nAddrTransRegisters,
	   csrAddrTransInterface : csrAddrTransInterface,
	},
        verilogParams: {},
        ports: {
	  in_addr : 'read_req_data['+cmd_addr_width+'-1:0]',
	  out_addr: 'read_req_data_comp['+cmd_addr_width+'-1:0]'
	},
	interfaces :  [{
          modulePrefix  :  '',
          localPrefix   :  '',
          interface     :   csrAddrTransInterface
	}]
  })=\

\jsbegin
        var dii_rd_req_fifo_Params = {
                width       : read_req_width ,
                depth       : 4,
                bypass_mode : 0
        };

        var  instance_ports_for_dii_rd_req_fifo = {
                clk             : 'clk',
                reset_n         : 'reset_n',
                push_valid      : 'rtt_has_muxarb_valid_entry',
                push_data       : 'read_req_data_comp',
                push_ready      : 'read_req_fifo_ready',
                pop_valid       : 'read_req_fifo_out_valid',
                pop_data        : 'read_req_fifo_out_data',
                pop_ready       : 'out_read_req_ready',
                empty           : 'read_req_fifo_empty'
        };

\jsend

  \=u.instance({
        instanceName: 'dii_rd_req_fifo',
        moduleName: 'dii_fifo',
        params: dii_rd_req_fifo_Params,
        verilogParams: {},
        ports: instance_ports_for_dii_rd_req_fifo
  })=\


assign dwid_next[2:0] = axi_mst_r_last ? 3'b0 : (dwid[2:0] + 3'b1); 

\=u.dffre(  3
          , 'dwid'
	  , 'dwid_next'
	  , "3'b0"
	  , 'axi_mst_r_valid & axi_mst_r_ready'
	  , 'clk'
	  , 'reset_n')=\

//Read Response FIFO
assign read_resp_fifo_in_valid = axi_mst_r_valid;

\jsbegin
// Dont have data user bits
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
if (ruser_width > 0) {
\jsend
assign read_resp_fifo_in_packet = {axi_mst_r_user, axi_mst_r_data, axi_mst_r_resp, axi_mst_r_id, axi_mst_r_last};
\js } else {
assign read_resp_fifo_in_packet = {axi_mst_r_data, axi_mst_r_resp, axi_mst_r_id, axi_mst_r_last};
\js }

assign axi_mst_r_ready = read_resp_fifo_ready;

assign read_resp_valid = read_resp_fifo_out_valid;
assign read_resp_data = read_resp_fifo_out_packet;
assign out_read_resp_fifo_ready = read_resp_ready;

\jsbegin
var dii_read_buffer_mem_interface = [];

memoryInterface['int_data_out'] = -read_resp_width;

var fifoDepth = memDepth;

dii_read_buffer_mem_interface[0] = {
             modulePrefix : '',
             localPrefix  : 'mem_read_buffer_',
             interface    : memoryInterface, exclude : ['int_data_out']
        };
	     
        var dii_r_io_fifo_Params = {
                width           : read_resp_width,
                depth           : fifoDepth,
                bypass_mode     : 0,
		memoryInterface : memoryInterface
        };

        var  instance_ports_for_dii_r_io_fifo_2 = {
                clk              : 'clk',
                reset_n          : 'reset_n',
		int_data_out     : 'int_data_out_fit',
		push_valid       : 'read_resp_fifo_in_valid',
                push_data        : 'read_resp_fifo_in_packet',
                push_ready       : 'read_resp_fifo_ready',
                pop_valid        : 'read_resp_fifo_out_valid',
                pop_data         : 'read_resp_fifo_out_packet',
                pop_ready        : 'out_read_resp_fifo_ready',
                empty            : 'read_resp_fifo_empty',
		corr_mem         : 'mem_data_c',
		ucorr_mem        : 'mem_data_uc',
		corr_data        : 'corr_data',
		corr_error       : 'read_resp_data_c',
		ucorr_error      : 'read_resp_data_uc'
        };
\jsend

\jsbegin
// Only double ported buffer this release
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
if (doublePortReadBuffer == 0) {
\jsend
\=u.instance({
        instanceName   : 'dii_r_io_fifo',
        moduleName     : 'dii_mem_fifo',
        params         : dii_r_io_fifo_Params,
        verilogParams  : {},
        ports          : instance_ports_for_dii_r_io_fifo_2,
	interfaces     : dii_read_buffer_mem_interface,
	portsDelimiter : '\n'
  })=\
\jsbegin
} else {
\jsend
\=u.instance({
        instanceName   : 'dii_r_io_fifo',
        moduleName     : 'dii_mem_fifo_dp',
        params         : dii_r_io_fifo_Params,
        verilogParams  : {},
        ports          : instance_ports_for_dii_r_io_fifo_2,
	interfaces     : dii_read_buffer_mem_interface,
	portsDelimiter : '\n'
  })=\
\js }

// This needs to be set even if the write is dropped from an exclusive fail
assign awdone = (awdone_d1) ? ~dtw_data_done : ((write_req_fifo_out_valid & ~awdone_d1) & (~write_req_ex_pass | axi_mst_aw_ready));

\=u.dffre(  1
          , 'awdone_d1'
	  , 'awdone'
	  , "1'b0"
	  , "1'b1"
	  , 'clk'
	  , 'reset_n')=\

\=u.dffre(  1
          , 'push_d1'
	  , 'write_req_valid'
	  , "1'b0"
	  , "1'b1"
	  , 'clk'
	  , 'reset_n')=\

\=u.dffre(  1
          , 'dtw_data_done_d1'
	  , 'dtw_data_done'
	  , "1'b0"
	  , "1'b1"
	  , 'clk'
	  , 'reset_n')=\

//=============================================================================
// WRITES
//=============================================================================

reg  [2:0] wr_mpf1_size;
reg  [9:0] wr_mpf1_trans_size;
wire [6:0] wr_mpf1_dii_size;
reg  [\=cmd_addr_width=\-1:0] wr_asize_aligned_address;
wire [\=cmd_addr_width=\-1:0] wr_mpf1_end_address;
wire [2:0] wr_mpf1_asize;
wire [9:0] wr_mpf1_alength;
wire       wr_mpf1_valid;
wire       wr_one_beat;


assign wr_mpf1_asize               = cmd_mpf1_wr[5:3];
assign wr_mpf1_alength             = {7'b0,cmd_mpf1_wr[2:0]};
wire wr_narrow                     = write_req_fifo_out_data[\=narrow=\];

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Address Alignments and Size Modifications

reg  [\=cmd_addr_width=\-1:0] write_size_wrap_addr_mask;
reg  [\=cmd_addr_width=\-1:0] wr_cap_aligned_address;
wire [\=cmd_addr_width=\-1:0] wr_width_aligned_address;
reg wr_addr_aligned_with_mpf1_trans;

always @ (*) begin
 case(wr_mpf1_asize)
   3'b000: begin
         wr_mpf1_trans_size         =  (wr_mpf1_alength + 10'd1) << 10'd0;
         wr_asize_aligned_address   =  write_req_fifo_out_data[\=cmd_addr_width=\-1:0];	 	 
   end
   3'b001: begin
         wr_mpf1_trans_size         =  (wr_mpf1_alength + 10'd1) << 10'd1;
         wr_asize_aligned_address   =  {write_req_fifo_out_data[\=cmd_addr_width=\-1:1],1'b0};	 	 	 
   end
   3'b010: begin
         wr_mpf1_trans_size         =  (wr_mpf1_alength + 10'd1) << 10'd2;
         wr_asize_aligned_address   =  {write_req_fifo_out_data[\=cmd_addr_width=\-1:2],2'b0};	 	 	 	 
   end
   3'b011: begin
         wr_mpf1_trans_size         =  (wr_mpf1_alength + 10'd1) << 10'd3;
         wr_asize_aligned_address   =  {write_req_fifo_out_data[\=cmd_addr_width=\-1:3],3'b0};	 	 	 	 
   end
   3'b100: begin
         wr_mpf1_trans_size         =  (wr_mpf1_alength + 10'd1) << 10'd4;
         wr_asize_aligned_address   =  {write_req_fifo_out_data[\=cmd_addr_width=\-1:4],4'b0};	 	 	 	 
   end
   3'b101: begin
         wr_mpf1_trans_size         =  (wr_mpf1_alength + 10'd1) << 10'd5;
         wr_asize_aligned_address   =  {write_req_fifo_out_data[\=cmd_addr_width=\-1:5],5'b0};	 	 	 	 
   end
   default: begin
         wr_mpf1_trans_size         =  (wr_mpf1_alength + 10'd1) << 10'd6;
         wr_asize_aligned_address   =  {write_req_fifo_out_data[\=cmd_addr_width=\-1:6],6'b0};	 	 	 	 	 
   end
 endcase
end

// At most align to bus. However if a Wrap is one beat the address must be aligned to the size of the transfer and the transaction must be changed to an incriment. 
always@(*) begin
 case (write_access_size) 
    \=cmd_size_width=\'d0:  write_size_wrap_addr_mask = {\=cmd_addr_width=\{1'b1}};
    \=cmd_size_width=\'d1:  write_size_wrap_addr_mask = {{\=cmd_addr_width-Math.min(log2ceil( 2),log2ceil(data_width/8))=\{1'b1}},{\=Math.min(log2ceil( 2),log2ceil(data_width/8))=\{1'b0}}};
    \=cmd_size_width=\'d2:  write_size_wrap_addr_mask = {{\=cmd_addr_width-Math.min(log2ceil( 4),log2ceil(data_width/8))=\{1'b1}},{\=Math.min(log2ceil( 4),log2ceil(data_width/8))=\{1'b0}}};
    \=cmd_size_width=\'d3:  write_size_wrap_addr_mask = {{\=cmd_addr_width-Math.min(log2ceil( 8),log2ceil(data_width/8))=\{1'b1}},{\=Math.min(log2ceil( 8),log2ceil(data_width/8))=\{1'b0}}};
    \=cmd_size_width=\'d4:  write_size_wrap_addr_mask = {{\=cmd_addr_width-Math.min(log2ceil(16),log2ceil(data_width/8))=\{1'b1}},{\=Math.min(log2ceil(16),log2ceil(data_width/8))=\{1'b0}}};
    \=cmd_size_width=\'d5:  write_size_wrap_addr_mask = {{\=cmd_addr_width-Math.min(log2ceil(32),log2ceil(data_width/8))=\{1'b1}},{\=Math.min(log2ceil(32),log2ceil(data_width/8))=\{1'b0}}}; 
    default              :  write_size_wrap_addr_mask = {{\=cmd_addr_width-Math.min(log2ceil(64),log2ceil(data_width/8))=\{1'b1}},{\=Math.min(log2ceil(64),log2ceil(data_width/8))=\{1'b0}}};
 endcase
end

\jsbegin
// data_width will not be 32. It will be 64 with external AXI Shim.
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
if(data_width == 32) {
\jsend
  assign  wr_width_aligned_address = {write_req_fifo_out_data[\=cmd_addr_width=\-1:2],2'b0}; 
\js } else if (data_width ==  64) {
  assign  wr_width_aligned_address = {write_req_fifo_out_data[\=cmd_addr_width=\-1:3],3'b0}; 
\js } else if (data_width ==  128) {
  assign  wr_width_aligned_address = {write_req_fifo_out_data[\=cmd_addr_width=\-1:4],4'b0};
\jsbegin
} else {
\jsend
  assign  wr_width_aligned_address = {write_req_fifo_out_data[\=cmd_addr_width=\-1:5],5'b0};
\js }

always @ (*) begin
 case(wr_mpf1_asize)
   3'b000: begin
         wr_cap_aligned_address   =  write_req_fifo_out_data[\=cmd_addr_width=\-1:0];	 
   end
   3'b001: begin
         wr_cap_aligned_address   =  {write_req_fifo_out_data[\=cmd_addr_width=\-1:1],1'b0};	 	 
   end
   3'b010: begin
         wr_cap_aligned_address   =  {write_req_fifo_out_data[\=cmd_addr_width=\-1:2],2'b0};	 	 	  
   end
   3'b011: begin
         wr_cap_aligned_address   =  {write_req_fifo_out_data[\=cmd_addr_width=\-1:3],3'b0};
   end
   3'b100: begin
       \js if(data_width == 64) {
         wr_cap_aligned_address   =  {write_req_fifo_out_data[\=cmd_addr_width=\-1:3],3'b0};
       \js } else {
         wr_cap_aligned_address   =  {write_req_fifo_out_data[\=cmd_addr_width=\-1:4],4'b0};       
       \js }
   end
   default: begin
       \js if(data_width == 64) {
         wr_cap_aligned_address   =  {write_req_fifo_out_data[\=cmd_addr_width=\-1:3],3'b0};
       \js } else if (data_width == 128) {
         wr_cap_aligned_address   =  {write_req_fifo_out_data[\=cmd_addr_width=\-1:4],4'b0};       
       \js } else {
         wr_cap_aligned_address   =  {write_req_fifo_out_data[\=cmd_addr_width=\-1:5],5'b0};
       \js }	 	 	  	 	 
   end
 endcase
end

always@(*) begin
 case (wr_mpf1_dii_size) 
    7'd1:       wr_mpf1_size = 3'b000;
    7'd2:       wr_mpf1_size = 3'b001;
    7'd4:       wr_mpf1_size = 3'b010;
    7'd8:       wr_mpf1_size = 3'b011;
    \js if ( data_width <= 64 ) {
    7'd16:      wr_mpf1_size = 3'b011;
    7'd32:      wr_mpf1_size = 3'b011;
    7'd64:      wr_mpf1_size = 3'b011;
    default:     wr_mpf1_size = 3'b011;
    \js } else if (data_width <= 128) {
    7'd16:      wr_mpf1_size = 3'b100;
    7'd32:      wr_mpf1_size = 3'b100;
    7'd64:      wr_mpf1_size = 3'b100;
    default:     wr_mpf1_size = 3'b100;
    \js } else {
    7'd16:      wr_mpf1_size = 3'b100;
    7'd32:      wr_mpf1_size = 3'b101;
    7'd64:      wr_mpf1_size = 3'b101;
    default:     wr_mpf1_size = 3'b101;
    \js }
 endcase
end

assign write_wrap_addr_mask                               = {{\=cmd_addr_width-log2ceil(data_width_bytes)=\{1'b1}},{\=log2ceil(data_width_bytes)=\{1'b0}}};
assign wr_mpf1_end_address                                = (wr_asize_aligned_address + {\=cmd_addr_width-10=\'b0,wr_mpf1_trans_size});
wire [6:0] full_wr_mpf1_dii_size                          = (wr_mpf1_end_address[6:0] -  wr_cap_aligned_address[6:0]);
assign wr_mpf1_dii_size                                   = full_wr_mpf1_dii_size[6:0];
assign    cmd_mpf1_wr                                     = write_req_fifo_out_data[\=mpf1_msb=\:\=mpf1_lsb=\]; //{BT,ASize,ALength}
assign    write_access_size                               = write_req_fifo_out_data[\=cmd_size_msb=\:\=cmd_size_lsb=\];						    
assign    wr_access_size_per_burst                        = (wr_mpf1_valid) ? {1'b0,wr_mpf1_dii_size} : (8'd1 << {\=8-cmd_size_width=\'b0,write_access_size});

assign wr_mpf1_valid               = write_req_fifo_out_data[\=st=\] & (cmd_mpf1_wr[7:6] != 2'b10) & ~write_req_fifo_out_data[\=ca=\] & ~write_req_fifo_out_data[\=ch=\] & (write_req_fifo_out_data[\=tof_msb=\:\=tof_lsb=\] != \=wTOF=\'b1);
assign wr_one_beat                 = (axi_mst_aw_len == 0) & !wr_narrow;

\jsbegin
// data_width will not be 32. It will be 64 with external AXI Shim.
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
if(data_width == 32) {
\jsend
  assign  awlen = (wr_access_size_per_burst >> 2) + {\=awlen_width-1=\'b0,|wr_access_size_per_burst[1:0]}; 
\js } else if (data_width ==  64) {
  assign  awlen = (wr_access_size_per_burst >> 3) + {\=awlen_width-1=\'b0,|wr_access_size_per_burst[2:0]}; 
\js } else if (data_width ==  128) {
  assign  awlen = (wr_access_size_per_burst >> 4) + {\=awlen_width-1=\'b0,|wr_access_size_per_burst[3:0]}; 
\jsbegin
} else {
\jsend
  assign  awlen = (wr_access_size_per_burst >> 5) + {\=awlen_width-1=\'b0,|wr_access_size_per_burst[4:0]};
\js} 

wire      tranaction_goes_above_top_bytes_of_bus   = ({1'b0,wr_mpf1_end_address[6:0]}) > (wr_width_aligned_address[6:0] + (awlen << (\=log2ceil(data_width/8)=\)));
wire      add_one_to_len                           = (wr_mpf1_valid) ? (tranaction_goes_above_top_bytes_of_bus & write_req_fifo_out_data[\=wtt_rotate=\]) : 1'b0;

assign    write_req_rb_id           = write_req_fifo_out_data[\=wtt_id_msb=\:\=wtt_id_lsb=\];
assign    write_req_ex_pass         = write_req_fifo_out_data[\=wtt_ex_pass=\];

reg [\=awcache_width-1=\:0] wr_cache;
always@(*) begin
 case ({write_req_fifo_out_data[\=st=\],
	write_req_fifo_out_data[\=vz=\],
	write_req_fifo_out_data[\=ordering_msb=\:\=ordering_lsb=\]}) 
    {1'b1,
     1'b1,
     2'b11}:
     wr_cache = 4'b0000;
    {1'b1,
     1'b0,
     2'b11}:
     wr_cache = 4'b0000;
    {1'b0,
     1'b1,
     2'b10}:
     wr_cache = 4'b0010;
    {1'b0,
     1'b0,
     2'b10}:
     wr_cache = 4'b0010;
    {1'b0,
     1'b1,
     2'b01}:
     wr_cache = 4'b0010;
    {1'b0,
     1'b0,
     2'b01}:
     wr_cache = 4'b0010;
    {1'b0,
     1'b0,
     2'b00}:
     wr_cache = 4'b0010;
    {1'b0,
     1'b0,
     2'b11}:
     wr_cache = 4'b0010;
    {1'b0,
     1'b1,
     2'b00}:
     wr_cache = 4'b0010;
    {1'b0,
     1'b1,
     2'b11}:
     wr_cache = 4'b0010;
    default:
     wr_cache = 4'h0;
 endcase
end

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Flow Control

assign  axi_mst_aw_valid            = write_req_fifo_out_valid & ~awdone_d1 & write_req_fifo_out_data[\=wtt_ex_pass=\]; // ~(~(dtw_data_done_d1) & awdone_d1);
assign  out_write_req_ready         = (awdone_d1 | (awdone & awdone_d1 & ~(push_d1 & ~write_req_valid))) & dtw_data_done; // ~wdata_in_progress & ~dtw_data_not_ready;

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// AXI Transaction


wire [\=cmd_addr_width=\-1:0] axi_mst_aw_addr_cmd;
assign    axi_mst_aw_addr_cmd       = (wr_mpf1_valid | wr_narrow) ? write_req_fifo_out_data[\=cmd_addr_width-1=\:0]:
                                      (wr_one_beat)               ? write_req_fifo_out_data[\=cmd_addr_width-1=\:0] & write_size_wrap_addr_mask : write_req_fifo_out_data[\=cmd_addr_width-1=\:0] & write_wrap_addr_mask;

\jsbegin
// SMI Addr Width == AXI Addr Width
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
if (awaddr_width > cmd_addr_width) {
\jsend
 assign axi_mst_aw_addr = {\=awaddr_width-cmd_addr_width=\'b0,axi_mst_aw_addr_cmd};
\js } else {
 assign axi_mst_aw_addr = axi_mst_aw_addr_cmd[\=awaddr_width=\-1:0];
\js }


assign    axi_mst_aw_id             = write_req_fifo_out_data[\=axi_id_msb=\:\=axi_id_lsb=\];

\jsbegin
// Always have ARProt
/* istanbul ignore next env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
if (awprot_width != undefined & awprot_width != 0) {
\jsend
assign    axi_mst_aw_prot           = write_req_fifo_out_data[\=axi_prot_msb=\:\=axi_prot_lsb=\]; //{Priv, Security, 0}
\jsbegin
} 
\jsend

assign    axi_mst_aw_len            = (wr_narrow)      ? wr_mpf1_alength[\=awlen_width=\-1:0]:
                                      (add_one_to_len) ? awlen[\=awlen_width=\-1:0] : (awlen[\=awlen_width=\-1:0] - \=awlen_width=\'d1);

\js // 7 is from the max transaction size of 64B
\jsbegin
// We wont have bus width of 512b for now.
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
if (7 == (wDataWidthBytes+1)) {
\jsend
wire      aw_access_smaller_than_bus_width = (7'd1 << {\=7-cmd_size_width=\'b0,write_access_size}) < bus_width_bytes;
\js } else  {
wire      aw_access_smaller_than_bus_width = (7'd1 << {\=7-cmd_size_width=\'b0,write_access_size}) < {\=7-(wDataWidthBytes+1)=\'b0,bus_width_bytes};
\js } 

assign    axi_mst_aw_size           = (wr_narrow)                            ? wr_mpf1_asize           :
                                      (wr_mpf1_valid)                        ? axi_bus_width_encoded   :
                                      (aw_access_smaller_than_bus_width)     ? write_access_size       : axi_bus_width_encoded;

// QOS will always be on AXI if its in network
\js if ( hasQos ) {
  \jsbegin
  // Will always have both Smi QoS and Axi Qos
  /* istanbul ignore else env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */ 
  if(wQos != 0 ){
  \jsend
    assign    axi_mst_aw_qos            = write_req_fifo_out_data[\=cmd_qos_msb=\:\=cmd_qos_lsb=\];
  \jsbegin
  } else  /* istanbul ignore next env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */  {
  \jsend
    assign    axi_mst_aw_qos            = 'h0;
  \js }
\js }

assign    axi_mst_aw_burst          = (wr_one_beat)                                                    ? 2'b01  :
                                      (~wr_mpf1_valid)                                                 ? 2'b10  : cmd_mpf1_wr[7:6];
		
\js if (nExclusiveEntries > 0) {
assign    axi_mst_aw_lock           = 1'b0;
\js } else {		     
assign    axi_mst_aw_lock           = write_req_fifo_out_data[\=lock_msb=\:\=lock_lsb=\];
\js }

assign    axi_mst_aw_cache          = wr_cache;

\js if (awuser_width != 0){
assign    axi_mst_aw_user           = write_req_fifo_out_data[\=user_msb=\:\=user_lsb=\];
\js }

\jsbegin
// No region signaling
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
if (awregion_width != 0){
\jsend
assign    axi_mst_aw_region         = 'h0;
\js }

// Write Address Compression

wire [\=write_req_width-1=\:0] write_req_data_comp;

assign write_req_data_comp[\=write_req_width-1=\:\=cmd_addr_width=\] = write_req_data[\=write_req_width-1=\:\=cmd_addr_width=\];

  \=u.instance({
        instanceName: 'dii_wr_addr_comp',
        moduleName: 'dii_addr_translation',
        params: {
	  wAddr                 : cmd_addr_width,
	  useAddrTranslation    : useAddrTranslation,
	  nAddrTransRegisters   : nAddrTransRegisters,
	  csrAddrTransInterface : csrAddrTransInterface
	},
        verilogParams: {},
        ports: {
	  in_addr : 'write_req_data['+cmd_addr_width+'-1:0]',
	  out_addr: 'write_req_data_comp['+cmd_addr_width+'-1:0]'
	},
	interfaces : [{
          modulePrefix  :  '',
          localPrefix   :  '',
          interface     :   csrAddrTransInterface
	}]
  })=\

\jsbegin
        var dii_wr_req_fifo_Params = {
                width       : write_req_width ,
                depth       : 4,
                bypass_mode : 1
        };

        var  instance_ports_for_dii_wr_req_fifo = {
                clk             : 'clk',
                reset_n         : 'reset_n',
                push_valid      : 'write_req_valid',
                push_data       : 'write_req_data_comp',
                push_ready      : 'write_req_fifo_ready',
                pop_valid       : 'write_req_fifo_out_valid',
                pop_data        : 'write_req_fifo_out_data',
                pop_ready       : 'out_write_req_ready',
                empty           : 'write_req_fifo_empty'
        };

\jsend

  \=u.instance({
        instanceName: 'dii_wr_req_fifo',
        moduleName: 'dii_fifo',
        params: dii_wr_req_fifo_Params,
        verilogParams: {},
        ports: instance_ports_for_dii_wr_req_fifo
  })=\

//Write Response FIFO
assign write_resp_fifo_in_valid  = axi_mst_b_valid;
assign write_resp_fifo_in_packet = {axi_mst_b_id, axi_mst_b_resp};
assign axi_mst_b_ready            = write_resp_fifo_ready;

assign write_resp_valid          = write_resp_fifo_out_valid;
assign write_resp_data           = write_resp_fifo_out_packet;
assign out_write_resp_ready      = write_resp_ready;
  
\jsbegin
        var dii_b_io_fifo_Params = {
                width       : axi_write_resp_width ,
                depth       : 4,
                bypass_mode : 1
        };

        var  instance_ports_for_dii_b_io_fifo = {
                clk             : 'clk',
                reset_n         : 'reset_n',
                push_valid      : 'write_resp_fifo_in_valid',
                push_data       : 'write_resp_fifo_in_packet',
                push_ready      : 'write_resp_fifo_ready',
                pop_valid       : 'write_resp_fifo_out_valid',
                pop_data        : 'write_resp_fifo_out_packet',
                pop_ready       : 'out_write_resp_ready',
                empty           : 'write_resp_fifo_empty'
        };

\jsend

  \=u.instance({
        instanceName: 'dii_b_io_fifo',
        moduleName: 'dii_fifo',
        params: dii_b_io_fifo_Params,
        verilogParams: {},
        ports: instance_ports_for_dii_b_io_fifo
  })=\



endmodule

