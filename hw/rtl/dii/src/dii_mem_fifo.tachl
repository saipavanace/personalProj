//=============================================================================
// Copyright (C) 2018 Arteris, Inc.
// All rights reserved.
//=============================================================================
\jsbegin
// Memory FIFO  module
//
// The FIFO is used as an elastic store for data which is stored in an external memory.
//=============================================================================
\jsend

\jsbegin
var u               = obj.lib;
var log2ceil        = function(n) { return Math.ceil(Math.log(n)/Math.LN2); };

//-----------------------------------------------------------------------------
// Default Parameters

u.paramDefault('zerodepth'   , 'int'   , 0);
u.paramDefault('bypass_mode' , 'int'   , 0);
u.paramDefault('fastread'    , 'int'   , 1);

//-----------------------------------------------------------------------------
// Top Level Parameters

var width           = u.getParam('width');
var depth           = u.getParam('depth');
var zerodepth       = u.getParam('zerodepth');
var bypass_mode     = u.getParam('bypass_mode');
var logDepth        = log2ceil(depth);
var logDepthp1      = logDepth + 1;
var logDepthm1      = logDepth - 1;
var wOccCnt         = log2ceil(depth+1);
var fastread        = u.getParam('fastread');
var hoqout          = 'pop_data_array';
var rdptr           = 'rd_ptr';
var memoryInterface = u.getParam('memoryInterface');

//=============================================================================
// Clock and Reset Interface
//=============================================================================

u.port('input', 'clk', 1);
u.port('input', 'reset_n', 1);

//=============================================================================
// FIFO Interface
//=============================================================================

u.port('input',  'push_valid', 1);
u.port('input',  'push_data',  width);
u.port('output', 'push_ready', 1);
u.port('output', 'pop_valid',  1);
u.port('output', 'pop_data',   width);
u.port('input',  'corr_data',  width);
u.port('input',  'corr_mem',  1);
u.port('input',  'ucorr_mem',  1);
u.port('input',  'pop_ready',  1);
u.port('output', 'empty',  1);
u.port('output', 'corr_error',  1);
u.port('output', 'ucorr_error',  1);

//=============================================================================
// External Memory Interface
//=============================================================================

obj.lib.interface('', 'master', memoryInterface);
\jsend

module \=u.getModuleName()=\ (
\=u.getPorts('\n    ')=\
);
\jsbegin
//=============================================================================
// Internal Wires and Registers
//=============================================================================
\jsend

reg [\=width+1=\:0]       r_data_out_nxt;
wire [\=width+1=\:0]      r_data_out;

wire [\=logDepthp1-1=\:0] rd_ptr;
reg  [\=logDepthp1-1=\:0] rd_ptr_nxt;
wire [\=logDepthp1-1=\:0] wr_ptr;
reg  [\=logDepthp1-1=\:0] wr_ptr_nxt;

wire                      load_data;
wire                      do_write;
wire                      do_read;
wire                      mem_read;
wire                      full;
wire                      stall;
wire                      w_stall;
wire                      r_do_write;
wire                      r_reset_det;
wire                      corr_err;
wire                      r_corr_err;

assign empty   = (rd_ptr[\=logDepth=\:0] == wr_ptr[\=logDepth=\:0]) & !r_corr_err;

//-----------------------------------------------------------------------------
// Output FIFO

wire                 fifo_valid;
wire [\=width+1=\:0] fifo_data;
wire [\=width+1=\:0] fifo_data_out;
wire                 fifo_ready;

\=u.instance({
        instanceName: 'mem_rd_buffer',
        moduleName: 'fifo',
        params: {
                width       :  width+2,
                depth       :  1,
                bypass_mode :  0
        },
        verilogParams: {},
        ports: {
                clk             : 'clk',
                reset_n         : 'reset_n',
                push_valid      : '(fifo_valid & ~corr_err) | r_corr_err',
                push_data       : 'fifo_data',
                push_ready      : 'fifo_ready',
                pop_valid       : 'pop_valid',
                pop_data        : 'fifo_data_out',
                pop_ready       : 'pop_ready'
        }
})=\

assign {ucorr_error,corr_error,pop_data} = fifo_data_out;

//-----------------------------------------------------------------------------
// Memory Control Logic

assign int_chip_en   = 1'b1;
// Write 0 to first entry in memory after reset
assign int_write_en  = do_write;
assign int_address   = do_write ? wr_ptr[\=logDepthm1=\:0] :
                       do_read  ? rd_ptr_nxt[\=logDepthm1=\:0] : rd_ptr[\=logDepthm1=\:0];

assign push_ready        = ~full; 
assign full              = (rd_ptr[\=logDepth=\] != wr_ptr[\=logDepth=\]) & (rd_ptr[\=logDepth-1=\:0] == wr_ptr[\=logDepth-1=\:0]);

//-----------------------------------------------------------------------------
// Data Out Logic

assign corr_err = ((!(do_write | r_do_write) & !empty)) ? (fifo_valid & fifo_ready & corr_mem) : 'h0;

assign int_data_in = push_data;

always @ (*) begin
//     r_data_out_nxt = ((rd_ptr == wr_ptr) & ~r_corr_err) ? {2'b0,push_data} :
//                      (~r_corr_err)                      ? {ucorr_mem,1'b0,int_data_out} :
//		                                           {1'b0,1'b1,corr_data};

     r_data_out_nxt = r_corr_err                           ? {1'b0,1'b1,corr_data}:
                      (rd_ptr == wr_ptr)                   ? {2'b0,push_data}:
		                                             {ucorr_mem,1'b0,int_data_out};

end

\=u.dffre(       1
              , 'r_corr_err'
	      , 'corr_err & ~r_corr_err'
	      , "1'b0"
	      , "1'b1"
	      , 'clk'
	      , 'reset_n')=\


assign fifo_data        = r_data_out_nxt;
assign fifo_valid       = ((rd_ptr == wr_ptr) & ~r_corr_err) ? (push_valid) : ((!(do_write | r_do_write) & !empty));
	      
//-----------------------------------------------------------------------------
// Stall Logic

\=u.dffre(       1
              , 'r_do_write'
	      , 'do_write'
	      , "1'b0"
	      , "1'b1"
	      , 'clk'
	      , 'reset_n')=\
	      
//-----------------------------------------------------------------------------
// Read Pointer Logic

assign do_read            = fifo_ready & fifo_valid;

\=u.dffre(       logDepthp1
              , 'rd_ptr'
	      , 'rd_ptr_nxt'
	      , '{'+logDepthp1+'{1\'b0}}'
	      , 'do_read'
	      , 'clk'
	      , 'reset_n')=\
	      
always @ (*)
        if(r_corr_err)
	    rd_ptr_nxt = rd_ptr;
        else if (rd_ptr[\=logDepthm1=\:0] == \=logDepth=\'d\=depth-1=\)
            rd_ptr_nxt = { ~rd_ptr[\=logDepth=\], \=logDepth=\'b0 };
        else
            rd_ptr_nxt = rd_ptr + \=logDepthp1=\'b1;

//-----------------------------------------------------------------------------
// Write Pointer Logic

assign do_write           = push_ready & push_valid;

\=u.dffre(       logDepthp1
              , 'wr_ptr'
	      , 'wr_ptr_nxt'
	      , '{'+logDepthp1+'{1\'b0}}'
	      , 'do_write'
	      , 'clk'
	      , 'reset_n')=\
	      
always @ (*) begin
            if (wr_ptr[\=logDepthm1=\:0] == \=logDepth=\'d\=depth-1=\)
                wr_ptr_nxt = { ~wr_ptr[\=logDepth=\], \=logDepth=\'b0 };
            else
                wr_ptr_nxt = wr_ptr + \=logDepthp1=\'b1;
	end
endmodule
