//=============================================================================
// Copyright(C) 2017 Arteris, Inc.
// All rights reserved
//=============================================================================
//\jsbegin
// Rtt control
// Author: Shilpa Sawant 
// Module controls the RTT entries
//=============================================================================
//\jsend

\jsbegin
    var u = obj.lib;

    var bundleFunctions = obj.userLib.bundleFunctions;
    var log2ceil = function(n) { return Math.ceil(Math.log(n)/Math.LN2); };

    var wAddr              =  u.getParam('wAddr');
    var axi_id_width       =  u.getParam('axi_id_width');
    var nRttEntries        =  u.getParam('nRttEntries');
    var rtt_num_entries    =  u.getParam('nRttEntries');
    var wtt_num_entries    =  u.getParam('nWttEntries');
    var wMsgId             =  u.getParam('wMsgId');
    var tid_width          =  u.getParam('wMsgId');
    var init_id_width      =  u.getParam('wInitiatorId'); 
    var wInitiatorId       =  u.getParam('wInitiatorId');
    var rtt_id_width       =  log2ceil(rtt_num_entries);
    var wtt_id_width       =  log2ceil(wtt_num_entries);
    var wIntfSize          =  u.getParam('wIntfSize');
    var wQos               =  u.getParam('wQos');    
    var wQl                =  u.getParam('wQl');
    var wPri               =  u.getParam('wPri');    
    var wMpf1              =  u.getParam('wMpf1');
    var wMpf2              =  u.getParam('wMpf2');
    var wTOF               =  u.getParam('wTOF');
    var tt_id_width        =  Math.max(rtt_id_width, wtt_id_width);
    var TT1                =  obj.lib.getParam('TT1');
    var TTentry2           =  obj.lib.getParam('TTentry2');
    var arprot_width       =  u.getParam('arprot_width');
    var arcache_width      =  u.getParam('arcache_width');
    var aruser_width       =  u.getParam('aruser_width');
    var read_req_width     =  u.getParam('read_req_width');
    var hasUser            =  u.getParam('hasUser');    
    var str_req_width      =  u.getParam('str_req_width');
    var fnNativeInterface  =  u.getParam('fnNativeInterface');
    var wFUnitId           = u.getParam('wFUnitId');
    var wFPortId           = obj.lib.getParam('wFPortId');
    var wChipletId         = obj.lib.getParam('wChipletId');
    var wLinkId            = obj.lib.getParam('wLinkId');
\jsend


\jsbegin
//=============================================================================
// ports
//=============================================================================
for (var i = 0; i < rtt_num_entries; i++) {
    // CLEANUP : Interface has it as an input for the entry, however it the RTT drives it out
    u.port('output', 'rtt_entry'+i+'_muxarb_valid',   1);
    u.port('output', 'rtt_entry'+i+'_valid', 1);
    u.port('output', 'rtt_entry'+i+'_sleep', 1);

    obj.lib.interface('rtt_entry'+i+'_', 'master', obj.lib.getParam('TTentry2'), ['qos','resp_pending','dbad','dtw_tid','dtw_priority','dtw_ql','clear','wo_depnd_id', 'wo_depnd', 'youngest_wo', 'wr_enable','ewa','ewa_sent','muxarb_valid','valid','sleep']);
    
    obj.lib.interface('rtt_entry'+i+'_', 'master', obj.lib.getParam('TT1'), ['prot','resp_pending','dbad','dtw_tid','dtw_priority','dtw_ql','mpf2', 'lock', 'attr', 'prot','ac','vz','tof','narrow','ex_pass']);
 };

    u.port('input', 'clk', 1);
    u.port('input', 'reset_n', 1);
    
    u.port('input',  'rtt_ro_match_rd',   1);
    u.port('input',  'rtt_eo_match_rd',   1);
    u.port('input',  'rtt_ro_match_wr',   1);
    u.port('input',  'rtt_eo_match_wr',   1);
    u.port('input',  'wtt_ro_match_rd',   1);
    u.port('input',  'wtt_eo_match_rd',   1);

    u.port('input',  'rd_ro_depnd_set',  1);
    u.port('input',  'rd_eo_depnd_set',  1);
    u.port('input',  'rd_axi_depnd_set', 1);
    u.port('input',  'rd_sleep_set', 1);
    u.port('input',  'rd_ro_depnd_clear',  rtt_num_entries);
    u.port('input',  'rd_eo_depnd_clear',  rtt_num_entries);
    u.port('input',  'rd_axi_depnd_clear', rtt_num_entries);
    u.port('input',  'rd_sleep_clear', rtt_num_entries);
    u.port('input',  'rd_axi_depnd_id_entry', rtt_num_entries);
    u.port('input',  'rtt_retire_entry', rtt_num_entries);
    u.port('input',  'rtt_new_wr_entry', rtt_num_entries);
    u.port('input',  'rd_ro_depnd_id_in',  tt_id_width);
    u.port('input',  'rd_eo_depnd_id_in',  tt_id_width);
    u.port('input',  'rd_axi_depnd_id_in', tt_id_width);
    u.port('input',  'rd_axi_id_in', axi_id_width);    
    u.port('input',  'rtt_new_axi_id', axi_id_width);
    u.port('input',  'rtt_allocate_new_entry', 1);
    u.port('input',  'wtt_allocate_new_entry', 1);
    u.port('input',  'read_req_fifo_ready', 1);
    u.port('input',  'all_axi_ids_in_use', 1);
    u.port('input',  'axi_id_match_rd', rtt_num_entries);
    u.port('input',  'ro_match_rtt_id', rtt_num_entries);
    u.port('input',  'eo_match_rtt_id', rtt_num_entries);
    u.port('input',  'rtt_cmo_blocked', rtt_num_entries);

    u.port('output', 'read_req_valid', 1);
    u.port('output', 'read_req_data', read_req_width);
    u.port('output', 'rtt_valid_entries', rtt_num_entries);
    u.port('output', 'rtt_has_muxarb_valid_entry', 1);
    u.port('output', 'rtt_muxarb_grant', rtt_num_entries);
    u.port('output', 'rtt_grant_given', rtt_num_entries);
    u.port('output', 'rtt_grant_given_in', rtt_num_entries);
    u.port('output', 'rtt_empty', 1);
    u.port('output', 'rtt_full', 1);
    u.port('output', 'rtt_axi_id', axi_id_width);
    u.port('output', 'rtt_entry_id', rtt_id_width);

    u.port('output', 'rtt_read_alloc_id', tt_id_width);
    
    u.port('input',  'addr_match_rtt', rtt_num_entries);
    u.port('input',  'init_id_match_rtt', rtt_num_entries);

    // Only needed for AXI Native Interface
    u.port('output', 'rtt_retire_entry_cmo' , rtt_num_entries);

    u.port('input' , 'str_req_fifo_ready_cmo', 1);
    u.port('output', 'str_req_fifo_valid_cmo', 1);
    u.port('output', 'str_req_fifo_data_cmo', str_req_width);
    u.port('output', 'str_req_fifo_last_cmo', 1);
    u.port('output', 'str_req_fifo_axi_id_cmo', axi_id_width);

    obj.lib.interface('tt_', 'slave', obj.lib.getParam('TT1'),['ewa']);

\jsend


module \=u.getModuleName()=\
(
\=u.getPorts('\n    ')=\
);

    wire read_request_muxarb_source_ready;
    wire read_request_muxarb_source_valid;
    wire read_request_muxarb_source_last;
    wire [\=read_req_width-1=\:0] read_request_muxarb_source_data;
    wire str_request_muxarb_source_ready;
    wire str_request_muxarb_source_valid;
    wire str_request_muxarb_source_last;
    wire [\=str_req_width + axi_id_width-1=\:0] str_request_muxarb_source_data_comb;
    wire [\=str_req_width-1=\:0] str_request_muxarb_source_data;    
    wire [\=rtt_num_entries-1=\:0] oldest_entry_set;
    wire [\=rtt_num_entries-1=\:0] oldest_entry_clear;
    wire [\=rtt_num_entries=\-1:0] rtt_ro_depnd;
    wire [\=rtt_num_entries=\-1:0] rtt_eo_depnd;
    wire [\=rtt_num_entries=\-1:0] rtt_cmo;
    wire [\=rtt_num_entries=\-1:0] rtt_muxarb_valid_entries;
    wire [\=rtt_num_entries=\-1:0] retire_entry;
    wire [\=axi_id_width-1=\:0] rtt_axi_id_v1;
    wire [\=rtt_id_width-1=\:0] rtt_entry_id_v1;    
    wire [\=tt_id_width-1=\:0] read_comp_id;
    wire [\=tt_id_width-1=\:0] cmo_comp_id;
    wire [\=tt_id_width-1=\:0] read_alloc_id;
    wire rtt_retire;
    wire rtt_cmo_retire;
    wire allocate_bypassing;
    wire allocate_valid;
    wire read_req_last;
\jsbegin
  for (var i = 0; i < rtt_num_entries; i++) {
\jsend
    wire rtt_entry\=i=\_str_muxarb_valid;
    wire read_request_muxarb_sink\=i=\_ready;
    wire read_request_muxarb_sink\=i=\_valid;
    wire read_request_muxarb_sink\=i=\_last;
    wire [\=read_req_width-1=\:0] read_request_muxarb_sink\=i=\_data;
    wire [\=read_req_width-1=\:0] rtt_entry\=i=\_data;
    wire rtt_entry\=i=\_axi_depnd_in;
    wire rtt_entry\=i=\_str_grant;
    wire rtt_entry\=i=\_grant;
\jsbegin
    }
\jsend
    assign retire_entry = rtt_retire_entry_cmo | rtt_retire_entry;


//---------------------------------------------------------
//   Native Interface AXI STRReq Arbitration
//      - For ACE-L the STRReqs will be created from reponces on the ACE-L Interface

\jsbegin
/* istanbul ignore else env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
if(fnNativeInterface == "AXI4" | fnNativeInterface == "AXI3" | fnNativeInterface == "AXI") {
for (var i = 0; i < rtt_num_entries; i++) { 
\jsend
wire                                                 str_request_muxarb_sink\=i=\_ready;
wire                                                 str_request_muxarb_sink\=i=\_valid;
wire                                                 str_request_muxarb_sink\=i=\_last;
wire [\=str_req_width + axi_id_width -1=\:0]         str_request_muxarb_sink\=i=\_data;
wire [\=str_req_width - 3 - wQos - wPri - wQl=\:0]   rtt_entry\=i=\_str_data;
\jsbegin
}
\jsend


\jsbegin
for (var i = 0; i < rtt_num_entries; i++) {
\jsend
assign rtt_retire_entry_cmo[\=i=\]        = str_request_muxarb_sink\=i=\_valid & str_request_muxarb_sink\=i=\_last & rtt_entry\=i=\_str_grant;
assign str_request_muxarb_sink\=i=\_valid = rtt_entry\=i=\_str_muxarb_valid & ~rtt_cmo_blocked[\=i=\];
assign str_request_muxarb_sink\=i=\_last  = str_request_muxarb_sink\=i=\_valid;

assign str_request_muxarb_sink\=i=\_data  = { rtt_entry\=i=\_tm,
                                              \jsbegin
                                              // No ql for this release
                                              /* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
	                                      if (wQl) {
					      \jsend
				   	      rtt_entry\=i=\_ql,
					      \js }
					      \js if (wPri) {
					      rtt_entry\=i=\_priority,
					      \js }
					      \js if (wQos) {
					      rtt_entry\=i=\_qos,
					      \js }
                                              1'b0,
					      rtt_entry\=i=\_str_data,
					      rtt_entry\=i=\_axi_id};

assign rtt_entry\=i=\_str_data            = {\=tt_id_width=\'d0, rtt_entry\=i=\_init_id, rtt_entry\=i=\_tid}; //TT ID, Target ID , R-Message ID
assign rtt_entry\=i=\_str_grant           = str_request_muxarb_sink\=i=\_ready;
\jsbegin
        }
\jsend

assign str_request_muxarb_source_ready = str_req_fifo_ready_cmo;
assign {str_request_muxarb_source_data,str_req_fifo_axi_id_cmo} = str_request_muxarb_source_data_comb;

\jsbegin
var str_requestMuxarbParam = {
        width             : str_req_width + axi_id_width,
        number_of_inputs  : rtt_num_entries
};
    
var instance_ports_for_str_request_muxarb = {
        clk                 : 'clk',
        reset_n             : 'reset_n',
        source_ready        : 'str_request_muxarb_source_ready',
        source_valid        : 'str_request_muxarb_source_valid',
        source_last         : 'str_request_muxarb_source_last',
        source_data         : 'str_request_muxarb_source_data_comb'
};


for (var i = 0; i < rtt_num_entries; i++) {
        instance_ports_for_str_request_muxarb['sink'+i+'_ready'] = 'str_request_muxarb_sink'+i+'_ready';
        instance_ports_for_str_request_muxarb['sink'+i+'_valid'] = 'str_request_muxarb_sink'+i+'_valid';
        instance_ports_for_str_request_muxarb['sink'+i+'_last']  = 'str_request_muxarb_sink'+i+'_last';
        instance_ports_for_str_request_muxarb['sink'+i+'_data']  = 'str_request_muxarb_sink'+i+'_data';
}

\jsend
\=u.instance({
        instanceName   : 'str_request_cmo_muxarb',
        moduleName     : 'muxarb',
        params         : str_requestMuxarbParam,
        verilogParams  : {},
        ports          : instance_ports_for_str_request_muxarb,
        portsDelimiter : '\n    '
    })=\

assign str_req_fifo_valid_cmo = str_request_muxarb_source_valid;
assign str_req_fifo_data_cmo  = str_request_muxarb_source_data;
assign str_req_fifo_last_cmo  = str_req_fifo_valid_cmo;
\jsbegin
} else /* istanbul ignore next env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */ {
    console.log("Error: "+u.getModuleName()+" - DII only supports an AXI Native Interface.");
}
\jsend

\jsbegin
for (var i = 0; i < rtt_num_entries; i++) {
\jsend
    \=bundleFunctions.wiresFromInterface('rtt_entry'+i+'_', TT1, ['qos','ql','priority','prot','cmo','tof','addr', 'init_id', 'ex_pass', 'lock', 'ordering', 'tid', 'size', 'mpf2', 'ewa','intfsize','st','ca','ch', 'tm', 'mpf1','narrow', 'user'], obj.lib.bundle)=\
\jsbegin
}
var read_comp_id_ports = {};
var cmo_comp_id_ports = {};
var read_alloc_id_ports = {};

for (i=0; i<rtt_num_entries ;i++) {
         read_comp_id_ports['in'+i] = tt_id_width+"'d"+i;
         cmo_comp_id_ports['in'+i] = tt_id_width+"'d"+i;
         read_alloc_id_ports['in'+i] = tt_id_width+"'d"+i;	 
}

read_comp_id_ports['sel']   = "rtt_retire_entry";
read_comp_id_ports['out']   = "read_comp_id";

cmo_comp_id_ports['sel']   = "rtt_retire_entry_cmo";
cmo_comp_id_ports['out']   = "cmo_comp_id";

read_alloc_id_ports['sel']   = "rtt_new_wr_entry";
read_alloc_id_ports['out']   = "read_alloc_id";
\jsend
    
\=u.instance({
        instanceName: 'u_read_comp_id',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : rtt_num_entries,
                        wMux             : tt_id_width
        },
        verilogParams: {},
        ports: read_comp_id_ports
})=\

\=u.instance({
        instanceName: 'u_cmo_comp_id',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : rtt_num_entries,
                        wMux             : tt_id_width
        },
        verilogParams: {},
        ports: cmo_comp_id_ports
})=\

\=u.instance({
        instanceName: 'u_read_alloc_id',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : rtt_num_entries,
                        wMux             : tt_id_width
        },
        verilogParams: {},
        ports: read_alloc_id_ports
})=\

\jsbegin
var rtt_axi_id_v1_ports = {};
var rtt_entry_id_v1_ports = {};

for (i=0; i<rtt_num_entries ;i++) {
         rtt_axi_id_v1_ports['in'+i] = "rtt_entry"+i+"_axi_id";
         rtt_entry_id_v1_ports['in'+i] = rtt_id_width+"'d"+i;
}
 
rtt_axi_id_v1_ports['sel']   = "rd_axi_depnd_id_entry";
rtt_axi_id_v1_ports['out']   = "rtt_axi_id_v1";
 
rtt_entry_id_v1_ports['sel']   = "rd_axi_depnd_id_entry";
rtt_entry_id_v1_ports['out']   = "rtt_entry_id_v1";
 
\jsend
    
\=u.instance({
        instanceName: 'u_rtt_axi_id_v1',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : rtt_num_entries,
                        wMux             : axi_id_width
        },
        verilogParams: {},
        ports: rtt_axi_id_v1_ports
})=\

\=u.instance({
        instanceName: 'u_rtt_entry_id_v1',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : rtt_num_entries,
                        wMux             : rtt_id_width
        },
        verilogParams: {},
        ports: rtt_entry_id_v1_ports
})=\

 
assign rtt_axi_id   = rtt_axi_id_v1;
assign rtt_entry_id = rtt_entry_id_v1;

assign rtt_read_alloc_id = read_alloc_id;
assign rtt_retire     = |(rtt_retire_entry);
assign rtt_cmo_retire = |(rtt_retire_entry_cmo);
\jsbegin

var instance_ports_for_rtt_entry = [];
var rtt_entry_interfaces = [];
var dii_num = 0

for (var i = 0; i < rtt_num_entries; i++) {
    rtt_entry_interfaces[dii_num] = {
             modulePrefix : '',
             localPrefix : 'rtt_entry'+i+'_',
             interface : TTentry2, exclude: ['lock', 'cmo','resp_pending','dbad','dtw_tid','dtw_priority','dtw_ql','clear','wo_depnd_id', 'wo_depnd', 'youngest_wo', 'wr_enable','ewa','ewa_sent','muxarb_valid']
                        } ;
    dii_num++

    rtt_entry_interfaces[dii_num] = {
             modulePrefix : '',
             localPrefix : 'rtt_entry'+i+'_',
             interface : TT1, exclude: ['resp_pending','dbad','dtw_tid','dtw_priority','dtw_ql','mpf2', 'attr','ewa','priority']
                        } ;
    dii_num++


\jsend

\js // If there was an EO with an address match, the youngest RO has to be updated properly. The below signals are used to clear the youngest bits.
assign  rtt_ro_depnd[\=i=\] = (((rtt_ro_match_rd | rtt_ro_match_wr) & ro_match_rtt_id[\=i=\]) | ((tt_ordering == 3) & addr_match_rtt[\=i=\] & init_id_match_rtt[\=i=\])); 
assign  rtt_eo_depnd[\=i=\] = (rtt_eo_match_rd | rtt_eo_match_wr) & eo_match_rtt_id[\=i=\];

assign rtt_cmo[\=i=\] = (rtt_entry\=i=\_cmo & rtt_entry\=i=\_valid);
 
wire axi_depnd_sent\=i=\ = rtt_entry\=i=\_valid & rtt_grant_given[rtt_entry\=i=\_axi_depnd_id] & ~rtt_entry\=i=\_cmo & ~rtt_cmo[rtt_entry\=i=\_axi_depnd_id];

\jsbegin
var rtt_entry_ports = {
         clk                        : 'clk',
         reset_n                    : 'reset_n',
         rtt_entry_muxarb_valid     : 'rtt_entry'+i+'_muxarb_valid',
	 rtt_entry_str_muxarb_valid : 'rtt_entry'+i+'_str_muxarb_valid',
         rtt_grant                  : 'rtt_entry'+i+'_grant',
         ordering_in                : 'tt_ordering',
         tid_in                     : 'tt_tid',
         init_id_in                 : 'tt_init_id',
         addr_in                    : 'tt_addr',
         size_in                    : 'tt_size',
         tof_in                     : 'tt_tof',
 	 intfsize_in                : 'tt_intfsize',
	 st_in                      : 'tt_st',
	 ca_in                      : 'tt_ca',
	 ac_in                      : 'tt_ac',
	 vz_in                      : 'tt_vz',
	 ch_in                      : 'tt_ch',
         ex_pass_in                 : 'tt_ex_pass',
	 cmo_in                     : 'tt_cmo',
	 tm_in                      : 'tt_tm',
         mpf1_in                    : 'tt_mpf1',
         mpf2_in                    : 'tt_mpf2',
         lock_in                    : 'tt_lock',
         narrow_in                  : 'tt_narrow',	 
         axi_id_in                  : 'rd_axi_id_in',
         rtt_allocate_new_entry     : 'rtt_allocate_new_entry',
         wtt_allocate_new_entry     : 'wtt_allocate_new_entry',
         ro_depnd_set               : 'rd_ro_depnd_set',
         eo_depnd_set               : 'rd_eo_depnd_set',
         axi_depnd_set              : 'rd_axi_depnd_set',
         wr_enable                  : 'rtt_new_wr_entry['+i+']',
         oldest_entry_set           : 'oldest_entry_set['+i+']',
         sleep_set                  : 'rd_sleep_set',
         ro_depnd_clear             : 'rd_ro_depnd_clear['+i+']',
         eo_depnd_clear             : 'rd_eo_depnd_clear['+i+']',
         axi_depnd_clear            : 'rd_axi_depnd_clear['+i+']',
         oldest_entry_clear         : 'oldest_entry_clear['+i+']',
         sleep_clear                : 'rd_sleep_clear['+i+']',
         valid_clear                : 'retire_entry['+i+']',
         new_rtt_ro_depnd           : 'rtt_ro_depnd['+i+']',
         new_rtt_eo_depnd           : 'rtt_eo_depnd['+i+']',
         ro_depnd_id_in             : 'rd_ro_depnd_id_in',
         eo_depnd_id_in             : 'rd_eo_depnd_id_in',
         axi_depnd_id_in            : 'rd_axi_depnd_id_in',
         wtt_ro_match_rd            : 'wtt_ro_match_rd',
         wtt_eo_match_rd            : 'wtt_eo_match_rd',
         axi_depnd_in               : 'rtt_entry'+i+'_axi_depnd_in',
         rtt_grant_given            : 'rtt_grant_given['+i+']',
         rtt_grant_given_in         : 'rtt_grant_given_in['+i+']',
         axi_depnd_sent             : 'axi_depnd_sent'+i

      };

if(hasUser == 'Y') {
   rtt_entry_ports['user_in'] = 'tt_user';
}

if(TT1.qos != undefined) {
   rtt_entry_ports['qos_in']   = 'tt_qos';
}

// No ql for this release
/* istanbul ignore if env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
if(TT1.ql != undefined) {
   rtt_entry_ports['ql_in']   = 'tt_ql';
}

if(TT1.priority != undefined) {
   rtt_entry_ports['priority_in']   = 'tt_priority';
   rtt_entry_ports['priority_out']  = 'rtt_entry'+i+'_priority';   
}

   rtt_entry_ports['prot_in'] = 'tt_prot';
   
\jsend

\=u.instance({
        instanceName: 'rtt_entry'+i, 
        moduleName: 'dii_rtt_entry',
        params : {
        wAddr             : wAddr,
        axi_id_width      : axi_id_width,
        wMsgId            : wMsgId,
        wInitiatorId      : wInitiatorId,
        nRttEntries       : nRttEntries,
        tt_id_width       : tt_id_width,
	wIntfSize         : wIntfSize,
        wMpf1             : wMpf1,
        wMpf2             : wMpf2,
	wPri              : wPri,
	wQl               : wQl,
	wQos              : wQos,	
        wTOF              : wTOF ,
        arprot_width      : arprot_width,
        arcache_width     : arcache_width,
        aruser_width      : aruser_width,
        TTentry2          : TTentry2,
        TT1               : TT1,
	fnNativeInterface : fnNativeInterface,
	wChipletId        : wChipletId,
	wFUnitId          : wFUnitId,
        wFPortId          : wFPortId
		},
        verilogParams: {},
        ports: rtt_entry_ports,
        interfaces : rtt_entry_interfaces, 
        portsDelimiter: '\n    '
    })=\

\jsbegin
}
\jsend

assign rtt_has_muxarb_valid_entry = |rtt_muxarb_valid_entries;

\jsbegin
for (var i = 0; i < rtt_num_entries; i++) { 
\jsend
        assign rtt_valid_entries[\=i=\]        = rtt_entry\=i=\_valid;
	assign rtt_muxarb_valid_entries[\=i=\] = rtt_entry\=i=\_muxarb_valid;
        assign rtt_muxarb_grant[\=i=\]         = rtt_entry\=i=\_grant;
        assign rtt_entry\=i=\_data             = {rtt_entry\=i=\_tof,
	                                          rtt_entry\=i=\_narrow,
						  rtt_entry\=i=\_st,
						  rtt_entry\=i=\_ca,
						  rtt_entry\=i=\_ac,
						  rtt_entry\=i=\_vz,
						  rtt_entry\=i=\_ch,
						  rtt_entry\=i=\_ordering,
						  \= (hasUser == 'Y') ? 'rtt_entry'+i+'_user,' : '' =\
						  rtt_entry\=i=\_lock,
						  rtt_entry\=i=\_mpf1,
						  \jsbegin
						  /* istanbul ignore else env ncore_3p2,ncore_3p0,ncore_3p4,ncore_3p6,ncore_3p7 */
						  if (arprot_width != 0) {						  
						  \jsend
						  rtt_entry\=i=\_prot,
						  \js } 
						  \= (wQos != 0) ? 'rtt_entry'+i+'_qos,' : '' =\
						  rtt_entry\=i=\_size,
						  rtt_entry\=i=\_axi_id,
						  rtt_entry\=i=\_addr};
\jsbegin
        }
\jsend
        assign rtt_empty = ~(|(rtt_valid_entries[\=rtt_num_entries-1=\:0]));
        assign rtt_full =    &(rtt_valid_entries[\=rtt_num_entries-1=\:0]);

\jsbegin
    var requestMuxarbParam = {
        width             : read_req_width,
        number_of_inputs  : rtt_num_entries
    };
    var instance_ports_for_read_request_muxarb = {
        clk                 : 'clk',
        reset_n             : 'reset_n',
        source_ready        : 'read_request_muxarb_source_ready',
        source_valid        : 'read_request_muxarb_source_valid',
        source_last         : 'read_request_muxarb_source_last',
        source_data         : 'read_request_muxarb_source_data'
    };
    for (var i = 0; i < rtt_num_entries; i++) {
        instance_ports_for_read_request_muxarb['sink'+i+'_ready'] = 'read_request_muxarb_sink'+i+'_ready';
        instance_ports_for_read_request_muxarb['sink'+i+'_valid'] = 'read_request_muxarb_sink'+i+'_valid';
        instance_ports_for_read_request_muxarb['sink'+i+'_last']  = 'read_request_muxarb_sink'+i+'_last';
        instance_ports_for_read_request_muxarb['sink'+i+'_data']  = 'read_request_muxarb_sink'+i+'_data'; 
    }

\jsend

//Setting the oldest entry
//The entry is set to the oldest at the time of allocation if it does not have any RO or EO dependencies or when an older entry that it is dependent on completes.
// Below Register is need for corner case: CONC-4429 (Fixes other than this connected the read return path to the depnd_set path which broke timing.
// - The case is when the axi dependancy is set to the entry that is being retired the same cycle it is being retired.
// - (rtt_entry\=entry=\_valid & rtt_entry\=entry=\_axi_depnd & (rtt_entry\=entry=\_axi_depnd_id == read_comp_id) & rtt_retire) only applys after the entry has been clocked in and not when its being set
// - The fix is to remember what entry was retired. If the entry that was retired matches the axi dependancy then it is the oldest

wire                       r_rtt_retire;
wire [\=tt_id_width-1=\:0] r_read_comp_id;

\=u.dffre(       1
              , 'r_rtt_retire'
	      , 'rtt_retire'
	      , "1'b0"
	      , "1'b1"
	      , 'clk'
	      , 'reset_n')=\

\=u.dffre(       tt_id_width
              , 'r_read_comp_id'
	      , 'read_comp_id'
	      , '{'+tt_id_width+'{1\'b0}}'
	      , "1'b1"
	      , 'clk'
	      , 'reset_n')=\

// Below will probably not be needed for <1.6GHz
wire                       r_cmo_retire;
wire [\=tt_id_width-1=\:0] r_cmo_comp_id;


\=u.dffre(       1
              , 'r_cmo_retire'
	      , 'rtt_cmo_retire'
	      , "1'b0"
	      , "1'b1"
	      , 'clk'
	      , 'reset_n')=\

\=u.dffre(       tt_id_width
              , 'r_cmo_comp_id'
	      , 'cmo_comp_id'
	      , '{'+tt_id_width+'{1\'b0}}'
	      , "1'b1"
	      , 'clk'
	      , 'reset_n')=\

\jsbegin
       for (var entry = 0 ; entry < rtt_num_entries ; entry++) {
\jsend

     assign oldest_entry_set[\=entry=\] =     // Entry is oldest on AXI dependency chain
                              (rtt_allocate_new_entry & rtt_new_wr_entry[\=entry=\] &  ~rtt_entry\=entry=\_axi_depnd_in) |
                              (rtt_entry\=entry=\_valid & rtt_entry\=entry=\_axi_depnd & (rtt_entry\=entry=\_axi_depnd_id == read_comp_id) & rtt_retire) |
			      (rtt_entry\=entry=\_valid & rtt_entry\=entry=\_axi_depnd & (rtt_entry\=entry=\_axi_depnd_id == r_read_comp_id) & r_rtt_retire) |
			      // Need to set the new oldest entry when the CMO is retired - Dont need to check. Dont reuse AXI ID after CMO
			      (rtt_entry\=entry=\_valid & rtt_entry\=entry=\_axi_depnd & (rtt_entry\=entry=\_axi_depnd_id == r_cmo_comp_id)  & r_cmo_retire) ;

     assign oldest_entry_clear[\=entry=\] = rtt_retire_entry[\=entry=\] | rtt_retire_entry_cmo[\=entry=\];
                                               //(axi_id_match_rd[\=entry=\]  & rtt_entry\=entry=\_oldest   & rtt_retire) |
                                               // Need to clear oldest once the CMO STRReq is sent out. 
                                               //(rtt_entry\=entry=\_oldest   & (\=entry=\ == r_cmo_comp_id)  & r_cmo_retire);

\jsbegin
                }
\jsend

    \=u.instance({
        instanceName: 'request_muxarb',
        moduleName: 'muxarb',
        params : requestMuxarbParam,
        verilogParams: {},
        ports: instance_ports_for_read_request_muxarb,
        portsDelimiter: '\n    '
    })=\

\jsbegin
for (var i = 0; i < rtt_num_entries; i++) {
\jsend

assign read_request_muxarb_sink\=i=\_valid = rtt_entry\=i=\_muxarb_valid;
assign read_request_muxarb_sink\=i=\_last  = rtt_entry\=i=\_muxarb_valid;
assign read_request_muxarb_sink\=i=\_data  = rtt_entry\=i=\_data;

assign rtt_entry\=i=\_grant = read_request_muxarb_sink\=i=\_ready;

\jsbegin
        }
\jsend

//
//assign  allocate_bypassing = allocate_bypassing = (read_req_fifo_ready & ~rtt_read_req_active & read_req_fifo_empty &  (allocate_sfipriv[6:0] != MrdFlush) & ~allocate_wr_outstanding & allocate_alloc);
assign allocate_bypassing = 1'b0;
assign allocate_valid = 1'b0;
assign read_req_valid = allocate_bypassing ? allocate_valid : read_request_muxarb_source_valid;

assign read_req_data = allocate_bypassing ? {\=read_req_width=\{1'b0}} : read_request_muxarb_source_data;

//
assign read_req_last = read_req_valid;

assign read_request_muxarb_source_ready = read_req_fifo_ready;


endmodule
 
