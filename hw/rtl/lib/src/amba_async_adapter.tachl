\jsbegin
// Copyright (C) 2024 Arteris, Inc.
// All rights reserved.
//=============================================================================
// This module defines an AMBA async adapter.
// - Can handle any AXI/ACE Style interface defined in InterfaceAXI CPR
//
// Designer: Eric Taylor
//
//=============================================================================

var u                    = obj.lib;
var m                    = obj.userLib;
var bundleFunction       = obj.userLib.bundleFunctions;
var utilFunctions        = obj.userLib;
var cloneDeep            = utilFunctions.deepCopy;
var log2ceil             = function(n) { return Math.ceil(Math.log(n)/Math.LN2); };
var newToOldStyleInterface      = obj.userLib.newToOldStyleInterface.bind( null, obj.userLib )


u.paramDefault('jitterOn', 'int', 0);
u.paramDefault('depth', 'int', 0);
u.paramDefault('syncDepth', 'int', 2);
u.paramDefault('async', 'boolean', true);

u.paramDefault('protectionStyle', 'object', null);
u.paramDefault('interfaces', 'object', {});

//=============================================================================
// Top Level Parameters
//=============================================================================
var interfaces       = obj.lib.getParam('interfaces');
var jitterOn         = obj.lib.getParam('jitterOn');
var depth            = obj.lib.getParam('depth');
var syncDepth        = obj.lib.getParam('syncDepth');
var async            = obj.lib.getParam('async');
var protectionStyle = utilFunctions.hierGetParam('protectionStyle',u.getParam);

let inProtectionInterface = Object.assign({}, interfaces.inProtectionInterface);
let outProtectionInterface = Object.assign({}, interfaces.outProtectionInterface);
let inClkInterface = Object.assign({}, interfaces.inClkInterface);
let outClkInterface = Object.assign({}, interfaces.outClkInterface);

//=============================================================================
// Interface Generation
//=============================================================================

// clk INterface Names
var inClkInterfaceName    = interfaces.inClkInterface.name;
var interfaceFunc         = new obj.userLib[interfaces.inClkInterface.interface];
var inClkInterfaceOldBundle = interfaceFunc.getSignalsBundle(interfaces.inClkInterface.params);
var inClkInterfaceOld = {
                          name: inClkInterfaceName,
                          signals: inClkInterfaceOldBundle
};

var outClkInterfaceName   = interfaces.outClkInterface.name;
var interfaceFunc         = new obj.userLib[interfaces.outClkInterface.interface];
var outClkInterfaceOldBundle = interfaceFunc.getSignalsBundle(interfaces.outClkInterface.params);
var outClkInterfaceOld = {
                          name: outClkInterfaceName,
                          signals: outClkInterfaceOldBundle
};

// protection INterface Names
var inProtectionInterfaceName    = interfaces.inProtectionInterface.name;
var interfaceFunc         = new obj.userLib[interfaces.inProtectionInterface.interface];
var inProtectionInterfaceOldBundle = interfaceFunc.getSignalsBundle(interfaces.inProtectionInterface.params);
var inProtectionInterfaceOld = {
                          name: inProtectionInterfaceName,
                          signals: inProtectionInterfaceOldBundle
};

var outProtectionInterfaceName   = interfaces.outProtectionInterface.name;
var interfaceFunc         = new obj.userLib[interfaces.outProtectionInterface.interface];
var outProtectionInterfaceOldBundle = interfaceFunc.getSignalsBundle(interfaces.outProtectionInterface.params);
var outProtectionInterfaceOld = {
                          name: outProtectionInterfaceName,
                          signals: outProtectionInterfaceOldBundle
};

// In AXI interface params generation
var interfaceFunc         = new obj.userLib[interfaces.inInterface.interface];
var inInterface           = interfaceFunc.getSignals(interfaces.inInterface.params);
var inInterfaceBundle     = interfaceFunc.getSignalsBundle(interfaces.inInterface.params);
var inInterfaceName       = interfaces.inInterface.name;

// Out AXI interface params generation
var interfaceFunc         = new obj.userLib[interfaces.outInterface.interface];
var outInterface          = interfaceFunc.getSignals(interfaces.outInterface.params);
var outInterfaceBundle    = interfaceFunc.getSignalsBundle(interfaces.outInterface.params);
var outInterfaceName      = interfaces.outInterface.name;

//=============================================================================
// Interface Declarations
//=============================================================================
u.nInterfaces(interfaces);

let mInterfaces = ["ar_","aw_","w_","cr_","cd_"];
let sInterfaces = ["r_","b_","ac_"];

// Maps to Interface CPR Object. The InterfaceAXI file in hw-lib/cpr/interfaces defines these
//  sub interface objects.

objectMap = {
   "ar_" : 'InterfaceAXIar',
   "r_" : 'InterfaceAXIr',
   "aw_" : 'InterfaceAXIaw',
   "w_" : 'InterfaceAXIw',
   "b_" : 'InterfaceAXIb',
   "ac_" : 'InterfaceAXIac',
   "cr_" : 'InterfaceAXIcr',
   "cd_" : 'InterfaceAXIcd'
};

\jsend
module \=u.getModuleName()=\ (\=u.getPorts('\n    ')=\);

wire in_clk = \=inClkInterfaceName=\clk;
wire out_clk = \=outClkInterfaceName=\clk;
wire in_reset_n = \=inClkInterfaceName=\reset_n;
wire out_reset_n = \=outClkInterfaceName=\reset_n;

\jsbegin
var interface_keys = Object.keys(inInterface);
let async_interface = {};

\jsend
\=m.bundleFunctions.wiresFromInterface(inInterfaceName+"native_", inInterfaceBundle, [], u.bundle)=\
\=m.bundleFunctions.wiresFromInterface(outInterfaceName+"ioaiu_", outInterfaceBundle, [], u.bundle)=\
\jsbegin

for (let i = 0; i < interface_keys.length; i++ ) {
  if ((interface_keys[i] == "cd_" & ((interfaces.inInterface.params.wCdData != 0) & (interfaces.inInterface.params.wCdData != undefined))) |
      (interface_keys[i] == "ac_" & (interfaces.inInterface.params.eAc)) |
      (interface_keys[i] == "cr_" & (interfaces.inInterface.params.eAc)) |
      (interface_keys[i] == "aw_" | interface_keys[i] == "b_" | interface_keys[i] == "w_" | interface_keys[i] == "ar_" | interface_keys[i] == "r_")
     ) {
\jsend

 \js if (mInterfaces.includes(interface_keys[i])) {
   \=m.bundleFunctions.assignByBundle(inInterfaceName+"native_"+interface_keys[i],inInterfaceName+interface_keys[i], inInterfaceBundle[interface_keys[i]], ["ready_chk"], u.bundle)=\
   \=m.bundleFunctions.assignByBundle(outInterfaceName+interface_keys[i],outInterfaceName+"ioaiu_"+interface_keys[i], outInterfaceBundle[interface_keys[i]], ["valid_chk"], u.bundle)=\

    \js if (Object.keys(inInterfaceBundle[interface_keys[i]]).includes("valid_chk") & inInterfaceBundle[interface_keys[i]]["valid_chk"] != 0) {
      \js var prefix = outInterfaceName + interface_keys[i];
      wire \=prefix=\mismatch_q;
      wire \=prefix=\mismatch    = (\=prefix=\ready_chk == \=prefix=\ready);
      \=u.dffre(1, prefix+"mismatch_q", prefix+"mismatch", `1'd0`, `1'b1`, `out_clk`, `out_reset_n`)=\
      assign \=prefix=\valid_chk = (\=prefix=\mismatch_q)  ? \=prefix=\valid :
                                                            ~\=prefix=\valid;

     \js var prefix = inInterfaceName + interface_keys[i];
      wire \=prefix=\mismatch_q;
      wire \=prefix=\mismatch    = (\=prefix=\valid_chk == \=prefix=\valid);
      \=u.dffre(1, prefix+"mismatch_q", prefix+"mismatch", `1'd0`, `1'b1`, `in_clk`, `in_reset_n`)=\
      assign \=prefix=\ready_chk = (\=prefix=\mismatch_q)  ? \=prefix=\ready :
                                                            ~\=prefix=\ready;
    \js }
  \js } else {
    \=m.bundleFunctions.assignByBundle(inInterfaceName+"native_"+interface_keys[i],inInterfaceName+interface_keys[i], inInterfaceBundle[interface_keys[i]], ["valid_chk"], u.bundle)=\
    \=m.bundleFunctions.assignByBundle(outInterfaceName+interface_keys[i],outInterfaceName+"ioaiu_"+interface_keys[i], outInterfaceBundle[interface_keys[i]], ["ready_chk"], u.bundle)=\

    \js if (Object.keys(inInterfaceBundle[interface_keys[i]]).includes("valid_chk") & inInterfaceBundle[interface_keys[i]]["valid_chk"] != 0) {
      \js var prefix = inInterfaceName + interface_keys[i];
      wire \=prefix=\mismatch_q;
      wire \=prefix=\mismatch    = (\=prefix=\ready_chk == \=prefix=\ready);
      \=u.dffre(1, prefix+"mismatch_q", prefix+"mismatch", `1'd0`, `1'b1`, `in_clk`, `in_reset_n`)=\
      assign \=prefix=\valid_chk = (\=prefix=\mismatch_q)  ? \=prefix=\valid :
                                                            ~\=prefix=\valid;

      \js var prefix = outInterfaceName + interface_keys[i];
      wire \=prefix=\mismatch_q;
      wire \=prefix=\mismatch    = (\=prefix=\valid_chk == \=prefix=\valid);
      \=u.dffre(1, prefix+"mismatch_q", prefix+"mismatch", `1'd0`, `1'b1`, `out_clk`, `out_reset_n`)=\
      assign \=prefix=\ready_chk = (\=prefix=\mismatch_q)  ? \=prefix=\ready :
                                                            ~\=prefix=\ready;
    \js }
\js }

\jsbegin
  }
}

for (let i = 0; i < interface_keys.length; i++ ) {
  if ((interface_keys[i] == "cd_" & ((interfaces.inInterface.params.wCdData != 0) & (interfaces.inInterface.params.wCdData != undefined))) | 
      (interface_keys[i] == "ac_" & (interfaces.inInterface.params.eAc)) | 
      (interface_keys[i] == "cr_" & (interfaces.inInterface.params.eAc)) |
      (interface_keys[i] == "aw_" | interface_keys[i] == "b_" | interface_keys[i] == "w_" | interface_keys[i] == "ar_" | interface_keys[i] == "r_")
     ) {
   var intf = inInterface[interface_keys[i]];
   async_interface = {};

   if (interface_keys[i] == "ac_" || interface_keys[i] == "b_" || interface_keys[i] == "r_") {
     var dir_native = 'master';
     var dir_down   = 'slave';
   } else {
     var dir_native = 'slave';
     var dir_down   = 'master';
   }

var tmpParams = utilFunctions.deepCopy(interfaces.inInterface.params);
if (((interfaces.inInterface.params.wCdData != 0) && (interfaces.inInterface.params.wCdData != undefined)) && (interface_keys[i]=="r_" || interface_keys[i]=="w_")) {
  tmpParams.wCdData = 0;

  if (interface_keys[i]=="r_") { \jsend

\js if (!(Object.keys(inInterfaceBundle[interface_keys[i]]).includes("valid_chk") & inInterfaceBundle[interface_keys[i]]["valid_chk"] != 0)) {
wire \=inInterfaceName=\native_r_ack_chk = 1'b0;
wire \=outInterfaceName=\ioaiu_r_ack_chk;
wire r_ack_error_in = 1'b0;
\js } else {
wire r_ack_error_in = ~(\=inInterfaceName=\native_r_ack_chk ^ \=inInterfaceName=\native_r_ack);
\js }

wire r_ack_valid_in = \=inInterfaceName=\native_r_ack | r_ack_error_in;
wire r_ack_error_out;
wire r_ack_valid_out;
wire ioaiu_r_ack_out;

  \=u.instance({
    'portsDelimiter': '\n    ',
    'instanceName': 'u_async_fifo_r_ack',
    'moduleName':   'async_fifo',
    'params': {
             'jitterOn'     : jitterOn,
             'width'        : 2,
             'depth'        : depth,
             'async'        : async,
             'exposeValids' : 0,
             'exposeNextValids' : 0,
             'inClkInterface' : inClkInterfaceOld,
             'outClkInterface' : outClkInterfaceOld,
             'inProtectionInterface' : inProtectionInterfaceOld,
             'outProtectionInterface' : outProtectionInterfaceOld
    },
    'verilogParams': {},
    'interfaces': [
        {'modulePrefix' : inClkInterfaceOld.name,
         'localPrefix'  : inClkInterfaceOld.name,
         'interface'    : inClkInterfaceOld.signals},
        {'modulePrefix' : outClkInterfaceOld.name,
         'localPrefix'  : outClkInterfaceOld.name,
         'interface'    : outClkInterfaceOld.signals},
        {'modulePrefix' : inProtectionInterfaceOld.name,
         'localPrefix'  : inProtectionInterfaceOld.name,
         'interface'    : inProtectionInterfaceOld.signals},
        {'modulePrefix' : outProtectionInterfaceOld.name,
         'localPrefix'  : outProtectionInterfaceOld.name,
         'interface'    : outProtectionInterfaceOld.signals}
    ],
    'ports': {
             'in_valid' : "r_ack_valid_in",
             'in_ready' : '',
             'in_data' : "{r_ack_error_in,"+inInterfaceName+"native_r_ack}",
             'out_valid' : "r_ack_valid_out",
             'out_ready' : "1'b1",
             'out_data' : "{r_ack_error_out,ioaiu_r_ack_out}"
    }
   })=\

assign \=outInterfaceName=\ioaiu_r_ack = r_ack_valid_out ? ioaiu_r_ack_out : 1'b0;

\js if ((Object.keys(inInterfaceBundle[interface_keys[i]]).includes("valid_chk") & inInterfaceBundle[interface_keys[i]]["valid_chk"] != 0)) {
assign \=outInterfaceName=\ioaiu_r_ack_chk = (r_ack_valid_out & r_ack_error_out) ?  \=outInterfaceName=\ioaiu_r_ack :
                                             (r_ack_valid_out                  ) ? ~\=outInterfaceName=\ioaiu_r_ack :
                                                                                   1'b1;
\js }

\jsbegin
  }

  if (interface_keys[i]=="w_") { \jsend

\js if (!(Object.keys(inInterfaceBundle[interface_keys[i]]).includes("valid_chk") & inInterfaceBundle[interface_keys[i]]["valid_chk"] != 0)) {
wire \=inInterfaceName=\native_w_ack_chk = 1'b0;
wire \=outInterfaceName=\ioaiu_w_ack_chk;
wire w_ack_error_in = 1'b0;
\js } else {
wire w_ack_error_in = ~(\=inInterfaceName=\native_w_ack_chk ^ \=inInterfaceName=\native_w_ack);
\js }

wire w_ack_valid_in = \=inInterfaceName=\native_w_ack | w_ack_error_in;
wire w_ack_error_out;
wire w_ack_valid_out;
wire ioaiu_w_ack_out;

  \=u.instance({
    'portsDelimiter': '\n    ',
    'instanceName': 'u_async_fifo_w_ack',
    'moduleName':   'async_fifo',
    'params': {
             'jitterOn'     : jitterOn,
             'width'        : 2,
             'depth'        : depth,
             'async'        : async,
             'exposeValids' : 0,
             'exposeNextValids' : 0,
             'inClkInterface' : inClkInterfaceOld,
             'outClkInterface' : outClkInterfaceOld,
             'inProtectionInterface' : inProtectionInterfaceOld,
             'outProtectionInterface' : outProtectionInterfaceOld
    },
    'verilogParams': {},
    'interfaces': [
        {'modulePrefix' : inClkInterfaceOld.name,
         'localPrefix'  : inClkInterfaceOld.name,
         'interface'    : inClkInterfaceOld.signals},
        {'modulePrefix' : outClkInterfaceOld.name,
         'localPrefix'  : outClkInterfaceOld.name,
         'interface'    : outClkInterfaceOld.signals},
        {'modulePrefix' : inProtectionInterfaceOld.name,
         'localPrefix'  : inProtectionInterfaceOld.name,
         'interface'    : inProtectionInterfaceOld.signals},
        {'modulePrefix' : outProtectionInterfaceOld.name,
         'localPrefix'  : outProtectionInterfaceOld.name,
         'interface'    : outProtectionInterfaceOld.signals}
    ],
    'ports': {
             'in_valid' : 'w_ack_valid_in',
             'in_ready' : '',
             'in_data' : "{w_ack_error_in,"+inInterfaceName+"native_w_ack}",
             'out_valid' : "w_ack_valid_out",
             'out_ready' : "1'b1",
             'out_data' : "{w_ack_error_out,ioaiu_w_ack_out}"
    }
   })=\

assign \=outInterfaceName=\ioaiu_w_ack = w_ack_valid_out ? ioaiu_w_ack_out : 1'b0;

\js if ((Object.keys(inInterfaceBundle[interface_keys[i]]).includes("valid_chk") & inInterfaceBundle[interface_keys[i]]["valid_chk"] != 0)) {
assign \=outInterfaceName=\ioaiu_w_ack_chk = (w_ack_valid_out & w_ack_error_out) ?  \=outInterfaceName=\ioaiu_w_ack :
                                             (w_ack_valid_out                  ) ? ~\=outInterfaceName=\ioaiu_w_ack :
                                                                                   1'b1;
\js }

\jsbegin
  }
}
   let interface_native = {
       name: inInterfaceName+"native_"+interface_keys[i],
       interface: objectMap[interface_keys[i]],
       params: tmpParams,
       direction: dir_native
     };
     
   let interface_down = {
       name: outInterfaceName+"ioaiu_"+interface_keys[i],
       interface: objectMap[interface_keys[i]],
       params: tmpParams,
       direction: dir_down
     };


   if(mInterfaces.includes(interface_keys[i])){
       async_interface.inClkInterface = inClkInterface;
       async_interface.outClkInterface = outClkInterface;
       async_interface.inProtectionInterface = inProtectionInterface;
       async_interface.outProtectionInterface = outProtectionInterface;
       async_interface.inInterface = interface_native;
       async_interface.outInterface = interface_down;
   } else {
       async_interface.inClkInterface = outClkInterface;
       async_interface.outClkInterface = inClkInterface;
       async_interface.inProtectionInterface = outProtectionInterface;
       async_interface.outProtectionInterface = inProtectionInterface;
       async_interface.inInterface = interface_down;
       async_interface.outInterface = interface_native;   
   }
   \jsend

   //=============================================================================
   // gen_async_adapter
   //=============================================================================
   \=u.nInstance({
         instanceName: 'async_adapter_'+interface_keys[i],
         moduleName: 'gen_async_adapter',
         params: {
                jitterOn: jitterOn,
                depth: depth,
                syncDepth: syncDepth,
                async: async,
                interfaces: async_interface
           },
           interfaceObj: {
                interfaces: async_interface,
                prefixes: async_interface
    }})=\
     
   \jsbegin
  }
}

\jsend
endmodule
