\jsbegin
//============================================================================
// Copyright (C) 2019 Arteris, Inc.
// All rights reserved.
//============================================================================
//
// NAME: Dependency Link
// 
// AUTHOR : Tso-Wei Chang
//
// DESCRIPTION:
// Linklist structure based on dep_id. The requests allocated with same dep_id 
// will form a single link, and within the link only the one without dependency 
// is marked as head. Can handle multiple type of dependencies with multiple 
// dep_links.
//============================================================================
\jsend
\jsbegin
//============================================================================     
// Variables
//============================================================================
   
let u = obj.lib;
let m = obj.userLib;
var bundleFunctions = m.bundleFunctions;

let log2ceil = function(n) { return Math.ceil(Math.log(n)/Math.LN2); };

let depth = u.getParam('depth');
let width = u.getParam('width');
let clkInterface= u.getParam('clkInterface');
let headDeallocOnly = m.ParamDefaultGet(u, 'headDeallocOnly', 'int',    1);
let useSmallArea = m.ParamDefaultGet(u, 'useSmallArea',  'int',    0);
let wRealPtr = useSmallArea ? log2ceil(depth) : depth;

var protectionStyle = m.ParamDefaultGet(u, 'protectionStyle', 'object', {protection: "none", protWidth: 0});

var protectionInterface = m.ParamDefaultGet(u, 'protectionInterface', 'object', {name: "prot_", signals: {}});

//============================================================================
// Ports
//============================================================================
u.port('input', 'alloc_en',             1);
u.port('input', 'alloc_id',         width);
u.port('input', 'alloc_idx',        depth);
u.port('input', 'dealloc_en',           1);
u.port('input', 'dealloc_idx',      depth);
u.port('output','valid_head_vec',   depth);

//============================================================================
// Interfaces
//============================================================================
u.interface('',  'slave',   clkInterface);

u.interface(protectionInterface.name, 'master', protectionInterface.signals);

\jsend
module \=u.getModuleName()=\ (\=u.getPorts('\n    ')=\);
\jsbegin
//============================================================================
// Wires
//============================================================================
\jsend


wire [\=depth-1=\:0] valid;
wire [\=depth-1=\:0] valid_in;
wire                 valid_en;
wire [\=depth-1=\:0] valid_set;
wire [\=depth-1=\:0] valid_clr;
\js for(let i = 0; i < depth; i++) {
wire [\=width-1=\:0] id\=i=\;
wire [\=depth-1=\:0] ptr\=i=\;
wire [\=depth-1=\:0] ptr_in\=i=\;
wire [\=wRealPtr-1=\:0] real_ptr\=i=\;
wire [\=wRealPtr-1=\:0] real_ptr_in\=i=\;
wire real_ptr_valid\=i=\;
wire real_ptr_valid_in\=i=\;
\js }

wire [\=depth-1=\:0] ptr_set;


wire [\=depth-1=\:0] tail;
wire [\=depth-1=\:0] tail_in;
wire [\=depth-1=\:0] tail_set;
wire [\=depth-1=\:0] tail_clr;
wire                 tail_en;

wire [\=depth-1=\:0] head;
wire [\=depth-1=\:0] head_in;
wire [\=depth-1=\:0] head_alloc_set;
wire [\=depth-1=\:0] head_dealloc_set;
wire [\=depth-1=\:0] head_clr;
wire                 head_en;

wire [\=depth-1=\:0] dealloc_idx_ptr_cam;
wire [\=depth-1=\:0] alloc_id_cam;
\jsbegin
/* istanbul ignore if env ncore_3p2, ncore_3p4,ncore_3p6, ncore_3p7  */
if ( headDeallocOnly == 0 ) {
\jsend
wire [\=depth-1=\:0] dealloc_ptr;
wire [\=width-1=\:0] dealloc_id;
wire                 dealloc_is_tail;
wire                 dealloc_ptr_forward;
wire [\=depth-1=\:0] dealloc_ptr_set;
wire [\=depth-1=\:0] alloc_ptr;

\js }
wire                 dealloc_is_head;

\jsbegin
//============================================================================
// Valid
//============================================================================
\jsend

\=bundleFunctions.wiresFromInterface('valid_', protectionInterface.signals, [], u.bundle)=\

\=u.instance({
    'instanceName': 'u_valid',
    'moduleName':   'prot_reg',
    'params': {
      'width'               : depth,
      'protectionStyle'     : protectionStyle,
      'protectionInterface' : protectionInterface },
    'interfaces': [{
      'interface'    : protectionInterface.signals,
      'localPrefix'  : 'valid_',
      'modulePrefix' : protectionInterface.name }],
    'ports': {
      'clk'     : 'clk',
      'reset_n' : 'reset_n',
      'en'      : 'valid_en',
      'd'       : 'valid_in',
      'q'       : 'valid' } })=\

assign valid_in  = valid_set | (valid & ~valid_clr);
assign valid_set = alloc_en ? alloc_idx : \=depth=\'b0;
assign valid_clr = dealloc_en ? dealloc_idx : \=depth=\'b0;
assign valid_en  = alloc_en | dealloc_en;

//============================================================================
// Entry ID
//============================================================================

\js for (let i = 0; i < depth; i++) {

    \=bundleFunctions.wiresFromInterface('id'+i+'_', protectionInterface.signals, [], u.bundle)=\

    \=u.instance({
        'instanceName': 'u_id'+i,
        'moduleName':   'prot_reg',
        'params': {
          'width'               : width,
          'protectionStyle'     : protectionStyle,
          'protectionInterface' : protectionInterface },
        'interfaces': [{
          'interface'    : protectionInterface.signals,
          'localPrefix'  : 'id'+i+'_',
          'modulePrefix' : protectionInterface.name }],
        'ports': {
          'clk'     : 'clk',
          'reset_n' : 'reset_n',
          'en'      : 'valid_set['+i+']',
          'd'       : 'alloc_id',
          'q'       : 'id'+i } })=\

\js }

\jsbegin
//============================================================================
// Entry Pointer
//============================================================================
\jsend

\js for (let i = 0; i < depth; i++) {

    \=bundleFunctions.wiresFromInterface('real_ptr'+i+'_', protectionInterface.signals, [], u.bundle)=\

    \=u.instance({
        'instanceName': 'u_real_ptr'+i,
        'moduleName':   'prot_reg',
        'params': {
          'width'               : wRealPtr,
          'protectionStyle'     : protectionStyle,
          'protectionInterface' : protectionInterface },
        'interfaces': [{
          'interface'    : protectionInterface.signals,
          'localPrefix'  : 'real_ptr'+i+'_',
          'modulePrefix' : protectionInterface.name }],
        'ports': {
          'clk'     : 'clk',
          'reset_n' : 'reset_n',
          'en'      : 'ptr_set['+i+']',
          'd'       : 'real_ptr_in'+i,
          'q'       : 'real_ptr'+i } })=\

    \=bundleFunctions.wiresFromInterface('real_ptr_valid'+i+'_', protectionInterface.signals, [], u.bundle)=\

    \=u.instance({
        'instanceName': 'u_real_ptr_valid'+i,
        'moduleName':   'prot_reg',
        'params': {
          'width'               : 1,
          'protectionStyle'     : protectionStyle,
          'protectionInterface' : protectionInterface },
        'interfaces': [{
          'interface'    : protectionInterface.signals,
          'localPrefix'  : 'real_ptr_valid'+i+'_',
          'modulePrefix' : protectionInterface.name }],
        'ports': {
          'clk'     : 'clk',
          'reset_n' : 'reset_n',
          'en'      : 'ptr_set['+i+']',
          'd'       : 'real_ptr_valid_in'+i,
          'q'       : 'real_ptr_valid'+i } })=\


    assign real_ptr_valid_in\=i=\ = {|{ptr_in\=i=\}};

\jsbegin
/* istanbul ignore if env ncore_3p2, ncore_3p4,ncore_3p6, ncore_3p7 */
if ( headDeallocOnly == 0 ) {
\jsend
    assign ptr_in\=i=\ = alloc_ptr   & {\=depth=\{valid_set[\=i=\]}} |
                         dealloc_ptr & {\=depth=\{dealloc_ptr_set[\=i=\]}};
    
\js } else {
    assign ptr_in\=i=\ = (valid & tail & alloc_id_cam); 
\js }



\jsbegin
/* istanbul ignore if env ncore_3p2, ncore_3p4,ncore_3p6, ncore_3p7 */
if ( headDeallocOnly == 0 ) {    
\jsend
    assign dealloc_ptr_set[\=i=\] = valid[\=i=\] & dealloc_idx_ptr_cam[\=i=\] & dealloc_en;
    assign ptr_set[\=i=\] = valid_set[\=i=\] | dealloc_ptr_set[\=i=\]; 
\js     } else {
    assign ptr_set[\=i=\] = valid_set[\=i=\];
\js     }

\js }
\jsbegin
/* istanbul ignore if env ncore_3p2, ncore_3p4,ncore_3p6, ncore_3p7 */
if ( headDeallocOnly == 0 ) {  
\jsend
assign dealloc_ptr_forward = dealloc_en & dealloc_is_tail & (dealloc_id == alloc_id);
assign alloc_ptr = (dealloc_ptr_forward ? dealloc_ptr : (valid & tail & alloc_id_cam));
\js } 

\jsbegin
//============================================================================
// Head
//============================================================================
\jsend

\=bundleFunctions.wiresFromInterface('head_', protectionInterface.signals, [], u.bundle)=\

\=u.instance({
    'instanceName': 'u_head',
    'moduleName':   'prot_reg',
    'params': {
      'width'               : depth,
      'protectionStyle'     : protectionStyle,
      'protectionInterface' : protectionInterface },
    'interfaces': [{
      'interface'    : protectionInterface.signals,
      'localPrefix'  : 'head_',
      'modulePrefix' : protectionInterface.name }],
    'ports': {
      'clk'     : 'clk',
      'reset_n' : 'reset_n',
      'en'      : 'head_en',
      'd'       : 'head_in',
      'q'       : 'head' } })=\


assign head_in          = head_alloc_set| head_dealloc_set | (head & ~head_clr);
assign head_alloc_set   = alloc_en & ~(|(valid & alloc_id_cam))? alloc_idx : \=depth=\'b0;
assign head_dealloc_set = dealloc_en ? (valid & dealloc_idx_ptr_cam & {\=depth=\{dealloc_is_head}}) : \=depth=\'b0;
assign head_clr         = dealloc_en ? dealloc_idx : \=depth=\'b0;
assign head_en          = alloc_en | dealloc_en;

\jsbegin
//============================================================================
// Tail
//============================================================================
\jsend

\=bundleFunctions.wiresFromInterface('tail_', protectionInterface.signals, [], u.bundle)=\

\=u.instance({
    'instanceName': 'u_tail',
    'moduleName':   'prot_reg',
    'params': {
      'width'               : depth,
      'protectionStyle'     : protectionStyle,
      'protectionInterface' : protectionInterface },
    'interfaces': [{
      'interface'    : protectionInterface.signals,
      'localPrefix'  : 'tail_',
      'modulePrefix' : protectionInterface.name }],
    'ports': {
      'clk'     : 'clk',
      'reset_n' : 'reset_n',
      'en'      : 'tail_en',
      'd'       : 'tail_in',
      'q'       : 'tail' } })=\


assign tail_in  = tail_set | (tail & ~tail_clr);
assign tail_set = (alloc_idx   & {\=depth=\{alloc_en}})
\jsbegin
/* istanbul ignore if env ncore_3p2, ncore_3p4,ncore_3p6, ncore_3p7 */
if ( headDeallocOnly == 0 ) {
\jsend
                 |(dealloc_ptr & {\=depth=\{dealloc_en & dealloc_is_tail & (dealloc_id != alloc_id)}})
\js }
;
assign tail_clr = alloc_en? (valid & tail & alloc_id_cam) : \=depth=\'b0;
assign tail_en  = alloc_en;

\jsbegin
//============================================================================
// CAM
//============================================================================
\jsend

\js for(var j=0; j < depth; j++) {
    assign alloc_id_cam[\=j=\] = (id\=j=\ == alloc_id) & ~(dealloc_idx[\=j=\] & dealloc_en);
    assign dealloc_idx_ptr_cam[\=j=\] = (ptr\=j=\ == dealloc_idx); 
\js }


\jsbegin
/* istanbul ignore if env ncore_3p2, ncore_3p4,ncore_3p6, ncore_3p7 */
if ( headDeallocOnly == 0 ) {  
\jsend
// dealloc is head
assign dealloc_is_head = |(dealloc_idx & head);
// dealloc is tail
assign dealloc_is_tail = |(dealloc_idx & tail);

assign dealloc_ptr = (ptr0 & {\=depth=\{dealloc_idx[0]}})
\js for(var i = 1; i < depth; i++) {
                    |(ptr\=i=\ & {\=depth=\{dealloc_idx[\=i=\]}})
\js }
                    ;

assign dealloc_id  = (id0 & {\=width=\{dealloc_idx[0]}})
\js for(var i = 1; i < depth; i++) {
                    |(id\=i=\ & {\=width=\{dealloc_idx[\=i=\]}})
\js }
                    ;

\js } else {
assign dealloc_is_head = 1'b1;
\js }


//============================================================================
// Output 
//============================================================================

assign valid_head_vec = valid & head;

//============================================================================
// useSmallArea
//============================================================================

    \js for (let i = 0; i < depth; i++) {

\js if (useSmallArea) {

assign ptr\=i=\ = real_ptr_valid\=i=\ ? (\=depth=\'b1 << real_ptr\=i=\) : \=depth=\'b0;

\=u.instance({
    instanceName: 'u_encode_ptr'+i,
    moduleName: 'encoder',
    params: { width: depth },
    ports: {
        invector: 'ptr_in'+i,
        outdecode: 'real_ptr_in'+i
    }
})=\

\js } else {

assign ptr\=i=\ = real_ptr\=i=\;

assign real_ptr_in\=i=\ = ptr_in\=i=\;

\js }

    \js }

\jsbegin
//============================================================================
// Protection MUX
//============================================================================
\jsend

\jsbegin
// Function to convert an interface {{name, signals}) to a { modulePrefix, localPrefix, interface} object
// that is used to specify how local interfaces are mapped to module interfaces of an instance
/* istanbul ignore next ncore_3p7 */
function getModuleLocalInterfacePrefixMap(intrface) {
    const modulePrefix  = intrface.name;
    const localPrefix   = intrface.name;
    return { modulePrefix, localPrefix, "interface": intrface.signals };
}

var local_prot_intf_array = [];

    local_prot_intf_array.push( {name: 'valid_', signals: protectionInterface.signals} );
    local_prot_intf_array.push( {name: 'head_',  signals: protectionInterface.signals} );
    local_prot_intf_array.push( {name: 'tail_',  signals: protectionInterface.signals} );
    for (let i = 0; i < depth; i++) {
        local_prot_intf_array.push( {name: 'id'+i+'_', signals: protectionInterface.signals} );
    }
    for (let i = 0; i < depth; i++) {
        local_prot_intf_array.push( {name: 'real_ptr'+i+'_', signals: protectionInterface.signals} );
    }
    for (let i = 0; i < depth; i++) {
        local_prot_intf_array.push( {name: 'real_ptr_valid'+i+'_', signals: protectionInterface.signals} );
    }
\jsend

\jsbegin

/* istanbul ignore else env ncore_3p7 */
if (protectionStyle.protection === 'none') { \jsend

\js } else {

\=u.instance({
    instanceName: 'u_prot_mux',
    moduleName:   'prot_mux',
    params: {'outInterface' : protectionInterface,
             'inInterfaces' : local_prot_intf_array},
    interfaces: local_prot_intf_array.concat( protectionInterface ).map( getModuleLocalInterfacePrefixMap )
})=\

\js }

endmodule
