\jsbegin
//=============================================================================
// Copyright (C) 2022 Arteris, Inc.
// All rights reserved.
//=============================================================================
// Request Response Mux
// Author: Eric Taylor
//
//=============================================================================

const u					= obj.lib;
const bundleFunctions			= obj.userLib.bundleFunctions;
const libUtils				= obj.userLib;
const log2ceil                          = function(n) { return Math.ceil(Math.log(n)/Math.LN2); };

//=============================================================================
// Default Parameter Declarations
//=============================================================================

u.paramDefault('requestInterfaces' ,'array', []);
u.paramDefault('responseInterfaces','array', []);

//=============================================================================
// Parameters
//=============================================================================

const requestInterfaces		= libUtils.hierGetParam('requestInterfaces', u.getParam);
const responseInterfaces	= libUtils.hierGetParam('responseInterfaces',u.getParam);

//=============================================================================
// Instantiate Interfaces
//=============================================================================

// Clock Interface
u.port('input', 'clk', 1);
u.port('input', 'reset_n', 1);

// Incoming Request Interfaces
for (var i=0 ; i < requestInterfaces.length; i++) {
  for(var intf = 0; intf < requestInterfaces[i].numInterfaces; intf++) {
    u.interface('in_req_'+intf+'_'+requestInterfaces[i].name, 'slave', requestInterfaces[i].signals);
  }
}

// Outgoing Request Interfaces
for (var i=0 ; i < requestInterfaces.length; i++) {
  var modifiedReqIntf = Object.assign({}, requestInterfaces[i].signals);;
  delete modifiedReqIntf[requestInterfaces[i].selectionMap];

  u.interface('out_req_'+requestInterfaces[i].name, 'master', modifiedReqIntf);
  // error case
  /* istanbul ignore else */
  if ( requestInterfaces[i].signals.selectionMap != "" ) {
    var selectionWidth = 0; // For now just use top bits. log2ceil(requestInterfaces[i].numInterfaces);
    u.port('output', 'out_req_'+requestInterfaces[i].name+requestInterfaces[i].selectionMap, requestInterfaces[i].signals[requestInterfaces[i].selectionMap]+selectionWidth)
  }
}

// Outgoing Response Interfaces
for (var i=0 ; i < responseInterfaces.length; i++) {
  for(var  intf = 0; intf < responseInterfaces[i].numInterfaces; intf++) {
    u.interface('out_rsp_'+intf+'_'+responseInterfaces[i].name, 'master', responseInterfaces[i].signals);
  }
}

// Incoming Response Interfaces
for (var i=0 ; i < responseInterfaces.length; i++) {
  var modifiedRspIntf = Object.assign({}, responseInterfaces[i].signals);;
  delete modifiedRspIntf[responseInterfaces[i].selectionMap];
  
  u.interface('in_rsp_'+responseInterfaces[i].name, 'slave', modifiedRspIntf);
  // error case
  /* istanbul ignore else */
  if ( responseInterfaces[i].signals.selectionMap != "" ) {
    var selectionWidth = 0; // For now just use top bits. log2ceil(responseInterfaces[i].numInterfaces);  
    u.port('input', 'in_rsp_'+responseInterfaces[i].name+responseInterfaces[i].selectionMap, responseInterfaces[i].signals[responseInterfaces[i].selectionMap]+selectionWidth)
  }
}

\jsend
module \=u.getModuleName()=\ (\=u.getPorts('\n    ')=\);

\jsbegin
//=============================================================================
// Request Muxing
//=============================================================================

// Loop through all request message types
for (var i=0 ; i < requestInterfaces.length; i++) {
\jsend
  \js var width = requestInterfaces[i].numInterfaces;
  \js var dataWidth = bundleFunctions.getBundleWidth(requestInterfaces[i].signals, ['valid', 'ready'], u.bundle)
  \js var signalKeys = Object.keys(requestInterfaces[i].signals).filter(key => (key != "ready")  & (key != "valid") & (key != "last") & (requestInterfaces[i].signals[key] != 0));

  // Arbitrate Between the Incoming Ports
  wire [\=width-1=\:0] arb_\=i=\_sink_ready;
  wire [\=width-1=\:0] arb_\=i=\_sink_valid;
  wire [\=width-1=\:0] arb_\=i=\_sink_last;
  wire [\=width-1=\:0] arb_\=i=\_sink_grant;
  wire arb_\=i=\_source_ready;
  wire arb_\=i=\_source_valid;
  wire arb_\=i=\_source_last;
  
  \js if (width != 1) {
  wire [\=log2ceil(width)-1=\:0] encoded_grant_\=i=\;
  \js } else {
  wire [0:0]                     encoded_grant_\=i=\;  
  \js }
  
  wire [\=dataWidth=\-1:0] out_bus_\=i=\;

  // For each of the incoming interfaces of a type drive the sink signaling 
  \jsbegin
  for (var intf = 0 ; intf < width; intf++) {
  \jsend
      wire [\=dataWidth=\-1:0] in_bus_\=i=\_\=intf=\ = \=bundleFunctions.packetizeBundle('in_req_'+intf+'_'+requestInterfaces[i].name,requestInterfaces[i].signals,['valid','ready'],u.bundle)=\;
      
      assign arb_\=i=\_sink_valid[\=intf=\] = in_req_\=intf=\_\=requestInterfaces[i].name=\valid;
      assign in_req_\=intf=\_\=requestInterfaces[i].name=\ready = arb_\=i=\_sink_ready[\=intf=\];
      
    \js if (requestInterfaces[i].hasLast) {
      assign  arb_\=i=\_sink_last[\=intf=\] = in_req_\=intf=\_\=requestInterfaces[i].name=\last;
    \js } else {
      assign  arb_\=i=\_sink_last[\=intf=\] = 1'b1;
    \js }    
  \js }

  // Connect Source Signaling
  assign out_req_\=requestInterfaces[i].name=\valid = arb_\=i=\_source_valid;
  assign arb_\=i=\_source_ready = out_req_\=requestInterfaces[i].name=\ready;

  // Instance Arbiter
  \jsbegin
  if ( width != 1) {
    var arbParams = {
        num_inputs  : width
    };
    var instance_ports_for_arb = {
        clk                 : 'clk',
        reset_n             : 'reset_n',
        sink_ready          : 'arb_'+i+'_sink_ready',
        sink_valid          : 'arb_'+i+'_sink_valid',
        sink_last           : 'arb_'+i+'_sink_last',
        sink_grant          : 'arb_'+i+'_sink_grant',
        source_ready        : 'arb_'+i+'_source_ready',
        source_valid        : 'arb_'+i+'_source_valid',
        source_last         : 'arb_'+i+'_source_last'
    };
    \jsend
    \=u.instance({
        instanceName: 'arb'+i,
        moduleName: 'rr_arb_comb_mux',
        params : arbParams,
        verilogParams: {},
        ports: instance_ports_for_arb,
        portsDelimiter: '\n    '
    })=\
  \js } else {
    assign arb_\=i=\_source_last  = arb_\=i=\_sink_last;
    assign arb_\=i=\_source_valid = arb_\=i=\_sink_valid;
    assign arb_\=i=\_sink_ready   = arb_\=i=\_source_ready;
    assign arb_\=i=\_sink_grant   = 1'b1;   
  \js }

  // Encode Selection
  \=obj.lib.instance({
    instanceName: 'grant_encode'+i,
    moduleName: 'encoder',
    params: {
        width: width,
    },
    verilogParams: {},
    ports: {
        invector:   'arb_'+i+'_sink_grant',
        outdecode:  'encoded_grant_'+i,
    },
    interfaces: [],
    portsDelimiter: '\n        '
  })=\


  \=bundleFunctions.wiresFromInterface(requestInterfaces[i].name+'muxout_', requestInterfaces[i].signals, [], u.bundle)=\

  // AO Mux to select correct data signals
  \jsbegin
  var intf_mux_ports = {};

  for (intf=0; intf<width ;intf++) {
         intf_mux_ports['in'+intf] = "in_bus_"+i+"_"+intf;
  }

  intf_mux_ports['sel']   = "arb_"+i+"_sink_grant";
  intf_mux_ports['out']   = "out_bus_"+i;
  \jsend
  
  \=u.instance({
        instanceName: 'u_intf_mux'+i,
        moduleName: 'ao_mux',
        params: {
                        nInputs          : width,
                        wMux             : dataWidth
        },
        verilogParams: {},
        ports: intf_mux_ports
  })=\

  // Assign Outputs
  assign \=bundleFunctions.packetizeBundle(requestInterfaces[i].name+'muxout_',requestInterfaces[i].signals,['valid','ready'],u.bundle)=\ = out_bus_\=i=\;
  
  \=bundleFunctions.assignByBundle('out_req_'+requestInterfaces[i].name, requestInterfaces[i].name+'muxout_' ,requestInterfaces[i].signals, [requestInterfaces[i].selectionMap, 'valid'], u.bundle)=\

  \js if ( requestInterfaces[i].selectionMap != "" ) {
    \js if ( width != 1) {
       // Drive the selection signal out.
       \js var selectionMapWidth = requestInterfaces[i].signals[requestInterfaces[i].selectionMap];
       assign out_req_\=requestInterfaces[i].name=\\=requestInterfaces[i].selectionMap=\ = {encoded_grant_\=i=\,\=requestInterfaces[i].name=\muxout_\=requestInterfaces[i].selectionMap=\[\=selectionMapWidth-log2ceil(width)-1=\:0]};
    \js } else {
       assign out_req_\=requestInterfaces[i].name=\\=requestInterfaces[i].selectionMap=\ = \=requestInterfaces[i].name=\muxout_\=requestInterfaces[i].selectionMap=\;    
    \js }
  \js }
\js }

\jsbegin
//=============================================================================
// Response Muxing
//=============================================================================

// Loop through all response message types
for (var  i=0 ; i < responseInterfaces.length; i++) {
\jsend
  \js var width = responseInterfaces[i].numInterfaces;
  wire [\=width-1=\:0] rsp_sel_vec_\=i=\;
  wire [\=width-1=\:0] ready_vec_\=i=\;
  wire [\=width-1=\:0] ready_vec_qual_\=i=\;

  wire out_ready\=i=\;

  \js if ( responseInterfaces[i].selectionMap != "" ) {
     // Drive the incoming response signals to all of the outputs
     \js for (var intf = 0; intf < width; intf++) {
       \=bundleFunctions.assignByBundle('out_rsp_'+intf+'_'+responseInterfaces[i].name,'in_rsp_'+responseInterfaces[i].name ,responseInterfaces[i].signals, ['valid','ready',responseInterfaces[i].selectionMap], u.bundle)=\
     \js }

     \js for (var intf = 0; intf < width; intf++) {  
        // Drive the selection signal out.
        \js var originalSigWidth = responseInterfaces[i].signals[responseInterfaces[i].selectionMap];
        \js var selectionWidth = log2ceil(responseInterfaces[i].numInterfaces);
	\js if ( selectionWidth != 0 ) {
        assign out_rsp_\=intf=\_\=responseInterfaces[i].name=\\=responseInterfaces[i].selectionMap=\ = { \=selectionWidth=\'b0,
	                                                                                                 in_rsp_\=responseInterfaces[i].name=\\=responseInterfaces[i].selectionMap=\[\=originalSigWidth-selectionWidth-1=\:0]};
	\js } else {
        assign out_rsp_\=intf=\_\=responseInterfaces[i].name=\\=responseInterfaces[i].selectionMap=\ =   in_rsp_\=responseInterfaces[i].name=\\=responseInterfaces[i].selectionMap=\[\=originalSigWidth-1=\:0];	
	\js }
        assign out_rsp_\=intf=\_\=responseInterfaces[i].name=\valid = in_rsp_\=responseInterfaces[i].name=\valid & rsp_sel_vec_\=i=\[\=intf=\];
	assign ready_vec_\=i=\[\=intf=\] = out_rsp_\=intf=\_\=responseInterfaces[i].name=\ready;
     \js }
   \js } else {
     \js for (var intf = 0; intf < width; intf++) {   
        \=bundleFunctions.assignByBundle('out_rsp_'+intf+'_'+responseInterfaces[i].name,'in_rsp_'+responseInterfaces[i].name ,responseInterfaces[i].signals, ['valid','ready'], u.bundle)=\
        assign out_rsp_\=intf=\_\=responseInterfaces[i].name=\valid = in_rsp_\=responseInterfaces[i].name=\valid & rsp_sel_vec_\=i=\[\=intf=\];
	assign ready_vec_\=i=\[\=intf=\] = out_rsp_\=intf=\_\=responseInterfaces[i].name=\ready;	
     \js }
   \js }

   assign ready_vec_qual_\=i=\ = ready_vec_\=i=\ & rsp_sel_vec_\=i=\;

   \=u.instance({
        portsDelimiter: '\n    ',
        instanceName: 'u_prop_ready'+i,
        moduleName:   'logic_tree',
        params: {
          'width' : width,
          'logic' : '|'},
        ports: {
          'din'  : 'ready_vec_qual_'+i,
          'dout' : 'out_ready'+i
	  }
    })=\

    \jsbegin
    for (intf=0; intf<width ;intf++) {
      // Actual Demux Selection
       if (Array.isArray(responseInterfaces[i].demuxSignal)) {
          var selectionString = "{";
	  var top = responseInterfaces[i].demuxSignal.length;
          for(var bit = 0; bit < top-1; bit++) {
	     selectionString += "in_rsp_"+responseInterfaces[i].name+responseInterfaces[i].demuxSignal[bit]+","
	  }
	  selectionString += "in_rsp_"+responseInterfaces[i].name+responseInterfaces[i].demuxSignal[bit] 
	  selectionString += "}";
       \jsend
         assign rsp_sel_vec_\=i=\[\=intf=\] = (\=selectionString=\ == \=intf=\);
       \js } else if (responseInterfaces[i].demuxSignal != "" && width > 1) {
         assign rsp_sel_vec_\=i=\[\=intf=\] = (in_rsp_\=responseInterfaces[i].name=\\=responseInterfaces[i].demuxSignal=\ == \=intf=\);
       \js } else {
         assign rsp_sel_vec_\=i=\[\=intf=\] = 1'b1;       
       \js }
    \js }
    
    assign in_rsp_\=responseInterfaces[i].name=\ready = out_ready\=i=\;
 \js }


endmodule
