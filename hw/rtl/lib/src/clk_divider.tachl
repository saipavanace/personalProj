\jsbegin
//=============================================================================
// Copyright (C) 2017 Arteris, Inc.
// All rights reserved.
//=============================================================================
// Clk Divider Unit
// Author: Ronak Salamat
// //=============================================================================
\jsend

\jsbegin

const u						= obj.lib;
const bundleFunctions				= obj.userLib.bundleFunctions;
const libUtils					= obj.userLib;

var log2ceil = function(n) { return Math.ceil(Math.log(n)/Math.LN2); };


//=============================================================================
// Default Parameter Declarations
//=============================================================================
u.paramDefault('clkDivisors', 'array', [16]);
u.paramDefault('clkInterface','object',null);
u.paramDefault('divisorInterface','object',null);
u.paramDefault('clkOutInterfaces','array',null);



//=============================================================================
// Parameters
//=============================================================================
const clkDivisors = libUtils.hierGetParam('clkDivisors', u.getParam); //reading the clkDivisors as a single array param

const width					= log2ceil(clkDivisors);

const clkInterface				= libUtils.hierGetParam('clkInterface',u.getParam);
const divisorInterface		  		= libUtils.hierGetParam('divisorInterface', u.getParam); //optional interface
//{name:"div_" , signals:{val:4}}	
const clkOutInterfaces = libUtils.hierGetParam('clkOutInterfaces', u.getParam);
//=============================================================================
// Interfaces
//=============================================================================
u.interface(clkInterface.name,    'slave' , clkInterface.signals);

if(divisorInterface){
u.interface(divisorInterface.name, 'slave', divisorInterface.signals);
}

for(let i=0; i<clkOutInterfaces.length; i++) {
u.interface(clkOutInterfaces[i].name, 'master', clkOutInterfaces[i].signals)
};

//=============================================================================
// Local Functions 
//=============================================================================

function getModuleLocalPrefixAndInterface (intrface) {
	const modulePrefix		= intrface.name;
	const localPrefix		= intrface.name;
	return { modulePrefix, localPrefix, "interface": intrface.signals };
}


//=============================================================================
// Instantiate Interfaces
//=============================================================================

\jsend
module \=u.getModuleName()=\ (\=u.getPorts('\n    ')=\);

\jsbegin
 
const stateInterface		= { name: "state_", signals: { val: width } };
const evtTmrInterface		= { name: "evt_", signals: { count: 1, start: 1, stop: 1, reset: 1, tmr: -1 } };

const local					= {
	limit		: width,
	mode		: 2,
	en		: 1
};


\jsend
\=bundleFunctions.wiresFromInterface("", local, [], obj.lib.bundle)=\
\=bundleFunctions.wiresFromInterface(evtTmrInterface.name, evtTmrInterface.signals, [], obj.lib.bundle)=\
\=bundleFunctions.wiresFromInterface(stateInterface.name, stateInterface.signals, [], obj.lib.bundle)=\



assign \=evtTmrInterface.name=\start = \=evtTmrInterface.signals["start"]=\'b1;
assign \=evtTmrInterface.name=\count = \=evtTmrInterface.signals["count"]=\'b1;
assign \=evtTmrInterface.name=\stop = \=evtTmrInterface.signals["stop"]=\'b0;
assign \=evtTmrInterface.name=\reset = \=evtTmrInterface.signals["reset"]=\'b0;


assign en = 1'b1;
assign mode = 2'd0;

//if the optional interface has been passed to clk_dividor, it's being used O.W. [clkDivisors] is used
\jsbegin
if(divisorInterface) { \jsend
	assign limit = \=divisorInterface.name=\val; \jsbegin
} else { \jsend
assign limit = \=width=\'d\=clkDivisors-1=\; \jsbegin
} \jsend

 // Instantiate nocre_pmon_tmr:
  \=u.instance({
      instanceName: 'u_ncore_pmon_tmr',
      moduleName: 'ncore_pmon_tmr',
      params: {
          width,
		  internalState		: true,
		  clkInterface,
		  stateInterface,
		  evtTmrInterface
      },
      ports: {
          	  en    : 'en',
		  mode	: 'mode',
		  limit	: 'limit'     
      },
	  interfaces	: [ clkInterface, stateInterface, evtTmrInterface ].map( getModuleLocalPrefixAndInterface )
  })=\

\jsbegin
for (let i=0; i<clkOutInterfaces.length; i++) {

  Object.keys(clkInterface.signals).sort().forEach( signal => {
	if((signal !== 'clk') && clkInterface.signals[signal]) { \jsend
		assign \=clkOutInterfaces[i].name+signal=\	= \=clkInterface.name+signal=\; \jsbegin
	}
  }); \jsend
		assign \=clkOutInterfaces[i].name=\clk		= \=evtTmrInterface.name=\tmr; \jsbegin

 } \jsend

endmodule
