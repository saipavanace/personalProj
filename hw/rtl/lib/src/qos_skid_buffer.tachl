\jsbegin
var u = obj.lib;
var m = obj.userLib;
var bundleFunctions = m.bundleFunctions;
var log2ceil = function(n) { return Math.ceil(Math.log(n)/Math.LN2); };

var p = u.getParam();

var protectionInterface = m.ParamDefaultGet(u, 'protectionInterface', 'object', {name: "prot_", signals: {}});
var protectionStyle = m.ParamDefaultGet(u, 'protectionStyle', 'object', {protection: "none", protWidth: 0});

var wReqPkt             = bundleFunctions.getBundleWidth(p.reqInterface, ['valid', 'ready'], u.bundle);
var wPriority           = p.reqInterface.priority ;
var nPriority           = Math.pow(2, wPriority);

var starvCntOffset      = 0;  // 1 events
var wStarvCnt           = p.wStarvThreshold + starvCntOffset;

var wDepth = log2ceil(p.depth);


u.port('input', 'starv_en',                             1);
u.port('input', 'starv_threshold',        p.wStarvThreshold);
u.port('input', 'qos_disable',                          1);
u.port('output', 'starv_overflow_event', 1);
u.port('output', 'starv_mode', 1);
 
u.port('output', 'empty',                               1);
u.port('output', 'full',                               1);


//============================================================================
// Interfaces
//============================================================================
u.interface('',             'slave',        p.clkInterface,            []);

u.interface('req_in_',      'slave',        p.reqInterface,            []);
u.interface('req_out_',     'master',       p.reqInterface, []);

u.interface(protectionInterface.name, 'master', protectionInterface.signals);


\jsend
module \=u.getModuleName()=\ (\=u.getPorts('\n    ')=\);


wire [\=wDepth=\:0] req_count_in, req_count_q0;
wire                req_count_en;
wire alloc_en,dealloc_en;
wire full_com, empty_com;

wire [\=p.depth-1=\ : 0] req_entry_valid, req_entry_valid_d, valid_com, req_entry_not_valid, req_valid;
wire req_entry_valid_en;
wire [\=p.depth-1=\ : 0] req_entry_alloc_ptr;

wire [\=p.depth-1=\ : 0] starv_valid;
wire                     starv_update_valid;
wire [\=wReqPkt-1=\ : 0] req_entry_in;

\jsbegin
for(var i=0;i<p.depth;i++){
\jsend
wire req_entry_en\=i=\;
wire [\=wReqPkt-1=\ : 0] req_entry_\=i=\;
\=bundleFunctions.wiresFromInterface('req_entry_'+i+"_",        p.reqInterface,    [], obj.lib.bundle)=\

wire req_entry_pri_en\=i=\;
wire [\=wPriority-1=\ : 0] req_entry_pri_\=i=\, req_entry_pri_d\=i=\, arb_req_entry_pri\=i=\;
\jsbegin
}
\jsend
wire [\=wReqPkt-1=\ :0] req_entry_out, req_entry_out_mux;
wire [\=p.depth-1=\ : 0] arb_vec;
wire [\=log2ceil(p.depth)-1=\ : 0] arb_index;

\= p.bypass ? "wire bypass;":""=\
wire arb_grant;

\jsbegin
/////////////////////////////////////////////////////////////////////////////
//Request count
// This coutners increment on allocation and decrements on deallocation
//allocation happens on new request being valid and the buffer not being full and there was not a bypass i.e out is ready and the buffer is empty
// the bypass path should be reasonably fast
// deallcoation happens the output handshake happens
//full and empty signals are generated based on the count. 
/////////////////////////////////////////////////////////////////////////////
\jsend

assign req_count_in = req_count_q0 - {\=wDepth=\'h0,alloc_en} + {\=wDepth=\'h0,dealloc_en}; 
assign req_count_en = alloc_en | dealloc_en;

assign dealloc_en = arb_grant & req_out_ready;

\=p.bypass ? "assign bypass = (empty & req_in_valid & req_out_ready);":""=\
assign alloc_en = req_in_valid & req_in_ready \=p.bypass ? "& ~bypass":""=\;

\=u.instance({
    'instanceName': 'request_count',
    'moduleName':   'prot_reg',
    'params': {
      'width'               : wDepth+1,
      'protectionStyle'     : protectionStyle,
      'protectionInterface' : protectionInterface,
      "rstVal"              : (wDepth+1)+"'d"+(p.depth)},
    'interfaces': [{
      'interface'    : protectionInterface.signals,
      'localPrefix'  : 'request_count_',
      'modulePrefix' : protectionInterface.name }],
    'ports': {
      'clk'     : 'clk',
      'reset_n' : 'reset_n',
      'en'      : 'req_count_en',
      'd'       : 'req_count_in',
      'q'       : 'req_count_q0' } })=\

assign full = ( req_count_q0 == \=wDepth+1=\'d0 );
assign empty = ( req_count_q0 == \=wDepth+1=\'d\=p.depth=\ );
assign req_in_ready = ~full;

\jsbegin
/////////////////////////////////////////////////////////////////////////////
//End Request count
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//Valid
//valid is set on allocation and cleared on deallocation
/////////////////////////////////////////////////////////////////////////////
\jsend

assign req_entry_valid_d = (req_entry_alloc_ptr & {\=p.depth=\{alloc_en}}) 
                          |(req_entry_valid & ~(arb_vec & {\=p.depth=\{dealloc_en}})); 
assign req_entry_valid_en = alloc_en | dealloc_en;

\=u.instance({
    'instanceName': 'u_req_entry_valid',
    'moduleName':   'prot_reg',
    'params': {
      'width'               : p.depth,
      'protectionStyle'     : protectionStyle,
      'protectionInterface' : protectionInterface },
    'interfaces': [{
      'interface'    : protectionInterface.signals,
      'localPrefix'  : 'req_entry_valid_',
      'modulePrefix' : protectionInterface.name }],
    'ports': {
      'clk'     : 'clk',
      'reset_n' : 'reset_n',
      'en'      : 'req_entry_valid_en',
      'd'       : 'req_entry_valid_d',
      'q'       : 'req_entry_valid' } })=\

assign req_entry_not_valid = ~req_entry_valid;

\=u.instance({
  instanceName: 'alloc_find_first',
  moduleName: 'find_first_one',
  params: {
      width: p.depth 
  },
  verilogParams: {},
  ports: {
      invec: 'req_entry_not_valid',
      outvec:'req_entry_alloc_ptr'},
  interfaces: [],
  portsDelimiter: '\n        '
})=\

\jsbegin
/////////////////////////////////////////////////////////////////////////////
//End valid
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//entries
//the entries are only updated on allocation
/////////////////////////////////////////////////////////////////////////////
\jsend


assign req_entry_in = \=bundleFunctions.packetizeBundle('req_in_', p.reqInterface, ['valid', 'ready'], u.bundle)=\;

\jsbegin
for (var i=0;i<p.depth;i++){
\jsend 
assign req_entry_en\=i=\ = req_entry_alloc_ptr[\=i=\] & alloc_en ;

    \=u.instance({
        'instanceName': 'req_entry_dffre_'+i,
        'moduleName':   'prot_reg',
        'params': {
          'width'               : wReqPkt,
          'protectionStyle'     : protectionStyle,
          'protectionInterface' : protectionInterface },
        'interfaces': [{
          'interface'    : protectionInterface.signals,
          'localPrefix'  : 'req_entry'+i+'_',
          'modulePrefix' : protectionInterface.name }],
        'ports': {
          'clk'     : 'clk',
          'reset_n' : 'reset_n',
          'en'      : 'req_entry_en'+i,
          'd'       : 'req_entry_in',
          'q'       : 'req_entry_'+i } })=\

    assign \=bundleFunctions.packetizeBundle('req_entry_'+i+"_", p.reqInterface, ['valid', 'ready'], u.bundle)=\ =req_entry_\=i=\;

    assign arb_req_entry_pri\=i=\ = qos_disable ? \=wPriority=\'d0 : req_entry_\=i=\_priority;
\js }


\jsbegin
/////////////////////////////////////////////////////////////////////////////
//end entries
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//QOS arbitration
//This library module uses a shift register to keep age ordering accross every transaction
//It will select the highest priority request on the grant interface
//The dealloc interface is used to pop any entry.
//Any valid request particiaptes in the arbitration
//the index for the push uses one hot encoding and is converting to decimal internally
/////////////////////////////////////////////////////////////////////////////
\jsend

\jsbegin
var ArbiterParams ={
     assertOn : p.assertOn,
     usePipe : 1,
     pipeOption : 0,
     useOnehotIndex: 0,
     nPorts: p.depth,
     wPorts: log2ceil(p.depth),
     nEntries : p.depth,
     wPrio : wPriority,
     nPrio : nPriority
 }

 var ArbiterPort={};
 ArbiterPort["clk"]="clk";
 ArbiterPort["reset_n"]="reset_n";
 ArbiterPort["push_en"]="alloc_en";
 ArbiterPort["push_index"]="req_entry_alloc_ptr";
 ArbiterPort["pop_en"]="dealloc_en"    
 ArbiterPort["pop_index"]="arb_index" ;
 for (var i = 0; i < p.depth; i++) {
     ArbiterPort["req"+i+"_prio"]="arb_req_entry_pri"+i;
     }
 ArbiterPort["req_vec"]="req_valid";
 ArbiterPort["grant"]="arb_grant";
 ArbiterPort["grant_ack"]="req_out_ready";
 ArbiterPort["grant_vec"]="arb_vec";
 ArbiterPort["grant_index"]="arb_index";
 ArbiterPort["valid_vec"]="valid_com";
 ArbiterPort["empty"]="empty_com";
 ArbiterPort["full"]="full_com";
        
\jsend


    \=u.instance({
        instanceName : "Arbiter",
        moduleName:"com_arb_qos_age",
        params:ArbiterParams,
        ports: ArbiterPort
    })=\


\jsbegin

/////////////////////////////////////////////////////////////////////////////
//end QOS arbitration
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//output generation
// this uses the grant vector as the sel for an ao mux
// for the request to be valid, grant must be asserted or the bypass path activated
/////////////////////////////////////////////////////////////////////////////
var reqOutMuxPorts				= { "sel": "arb_vec", "out": "req_entry_out_mux" };

for(var i=0; i < p.depth; i++) {	// Add ports for mux inputs
    reqOutMuxPorts["in"+i]		= "req_entry_"+i;
} 
\jsend

    \=u.instance({
        instanceName: 'u_req_out_mux',
        moduleName: 'ao_mux',
        params: { nInputs: p.depth, wMux: wReqPkt },
        ports: reqOutMuxPorts
    })=\

assign req_entry_out = \=p.bypass? "empty? req_entry_in : req_entry_out_mux":"req_entry_out_mux"=\;


assign  \=bundleFunctions.packetizeBundle('req_out_', p.reqInterface, ['valid', 'ready'], u.bundle)=\ = req_entry_out ;


assign req_out_valid = arb_grant \=p.bypass? "| (empty & req_in_valid)" : ""=\ ;

assign req_valid = starv_mode ? starv_valid : req_entry_valid;
\=u.instance({
    instanceName: 'starvation',
    moduleName: 'starvation',
    params: { depth           : p.depth, 
              wStarvThreshold : p.wStarvThreshold, 
              wStarvCnt       : wStarvCnt, 
              starvCntOffset  : starvCntOffset, 
              clkInterface    : p.clkInterface },
    ports: {req_entry_valid           : "req_entry_valid",
            starv_mode          : "starv_mode",
            starv_valid         : "starv_valid",
            starv_threshold     : "starv_threshold",
            dealloc_en          : "dealloc_en",
            grant_index_one_hot : "arb_vec",
            starv_overflow_event: "starv_overflow_event",
            qos_disable         : "qos_disable",
            starv_en : "starv_en"

            },
    interfaces : [{modulePrefix: '',          localPrefix: '',interface: p.clkInterface,    exclude: [] }]
})=\


endmodule
