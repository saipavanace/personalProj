\jsbegin
//=============================================================================
// Copyright(C) 2018 Arteris, Inc.
// All rights reserved
//=============================================================================
// GRB Control Status Registers
// Author: Boon Chuan
// Filename: grb_csr.tachl
//=============================================================================
\jsend

\jsbegin

var u = obj.lib;

var utilFunctions = obj.userLib;

var log2ceil = function(n) { return Math.ceil(Math.log(n)/Math.LN2); };

var clkInterface               = obj.lib.getParam('clkInterface');
var clkInterfaceName           = obj.lib.getParam('clkInterfaceName');
var apbInterface               = obj.lib.getParam('apbInterface');
var apbInterfaceName           = obj.lib.getParam('apbInterfaceName');
var regProtectionInterface     = obj.lib.getParam('regProtectionInterface');
var regProtectionInterfaceName = obj.lib.getParam('regProtectionInterfaceName');
var regProtectionStyle         = obj.lib.getParam('regProtectionStyle');

var CSR              = obj.lib.getParam('csr');

//
// generate csrHwPorts
//
var grbCSR           = new utilFunctions.CreateCSRObj(CSR);
var AWIDTH           = grbCSR.addressWidth;

var nDCEs = 0;
var nSFs = 0;

var regs             = grbCSR.spaceBlock[0].registers;
var csrHwPorts       = grbCSR.getHWPorts();
var regFldsIn        = grbCSR.getRegFldsIn();
var regFldsOut       = grbCSR.getRegFldsOut();

var rfSwWdata = {};
regs.forEach( function (r) {
    r.fields.forEach( function (f) {
    var rf        = r.name+"_"+f.name+"_"+"sw_wdata";
    if ( rf.includes("Rsv") ) {
    } else {
        rfSwWdata[rf] = f.bitWidth;
    }
    if (r.name == 'GRBUNRRUCR' && f.name == 'nDCEs' ) {
        nDCEs = f.reset;
    }
    for (var i=0; i < 128; i++) {
        if (r.name == 'GRBUCSSFIDR'+i) {
            nSFs = i+1;
        }
    }

    });
});
var rfSwWr = regs.map( r => r.name+"_sw_wr");

Object.keys(rfSwWdata).forEach(rf => { csrHwPorts[rf] = rf; });

rfSwWr.forEach(r => { csrHwPorts[r] = r; });

\jsend

\jsbegin
//=============================================================================
// Ports
//=============================================================================

obj.lib.port('input',  'clk',     1);
obj.lib.port('input',  'reset_n', 1);

// APB interface

obj.lib.interface(apbInterfaceName, 'slave', apbInterface);

\jsend

module \=obj.lib.getModuleName()=\ (\=obj.lib.getPorts('\n')=\);

    \js Object.keys(rfSwWdata).forEach(rf => {
wire [\=rfSwWdata[rf]-1=\:0] \=rf=\;
    \js });
    \js rfSwWr.forEach(r => {
wire \=r=\;
    \js });

    \js for (var rf in regFldsIn) {
wire [\=regFldsIn[rf]-1=\:0] \=rf=\;
    \js }

    \js for (var rf in regFldsOut) {
wire [\=regFldsOut[rf]-1=\:0] \=rf=\;
    \js }

wire dff_enable;

\jsbegin
//=============================================================================
// Logic
//=============================================================================
\jsend

assign dff_enable = 1'b1;

\js for (var i=0; i < nSFs; i++) {
assign GRBUCSSFIDR\=i=\_nSets_in = \=regFldsIn['GRBUCSSFIDR'+i+'_nSets_in']=\'b0;
assign GRBUCSSFIDR\=i=\_nWays_in = \=regFldsIn['GRBUCSSFIDR'+i+'_nWays_in']=\'b0;
assign GRBUCSSFIDR\=i=\_filterType_in = \=regFldsIn['GRBUCSSFIDR'+i+'_filterType_in']=\'b0;
\js }

assign GRBUNRRIR_NRRI_in = \=regFldsIn['GRBUNRRIR_NRRI_in']=\'b0;

assign GRBUNRRIR_NRRUsed_in = \=regFldsIn['GRBUNRRIR_NRRUsed_in']=\'b0;

assign GRBUNRRUCR_nAIUs_in = \=regFldsIn['GRBUNRRUCR_nAIUs_in']=\'b0;

assign GRBUNRRUCR_nDCEs_in = \=regFldsIn['GRBUNRRUCR_nDCEs_in']=\'b0;

assign GRBUNRRUCR_nDMIs_in = \=regFldsIn['GRBUNRRUCR_nDMIs_in']=\'b0;

assign GRBUNRRUCR_nDIIs_in = \=regFldsIn['GRBUNRRUCR_nDIIs_in']=\'b0;

assign GRBUNRRUCR_nDVEs_in = \=regFldsIn['GRBUNRRUCR_nDVEs_in']=\'b0;

assign GRBUENGIDR_EngVerId_in = \=regFldsIn['GRBUENGIDR_EngVerId_in']=\'b0;

assign GRBUNSIDR_RelVer_in = \=regFldsIn['GRBUNSIDR_RelVer_in']=\'b0;

assign GRBUNSIDR_CachelineOffset_in = \=regFldsIn['GRBUNSIDR_CachelineOffset_in']=\'b0;

assign GRBUNSIDR_nSnoopFilters_in = \=regFldsIn['GRBUNSIDR_nSnoopFilters_in']=\'b0;

\jsbegin
//=============================================================================
// Symphony Stuff
//=============================================================================
\jsend

// Instantiate CSR registers:

\jsbegin
var reg_interfaces = [];

reg_interfaces.push({
        modulePrefix: '',
        localPrefix: '',
        interface: clkInterface
});

reg_interfaces.push({
        modulePrefix: apbInterfaceName,
        localPrefix:apbInterfaceName,
        interface: apbInterface
});

if(regProtectionStyle != null) {
  if(regProtectionStyle.protection != "none") {
    reg_interfaces.push({
        modulePrefix: regProtectionInterfaceName,
        localPrefix: regProtectionInterfaceName,
        interface: regProtectionInterface
    });
  }
}

\jsend

\=obj.lib.instance({
        instanceName: 'u_apb_csr',
        moduleName: 'apb_csr',
        params: {
          clkInterface          : {"name" : '',                         "signals" : clkInterface},
          cfgInterface          : {"name" : apbInterfaceName,           "signals" : apbInterface},
          protectionInterface   : {"name" : regProtectionInterfaceName, "signals" : regProtectionInterface},
          protectionStyle       : regProtectionStyle,
          flopAPB               : "yes",
          csr                   : CSR
        },
        ports: csrHwPorts,
        interfaces: reg_interfaces
})=\

endmodule
