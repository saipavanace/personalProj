\jsbegin
//=============================================================================
// Copyright(C) 2022 Arteris, Inc.
// All rights reserved
//=============================================================================
// DCE Stage Type 3 : N entry FIFO
// Filename: dce_stage_type3.tachl
//
// NOTE: only type 3 can support BYPASS (this is a TODO item)
//=============================================================================

var u = obj.lib;

var log2ceil = function (n) { return Math.ceil(Math.log2(n)); }
var powerOf2 = function (n) { return (Math.log2(n) % 1 === 0); }

var assertOn = u.getParam('assertOn');

var DEPTH = u.getParam('DEPTH');
var WIDTH = u.getParam('WIDTH');
var AF    = u.getParam('AF');

var AW = log2ceil(DEPTH);
var PW = AW + 1;

//=============================================================================
// Ports
//=============================================================================

u.port('input',  'clk_i', 1);
u.port('input',  'reset_ni', 1);
u.port('output', 'wr_af_o', 1);
u.port('output', 'wr_ready_o', 1);
u.port('input',  'wr_valid_i', 1);
u.port('input',  'wr_wdata_i', WIDTH);
u.port('input',  'rd_ready_i', 1);
u.port('output', 'rd_valid_o', 1);
u.port('output', 'rd_rdata_o', WIDTH);

\jsend

module \=u.getModuleName()=\ (\=u.getPorts('\n')=\);

localparam DEPTH    = \=DEPTH=\;
localparam WIDTH    = \=WIDTH=\;
localparam AF       = \=AF=\;
localparam AW       = \=AW=\;
localparam PW       = \=PW=\;

//=============================================================================
// Wires
//=============================================================================

wire dff_enable = 1'b1; 

wire             w_wr_full;
wire [AW:0]      w_wr_count;
wire             w_rd_empty;
reg  [WIDTH-1:0] w_rd_rdata;

wire [AW-1:0] w_wr_waddr;
wire [AW-1:0] w_rd_raddr;
wire          w_wr_we;

wire t_wr_push;
wire t_rd_pop;

wire [AW:0]   n_wr_wptr,  n_rd_rptr;
wire [AW-1:0] t_wr_waddr, t_rd_raddr;
wire [AW:0]   q_wr_wptr,  q_rd_rptr;
wire          q_wr_full,  n_wr_full;

//=============================================================================
// Logic
//=============================================================================

\js for (var i = 0; i < DEPTH; i++) {
wire [\=WIDTH-1=\:0] mem\=i=\, mem_in\=i=\;
\js }

\js for (var i = 0; i < DEPTH; i++) {
\=u.dffre(WIDTH, 'mem'+i, 'mem_in'+i, "{"+WIDTH+"{1'b0}}", 'dff_enable', 'clk_i', 'reset_ni')=\
\js }

\js for (var i = 0; i < DEPTH; i++) {
assign mem_in\=i=\ = (w_wr_we & (w_wr_waddr == \=AW=\'d\=i=\)) ? wr_wdata_i : mem\=i=\;
\js }

always @(*) begin
    case (w_rd_raddr)
    \js for(var i=0; i < DEPTH; i++)  {
    \=AW=\'d\=i=\ : w_rd_rdata = mem\=i=\;
    \js }
    default w_rd_rdata = {WIDTH{1'b0}};
    endcase
end

//=============================================================================

assign wr_ready_o = ~w_wr_full;
assign rd_valid_o = ~w_rd_empty;
assign rd_rdata_o = w_rd_rdata;

assign wr_af_o = ({\=32-(AW+1)=\'b0, w_wr_count} > AF);

assign t_wr_push = wr_valid_i & wr_ready_o;
assign t_rd_pop  = rd_ready_i & rd_valid_o;

//=============================================================================

assign w_wr_we = t_wr_push;

assign w_wr_waddr = (DEPTH == 1) ? {AW{1'b0}} : t_wr_waddr;

assign w_wr_full  = q_wr_full;

assign w_wr_count = q_wr_wptr - q_rd_rptr;

assign w_rd_raddr = (DEPTH == 1) ? {AW{1'b0}} : t_rd_raddr;

assign w_rd_empty = (q_wr_wptr == q_rd_rptr);

//=============================================================================
// q_wr_wptr
// q_rd_rptr
//=============================================================================

\=u.dffre(PW, 'q_wr_wptr', 'n_wr_wptr', "{"+PW+"{1'b0}}", 'dff_enable', 'clk_i', 'reset_ni')=\
\=u.dffre(PW, 'q_rd_rptr', 'n_rd_rptr', "{"+PW+"{1'b0}}", 'dff_enable', 'clk_i', 'reset_ni')=\

assign n_wr_wptr = t_wr_push ? (q_wr_wptr + 1'b1) : q_wr_wptr;
assign n_rd_rptr = t_rd_pop  ? (q_rd_rptr + 1'b1) : q_rd_rptr;

//=============================================================================
// q_wr_full
//=============================================================================

\=u.dffre(1, 'q_wr_full', 'n_wr_full', "1'b0", 'dff_enable', 'clk_i', 'reset_ni')=\

assign n_wr_full = q_wr_full ? (w_wr_count >= \=AW+1=\'d\=DEPTH=\) & ~t_rd_pop : t_wr_push & (w_wr_count == \=AW+1=\'d\=DEPTH-1=\) & ~t_rd_pop;

//=============================================================================
// t_wr_waddr
// t_rd_raddr
//=============================================================================

\jsbegin
/* istanbul ignore else env ncore_3p4, ncore_3p6, ncore_3p7 */
if (powerOf2(DEPTH)) {
\jsend

assign t_wr_waddr = q_wr_wptr[AW-1:0];
assign t_rd_raddr = q_rd_rptr[AW-1:0];

\js } else {

wire [AW-1:0] q_wr_waddr, q_rd_raddr, wr_waddr_in, rd_raddr_in;

\=u.dffre(AW, 'q_wr_waddr', 'wr_waddr_in', "{"+AW+"{1'b0}}", 'dff_enable', 'clk_i', 'reset_ni')=\
\=u.dffre(AW, 'q_rd_raddr', 'rd_raddr_in', "{"+AW+"{1'b0}}", 'dff_enable', 'clk_i', 'reset_ni')=\

assign wr_waddr_in = ~t_wr_push ? q_wr_waddr : (q_wr_waddr == (DEPTH-1)) ? {AW{1'b0}} : q_wr_waddr + 1'b1;
assign rd_raddr_in = ~t_rd_pop  ? q_rd_raddr : (q_rd_raddr == (DEPTH-1)) ? {AW{1'b0}} : q_rd_raddr + 1'b1;

assign t_wr_waddr = q_wr_waddr;
assign t_rd_raddr = q_rd_raddr;

\js }

///////////////////////////////////////////////////////////////////////////

\jsbegin
/* istanbul ignore else env ncore_3p7 */
	if (assertOn) { \jsend

`ifdef OVL_ASSERT_ON

// pragma synthesis_off
// synopsys translate_off
// coverage off

assert_never #(0) assert_parameters(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	((DEPTH == 0))
);

assert_never #(0) assert_overflow(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	(t_wr_push & w_wr_full)
);

assert_never #(0) assert_wcount(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	((w_wr_count > DEPTH) | ((w_wr_count >= DEPTH) & ~w_wr_full))
);

assert_never_unknown #(0, AW+4) assert_wcontrol(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.qualifier	(reset_ni),
	.test_expr	({AW+4{reset_ni}} &
			 {t_wr_push, w_wr_full, w_wr_count, w_wr_we})
);

assert_never #(0) assert_underflow(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	(t_rd_pop & w_rd_empty)
);

assert_never_unknown #(0, 2) assert_rcontrol(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.qualifier	(reset_ni),
	.test_expr	({2{reset_ni}} & {t_rd_pop, w_rd_empty})
);


assert_never #(0) assert_skid(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	((~wr_ready_o & ~wr_af_o))
);

// coverage on
// pragma synthesis_on
// synthesis_on

`endif

\js }

endmodule
