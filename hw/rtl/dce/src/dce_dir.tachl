\jsbegin
var u = obj.lib;
var m = obj.userLib;

var ioaiu_pos = function(n) { return (n < 1) ? 1 : n; };
var ioaiu_log = function(n) { return (n > 1) ? m.log2ceil(n) : 1; };

var assertOn = u.getParam('assertOn');

var useSramInputFlop = u.getParam('useSramInputFlop');

var SFI = u.getParam('SFI'); //Snoop Filter Info

var ARST = u.getParam('ARST');
var DARST = u.getParam('DARST');
var EARST = u.getParam('EARST');
var SETS = u.getParam('SETS');
var SW = ioaiu_log(SETS);

var nChiplets        = u.getParam('nChiplets');
var wChipletId       = u.getParam('wChipletId');
var wLinkId          = u.getParam('wLinkId');
var wFUnitId         = u.getParam('wFUnitId');
var wFPortId         = u.getParam('wFPortId');
var wGlobalFUnitId   = u.getParam('wGlobalFUnitId');
var nCachingAgents   = u.getParam('nCachingAgents');

var UIDW = u.getParam('UIDW'); //BOON: This is wFUnitId
var AW = u.getParam('AW');
var WN = u.getParam('WN');
var TCW = u.getParam('TCW');
var TCN = u.getParam('TCN');
var IW = u.getParam('IW');
var FN = u.getParam('FN'); //i.e. SFI.length
var FW = ioaiu_log(FN);
var MSW = u.getParam('MSW');
var MNW = u.getParam('MNW');
var CLO = u.getParam('CLO');

var CBASE = u.getParam('CBASE');
var YBASE = u.getParam('YBASE');
var WAYS = u.getParam('WAYS');
var FCN = u.getParam('FCN');
var VB = u.getParam('VB');
var MGN = u.getParam('MGN');
var PROT = u.getParam('PROT');

var VBE = (VB > 0) ? 1 : 0;
var useVictimBufferRecallTimingFix = VBE ? /* istanbul ignore else env ncore_3p7 */ useSramInputFlop : 0;
var VBN = ioaiu_pos(VB);
var VBW = ioaiu_log(VBN);
var FCW = ioaiu_log(FCN);
var KW = ioaiu_pos(AW-SW-CLO);		//tag width
var DW = ((FCN>1) ? FCW : 0) +	//optional owner number
		1 +			//owner valid
		FCN;			//sharer bit vector
var EW = m.lib_utils.getEccWidth(SW+KW+DW);
var EW = (PROT > 1) ? EW : 1;
var NW = KW+DW+((PROT>0) ? EW : 0);
var TMNW = KW+DW;
var FCT = 3+SW+KW+WAYS+((1+KW+SW+FCN+FCW)*VB)+1;	//nnm: review p2 flops

var PriSubDiagAddrBits = u.getParam('PriSubDiagAddrBits');
var SecSubRows         = u.getParam('SecSubRows');

var usePLRU = u.getParam('usePLRU');
var nWays = WAYS;
var nSets = SFI.nSets;
var wSets = m.log2ceil(nSets);

var t_p0_wdata_padding0 = TMNW-(KW+DW) > 0 ? /* istanbul ignore next env ncore_3p6, ncore_3p7 */ (TMNW-(KW+DW))+"'d0 ," : "";

u.port('input','my_fid_i',FW);
u.port('input','CachingAgents',TCN*UIDW);

if (nChiplets > 1) {
u.port('input', 'ca_global_f_unit_id', nCachingAgents * wGlobalFUnitId);
u.port('input', 'ca_global_f_unit_id_valid', nCachingAgents);
}

u.port('input','clk_i',1);
u.port('input','reset_ni',1);
u.port('input','cfg_bb_i',1);
u.port('input','cfg_rc_i',1);
u.port('input','cfg_vb_i',1);
u.port('input','cfg_wb_i',1);
u.port('input','cfg_skid_i',3);
u.port('input','cfg_null_i',1);
u.port('input','cfg_save_i',2);
u.port('input','in_valid_i',1);
u.port('input','in_addr_i',AW);
u.port('input','wr_valid_i',1);
u.port('input','wr_addr_i',AW);
u.port('input','wr_ways_i',WN);
u.port('input','wr_oval_i',1);
u.port('input','wr_owner_i',TCW);
u.port('input','wr_sbv_i',TCN);
u.port('input','wr_change_i',TCN);
u.port('input','lu_valid_i',1);
u.port('input','lu_addr_i',AW);
u.port('input','lu_iid_i',IW);
u.port('input','lu_upd_i',1);
u.port('input','lu_wakeup_i',1);
u.port('output','lu_home_o',1);
u.port('output','p1_fid_o',FW);	//nnm: remove
u.port('output','p1_home_o',1);
u.port('input','p1_busy_i',WN);
u.port('input','p1_alloc_i',1);
u.port('output','p1_rc_hit_o',1);
u.port('input','p1_rc_hit_i',1);
u.port('input','p2_cancel_i',1);
u.port('input','p2_iid_i',IW);
u.port('output','p2_vretry_o',1);
u.port('input','p2_vretry_i',1);
u.port('output','p2_retry_o',1);
u.port('output','p2_sbv_o',TCN);
u.port('output','p2_oval_o',1);
u.port('output','p2_owner_o',TCW);
u.port('output','p2_ways_o',WN);
u.port('output','p2_alloc_o',1);
u.port('output','p2_wb_o',1);
u.port('output','p2_vhit_o',1);
u.port('output','p2_stall_o',1);
u.port('input','p2_stall_i',1);
u.port('output','p2_error_o',1);
u.port('output','p2_uerrs_o',WN);
u.port('output','p2_cerrs_o',WN);
u.port('output','p2_uindex_o',AW);
u.port('output','p2_cindex_o',AW);
u.port('output','p2_up_hit_o',1);
u.port('output','p2_rc_hit_o',1);
u.port('input','p2_rc_hit_i',1);
u.port('input','rc_ready_i',1);
u.port('output','rc_valid_o',1);
u.port('output','rc_addr_o',AW);
u.port('output','rc_sbv_o',TCN);
u.port('output','rc_oval_o',1);
u.port('output','rc_owner_o',TCW);
u.port('output','ymask_o',WN);
        for (let w=0; w < SFI.nMemory; w++) {
u.port('output', 'fm'+w+'_ce_o', 1);
u.port('output', 'fm'+w+'_we_o', 1);
u.port('output', 'fm'+w+'_addr_o', m.log2ceil(SFI.nSets));
u.port('output', 'fm'+w+'_biten_o', SFI.wMemory);
u.port('output', 'fm'+w+'_wdata_o', SFI.wMemory);
u.port('input',  'fm'+w+'_rdata_i', SFI.wMemory);
        }

    if (usePLRU) {
u.port('input',  'plru_mem_init',       1);
u.port('input',  'plru_mem_init_addr',  wSets);
u.port('output', 'plru_mem_read_en',    1);     // p0
u.port('output', 'plru_mem_read_addr',  wSets); // p0
u.port('input',  'plru_mem_read_data',  nWays); // p1
u.port('output', 'plru_mem_write_en',   1);     // p3
u.port('output', 'plru_mem_write_addr', wSets); // p3
u.port('output', 'plru_mem_write_data', nWays); // p3
    }

\jsend

module \=u.getModuleName()=\
        (\=u.getPorts('\n\t')=\
);

parameter DRST = 1'b0;

localparam MNW = \=MNW=\;
localparam MSW = \=MSW=\;
localparam PROT = \=PROT=\;
localparam CBASE = \=CBASE=\;
localparam YBASE = \=YBASE=\;
localparam UIDW = \=UIDW=\;

parameter FID = 0;

localparam FN = \=FN=\;
localparam WN = \=WN=\;
localparam AW = \=AW=\;
localparam IW = \=IW=\;
localparam WAYS = \=WAYS=\;
localparam SETS = \=SETS=\;
localparam MGN = \=MGN=\;
localparam CLO = \=CLO=\;
localparam TCN = \=TCN=\;
localparam TCW = \=TCW=\;
localparam FCN = \=FCN=\;

parameter UpdInv = 8'h0;

localparam VB = \=VB=\;

localparam VBE = \=VBE=\;
localparam VBN = \=VBN=\;
localparam VBW = \=VBW=\;
localparam FCW = \=FCW=\;
localparam FW = \=FW=\;
localparam SW = \=SW=\;
localparam KW = \=KW=\;
localparam DW = \=DW=\;
localparam EW = \=EW=\;
localparam NW = \=NW=\;
localparam FCT = \=FCT=\;
localparam TMNW = \=TMNW=\;

wire dff_enable = 1'b1;

\jsbegin
/* istanbul ignore else env ncore_3p7 */
if (useSramInputFlop) {
\jsend

wire                    w_p0plus_ready;
wire                    n_p0plus_valid;
wire                    n_p0plus_home;
wire [KW-1:0]           n_p0plus_ltag;
wire                    n_p0plus_ready;
wire                    w_p0plus_valid;
wire                    w_p0plus_home;
wire                    w_p0plus_upd;
wire                    w_p0plus_wakeup;
wire [KW-1:0]           w_p0plus_ltag;
wire [SW-1:0]           w_p0plus_rindex;
wire [WAYS-1:0]         w_p0plus_res;

wire                    n_p1_upd;
wire                    n_p1_wakeup;
wire [SW-1:0]           n_p1_rindex;
wire [WAYS-1:0]         n_p1_res;

wire [WAYS-1:0]         t_p0plus_wes;
wire [WAYS-1:0]         t_p0plus_res;
wire [WAYS-1:0]         t_p0plus_wes_select;
wire [SW-1:0]           t_p0plus_windex_ram;
wire [SW-1:0]           t_p0plus_rindex;
wire [NW-1:0]           t_p0plus_wentry_ram;
wire [KW-1:0]		t_p0plus_wtag;
wire [DW-1:0] 		t_p0plus_wstate;
wire [EW-1:0]		t_p0plus_wprot;

\js }

wire [FCN-1:0]		t_p0_abv, t_p2_abv;
wire [WAYS-1:0]		t_p0_wes,	t_p0_res, t_p0_wes_select;
wire [SW-1:0]    	t_p0_windex,	t_p0_rindex, t_p0_windex_init, t_p0_windex_noninit, t_p0_windex_ram;
wire [SW-1:0]    	wr_addr_index;
wire [SW-1:0]    	lu_addr_index;
wire [KW-1:0]		t_p0_wtag, t_p0_wtag_init, t_p0_wtag_noninit, t_p0_wtag_vb_save, t_p0_wtag_p2_upd, t_p0_wtag_wr_dir;
wire [KW-1:0]		wr_addr_tag;
wire [DW-1:0] 		t_p0_wstate, t_p0_wstate_init, t_p0_wstate_noninit, t_p0_wstate_vb_save, t_p0_wstate_p2_upd, t_p0_wstate_wr_dir;
wire			t_p0_woval;
wire [EW-1:0]		t_p0_wprot, t_p0_wprot_init, t_p0_wprot_noninit, t_p0_wprot_vb_save, t_p0_wprot_p2_upd, t_p0_wprot_wr_dir;
wire [NW-1:0]		t_p0_wentry,	w_p1_rentry[WAYS-1:0], t_p0_wentry_ram;

wire 			w_p1_ready,	n_p1_ready;
wire 			n_p1_valid,	w_p1_valid;
wire [WAYS-1:0]				w_p1_res;
wire [SW-1:0]				w_p1_rindex;
wire [KW-1:0]		n_p1_ltag;
wire [KW-1:0]		lu_addr_tag;
wire [KW-1:0]				w_p1_ltag;
wire			n_p1_home,	w_p1_home;
wire					w_p1_wakeup;
wire					w_p1_upd;
wire [WAYS-1:0]				t_p1_busy;

wire [WAYS-1:0]		w_p2_ready,	n_p2_ready;
wire [WAYS-1:0]		n_p2_valid,	w_p2_valid, w_p2_valid_dup;
wire [WAYS-1:0]				t_p2_uerrs, t_p2_cerrs;
wire [WAYS-1:0]				t_p2_vals, 	t_p2_invals;
wire [WAYS-1:0]				t_p2_hits, 	t_p2_ebv,
						   	w_p2_evbv; 
wire					t_p2_retry;
wire					t_p2_cancel, t_p2_cancel_no_stall;
wire					t_p2_error;
wire					t_p2_valid;
wire [WAYS-1:0]				t_p2_ways;
wire							w_vb_ready;
wire							n_vb_valid;
wire [WAYS*KW-1:0]					n_vb_rtags;
wire [WAYS*FCN-1:0]			t_p2_sbvs,	n_vb_sbvs;
wire [WAYS-1:0]				t_p2_ovals,	n_vb_ovals;
wire [WAYS*FCW-1:0]			t_p2_owners,	n_vb_owners;
wire [KW-1:0]						n_vb_rtag,  t_vb_stag;
wire [FCN-1:0]		t_vb_sbv,	t_p2_sbv,	n_vb_sbv,   t_vb_ssbv;
wire 			t_vb_oval,	t_p2_oval,	n_vb_oval,  t_vb_soval;
wire [FCW-1:0]		t_vb_owner,	t_p2_owner,	n_vb_owner, t_vb_sowner;
wire			t_vb_hit,	t_p2_hit, t_p2_hits_ror;
wire					t_p2_alloc, t_p2_alloc_fast;
wire					t_p2_uown;
wire			w_vb_shit;
wire			t_vb_save, q_t_vb_save, q_p2_vb_save_retry, w_p1_vb_save_retry, p2_vretry_o_org;
wire		w_rc_ready,	n_rc_ready;
wire		n_rc_valid,	w_rc_valid;
wire [KW-1:0]	n_rc_tag,	w_rc_tag;
wire [SW-1:0]	n_rc_index,	w_rc_index;
wire [AW-1:0]			w_rc_addr;
wire [FCN-1:0]	n_rc_sbv,	w_rc_sbv;
wire		n_rc_oval,	w_rc_oval;
wire [FCW-1:0]	n_rc_owner,	w_rc_owner;
wire				t_rc_hit;
wire            p1_ready_valid;
wire [SW-1:0]   q_p2_rindex, q_p2_rindex_dup_a;
wire [KW-1:0]   q_p2_ltag,   q_p2_ltag_dup_a;
wire            q_p2_home;
wire            q_p2_wakeup;
wire            q_p2_upd;
wire            q_p2_alloc;
wire [WAYS-1:0] q_p2_busy,   p2_busy_in;
wire [WAYS-1:0] q_p2_stale,  p2_stale_in;
wire            q_p2_retry;
wire [KW-1:0]   w_p2_rtag[WAYS-1:0];
wire [FCN-1:0]  w_p2_sbv[WAYS-1:0];
wire [FCW-1:0]  w_p2_owner[WAYS-1:0];
wire [WAYS-1:0] w_p2_oval;

\js if (useVictimBufferRecallTimingFix) {

wire		w_rc_af;
wire		q_n_rc_valid;
wire [KW-1:0]	q_n_rc_tag;
wire [SW-1:0]	q_n_rc_index;
wire [FCN-1:0]	q_n_rc_sbv;
wire		q_n_rc_oval;
wire [FCW-1:0]	q_n_rc_owner;

\js }

wire [\=TCN-1=\:0] wr_sbv	= wr_sbv_i;



\js if (nChiplets > 1) {

        \js if (IW >= wChipletId+wLinkId+wFUnitId+wFPortId) {

wire [\=wGlobalFUnitId-1=\:0] lu_iid_global_f_unit_id = {lu_iid_i[\=wChipletId+wLinkId+wFUnitId+wFPortId-1=\:\=wLinkId+wFUnitId+wFPortId=\], lu_iid_i[\=wFUnitId+wFPortId-1=\:\=wFPortId=\]};
wire [\=wGlobalFUnitId-1=\:0] p2_iid_global_f_unit_id = {p2_iid_i[\=wChipletId+wLinkId+wFUnitId+wFPortId-1=\:\=wLinkId+wFUnitId+wFPortId=\], p2_iid_i[\=wFUnitId+wFPortId-1=\:\=wFPortId=\]};

    \js for (var i=CBASE; i<CBASE+FCN; i++) {
assign t_p0_abv[\=i-CBASE=\] = (lu_iid_global_f_unit_id == ca_global_f_unit_id[\=i*wGlobalFUnitId=\ +: \=wGlobalFUnitId=\]) & ca_global_f_unit_id_valid[\=i=\];
assign t_p2_abv[\=i-CBASE=\] = (p2_iid_global_f_unit_id == ca_global_f_unit_id[\=i*wGlobalFUnitId=\ +: \=wGlobalFUnitId=\]) & ca_global_f_unit_id_valid[\=i=\];
    \js }

        \js } else {

    \js for (var i=CBASE; i<CBASE+FCN; i++) {
assign t_p0_abv[\=i-CBASE=\] = (lu_iid_i[\=wFUnitId+wFPortId-1=\:\=wFPortId=\] == ca_global_f_unit_id[\=i*wGlobalFUnitId=\ +: \=wFUnitId=\]) & ca_global_f_unit_id_valid[\=i=\];
assign t_p2_abv[\=i-CBASE=\] = (p2_iid_i[\=wFUnitId+wFPortId-1=\:\=wFPortId=\] == ca_global_f_unit_id[\=i*wGlobalFUnitId=\ +: \=wFUnitId=\]) & ca_global_f_unit_id_valid[\=i=\];
    \js }

        \js }

\js } else {

    \js for (var i=CBASE; i<CBASE+FCN; i++) {
assign t_p0_abv[\=i-CBASE=\] = (lu_iid_i[IW-1 -: UIDW] == CachingAgents[\=i=\*UIDW +: UIDW]);
assign t_p2_abv[\=i-CBASE=\] = (p2_iid_i[IW-1 -: UIDW] == CachingAgents[\=i=\*UIDW +: UIDW]);
    \js }

\js }

assign t_p2_uown = (| ({FCN{t_p2_oval}} & t_p2_abv & ({{FCN{1'b0}}, 1'b1} << t_p2_owner)));

assign t_p0_wes_select = {WAYS{in_valid_i | wr_valid_i | (t_p2_valid & q_p2_upd)}};

assign t_p0_wes = in_valid_i ? {WAYS{(in_addr_i < \=AW=\'d\=SETS=\)}} :
		  (wr_valid_i & 
\js if (TCN == 1) {
		      wr_change_i               ) ? wr_ways_i[YBASE +: WAYS]  :
\js } else {
		   (| wr_change_i[CBASE +: FCN])) ? wr_ways_i[YBASE +: WAYS]  :
\js }
		  (t_p2_valid & q_p2_upd & ~t_p2_error &
					   ~p2_stall_i) ? t_p2_hits :
							  {WAYS{1'b0}};

assign t_p0_woval = wr_oval_i & ({\=32-TCW=\'b0, wr_owner_i} >= CBASE) &
				({\=32-TCW=\'b0, wr_owner_i} < (CBASE+FCN));

assign t_p0_wstate = in_valid_i              ? t_p0_wstate_init :
                     (t_vb_save & w_vb_shit) ? t_p0_wstate_vb_save :
                     (t_p2_valid & q_p2_upd) ? t_p0_wstate_p2_upd :
                                               t_p0_wstate_wr_dir;

assign t_p0_wstate_init = {DW{1'b0}};

assign t_p0_wstate_noninit = (t_vb_save & w_vb_shit) ? t_p0_wstate_vb_save :
                             (t_p2_valid & q_p2_upd) ? t_p0_wstate_p2_upd  :
                                                       t_p0_wstate_wr_dir;

\js if (PROT > 1) {
assign t_p0_wprot_noninit  = (t_vb_save & w_vb_shit) ? t_p0_wprot_vb_save :
                             (t_p2_valid & q_p2_upd) ? t_p0_wprot_p2_upd  :
                                                       t_p0_wprot_wr_dir;
\js } else if (PROT == 1) {
assign t_p0_wprot_noninit  = (t_vb_save & w_vb_shit) ? t_p0_wprot_vb_save :
                             (t_p2_valid & q_p2_upd) ? t_p0_wprot_p2_upd  :
                                                       t_p0_wprot_wr_dir;
\js } else {
assign t_p0_wprot_noninit = 1'b0;
\js }


assign t_p0_wstate_vb_save = {
\js if (FCN > 1) {
                                                t_vb_sowner, 
\js }
						t_vb_soval, t_vb_ssbv};
assign t_p0_wstate_p2_upd = {
\js if (FCN > 1) {
				   (t_p2_owner & {FCW{~t_p2_uown}}),
\js }
				   (t_p2_oval & ~t_p2_uown), 
				   (t_p2_sbv & ~t_p2_abv)};

wire [TCW-1:0] wr_owner_i_minus_CBASE = wr_owner_i - \=TCW=\'d\=CBASE=\;

assign t_p0_wstate_wr_dir = {
\js if (FCN > 1) {
				   ({FCW{t_p0_woval}} & wr_owner_i_minus_CBASE[FCW-1:0]),
\js }
\js if (TCN == 1) {
				   t_p0_woval, wr_sbv_i};
\js } else {
				   t_p0_woval, wr_sbv_i[CBASE +: FCN]};
\js }


assign p2_up_hit_o = t_p2_valid & q_p2_upd & ~t_p2_error & ~p2_stall_i & (t_p2_hits_ror | t_vb_hit);

\js if (PROT > 1) {

wire [SW+TMNW-1:0] t_p0_wdata, t_p0_wdata_init, t_p0_wdata_noninit, t_p0_wdata_vb_save, t_p0_wdata_p2_upd, t_p0_wdata_wr_dir;

assign t_p0_wdata         = {\=t_p0_wdata_padding0=\ t_p0_windex,         t_p0_wtag,         t_p0_wstate};

assign t_p0_wdata_init    = {\=t_p0_wdata_padding0=\ t_p0_windex_init,    t_p0_wtag_init,    t_p0_wstate_init};
assign t_p0_wdata_noninit = {\=t_p0_wdata_padding0=\ t_p0_windex_noninit, t_p0_wtag_noninit, t_p0_wstate_noninit};
assign t_p0_wdata_vb_save = {\=t_p0_wdata_padding0=\ t_p0_windex_noninit, t_p0_wtag_vb_save, t_p0_wstate_vb_save};
assign t_p0_wdata_p2_upd  = {\=t_p0_wdata_padding0=\ t_p0_windex_noninit, t_p0_wtag_p2_upd,  t_p0_wstate_p2_upd};
assign t_p0_wdata_wr_dir  = {\=t_p0_wdata_padding0=\ t_p0_windex_noninit, t_p0_wtag_wr_dir,  t_p0_wstate_wr_dir};

    \=u.instance({
	moduleName: 'ecc_enc',
	instanceName: 'ecc_enc',
	params: {
		data_width:	SW+TMNW
	},
	ports: {
		data:		't_p0_wdata',
		ecc:		't_p0_wprot'
	}
    })=\

    \=u.instance({
	moduleName: 'ecc_enc',
	instanceName: 'u_ecc_enc_init',
	params: {
		data_width:	SW+TMNW
	},
	ports: {
		data:		't_p0_wdata_init',
		ecc:		't_p0_wprot_init'
	}
    })=\

    \=u.instance({
	moduleName: 'ecc_enc',
	instanceName: 'u_ecc_enc_vb_save',
	params: {
		data_width:	SW+TMNW
	},
	ports: {
		data:		't_p0_wdata_vb_save',
		ecc:		't_p0_wprot_vb_save'
	}
    })=\

    \=u.instance({
	moduleName: 'ecc_enc',
	instanceName: 'u_ecc_enc_p2_upd',
	params: {
		data_width:	SW+TMNW
	},
	ports: {
		data:		't_p0_wdata_p2_upd',
		ecc:		't_p0_wprot_p2_upd'
	}
    })=\

    \=u.instance({
	moduleName: 'ecc_enc',
	instanceName: 'u_ecc_enc_wr_dir',
	params: {
		data_width:	SW+TMNW
	},
	ports: {
		data:		't_p0_wdata_wr_dir',
		ecc:		't_p0_wprot_wr_dir'
	}
    })=\

    \jsbegin
    /* istanbul ignore else env ncore_3p7 */
    if (useSramInputFlop) {
    \jsend
assign p2_stall_o = 1'b0;
    \js } else {
assign p2_stall_o = (| w_p2_valid_dup) & (| t_p2_cerrs);
    \js }

\js } else if (PROT == 1) {

assign t_p0_wprot      = (^ {t_p0_windex,      t_p0_wtag,      t_p0_wstate});
assign t_p0_wprot_init = (^ {t_p0_windex_init, t_p0_wtag_init, t_p0_wstate_init});

assign t_p0_wprot_vb_save  = (^ {t_p0_windex_noninit, t_p0_wtag_vb_save, t_p0_wstate_vb_save});
assign t_p0_wprot_p2_upd   = (^ {t_p0_windex_noninit, t_p0_wtag_p2_upd,  t_p0_wstate_p2_upd});
assign t_p0_wprot_wr_dir   = (^ {t_p0_windex_noninit, t_p0_wtag_wr_dir,  t_p0_wstate_wr_dir});

assign p2_stall_o = 1'b0;

\js } else {

assign t_p0_wprot = 1'b0;
assign t_p0_wprot_init = 1'b0;

assign p2_stall_o = 1'b0;

\js }


\js if (PROT > 0) {

assign t_p0_wentry = {t_p0_wprot, t_p0_wtag, t_p0_wstate};

assign t_p0_wentry_ram = in_valid_i ? {t_p0_wprot_init,    t_p0_wtag_init,    t_p0_wstate_init} :
                                      {t_p0_wprot_noninit, t_p0_wtag_noninit, t_p0_wstate_noninit};

\js } else {

assign t_p0_wentry = {t_p0_wtag, t_p0_wstate};

assign t_p0_wentry_ram = in_valid_i ? {t_p0_wtag,         t_p0_wstate} :
                                      {t_p0_wtag_noninit, t_p0_wstate_noninit};

\js }


assign t_p0_res = (lu_valid_i & (~lu_upd_i | lu_home_o)) ? {WAYS{1'b1}} :
							   {WAYS{1'b0}};
assign t_p0_rindex = lu_addr_index;

assign t_p0_windex[SW-1:0] = in_valid_i ? in_addr_i[SW-1:0] :
                             wr_valid_i ? wr_addr_index[SW-1:0] :
                             q_p2_upd   ? q_p2_rindex_dup_a[SW-1:0] :
                                          {SW{DRST}};

assign t_p0_windex_ram[SW-1:0] = in_valid_i ? in_addr_i[SW-1:0] :
                                 wr_valid_i ? wr_addr_index[SW-1:0] :
                                              q_p2_rindex_dup_a[SW-1:0];

assign t_p0_windex_init[SW-1:0] = in_addr_i[SW-1:0];
assign t_p0_windex_noninit[SW-1:0] = wr_valid_i ? wr_addr_index[SW-1:0] : q_p2_rindex_dup_a[SW-1:0];


    \=obj.lib.instance({
        instanceName: 'u_dir_index_tag',
        moduleName: 'dce_dir_index_tag_ccp',
        params: {
            AW : AW,
            KW : KW,
            SW : SW,
            CLO : CLO,
            PriSubDiagAddrBits : PriSubDiagAddrBits,
            SecSubRows         : SecSubRows
        },
        ports: {
           lu_addr_i     : 'lu_addr_i',
           lu_addr_index : 'lu_addr_index',
           lu_addr_tag   : 'lu_addr_tag',

           wr_addr_i     : 'wr_addr_i',
           wr_addr_index : 'wr_addr_index',
           wr_addr_tag   : 'wr_addr_tag',

           w_rc_tag      : 'w_rc_tag',
           w_rc_index    : 'w_rc_index',
           w_rc_addr     : 'w_rc_addr'
        }
    })=\

\jsbegin
/* istanbul ignore else env ncore_3p7 */
if (useSramInputFlop) {
\jsend

assign n_p0plus_ltag = lu_addr_tag;

\js } else {

assign n_p1_ltag = lu_addr_tag;

\js }

assign t_p0_wtag = in_valid_i            ? t_p0_wtag_init :
                   t_vb_save & w_vb_shit ? t_p0_wtag_vb_save :
                   t_p2_valid & q_p2_upd ? t_p0_wtag_p2_upd :
                                           t_p0_wtag_wr_dir;

assign t_p0_wtag_init    = (PROT>0) ? {KW{1'b0}} : {KW{DRST}};
assign t_p0_wtag_noninit = (t_vb_save & w_vb_shit) ? t_p0_wtag_vb_save :
                           (t_p2_valid & q_p2_upd) ? t_p0_wtag_p2_upd :
                                                     t_p0_wtag_wr_dir;
assign t_p0_wtag_vb_save = t_vb_stag[KW-1:0];
assign t_p0_wtag_p2_upd  = q_p2_ltag_dup_a[KW-1:0];
assign t_p0_wtag_wr_dir  = wr_addr_tag;

\jsbegin
/* istanbul ignore else env ncore_3p7 */
if (useSramInputFlop) {
\jsend

assign n_p0plus_valid = (| t_p0_res);
assign n_p0plus_home = (| t_p0_abv);
assign lu_home_o = n_p0plus_home;

\js } else {

assign n_p1_valid = (| t_p0_res);
assign n_p1_home = (| t_p0_abv);
assign lu_home_o = n_p1_home;

\js }

assign n_p1_ready = (| w_p2_ready) & ~p2_stall_i;

\jsbegin
/* istanbul ignore else env ncore_3p7 */
if (useSramInputFlop) {
\jsend

    \=u.instance({
        moduleName: 'dce_stage_type0',
        instanceName: 'p0plus',
        params: {
            assertOn: assertOn,
            WIDTH : 3+KW+SW+WAYS
        },
        ports: {
            clk_i:      'clk_i',
            reset_ni:   'reset_ni',
            wr_ready_o: 'w_p0plus_ready',
            wr_valid_i: 'n_p0plus_valid',
            wr_wdata_i: '{n_p0plus_home, lu_upd_i, lu_wakeup_i, n_p0plus_ltag, t_p0_rindex, t_p0_res}',
            rd_ready_i: 'n_p0plus_ready',
            rd_valid_o: 'w_p0plus_valid',
            rd_rdata_o: '{w_p0plus_home, w_p0plus_upd, w_p0plus_wakeup, w_p0plus_ltag, w_p0plus_rindex, w_p0plus_res}'
        }
    })=\

assign n_p0plus_ready = w_p1_ready;
assign n_p1_valid     = w_p0plus_valid;

assign n_p1_home      = w_p0plus_home;
assign n_p1_upd       = w_p0plus_upd;
assign n_p1_wakeup    = w_p0plus_wakeup;
assign n_p1_ltag      = w_p0plus_ltag;
assign n_p1_rindex    = w_p0plus_rindex;
assign n_p1_res       = w_p0plus_res;

    \=u.instance({
        moduleName: 'dce_stage_type0',
        instanceName: 'p1',
        params: {
            assertOn: assertOn,
            WIDTH : 3+KW+SW+WAYS
        },
        ports: {
            clk_i:      'clk_i',
            reset_ni:   'reset_ni',
            wr_ready_o: 'w_p1_ready',
            wr_valid_i: 'n_p1_valid',
            wr_wdata_i: '{n_p1_home, n_p1_upd, n_p1_wakeup, n_p1_ltag, n_p1_rindex, n_p1_res}',
            rd_ready_i: 'n_p1_ready',
            rd_valid_o: 'w_p1_valid',
            rd_rdata_o: '{w_p1_home, w_p1_upd, w_p1_wakeup, w_p1_ltag, w_p1_rindex, w_p1_res}'
        }
    })=\

\js } else {

    \=u.instance({
        moduleName: 'dce_stage_type0',
        instanceName: 'p1',
        params: {
            assertOn: assertOn,
            WIDTH : 3+KW+SW+WAYS
        },
        ports: {
            clk_i:      'clk_i',
            reset_ni:   'reset_ni',
            wr_ready_o: 'w_p1_ready',
            wr_valid_i: 'n_p1_valid',
            wr_wdata_i: '{n_p1_home, lu_upd_i, lu_wakeup_i, n_p1_ltag, t_p0_rindex, t_p0_res}',
            rd_ready_i: 'n_p1_ready',
            rd_valid_o: 'w_p1_valid',
            rd_rdata_o: '{w_p1_home, w_p1_upd, w_p1_wakeup, w_p1_ltag, w_p1_rindex, w_p1_res}'
        }
    })=\

\js }

assign p1_ready_valid = n_p1_ready & w_p1_valid;

assign p1_fid_o = w_p1_home ? my_fid_i : {FW{1'b0}};
assign p1_home_o = w_p1_valid & w_p1_home;
assign t_p1_busy = p1_busy_i[YBASE +: WAYS];

\=u.dffre(SW,  'q_p2_rindex_dup_a', 'w_p1_rindex', "{"+SW+"{1'b0}}", 'p1_ready_valid', 'clk_i', 'reset_ni')=\
\=u.dffre(SW,  'q_p2_rindex',       'w_p1_rindex', "{"+SW+"{1'b0}}", 'p1_ready_valid', 'clk_i', 'reset_ni')=\
\=u.dffre(KW,  'q_p2_ltag_dup_a',   'w_p1_ltag',   "{"+KW+"{1'b0}}", 'p1_ready_valid', 'clk_i', 'reset_ni')=\
\=u.dffre(KW,  'q_p2_ltag',         'w_p1_ltag',   "{"+KW+"{1'b0}}", 'p1_ready_valid', 'clk_i', 'reset_ni')=\
\=u.dffre(1,   'q_p2_home',         'w_p1_home',   "1'b0",           'p1_ready_valid', 'clk_i', 'reset_ni')=\
\=u.dffre(1,   'q_p2_upd',          'w_p1_upd',    "1'b0",           'p1_ready_valid', 'clk_i', 'reset_ni')=\
\=u.dffre(1,   'q_p2_wakeup',       'w_p1_wakeup', "1'b0",           'p1_ready_valid', 'clk_i', 'reset_ni')=\
\=u.dffre(1,   'q_p2_alloc',        'p1_alloc_i',  "1'b0",           'p1_ready_valid', 'clk_i', 'reset_ni')=\

\=u.dffre(WAYS,'q_p2_busy',       'p2_busy_in',  "{"+WAYS+"{1'b0}}", 'p1_ready_valid', 'clk_i', 'reset_ni')=\
\=u.dffre(WAYS,'q_p2_stale',      'p2_stale_in', "{"+WAYS+"{1'b0}}", 'p1_ready_valid', 'clk_i', 'reset_ni')=\

wire p2_busy_cond_in = t_p2_valid & ((t_p2_hits_ror | t_vb_hit) | q_p2_home) & (w_p1_rindex == q_p2_rindex) & ~p2_cancel_i; // & ~w_p1_upd

wire p2_stale_in_correction =                p2_busy_cond_in &  (w_p1_ltag == q_p2_ltag) & (~w_p1_wakeup | q_p2_wakeup);
wire p2_busy_in_correction  = (~t_p2_retry & p2_busy_cond_in & ~(w_p1_ltag == q_p2_ltag))
                            | (~t_p2_retry & p2_stale_in_correction);

assign p2_stale_in = t_p1_busy | ({WAYS{p2_stale_in_correction}} & t_p2_ways);
assign p2_busy_in  = t_p1_busy | ({WAYS{p2_busy_in_correction}}  & t_p2_ways);

wire p2_retry_clr = p1_ready_valid;
wire p2_retry_set = p1_rc_hit_i | (p2_rc_hit_i & p2_stall_i);
wire p2_retry_en  = p2_retry_set | p2_retry_clr;

\=u.dffre(1, 'q_p2_retry', 'p2_retry_set', "1'b0", 'p2_retry_en', 'clk_i', 'reset_ni')=\

\jsbegin
/* istanbul ignore else env ncore_3p7 */
if (useSramInputFlop) {
\jsend

\=u.dffre(WAYS, 't_p0plus_wes',        't_p0_wes',        WAYS+"'b0", 'dff_enable', 'clk_i', 'reset_ni')=\
\=u.dffre(WAYS, 't_p0plus_res',        't_p0_res',        WAYS+"'b0", 'dff_enable', 'clk_i', 'reset_ni')=\
\=u.dffre(WAYS, 't_p0plus_wes_select', 't_p0_wes_select', WAYS+"'b0", 'dff_enable', 'clk_i', 'reset_ni')=\
\=u.dffre(SW,   't_p0plus_windex_ram', 't_p0_windex_ram',   SW+"'b0", 'dff_enable', 'clk_i', 'reset_ni')=\
\=u.dffre(SW,   't_p0plus_rindex',     't_p0_rindex',       SW+"'b0", 'dff_enable', 'clk_i', 'reset_ni')=\
\=u.dffre(KW,   't_p0plus_wtag',       't_p0_wtag',         KW+"'b0", 'dff_enable', 'clk_i', 'reset_ni')=\
\=u.dffre(DW,   't_p0plus_wstate',     't_p0_wstate',       DW+"'b0", 'dff_enable', 'clk_i', 'reset_ni')=\

    \js if (PROT > 1) {

wire [SW+TMNW-1:0] t_p0plus_wdata = {\=t_p0_wdata_padding0=\ t_p0plus_windex_ram, t_p0plus_wtag, t_p0plus_wstate};


    \=u.instance({
        moduleName: 'ecc_enc',
        instanceName: 'ecc_enc_p0plus',
        params: {
                data_width:     SW+TMNW
        },
        ports: {
                data:           't_p0plus_wdata',
                ecc:            't_p0plus_wprot'
        }
    })=\

    \jsbegin
   	/* istanbul ignore else env ncore_3p7 */
    } else if (PROT == 1) { \jsend

assign t_p0plus_wprot = (^ {t_p0plus_windex_ram, t_p0plus_wtag, t_p0plus_wstate});

    \jsbegin
   	/* istanbul ignore next env ncore_3p7 */
    } else { \jsend

assign t_p0plus_wprot = 1'b0;

    \jsbegin
    } \jsend

    \jsbegin
	/* istanbul ignore else env ncore_3p7 */
    if (PROT > 0) { \jsend
assign t_p0plus_wentry_ram = {t_p0plus_wprot, t_p0plus_wtag, t_p0plus_wstate};
    \js } else {
assign t_p0plus_wentry_ram = {t_p0plus_wtag, t_p0plus_wstate};
    \js }

    \js for (var w=0; w<WAYS; w=w+1) {
assign fm\=w=\_ce_o = t_p0plus_wes[\=w=\] | t_p0plus_res[\=w=\];
assign fm\=w=\_we_o = t_p0plus_wes_select[\=w=\];
assign fm\=w=\_addr_o = t_p0plus_wes_select[\=w=\] ? t_p0plus_windex_ram : t_p0plus_rindex;
assign fm\=w=\_wdata_o = t_p0plus_wentry_ram;
assign fm\=w=\_biten_o = {\=NW=\{t_p0plus_wes_select[\=w=\]}};

wire fm\=w=\_write_forward = w_p1_valid & w_p1_res[\=w=\] & t_p0plus_wes[\=w=\] & (w_p1_rindex == t_p0plus_windex_ram);

assign w_p1_rentry[\=w=\] = fm\=w=\_rdata_i;
    \js }

\=u.dffre(1,'q_t_vb_save', 't_vb_save', "1'b0", "1'b1", 'clk_i', 'reset_ni')=\

\=u.dffre(1,'q_p2_vb_save_retry', 'w_p1_vb_save_retry', "1'b0", "1'b1", 'clk_i', 'reset_ni')=\

assign w_p1_vb_save_retry = q_t_vb_save & (1'b0
    \js for (var w=0; w<WAYS; w=w+1) {
                              | fm\=w=\_write_forward
    \js }
                            );

\js } else {

    \js for (var w=0; w<WAYS; w=w+1) {
assign fm\=w=\_ce_o = t_p0_wes[\=w=\] | t_p0_res[\=w=\];
assign fm\=w=\_we_o = t_p0_wes_select[\=w=\];
assign fm\=w=\_addr_o = t_p0_wes_select[\=w=\] ? t_p0_windex_ram : t_p0_rindex;
assign fm\=w=\_wdata_o = t_p0_wentry_ram;
assign fm\=w=\_biten_o = {\=NW=\{t_p0_wes_select[\=w=\]}};

assign w_p1_rentry[\=w=\] = fm\=w=\_rdata_i;
    \js }

\js }

\js for (var w=0; w<WAYS; w=w+1) {

    \=obj.lib.instance({
        instanceName: 'u_dir_way'+w,
        moduleName: 'dce_dir_way',
        params: {
            assertOn : assertOn,
            useSramInputFlop : useSramInputFlop,
            SETS : SETS,
            AW : AW,
            CLO : CLO,
            FN : FN,
            FCN : FCN,
            PROT : PROT
        },
        ports: {
            clk_i:        'clk_i',
            reset_ni:     'reset_ni',
            p2_stall_i:   'p2_stall_i',
            w_p1_valid:   'w_p1_valid',
            q_p2_rindex:  'q_p2_rindex',
            q_p2_ltag:    'q_p2_ltag',
            t_vb_hit:     't_vb_hit',
            t_rc_hit:     't_rc_hit',
            w_p1_rindex:  'w_p1_rindex',
            w_p1_rentry:  'w_p1_rentry['+w+']',
            w_p1_res:     'w_p1_res['+w+']',
            w_p2_evbv:    'w_p2_evbv['+w+']',
            q_p2_busy:    'q_p2_busy['+w+']',
            q_p2_stale:   'q_p2_stale['+w+']',
            t_p2_invals:  't_p2_invals['+w+']',
            w_p2_ready:   'w_p2_ready['+w+']',
            n_p2_ready:   'n_p2_ready['+w+']',
            n_p2_valid:   'n_p2_valid['+w+']',
            w_p2_valid:   'w_p2_valid['+w+']',
            w_p2_valid_dup: 'w_p2_valid_dup['+w+']',
            w_p2_rtag:    'w_p2_rtag['+w+']',
            w_p2_sbv:     'w_p2_sbv['+w+']',
            w_p2_owner:   'w_p2_owner['+w+']',
            w_p2_oval:    'w_p2_oval['+w+']',
            t_p2_uerrs:   't_p2_uerrs['+w+']',
            t_p2_cerrs:   't_p2_cerrs['+w+']',
            t_p2_vals:    't_p2_vals['+w+']',
            t_p2_hits:    't_p2_hits['+w+']',
            n_vb_rtags:   'n_vb_rtags['+(w*KW)+' +: '+KW+']',
            t_p2_sbvs:    't_p2_sbvs['+(w*FCN)+' +: '+FCN+']',
            n_vb_sbvs:    'n_vb_sbvs['+(w*FCN)+' +: '+FCN+']',
            t_p2_ovals:   't_p2_ovals['+w+']',
            n_vb_ovals:   'n_vb_ovals['+w+']',
            t_p2_owners:  't_p2_owners['+(w*FCW)+' +: '+FCW+']',
            n_vb_owners:  'n_vb_owners['+(w*FCW)+' +: '+FCW+']'
        }
    })=\

\js }

assign t_p2_cancel_no_stall = t_p2_error | (t_p2_valid & p2_cancel_i);
assign t_p2_cancel          = t_p2_error | (t_p2_valid & p2_cancel_i) | p2_stall_i;
assign t_p2_error = (| (w_p2_valid & t_p2_uerrs));
assign t_p2_valid = (| w_p2_valid);

assign t_p2_alloc = t_p2_valid & q_p2_alloc & ~t_p2_cancel;

assign t_p2_alloc_fast = t_p2_valid & q_p2_alloc;

assign t_p2_hits_ror = (| t_p2_hits);

assign t_p2_hit = t_p2_hits_ror | t_vb_hit;

assign t_p2_ways = t_p2_hits | t_p2_ebv;

    \=u.instance({
	moduleName: 'dce_ror',
	instanceName: 'p2_sbv',
	params: {},
	verilogParams: {
		NUM:		'WAYS',
		DW:		'FCN'
	},
	ports: {
		vec_i:		't_p2_sbvs',
		ror_o:		't_p2_sbv'
	}
    })=\

assign t_p2_oval = (| t_p2_ovals);

    \=u.instance({
	moduleName: 'dce_ror',
	instanceName: 'p2_owner',
	params: {},
	verilogParams: {
		NUM:		'WAYS',
		DW:		'FCW'
	},
	ports: {
		vec_i:		't_p2_owners',
		ror_o:		't_p2_owner'
	}
    })=\


assign p2_retry_o = t_p2_retry;

\jsbegin
/* istanbul ignore else env ncore_3p7 */
if (useSramInputFlop) {
\jsend
assign t_p2_retry = t_p2_valid & ~t_p2_cancel & ~q_p2_upd &
		    (p2_rc_hit_i |
		     p2_vretry_i | q_p2_retry);
\js } else {
assign t_p2_retry = t_p2_valid & ~t_p2_cancel & ~q_p2_upd &
		    (p2_rc_hit_i |
		     p2_vretry_i | q_p2_retry |
		     ((& q_p2_busy) & ((q_p2_home & t_p2_alloc_fast) | t_vb_hit)) | 
		     (q_p2_home & ~w_vb_ready & ~(t_p2_hits_ror | t_vb_hit))
                    );
\js }
assign p2_sbv_o = t_p2_cancel ? {TCN{1'b1}} :
			    (({TCN{1'b0}} | (t_p2_sbv | t_vb_sbv)) << CBASE);
assign p2_oval_o = t_p2_cancel ? 1'b0 : (t_p2_oval | t_vb_oval);
assign p2_owner_o = t_p2_cancel ? {TCW{1'b1}} :
			       ({TCW{1'b0}} | (t_p2_owner | t_vb_owner)) + 
				((t_p2_oval | t_vb_oval) ? \=TCW=\'d\=CBASE=\ : {TCW{1'b0}});
assign p2_ways_o = (({WN{1'b0}} | t_p2_ways) << YBASE);
assign p2_alloc_o = t_p2_alloc & q_p2_home & (~& q_p2_busy);
assign p2_vretry_o_org = ~q_p2_upd & (

\jsbegin
/* istanbul ignore else env ncore_3p7 */
if (useSramInputFlop) {
\jsend
		      (t_p2_valid & q_p2_home & ~w_vb_ready & ~(                t_vb_hit)) |
\js } else {
		      (t_p2_valid & q_p2_home & ~w_vb_ready & ~(t_p2_hits_ror | t_vb_hit)) |
\js }
		      ((t_vb_hit | (q_p2_home & t_p2_alloc_fast)) & (& q_p2_busy)) |
		      (t_p2_valid & q_p2_retry & ~q_p2_home)
                     );

assign p2_vretry_o = p2_vretry_o_org
\jsbegin
/* istanbul ignore else env ncore_3p7 */
if (useSramInputFlop) {
\jsend
                   | q_p2_vb_save_retry
\js }
                   ;
assign p2_wb_o = t_vb_hit | n_vb_valid | cfg_wb_i | t_p2_alloc;
assign p2_vhit_o = t_vb_hit;
assign p2_error_o = t_p2_error;
assign p2_uerrs_o = (({WN{1'b0}} | (w_p2_valid & t_p2_uerrs)) << YBASE); 
assign p2_cerrs_o = (({WN{1'b0}} | (w_p2_valid & t_p2_cerrs)) << YBASE);
assign p2_uindex_o = (| (w_p2_valid & t_p2_uerrs)) ? {{AW-SW{1'b0}}, q_p2_rindex} : {AW{1'b0}};
assign p2_cindex_o = (| (w_p2_valid & t_p2_cerrs)) ? {{AW-SW{1'b0}}, q_p2_rindex} : {AW{1'b0}};
assign ymask_o = (({WN{1'b0}} | {WAYS{1'b1}}) << YBASE); // spyglass disable W486



    \=u.instance({
	moduleName: 'dce_ror',
	instanceName: 'vb_rtag',
	params: {},
	verilogParams: {
		NUM:		'WAYS',
		DW:		'KW'
	},
	ports: {
		vec_i:		'n_vb_rtags',
		ror_o:		'n_vb_rtag'
	}
    })=\

    \=u.instance({
	moduleName: 'dce_ror',
	instanceName: 'vb_sbv',
	params: {},
	verilogParams: {
		NUM:		'WAYS',
		DW:		'FCN'
	},
	ports: {
		vec_i:		'n_vb_sbvs',
		ror_o:		'n_vb_sbv'
	}
    })=\

assign n_vb_oval = (| n_vb_ovals);

    \=u.instance({
	moduleName: 'dce_ror',
	instanceName: 'vb_owner',
	params: {},
	verilogParams: {
		NUM:		'WAYS',
		DW:		'FCW'
	},
	ports: {
		vec_i:		'n_vb_owners',
		ror_o:		'n_vb_owner'
	}
    })=\

\jsbegin

if (VBE) {

    var instance_ports_for_vb = {
            clk_i:        'clk_i',
            reset_ni:     'reset_ni',
            q_p2_upd:     'q_p2_upd',
            p2_stall_i:   'p2_stall_i',
            t_p2_abv:     't_p2_abv',
            t_p2_valid:   't_p2_valid',
            q_p2_ltag:    'q_p2_ltag',
            wr_valid_i:   'wr_valid_i',
            t_p0_windex:  't_p0_windex',
            w_p1_valid:   'w_p1_valid',
            w_p1_rindex:  'w_p1_rindex',
            cfg_save_i:   'cfg_save_i',
            t_p0_woval:   't_p0_woval',
            t_p2_hits:    't_p2_hits',
            t_p2_oval:    't_p2_oval',
            t_p2_uown:    't_p2_uown',
            t_p2_sbv:     't_p2_sbv',
            t_p2_cancel:  't_p2_cancel',
            t_p2_cancel_no_stall:  't_p2_cancel_no_stall',
            p2_rc_hit_i:  'p2_rc_hit_i',
            q_p2_retry:   'q_p2_retry',
            wr_ways_i:    'wr_ways_i',
            t_p2_vals:    't_p2_vals',
            p2_vretry_i:  'p2_vretry_i',
            t_p2_invals:  't_p2_invals',
            wr_sbv:       'wr_sbv',
            p2_retry_o:   'p2_retry_o',

            w_rc_ready:   'w_rc_ready',
            n_vb_valid:   'n_vb_valid',
            n_vb_sbv:     'n_vb_sbv',
            n_vb_oval:    'n_vb_oval',
            n_vb_owner:   'n_vb_owner',
            n_vb_rtag:    'n_vb_rtag',
            q_p2_rindex:  'q_p2_rindex',

            w_vb_shit:    'w_vb_shit',
            t_vb_hit:     't_vb_hit',
            t_vb_sbv:     't_vb_sbv',
            t_vb_oval:    't_vb_oval',
            t_vb_owner:   't_vb_owner',
            t_vb_save:    't_vb_save',
            t_vb_stag:    't_vb_stag',
            t_vb_ssbv:    't_vb_ssbv',
            t_vb_soval:   't_vb_soval',
            t_vb_sowner:  't_vb_sowner',
            w_vb_ready:   'w_vb_ready',
            n_rc_valid:   'n_rc_valid',
            n_rc_tag:     'n_rc_tag',
            n_rc_index:   'n_rc_index',
            n_rc_sbv:     'n_rc_sbv',
            n_rc_oval:    'n_rc_oval',
            n_rc_owner:   'n_rc_owner'
    };

    if (useVictimBufferRecallTimingFix) {

        instance_ports_for_vb['w_rc_af']      = 'w_rc_af';
        instance_ports_for_vb['q_n_rc_valid'] = 'q_n_rc_valid';
        instance_ports_for_vb['q_n_rc_tag']   = 'q_n_rc_tag';
        instance_ports_for_vb['q_n_rc_index'] = 'q_n_rc_index';
        instance_ports_for_vb['q_n_rc_sbv']   = 'q_n_rc_sbv';
        instance_ports_for_vb['q_n_rc_oval']  = 'q_n_rc_oval';
        instance_ports_for_vb['q_n_rc_owner'] = 'q_n_rc_owner';

    }

\jsend

    \=obj.lib.instance({
        instanceName: 'u_vb',
        moduleName: 'dce_vb',
        params: {
            useVictimBufferRecallTimingFix : useVictimBufferRecallTimingFix,
            assertOn : assertOn,
            VBN : VBN,
            YBASE : YBASE,
            CBASE : CBASE,
            WAYS : WAYS,
            WN : WN,
            TCN : TCN,
            FCN : FCN,
            FCW : FCW,
            KW : KW,
            SW : SW
        },
        ports: instance_ports_for_vb
    })=\

\js } else {

assign w_vb_shit = 1'b0;
assign t_vb_hit = 1'b0;
assign t_vb_sbv = {FCN{1'b0}};
assign t_vb_oval = 1'b0;
assign t_vb_owner = {FCW{1'b0}};
assign t_vb_save = 1'b0;
assign t_vb_stag = {KW{1'b0}};
assign t_vb_ssbv = {FCN{1'b0}};
assign t_vb_soval = 1'b0;
assign t_vb_sowner = {FCW{1'b0}};

assign w_vb_ready = w_rc_ready;
assign n_rc_valid = n_vb_valid;
assign n_rc_tag = n_vb_rtag;
assign n_rc_index = q_p2_rindex;
assign n_rc_sbv = n_vb_sbv;
assign n_rc_oval = n_vb_oval;
assign n_rc_owner = n_vb_owner;

\js }

\jsbegin

    var rcFifoParams = {
        width       : KW+SW+FCN+1+FCW,
        depth       : 2,
        bypass_mode : 1,
        use_fastread: 0,
        zerodepth   : 0,
        almostFull  : 1
    };
    var instance_ports_for_rc_fifo = {
        clk                 : 'clk_i',
        reset_n             : 'reset_ni',
        push_data           : '{q_n_rc_tag, q_n_rc_index, q_n_rc_sbv, q_n_rc_oval, q_n_rc_owner}',
        push_valid          : 'q_n_rc_valid',
        push_ready          : 'w_rc_ready',
        almost_full         : 'w_rc_af',
        pop_data            : '{w_rc_tag, w_rc_index, w_rc_sbv, w_rc_oval, w_rc_owner}',
        pop_valid           : 'w_rc_valid',
        pop_ready           : 'n_rc_ready'
    };

\jsend

\js if (useVictimBufferRecallTimingFix) {

    \=obj.lib.instance({
        instanceName: 'rc',
        moduleName: 'fifo',
        params : rcFifoParams,
        ports: instance_ports_for_rc_fifo
    })=\

\js } else {

    \=obj.lib.instance({
        moduleName: 'dce_stage_type0',
        instanceName: 'rc',
        params: {
            assertOn: assertOn,
            WIDTH : KW+SW+FCN+1+FCW
        },
        ports: {
            clk_i:      'clk_i',
            reset_ni:   'reset_ni',
            wr_ready_o: 'w_rc_ready',
            wr_valid_i: 'n_rc_valid',
            wr_wdata_i: '{n_rc_tag, n_rc_index, n_rc_sbv, n_rc_oval, n_rc_owner}',
            rd_ready_i: 'n_rc_ready',
            rd_valid_o: 'w_rc_valid',
            rd_rdata_o: '{w_rc_tag, w_rc_index, w_rc_sbv, w_rc_oval, w_rc_owner}'
        }
    })=\

\js }

assign p1_rc_hit_o = w_p1_valid & w_rc_valid & (w_p1_ltag == w_rc_tag) & (w_p1_rindex == w_rc_index) & ~w_p1_upd;
assign p2_rc_hit_o = t_p2_valid & w_rc_valid & (q_p2_ltag == w_rc_tag) & (q_p2_rindex == w_rc_index) & ~q_p2_upd;
assign  t_rc_hit   =              w_rc_valid & (q_p2_ltag == w_rc_tag) & (q_p2_rindex == w_rc_index);

assign n_rc_ready = rc_ready_i;
assign rc_valid_o = w_rc_valid;
assign rc_addr_o = w_rc_addr;
assign rc_sbv_o = (({TCN{1'b0}} | w_rc_sbv) << CBASE);
assign rc_oval_o = w_rc_oval;
assign rc_owner_o = ({TCW{1'b0}} | w_rc_owner) + 
		    (w_rc_oval ? \=TCW=\'d\=CBASE=\ : {TCW{1'b0}});

\jsbegin

var dir_rp_ports = {
    clk_i:        'clk_i',
    reset_ni:     'reset_ni',
    p2_stall_i:    'p2_stall_i',
    p2_cancel_i:   'p2_cancel_i',
    p2_vretry_i:   'p2_vretry_i',
    p2_rc_hit_i:   'p2_rc_hit_i',
    t_p2_valid:    't_p2_valid',
    t_p2_retry:    't_p2_retry',
    t_p2_cancel:   't_p2_cancel',
    t_p2_alloc:    't_p2_alloc',
    t_p2_vals:     't_p2_vals',
    t_p2_hits:     't_p2_hits',
    q_p2_upd:      'q_p2_upd',
    q_p2_busy:     'q_p2_busy',
    q_p2_home:     'q_p2_home',
    q_p2_retry:    'q_p2_retry',
    t_vb_hit:      't_vb_hit',
    w_vb_ready:    'w_vb_ready',

    n_p1_valid:    'n_p1_valid',
    w_p1_ready:    'w_p1_ready',
    w_p1_valid:    'w_p1_valid',
    n_p1_ready:    'n_p1_ready',
    n_p2_valid:    'n_p2_valid',
    w_p2_ready:    'w_p2_ready',
    w_p2_valid:    'w_p2_valid',
    n_p2_ready:    'n_p2_ready',

    n_vb_valid:    'n_vb_valid',
    t_p2_invals:   't_p2_invals',
    t_p2_ebv:      't_p2_ebv',
    w_p2_evbv:     'w_p2_evbv'
};

// CONC-16170
// PLRU SRAM pipeline is always P0, P1, P2, P3
// When useSramInputFlop=1, DCE DIR pipeline is P0, P0+, P1, P2 therefore PLRU SRAM P0 is DCE DIR P0+.
// When useSramInputFlop=0, DCE DIR pipeline is P0,      P1, P2 therefore PLRU SRAM P0 is DCE DIR P0.

if (useSramInputFlop) {

    dir_rp_ports['t_p0_res_0']          = 't_p0plus_res[0]';
    dir_rp_ports['t_p0_rindex']         = 't_p0plus_rindex';

} else {

    dir_rp_ports['t_p0_res_0']          = 't_p0_res[0]';
    dir_rp_ports['t_p0_rindex']         = 't_p0_rindex';

}
if (usePLRU) {
    dir_rp_ports['plru_mem_init']       = 'plru_mem_init';
    dir_rp_ports['plru_mem_init_addr']  = 'plru_mem_init_addr';
    dir_rp_ports['plru_mem_read_en']    = 'plru_mem_read_en';
    dir_rp_ports['plru_mem_read_addr']  = 'plru_mem_read_addr';
    dir_rp_ports['plru_mem_read_data']  = 'plru_mem_read_data';
    dir_rp_ports['plru_mem_write_en']   = 'plru_mem_write_en';
    dir_rp_ports['plru_mem_write_addr'] = 'plru_mem_write_addr';
    dir_rp_ports['plru_mem_write_data'] = 'plru_mem_write_data';
}

\jsend

    \=obj.lib.instance({
        instanceName: 'u_dir_rp',
        moduleName: 'dce_dir_rp',
        params: {
            assertOn : assertOn,
            usePLRU : usePLRU,
            SETS : SETS,
            WAYS : WAYS
        },
        ports: dir_rp_ports
    })=\


\jsbegin
/* istanbul ignore else env ncore_3p7 */
if (assertOn) { \jsend

`ifdef OVL_ASSERT_ON

//coverage off
//pragma synthesis_off

reg a_error_test;
initial begin
	if ($test$plusargs("error_test")) begin
		a_error_test = 1'b1;
	end else begin
		a_error_test = 1'b0;
	end
end

assert_never #(0) assert_param(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	((FCN<1) | ((CBASE+FCN)>TCN) | (CBASE<FID) | (IW>12) |
			 (MGN==0) | (MGN>WAYS) |
			 ((KW+SW+CLO) != AW) | (UIDW>=IW) |
			 (NW>MNW) | (WAYS>WN) | (SW>MSW) |
			 ((YBASE+WAYS)>WN) | (FID > (1'b1<<FW)) | (~| ymask_o))
);

assert_never #(0) assert_pipe(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	(((~w_p1_ready | ~n_p1_ready | (~& w_p2_ready)) & 
			  ~p2_stall_i) | 
			 ((| t_p0_wes) & (| t_p0_res)) |
			 ((| t_p0_wes_select) & (| t_p0_res)) |
			 ((| t_p0_wes) & (t_p0_wentry_ram != t_p0_wentry)) |
			 ((| t_p0_wes) & (t_p0_windex_ram != t_p0_windex)) |
			 (t_p2_valid & q_p2_upd & wr_valid_i) |
			 (t_p2_valid & ~p2_retry_o & q_p2_home & t_p2_alloc &
				       ~q_p2_upd & (& q_p2_busy)) |
//			 (t_p2_valid & ~p2_retry_o & q_p2_home & ~t_p2_cancel & 
//				       ~p2_cancel_i & p2_vretry_i) |
			 (t_p2_valid & ~t_p2_alloc & (| p2_ways_o) & ~(t_p2_hits_ror | t_vb_hit))|
			 (t_p2_valid & t_p2_alloc & q_p2_home & ~q_p2_upd &
					(~| p2_ways_o) & ~p2_retry_o) |
			 (t_p2_valid & p2_cancel_i & p2_retry_o) |
			 (q_p2_upd & p2_retry_o) |
			 (t_p2_cancel & p2_retry_o) |
			 (t_p2_cancel & t_p2_valid & p2_oval_o) |
			 (t_p2_cancel & t_p2_valid & (~& p2_owner_o)) |
			 (t_p2_cancel & t_p2_valid & (~& p2_sbv_o)))
);

assert_never #(0) assert_error(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	(t_p2_error & ~a_error_test)
);

assert_never #(0) assert_write(
	.clk		(clk_i),
	.reset_n	(reset_ni),
\js if (TCN == 1) {
	.test_expr	((wr_valid_i &    wr_change_i                & 1'b0 &
\js } else {
	.test_expr	((wr_valid_i & (| wr_change_i[CBASE +: FCN]) & 1'b0 &
\js }
				     (~| wr_ways_i[YBASE +: WAYS])) |
			 ((| t_p0_wes) & ~in_valid_i & ~wr_valid_i & ~q_p2_upd)|
			 (wr_valid_i & t_p2_valid & q_p2_upd))
);

assert_never #(0) assert_evict(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	(n_vb_valid & (p2_retry_o | ~w_vb_ready | 
				       (& q_p2_busy) |
				       (| t_p2_hits) |
				       (| t_p2_invals) |
				       (~| t_p2_vals) |
				       ((~| n_vb_sbv) & ~n_vb_oval) |
				       (~n_vb_oval & (| n_vb_owner))))
			 
);

assert_zero_one_hot #(0, WAYS) assert_hits(
	.clk		(clk_i),
	.reset_n	(reset_ni & ~q_p2_upd & ~p2_stall_i & ~p2_vretry_i),
	.test_expr	(t_p2_hits)
);
assert_zero_one_hot #(0, FCN) assert_home(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	(t_p0_abv)
);
assert_zero_one_hot #(0, FCN) assert_update(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	(t_p2_abv)
);
assert_zero_one_hot #(0, WN) assert_ways(
	.clk		(clk_i),
	.reset_n	(reset_ni & ~q_p2_upd & ~p2_stall_i & ~p2_vretry_i) ,
	.test_expr	(p2_ways_o)
);
assert_zero_one_hot #(0, WAYS) assert_writes(
	.clk		(clk_i),
	.reset_n	(reset_ni & ~in_valid_i & ~q_p2_upd),
	.test_expr	(t_p0_wes)
);

assert_never_unknown #(0, 15+TCN+TCW) assert_unknown_control(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.qualifier	(reset_ni),
	.test_expr	({15+TCN+TCW{reset_ni}} & 
			 {wr_valid_i, lu_valid_i, rc_valid_o, rc_ready_i,
			  p2_sbv_o, p2_oval_o, p2_owner_o, cfg_vb_i, cfg_wb_i,
			  cfg_skid_i, cfg_null_i, cfg_save_i, t_p2_error,
			  p2_stall_i})
);

assert_never_unknown #(0, AW+WN+1+TCW+TCN+TCN) assert_unknown_write(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.qualifier	(rc_valid_o),
	.test_expr	({AW+WN+1+TCW+TCN+TCN{reset_ni}} & 
			 {wr_addr_i, wr_ways_i, wr_oval_i, wr_owner_i, 
			  wr_sbv_i, wr_change_i})
);

assert_never_unknown #(0, AW+TCN+1+TCW) assert_unknown_recall(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.qualifier	(rc_valid_o),
	.test_expr	({AW+TCN+1+TCW{reset_ni}} & 
			 {rc_addr_o, rc_sbv_o, rc_oval_o, rc_owner_o})
);

wire [SW-1:0] lu_addr_index_org;
wire [SW-1:0] wr_addr_index_org;
wire [KW-1:0] lu_addr_tag_org;
wire [KW-1:0] wr_addr_tag_org;
wire [AW-1:0] w_rc_addr_org;

    \=obj.lib.instance({
        instanceName: 'u_dir_index_tag_org',
        moduleName: 'dce_dir_index_tag',
        params: {
            AW : AW,
            KW : KW,
            SW : SW,
            CLO : CLO,
            PriSubDiagAddrBits : PriSubDiagAddrBits,
            SecSubRows         : SecSubRows
        },
        ports: {
           lu_addr_i     : 'lu_addr_i',
           lu_addr_index : 'lu_addr_index_org',
           lu_addr_tag   : 'lu_addr_tag_org',

           wr_addr_i     : 'wr_addr_i',
           wr_addr_index : 'wr_addr_index_org',
           wr_addr_tag   : 'wr_addr_tag_org',

           w_rc_tag      : 'w_rc_tag',
           w_rc_index    : 'w_rc_index',
           w_rc_addr     : 'w_rc_addr_org'
        }
    })=\

assert_never #(0) assert_lu_addr_index (
        .clk            (clk_i),
        .reset_n        (reset_ni),
        .test_expr      ((lu_addr_index != lu_addr_index_org))
);
assert_never #(0) assert_lu_addr_tag (
        .clk            (clk_i),
        .reset_n        (reset_ni),
        .test_expr      ((lu_addr_tag != lu_addr_tag_org))
);
assert_never #(0) assert_wr_addr_index (
        .clk            (clk_i),
        .reset_n        (reset_ni),
        .test_expr      ((wr_addr_index != wr_addr_index_org))
);
assert_never #(0) assert_wr_addr_tag (
        .clk            (clk_i),
        .reset_n        (reset_ni),
        .test_expr      ((wr_addr_tag != wr_addr_tag_org))
);
assert_never #(0) assert_w_rc_addr (
        .clk            (clk_i),
        .reset_n        (reset_ni),
        .test_expr      ((w_rc_addr != w_rc_addr_org))
);

                       \jsbegin
                       for (var i = 0; i < WAYS; i++) {
                           for (var j = i+1; j < WAYS; j++) {
                       \jsend
wire w_p2_rtag_way\=i=\_matches_way\=j=\ = (w_p2_rtag[\=i=\] == w_p2_rtag[\=j=\]) & (w_p2_oval[\=i=\] | {|{w_p2_sbv[\=i=\]}}) & (w_p2_oval[\=j=\] | {|{w_p2_sbv[\=j=\]}});
                       \jsbegin
                           }
                       }
                       \jsend

wire duplicate_dir_way_index_tag_detected =
                  (  1'b0
                       \jsbegin
                       for (var i = 0; i < WAYS; i++) {
                           for (var j = i+1; j < WAYS; j++) {
                       \jsend
                     | ((w_p2_rtag[\=i=\] == w_p2_rtag[\=j=\]) & w_p2_valid[\=i=\] & w_p2_valid[\=j=\] & t_p2_vals[\=i=\] & t_p2_vals[\=j=\] & ~q_p2_busy[\=i=\] & ~q_p2_busy[\=j=\] & ~t_p2_cancel)
                       \jsbegin
                           }
                       }
                       \jsend
                  );

assert_never #(0) assert_duplicate_dir_way_index_tag(
        .clk            (clk_i),
        .reset_n        (reset_ni),
        .test_expr      (
                         duplicate_dir_way_index_tag_detected
                        )
);

//pragma synthesis_on
//coverage on

`endif

\js }


endmodule
