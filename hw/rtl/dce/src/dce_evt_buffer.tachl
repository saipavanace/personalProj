// ======================================================================
// Copyright(C) 2017 Arteris, Inc.
// All rights reserved.
// ======================================================================
\jsbegin
//
// This Tachl component implements the Event Buffer block
//
// ======================================================================
const u							= obj.lib;
const libUtils					= obj.userLib;

//---------------------------------------------------------------------
// Default Parameter Declarations
//---------------------------------------------------------------------
u.paramDefault('clkInterface','object', null);
u.paramDefault('reqAckEventInterface','object',null);
u.paramDefault('width', 'int', 1);

// Read all block parameters
const clkInterface				= libUtils.hierGetParam('clkInterface', u.getParam);
const reqAckEventInterface		= libUtils.hierGetParam('reqAckEventInterface', u.getParam);
const width						= libUtils.hierGetParam('width', u.getParam);
const wCounter					= 1; // Will likely always be set to 1

//---------------------------------------------------------------------
// Interface Declarations
//---------------------------------------------------------------------
u.interface(clkInterface.name, 'slave', clkInterface.signals);
u.interface(reqAckEventInterface.name, 'master', reqAckEventInterface.signals);

//---------------------------------------------------------------------
// Port Declarations
//---------------------------------------------------------------------
u.port('input', 'en', 1);
u.port('output', 'busy', 1); 

\jsend
module \=u.getModuleName()=\ (\=u.getPorts('\n    ')=\);

	localparam IDLE				= 2'd0;
	localparam ASSERT			= 2'd1;
	localparam DEASSERT			= 2'd2;

	\jsbegin
	const local					= {
		nState			: 2,
		pState			: 2,
		sm_en			: 1,
		count			: wCounter,
		count_next		: wCounter,
		count_en		: 1,
		count_clr		: 1,
		count_max		: 1
	}; \jsend

	\=libUtils.bundleFunctions.wiresFromInterface("", local, [], u.bundle)=\


	// Instantiate Flops for event counter
	\=u.instance({
      instanceName: 'u_evt_counter',
      moduleName: 'prot_reg',
      params: {
          width : wCounter
      },
      ports: {
          clk     : clkInterface.name+'clk',
          reset_n : clkInterface.name+'reset_n',
          d       : 'count_next',
          q       : 'count',
          en      : 'count_en'       
      }
	})=\

	// Event counter control logic
	assign count_max						= &count;
	assign count_clr						= |count & (pState == IDLE);
	assign count_en							= pState == IDLE ? |count : ~count_max & en;
	assign count_next						= count_clr ? \=wCounter+"'d0"=\ : count + \=wCounter+"'d1"=\;


	// Instantiate Flops for state-machine
	\=u.instance({
      instanceName: 'u_sm',
      moduleName: 'prot_reg',
      params: {
          width : 2
      },
      ports: {
          clk     : clkInterface.name+'clk',
          reset_n : clkInterface.name+'reset_n',
          d       : 'nState',
          q       : 'pState',
          en      : 'sm_en'       
      }
	})=\

	// State machine control logic
	assign \=reqAckEventInterface.name=\req	= pState == IDLE ? |count | en : pState == ASSERT;
	assign nState							= pState == ASSERT ? DEASSERT : pState == IDLE ? ASSERT : IDLE;
	assign sm_en							= (pState == IDLE)		& (|count | en)						|
											  (pState == ASSERT)	& \=reqAckEventInterface.name=\ack	|
											  (pState == DEASSERT)	& !\=reqAckEventInterface.name=\ack;

	// Busy generation
	assign busy								= |count | en | (pState == ASSERT) | (pState == DEASSERT);

endmodule
