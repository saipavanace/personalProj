\jsbegin
// NAME: Priority Age Buffer Arbiter 

//============================================================================     
// Variables
//============================================================================
   
var u = obj.lib;
var m = obj.userLib;
var utilFunctions = obj.userLib;

var bundleFunctions = m.bundleFunctions;
var log2ceil = function(n) { return Math.ceil(Math.log(n)/Math.LN2); };

var assertOn            = m.ParamDefaultGet(u, 'assertOn',          'int',    0);

var useQos              = m.ParamDefaultGet(u, 'useQos',            'int',    1);

var wStarvThreshold = m.ParamDefaultGet(u, 'wStarvThreshold',   'int',   16);

var starvCntOffset      = 0;  // 1 events
var depth               = u.getParam('depth');
var wDepth              = log2ceil(depth);

var clkInterface        = u.getParam('clkInterface');
var reqInterface        = u.getParam('reqInterface');

var wQos                = reqInterface.qos;
var wReqPkt             = bundleFunctions.getBundleWidth(reqInterface, ['valid', 'ready'], u.bundle);
var wPriority           = reqInterface.priority != undefined ? reqInterface.priority : /* istanbul ignore next env ncore_3p2, ncore_3p4,ncore_3p6, ncore_3p7 */ 0;
var nPriority           = Math.pow(2, wPriority);

var wStarvCnt           = wStarvThreshold + starvCntOffset;

var protectionStyle = m.ParamDefaultGet(u, 'protectionStyle', 'object', {protection: "none", protWidth: 0});

var protectionInterface = m.ParamDefaultGet(u, 'protectionInterface', 'object', {name: "prot_", signals: {}});

//============================================================================
// Ports
//============================================================================

if (useQos) {
u.port('input',  'starv_en',             1);
u.port('input',  'starv_threshold',      wStarvThreshold);
u.port('input',  'qos_disable',          1);
u.port('output', 'starv_overflow_event', 1);
u.port('output', 'starv_mode',           1);
}

u.port('output', 'empty',                               1);

//============================================================================
// Interfaces
//============================================================================
u.interface('',             'slave',        clkInterface,            ['']);

u.interface('req_in_',      'slave',        reqInterface,            ['']);
u.interface('req_out_',     'master',       reqInterface,            ['']);

u.interface(protectionInterface.name, 'master', protectionInterface.signals);

\jsend
module \=u.getModuleName()=\ (\=u.getPorts('\n    ')=\);

\jsbegin
//============================================================================
// Wires
//============================================================================
\jsend
wire                        alloc_en;
wire                        dealloc_en;
wire [\=wReqPkt-1=\:0]      req_entry_in;
wire [\=wReqPkt-1=\:0]      req_entry_out;
wire [\=depth-1=\:0]        req_buf_valid_vec;

\jsbegin
//============================================================================
// Entry Allocation/Deallocation
//============================================================================
\jsend

assign alloc_en = req_in_valid & req_in_ready;

assign dealloc_en = req_out_valid & req_out_ready;

//============================================================================
// SRAM-based FIFO
//============================================================================

assign req_entry_in = \=bundleFunctions.packetizeBundle('req_in_', reqInterface, ['valid', 'ready'], u.bundle)=\;

wire [\=nPriority-1=\:0] req_in_prio_onehot;
wire [\=nPriority-1=\:0] req_out_prio_onehot;

    \js if (useQos) {
assign req_in_prio_onehot = \=nPriority=\'b1 << req_in_priority;
    \js } else {
assign req_in_prio_onehot = \=nPriority=\'b1;
    \js }

\jsbegin
    var req_buf_params = {
        assertOn : false,
        useStarvation : useQos,
        useStarvationChaining : 0,
        useBypass : 1,
        nEntries : depth,
        wData    : wReqPkt,
        nPrio    : nPriority
    };

    var req_buf_ports = {
        clk:        'clk',
        reset_n:    'reset_n',
        push_valid: 'req_in_valid',
        push_ready: 'req_in_ready',
        push_data:  'req_entry_in',
        pop_valid:  'req_out_valid',
        pop_ready:  'req_out_ready',
        pop_data:   'req_entry_out',
        valid_vec:  'req_buf_valid_vec'
    };

        req_buf_ports['push_prio']  = 'req_in_prio_onehot';
        req_buf_ports['pop_prio']   = 'req_out_prio_onehot';

    if (useQos) {
        req_buf_ports['starv_enable']         = 'starv_en & ~qos_disable';
        req_buf_ports['starv_overflow_event'] = 'starv_overflow_event';
        req_buf_ports['starv_mode']           = 'starv_mode';
    }

\jsend

        \=u.instance({
            instanceName: 'u_req_buf',
            moduleName: 'com_prio_buf',
            params: req_buf_params,
            ports: req_buf_ports,
            interfaces: []
        })=\

assign \=bundleFunctions.packetizeBundle('req_out_', reqInterface, ['valid', 'ready'], u.bundle)=\ = req_entry_out;

assign empty = ~req_out_valid;

\jsbegin
//============================================================================
// Starvation
//============================================================================
\jsend

\js if (useQos) {

//
// starv_overflow_event
//

wire [\=wStarvCnt-1=\:0]    starv_count;
wire [\=wStarvCnt-1=\:0]    starv_count_d;
wire                        starv_count_en;

assign starv_overflow_event = (starv_count[\=wStarvCnt-1=\:\=starvCntOffset=\] == starv_threshold) 
                            & (starv_threshold != \=wStarvThreshold=\'b0) 
                            & starv_en & ~qos_disable;

\=u.dffre(wStarvCnt, 'starv_count', 'starv_count_d', wStarvCnt+"'d0", 'starv_count_en', 'clk', 'reset_n')=\

assign starv_count_d = (starv_count[\=wStarvCnt-1=\:\=starvCntOffset=\] == starv_threshold) ? \=wStarvCnt=\'b0 : starv_count + 1'b1;

assign starv_count_en = (~starv_mode & dealloc_en & starv_en & ~qos_disable) 
                      | starv_overflow_event;

\js }

endmodule
