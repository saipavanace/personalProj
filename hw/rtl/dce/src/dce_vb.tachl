\jsbegin
//=============================================================================
// Copyright(C) 2022 Arteris, Inc.
// All rights reserved
//=============================================================================
// DCE Victim Buffer
// Filename: dce_vb.tachl
//
// Operations for the victim buffer entries:
//  victim buffer entry write on n_vb_valid when tag filter evicts an entry due to tag miss allocate.
//  victim buffer entry write on swapok     when CMDreq hits victim buffer.
//  victim buffer entry clear on moveok1    when UpdInv hits victim buffer (and there is no owner/sharers excluding initiator).
//  victim buffer entry clear on moveok2    when CMDreq hits victim buffer.
//  victim buffer entry clear on save1      when UpdInv hits tag filter and the tag filter entry has no owner/sharers excluding initiator.
//  victim buffer entry clear on save2      when tag filter write has no owner/sharers excluding initiator.
//  victim buffer entry clear on recall     when victim buffer is full
//=============================================================================

var u = obj.lib;

//=============================================================================
// Parameters
//=============================================================================

u.paramDefault('useVictimBufferRecallTimingFix', 'int', 0);

var useVictimBufferRecallTimingFix = u.getParam('useVictimBufferRecallTimingFix'); 

var assertOn = u.getParam('assertOn');
var VBN      = u.getParam('VBN');
var YBASE    = u.getParam('YBASE');
var CBASE    = u.getParam('CBASE');
var WAYS     = u.getParam('WAYS');
var WN       = u.getParam('WN');
var TCN      = u.getParam('TCN');

var FCN      = u.getParam('FCN');
var FCW      = u.getParam('FCW');
var KW       = u.getParam('KW');
var SW       = u.getParam('SW');

//=============================================================================
// Ports
//=============================================================================

u.port('input',  'clk_i', 1);
u.port('input',  'reset_ni', 1);
u.port('input',  'cfg_save_i', 2);     //FOR t_vb_save

//
// Tag Filter P0 Signals for Write
//
u.port('input',  'wr_valid_i', 1);     //FOR t_vb_shits, t_vb_save
u.port('input',  'wr_ways_i', WN);     //FOR t_vb_save
u.port('input',  'wr_sbv', TCN);       //FOR t_vb_save
u.port('input',  't_p0_woval', 1);     //FOR t_vb_save
u.port('input',  't_p0_windex', SW);   //FOR t_vb_shits

//
// Tag Filter P1 Signals
//
u.port('input',  'w_p1_valid', 1);     //FOR t_vb_shits
u.port('input',  'w_p1_rindex', SW);   //FOR t_vb_shits

//
// Tag Filter P2 Signals
//
u.port('input',  't_p2_valid', 1);     //FOR t_vb_hits, t_vb_shits, assertion
u.port('input',  't_p2_abv', FCN);     //FOR t_vb_uowns, t_vb_ulasts, dce_vb_entry, t_vb_save
u.port('input',  't_p2_hits', WAYS);   //FOR t_vb_save, assertion
u.port('input',  't_p2_oval', 1);      //FOR t_vb_save
u.port('input',  't_p2_uown', 1);      //FOR t_vb_save
u.port('input',  't_p2_sbv', FCN);     //FOR t_vb_save
u.port('input',  't_p2_cancel', 1);    //FOR t_vb_ok
u.port('input',  't_p2_cancel_no_stall', 1);    //FOR t_vb_ok
u.port('input',  't_p2_vals', WAYS);   //FOR t_vb_swapok
u.port('input',  't_p2_invals', WAYS); //FOR t_vb_swapok, t_vb_moveok

u.port('input',  'q_p2_upd', 1);       //FOR t_vb_ups, t_vb_shits, t_vb_save, t_vb_swapok, t_vb_moveok, assertion
u.port('input',  'q_p2_retry', 1);     //FOR t_vb_ok
u.port('input',  'q_p2_ltag', KW);     //FOR t_vb_hits

u.port('input',  'p2_stall_i', 1);     //FOR t_vb_ups
u.port('input',  'p2_rc_hit_i', 1);    //FOR t_vb_ok
u.port('input',  'p2_vretry_i', 1);    //FOR t_vb_swapok, t_vb_moveok
u.port('input',  'p2_retry_o', 1);     //FOR assertion

//
// Victim Buffer Entry Write Interface
//
u.port('input',  'n_vb_valid', 1);     //FOR t_vb_wes (the write signal to dce_vb_entry), assertion
u.port('input',  'n_vb_sbv', FCN);     //FOR dce_vb_entry, assertion
u.port('input',  'n_vb_oval', 1);      //FOR dce_vb_entry, assertion
u.port('input',  'n_vb_owner', FCW);   //FOR dce_vb_entry, assertion
u.port('input',  'n_vb_rtag', KW);     //FOR dce_vb_entry, assertion
u.port('input',  'q_p2_rindex', SW);   //FOR dce_vb_entry, t_vb_hits, t_vb_shits, assertion

//
// Victim Buffer Output Interface
//
u.port('output', 'w_vb_ready', 1);
u.port('output', 'w_vb_shit', 1);
u.port('output', 't_vb_hit', 1);
u.port('output', 't_vb_sbv', FCN);
u.port('output', 't_vb_oval', 1);
u.port('output', 't_vb_owner', FCW);
u.port('output', 't_vb_save', 1);
u.port('output', 't_vb_stag', KW);
u.port('output', 't_vb_ssbv', FCN);
u.port('output', 't_vb_soval', 1);
u.port('output', 't_vb_sowner', FCW);

//
// Victim Buffer Recall Interface
//
u.port('input',  'w_rc_ready', 1);
u.port('output', 'n_rc_valid', 1);
u.port('output', 'n_rc_tag', KW);
u.port('output', 'n_rc_index', SW);
u.port('output', 'n_rc_sbv', FCN);
u.port('output', 'n_rc_oval', 1);
u.port('output', 'n_rc_owner', FCW);

if (useVictimBufferRecallTimingFix) {

u.port('input',  'w_rc_af', 1);
u.port('output', 'q_n_rc_valid', 1);
u.port('output', 'q_n_rc_tag', KW);
u.port('output', 'q_n_rc_index', SW);
u.port('output', 'q_n_rc_sbv', FCN);
u.port('output', 'q_n_rc_oval', 1);
u.port('output', 'q_n_rc_owner', FCW);

}

\jsend

module \=u.getModuleName()=\ (\=u.getPorts('\n')=\);

localparam VBN   = \=VBN=\;
localparam FCN   = \=FCN=\;
localparam FCW   = \=FCW=\;
localparam KW    = \=KW=\;
localparam SW    = \=SW=\;
localparam YBASE = \=YBASE=\;
localparam CBASE = \=CBASE=\;
localparam WAYS  = \=WAYS=\;
localparam WN    = \=WN=\;
localparam TCN   = \=TCN=\;



//=============================================================================

wire dff_enable = 1'b1;

wire t_vb_save1;
wire t_vb_save2;
wire t_vb_moveok1;
wire t_vb_moveok2;

//=============================================================================

wire			t_vb_arb;
wire [VBN-1:0]		w_vb_wbv, t_vb_wes, t_vb_ups, t_vb_uowns, t_vb_ulasts,
			w_vb_rbv, t_vb_clrs;
wire [VBN-1:0]		t_vb_vals, t_vb_rvals, t_vb_invals;
wire [VBN*KW-1:0]			t_vb_stags;
wire [VBN*FCN-1:0]	t_vb_sbvs,	t_vb_ssbvs;
wire [VBN-1:0]		t_vb_ovals,	t_vb_sovals;
wire [VBN*FCW-1:0]	t_vb_owners,	t_vb_sowners;
wire [VBN-1:0]		t_vb_hits, 	t_vb_shits, w_vb_shits, t_vb_shits1, t_vb_shits2;
wire			t_vb_moveok, t_vb_swapok, t_vb_ok, t_vb_ok_no_stall;
wire [VBN-1:0]  q_vb_valid;
wire [KW-1:0]	q_vb_tag[VBN-1:0];
wire [SW-1:0]	q_vb_index[VBN-1:0];
wire [FCN-1:0]	q_vb_sbv[VBN-1:0];
wire [VBN-1:0]	q_vb_oval;
wire [FCW-1:0]	q_vb_owner[VBN-1:0];

\js if (useVictimBufferRecallTimingFix) {

wire [KW-1:0]	qq_vb_tag[VBN-1:0];
wire [SW-1:0]	qq_vb_index[VBN-1:0];
wire [FCN-1:0]	qq_vb_sbv[VBN-1:0];
wire [VBN-1:0]	qq_vb_oval;
wire [FCW-1:0]	qq_vb_owner[VBN-1:0];

wire [VBN-1:0]	q_w_vb_rbv;

\js }

wire            t_vb_clrs_undo;
wire            q_vb_clrs_undo;

assign t_vb_invals = ~t_vb_vals;

    \=obj.lib.instance({
        instanceName: 'u_find_first_one_t_vb_invals',
        moduleName: 'find_first_one',
        params: { width : VBN },
        verilogParams: { WIDTH : VBN },
        ports: {
            invec  : 't_vb_invals',
            outvec : 'w_vb_wbv'
        }
    })=\


assign w_vb_ready = (~& t_vb_vals);

assign t_vb_wes = ({VBN{n_vb_valid}} & w_vb_wbv) |
		  ({VBN{t_vb_swapok}} & t_vb_hits);

assign t_vb_ups = {VBN{q_p2_upd & ~p2_stall_i}} & t_vb_hits;

\jsbegin
//=============================================================================
// t_vb_ups[w] is UpdInv hits victim buffer
//
// t_vb_uowns[w] is an onehot0 vector indicating initiator is the vb owner
//
// t_vb_ulasts[w] is victim entry update (UpdInv hits victim buffer) for vb_moveok1 when
//   vb sharer vector excluding initiator is all zeros, and
//     no owner valid excluding initiator
//
// (q_vb_sbv[w] & ~t_p2_abv) means vb sharer vector excluding initiator
//
// (q_vb_oval[w] & ~t_vb_uowns[w]) means vb owner valid excluding initiator
//=============================================================================
\jsend

\js for (var w=0; w < VBN; w++) {

assign t_vb_uowns[\=w=\] = (| ({FCN{q_vb_oval[\=w=\]}} & t_p2_abv & ({{FCN{1'b0}}, 1'b1} << q_vb_owner[\=w=\])));

assign t_vb_ulasts[\=w=\] = t_vb_ups[\=w=\] & (~| (q_vb_sbv[\=w=\] & ~t_p2_abv)) & ~(q_vb_oval[\=w=\] & ~t_vb_uowns[\=w=\]); 

\jsbegin
var instance_ports_for_vb_entry = {
            clk_i:        'clk_i',
            reset_ni:     'reset_ni',
            p2_stall_i:   'p2_stall_i',
            t_vb_clrs:    't_vb_clrs['+w+']',
            t_vb_ups:     't_vb_ups['+w+']',
            t_vb_wes:     't_vb_wes['+w+']',
            t_p2_abv:     't_p2_abv',
            n_vb_sbv:     'n_vb_sbv',
            t_vb_uowns:   't_vb_uowns['+w+']',
            n_vb_oval:    'n_vb_oval',
            n_vb_owner:   'n_vb_owner',
            n_vb_rtag:    'n_vb_rtag',
            q_p2_rindex:  'q_p2_rindex',
            q_vb_valid:   'q_vb_valid['+w+']',
            q_vb_sbv:     'q_vb_sbv['+w+']',
            q_vb_oval:    'q_vb_oval['+w+']',
            q_vb_owner:   'q_vb_owner['+w+']',
            q_vb_tag:     'q_vb_tag['+w+']',
            q_vb_index:   'q_vb_index['+w+']'
    };

if (useVictimBufferRecallTimingFix) {
    instance_ports_for_vb_entry['qq_vb_sbv']   = 'qq_vb_sbv['+w+']';
    instance_ports_for_vb_entry['qq_vb_oval']  = 'qq_vb_oval['+w+']';
    instance_ports_for_vb_entry['qq_vb_owner'] = 'qq_vb_owner['+w+']';
    instance_ports_for_vb_entry['qq_vb_tag']   = 'qq_vb_tag['+w+']';
    instance_ports_for_vb_entry['qq_vb_index'] = 'qq_vb_index['+w+']';
}

\jsend

    \=obj.lib.instance({
        instanceName: 'u_vb_entry'+w,
        moduleName: 'dce_vb_entry',
        params: {
            useVictimBufferRecallTimingFix : useVictimBufferRecallTimingFix,
            FCN : FCN,
            FCW : FCW,
            KW : KW,
            SW : SW
        },
        ports: instance_ports_for_vb_entry
    })=\

assign t_vb_vals[\=w=\] = (| q_vb_sbv[\=w=\]) | q_vb_oval[\=w=\];

assign t_vb_hits[\=w=\] = t_p2_valid & t_vb_vals[\=w=\] & (q_p2_ltag == q_vb_tag[\=w=\]) & (q_p2_rindex == q_vb_index[\=w=\]);

assign t_vb_sbvs[\=w=\*FCN +: FCN]   = {FCN{t_vb_hits[\=w=\]}} & q_vb_sbv[\=w=\];
assign t_vb_ovals[\=w=\]             =      t_vb_hits[\=w=\]   & q_vb_oval[\=w=\];
assign t_vb_owners[\=w=\*FCW +: FCW] = {FCW{t_vb_hits[\=w=\]}} & q_vb_owner[\=w=\];

\jsbegin
//-----------------------------------------------------------------------------
// t_vb_shits[w] : vb save hit (must exclude vb hit)
//  two cases:
//  case 1: t_p2_valid update invalidate index match during p2
//  case 2: wr_valid_i index match during p0 (must exclude previous p0 index match)
//-----------------------------------------------------------------------------
\jsend

assign t_vb_shits1[\=w=\] = t_vb_vals[\=w=\] & ~t_vb_hits[\=w=\] & t_p2_valid & q_p2_upd & (q_p2_rindex == q_vb_index[\=w=\]);
		       
assign t_vb_shits2[\=w=\] = t_vb_vals[\=w=\] & ~t_vb_hits[\=w=\] & wr_valid_i & (t_p0_windex == q_vb_index[\=w=\]) &
			                                         ~(w_p1_valid & (w_p1_rindex == q_vb_index[\=w=\])); 

assign t_vb_shits[\=w=\] = t_vb_shits1[\=w=\] | t_vb_shits2[\=w=\];

assign t_vb_stags[\=w=\*KW +: KW]     = { KW{w_vb_shits[\=w=\]}} & q_vb_tag[\=w=\];
assign t_vb_ssbvs[\=w=\*FCN +: FCN]   = {FCN{w_vb_shits[\=w=\]}} & q_vb_sbv[\=w=\];
assign t_vb_sovals[\=w=\]             =      w_vb_shits[\=w=\]   & q_vb_oval[\=w=\];
assign t_vb_sowners[\=w=\*FCW +: FCW] = {FCW{w_vb_shits[\=w=\]}} & q_vb_owner[\=w=\];

\js }



\jsbegin
//=============================================================================
// t_vb_save2 : p0 write             has no owner and no sharer
// t_vb_save1 : p2 update invalidate has no owner and no sharer
//
// ((| t_p2_vals) & (~| t_p2_invals)) means tag filter has valid not busy entry
//
// swapok must not happen when upd is in progress
// swapok must not happen when vb retry is in progress
//=============================================================================
\jsend

    \=u.instance({
        instanceName: 'u_or_tree_t_vb_shits',
        moduleName:   'logic_tree',
        params: {'width' : VBN,
                 'logic' : '|'},
        ports: { 'din'  : 't_vb_shits',
                 'dout' : 'w_vb_shit' }
    })=\

    \=obj.lib.instance({
        instanceName: 'u_find_first_one_t_vb_shits',
        moduleName: 'find_first_one',
        params: { width : VBN },
        verilogParams: { WIDTH : VBN },
        ports: {
            invec  : 't_vb_shits',
            outvec : 'w_vb_shits'
        }
    })=\

assign t_vb_ok          = ~t_p2_cancel          & ~p2_rc_hit_i & ~q_p2_retry;

assign t_vb_ok_no_stall = ~t_p2_cancel_no_stall & ~p2_rc_hit_i & ~q_p2_retry;

assign t_vb_save2 = wr_valid_i & (| wr_ways_i[YBASE +: WAYS]) & ~t_p0_woval & ~cfg_save_i[1] & t_vb_ok_no_stall &
\js if (TCN > 1) {
                                (~| wr_sbv[CBASE +: FCN]);
\js } else {
                                (~| wr_sbv);
\js }

assign t_vb_save1 = q_p2_upd & (| t_p2_hits) & ~(t_p2_oval & ~t_p2_uown) & (~| (t_p2_sbv & ~t_p2_abv)) & ~cfg_save_i[0] & t_vb_ok_no_stall;

assign t_vb_save = t_vb_save2 | t_vb_save1;

assign t_vb_swapok = (| t_p2_vals) & ~q_p2_upd & ~p2_vretry_i & (~| t_p2_invals) & t_vb_ok;

assign t_vb_moveok2 =                ~q_p2_upd & ~p2_vretry_i &  (| t_p2_invals) & t_vb_ok;

assign t_vb_moveok1 =                 q_p2_upd &                 (| t_vb_ulasts) & t_vb_ok;

assign t_vb_moveok = t_vb_moveok2 | t_vb_moveok1;



assign t_vb_hit = (| t_vb_hits);

    \=u.instance({
	moduleName: 'dce_ror',
	instanceName: 'vb_sbv',
	params: {},
	verilogParams: {
		NUM:		'VBN',
		DW:		'FCN'
	},
	ports: {
		vec_i:		't_vb_sbvs',
		ror_o:		't_vb_sbv'
	}
    })=\

assign t_vb_oval = (| t_vb_ovals);

    \=u.instance({
	moduleName: 'dce_ror',
	instanceName: 'vb_owner',
	params: {},
	verilogParams: {
		NUM:		'VBN',
		DW:		'FCW'
	},
	ports: {
		vec_i:		't_vb_owners',
		ror_o:		't_vb_owner'
	}
    })=\

    \=u.instance({
	moduleName: 'dce_ror',
	instanceName: 'vb_ssbv',
	params: {},
	verilogParams: {
		NUM:		'VBN',
		DW:		'FCN'
	},
	ports: {
		vec_i:		't_vb_ssbvs',
		ror_o:		't_vb_ssbv'
	}
    })=\

assign t_vb_soval = (| t_vb_sovals);

    \=u.instance({
	moduleName: 'dce_ror',
	instanceName: 'vb_sowner',
	params: {},
	verilogParams: {
		NUM:		'VBN',
		DW:		'FCW'
	},
	ports: {
		vec_i:		't_vb_sowners',
		ror_o:		't_vb_sowner'
	}
    })=\

    \=u.instance({
	moduleName: 'dce_ror',
	instanceName: 'vb_stag',
	params: {},
	verilogParams: {
		NUM:		'VBN',
		DW:		'KW'
	},
	ports: {
		vec_i:		't_vb_stags',
		ror_o:		't_vb_stag'
	}
    })=\

\jsbegin
//=============================================================================
// Victim Buffer entries that are eligible for Recall
// must not be VB Save Hit entry, and must not be VB Hit entry
//=============================================================================
\jsend

assign t_vb_rvals = t_vb_vals & ~({VBN{t_vb_save}} & w_vb_shits) & ~t_vb_hits;

    \=u.instance({
        moduleName: 'dce_dir_arb',
        instanceName: 'vbr',
        params: { DW: VBN },
        ports: {
                clk:            'clk_i',
                reset_n:        'reset_ni',
                ready_i:        't_vb_arb',
                bv_i:           't_vb_rvals',
                wbv_o:          'w_vb_rbv'
        }
    })=\

assign t_vb_clrs = ({VBN{t_vb_arb}}    & w_vb_rbv)
                 | ({VBN{t_vb_moveok}} & t_vb_hits)
                 | ({VBN{t_vb_save}}   & w_vb_shits);

assign t_vb_arb = n_rc_valid & w_rc_ready
\js if (useVictimBufferRecallTimingFix) {
                & ~w_rc_af
\js }
                ;

assign n_rc_valid = (| t_vb_rvals) & (& t_vb_vals) & ~q_vb_clrs_undo & ~p2_stall_i;

\js // w_vb_rbv (onehot encoded) is the winner of t_vb_rvals

wire [KW+SW+FCN+1+FCW-1:0] q_vb[VBN-1:0];
wire [KW+SW+FCN+1+FCW-1:0] mux_q_vb;

    \js for (var i=0; i < VBN; i++) {
assign q_vb[\=i=\] = {q_vb_tag[\=i=\], q_vb_index[\=i=\], q_vb_sbv[\=i=\], q_vb_oval[\=i=\], q_vb_owner[\=i=\]};
    \js }

assign {n_rc_tag, n_rc_index, n_rc_sbv, n_rc_oval, n_rc_owner} = mux_q_vb;

\js if (useVictimBufferRecallTimingFix) {

wire [KW+SW+FCN+1+FCW-1:0] qq_vb[VBN-1:0];
wire [KW+SW+FCN+1+FCW-1:0] mux_qq_vb;

    \js for (var i=0; i < VBN; i++) {
assign qq_vb[\=i=\] = {qq_vb_tag[\=i=\], qq_vb_index[\=i=\], qq_vb_sbv[\=i=\], qq_vb_oval[\=i=\], qq_vb_owner[\=i=\]};
    \js }

assign {q_n_rc_tag, q_n_rc_index, q_n_rc_sbv, q_n_rc_oval, q_n_rc_owner} = mux_qq_vb;

\js }

\jsbegin

var mux_q_vb_ports = {};
    for (var i=0; i < VBN; i++) {
mux_q_vb_ports['in'+i]       = 'q_vb['+i+']';
    }
mux_q_vb_ports['sel']        = 'w_vb_rbv';
mux_q_vb_ports['out']        = 'mux_q_vb';

if (useVictimBufferRecallTimingFix) {

var mux_qq_vb_ports = {};
    for (var i=0; i < VBN; i++) {
mux_qq_vb_ports['in'+i]       = 'qq_vb['+i+']';
    }
mux_qq_vb_ports['sel']        = 'q_w_vb_rbv';
mux_qq_vb_ports['out']        = 'mux_qq_vb';

}

\jsend

    \=u.instance({
        instanceName: 'u_mux_q_vb',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : VBN,
                        wMux             : KW+SW+FCN+1+FCW
        },
        ports: mux_q_vb_ports
    })=\

\js if (useVictimBufferRecallTimingFix) {

    \=u.instance({
        instanceName: 'u_mux_qq_vb',
        moduleName: 'ao_mux',
        params: {
                        nInputs          : VBN,
                        wMux             : KW+SW+FCN+1+FCW
        },
        ports: mux_qq_vb_ports
    })=\

\js }

assign t_vb_clrs_undo = {|{t_vb_clrs}} & p2_stall_i;

\=u.dffre(1, 'q_vb_clrs_undo', 't_vb_clrs_undo', "1'b0", 'dff_enable', 'clk_i', 'reset_ni')=\

\js if (useVictimBufferRecallTimingFix) {

\=u.dffre(VBN, 'q_w_vb_rbv', 'w_vb_rbv', VBN+"'b0", 'dff_enable', 'clk_i', 'reset_ni')=\

\=u.dffre(1, 'q_n_rc_valid', 'n_rc_valid', "1'b0", 'dff_enable', 'clk_i', 'reset_ni')=\

\js }

//=============================================================================

\jsbegin
/* istanbul ignore else env ncore_3p7 */
if (assertOn) { \jsend

`ifdef OVL_ASSERT_ON

//coverage off
//pragma synthesis_off

function automatic integer ioaiu_sum (input [1023:0] num);
begin: func_ioaiu_sum
        for (ioaiu_sum=(num%2); num>0; ioaiu_sum=ioaiu_sum+(num%2)) begin
                num = (num >> 1);
        end
end
endfunction

wire [VBN-1:0]	g_ehit;
\js for (var w=0; w < VBN; w++) {
assign g_ehit[\=w=\] = n_vb_valid & t_vb_vals[\=w=\] & (n_vb_rtag == q_vb_tag[\=w=\]) & (q_p2_rindex == q_vb_index[\=w=\]);
\js }

assert_never #(0) assert_n_vb_valid(
    .clk       (clk_i),
    .reset_n   (reset_ni),
    .test_expr ((n_vb_valid & n_rc_valid) |            //Cannot push to VB when Recall
                (n_vb_valid & (& t_vb_vals)) |         //Cannot push to VB when VB Full
                (n_vb_valid & (~| t_vb_invals)) |      //Cannot push to VB when VB Invalids are zero
                (n_vb_valid & (| t_vb_hits)) |         //Cannot push to VB when VB Hit
                (n_vb_valid & t_p2_valid & q_p2_upd))  //Cannot push to VB when UPDinv
);

assert_never #(0) assert_vb(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	( 
			 //(~cfg_save_i & (| t_vb_hits) & (| t_p2_invals)) |
			 //(q_vb_count > VBN) |
			 (t_vb_moveok & 
			  t_vb_save & (| (t_vb_hits & t_vb_shits))) &
			 (t_vb_arb & (((~| (w_vb_rbv & t_vb_hits)) &
					t_vb_moveok & (| t_vb_hits)) &
				       (t_vb_save & w_vb_shit))) 
			 //((~| q_vb_count) & (| t_vb_dec)) |
			 //((& q_vb_count) & t_vb_inc) |
			 //(ioaiu_sum(t_vb_vals) != q_vb_count) |
			 //(cfg_rc_i & (ioaiu_sum(t_vb_clrs) > 1)) |
			)
);

assert_never #(0) assert_vb__t_vb_wes__p2_retry_o(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	( 
			 ((| t_vb_wes) & p2_retry_o) //BOON: Cannot write to Victim Buffer when Retry is active
			)
);

assert_never #(0) assert_vb__t_vb_wes__t_vb_clrs(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	( 
			 (| (t_vb_wes & t_vb_clrs)) //BOON: for the same VB entry, Write and Clear must be mutually exclusive
			)
);

assert_never #(0) assert_vb__n_rc_valid__t_vb_hits(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	( 
			 (n_rc_valid & {|{t_vb_hits & w_vb_rbv}}) //BOON: A VB entry under Recall must be excluded from VB hit
			)
);

assert_never #(0) assert_vb__t_vb_hit__t_p2_hits(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	( 
			 (t_vb_hit & (| t_p2_hits) & ~q_p2_upd) //BOON: cannot have VB hit and TagFilter hit together while not Update
			)
);

assert_never #(0) assert_vb__t_vb_clrs(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	( 
			 (ioaiu_sum(t_vb_clrs) > 3) //BOON: CONC-15553 Recall, VB Move and VB Save can occur in same cycle
			)
);

assert_never #(0) assert_vb__g_ehit(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	( 
			 (| g_ehit) //BOON: cannot write an eviction entry to victim buffer that also has the same entry
			)
);

assert_never #(0) assert_vb__t_vb_wes(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	( 
			 (ioaiu_sum(t_vb_wes) > 1) //BOON: t_vb_wes must be onehot0
			)
);

assert_never #(0) assert_vb__t_vb_hits(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	( 
			 (ioaiu_sum(t_vb_hits) > 1) //BOON: t_vb_hits must be onehot0
			)
);

assert_never #(0) assert_vb__t_vb_wes__n_vb_owner(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	( 
			 ((| t_vb_wes) & ~n_vb_oval & (| n_vb_owner)) //BOON: Cannot write to VB with Owner Valid low but Owner Vector non-zero
			)
);

assert_never #(0) assert_vb__t_vb_wes__null_entry(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	( 
			 ((| t_vb_wes) & ~n_vb_oval & (~| n_vb_sbv)) //BOON: Cannot write to VB with null entry (no owner, no sharer)
			)
);

wire duplicate_vb_index_tag_detected =
                  (  1'b0
                       \jsbegin
                       for (var i = 0; i < VBN; i++) {
                           for (var j = i+1; j < VBN; j++) {
                       \jsend
                     | ((q_vb_tag[\=i=\] == q_vb_tag[\=j=\]) & (q_vb_index[\=i=\] == q_vb_index[\=j=\]) & q_vb_valid[\=i=\] & q_vb_valid[\=j=\])
                       \jsbegin
                           }
                       }
                       \jsend
                  );

assert_never #(0) assert_vb__duplicate_vb_index_tag(
	.clk		(clk_i),
	.reset_n	(reset_ni),
	.test_expr	( 
			 duplicate_vb_index_tag_detected
			)
);

//pragma synthesis_on
//coverage on

`endif

\js }

endmodule
