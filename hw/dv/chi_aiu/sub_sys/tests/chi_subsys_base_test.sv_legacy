<%

var pma_en_dmi_blk = 1;
var pma_en_dii_blk = 1;
var pma_en_aiu_blk = 1;
var pma_en_dce_blk = 1;
var pma_en_dve_blk = 1;
var pma_en_at_least_1_blk = 0;
var pma_en_all_blk = 1;
var numChiAiu = 0; // Number of CHI AIUs
var numACEAiu = 0; // Number of ACE AIUs
var numIoAiu = 0; // Number of IO AIUs
var numCAiu = 0; // Number of Coherent AIUs
var numNCAiu = 0; // Number of Non-Coherent AIUs
var numBootIoAiu = 0; // Number of NCAIUs can participate in Boot
var chiaiu0;  // strRtlNamePrefix of chiaiu0
var aceaiu0;  // strRtlNamePrefix of aceaiu0
var ncaiu0;   // strRtlNamePrefix of aceaiu0
var csrAccess_ioaiu;
var csrAccess_chiaiu;
var idxIoAiuWithPC = obj.nAIUs; // To get valid index of NCAIU with ProxyCache. Initialize to nAIUs
var numDmiWithSMC = 0; // Number of DMIs with SystemMemoryCache
var idxDmiWithSMC = 0; // To get valid index of DMI with SystemMemoryCache
var numDmiWithSP = 0; // Number of DMIs with ScratchPad memory
var idxDmiWithSP = 0; // To get valid index of DMIs with ScratchPad memory
var numDmiWithWP = 0; // Number of DMIs with WayPartitioning
var idxDmiWithWP = 0; // To get valid index of DMIs with WayPartitioning
var noBootIoAiu = 1;
const BootIoAiu = [];
var found_csr_access_chiaiu=0;
var found_csr_access_ioaiu=0;
const aiu_axiInt = [];
var dmi_width= [];
var initiatorAgents   = obj.AiuInfo.length ;
var aiu_NumCores = [];
var aiu_rpn = [];
const aiuName = [];

   var _blkid = [];
   var _blkportsid =[];
   var _blk   = [{}];
   var _idx = 0;
   var aiu_idx = 0;
   obj.nAIUs_mpu =0; 
   
   for(var pidx = 0; pidx < obj.nAIUs; pidx++) {
      if(!Array.isArray(obj.AiuInfo[pidx].interfaces.axiInt)) {
       _blk[_idx]   = obj.AiuInfo[pidx];
       _blkid[_idx] = 'aiu' + aiu_idx;
       _blkportsid[_idx] = 0;
       obj.nAIUs_mpu++;
       aiu_idx++;
       _idx++;
       } else {
       for (var port_idx = 0; port_idx < obj.AiuInfo[pidx].nNativeInterfacePorts; port_idx++) {
        _blk[_idx]   = obj.AiuInfo[pidx];
        _blkid[_idx] = 'aiu' + aiu_idx ;
        _blkportsid[_idx] = port_idx;
        _idx++;
        obj.nAIUs_mpu++;
        }
        aiu_idx++;
       }
   }

 for(var pidx = 0; pidx < initiatorAgents; pidx++) { 
   if(Array.isArray(obj.AiuInfo[pidx].interfaces.axiInt)) {
       aiu_NumCores[pidx]    = obj.AiuInfo[pidx].interfaces.axiInt.length;
       aiu_rpn[pidx]= obj.AiuInfo[pidx].rpn[0];
   } else {
       aiu_NumCores[pidx]    = 1;
       aiu_rpn[pidx]= obj.AiuInfo[pidx].rpn;
   }
 }

for(var pidx = 0; pidx < obj.nDMIs; pidx++) {
    pma_en_dmi_blk &= obj.DmiInfo[pidx].usePma;
    pma_en_at_least_1_blk |= obj.DmiInfo[pidx].usePma;
    if(obj.DmiInfo[pidx].useCmc)
       {
         numDmiWithSMC++;
         idxDmiWithSMC = pidx;
         if(obj.DmiInfo[pidx].ccpParams.useScratchpad)
            {
              numDmiWithSP++;
              idxDmiWithSP = pidx;
            }
         if(obj.DmiInfo[pidx].useWayPartitioning)
            {
              numDmiWithWP++;
              idxDmiWithWP = pidx;
            }
       }
}
for(var pidx = 0; pidx < obj.nDIIs; pidx++) {
    pma_en_dii_blk &= obj.DiiInfo[pidx].usePma;
    pma_en_at_least_1_blk |= obj.DiiInfo[pidx].usePma;
}
for(var pidx = 0; pidx < obj.nDCEs; pidx++) {
    pma_en_dce_blk &= obj.DceInfo[pidx].usePma;
    pma_en_at_least_1_blk |= obj.DceInfo[pidx].usePma;
}
for(var pidx = 0; pidx < obj.nDVEs; pidx++) {
    pma_en_dve_blk &= obj.DveInfo[pidx].usePma;
    pma_en_at_least_1_blk |= obj.DveInfo[pidx].usePma;
}
pma_en_all_blk = pma_en_dmi_blk & pma_en_dii_blk & pma_en_aiu_blk & pma_en_dce_blk & pma_en_dve_blk;

%>

<%
var ioCacheEn = [];
var aiuNativeInf = [];
var dvmEn = [];
var dvmCmpEn = [];
var interlvAiu = [];
var cacheId;
var idSnoopFilterSlice = [];
var hntEn = [];
var hntEnVal;

//var agent_num = [];
//var current_agt_num = 0;
var count = -1 ;
var logical_id = -1;
var AgtIdToCacheId = [];
var aiuBundleIndex = [];
var nACEAgents = 0;


if (obj.nAIUs > 0) {
obj.AiuInfo.forEach(function(bundle, indx, array) {
    if(bundle.useCache) {
        ioCacheEn.push(1);
    } else {
        ioCacheEn.push(0);
    }
     aiuNativeInf.push(bundle.fnNativeInterface);

     if(bundle.nAius > 1) { // interleaved Aius?
       interlvAiu.push(1);
       //current_agt_num += 2;
     } else {
       interlvAiu.push(0);
       //current_agt_num += 1;
     }

     if((bundle.cmpInfo.nDvmSnpInFlight > 0)|(bundle.cmpInfo.nDvmMsgInFlight > 0)) {
       dvmEn.push(1);
     } else {
       dvmEn.push(0);
     }

     if((bundle.cmpInfo.nDvmCmpInFlight > 0)) {
       dvmCmpEn.push(1);
     } else {
       dvmCmpEn.push(0);
     }

     if(bundle.fnNativeInterface === "CHI-A" || bundle.fnNativeInterface === "CHI-B" || bundle.fnNativeInterface === "CHI-E") { // interleaved Aius?
       obj.SnoopFilterInfo.forEach(function(snpinfo, snp_indx, array) {
          if (snpinfo.SnoopFilterAssignment.includes(bundle.FUnitId))
            idSnoopFilterSlice.push(snp_indx);
       });
     }
});
}
   var bundle_index = -1;
   
obj.AiuInfo.forEach(function(bundle, indx, array) {
  if (bundle.interleavedAgent == 0) {
    bundle_index += 1;
  }
  aiuBundleIndex.push(bundle_index);
});

%>

`ifdef USE_VIP_SNPS // Now using this test for synopsys vip sim 
import chi_subsys_pkg::*;
class chi_subsys_base_test extends concerto_base_test;

    //////////////////
    //Properties
    //////////////////

    static string inst_name="";
    static uvm_event csr_trace_debug_done = ev_pool.get("csr_trace_debug_done");
    static uvm_event ev_bist_reset_done = ev_pool.get("bist_reset_done");
    uvm_event kill_uncorr_test   = ev_pool.get("kill_uncorr_test");
    uvm_event kill_chiaiu_uncorr_test   = ev_pool.get("kill_chiaiu_uncorr_test");
    uvm_event kill_uncorr_grar_nsx_test = ev_pool.get("kill_uncorr_grar_nsx_test");
    bit vip_snps_non_coherent_txn = 0;
    bit vip_snps_coherent_txn = 0;
    int vip_snps_seq_length = 4;
    bit                          SYNPS_AXI_SLV_BACKPRESSURE_EN = 0;
    uvm_event                    svt_axi_common_aclk_posedge_e;
    addr_trans_mgr  m_addr_mgr;
    semaphore key=new(1);
    semaphore coh_key=new(1);

    <%for(let idx=0; idx < obj.nCHIs; idx++){%>
        svt_chi_rn_transaction_random_sequence svt_chi_rn_seq_h<%=idx%>;
        svt_chi_link_service_activate_sequence svt_chi_link_up_seq_h<%=idx%>;
        svt_chi_link_service_deactivate_sequence svt_chi_link_dn_seq_h<%=idx%>;
        static uvm_event done_svt_chi_link_dn_seq_h<%=idx%> = ev_pool.get("done_svt_chi_link_dn_seq_h<%=idx%>");
        static uvm_event done_svt_chi_rn_seq_h<%=idx%> = ev_pool.get("done_svt_chi_rn_seq_h<%=idx%>");
        chi_subsys_pkg::chi_subsys_coherency_entry_seq coherency_entry_seq<%=idx%>;
        chi_subsys_pkg::chi_subsys_vseq             m_snps_chi<%=idx%>_vseq;
        chi_aiu_unit_args_pkg::chi_aiu_unit_args    m_chi<%=idx%>_args;
    <%}%>

    <% var axi_slv_idx=0; %>
    <% for(var pidx = 0 ; pidx < obj.nDMIs; pidx++) { %>
    `ifdef USE_VIP_SNPS_AXI_SLAVES
        axi_slave_mem_response_sequence m_axi_slave_mem_response_sequence_dmi<%=axi_slv_idx%>;
        <% axi_slv_idx  = axi_slv_idx + 1; %>
    `endif // USE_VIP_SNPS_AXI_SLAVES
        dmi<%=pidx%>_inhouse_axi_bfm_pkg::axi_slave_read_seq   m_axi_slv_rd_seq_dmi<%=pidx%>;
        dmi<%=pidx%>_inhouse_axi_bfm_pkg::axi_slave_write_seq  m_axi_slv_wr_seq_dmi<%=pidx%>;
        dmi<%=pidx%>_inhouse_axi_bfm_pkg::axi_memory_model     m_axi_slv_memory_model_dmi<%=pidx%>;
        dmi<%=pidx%>_axi_agent_pkg::axi_agent_config  m_dmi<%=pidx%>_axi_slave_cfg;
    <% } %>

    <% for(var pidx = 0 ; pidx < obj.nDIIs; pidx++) { %>
	<% if(obj.DiiInfo[pidx].configuration == 0) { %>
    `ifdef USE_VIP_SNPS_AXI_SLAVES
        axi_slave_mem_response_sequence m_axi_slave_mem_response_sequence_dii<%=axi_slv_idx%>;
    <% axi_slv_idx  = axi_slv_idx + 1; %>
    `endif // USE_VIP_SNPS_AXI_SLAVES
        dii<%=pidx%>_inhouse_axi_bfm_pkg::axi_slave_read_seq   m_axi_slv_rd_seq_dii<%=pidx%>;
        dii<%=pidx%>_inhouse_axi_bfm_pkg::axi_slave_write_seq  m_axi_slv_wr_seq_dii<%=pidx%>;
        dii<%=pidx%>_inhouse_axi_bfm_pkg::axi_memory_model     m_axi_slv_memory_model_dii<%=pidx%>;
        <% } %>
    <% } %>


    int chi_num_trans;
    int ioaiu_num_trans;

   int 	      chiaiu_qos[int];
   int 	      ioaiu_qos[int];
   string     chiaiu_qos_str[];
   string     ioaiu_qos_str[];
   string     chiaiu_qos_arg;
   string     ioaiu_qos_arg;
   bit 	      chiaiu_user_qos;
   bit 	      ioaiu_user_qos;
   
    bit 	hard_reset_issued;

    bit [31:0] 	trace_capture_en_q[$];
    bit [31:0] 	trace_trigger_en_q[$];
    <% 
      var ioaiu_idx = 0;
   %>

    //////////////////
    //UVM Registery
    //////////////////    
    `uvm_component_utils(chi_subsys_base_test)

    //////////////////
    //Methods
    //////////////////

    function new(string name = "chi_subsys_base_test", uvm_component parent = null);
        super.new(name, parent);
        hard_reset_issued = 0;
        m_addr_mgr = addr_trans_mgr::get_instance();
        if(inst_name=="")
        inst_name=name;
    endfunction: new

    function void build_phase(uvm_phase phase);

        string msg_idx;
        int    transorder_mode;

        `uvm_info("Build", "Entered Build Phase", UVM_LOW);
        super.build_phase(phase);

        if (!$value$plusargs("chi_num_trans=%d",chi_num_trans)) begin
            chi_num_trans = 0;
        end
        ioaiu_num_trans = 0;

        `ifdef USE_VIP_SNPS

            void'($value$plusargs("vip_snps_seq_length=%0d",vip_snps_seq_length));

            //SVT CREATE
            <% for(idx = 0; idx < obj.nCHIs; idx++) { %>
                `uvm_info(get_name(), "USE_VIP_SNPS svt_chi_link_service_sequence::CREATE[<%=idx%>]", UVM_NONE)
                svt_chi_link_up_seq_h<%=idx%> = svt_chi_link_service_activate_sequence::type_id::create("svt_chi_link_up_seq_h<%=idx%>");
                svt_chi_link_dn_seq_h<%=idx%> = svt_chi_link_service_deactivate_sequence::type_id::create("svt_chi_link_dn_seq_h<%=idx%>");
                `uvm_info(get_name(), "USE_VIP_SNPS svt_chi_rn_transaction_random_sequence::CREATE[<%=idx%>]", UVM_NONE)
                svt_chi_rn_seq_h<%=idx%> = svt_chi_rn_transaction_random_sequence::type_id::create("svt_chi_rn_seq_h<%=idx%>");
                    coherency_entry_seq<%=idx%> = chi_subsys_pkg::chi_subsys_coherency_entry_seq::type_id::create("coherency_entry_seq<%=idx%>");
            <%}%>
                //SVT OVERRIDE
            
                `ifdef CHI_UNITS_CNT_NON_ZERO
                    set_type_override_by_type(svt_chi_rn_transaction::get_type(),chi_subsys_base_item::get_type());
                    set_type_override_by_type (svt_chi_rn_snoop_transaction::get_type(), chi_subsys_snoop_base_item::get_type());
                `endif // CHI_UNITS_CNT_NON_ZERO
        
            /** Apply the null sequence to the AMBA ENV virtual sequencer to override the default sequence. */
            uvm_config_db#(uvm_object_wrapper)::set(this, "concerto_svt_env.amba_system_env.sequencer.main_phase", "default_sequence", null ); 
        
            <%for (let chi_idx=0; chi_idx < obj.nCHIs; chi_idx++) {%>
                uvm_config_db#(int unsigned)::set(this, "concerto_svt_env.amba_system_env.chi_system[0].rn[<%=chi_idx%>].rn_xact_seqr.svt_chi_rn_transaction_random_sequence", "sequence_length", chi_num_trans);
                uvm_config_db#(bit)::set(this, "concerto_svt_env.amba_system_env.chi_system[0].rn[<%=chi_idx%>].rn_xact_seqr.svt_chi_rn_transaction_random_sequence", "enable_non_blocking", 1);
            <%}%>
        `endif //`ifdef USE_VIP_SNPS
        
    <% var axi_slv_idx=0; %>
        <% for(var pidx = 0 ; pidx < obj.nDMIs; pidx++) { %>
            m_axi_slv_memory_model_dmi<%=pidx%> = dmi<%=pidx%>_inhouse_axi_bfm_pkg::axi_memory_model::type_id::create("m_axi_slv_memory_model");
        
            m_dmi<%=pidx%>_axi_slave_cfg      = dmi<%=pidx%>_axi_agent_pkg::axi_agent_config::type_id::create("m_dmi<%=pidx%>_axi_slave_cfg",  this);
        `ifdef USE_VIP_SNPS_AXI_SLAVES
            m_dmi<%=pidx%>_axi_slave_cfg.active = UVM_PASSIVE;
            m_concerto_env_cfg.m_dmi<%=pidx%>_env_cfg.m_axi_slave_agent_cfg.active = UVM_PASSIVE;
            m_axi_slave_mem_response_sequence_dmi<%=axi_slv_idx%> =  axi_slave_mem_response_sequence::type_id::create("m_axi_slave_mem_response_sequence_dmi<%=axi_slv_idx%>");
            <% axi_slv_idx  = axi_slv_idx + 1; %>
        `else
            m_dmi<%=pidx%>_axi_slave_cfg.active = UVM_ACTIVE;
            m_concerto_env_cfg.m_dmi<%=pidx%>_env_cfg.m_axi_slave_agent_cfg.active = UVM_ACTIVE;
        `endif // `ifdef USE_VIP_SNPS_AXI_SLAVES

        <% } %>

        `ifdef USE_VIP_SNPS_AXI_SLAVES
            svt_axi_common_aclk_posedge_e = new("svt_axi_common_aclk_posedge_e");
            if (!uvm_config_db#(uvm_event)::get( .cntxt(null),
                                            .inst_name(""),
                                            .field_name( "svt_axi_common_aclk_posedge_e" ),
                                            .value( svt_axi_common_aclk_posedge_e ))) begin
                `uvm_error(get_name(), "Event svt_axi_common_aclk_posedge_e is not found")
            end
        `endif // USE_VIP_SNPS_AXI_SLAVES


        <% for(var pidx = 0 ; pidx < obj.nDIIs; pidx++) { %>
            <% if(obj.DiiInfo[pidx].configuration == 0) { %>
            m_axi_slv_memory_model_dii<%=pidx%> = dii<%=pidx%>_inhouse_axi_bfm_pkg::axi_memory_model::type_id::create("m_axi_slv_memory_model");
        

        <%    if (obj.DiiInfo[pidx].configuration != 1) { %>
        `ifdef USE_VIP_SNPS_AXI_SLAVES
            m_concerto_env_cfg.m_dii<%=pidx%>_env_cfg.m_axi_slave_agent_cfg.active = UVM_PASSIVE;
            m_axi_slave_mem_response_sequence_dii<%=axi_slv_idx%> =  axi_slave_mem_response_sequence::type_id::create("m_axi_slave_mem_response_sequence_dii<%=axi_slv_idx%>");
            <% axi_slv_idx  = axi_slv_idx + 1; %>
        `else
            m_concerto_env_cfg.m_dii<%=pidx%>_env_cfg.m_axi_slave_agent_cfg.active = UVM_ACTIVE;
        `endif // `ifdef USE_VIP_SNPS_AXI_SLAVES
            <% } %>
        <% } %>
        <% } %>

        set_inactivity_period(m_args.k_timeout);
        
        `uvm_info("Build", "Exited Build Phase", UVM_LOW);
    endfunction: build_phase

    function chi_subsys_base_test get_instance();
        chi_subsys_base_test fullsys_test;
        uvm_root top;
        top = uvm_root::get();
        if(top.get_child(inst_name)==null) begin
            $display("chi_subsys_base_test, could not find handle of fullsys_test %0s",inst_name);
        end
        else
            $cast(fullsys_test,top.get_child(inst_name));
        return fullsys_test;

    endfunction:get_instance

    task exec_inhouse_boot_seq(uvm_phase phase);
        // Randomize and set configuration in DMI scoreboard
        bit [31:0] agent_id,way_vec,way_full_chk;
        bit [31:0] agent_ids_assigned_q[ncore_config_pkg::ncoreConfigInfo::NUM_DMIS][$];
        bit [31:0] wayvec_assigned_q[ncore_config_pkg::ncoreConfigInfo::NUM_DMIS][$];
        int shared_ways_per_user;
        int way_for_atomic=0;

        int sp_ways[] = new[ncore_config_pkg::ncoreConfigInfo::NUM_DMIS];
        int sp_size[] = new[ncore_config_pkg::ncoreConfigInfo::NUM_DMIS];
        bit [<%=obj.wSysAddr-1%>:0] k_sp_base_addr[] = new[ncore_config_pkg::ncoreConfigInfo::NUM_DMIS];
        int idxq[$];
        string dce_credit_msg="";
        int new_dce_credits;

        ncore_config_pkg::ncoreConfigInfo::sys_addr_csr_t csrq[$];
        csrq = ncore_config_pkg::ncoreConfigInfo::get_all_gpra();

        <% if(obj.useResiliency == 1) { %>
        uvm_resource_db#(bit)::set({"REG::",m_concerto_env.resiliency_m_regs.fsc.FSCMF0.get_full_name()}, "NO_REG_TESTS", 1,this);
        uvm_resource_db#(bit)::set({"REG::",m_concerto_env.resiliency_m_regs.fsc.FSCMF1.get_full_name()}, "NO_REG_TESTS", 1,this);
        uvm_resource_db#(bit)::set({"REG::",m_concerto_env.resiliency_m_regs.fsc.FSCMF2.get_full_name()}, "NO_REG_TESTS", 1,this);
        uvm_resource_db#(bit)::set({"REG::",m_concerto_env.resiliency_m_regs.fsc.FSCMF3.get_full_name()}, "NO_REG_TESTS", 1,this);
        <% } %>
        
        for(int i=0; i<ncore_config_pkg::ncoreConfigInfo::NUM_DMIS; i++) begin
        int max_way_partitioning;
        if(ncore_config_pkg::ncoreConfigInfo::dmis_with_ae[i]) begin  
            way_for_atomic = $urandom_range(0,ncore_config_pkg::ncoreConfigInfo::dmi_CmcWays[i]-1);
        end
        if(ncore_config_pkg::ncoreConfigInfo::dmis_with_cmcwp[i]) begin  
            way_full_chk = 0;
            for(int k=0; k<<%=obj.nAIUs%>;k++) begin
                agent_ids_assigned_q[i].push_back(k);  
            end
            agent_ids_assigned_q[i].shuffle();  
            max_way_partitioning = (ncore_config_pkg::ncoreConfigInfo::dmi_CmcWPReg[i] > <%=obj.nAIUs%>) ? <%=obj.nAIUs%> : ncore_config_pkg::ncoreConfigInfo::dmi_CmcWPReg[i];
            for( int j=0;j<max_way_partitioning /*ncore_config_pkg::ncoreConfigInfo::dmi_CmcWPReg[i]*/;j++) begin
                
                randcase
                    10 : begin agent_id = 32'h0000_0000 | agent_ids_assigned_q[i][j]; agent_ids_assigned_q[i][j] = agent_id; end
                    90 : begin agent_id = 32'h8000_0000 | agent_ids_assigned_q[i][j]; agent_ids_assigned_q[i][j] = agent_id; end
                endcase

                case(i) <%for(var sidx = 0; sidx < obj.nDMIs; sidx++) {%>
                    <%=sidx%> : begin <% if(obj.DmiInfo[sidx].useWayPartitioning && obj.DmiInfo[sidx].useCmc) {%>
                                    if(dmi_scb_en) begin
                                        m_concerto_env.m_dmi<%=sidx%>_env.m_sb.way_partition_vld[j] = agent_id[31]; m_concerto_env.m_dmi<%=sidx%>_env.m_sb.way_partition_reg_id[j] = agent_id[30:0];
                                        end
                                    <%}%>end
            <%}%>endcase

            end // for Waypart Registers
            if(ncore_config_pkg::ncoreConfigInfo::dmis_with_ae[i]==0) begin
                shared_ways_per_user = ncore_config_pkg::ncoreConfigInfo::dmi_CmcWays[i]/ncore_config_pkg::ncoreConfigInfo::dmi_CmcWPReg[i];
            end else begin
                shared_ways_per_user = (ncore_config_pkg::ncoreConfigInfo::dmi_CmcWays[i]-1)/ncore_config_pkg::ncoreConfigInfo::dmi_CmcWPReg[i];
            end
            for( int j=0;j<ncore_config_pkg::ncoreConfigInfo::dmi_CmcWPReg[i];j++) begin
                
                    way_vec = ((1<<$urandom_range(1,shared_ways_per_user)) - 1) << (shared_ways_per_user)*j;
                `uvm_info("TEST_MAIN", $sformatf("For DMI%0d reg%0d with wayvec :%0b",i,j,way_vec), UVM_LOW)
                wayvec_assigned_q[i].push_back(way_vec);
                way_full_chk |=way_vec;
                `uvm_info("TEST_MAIN", $sformatf("For DMI%0d reg%0d with wayfull:%0b num ways in DMI:%0d",i,j,way_full_chk,ncore_config_pkg::ncoreConfigInfo::dmi_CmcWays[i]), UVM_LOW)
            end

            for( int j=0;j<ncore_config_pkg::ncoreConfigInfo::dmi_CmcWPReg[i];j++) begin
                `uvm_info("TEST_MAIN", $sformatf("For DMI%0d reg%0d with wayfull:%0b count ones:%0d",i,j,way_full_chk,$countones(way_full_chk)), UVM_LOW)
                way_vec = wayvec_assigned_q[i].pop_front;
                if(ncore_config_pkg::ncoreConfigInfo::dmis_with_ae[i] && $countones(way_full_chk)>=ncore_config_pkg::ncoreConfigInfo::dmi_CmcWays[i]) begin  
                    way_vec[way_for_atomic] = 1'b0;
                    `uvm_info("TEST_MAIN", $sformatf("For DMI%0d with AtomicEngine way:%0d/%0d is unallocated, so that atomic txn can allocate",i,way_for_atomic,ncore_config_pkg::ncoreConfigInfo::dmi_CmcWays[i]), UVM_LOW)
                    `uvm_info("TEST_MAIN", $sformatf("For DMI%0d reg%0d with wayvec :%0b",i,j,way_vec), UVM_LOW)
                end
                wayvec_assigned_q[i].push_back(way_vec);

                case(i) <%for(var sidx = 0; sidx < obj.nDMIs; sidx++) {%>
                    <%=sidx%> : begin <% if(obj.DmiInfo[sidx].useWayPartitioning && obj.DmiInfo[sidx].useCmc) {%>
                                    if(dmi_scb_en) begin
                                        m_concerto_env.m_dmi<%=sidx%>_env.m_sb.way_partition_reg_way[j] = way_vec;
                                    end
                                    <%}%>end
            <%}%>endcase
            end
        end // if (ncore_config_pkg::ncoreConfigInfo::dmis_with_cmcwp[i])

        // Configure Scratchpad memories
        if(ncore_config_pkg::ncoreConfigInfo::dmis_with_cmcsp[i]) begin  
                randcase
                    //15 : sp_ways[i] = 0;
                    30 : sp_ways[i] = ncore_config_pkg::ncoreConfigInfo::dmi_CmcWays[i];
                    30 : sp_ways[i] = (ncore_config_pkg::ncoreConfigInfo::dmi_CmcWays[i]/2);
                    40 : sp_ways[i] = $urandom_range(1,(ncore_config_pkg::ncoreConfigInfo::dmi_CmcWays[i]-1));
                endcase
    
            idxq = csrq.find_index(x) with (  (x.unit.name == "DMI") && (x.mig_nunitid == ncore_config_pkg::ncoreConfigInfo::dmi_intrlvgrp[ncore_config_pkg::ncoreConfigInfo::picked_dmi_igs][i]) );
            if(idxq.size() == 0) begin
                `uvm_error("EXEC_INHOUSE_BOOT_SEQ", $sformatf("DMI%0d Interleaving group %0d not found", i, ncore_config_pkg::ncoreConfigInfo::dmi_intrlvgrp[ncore_config_pkg::ncoreConfigInfo::picked_dmi_igs][i]))
                end
            k_sp_base_addr[i] = {csrq[idxq[0]].upp_addr,csrq[idxq[0]].low_addr,12'h0}; 

            sp_size[i] = ncore_config_pkg::ncoreConfigInfo::dmi_CmcSet[i] * sp_ways[i];
            k_sp_base_addr[i] = $urandom_range(0, k_sp_base_addr[i] - (sp_size[i] << <%=obj.wCacheLineOffset%>) - 1);
            k_sp_base_addr[i] = k_sp_base_addr[i] >> ($clog2(ncore_config_pkg::ncoreConfigInfo::dmi_CmcSet[i]*ncore_config_pkg::ncoreConfigInfo::dmi_CmcWays[i])+<%=obj.wCacheLineOffset%>);
            k_sp_base_addr[i] = k_sp_base_addr[i] << ($clog2(ncore_config_pkg::ncoreConfigInfo::dmi_CmcSet[i]*ncore_config_pkg::ncoreConfigInfo::dmi_CmcWays[i])+<%=obj.wCacheLineOffset%>);

            <% if((obj.useCmc) && (numDmiWithSP > 0)) { %>
        if(dmi_scb_en) begin 
                case(i) <%for(var sidx = 0; sidx < obj.nDMIs; sidx++) { if(obj.DmiInfo[sidx].ccpParams.useScratchpad==1) {%>
                    <%=sidx%> : 
                        if(sp_ways[<%=sidx%>] > 0) begin
                        m_concerto_env.m_dmi<%=sidx%>_env.m_sb.sp_enabled     = (ncore_config_pkg::ncoreConfigInfo::dmi_CmcWays[<%=sidx%>]) ? 32'h1 : 32'h0;
                        m_concerto_env.m_dmi<%=sidx%>_env.m_sb.lower_sp_addr  = k_sp_base_addr[<%=sidx%>];
                        m_concerto_env.m_dmi<%=sidx%>_env.m_sb.sp_ways        = sp_ways[<%=sidx%>];
                        m_concerto_env.m_dmi<%=sidx%>_env.m_sb.create_SP_q();
                end
                    <% } } %>
                endcase
        end
            <% } %>
        end // if (ncore_config_pkg::ncoreConfigInfo::dmis_with_cmcsp[i])
        end // for nDMIs
    
        begin
        `uvm_info("TEST_MAIN", "Start CHIAIU0 enum_boot_seq", UVM_NONE)
        m_snps_chi0_vseq.enum_boot_seq(agent_ids_assigned_q,wayvec_assigned_q, k_sp_base_addr, sp_ways, sp_size, aiu_qos_threshold, dce_qos_threshold, dmi_qos_threshold);
        end // else: !if(boot_from_ioaiu == 1) !!! in case USE_VIP_SNPS

        #5us; // Need to wait for pending transactions to complete e.g. DTRRsp
        `ifdef USE_VIP_SNPS
            tb_top.release_sysco_req = 1;
        `endif //`ifndef USE_VIP_SNPS
    endtask: exec_inhouse_boot_seq

    task exec_inhouse_seq(uvm_phase phase);
        
        bit timeout;
        int 	      num_qchannel_loop;
        int 	      loop;
        int 	      rand_delay;
        int 	      chiaiu_en[int];
        string     chiaiu_en_str[];
        string     chiaiu_en_arg;
        bit        enable_ace_dvmsync = 0;
        bit [<%=obj.AiuInfo[0].wAddr%>-1:0] cntvr_addr;
        bit [<%=obj.AiuInfo[0].wAddr%>-1:0] cntctrl_addr;
        int 	      data;
        bit [7:0] rpn = 0;
        bit [7:0] nAIUs; // Max 128
        bit [5:0] nDCEs; // Max 32
        bit [5:0] nDMIs; // Max 32
        bit [5:0] nDIIs; // Max 32 or nDIIs
        bit       nDVEs; // Max 1

        <% var axi_slv_idx=0; %>
        <% for(var pidx = 0 ; pidx < obj.nDMIs; pidx++) { %>
            `ifdef USE_VIP_SNPS_AXI_SLAVES
                m_axi_slave_mem_response_sequence_dmi<%=axi_slv_idx%>.prob_ace_rd_resp_error = m_args.dmi<%=pidx%>_prob_ace_slave_rd_resp_error;
                m_axi_slave_mem_response_sequence_dmi<%=axi_slv_idx%>.prob_ace_wr_resp_error = m_args.dmi<%=pidx%>_prob_ace_slave_wr_resp_error;
                fork
                    m_axi_slave_mem_response_sequence_dmi<%=axi_slv_idx%>.start(concerto_svt_env.amba_system_env.axi_system[0].slave[<%=axi_slv_idx%>].sequencer);
                join_none
                <% axi_slv_idx  = axi_slv_idx + 1; %>
            `endif // USE_VIP_SNPS_AXI_SLAVES
            m_axi_slv_rd_seq_dmi<%=pidx%> = dmi<%=pidx%>_inhouse_axi_bfm_pkg::axi_slave_read_seq::type_id::create("m_axi_slv_rd_seq_dmi");
            m_axi_slv_wr_seq_dmi<%=pidx%> = dmi<%=pidx%>_inhouse_axi_bfm_pkg::axi_slave_write_seq::type_id::create("m_axi_slv_wr_seq_dmi");
            m_axi_slv_rd_seq_dmi<%=pidx%>.m_read_addr_chnl_seqr  = m_concerto_env.m_dmi<%=pidx%>_env.m_axi_slave_agent.m_read_addr_chnl_seqr;
            m_axi_slv_rd_seq_dmi<%=pidx%>.m_read_data_chnl_seqr  = m_concerto_env.m_dmi<%=pidx%>_env.m_axi_slave_agent.m_read_data_chnl_seqr;
            m_axi_slv_rd_seq_dmi<%=pidx%>.m_memory_model         = m_axi_slv_memory_model_dmi<%=pidx%>;
            m_axi_slv_rd_seq_dmi<%=pidx%>.prob_ace_rd_resp_error = m_args.dmi<%=pidx%>_prob_ace_slave_rd_resp_error;
            m_axi_slv_wr_seq_dmi<%=pidx%>.m_write_addr_chnl_seqr = m_concerto_env.m_dmi<%=pidx%>_env.m_axi_slave_agent.m_write_addr_chnl_seqr;
            m_axi_slv_wr_seq_dmi<%=pidx%>.m_write_data_chnl_seqr = m_concerto_env.m_dmi<%=pidx%>_env.m_axi_slave_agent.m_write_data_chnl_seqr;
            m_axi_slv_wr_seq_dmi<%=pidx%>.m_write_resp_chnl_seqr = m_concerto_env.m_dmi<%=pidx%>_env.m_axi_slave_agent.m_write_resp_chnl_seqr;
            m_axi_slv_wr_seq_dmi<%=pidx%>.m_memory_model         = m_axi_slv_memory_model_dmi<%=pidx%>;
            m_axi_slv_wr_seq_dmi<%=pidx%>.prob_ace_wr_resp_error = m_args.dmi<%=pidx%>_prob_ace_slave_wr_resp_error;

            if($test$plusargs("perf_test") || $test$plusargs("no_delay")) begin
                m_dmi<%=pidx%>_axi_slave_cfg.k_slow_agent = 0;
                m_dmi<%=pidx%>_axi_slave_cfg.k_ace_slave_read_addr_chnl_burst_pct.set_value(100);
                m_dmi<%=pidx%>_axi_slave_cfg.k_ace_slave_read_data_chnl_burst_pct.set_value(100);
                m_dmi<%=pidx%>_axi_slave_cfg.k_ace_slave_write_addr_chnl_burst_pct.set_value(100);
                m_dmi<%=pidx%>_axi_slave_cfg.k_ace_slave_write_data_chnl_burst_pct.set_value(100);
                m_dmi<%=pidx%>_axi_slave_cfg.k_ace_slave_write_resp_chnl_burst_pct.set_value(100);
            end
            m_concerto_env.m_dmi<%=pidx%>_env.m_cfg.m_axi_slave_agent_cfg = m_dmi<%=pidx%>_axi_slave_cfg;

            <% if(obj.DmiInfo[pidx].useCmc) { %>
                if(dmi_scb_en) begin  
                    if(dmiusmc_policy_rand==2) begin
                    m_concerto_env.m_dmi<%=pidx%>_env.m_sb.ClnWrAllocDisable = 1;
                    end		
                    if(dmiusmc_policy_rand==4) begin
                    m_concerto_env.m_dmi<%=pidx%>_env.m_sb.DtyWrAllocDisable = 1;
                    end
                
                    m_concerto_env.m_dmi<%=pidx%>_env.m_sb.lookup_en = 1;				  
                    if($test$plusargs("dmi_alloc_dis")) begin
                        m_concerto_env.m_dmi<%=pidx%>_env.m_sb.alloc_en = 0;
                    end else begin
                        m_concerto_env.m_dmi<%=pidx%>_env.m_sb.alloc_en = 1;
                    end
        
                end	  
            <% } %>						  
        <% } %>
        <% for(var pidx = 0 ; pidx < obj.nDIIs; pidx++) { %>
            <% if(obj.DiiInfo[pidx].configuration == 0) { %>
                `ifdef USE_VIP_SNPS_AXI_SLAVES
                    m_axi_slave_mem_response_sequence_dii<%=axi_slv_idx%>.prob_ace_rd_resp_error = m_args.dii<%=pidx%>_prob_ace_slave_rd_resp_error;
                    m_axi_slave_mem_response_sequence_dii<%=axi_slv_idx%>.prob_ace_wr_resp_error = m_args.dii<%=pidx%>_prob_ace_slave_wr_resp_error;
                    fork
                        m_axi_slave_mem_response_sequence_dii<%=axi_slv_idx%>.start(concerto_svt_env.amba_system_env.axi_system[0].slave[<%=axi_slv_idx%>].sequencer);
                    join_none
                    <% axi_slv_idx  = axi_slv_idx + 1; %>
                `endif // USE_VIP_SNPS_AXI_SLAVES
                m_axi_slv_rd_seq_dii<%=pidx%> = dii<%=pidx%>_inhouse_axi_bfm_pkg::axi_slave_read_seq::type_id::create("m_axi_slv_rd_seq_dii");
                m_axi_slv_wr_seq_dii<%=pidx%> = dii<%=pidx%>_inhouse_axi_bfm_pkg::axi_slave_write_seq::type_id::create("m_axi_slv_wr_seq_dii");
                m_axi_slv_rd_seq_dii<%=pidx%>.m_read_addr_chnl_seqr  = m_concerto_env.m_dii<%=pidx%>_env.m_axi_slave_agent.m_read_addr_chnl_seqr;
                m_axi_slv_rd_seq_dii<%=pidx%>.m_read_data_chnl_seqr  = m_concerto_env.m_dii<%=pidx%>_env.m_axi_slave_agent.m_read_data_chnl_seqr;
                m_axi_slv_rd_seq_dii<%=pidx%>.m_memory_model         = m_axi_slv_memory_model_dii<%=pidx%>;
                m_axi_slv_rd_seq_dii<%=pidx%>.prob_ace_rd_resp_error = m_args.dii<%=pidx%>_prob_ace_slave_rd_resp_error;
                m_axi_slv_wr_seq_dii<%=pidx%>.m_write_addr_chnl_seqr = m_concerto_env.m_dii<%=pidx%>_env.m_axi_slave_agent.m_write_addr_chnl_seqr;
                m_axi_slv_wr_seq_dii<%=pidx%>.m_write_data_chnl_seqr = m_concerto_env.m_dii<%=pidx%>_env.m_axi_slave_agent.m_write_data_chnl_seqr;
                m_axi_slv_wr_seq_dii<%=pidx%>.m_write_resp_chnl_seqr = m_concerto_env.m_dii<%=pidx%>_env.m_axi_slave_agent.m_write_resp_chnl_seqr;
                m_axi_slv_wr_seq_dii<%=pidx%>.m_memory_model         = m_axi_slv_memory_model_dii<%=pidx%>;
                m_axi_slv_wr_seq_dii<%=pidx%>.prob_ace_wr_resp_error = m_args.dii<%=pidx%>_prob_ace_slave_wr_resp_error;
            <% } %>
        <% } %>

        <%for(var idx = 0; idx < obj.nCHIs; idx++) { %>
            m_snps_chi<%=idx%>_vseq = chi_subsys_pkg::chi_subsys_vseq::type_id::create("m_chi<%=idx%>_seq");
            m_snps_chi<%=idx%>_vseq.set_seq_name("m_chi<%=idx%>_seq");
            m_snps_chi<%=idx%>_vseq.set_done_event_name("done_svt_chi_rn_seq_h<%=idx%>");
            m_snps_chi<%=idx%>_vseq.rn_xact_seqr    =  concerto_svt_env.amba_system_env.chi_system[0].rn[<%=idx%>].rn_xact_seqr;  
            m_snps_chi<%=idx%>_vseq.shared_status =  concerto_svt_env.amba_system_env.chi_system[0].rn[<%=idx%>].shared_status;  
            m_snps_chi<%=idx%>_vseq.chi_num_trans =  chi_num_trans;  
            m_snps_chi<%=idx%>_vseq.m_regs = m_concerto_env.m_regs;
            m_chi0_args = chi_aiu_unit_args_pkg::chi_aiu_unit_args::type_id::create("chi_aiu_unit_args<%=idx%>");
            m_chi0_args.k_num_requests.set_value(chi_num_trans);
            m_chi0_args.k_coh_addr_pct.set_value(50);
            m_chi0_args.k_noncoh_addr_pct.set_value(50);
            m_chi0_args.k_device_type_mem_pct.set_value(50);
            m_chi0_args.k_new_addr_pct.set_value(50);
            m_snps_chi<%=idx%>_vseq.set_unit_args(m_chi0_args);
        <% } %>

        phase.raise_objection(this, "chi_subsys_base_test");

        fork
            <% for(var pidx = 0; pidx < obj.nDMIs; pidx++) { %>
                    m_axi_slv_rd_seq_dmi<%=pidx%>.start(null);
                    m_axi_slv_wr_seq_dmi<%=pidx%>.start(null);
            <% } %>
            <% for(var pidx = 0; pidx < obj.nDIIs; pidx++) { %>
                <% if(obj.DiiInfo[pidx].configuration == 0) { %>
                    m_axi_slv_rd_seq_dii<%=pidx%>.start(null);
                    m_axi_slv_wr_seq_dii<%=pidx%>.start(null);
                <% } %>
            <% } %>
        join_none

        fork
            <%for(let idx=0; idx < obj.nCHIs; idx++){%>
                begin
                    `uvm_info(get_name(), "USE_VIP_SNPS svt_chi_link_UP_service_sequence::START[<%=idx%>]", UVM_LOW)
                    svt_chi_link_up_seq_h<%=idx%>.start(concerto_svt_env.amba_system_env.chi_system[0].rn[<%=idx%>].link_svc_seqr) ;
                    `uvm_info(get_name(), "USE_VIP_SNPS svt_chi_link_UP_service_sequence::END[<%=idx%>]", UVM_LOW)
                end
            <% } %>
        join


        fork
            <%for(let idx=0; idx < obj.nCHIs; idx++){%>
                begin
                    `uvm_info(get_name(), "USE_VIP_SNPS coherency_entry_seq::START[<%=idx%>]", UVM_NONE)
                    coherency_entry_seq<%=idx%>.delay_in_ns=50000;
                    coherency_entry_seq<%=idx%>.randomize();
                    fork
                        begin
                        coherency_entry_seq<%=idx%>.start(concerto_svt_env.amba_system_env.chi_system[0].rn[<%=idx%>].prot_svc_seqr);
                        `uvm_info(get_name(), "USE_VIP_SNPS coherency_entry_seq::END[<%=idx%>]", UVM_NONE)
                        end
                    join_none
                    csr_init_done.wait_trigger();
                    `uvm_info("TEST MAIN", "Done - waiting for csr_init_done trigger", UVM_NONE)
                    tb_top.release_sysco_req = 1;
                end
            <%}%>
        join_none


        exec_inhouse_boot_seq(phase);
        csr_init_done.trigger(null);

        #100ns;
        start_sequence();
        phase.drop_objection(this, "chi_subsys_base_test");
    endtask: exec_inhouse_seq

    virtual task start_sequence();
        bit[<%=obj.AiuInfo[0].wAddr%>-1:0] addr;
	`ifdef SVT_CHI_ISSUE_E_ENABLE
        chi_subsys_pkg::chi_subsys_mkrdunq_seq      m_mkrdunq0_seq;
	`endif

        fork
            begin
		`ifdef SVT_CHI_ISSUE_E_ENABLE
                if($test$plusargs("mkrdunq_directed_test")) begin
                    addr = m_addr_mgr.gen_coh_addr(0, 1);
                    m_mkrdunq0_seq = chi_subsys_pkg::chi_subsys_mkrdunq_seq::type_id::create("m_mkrdunq0_seq");
                    m_mkrdunq0_seq.directed_addr_mailbox.put(addr);
                    m_mkrdunq0_seq.directed_is_non_secure_access_mailbox.put(1);
                    m_mkrdunq0_seq.disable_all_weights();
                    m_mkrdunq0_seq.readpreferunique_wt = 1;
                    m_mkrdunq0_seq.start(concerto_svt_env.amba_system_env.chi_system[0].rn[0].rn_xact_seqr);
                    #1us; // Wait for the above transaction to finish - Is there a better way?
                    m_mkrdunq0_seq.directed_addr_mailbox.put(addr);
                    m_mkrdunq0_seq.directed_is_non_secure_access_mailbox.put(1);
                    m_mkrdunq0_seq.disable_all_weights();
                    m_mkrdunq0_seq.readpreferunique_wt = 1;
                    m_mkrdunq0_seq.start(concerto_svt_env.amba_system_env.chi_system[0].rn[1].rn_xact_seqr);
                    #1us;
                    // m_mkrdunq0_seq.directed_addr_mailbox.put(addr);
                    // m_mkrdunq0_seq.directed_is_non_secure_access_mailbox.put(1);
                    // m_mkrdunq0_seq.disable_all_weights();
                    // m_mkrdunq0_seq.cleanunique_wt = 1;
                    // m_mkrdunq0_seq.start(concerto_svt_env.amba_system_env.chi_system[0].rn[1].rn_xact_seqr);
                    // #1us;
                    m_mkrdunq0_seq.directed_addr_mailbox.put(addr);
                    m_mkrdunq0_seq.directed_is_non_secure_access_mailbox.put(1);
                    m_mkrdunq0_seq.disable_all_weights();
                    m_mkrdunq0_seq.makereadunique_wt = 1;
                    m_mkrdunq0_seq.start(concerto_svt_env.amba_system_env.chi_system[0].rn[0].rn_xact_seqr);
                    #1us;
                    // m_mkrdunq0_seq.directed_addr_mailbox.put(addr);
                    // m_mkrdunq0_seq.directed_is_non_secure_access_mailbox.put(1);
                    // m_mkrdunq0_seq.disable_all_weights();
                    // m_mkrdunq0_seq.makereadunique_wt = 1;
                    // m_mkrdunq0_seq.start(concerto_svt_env.amba_system_env.chi_system[0].rn[0].rn_xact_seqr);
                end else begin
		`endif
                    <%for(let idx = 0; idx < obj.nCHIs; idx++) { %>
                        begin
                            m_snps_chi<%=idx%>_vseq.set_unit_args(m_chi0_args);
                            `uvm_info(get_name(), "Starting m_snps_chi<%=idx%>_vseq", UVM_NONE)
                            m_snps_chi<%=idx%>_vseq.start(null);
                            `uvm_info(get_name(), "Done m_snps_chi<%=idx%>_vseq", UVM_NONE)
                        end
                    <%}%>
		`ifdef SVT_CHI_ISSUE_E_ENABLE
                end
		`endif
            end
        join
    endtask: start_sequence

    task run_phase(uvm_phase phase);
        super.run_phase(phase);
        addr_mgr.get_connectivity_if();
        `uvm_info("TEST_MAIN", "Starting chi_subsys_base_test::exec_inhouse_seq ...", UVM_LOW)
            exec_inhouse_seq(phase);
        `uvm_info("TEST_MAIN", "Finish chi_subsys_base_test ...", UVM_LOW)
    endtask: run_phase

endclass: chi_subsys_base_test

`endif // `ifdef USE_VIP_SNPS
