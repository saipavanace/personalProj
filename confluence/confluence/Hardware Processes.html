<p>Hardware development processes are described in the flow chart shown below. Architecture, verification test plan development and verification coding  details are described in their respective process sections and are not part of this section.</p><p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" src="https://arterisip.atlassian.net/wiki/download/attachments/16171195/image2017-7-18%2016:30:20.png?api=v2"></span></p><h2 id="HardwareProcesses-DetailedScheduledevelopment">Detailed Schedule development</h2><p>A detailed schedule is developed by breaking down the architecture requirements into different design units and corresponding verification units. These units are assigned owners.  Note that a single unit may be assigned multiple owners or a single owner may be assigned to multiple units. The units are further broken down into tasks, which are assigned estimated time to complete. This detailed schedule is developed partly in parallel to initial micro arch development.  </p><p> </p><p>An example of detailed Ncore 2.0 schedule is  here (<a href="https://arterisip.atlassian.net/wiki/download/attachments/16171195/hw_release_2.0_Schedule_V0.4%20(5).pod?version=1&amp;modificationDate=1499365370603&amp;cacheVersion=1&amp;api=v2" data-linked-resource-id="16282012" data-linked-resource-version="1" data-linked-resource-type="attachment" data-linked-resource-default-alias="hw_release_2.0_Schedule_V0.4 (5).pod" data-linked-resource-content-type="application/octet-stream" data-linked-resource-container-id="16171195" data-linked-resource-container-version="26">hw_release_2.0_Schedule</a>)</p><h2 id="HardwareProcesses-MicroArchdevelopment">Micro Arch development</h2><p>Each design unit will have a micro architecture document associated with it. Micro arch documents are developed based on the template below.</p><p><a href="https://arterisip.atlassian.net/wiki/download/attachments/16171195/ArterisMicroArchitectureTemplate.docx?version=1&amp;modificationDate=1499367209218&amp;cacheVersion=1&amp;api=v2" data-linked-resource-id="16281963" data-linked-resource-version="1" data-linked-resource-type="attachment" data-linked-resource-default-alias="ArterisMicroArchitectureTemplate.docx" data-nice-type="Microsoft Word Document" data-linked-resource-content-type="application/vnd.openxmlformats-officedocument.wordprocessingml.document" data-linked-resource-container-id="16171195" data-linked-resource-container-version="26">ArterisMicroArchitectureTemplate.docx</a></p><p>The document is a work in progress document throughout the project. The different versions are defined as below. </p><ul><li>Version 0.5 should specify all expected features to be implemented and possibly have basic data and control structures </li><li>Version 0.7 should have all implementation details with configuration parameters, block diagrams and state machines. This document should be ready for pre-implementation review with Arch team. </li><li>Version 0.9 should incorporate all review feed back and is a WIP document until all development is done. <ul><li>Update to this version is required ASAP if and when there are any interface changes.</li><li>Internal logic change updates are required but the document can be updated depending on the owners discretion. Implementation and debug has higher priority.  </li><li>This version will go into <span class="inline-comment-marker" data-ref="df790e31-7267-4e66-a7c1-7b6629ffe485">final detailed r</span>eview with the architecture and verification team before the release.      </li></ul></li><li>Version 1.0 Should incorporate any typos and minor updates from the review. Note that the final review is not expected to have any major updates </li></ul><p>The general development process of the document is shown in the flow chart below:</p><p> </p><p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" src="https://arterisip.atlassian.net/wiki/download/attachments/16171195/image2017-8-25%2013:57:15.png?api=v2"></span></p><h2 id="HardwareProcesses-RTLcoding">RTL coding</h2><p><span class="confluence-anchor-link" id="HardwareProcesses-ACHL"><span class="confluence-anchor-link" id="ACHL"></span></span>Arteris designs are highly configurable and we use internally developed Arteris Configurable Hardware Language (ACHL).</p><p>ACHL specification is described in <a href="https://arterisip.atlassian.net/wiki/download/attachments/16171195/ACHL%20Language%20Overview%20ver%200.10.pdf?version=1&amp;modificationDate=1499481064478&amp;cacheVersion=1&amp;api=v2" data-linked-resource-id="16282672" data-linked-resource-version="1" data-linked-resource-type="attachment" data-linked-resource-default-alias="ACHL Language Overview ver 0.10.pdf" data-nice-type="PDF Document" data-linked-resource-content-type="application/pdf" data-linked-resource-container-id="16171195" data-linked-resource-container-version="26">ACHL Language Overview ver 0.10.pdf</a>  </p><p>In addition to the specification following coding guidelines are followed </p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166882/ACHL+Coding+Guidelines" data-linked-resource-id="16166882" data-linked-resource-version="21" data-linked-resource-type="page">ACHL Coding Guidelines</a></p><p>During RTL coding depending on the risk factor and critical path some or all of the code may go through code reviews. Code reviews are used to identify and flush out bugs which may be found later on in the development cycle by verification. </p><p>RTL is broadly classified into four phases. The work done in these phases is defined as part of RTL staging plan. </p><ol><li><strong>Initial design phase</strong>: <br/>During this phase the designer spends 100% of the time coding. This phase includes complete infrastructure and core <span class="inline-comment-marker" data-ref="2c0766c0-9167-4af3-9fd3-78c66243cbf9">functionality.  It should include all ports, data and control structures required to support functionality defined as part of RTL staging plan for this phase. At the end of this phase the design is expected to be compile clean.     </span></li><li><strong>Bring-up phase</strong>: <br/>During this phase the designer spends 40% of the time coding advanced features and 60% of the time bringing up the design that is coded in the initial design <span class="inline-comment-marker" data-ref="f6162940-e013-4c05-adf5-2d09053c812d">phase</span>. The bring up phase is declared complete once all the test cases identified for mini regression are clean and the design is at a stage where pre-push can be enabled. Note that the mini regression should have at least one test for each feature or combination of features. As design progresses and features are added mini regression should be beefed-up.   </li><li><strong>Volume phase</strong>: <br/>During this phase the designer spends 70% of the time coding and 30% of the time debugging/ fixing both timing and functional bugs found. The designer will start getting timing feedback in this phase. This phase ends when all major advanced features have been coded. </li><li><strong>Final phase</strong>:<br/>During this phase the designer spends 20% of the time coding any remaining minor advance features and 80% of the time debugging/ fixing both timing and functional bugs found. This phase ends when the regressions are 100% clean and timing closure is achieved. </li></ol><h3 id="HardwareProcesses-Issueprocess">Issue process </h3><p>JIRA is used to file and track issues. This is done once the bring-up phase is complete. During bring-up phase the design and verification engineer is expected to work closely to resolve issues as soon as they are found. the JIRA process is described here: <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166643/Jira+Process" data-linked-resource-id="16166643" data-linked-resource-version="3" data-linked-resource-type="page">Jira Process</a></p><p>JIRA dashboards are used to track and report progress; below is an example of a HW dashboard</p><p><span class="confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image image-center" height="400" src="https://arterisip.atlassian.net/wiki/download/attachments/16171195/image2017-7-10%209:18:58.png?api=v2"></span></p><p> </p><h2 id="HardwareProcesses-Unitleveldebugandbugfixes">Unit level debug and bug fixes </h2><p> This starts at the bring-up phase and runs till the end of the project. </p><h2 id="HardwareProcesses-Systemleveldebugandbugfixes">System level debug and bug fixes </h2><div> This starts towards the end of bring-up phase and runs till the end of the project. </div><h2 id="HardwareProcesses-TimingClosure">Timing Closure </h2><p>Each project has an associated eval configuration. This configuration is developed based on the design knowledge and practical use case. The eval configuration should meet following requirements</p><ul><li>It should include all current and new features </li><li>It should include all expected worst critical timings paths</li><li>Memories and resources should be sized based on expected use case for the project.</li></ul><p>The eval project is used to achieve timing closure. The eval projects are saved under concerto stash repository test_projects/<span>synthesis_projects/</span>   </p><p>Timing closure Methodology is defined below:</p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16169030/Ncore+Synthesis+Methodology" data-linked-resource-id="16169030" data-linked-resource-version="10" data-linked-resource-type="page">Ncore Synthesis Methodology</a></p><h2 id="HardwareProcesses-Regressions">Regressions </h2><p>Please refer to verification processes. </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p>