<h1 id="ParameterAPIreorganizationproposal-Problem">Problem</h1><p>Current Parameter API simplified a lot the way how ADM clients can access parameters data.</p><p>Although there are still some possibilities for improvement.</p><ul><li>There is no consistency between <code>set_attribute</code> command and Parameter API.<ul><li><code>set_attribute</code> command make no difference between pre and postmap parameters while parameter API does.</li><li><code>set_attribute</code> command differ scalar and array parameters while parameter API does not (there is a single interface).</li></ul></li><li><code>ParameterInterface</code>  contains methods for all possible parameters (scalar, array, custom). It violates Interface Segregation principle (from <a class="external-link" href="https://en.wikipedia.org/wiki/SOLID" rel="nofollow">SOLID principles</a>).</li></ul><h1 id="ParameterAPIreorganizationproposal-Solution">Solution</h1><p>The main idea is split <code>ParameterInterface</code>  on several smaller interfaces.<br/>To hide difference between pre and postmap parameters we can implement mapping parameters as a decoration (Decorator pattern) for premapping ones.</p><p>Here is a sketch of the interface for scalar parameters:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">class ScalarParameters {
 public:
  bool has(HashString name) const {
    return hasImpl(name) ? true : decoratedParameters_.has();
  }
  AttrValue get(HashString) const;
  ... validate, getDescription, set, flags ...

  void decorateWith(ScalarParameters&amp; parametersToDecoration);

 protected:
  virtual bool hasImpl(HashString) const = 0;
  virtual optional&lt;AttrValue&gt; getImpl(HashString) = 0;

 private:
  ScalarParameters&amp; decoratedParameters_;
};</pre>
</div></div><p>A similar API will be for array and custom parameters.</p><p>The decoration can be done during the mapping:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">AdmMapper::ArchMappingResult mapArchitecture(SomeObject&amp; obj) {
  ...
  obj.parameters().decorateWith(PostmapScalarParameters(&quot;some_object_map_type&quot;));
  obj.arrayParameters().decorateWith(PostmapArrayParameters(&quot;some_object_map_type&quot;));
  ...
}</pre>
</div></div><p>AdmOwner class can provide references to access scalar, array, and custom separately.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">class AdmOwner {
 public:
  ...
  ScalarParameters&amp; parameters();
  const ScalarParameters&amp; parameters() const;

  ArrayParameters&amp; arrayParameters();
  const ArrayParameters&amp; arrayParameters() const;

  CustomParameters&amp; customParameters();
  const CustomParameters&amp; customParameters() const;
};</pre>
</div></div><h1 id="ParameterAPIreorganizationproposal-Prosandcons">Pros and cons</h1><p>Pros:</p><ul><li>Single responsibility interfaces</li><li>Consistency between commands and internal API</li><li>Hiding the difference between pre and postmap parameters</li><li>Socket run-time parameters can also be implemented as decoration</li><li>A lot of existing code can be reused</li></ul><p>Const:</p><ul><li>Potential overhead for Adm code which works with postmap parameters (may require keeping internally an interface for direct access to postmap parameters)</li><li>A high amount of old API usages need to be changed</li></ul>