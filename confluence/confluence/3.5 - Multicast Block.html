<p>The multicast block's purpose is to take a single request transaction and multiply it up to become multiple request transactions to multiple targets. It is also responsible for accumulating all the responses and generating a single response for the single request. </p><p>Multicast blocks act more like switches than adapters, but they have properties of bidirectional adapters because the responses for all the requests that pass through them must return through them.</p><p>Below is a simple block diagram that shows how a multicast block sits relative to the request and response networks.</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16169566/multicast_bench_full.svg?api=v2"></span></p><p>The links and switches colored in red represent the request network. The links and switches colored in blue represent the response network. Blocks colored in black represent blocks that are connected to both networks. The black block labeled multi is the multicast block.</p><h3 id="id-3.5-MulticastBlock-MultipleMulticastTrees">Multiple Multicast Trees</h3><p>There can be multiple multicast trees in a network and a single target can be a part of multiple multicast tress.</p><h3 id="id-3.5-MulticastBlock-MulticastMicroarchitecture">Multicast Microarchitecture</h3><p>In the first implementation of Symphony, the multicast block can only multicast from a single incoming request ATP link to multiple outgoing request ATP links and the maximum number of output packets generated from a single request is equal to the number output request ATP links. So if a multicast block has three output request ports it can multicast to three targets.</p><p>The multicast block itself has the following block diagram:<br/><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16169566/MultiCastBlockDiagram.svg?api=v2"></span></p><p>To understand what the multicast block does, it's best to follow a packet from initiator to targets.</p><h3 id="id-3.5-MulticastBlock-TheLifeofaMulticastPacket">The Life of a Multicast Packet</h3><p>In the initiator ATU, the only thing that differentiates a normal packet from a multicast packet is the address of the transaction. When the address of the transaction hits in the multicast address space, it causes a different route and target ID to be put into the packet. The target ID is the ID of the multicast block. There is also a label (referred to as multi_label for now on,) that is put into the header that identifies which multicast tree is being used, there can be multiple multicast trees in a design. The label 0 is reserved for all non multicast transactions. There will be bits in the incoming user bits of the native interface that get mapped into the packet header (referred to has multi_mask for now on,) but this mapping happens for all transactions. The multi_mask indicate which targets are desired for the multicast transaction and are ignored for normal transactions. The thing to understand is from the viewpoint of the initiator there is only one transaction.</p><p>When a packet hits a multicast block, it will store context under the source id and sequence number that comes from the packet. These fields are put into the packet by the initiator. What gets stored in context is a function of what’s in the two link packet definitions are for the request and response networks. Packet definitions are dynamic in Symphony and are a function of the type of fabric (request or response) and the configuration of the targets and initiators.</p><p>The number of transactions broadcast from the multicast block is a function of the multi_mask coming in. In the outgoing packets, two things are changed, the target ID and route.</p><p>For the response packet, the target ATU will generate a route based on the multi_label value and source ID of the original transaction. The only way the target ATU differentiates a normal response vs a multicast response is by the multi_label. This is why label 0 is reserved for normal transactions. This also means that multi_label will always be at least 1 bit even in a system that has only one broadcast tree.</p><p>Because the present multicast block only supports writes, it will be getting back from each of the packets broadcast a response. It must take those responses and merge them. To do this, it uses the target ID (which is the original source ID of the initiator ATU,) the multicast label and sequence number to merge the responses into one response. The error response will be merged in the same way the errors are accumulated in a normal write response. Once all the responses for a broadcast have been accumulated and all the ordering rules have been maintained, the multicast adapter forms a packet from context. It will look up the route using the target ID (the original source ID) from the srcPathLut.  If there are no errors this packet will look identical to the incoming responses except the route and srcID if it exists.</p><h3 id="id-3.5-MulticastBlock-DaisyChaining">Daisy Chaining</h3><p>Multiple multicast blocks can be daisy chained to build up a single multicast tree.</p><h3 id="id-3.5-MulticastBlock-Interrupts">Interrupts</h3><p>Not shown in the block diagram is an interrupt signal that exits the block. The reason the interrupt is generated is because a transaction can be buffered (a transaction type) and when this happens the multicast can get an error response from one of it's targets after it has sent an error free response back to the original initiator. To cover for this possibility, the multicast block always sends an interrupt when it gets an error on a response.</p><h3 id="id-3.5-MulticastBlock-DeadLockAvoidance">Dead Lock Avoidance</h3><p>One of the parameters a customer controls in the multicast block is how much buffering (pktSize) that the multicast block can hold. The buffering does not need to be the size of a maximum broadcast packet except under certain conditions. These conditions are set determined by topologies that can cause deadlocks.</p><p><strong>When must a multicast block hold and entire broadcast packet:</strong></p><ol><li>If any resource (a link, a pipe, a FIFO, a ATU target . . . ) is shared between multiple broadcast trees.</li><li>If the topology has cycles. Examples of this are meshes and rings.</li></ol><h3 id="id-3.5-MulticastBlock-Parameters">Parameters</h3><p>Most parameters for a multicast block are created by Maestro based on the location and topology of the network the tree is located in. However, there is a parameter the customer can control.</p><p><strong>pktSize</strong>: The number of beats of data the multicast block can hold at any given time.</p>