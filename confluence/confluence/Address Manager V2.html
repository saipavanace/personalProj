<style type='text/css'>/*<![CDATA[*/
div.rbtoc1759725155439 {padding: 0px;}
div.rbtoc1759725155439 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1759725155439 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class='toc-macro rbtoc1759725155439'>
<ul class='toc-indentation'>
<li><a href='#AddressManagerV2-Responsibilities'>Responsibilities</a>
<ul class='toc-indentation'>
<li><a href='#AddressManagerV2-AggregateBootRegion'>Aggregate Boot Region</a></li>
<li><a href='#AddressManagerV2-AggregateCSRRegion'>Aggregate CSR Region</a></li>
<li><a href='#AddressManagerV2-RandomizetheDMIInterleavinggroups'>Randomize the DMI Interleaving groups</a></li>
<li><a href='#AddressManagerV2-RandomizeGPRAaddressspace'>Randomize GPRA address space</a></li>
<li><a href='#AddressManagerV2-RandomizeGPRAmappingtoDMIandDII'>Randomize GPRA mapping to DMI and DII</a></li>
<li><a href='#AddressManagerV2-ProvideUtilityFunctionstoUsers'>Provide Utility Functions to Users</a></li>
</ul>
</li>
<li><a href='#AddressManagerV2-AddressSpacePriorityAccess'>Address Space Priority Access</a></li>
<li><a href='#AddressManagerV2-CodeStructure'>Code Structure</a>
<ul class='toc-indentation'>
<li><a href='#AddressManagerV2-chiplet_mem_info.sv'>chiplet_mem_info.sv</a></li>
<li><a href='#AddressManagerV2-mem_agent.sv'>mem_agent.sv</a></li>
<li><a href='#AddressManagerV2-mem_agent_cfg.sv'>mem_agent_cfg.sv</a></li>
<li><a href='#AddressManagerV2-mem_agent_pkg.sv'>mem_agent_pkg.sv</a></li>
</ul>
</li>
<li><a href='#AddressManagerV2-AddressManagerConfigurationObject'>Address Manager Configuration Object</a></li>
<li><a href='#AddressManagerV2-CustomMemoryRegions'>Custom Memory Regions</a></li>
<li><a href='#AddressManagerV2-AddressManagerUsage'>Address Manager Usage</a></li>
<li><a href='#AddressManagerV2-Multi-ChipletAddressMapGenerator—RequirementsSpec'>Multi-Chiplet Address Map Generator — Requirements Spec</a>
<ul class='toc-indentation'>
<li><a href='#AddressManagerV2-1)Systemoverview'>1) System overview</a>
<ul class='toc-indentation'>
<li><a href='#AddressManagerV2-Reachabilityexamples'>Reachability examples</a></li>
</ul>
</li>
<li><a href='#AddressManagerV2-2)Inputs(pertest/designinstance)'>2) Inputs (per test / design instance)</a></li>
<li><a href='#AddressManagerV2-3)Outputs'>3) Outputs</a></li>
<li><a href='#AddressManagerV2-4)Addressregionrules'>4) Address region rules</a></li>
<li><a href='#AddressManagerV2-5)HUT/HUIencoding'>5) HUT/HUI encoding</a></li>
<li><a href='#AddressManagerV2-6)Localminimumrequirements'>6) Local minimum requirements</a></li>
<li><a href='#AddressManagerV2-7)Remoteplacement—mirror-or-forwardchains'>7) Remote placement — mirror-or-forward chains</a>
<ul class='toc-indentation'>
<li><a href='#AddressManagerV2-GPRAbudgetaccountingforremotes'>GPRA budget accounting for remotes</a></li>
</ul>
</li>
<li><a href='#AddressManagerV2-8)Globalvalidityconstraints'>8) Global validity constraints</a></li>
<li><a href='#AddressManagerV2-9)Randomizationandreproducibility'>9) Randomization and reproducibility</a></li>
<li><a href='#AddressManagerV2-10)Codestructureandgenerationflow'>10) Code structure and generation flow</a></li>
<li><a href='#AddressManagerV2-11)Fielddefinitions(mem_info_t)'>11) Field definitions (mem_info_t)</a></li>
<li><a href='#AddressManagerV2-12)Cornercasesandguarantees'>12) Corner cases and guarantees</a></li>
</ul>
</li>
<li><a href='#AddressManagerV2-OldvsNewAddressManagerFunctions'>Old vs New Address Manager Functions</a></li>
</ul>
</div><h1 id="AddressManagerV2-Responsibilities">Responsibilities</h1><h2 id="AddressManagerV2-AggregateBootRegion">Aggregate Boot Region</h2><ul><li><p>The base address of the BOOT region is part of the configuration </p></li><li><p>This can be found in the dv.json in this parameter:<br/></p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">&quot;BootInfo&quot;: {
  &quot;regionHui&quot;: 0,
  &quot;regionHut&quot;: 1,
  &quot;regionSize&quot;: 2,
  &quot;regionBlr&quot;: &quot;&#39;h0&quot;,
  &quot;regionBhr&quot;: &quot;&#39;h0&quot;
}</pre>
</div></div></li><li><p>In the above snippet, HUT indicates which type of unit is connected to the boot region</p></li><li><p>HUI indicates the FUnitId of the unit that is connected to the Boot Region</p></li><li><p>Size indicates the Size of the Boot region according to this formula: 2^(regionSize + 12)</p></li><li><p>regionBlr and regionBhr - TODO: Need to understand why we need two? We just need base address and size?</p></li></ul><h2 id="AddressManagerV2-AggregateCSRRegion">Aggregate CSR Region</h2><ul><li><p>The base address of the CSR region is also part of the configuration where the base address of the first unit is obtained by this parameter in the dv.json:<br/></p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">&quot;CsrInfo&quot;: {
  &quot;csrBaseAddress&quot;: &quot;&#39;h00002e8&quot;
},</pre>
</div></div></li><li><p>After we have this base address, the CSR region for each unit will be the last address of previous region + 4K boundary</p></li><li><p>We just need to keep incrementing the addresses for each unit based on ‘rpn’ parameter in the dv.json</p></li></ul><h2 id="AddressManagerV2-RandomizetheDMIInterleavinggroups">Randomize the DMI Interleaving groups</h2><ul><li><p>DMIs can be interleaved/distributed as a Memory Interleave Group (MIG) of 1, 2 or 4 DMIs. Multiple memory interleave groups form a Memory Interleave Group Set (MIGS). For example, if a system has 7 DMIs, DMI0 to DMI6, they can be categorized into 3 different memory interleave groups:</p><ul><li><p>Group 0 of four DMIs (DMI0, DMI1, DMI2, DMI3)</p></li><li><p>Group 1 of 2 DMIs (DMI4 and DMI5) and</p></li><li><p>Group 2 of one DMI i.e. DMI6.</p></li></ul></li><li><p>Three groups together are referred to as Memory Interleave Group Set. Alternatively, the MIGS may be configured as follows:</p><ul><li><p>Group 0 of two DMIs (DMI0, DMI1)</p></li><li><p>Group 1 of two DMIs (DMI2, DMI3)</p></li><li><p>Group 2 of two DMIs (DMI4 and DMI5) and</p></li><li><p>Group 3 of one DMI i.e. DMI6</p></li></ul></li></ul><h2 id="AddressManagerV2-RandomizeGPRAaddressspace">Randomize GPRA address space</h2><ul><li><p>The number of GPRA regions will be given by the configuration</p></li><li><p>Address space can be between 4KB and 32TB</p></li></ul><h2 id="AddressManagerV2-RandomizeGPRAmappingtoDMIandDII">Randomize GPRA mapping to DMI and DII</h2><h2 id="AddressManagerV2-ProvideUtilityFunctionstoUsers">Provide Utility Functions to Users</h2><h1 id="AddressManagerV2-AddressSpacePriorityAccess">Address Space Priority Access</h1><ul><li><p><em>“NRS has the highest priority followed by general purpose address space and lastly boot address space. If an access matches higher priority address space, then overlapping lower priority address space matches are ignored, and the higher priority space is selected for access. Within an address space multiple address region matches are treated as errors; this specifically applies to general purpose address space. An access will result in an error if multiple address region matches are detected within a single address space or no matches are detected to any address space” - Ncore36SystArch Spec</em></p></li><li><p>TBD: Understand how to program the memory regions for the below scenarios</p><ul><li><p>Error scenario as described in the statement</p></li><li><p>Priority access scenario</p></li></ul></li></ul><h1 id="AddressManagerV2-CodeStructure">Code Structure</h1><h2 id="AddressManagerV2-chiplet_mem_info.sv">chiplet_mem_info.sv</h2><ul><li><p>This holds the individual chiplet level memory information</p></li><li><p>Example, boot regions, gpra regions, csr regions, units, etc</p></li></ul><h2 id="AddressManagerV2-mem_agent.sv">mem_agent.sv</h2><ul><li><p>This is the main address manager file which is imported and used by the users</p></li></ul><h2 id="AddressManagerV2-mem_agent_cfg.sv">mem_agent_cfg.sv</h2><h2 id="AddressManagerV2-mem_agent_pkg.sv">mem_agent_pkg.sv</h2><h1 id="AddressManagerV2-AddressManagerConfigurationObject">Address Manager Configuration Object</h1><h1 id="AddressManagerV2-CustomMemoryRegions">Custom Memory Regions</h1><h1 id="AddressManagerV2-AddressManagerUsage">Address Manager Usage</h1><h1 id="AddressManagerV2-Multi-ChipletAddressMapGenerator—RequirementsSpec">Multi-Chiplet Address Map Generator — Requirements Spec</h1><h2 id="AddressManagerV2-1)Systemoverview">1) System overview</h2><ul><li><p>The design contains <strong>N chiplets</strong> (<code>num_chiplets</code>), indexed <code>0..N-1</code>.</p></li><li><p>Each chiplet contains traffic initiators (<strong>AIUs</strong>) and local egress “slave” ports:</p><ul><li><p><strong>DMI</strong> (memory), which is partitioned into <strong>Interleaving Groups (IGs)</strong>.</p></li><li><p><strong>DII</strong> (I/O).</p></li></ul></li><li><p>Chiplets interconnect via <strong>GIU[x]</strong> blocks. A <strong>link</strong> connects <code>(from_chiplet_id, from_giu_id) → (to_chiplet_id, to_giu_id)</code>.</p><ul><li><p>Each <code>(chiplet, GIU)</code> participates in at most <strong>one physical link</strong>.</p></li><li><p>If a <strong>single</strong> directed link is listed for a GIU pair, the link is considered <strong>available in both directions</strong>.</p></li><li><p>A single physical link can carry <strong>multiple regions/hops</strong>.</p></li></ul></li><li><p>Each chiplet may have <strong>1–4 GIUs</strong>; the actual count per chiplet is <strong>deduced from the link data</strong>.</p></li></ul><h3 id="AddressManagerV2-Reachabilityexamples">Reachability examples</h3><ul><li><p>AIU on chiplet A can access A’s local <strong>DMI/DII</strong>.</p></li><li><p>AIU on A can access B’s <strong>DMI/DII</strong> remotely through GIUs if links exist.</p></li><li><p>Symmetrically for AIUs on B.</p></li></ul><hr/><h2 id="AddressManagerV2-2)Inputs(pertest/designinstance)">2) Inputs (per test / design instance)</h2><ul><li><p><code>num_chiplets</code>: total chiplets (IDs are <code>0..num_chiplets-1</code>).</p></li><li><p><strong>Connectivity</strong>: array <code>links[$]</code> of:</p><ul><li><p><code>{ from_chiplet_id, to_chiplet_id, from_giu_id, to_giu_id }</code></p></li></ul></li><li><p><strong>Per-chiplet inventory and targets</strong> (arrays indexed by chiplet ID <code>c</code>):</p><ul><li><p><code>num_gpras_per_chiplet[c]</code>: target number of regions to program on chiplet <code>c</code>.</p></li><li><p><code>num_igs_per_chiplet[c]</code>: number of DMI <strong>IGs</strong>; IG IDs are <code>0..num_igs-1</code>.</p></li><li><p><code>dii_units[c][$]</code>: each <code>{ funit_id }</code>. <code>funit_id</code> is unique <strong>within</strong> the chiplet.</p></li><li><p><code>dmi_units[c][$]</code>: each <code>{ funit_id, ig_id }</code> with <code>0 ≤ ig_id &lt; num_igs_per_chiplet[c]</code>. <code>funit_id</code> is unique within the chiplet; multiple DMIs may share an <code>ig_id</code>.</p></li></ul></li><li><p><strong>Policy knob</strong> (optional): <code>remote_probability_pct[c] ∈ [0,100]</code> per chiplet. Default is <strong>50</strong> if unspecified.</p></li></ul><hr/><h2 id="AddressManagerV2-3)Outputs">3) Outputs</h2><ul><li><p><strong>Per-chiplet address map</strong> <code>chiplet_address_spaces[c][$]</code> (vector of <code>mem_info_t</code>), where each region has:</p><ul><li><p><code>lower_addr</code> (inclusive), <code>size</code> with <code>size_log2</code> a power-of-two (4 KB..32 TB ⇒ <code>12..45</code>).</p></li><li><p><code>home_unit_type</code> (<strong>HUT</strong>, 2 bits) and <code>home_unit_identifier</code> (<strong>HUI</strong>, fixed <strong>5 bits</strong>).</p></li><li><p><code>interleave = 0</code> (interleaving ignored in this version).</p></li><li><p><code>link_id</code> (3 bits): source GIU id when <strong>remote</strong>; <code>0</code> for local.</p></li><li><p><code>order</code>, <code>mig_nunitid</code>, <code>nc</code>, <code>nsx</code>: randomized without semantic constraints.</p></li><li><p><code>target = 0</code> (unused).</p></li></ul></li><li><p><strong>Per-region ownership</strong> <code>region_owners[c][region_index][$]</code> (list of <code>{ chiplet_id, funit_id }</code>):</p><ul><li><p>Local <strong>DII</strong> region: exactly <strong>one</strong> owner (that DII on that chiplet).</p></li><li><p>Local <strong>DMI IG</strong> region: <strong>all</strong> DMIs on that chiplet in that IG are owners.</p></li><li><p><strong>Remote</strong> regions: <strong>no owners</strong> (empty list).</p></li></ul></li><li><p><strong>Per-chiplet GPRA budget (hard cap)</strong>: For each chiplet <code>c</code>, the number of regions <strong>present on that chiplet</strong> (local + remote entries) must equal <code>num_gpras_per_chiplet[c]</code>. Any region entry instantiated on chiplet <code>c</code> counts toward <code>c</code>’s budget.</p></li></ul><hr/><h2 id="AddressManagerV2-4)Addressregionrules">4) Address region rules</h2><ul><li><p>Exactly <code>num_gpras_per_chiplet[c]</code> regions are produced for chiplet <code>c</code>.</p></li><li><p>Each region’s size is a power of two, with <code>size_log2 ∈ [12,45]</code> (4 KB..32 TB).</p></li><li><p>The base address (<code>lower_addr</code>) is <strong>aligned</strong> to its size: <code>lower_addr % (1 &lt;&lt; size_log2) == 0</code>.</p></li><li><p>Regions must be <strong>non-overlapping within a chiplet</strong>.</p></li><li><p>Address space range is <strong>53 bits</strong>: <code>0 .. 2^53 - 1</code>.</p></li></ul><hr/><h2 id="AddressManagerV2-5)HUT/HUIencoding">5) HUT/HUI encoding</h2><ul><li><p><strong>Local DMI region</strong>: <code>HUT = 2'b00</code>, <code>HUI = IG id</code> (chiplet-local interpretation).</p></li><li><p><strong>Local DII region</strong>: <code>HUT = 2'b10</code>, <code>HUI = DII funit_id</code> (chiplet-local).</p></li><li><p><strong>Remote DMI region</strong>: <code>HUT = 2'b01</code>, <code>HUI = destination chiplet_id</code>.</p></li><li><p><strong>Remote DII region</strong>: <code>HUT = 2'b11</code>, <code>HUI = destination chiplet_id</code>.</p></li><li><p><strong>HUI width is fixed to 5 bits.</strong> Values larger than 31 are truncated to <code>[4:0]</code>.</p></li></ul><hr/><h2 id="AddressManagerV2-6)Localminimumrequirements">6) Local minimum requirements</h2><p>For each chiplet <code>c</code>:</p><ul><li><p>Every <strong>DII</strong> in <code>dii_units[c]</code> must own <strong>≥ 1 local</strong> region (exclusive).</p></li><li><p>Every <strong>DMI IG</strong> in <code>0..num_igs_per_chiplet[c]-1</code> must own <strong>≥ 1 local</strong> region (shared by all DMIs in that IG).</p></li><li><p>After meeting minima, optional extra locals may be created:</p><ul><li><p><strong>DII-exclusive</strong> extras (owned by one DII on that chiplet), and/or</p></li><li><p><strong>DMI IG-shared</strong> extras (owned by all DMIs in a selected IG),</p></li><li><p>subject to chiplet <code>c</code>’s <strong>GPRA budget</strong>.</p></li></ul></li></ul><hr/><h2 id="AddressManagerV2-7)Remoteplacement—mirror-or-forwardchains">7) Remote placement — mirror-or-forward chains</h2><p>If a region <strong>R</strong> with bounds <code>(lower_addr, size_log2)</code> is marked <strong>remote</strong> on chiplet <code>i</code> pointing to chiplet <code>j</code>, then the <strong>exact same bounds</strong> for <strong>R</strong> must appear on chiplet <code>j</code> either:</p><ol start="1"><li><p>as a <strong>local</strong> region of the <strong>same class</strong> (<strong>DII</strong> remains DII, <strong>DMI</strong> remains DMI), or</p></li><li><p>as <strong>remote</strong> to a <strong>different</strong> chiplet <code>k</code> (<code>k ≠ j</code>), still of the <strong>same class</strong> and bounds, eventually terminating in a <strong>local</strong> region of that class on some chiplet.</p></li></ol><p>Additional constraints:</p><ul><li><p><strong>Unit-class consistency</strong>: the class of <strong>R</strong> is preserved along the entire chain.</p><ul><li><p>If <strong>R</strong> is DII on <code>i</code> (remote), it is DII at every hop; the terminal node is a <strong>Local DII</strong> region.</p></li><li><p>If <strong>R</strong> is DMI on <code>i</code> (remote), it is DMI at every hop; the terminal node is a <strong>Local DMI IG</strong> region. The IG id is chiplet-local and need not numerically match other chiplets’ IG ids.</p></li></ul></li><li><p><strong>Acyclic per region</strong>: The chain for <strong>R</strong> forms a simple directed path that <strong>terminates</strong> in a local region. Cycles (e.g., <code>i → j → i</code>) are disallowed.</p></li><li><p><strong>Valid hop</strong>: Each remote hop <code>x → y</code> for <strong>R</strong> must correspond to a valid outgoing GIU link. <code>link_id</code> records the <strong>source GIU</strong> used at that hop.</p></li><li><p><strong>Termination guarantee</strong>: If no valid forwarding target can be found for <strong>R</strong>, the algorithm must <strong>close the chain locally</strong> at the current chiplet with a same-class local region and the exact same bounds.</p></li></ul><h3 id="AddressManagerV2-GPRAbudgetaccountingforremotes">GPRA budget accounting for remotes</h3><ul><li><p>A <strong>remote</strong> region entry <strong>counts toward the source chiplet’s budget</strong>.</p></li><li><p>A <strong>new local</strong> created on a destination to satisfy mirroring <strong>counts toward the destination’s budget</strong>.</p></li><li><p>The generator must <strong>not exceed</strong> <code>num_gpras_per_chiplet[c]</code> on any chiplet:</p><ul><li><p>If the destination already has an <strong>exact same-bounds local</strong> of the required class, <strong>reuse it</strong> (no new budget consumed).</p></li><li><p>If creating the required local on the destination would exceed its budget or overlap existing regions, the remote attempt must either:</p><ul><li><p>choose an alternate valid destination (or forward another hop) that can host the local <strong>within budget</strong>, or</p></li><li><p><strong>fall back</strong> and make <strong>R local on the source</strong> chiplet instead.</p></li></ul></li></ul></li></ul><hr/><h2 id="AddressManagerV2-8)Globalvalidityconstraints">8) Global validity constraints</h2><ul><li><p><strong>Non-overlap per chiplet</strong>.</p></li><li><p>For any region <strong>R</strong> that is remote anywhere, there exists at least <strong>one chiplet</strong> where <strong>R</strong> is <strong>local</strong>.</p></li><li><p><strong>No directed cycles per region</strong> (chains must terminate).</p></li><li><p><strong>Budgets are hard caps</strong>: no chiplet’s region count may exceed <code>num_gpras_per_chiplet[c]</code>.</p></li><li><p>No contradictory mapping: the per-region acyclic rule inherently forbids “A remote to B” and “B remote back to A” for the <strong>same region</strong>.</p></li></ul><hr/><h2 id="AddressManagerV2-9)Randomizationandreproducibility">9) Randomization and reproducibility</h2><ul><li><p>Randomized elements include:</p><ul><li><p>Region sizes, base addresses, choices of extra locals,</p></li><li><p>Remote vs local decision per remaining region,</p></li><li><p>Link selection for remote hops,</p></li><li><p>Remote class choice (DII vs DMI),</p></li><li><p>Free bits: <code>order</code>, <code>mig_nunitid</code>, <code>nc</code>, <code>nsx</code>.</p></li></ul></li><li><p>The generator can be made deterministic for replay by seeding the RNG(s) (e.g., via <code>$urandom(seed)</code> or a seed field in the config).</p></li></ul><hr/><h2 id="AddressManagerV2-10)Codestructureandgenerationflow">10) Code structure and generation flow</h2><ul><li><p><strong>Top-level singleton</strong>: <code>mem_agent extends uvm_object</code></p><ul><li><p>Holds <code>mem_agent_cfg</code> (inputs and policy).</p></li><li><p>Owns one <code>chiplet_mem_info</code> per chiplet (2 in the current hardcoded setup).</p></li><li><p>Builds connectivity from <code>links</code>.</p></li><li><p><strong>Flow in </strong><code>generate_memory_regions()</code>:</p><ol start="1"><li><p>Initialize each <code>chiplet_mem_info</code> from config.</p></li><li><p>Seed <strong>local minima</strong> per chiplet (all DIIs and all IGs).</p></li><li><p>Build connectivity from <code>links</code>.</p></li><li><p>Fill remaining regions with policy, enforcing:</p><ul><li><p>mirror-or-forward chains,</p></li><li><p>same-bounds and same-class,</p></li><li><p>valid link hops,</p></li><li><p><strong>no budget over-subscription</strong> on any chiplet (reuse exact locals where possible, else fall back to a local at the source).</p></li></ul></li><li><p>Optionally add <strong>extra IG locals</strong> if headroom remains.</p></li></ol></li><li><p>Exposes the final per-chiplet <code>regions</code> and <code>region_owners</code>.</p></li></ul></li><li><p><strong>Per-chiplet class</strong>: <code>chiplet_mem_info extends uvm_object</code></p><ul><li><p><strong>Inputs</strong>: <code>chiplet_id</code>, <code>num_gpras_target</code>, <code>num_igs</code>, <code>local_dii_units[$]</code>, <code>local_dmi_units[$]</code>.</p></li><li><p><strong>Outputs</strong>: <code>regions[$] : mem_info_t</code>, <code>region_owners[$][$] : region_owner_t</code>.</p></li><li><p><strong>Methods</strong>:</p><ul><li><p><code>seed_local_minima()</code> → one local per DII (exclusive) and per IG (shared).</p></li><li><p><code>maybe_add_extra_ig_regions()</code> → random extra IG locals within budget.</p></li><li><p><code>allocate_one_additional_local()</code> → locally adds either DII-exclusive or IG-shared.</p></li><li><p><code>choose_non_overlapping_region()</code> → selects aligned, power-of-two, non-overlapping <code>(base,size)</code>.</p></li><li><p>Utilities to check/append <strong>exact-bounds</strong> locals for mirror/forward enforcement.</p></li></ul></li></ul></li><li><p><strong>Connectivity helpers</strong> (in <code>mem_agent</code> scope):</p><ul><li><p>Build per-chiplet GIU forward edges from <code>links</code>.</p></li><li><p>Select a valid outgoing link for remote placement; a GIU participates in at most one physical link, but the link may carry multiple region hops.</p></li></ul></li></ul><hr/><h2 id="AddressManagerV2-11)Fielddefinitions(mem_info_t)">11) Field definitions (<code>mem_info_t</code>)</h2><ul><li><p><code>lower_addr[52:0]</code>, <code>upper_addr[52:0]</code>: inclusive bounds.</p></li><li><p><code>size_log2[5:0]</code>: log2 of region size in bytes; <code>12..45</code>.</p></li><li><p><code>home_unit_type[1:0]</code> (<strong>HUT</strong>) and <code>home_unit_identifier[4:0]</code> (<strong>HUI</strong>).</p><ul><li><p>Local DMI: <code>HUT=00</code>, <code>HUI=IG id</code>.</p></li><li><p>Local DII: <code>HUT=10</code>, <code>HUI=DII funit_id</code>.</p></li><li><p>Remote DMI: <code>HUT=01</code>, <code>HUI=dest chiplet id</code>.</p></li><li><p>Remote DII: <code>HUT=11</code>, <code>HUI=dest chiplet id</code>.</p></li></ul></li><li><p><code>link_id[2:0]</code>: source GIU id when remote; <code>0</code> for local.</p></li><li><p><code>interleave</code>: <code>0</code>.</p></li><li><p><code>order[3:0]</code>, <code>mig_nunitid</code>, <code>nc</code>, <code>nsx</code>: randomized.</p></li><li><p><code>target[2:0]</code>: <code>0</code>.</p></li></ul><hr/><h2 id="AddressManagerV2-12)Cornercasesandguarantees">12) Corner cases and guarantees</h2><ul><li><p>A chiplet may end up with <strong>0 remote regions</strong> — valid.</p></li><li><p>A region <strong>R</strong> may be referenced on multiple chiplets with identical bounds, forming a <strong>chain</strong> of one or more remote hops that <strong>terminates</strong> in one or more locals (fan-in allowed), as long as <strong>no cycles</strong> occur.</p></li><li><p>The inputs guarantee <code>num_gpras_per_chiplet[c]</code> is <strong>large enough</strong> to satisfy all local minima for chiplet <code>c</code>.</p></li><li><p>GIU per chiplet is deduced from links; each <code>(chiplet,GIU)</code> participates in at most one physical link.</p></li></ul><h1 id="AddressManagerV2-OldvsNewAddressManagerFunctions">Old vs New Address Manager Functions</h1><div class="table-wrap"><table data-table-width="1800" data-layout="full-width" data-local-id="a721ea98-c293-4b99-9ed4-c37a1b142251" class="confluenceTable"><colgroup><col style="width: 337.59px;"/><col style="width: 1048.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p><strong>Address Mgr Pkg Classes/files </strong></p></th><th class="confluenceTh"><p><strong>Description </strong></p></th></tr><tr><td class="confluenceTd"><p>ncore_config_info.svh</p></td><td class="confluenceTd"><p>Define types, parameters.   </p></td></tr><tr><td class="confluenceTd"><p>memregions_per_ig.svh</p></td><td class="confluenceTd"><p>Helper class for address manager to assign memory region to Ig and DII</p></td></tr><tr><td class="confluenceTd"><p>memregions_info.svh</p></td><td class="confluenceTd"><p>Helper class for address manager to randomly generate memory region. (Start and end boundaries) </p></td></tr><tr><td class="confluenceTd"><p>select_bits.svh</p></td><td class="confluenceTd"><p>It gives primary and secondary selection bit. </p></td></tr><tr><td class="confluenceTd"><p>addr_trans_mgr.svh</p></td><td class="confluenceTd"><p>This class contain functions to get meaningful address.   </p></td></tr></tbody></table></div><p>  </p><div class="table-wrap"><table data-table-width="1800" data-layout="full-width" data-local-id="0cb8da36-caa3-4c4a-913d-5a3cf612bc7b" class="confluenceTable"><colgroup><col style="width: 692.59px;"/><col style="width: 693.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p><strong>Function available in addr_trans_mgr.svh</strong></p></th><th class="confluenceTh"><p><strong>Description </strong></p></th></tr><tr><td class="confluenceTd"><p>gen_memory_map()</p></td><td class="confluenceTd"><p>generate memory map for all GPRAR </p></td></tr><tr><td class="confluenceTd"><p>set_addr_collision_pct(int funitid, bit en_funitid, int hit_pct)</p></td><td class="confluenceTd"><p>it set the collision % of address for agent = funitid</p></td></tr><tr><td class="confluenceTd"><p> get_memregion_info( input bit [addrMgrConst::W_SEC_ADDR -1:0] addr, output bit hut, output bit [4:0] hui)</p></td><td class="confluenceTd"><p>it returns HUT and HUI for a given address.</p></td></tr><tr><td class="confluenceTd"><p>get_memory_map_instance()</p></td><td class="confluenceTd"><p>it returns memory map handle.</p></td></tr><tr><td class="confluenceTd"><p>get_coh_addr(<br/>    int funitid,<br/>    bit en_funitid,<br/>    bit collision_user = 0,<br/>    int core_id=0,<br/>    int set_index= -1,<br/>    int tfilter_id=-1)</p></td><td class="confluenceTd"><p>it returns address from COH queue of agent, this function return address as per collision %. if it is new cacheline  then it returns randomly generated as per following logic and push into COH queue </p><p>if (set_index &gt;-1) {</p><p>     if (tfilter_id &gt;-1 ) { </p><p>         returns address for snoop filter = tfilter_id with index = set_index</p><p>     } else { </p><p>         returns address for core_id  with index = set_index</p><p>  }</p><p>} else {</p><p>  returns address for core id,</p></td></tr><tr><td class="confluenceTd"><p>gen_coh_addr(<br/>  int funitid,<br/>  bit en_funitid,<br/>  int target_id    = -1,<br/>  int memregion_id = -1,<br/>  int tfilter_id   = -1,<br/>  int set_index    = -1,<br/>  int core_id      =  0);</p></td><td class="confluenceTd"><p>it returns randomly generated as per following logic and push into COH queue. </p><p>if (set_index &gt;-1) {</p><p>     if (tfilter_id &gt;-1 ) { </p><p>         returns address for snoop filter = tfilter_id with index = set_index</p><p>   } else if (target_id &gt;-1 ) { </p><p>        returns address for target = target_id with index = set_index </p><p>    } else { </p><p>         returns address for core_id  with index = set_index</p><p>  }</p><p>} else {</p><p>  returns address for core id,</p></td></tr><tr><td class="confluenceTd"><p>get_iocoh_addr( int funitid, bit en_funitid, int core_id=0)</p></td><td class="confluenceTd"><p>it returns address from IOCOH queue of agent, this function return address as per collision %. if it is new cacheline  then it returns randomly generated from address region map to DII and push into IOCOH queue</p></td></tr><tr><td class="confluenceTd"><p>gen_iocoh_addr( int funitid, bit en_funitid,  int memregion_id, int core_id=0)</p></td><td class="confluenceTd"><p>it returns randomly generated from address region map to DII and push into IOCOH queue. <strong>Note:</strong> current implementation ignoring memregion_id,  </p></td></tr><tr><td class="confluenceTd"><p>get_noncohboot_addr( int funitid, bit en_funitid, int core_id=0)</p></td><td class="confluenceTd"><p>it returns address from BOOTNONCOH queue of agent, this function return address as per collision %. if it is new cacheline  then it returns randomly generated from boot region and push into BOOTNONCOH queue.</p></td></tr><tr><td class="confluenceTd"><p>gen_noncohboot_addr( int funitid, bit en_funitid, int core_id=0)</p></td><td class="confluenceTd"><p>it returns randomly generated address from boot region and push into BOOTNONCOH queue.</p></td></tr><tr><td class="confluenceTd"><p>get_cohboot_addr(int funitid, bit en_funitid, int core_id=0)</p></td><td class="confluenceTd"><p>it returns address from BOOTCOH queue of agent, this function return address as per collision %. if it is new cacheline  then it returns randomly generated from boot region and push into BOOTCOH queue</p></td></tr><tr><td class="confluenceTd"><p>gen_cohboot_addr(int funitid, bit en_funitid, int core_id=0)</p></td><td class="confluenceTd"><p> it returns randomly generated address from boot region and push into BOOTCOH queue.</p></td></tr><tr><td class="confluenceTd"><p>get_noncoh_addr(int funitid, bit en_funitid, int core_id=0)</p></td><td class="confluenceTd"><p>it returns address from NONCOH queue of agent, this function return address as per collision %. if it is new cacheline  then it returns randomly generated from nonCoh region and push into NONCOH queue.</p></td></tr><tr><td class="confluenceTd"><p>gen_noncoh_addr(int funitid, bit en_funitid, int core_id  =  0)</p></td><td class="confluenceTd"><p>it returns randomly generated address from  nonCoh region and push into NONCOH queue.</p></td></tr><tr><td class="confluenceTd"><p>get_set_index( int funitid, bit en_funitid, bit [addrMgrConst::W_SEC_ADDR -1:0] addr, int tfid = -1);</p></td><td class="confluenceTd"><p>it returns the index value.</p><p>for IOAIU : proxy cache</p><p>for DCE: snoop filter</p><p>for DMI : Smc</p></td></tr><tr><td class="confluenceTd"><p>set_addr_in_agent_mem_map( bit [addrMgrConst::W_SEC_ADDR -1:0] addr, int initiator_agentid)</p></td><td class="confluenceTd"><p>it sets the addr in m_agent_mem_map array for agent=. initiator_agentid</p><p>m_agent_mem_map  is associative array, key of array =  (((agentid &lt;&lt; addrMgrConst::W_SEC_ADDR) | addr) &gt;&gt;6)&lt;&lt;6)</p></td></tr><tr><td class="confluenceTd"><p>addr_evicted_from_agent( int funitid, bit en_funitid,<br/>    bit [addrMgrConst::W_SEC_ADDR - 1 : 0] addr)</p></td><td class="confluenceTd"><p>it removes the addr from m_agent_mem_map array for agent=. agentid</p><p>m_agent_mem_map  is associative array, key of array =  (((agentid &lt;&lt; addrMgrConst::W_SEC_ADDR) | addr) &gt;&gt;6)&lt;&lt;6)</p></td></tr><tr><td class="confluenceTd"><p>get_addr_target_unit(bit [addrMgrConst::W_SEC_ADDR -1:0] addr)</p></td><td class="confluenceTd"><p>it returns HUT (DMI/DII) this address is mapped.</p></td></tr><tr><td class="confluenceTd"><p> set_dce_sf_fix_index_in_user_addrq(int agentid,</p><p> ref addrMgrConst::addrq maddrq, output int csrq_idx)</p></td><td class="confluenceTd"><p>this function used to generate fixed set_index addr queue for snoop filter to create evict scenario.  <strong>Note</strong>: it only use primary bits for index , so need to update for Ncore3.6 </p></td></tr><tr><td class="confluenceTd"><p>set_dmi_smc_fix_index_in_user_addrq(int agentid,</p><p> ref addrMgrConst::addrq maddrq, input bit c_nc)</p></td><td class="confluenceTd"><p>this function used to generate fixed set_index addr queue for DMI Smc  to create evict scenario.  <strong>Note</strong>: it only use primary bits for index , so need to update for Ncore3.6 </p></td></tr><tr><td class="confluenceTd"><p>get_mem_region_bounds( int mid,<br/>    output [addrMgrConst::W_SEC_ADDR -1:0] lb,<br/>    output [addrMgrConst::W_SEC_ADDR -1:0] ub)</p></td><td class="confluenceTd"><p> lower bound and upper bound of address region id =mid</p></td></tr><tr><td class="confluenceTd"><p>get_dmi_unit_addr_range( output<br/>  bit [addrMgrConst::W_SEC_ADDR - 1 : 0] low_addr_dmi0,<br/>  bit [addrMgrConst::W_SEC_ADDR - 1 : 0] upp_addr_dmi0,<br/>  bit [addrMgrConst::W_SEC_ADDR - 1 : 0] low_addr_dmi1,<br/>  bit [addrMgrConst::W_SEC_ADDR - 1 : 0] upp_addr_dmi1<br/>  );</p></td><td class="confluenceTd"><p>it returns lower and upper address range for dmi0 and dmi1 </p></td></tr><tr><td class="confluenceTd"><p>get_user_coh_addr( int funitid, int idx)</p></td><td class="confluenceTd"><p>it returns address from user_addrq as per index=idx, call gen_user_coh_addr() to fill user_addrq before calling this function, if this queue is empty then it will return error  </p></td></tr><tr><td class="confluenceTd"><p>gen_user_coh_addr(int funitid, int _size, ref addrMgrConst::addrq maddrq)</p></td><td class="confluenceTd"><p>it will fill user-maintained queue up to size = _size by randomly generated address from COH memory region </p></td></tr><tr><td class="confluenceTd"><p>get_user_noncoh_addr(int funitid, int idx)</p></td><td class="confluenceTd"><p>it returns address from user_addrq as per index=idx, call gen_user_noncoh_addr() to fill user_addrq before calling this function, if this queue is empty then it will return error  </p></td></tr><tr><td class="confluenceTd"><p>gen_user_noncoh_addr(int funitid, int _size, ref addrMgrConst::addrq maddrq)</p></td><td class="confluenceTd"><p>it will fill user-maintained queue up to size = _size by randomly generated address from NONCOH memory region </p></td></tr><tr><td class="confluenceTd"><p>alter_tag_bits(int funitid, bit en_funitid,<br/>    bit [addrMgrConst::W_SEC_ADDR -1:0] addr,<br/>    int tfid = -1)</p></td><td class="confluenceTd"><p>it will extract the set_index information from given address and given tfid  and return the new random address with this set_index.</p></td></tr><tr><td class="confluenceTd"><p>set_sf_addr_in_user_addrq(int agentid, int _nSets, int _nWays, ref addrMgrConst::addrq maddrq)</p></td><td class="confluenceTd"><p>Fill user_addrq with addresses that fall in the range of a particular SnoopFilter,specify which DCE unit's SnoopFilter, and how many ways/how many sets to fill</p></td></tr><tr><td class="confluenceTd"><p /></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>gen_noncoh_addr_in_user_addrq( int num_addr, ref addrMgrConst::addrq maddrq)</p></td><td class="confluenceTd"><p>it randomly generates address from NONCOH and fill in maddrq,</p><p>size of queue = num_addr </p></td></tr><tr><td class="confluenceTd"><p>gen_seq_dmi_addr_in_user_addrq(int num_addr, int offset, int intrlv_grp, ref addrMgrConst::addrq maddrq)</p></td><td class="confluenceTd"><p>this method used in performance testing.</p></td></tr><tr><td class="confluenceTd"><p>gen_seq_write_addr_in_user_addrq(int num_addr, int addr_step, int intrlv_grp1, int intrlv_grp2, ref addrMgrConst::addrq maddrq)</p></td><td class="confluenceTd"><p>this method used in performance testing. </p></td></tr><tr><td class="confluenceTd"><p>gen_seq_addr_w_offset_in_user_addrq(int num_addr, int addr_step, int offset, int intrlv_grp, ref addrMgrConst::addrq maddrq)</p></td><td class="confluenceTd"><p>this method used in performance testing.</p></td></tr><tr><td class="confluenceTd"><p>gen_seq_addr_in_user_write_read_addrq(int num_addr, int addr_step, int intrlv_grp, ref addrMgrConst::addrq write_addrq, ref addrMgrConst::addrq read_addrq)</p></td><td class="confluenceTd"><p>this method used in performance testing. </p></td></tr><tr><td class="confluenceTd"><p>gen_seq_dmi_addr_in_user_write_read_addrq(int num_addr, int offset, int intrlv_grp, ref addrMgrConst::addrq write_addrq, ref addrMgrConst::addrq read_addrq)</p></td><td class="confluenceTd"><p>this method used in performance testing. </p></td></tr><tr><td class="confluenceTd"><p>gen_intrlvgrp_addr(int intrlv_grp, int mem_idx=-1)</p></td><td class="confluenceTd"><p>it returns randomly Generette address from interleave group if mem_idx = -1, otherwise it returns address from mem region idx= mem_idx</p></td></tr><tr><td class="confluenceTd"><p>check_unmapped_add(bit [addrMgrConst::ADDR_WIDTH - 1 : 0] addr, int agent_id, output bit [2:0] unit_unconnected)</p></td><td class="confluenceTd"><p>it returns connectivity status of a address for agent_idx  as below</p><p> if(no_address_hit)<br/>        unit_unconnected = 'b000;<br/> else if(multiple_address_hit)<br/>        unit_unconnected = 'b001;<br/> else if ($test$plusargs(&quot;unsupported_atomic_txn_to_dii&quot;)) begin<br/>        unit_unconnected = 'b011;<br/>        check_unmapped_add = 1;<br/> end else if(dmi_unconnected)<br/>        unit_unconnected = 'b100;<br/> else if(dii_unconnected)<br/>        unit_unconnected = 'b101;<br/> else if(dce_unconnected)<br/>        unit_unconnected = 'b110;<br/> else<br/>        unit_unconnected = 'b111;</p><p /></td></tr><tr><td class="confluenceTd"><p>check_aiu_is_unconnected(int tgt_unit_id, int src_unit_id)</p></td><td class="confluenceTd"><p>it checks AIU → AIU/DCE connectivity. </p></td></tr><tr><td class="confluenceTd"><p>gen_seq_addr_in_user_addrq(int num_addr, int addr_step, int intrlv_grp, int dmi_idx, ref addrMgrConst::addrq maddrq, input bit ioaiu_pick_random = 0, input bit ioaiu_coherent = 0, input int nbr_alternate[0:1]='{0,0}, input int size_alternate[0:1]='{0,0})</p></td><td class="confluenceTd"><p>this method used in performance testing. </p></td></tr></tbody></table></div><p />