<p>In an ideal situation a transaction entring Symphony will exit at the target unmodified, however, there are many cases explained below which may modify the transaction either based user configuration or for the transaction to make forward progress. Symphony will do its best to not modify a non-modifiable transaction and will only do so if the transaction cannot make any forward progress. Below defines a modifiable transaction:</p><h3 id="id-2.2-TransactionHandling-ModifiableTransaction">Modifiable Transaction</h3><p>If a transaction is modifiable Symphony can modify the transaction.</p><ul><li>Non-modifiable transactions will not be split. Symphony would be configured to support the largest non-modifiable request possible. It should not cross a striping boundary and/or any boundary limitation at the target.</li><li>The following cannot change in a non-modifiable transaction:<ul><li>Address</li><li>Burst Size (Unless Unavoidable) /Length (Unless Unavoidable) /Type</li><li>Ordering ID, Channel ID, Ordering Model</li><li>Request Prot</li></ul></li><li>Unavoidable conditions may occur and transactions may need to be modified to make forward progress. e.g. Narrower/Wider interface. Burst Size Support. Narrow Support.</li></ul><h3 id="id-2.2-TransactionHandling-Splitting">Splitting</h3><p>A transaction can be split for the following reasons:</p><ul><li>Below mismatches (Burst Type, Narrow, Width)</li><li>Transaction crosses boundary at the initiator or target.</li><li>The transaction is larger than the max burst size of the initiator or the target. </li></ul><p>The order of the splitting follows downward from the start of the list. For example, if a transaction is split into multiple increments because of an unsupported wrap at the target, it can also then be split further if any of those increments crosses a boundary at the target, and then further if any of the resulting increments are larger than the max burst size.</p><p>Splitting causes a transaction to a specific target to be split into multiple transactions to that target. When splitting it is possible for a slave to see modified address and length fields.</p><p>Burst Type Mismatch</p><div>If the target does not support a specific type of burst the transaction will need to be modified.</div><div><ul><li>Fixed - If the target does not support fixed the transaction will be split into single beat transactions. </li><li>Increment - If the target does not support increment then the transaction must be split into single beat transactions.</li><li>Wrap - If the target does not support wrap the initiator will split the transaction into two increments<ul><li>The first is from the transaction address to the upper boundary.</li><li>The second is from the lower boundary to the starting address.</li><li>Both of these transactions can be further split if any other mismatches occur. <br/><br/></li></ul></li></ul></div><div><h3 id="id-2.2-TransactionHandling-NarrowSupportedMismatch">Narrow Supported Mismatch</h3><div>If the slave doesn't support narrows, a transaction will be split up into multiple incremental transactions that fully represent the narrow transaction. The response will be properly accumulated inside Symphony and sent back as a narrow response to the master.</div><div>This splitting will only occur if the master transaction will result in a narrow transaction at the target, </div></div><div><h3 id="id-2.2-TransactionHandling-WidthMismatch">Width Mismatch</h3></div><h4 id="id-2.2-TransactionHandling-TransactionEquivalence">Transaction Equivalence</h4><p>If there is a width mismatch the transaction on either end has to be an equivalent transaction when converting one width to another.</p><p>The points below define an equivalent transaction:</p><ul><li>When converting from one width to another no extra bytes can be read or written as this can cause unwanted behavior to device memory. </li><li>When converting from one width to another the transaction data must stay in the same byte lanes respective to the base address of a beat.</li><li>Non-modifiable transactions can be changed if unavoidable and the transaction cannot be made equivalent in any other way.</li></ul><p>e.g. These two transactions are equivalent:</p><div class="table-wrap"><table class="confluenceTable"><thead><tr><th colspan="1" class="confluenceTh"><div class="tablesorter-header-inner">Offset:</div></th><th class="confluenceTh"><div class="tablesorter-header-inner">0x30</div></th><th class="confluenceTh"><div class="tablesorter-header-inner">0x20</div></th><th colspan="1" class="confluenceTh"><div class="tablesorter-header-inner">0x10</div></th><th colspan="1" class="confluenceTh"><div class="tablesorter-header-inner">0x00</div></th><th colspan="1" class="confluenceTh"><div class="tablesorter-header-inner">Address</div></th></tr></thead><tbody><tr><td colspan="1" class="confluenceTd">Beat 0</td><td data-highlight-colour="blue" style="text-align: center;" class="highlight-blue confluenceTd">X</td><td style="text-align: center;" class="confluenceTd"> </td><td colspan="1" style="text-align: center;" class="confluenceTd"> </td><td colspan="1" style="text-align: center;" class="confluenceTd"> </td><td colspan="1" class="confluenceTd">0x100</td></tr><tr><td colspan="1" class="confluenceTd">Beat 1</td><td style="text-align: center;" class="confluenceTd"> </td><td data-highlight-colour="blue" style="text-align: center;" class="highlight-blue confluenceTd">X</td><td colspan="1" data-highlight-colour="blue" style="text-align: center;" class="highlight-blue confluenceTd">X</td><td colspan="1" data-highlight-colour="blue" style="text-align: center;" class="highlight-blue confluenceTd">X</td><td colspan="1" class="confluenceTd">0x140</td></tr></tbody></table></div><div class="table-wrap"><table class="confluenceTable"><thead><tr><th class="confluenceTh"><div class="tablesorter-header-inner">Offset:</div></th><th class="confluenceTh"><div class="tablesorter-header-inner">0x10</div></th><th class="confluenceTh"><div class="tablesorter-header-inner">0x00</div></th><th class="confluenceTh"><div class="tablesorter-header-inner"> </div></th></tr></thead><tbody><tr><td class="confluenceTd">Beat 0</td><td data-highlight-colour="blue" style="text-align: center;" class="highlight-blue confluenceTd">X</td><td style="text-align: center;" class="confluenceTd"> </td><td class="confluenceTd">0x120</td></tr><tr><td class="confluenceTd">Beat 1</td><td data-highlight-colour="blue" style="text-align: center;" class="highlight-blue confluenceTd">X</td><td data-highlight-colour="blue" style="text-align: center;" class="highlight-blue confluenceTd">X</td><td class="confluenceTd">0x140</td></tr><tr><td class="confluenceTd">Beat 2</td><td style="text-align: center;" class="confluenceTd"> </td><td data-highlight-colour="blue" style="text-align: center;" class="highlight-blue confluenceTd">X</td><td class="confluenceTd">0x160</td></tr></tbody></table></div><h4 id="id-2.2-TransactionHandling-NarrowEquivalence">Narrow Equivalence</h4><ul><li>For narrow transactions, the above must be true.</li><li>In addition, the size of each access must also be the same unless unavoidable.<ul><li>For example, if the narrow transaction at the initiator has a burst size greater than the width of the target.</li><li>The burst size must be modified to the target width.</li></ul></li></ul><p>e.g. These two narrow transactions are equivalent:</p><div class="table-wrap"><table class="confluenceTable"><thead><tr><th colspan="1" class="confluenceTh"><div class="tablesorter-header-inner">Offset:</div></th><th class="confluenceTh"><div class="tablesorter-header-inner">0x30</div></th><th class="confluenceTh"><div class="tablesorter-header-inner">0x20</div></th><th colspan="1" class="confluenceTh"><div class="tablesorter-header-inner">0x10</div></th><th colspan="1" class="confluenceTh"><div class="tablesorter-header-inner">0x00</div></th><th colspan="1" class="confluenceTh"><div class="tablesorter-header-inner">Address</div></th></tr></thead><tbody><tr><td colspan="1" class="confluenceTd">Beat 0</td><td data-highlight-colour="blue" style="text-align: center;" class="highlight-blue confluenceTd">X</td><td style="text-align: center;" class="confluenceTd"> </td><td colspan="1" style="text-align: center;" class="confluenceTd"> </td><td colspan="1" style="text-align: center;" class="confluenceTd"> </td><td colspan="1" class="confluenceTd">0x100</td></tr><tr><td colspan="1" class="confluenceTd">Beat 1</td><td style="text-align: center;" class="confluenceTd"> </td><td style="text-align: center;" class="confluenceTd"> </td><td colspan="1" style="text-align: center;" class="confluenceTd"> </td><td colspan="1" data-highlight-colour="blue" style="text-align: center;" class="highlight-blue confluenceTd">X</td><td colspan="1" class="confluenceTd">0x140</td></tr><tr><td colspan="1" class="confluenceTd">Beat 2</td><td colspan="1" class="confluenceTd"> </td><td colspan="1" style="text-align: center;" class="confluenceTd"> </td><td colspan="1" data-highlight-colour="blue" style="text-align: center;" class="highlight-blue confluenceTd">X</td><td colspan="1" class="confluenceTd"> </td><td colspan="1" class="confluenceTd">0x140</td></tr><tr><td colspan="1" class="confluenceTd">Beat 3</td><td colspan="1" class="confluenceTd"> </td><td colspan="1" data-highlight-colour="blue" style="text-align: center;" class="highlight-blue confluenceTd">X</td><td colspan="1" style="text-align: center;" class="confluenceTd"> </td><td colspan="1" class="confluenceTd"> </td><td colspan="1" class="confluenceTd">0x140</td></tr></tbody></table></div><div class="table-wrap"><table class="confluenceTable"><thead><tr><th class="confluenceTh"><div class="tablesorter-header-inner">Offset:</div></th><th class="confluenceTh"><div class="tablesorter-header-inner">0x10</div></th><th class="confluenceTh"><div class="tablesorter-header-inner">0x00</div></th><th class="confluenceTh"><div class="tablesorter-header-inner"> </div></th></tr></thead><tbody><tr><td class="confluenceTd">Beat 0</td><td data-highlight-colour="blue" style="text-align: center;" class="highlight-blue confluenceTd">X</td><td style="text-align: center;" class="confluenceTd"> </td><td class="confluenceTd">0x120</td></tr><tr><td class="confluenceTd">Beat 1</td><td style="text-align: center;" class="confluenceTd"> </td><td data-highlight-colour="blue" style="text-align: center;" class="highlight-blue confluenceTd">X</td><td class="confluenceTd">0x140</td></tr><tr><td class="confluenceTd">Beat 2</td><td data-highlight-colour="blue" style="text-align: center;" class="highlight-blue confluenceTd"> X</td><td style="text-align: center;" class="confluenceTd"> </td><td class="confluenceTd">0x140</td></tr><tr><td colspan="1" class="confluenceTd">Beat 3</td><td colspan="1" style="text-align: center;" class="confluenceTd"> </td><td colspan="1" data-highlight-colour="blue" style="text-align: center;" class="highlight-blue confluenceTd">X</td><td colspan="1" class="confluenceTd">0x160</td></tr></tbody></table></div><h4 id="id-2.2-TransactionHandling-ConversionCharacteristics">Conversion Characteristics</h4><div class="table-wrap"><table class="confluenceTable"><thead><tr><th class="highlight-grey confluenceTh" colspan="4" data-highlight-colour="grey">Target Width Related to Initiator</th></tr></thead><thead><tr><th class="highlight-grey confluenceTh" data-highlight-colour="grey"> </th><th class="highlight-grey confluenceTh" colspan="4" data-highlight-colour="grey">Target Width Related to Initiator</th></tr></thead><tbody><tr><td class="highlight-grey confluenceTd" data-highlight-colour="grey"><strong>From Initiator</strong></td><td class="highlight-grey confluenceTd" data-highlight-colour="grey"><strong>Same</strong></td><td class="highlight-grey confluenceTd" data-highlight-colour="grey"><strong>Wide</strong></td><td class="highlight-grey confluenceTd" data-highlight-colour="grey"><strong>Narrow</strong></td><td class="highlight-grey confluenceTd" data-highlight-colour="grey"><strong>No/Limited</strong></td></tr><tr><td class="highlight-grey confluenceTd" data-highlight-colour="grey"><strong>Incr</strong></td><td class="confluenceTd">Unchanged</td><td class="confluenceTd"><ol><li>Use the same start address.</li><li>Modify burstSize to match wide bus/</li><li>Modify len to account for burst length changes.</li><li>For Writes, Place incoming data beats into proper alignment on the data bus. This will involve possible rotation of the data from SMI. Place BE=0 if extra padding needs to be used.</li><li>For Reads, Align data to the initiator so that the critical byte will be received first. This will involve possible rotation of the data from the response channel.</li></ol></td><td class="confluenceTd"><ol><li>Use same start address.</li><li>Modify burstSize to match narrow bus.</li><li>Modify len to account for burst length changes.</li><li>For writes, data beats may have to be dropped to get data into the proper alignment.</li><li>For reads, padding may have to be added to the response to get the proper data alignment.</li></ol></td><td class="confluenceTd"> </td></tr><tr><td class="highlight-grey confluenceTd" data-highlight-colour="grey"><strong>Incr - Unaligned</strong></td><td class="confluenceTd">Unchanged</td><td class="confluenceTd">Same as Above</td><td class="confluenceTd">Same as Above</td><td class="confluenceTd"> </td></tr><tr><td class="highlight-grey confluenceTd" data-highlight-colour="grey"><strong>Incr - Narrow</strong></td><td class="confluenceTd">Unchanged</td><td class="confluenceTd"><ol><li>Use the same start address.</li><li>Target will leave burstSize unmodified.</li><li>Target will leave len unmodified.</li><li>For writes, the target will receive packeted data. The target must unpack and align the data same as above.</li><li>For reads, the target must pack the data and align it properly like above.</li></ol></td><td class="confluenceTd"><p>if (burstSize &lt;= narrow) slave :</p><ol><li>Use the same address.</li><li>Target will leave burstSize unchanged.</li><li>Target will leave len unchanged.</li><li>For writes, the target will receive packed data. The target must unpack and align the data same as above.</li><li>For reads, the target must pack the data and align it properly like above.</li></ol><p>else (burstSize &gt;  narrow slave):</p><ol><li>Use same start address.</li><li>Modify burstSize to match narrow bus.</li><li>Modify len to account for burst length changes.</li><li>For writes, data beats may have to be dropped to get data into the proper alignment.</li><li>For reads, padding may have to be added to the response to get the proper data alignment.</li></ol></td><td class="confluenceTd">Split into multiple Incr bursts with len = 1 beat</td></tr><tr><td class="highlight-grey confluenceTd" data-highlight-colour="grey"><strong>Fixed</strong></td><td class="confluenceTd">Unchanged</td><td class="confluenceTd">1.use same start address (fixed narrow burst)<br/>2. Number of beats at target same as at initiator<br/>3. write converted into fixed narrow, with extra BE=0 for extra bytes (if unaligned)<br/>4. read converted into fixed narrow, with read response data for extra bytes (initiator sized beats) have BE=0 (to be dropped in width adapter)</td><td class="confluenceTd">1. use same start address<br/>2. At initiator FIXED beat is converted into INCR burst of 1 (then handled like INCR burst at target), so split into #burst_len requests.<br/>3. At target, the INCR burst of len=1, is adjusted for the width changes and sets burst length N (N =target/initiator width)<br/>4. Responses are merged at Initiator as for any request slitting.</td><td class="confluenceTd"> </td></tr><tr><td class="highlight-grey confluenceTd" data-highlight-colour="grey"><strong>Fixed - Unaligned</strong></td><td class="confluenceTd">Unchanged</td><td class="confluenceTd">same as above and INCR narrow, but fixed position (unlike INCR) for the valid bytes in each beat.</td><td class="confluenceTd">Same as Above</td><td class="confluenceTd"> </td></tr><tr><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey"><strong>Fixed - Narrow</strong></td><td colspan="1" class="confluenceTd">Unchanged</td><td colspan="1" class="confluenceTd">Same as Above</td><td colspan="1" class="confluenceTd">if burst size &lt;= target width:<br/>same handling like that for fixed-narrow from narrow initiator, except that the initiator is wider and hence read response beats have to be padded with dummy beats to pack the response data for initiator width<br/><br/>Else:<br/>Same handling as for full FIXED burst to narrow target</td><td colspan="1" class="confluenceTd"> </td></tr><tr><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey"><strong>Wrap</strong></td><td colspan="1" class="confluenceTd">Unchanged</td><td colspan="1" class="confluenceTd">1. same start address (if aligned to target size), otherwise different address (target burst size ligned)<br/>2. number of beats adjusted for target width = burst length/N (N =target/initiator width)<br/>3. For writes, target need to hold the wide beat (for target alignment) and selects the bytes from held bytes and incoming beat for every outgoing beat to the slave.<br/>4. For reads, need extra context and storage at target for identifying given WRAP read response, and holding a response data beat (# number of WRAP outstanding read supported), to map/accumulate to the wider response data beat to map to initiator offset/size alignment (will be demuxed by data width adapter to N narrow beats to initiator).</td><td colspan="1" class="confluenceTd">1. same start address, aligned access but not a narrow burst.<br/>2. number of beats adjusted for the narrow target (xN, N=initiator/target width).</td><td colspan="1" class="confluenceTd"> </td></tr><tr><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey"><strong>Wrap - Unaligned</strong></td><td colspan="1" class="confluenceTd">Unchanged</td><td colspan="1" class="confluenceTd">1. same like WRAP-narrow to same width target, except that the valid data narrow beat has to be mapped to/from initiator wide (full) beat.<br/>2. same start address at target<br/>3. same number of beats at target<br/>4. For writes, extra thing is to extract the valid bytes based on valid narrow burst position in the intitiatot wide beat, and then N (N = initiator/target width) write data beats per single wide data beat at target.<br/>4. For reads, the response data beats are accumulated o correctly map the N valid narrow burst data from the wide interface into the accumulated wide response data beat (to be split into N beats by width adapter).</td><td colspan="1" class="confluenceTd">a) burst size &lt;= slave width:<br/> Same as above, except for -<br/>Writes: discard the beats with no valid data (1 valid beat per N beats). Reads: add dummy beats to align the valid narrow data bytes to initiator width (N-1 dummy beats per 1 response data beat).<br/>b) burst size &gt; slave width:<br/>Split into burst length# INCR burst of 1 </td><td colspan="1" class="confluenceTd"> </td></tr><tr><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey"><strong>Wrap - Narrow</strong></td><td colspan="1" class="confluenceTd">Unchanged</td><td colspan="1" class="confluenceTd"> </td><td colspan="1" class="confluenceTd"> </td><td colspan="1" class="confluenceTd">Split into multiple Incr bursts with len = 1 beat</td></tr></tbody></table></div>