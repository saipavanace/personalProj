<h1 id="HW-SYMExclusiveMonitorPlan-ProtocolsoutsideofAPB/AXI">Protocols outside of APB/AXI</h1><p>We aren't going to do anything that will preclude us from supporting AHB and OCP in the future, but AHB isn't until R2, and OCP isn't until R3 or later, so at this time we are not considering them.</p><h1 id="HW-SYMExclusiveMonitorPlan-RTLbehavior">RTL behavior</h1><h2 id="HW-SYMExclusiveMonitorPlan-ExclusiveMonitor:">Exclusive Monitor:</h2><p>The exclusive monitor will only record 3 things from the read: address, size and ID.</p><p>The ID is actually a concatenation of the ATUI node ID and and uncompressed ID from the native Interface.</p><p>If those three things match the exclusive write, the exclusive monitor returns Ex OK if no intervening write has overlapped the region.</p><h2 id="HW-SYMExclusiveMonitorPlan-ATUs:">ATUs:</h2><p>The ATUs, initiator and target, will return a slave error if they split a transaction that is marked exclusive.</p><h1 id="HW-SYMExclusiveMonitorPlan-Verification">Verification</h1><h2 id="HW-SYMExclusiveMonitorPlan-SymphonyR1:">Symphony R1:</h2><p>The irritators will only send exclusive reads and writes that match on all control signals, that are aligned, have sizes of 1,2,4,8,16,32,64,128 bytes and don't split with the intent to get an Ex OK and verify. They will verify that for a read/write pair that can return an Ex OK, that if a write the occurs between the exclusive read and write overlaps the space, Ex OK is not returned, but an OK. The splitting rules to be followed are documented below.</p><p>The irritators will send exclusive reads and writes that don't match on all AXI fields, are unaligned, have strange sizes and verify that they don't deadlock the system but won't predict if the transaction gets an Ex OK or slave error.</p><p>Rules that must be followed to avoid splitting in an exclusive:</p><ol><li>There are certainty conditions when an exclusive transaction would split and always fail thus should be avoided. This can be determined by the target characteristics:<ol><li><strong>You cannot send a narrow WRAP exclusive transaction to a target that doesn't support narrows.</strong><ol><li>if((math.pow(2,axi_txn.axsize) &lt;  (ATUI.wData/8)) &amp;&amp; (ATUT.narrowSupported == false) &amp;&amp; axi_txn.axburst == WRAP) then exclusive will always fail</li></ol></li><li><strong>You cannot send a WRAP exclusive transaction to a target that doesn't support WRAPS.</strong><ol><li>if((axi_txn.axburst == WRAP) &amp;&amp; [ !ATUT.wrapSupported , ATUT.pamTargSplitWrap[targId] ]) then exclusive will always fail (Either option in the brackets can be used depending on if viewing from an ATUT, or ATUI PAM perspective.)</li></ol></li><li><strong>You cannot send a FIXED exclusive transaction to a target that doesn't support FIXED unless its a single beat.</strong><ol><li>if((axi_txn.axburst == FIXED) &amp;&amp; (axi_txn.axlen != 0) &amp;&amp; (ATUT.fixedSupported == false)) then exclusive will always fail</li></ol></li><li><strong>You cannot send a FIXED exclusive transaction to a target with a differant data width. </strong><ol><li>if((axi_txn.axburst == FIXED) &amp;&amp; (ATUI.wData != ATUT.wData) &amp;&amp; (axi_txn.axlen != 0)) then exclusive will always fail</li></ol></li><li><strong>You cannot send a exclusive larger than maxPduSize of the initiator or target.</strong><ol><li>axi_txn_size == (axi_txn.axlen + 1) * math.pow(2,axi_txn.axsize)</li><li>if((axi_txn_size &gt; ATUI.maxPduSz) || (axi_txn_size &gt; ATUT.maxPduSz)) then exclusive will always fail</li></ol></li></ol></li><li>Event with all above limitations splits can still happen at Target NL which needs to handle by AXI Slave with excursive support. These fall under:<ol><li>if INCR, init axi_txn_size &lt;= (ATUT.wData/8) * 256</li><li>if FIXED, init axi_txn_size &lt;= (ATUT.wData/8) * 16</li><li>if WRAP, init axi_txn_size &lt;= (ATUT.wData/8) * 16</li><li>if to APB, init txn_size &lt;= (ATUT.wData/8)</li></ol></li></ol><p style="text-align: left;">where axi_txn_size = (axi_txn.axlen + 1) * math.pow(2,axi_txn.axsize)</p><h1 id="HW-SYMExclusiveMonitorPlan-VerificationBeyondSymphonyR1">Verification Beyond Symphony R1</h1><p>Should it be determined that it is necessary to predict the behavior of Ex OK in the &quot;implementation defined&quot; space, RTL designers will provide DV with a set of rules that predict when Ex OK is returned or not returned.</p><h1 id="HW-SYMExclusiveMonitorPlan-Wheredotheaddress,sizeandIDcomefrom?">Where do the address, size and ID come from?</h1><p><span style="text-decoration: none;" class="legacy-color-text-default">The ID stored in the monitor is the concatenation of the source node ID and ID field. The ID field is different from the order ID field. It is an noncompressed form of the ID from the native protocol and Its purpose is for the exclusive monitor in the AXI use case, and for debug. As such, it can be formed from a concatenation of any number of fields from the native layer.</span></p><p>The address stored in the monitor is the address in the packet. The address bits used are a function of the length store in the packet.</p><p>The size stored is the length stored in the packet.</p>