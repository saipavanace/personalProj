<h1 id="OBSOLETE-DELETEHW-SYMsym_fifo_rate_mem_1p_ctl-module_name"><strong>module_name</strong></h1><p>sym_fifo_rate_mem_1p_ctl</p><h1 id="OBSOLETE-DELETEHW-SYMsym_fifo_rate_mem_1p_ctl-parameters"><strong>parameters</strong></h1><h2 id="OBSOLETE-DELETEHW-SYMsym_fifo_rate_mem_1p_ctl-java_script:"><strong>java_script:</strong></h2><pre class="page view">{
	&quot;width&quot; : any positive integer <br/>        &quot;depth&quot; : any positive integer 4 or greater <br/>        &quot;ratio&quot; : [I,J], // I is the number of in valid beats per J beats on the output, Specifies ratio of beats.<br/>        &quot;protectionStyle&quot; : protectionStyle, <br/>        &quot;protectionInterface&quot; : protectionInterface</pre><pre>}</pre><h2 id="OBSOLETE-DELETEHW-SYMsym_fifo_rate_mem_1p_ctl-verilog:"><strong>verilog:</strong></h2><p style="margin-left: 30.0px;">none.</p><h1 id="OBSOLETE-DELETEHW-SYMsym_fifo_rate_mem_1p_ctl-I/O"><strong>I/O</strong></h1><p>u.port('input', 'in_valid', 1);<br/>u.port('input', 'in_first', 1);<br/>u.port('input', 'in_last', 1);<br/>u.port('output', 'in_ready', 1);<br/>u.port('output', 'out_valid', 1);<br/>u.port('input', 'out_ready', 1);</p><p>// Ports to read buffer<br/>// A rdy_vld_pipe, depth = 2, pF = false, pB = true, exposeValids = true<br/>u.port('input', 'pipe_out_valid', 1);<br/>u.port('output', 'pipe_out_ready', 1);<br/>u.port('output', 'pipe_in_valid', 1);<br/>u.port('input', 'pipe_in_ready', 1);<br/>u.port('input', 'pipe_in_first', 1);<br/>u.port('input', 'pipe_in_last', 1);</p><p>// Ports to SRAM<br/>u.port('output', 'sel', 1);<br/>u.port('output', 'addr', addr_width);<br/>u.port('output', 'we', 1);</p><p>// Ports to data mux<br/>u.port('output', 'empty', 1);</p><p>u.interface(protectionInterface.name, 'master', protectionInterface.signal);</p><h1 id="OBSOLETE-DELETEHW-SYMsym_fifo_rate_mem_1p_ctl-ModulesUsed"><strong>Modules Used</strong></h1><p><a class="external-link" href="https://confluence.arteris.com/display/ENGR/prot_reg" rel="nofollow">prot_reg</a></p><p><a class="external-link" href="https://confluence.arteris.com/display/ENGR/logic_tree" rel="nofollow">logic_tree</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16167580/logic_tree_bus" data-linked-resource-id="16167580" data-linked-resource-version="11" data-linked-resource-type="page">logic_tree_bus</a></p><h1 id="OBSOLETE-DELETEHW-SYMsym_fifo_rate_mem_1p_ctl-Description"><strong>Description</strong></h1><p>The control logic to turn a single read/write port SRAM into a FIFO based rate adapter using ready and valids. The block diagram of the <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156690/OBSOLETE-DELETE+HW-SYM+sym_fifo_rate_mem_1p" data-linked-resource-id="16156690" data-linked-resource-version="7" data-linked-resource-type="page">OBSOLETE-DELETE HW-SYM sym_fifo_rate_mem_1p</a> where this block is used is shown below:</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16156921/sym_fifo_rate_mem_1p_ctl.svg?api=v2"></span></p><p><strong>ratio: </strong>I represents the number of valid beats per J beats on the output. So, if a packet is coming into the block with a valid every other beat, which can happen from a data width adapter, then I = 1 and J = 2. Another way of saying this is the in side has a bubble every other cycle. If the in side has a bubble once ever three cycles, then I = 2 and J = 3. If the in side had two bubbles every 5 cycles, then I = 3 and J = 5.</p><p>The purpose of rate control is to only allow the FIFO to start unloading if the loading of the FIFO will cause no bubbles in a packet on the out side. It does this by calculating an offset from the present write pointer when a packet starts that the FIFO will have to reach when loading a packet of depth beats such that it can start to unload and not cause bubbles on the output. If the packet ends before reaching the offset, the packet is started on the output.</p><p>The microarchitecture of the block is based off of the <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16171445/OBSOLETE-DELETE+HW-SYM+sym_fifo_rate_mem_2p_ctl" data-linked-resource-id="16171445" data-linked-resource-version="12" data-linked-resource-type="page">OBSOLETE-DELETE HW-SYM sym_fifo_rate_mem_2p_ctl</a>. A filter is added to the logic that allows only one operation based on what happened on the previous cycle. The filter is if you can do both ops, and the previous transaction was a write, you read, otherwise you write. This means if nothing was done on the previous cycle, the preference is given to write.</p><p>There are the following internal registers:</p><p style="margin-left: 30.0px;">prev_op: 1 = write, 0 = read or nothing.<br/>wt_addr: The write pointer<br/>rd_addr: The read pointer<br/>wrap: When asserted and wt_addr = rd_addr indicates FIFO is full. When deserted and wt_addr = rd_addr FIFO is empty.<br/>rd_sel_p: Indicates a read was issued on the previous cycle.<br/>prev_trigger: There was a packet release trigger on the previous cycle.<br/>pkt_cnt: The number of packets in the FIFO.<br/>trigger_pt: The calculated offset from the wt_addr that must be reach for a packet with depth beats must reach before the packet can start unloading</p><p>These registers are actually stored in one register in the following order:</p><p style="margin-left: 30.0px;">{prev_op,wrap,rd_sel_p,prev_trigger,pkt_cnt,trigger_pt,wt_addr,rd_addr} </p><p>Internally there are the following wires:</p><p style="margin-left: 30.0px;">wire int_empty;<br/>wire equal;<br/>wire next_equal;<br/>wire full;<br/>wire wrap;<br/>wire next_wrap;<br/>wire rd_sel;<br/>wire wt_sel;<br/>wire [\=addr_width-1=\:0] wt_addr;<br/>wire [\=addr_width-1=\:0] next_wt_addr;<br/>wire [\=addr_width-1=\:0] rd_addr;<br/>wire [\=addr_width-1=\:0] next_rd_addr;<br/>wire trigger;<br/>wire prev_trigger;<br/>wire [\=addr_width-1=\:0] next_trigger_pt;<br/>wire [\=addr_width-1=\:0] trigger_pt;<br/>wire trigger_pt_hit;<br/>wire rd_sel_p;<br/>wire prev_op;<br/>wire next_prev_op;<br/>wire [\=state_width-1=\:0] state;<br/>wire [\=state_width-1=\:0] next_state;<br/>wire [\=pkt_cnt_width-1=\:0] pkt_cnt;<br/>wire [\=pkt_cnt_width-1=\:0] pkt_cnt_p0;<br/>wire [\=pkt_cnt_width-1=\:0] pkt_cnt_p1;<br/>wire [\=pkt_cnt_width-1=\:0] pkt_cnt_m1;<br/>wire [\=pkt_cnt_width-1=\:0] next_pkt_cnt;<br/>wire sel_p0;<br/>wire sel_p1;<br/>wire sel_m1;<br/>wire pkt_cnt_not_zero;<br/>wire next_pkt_cnt_not_zero;<br/>wire in_has_last;<br/>wire in_has_first;<br/>wire pipe_has_last;</p><p>The loading and unloaded on the single register:</p><p style="margin-left: 30.0px;">assign next_state[\=state_width-1=\] = next_prev_op;<br/>assign next_state[\=state_width-2=\] = next_wrap;<br/>assign next_state[\=state_width-3=\] = rd_sel;<br/>assign next_state[\=state_width-4=\] = trigger;<br/>assign next_state[\=3*addr_width+pkt_cnt_width-1=\:\=3*addr_width=\] = next_pkt_cnt;<br/>assign next_state[\=3*addr_width-1=\:\=2*addr_width=\] = next_trigger_pt;<br/>assign next_state[\=2*addr_width-1=\:\=addr_width=\] = next_wt_addr;<br/>assign next_state[\=addr_width-1=\:0] = next_rd_addr;</p><p style="margin-left: 30.0px;">assign prev_op = state[\=state_width-1=\];<br/>assign wrap = state[\=state_width-2=\];<br/>assign rd_sel_p = state[\=state_width-3=\];<br/>assign prev_trigger = state[\=state_width-4=\];<br/>assign pkt_cnt = state[\=3*addr_width+pkt_cnt_width-1=\:\=3*addr_width=\];<br/>assign trigger_pt = state[\=3*addr_width-1=\:\=2*addr_width=\];<br/>assign wt_addr = state[\=2*addr_width-1=\:\=addr_width=\];<br/>assign rd_addr = state[\=addr_width-1=\:0];</p><p>The logic_tree block is used three times to calculate equal, next_equal and trigger_pt_hit. The two pointers are exclusive NORed, the resulting bits are ORed using the logic_tree module, and the output for the OR tree is whether the two pointers are equal or not. </p><p>The logic_tree block is used two additional times to calculate pkt_cnt_not_zero and next_pkt_cnt_not_zero. In the case the pkt_cnt and next_pkt_cnt are bit was ORed together to create the signals.</p><p>A logic_tree_bus block is used to create a mux between three calculated values for next_pkt_cnt. The three inputs are ANDed per bit with the a select signal before (as shown in below equations) being inputed into the logic_tree_bus. These three inputs are pkt_cnt_p1, pkt_cnt_m1 and pkt_cnt_p0.</p><p>Here are the logic equations with descriptions of what they are doing. It shows both the original equation from <a class="external-link" href="https://confluence.arteris.com/display/ENGR/sym_fifo_mem_2p_ctl" rel="nofollow">sym_mem_2p_ctl</a> and the modified one.</p><p><strong>New Equations:</strong></p><p style="margin-left: 30.0px;">assign addr = we ? wt_addr : rd_addr;</p><p>Depending on what the operation is, the address changes.</p><p style="margin-left: 30.0px;">assign we   = wt_sel;</p><p>we to the SRAM is just wt_sel;</p><p style="margin-left: 30.0px;">assign next_prev_op   = sel &amp; we;</p><p>Was a write performed on the previous cycle.</p><p><strong>Equations that didn't change (see <a class="external-link" href="https://confluence.arteris.com/display/ENGR/sym_fifo_mem_2p_ctl" rel="nofollow">sym_mem_2p_ctl</a> for descriptions):</strong></p><p style="margin-left: 30.0px;">assign in_has_last = in_valid &amp; in_ready &amp; in_last &amp; (~int_empty | ~pipe_out_valid) ;</p><p style="margin-left: 30.0px;">assign in_has_first = in_valid &amp; in_ready &amp; in_first;</p><p style="margin-left: 30.0px;">assign pipe_has_last = pipe_in_valid &amp; pipe_in_ready &amp; pipe_in_last;</p><p style="margin-left: 30.0px;">assign sel_p1 = in_has_last &amp; ~pipe_has_last;</p><p style="margin-left: 30.0px;">assign sel_m1 = ~in_has_last &amp; pipe_has_last;</p><p style="margin-left: 30.0px;">assign sel_p0 = ~(in_has_last ^ pipe_has_last);</p><p style="margin-left: 30.0px;">assign pkt_cnt_p1 = {\=pkt_cnt_width=\{sel_p1}} &amp; (pkt_cnt + 1'b1);</p><p style="margin-left: 30.0px;">assign pkt_cnt_m1 = {\=pkt_cnt_width=\{sel_m1}} &amp; (pkt_cnt - 1'b1);</p><p style="margin-left: 30.0px;">assign pkt_cnt_p0 = {\=pkt_cnt_width=\{sel_p0}} &amp; pkt_cnt;</p><p style="margin-left: 30.0px;">assign trigger = (~prev_trigger &amp; (trigger_pt_hit | next_pkt_cnt_not_zero | full)) | (prev_trigger &amp; ~(pipe_has_last &amp; ~next_pkt_cnt_not_zero));</p><p style="margin-left: 30.0px;">assign next_trigger_pt =<br/>  in_has_first ?<br/>  ((wt_addr &gt;= \=addr_width=\'d\=depth-valid_trigger_num=\) ?<br/>  wt_addr - \=addr_width=\'d\=depth-valid_trigger_num=\ :<br/>  wt_addr + \=valid_trigger=\ ) :<br/>  trigger_pt;</p><p style="margin-left: 30.0px;">assign addr = we ? wt_addr : rd_addr;</p><p style="margin-left: 30.0px;">assign sel = rd_sel | wt_sel;</p><p style="margin-left: 30.0px;">assign we = wt_sel;</p><p style="margin-left: 30.0px;">assign full = equal &amp; wrap;</p><p style="margin-left: 30.0px;">assign empty = equal &amp; ~wrap &amp; ~pipe_out_valid;</p><p style="margin-left: 30.0px;">assign int_empty = equal &amp; ~wrap;</p><p style="margin-left: 30.0px;">assign out_valid = pipe_out_valid &amp; trigger | empty &amp; in_valid;</p><p style="margin-left: 30.0px;">assign pipe_out_ready = ~empty &amp; out_ready &amp; trigger;</p><p style="margin-left: 30.0px;">assign pipe_in_valid = rd_sel_p;</p><p style="margin-left: 30.0px;">assign rd_sel = ~int_empty &amp; ~wt_sel &amp; (~pipe_in_valid &amp; pipe_in_ready | ~pipe_in_valid &amp; out_ready &amp; trigger | pipe_in_valid &amp; out_ready &amp; trigger);</p><p style="margin-left: 30.0px;">assign next_wt_addr = wt_sel ? ((wt_addr == \=addr_width=\'d\=depth-1=\) ? \=addr_width=\'b0 : wt_addr + 1'b1) : wt_addr;</p><p style="margin-left: 30.0px;">assign next_rd_addr = rd_sel ? ((rd_addr == \=addr_width=\'d\=depth-1=\) ? \=addr_width=\'b0 : rd_addr + 1'b1) : rd_addr;</p><p style="margin-left: 30.0px;">assign next_wrap = (~wrap &amp; wt_sel &amp; ~rd_sel &amp; next_equal) | (wrap &amp; (~rd_sel | (wt_sel &amp; rd_sel)));</p><p><strong>Equations that changed:</strong></p><p style="margin-left: 30.0px;">assign wt_sel = in_valid &amp; ((~empty &amp; ~full) | (~full &amp; ~(out_ready &amp; trigger)));</p><p style="margin-left: 30.0px;">changed to:</p><p style="margin-left: 30.0px;">assign wt_sel = in_valid &amp; (int_empty | ~pipe_in_ready | ~(~int_empty &amp; prev_op)) &amp; ((~empty &amp; ~full) | (~full &amp; ~(out_ready &amp; trigger)));</p><p>The SRAM FIFO is written if there's an input coming in and the block is not empty (not int_empty) and not full or the block is not full and output doesn't have a ready. I don't want to write the SRAM if the SRAM FIFO is empty, the external pipe is empty and the output is ready. In that case, the data is routed around the internal storage and straight to the output. This is what makes the block pipeForward equals false.</p><p>Trigger is being used to filter out_ready for rate limiting. If trigger is not asserted, out_valid can't assert, so the out_ready must be masked.</p><p>The filter for only doing a read or write is (int_empty | ~in_pipe_ready | ~(~int_empty &amp; prev_op)). Since the external pipe can read and write in a single cycle, if we are doing a write into the SRAM, you can still read the contents of the external pipe, so you can't just look at the total empty status to determine if you can do a write or not. In this case you can always write if the SRAM is empty (int_empty, because you won't do a read of an empty FIFO), if the prev_op wasn't a write and you are not empty or you can write if the external pipe is full (in_pipe_ready = 0).</p><p style="margin-left: 30.0px;">assign in_ready = ~full ;</p><p style="margin-left: 30.0px;">changed to:</p><p style="margin-left: 30.0px;">assign in_ready = ~full &amp; (int_empty | ~pipe_in_ready | ~(~int_empty &amp; prev_op));</p><p>The block can't accept data if the SRAM FIFO is full. This is what makes the block pipeBackward equals true. The reason for doing this is most SRAMs can't read and write the same word in the same cycle, so the logic prevents that from happening.</p><p>The filter for only doing a read or write is (int_empty | ~in_pipe_ready | ~(~int_empty &amp; prev_op)) which is the same as above, because ready is the ability the write.</p><p style="margin-left: 30.0px;"><br/></p>