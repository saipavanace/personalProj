<h2 id="InterfaceDefinitionandusemodel(Manadher'sproposal)-Requirements"><style>[data-colorid=ka5niqdsau]{color:#707070} html[data-color-mode=dark] [data-colorid=ka5niqdsau]{color:#8f8f8f}[data-colorid=iyv6bnc509]{color:#707070} html[data-color-mode=dark] [data-colorid=iyv6bnc509]{color:#8f8f8f}[data-colorid=d34rlq0t3m]{color:#707070} html[data-color-mode=dark] [data-colorid=d34rlq0t3m]{color:#8f8f8f}[data-colorid=c97bk3y8rf]{color:#707070} html[data-color-mode=dark] [data-colorid=c97bk3y8rf]{color:#8f8f8f}[data-colorid=s0uhz6qg4q]{color:#707070} html[data-color-mode=dark] [data-colorid=s0uhz6qg4q]{color:#8f8f8f}[data-colorid=qttbprgdyu]{color:#707070} html[data-color-mode=dark] [data-colorid=qttbprgdyu]{color:#8f8f8f}[data-colorid=wj7cc5y2ik]{color:#333333} html[data-color-mode=dark] [data-colorid=wj7cc5y2ik]{color:#cccccc}[data-colorid=x5iho848li]{color:#707070} html[data-color-mode=dark] [data-colorid=x5iho848li]{color:#8f8f8f}[data-colorid=k0c63ffycd]{color:#707070} html[data-color-mode=dark] [data-colorid=k0c63ffycd]{color:#8f8f8f}[data-colorid=hxp113nzx2]{color:#707070} html[data-color-mode=dark] [data-colorid=hxp113nzx2]{color:#8f8f8f}[data-colorid=e6lz37xay7]{color:#707070} html[data-color-mode=dark] [data-colorid=e6lz37xay7]{color:#8f8f8f}[data-colorid=hgmob1nsny]{color:#707070} html[data-color-mode=dark] [data-colorid=hgmob1nsny]{color:#8f8f8f}[data-colorid=kd0a6aac4y]{color:#333333} html[data-color-mode=dark] [data-colorid=kd0a6aac4y]{color:#cccccc}[data-colorid=cr90wjyunf]{color:#707070} html[data-color-mode=dark] [data-colorid=cr90wjyunf]{color:#8f8f8f}[data-colorid=nj05k1va9s]{color:#333333} html[data-color-mode=dark] [data-colorid=nj05k1va9s]{color:#cccccc}[data-colorid=bvg42nrexg]{color:#707070} html[data-color-mode=dark] [data-colorid=bvg42nrexg]{color:#8f8f8f}[data-colorid=n7po6p7ku7]{color:#333333} html[data-color-mode=dark] [data-colorid=n7po6p7ku7]{color:#cccccc}[data-colorid=wz5whfzcj0]{color:#333333} html[data-color-mode=dark] [data-colorid=wz5whfzcj0]{color:#cccccc}[data-colorid=ykz1tacmpk]{color:#707070} html[data-color-mode=dark] [data-colorid=ykz1tacmpk]{color:#8f8f8f}[data-colorid=nuzskv9sf5]{color:#707070} html[data-color-mode=dark] [data-colorid=nuzskv9sf5]{color:#8f8f8f}[data-colorid=qe7je7fkbz]{color:#707070} html[data-color-mode=dark] [data-colorid=qe7je7fkbz]{color:#8f8f8f}[data-colorid=ht2fs4luok]{color:#707070} html[data-color-mode=dark] [data-colorid=ht2fs4luok]{color:#8f8f8f}[data-colorid=ed2yqdl8ef]{color:#707070} html[data-color-mode=dark] [data-colorid=ed2yqdl8ef]{color:#8f8f8f}[data-colorid=all4flajvf]{color:#333333} html[data-color-mode=dark] [data-colorid=all4flajvf]{color:#cccccc}[data-colorid=io63b16lwq]{color:#707070} html[data-color-mode=dark] [data-colorid=io63b16lwq]{color:#8f8f8f}[data-colorid=kia80ing8f]{color:#707070} html[data-color-mode=dark] [data-colorid=kia80ing8f]{color:#8f8f8f}[data-colorid=k0mo2x09ue]{color:#333333} html[data-color-mode=dark] [data-colorid=k0mo2x09ue]{color:#cccccc}[data-colorid=rfapivfpxv]{color:#333333} html[data-color-mode=dark] [data-colorid=rfapivfpxv]{color:#cccccc}</style>Requirements</h2><h3 id="InterfaceDefinitionandusemodel(Manadher'sproposal)-Introduction">Introduction</h3><p>Interfaces in TACHL are meant to simplify the handling of the connectivity between TACHL modules (Consequently RTL generated from it). In this document we will use the word interfaces assuming the context of TACHL as interfaces have been defined in every HDL in a form or another (Entities in VHDL, Interfaces in System Verilog &hellip;). As are the modules of TACHL, the interfaces will be in a &quot;template&quot; format configurable using the same parameters the TACHL module are using to simplify the instantiation of internal interfaces and internal signals connected to the interfaces.</p><p>The only<span data-colorid="wj7cc5y2ik" style="text-decoration: none;">&nbsp;new</span>&nbsp;difference from TACHL modules view is that the TACHL modules will have the interfaces associated with them as parameters !</p><p>A TACHL module, then, will have its own IO defined in the format of an&nbsp; interface composed itself from interfaces.</p><h3 id="InterfaceDefinitionandusemodel(Manadher'sproposal)-RequiredFunctionality&amp;Features">Required Functionality &amp; Features</h3><p>In essence an interface is composed of a set of signals with configurable width and IO direction when applicable (we will use interfaces to define the signal bundles within the modules that connect to the IO interfaces). The configuration of the signals within a particular instance of an interface includes on top of their widths their very existence (signals can be excluded from a particular instance of an interface)</p><p>An interface does not have an IO direction per say (like a port has) but it has a &quot;port mode&quot; that we chose to have in TACHL constrained to the values within <span data-colorid="all4flajvf" style="text-decoration: none;">the enumeration set : { 'Master', 'Slave', 'Signal'&nbsp;}&nbsp;</span></p><p>A port within an interface will have a &quot;pseudo direction&quot; within the enumeration set <span data-colorid="rfapivfpxv" style="text-decoration: none;">{'m_in', 'm_out'}</span></p><ul><li>A port having the &quot;<span data-colorid="wz5whfzcj0" style="text-decoration: none;">pseudo </span>direction&quot; 'm_out' will be rendered in a Verilog port having the direction 'output' when the interface is used in the &quot;port mode&quot; 'Master' and the Verilog direction 'input' when the when the interface is used in the &quot;mod port&quot; 'slave'.</li><li><span data-colorid="kd0a6aac4y" style="text-decoration: none;">A port having the &quot;<span data-colorid="nj05k1va9s" style="text-decoration: none;">pseudo </span>direction&quot; 'm_in' will be rendered in a Verilog port having the direction 'input' when the interface is used in the &quot;port mode&quot; 'Master' and the Verilog direction 'output' when the when the interface is used in the &quot;mod port&quot; 'slave'.</span></li><li><span data-colorid="n7po6p7ku7" style="text-decoration: none;">In the 'Signal' mode an instance of an interface is used to render internal signals ( wire, register, logic &hellip;) not ports. Using the bundle aspect of an interface in this mode.<br /></span></li></ul><p>To further simplify the manipulation of interface manipulation at a higher level of abstraction, an interface is composed not only from simple signals but also from entire interfaces. The configuration of an interface within another interface is handled by the inclusion/exclusion of the entire interface and by passing a parameter object allowing the inner interface to configure the width of its internal signals and its internal interfaces in its turn.</p><p>To simplify the integration of our solutions within the verification harness implemented within Arteris IP for internal validation needs and within the customer verification environment as much as the customer SoC solution we are considering the simplification of translation between TACHL interfaces and System Verilog Interfaces.</p><p>The parameters passed to an internal Interface, at rendering time, imply the decision about its &quot;port mode&quot; at instantiation.</p><h2 id="InterfaceDefinitionandusemodel(Manadher'sproposal)-Implementationconsiderations"><u style="font-size: 16.0px;font-weight: bold;"><span data-colorid="k0mo2x09ue" style="text-decoration: none;">Implementation considerations</span></u></h2><p>The most important aspect of the use model of the interfaces in TACHL is the possibility to pass objects describing the interface rendering between SW and HW and crucially between top level modules and the instances of other modules they have inside them. This operation (interface rendering) happens at the time of instantiation.</p><ul><li>Interfaces are meant to be shared between TACHL modules : define them as library elements</li><li>Interfaces are needed by the SW to make QoR decisions : Put them in the Central Parameter Repository (BtB)</li><li>Interface instantiation to a TACHL module affects the generated Verilog module base (not same modules) : Interfaces are part of TACHL parameters and affect the identification hash calculation.</li><li>The decision to include or exclude Interface elements (signals or inner interfaces) is made at instantiation time : Exclusion list is a parameter</li><li>Meta data about Interface elements can be static (at definition time like for use as clock signal) or dynamic (at instantiation time)</li><li>The functionality of rendering the interface into a bundle of signals is generic enough to be implemented independently of a specific interface. We'll use parametrization handled by a unique function specified only once (even if copied several times)</li><li>We should allow for reuse of the same Interface instance to instantiate several signal bundles or port bundles.</li><li>The several signal or port bundles instantiated within the same scope should be differentiated: Naming handling scheme using parametrized prefixes and postfixes can be the solution.</li></ul><h3 id="InterfaceDefinitionandusemodel(Manadher'sproposal)-HWArchitectureQuestionsAnswering"><u>HW Architecture Questions Answering</u></h3><h4 id="InterfaceDefinitionandusemodel(Manadher'sproposal)-Motivation">Motivation</h4><ol><li>Enable Symphony Dynamic Configuration</li><li>Allow easy randomization of Test Design generation for DV</li><li>Allow easy signal bundles handling while passing them to RTL instances</li><li>Allow easy internal signals declaration (Glue wires)</li></ol><h5 id="InterfaceDefinitionandusemodel(Manadher'sproposal)-BasicDCIsyntaxandspecificationofitscomponentparts,withalloptionsidentified.ForDeclarationandinvocation."><u>Basic DCI syntax and specification of its component parts, with all options identified. For Declaration and invocation.</u></h5><p>No need for users to know about internal implementation (A degree of freedom for SW) The CPR tool will gather data about :</p><ol><li>Signals belonging to a certain interface<ol><li>A signal can be of type &quot;logic&quot; denoting an actual wire or reg in Verilog</li><li>A signal can be itself an interface</li><li>An array of the above signals (Allowing easy switch configurations)</li></ol></li><li>Parameters used to configure the signals either as elements of the width expressions or conditions for signal presence</li><li>An elaboration function per interface to handle complex configurations.</li></ol><p>Examples of Interface elements:</p><blockquote><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;{</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sname&nbsp;&nbsp;&nbsp;:&nbsp;'E',</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stype&nbsp;&nbsp;&nbsp;:&nbsp;'logic',</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sdir&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;'m_in',</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Swidth&nbsp;&nbsp;: params.w1,</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Excludable : &quot;Yes&quot;</p><p><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;isArray : &quot;No&quot;</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sname&nbsp;&nbsp;&nbsp;:&nbsp;'P',</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stype&nbsp;&nbsp;&nbsp;:&nbsp;'interface',</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sdir&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;'m_in',</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sdef&nbsp;&nbsp;&nbsp;&nbsp;: InterfaceSimple(),&nbsp;// params.w1</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Swidth&nbsp;&nbsp;: params.www</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Excludable : &quot;No&quot;</p><p><span data-colorid="iyv6bnc509">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;isArray : &quot;No&quot;</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p></blockquote><h5 id="InterfaceDefinitionandusemodel(Manadher'sproposal)-Specificationof“helper”functionsandtheirusage"><u>Specification of &ldquo;helper&rdquo; functions and their usage</u></h5><ol><li><span data-colorid="hgmob1nsny">set_params (Param_Object) : Sets the object that describes all the parameters of the interface (including the excluded signals)</span></li><li><span data-colorid="x5iho848li">&nbsp;</span><span data-colorid="e6lz37xay7">get_params (Param_Object) : returns the object that describes all the parameters of the interface (including the excluded signals)</span></li><li><span data-colorid="nuzskv9sf5">&nbsp;</span><span data-colorid="d34rlq0t3m">set_param&nbsp; (Param_Name/Param_Path, Param_Value)&nbsp; : Sets a single parameter giving the path to it through the parameter object structure to the provided value.&nbsp;</span></li><li><span data-colorid="k0c63ffycd"><span data-colorid="bvg42nrexg"><span data-colorid="s0uhz6qg4q">get_param <span data-colorid="ed2yqdl8ef">&nbsp;(Param_Name/Param_Path)&nbsp;</span>:&nbsp;<span data-colorid="kia80ing8f">returns the value of a single parameter giving the path to it through the parameter object structure.&nbsp;</span></span></span></span></li><li><span data-colorid="ykz1tacmpk">exclude_signal (Signal_Path) : Mark a signal for exclusion ( in addition to the excluded signals by the parameter object)</span></li><li>include_signal (Signal_Path) :&nbsp;<span data-colorid="qe7je7fkbz">Mark a signal for inclusion ( overrides the excluded signals by the parameter object)</span></li><li><span data-colorid="ht2fs4luok"><span data-colorid="cr90wjyunf">get_excluded() : returns the array of the signal names marked for exclusion</span></span></li><li><span data-colorid="hxp113nzx2"><span data-colorid="c97bk3y8rf">elaborate() : Uses the parameter object to decide the signal widths/configuration objects and the exclusion list.</span></span></li><li><span data-colorid="qttbprgdyu"><span data-colorid="ka5niqdsau">get_signals() : Returns the elaborated list of signals belonging to this instance of an interface. (The actual ports need prefixes and suffixes attached to the names in this list)</span></span></li></ol><h5 id="InterfaceDefinitionandusemodel(Manadher'sproposal)-Specificationofexclusionsorinclusions"><u>Specification of exclusions or inclusions</u></h5><p>Please read item 5. and 6. of the precedent answer.</p><h5 id="InterfaceDefinitionandusemodel(Manadher'sproposal)-HowdoesDCIinformationgetmappedintoCPR?"><u>How does DCI information get mapped into CPR?</u></h5><ul><li>The Parameters of an interface are exactly like the parameters of a TACHL module used befor in the CPR (e.g. CodaCache)</li><li>The signals of an interface are &quot;special type of TACHL parameters&quot; having as fields : 'Sname'&nbsp; &nbsp;,&nbsp; 'Stype'&nbsp; &nbsp;, 'Sdir'&nbsp; &nbsp;, 'Sdef'&nbsp; ,&nbsp; 'Swidth'&nbsp;,&nbsp; 'Excludable' and 'isArray'.</li><li>The 'elaborate' function is entered as text like the 'custom validation&quot; function is entered for old TACHL params</li></ul><h5 id="InterfaceDefinitionandusemodel(Manadher'sproposal)-HowisthesemanticsofthedatagetscommunicatedtoMaestrosoitcanproducethecorrectinputparametervaluesforeachparticularinstance?"><u>How is the semantics of the data gets communicated to Maestro so it can produce the correct input parameter values for each particular instance?</u></h5><p>There is no easy way to pass the semantics from a generic elaboration function. It is the other way around. The semantics of the interface configuration is defined to implement the wanted behavior realizing Symphony topologies then the elaboration functions are written and verified to map the semantics into signal inclusion or exclusion using only the parameters to fully describe it.</p><h5 id="InterfaceDefinitionandusemodel(Manadher'sproposal)-HowwillsoftwaredeterminewhichconfigurationoftheDCItouseandwhere"><u>How will software determine which configuration of the DCI to use and where</u></h5><p>It is the topology choices that determine the attributes of the interface we want to have using the QoR and the possible packet definitions that can go over each interface. The attributes are then mapped to the possible interfaces that can guarantee them (Part of the Hardware Inference module)</p><h5 id="InterfaceDefinitionandusemodel(Manadher'sproposal)-ExamplesofDCIspecificationsifandwheretheycanhelpilluminatetheaboveideas"><u>Examples of DCI specifications if and where they can help illuminate the above ideas</u></h5><p>Please, visit the page at this link for a basic example (more to be done! )</p><p><a class="external-link" href="https://maestrodev.arteris.com/static/docs/sections/interfaces/#proposal" rel="nofollow">https://maestrodev.arteris.com/static/docs/sections/interfaces/#proposal</a></p><h5 id="InterfaceDefinitionandusemodel(Manadher'sproposal)-WherecanaTACHLmoduleaccesstheavailableinterfacedefinitions(objects)?"><u>Where can a TACHL module access the available interface definitions (objects) ?</u></h5><p>The Interface definitions should be included in the versioned TACHL library coming with any HW release.</p><h5 id="InterfaceDefinitionandusemodel(Manadher'sproposal)-HowtopassmultipleinterfacestoaTACHLmodule?"><u>How to pass multiple interfaces to a TACHL module ?</u></h5><p>You can't&nbsp;! and you shouldn't.</p><p>A TACHL module has only one Interface which can include multiple interfaces as signals (See above)</p><h5 id="InterfaceDefinitionandusemodel(Manadher'sproposal)-Describehowonewouldcopyorcloneandinterface?"><u>Describe how one would copy or clone and interface</u>?</h5><p>When you get the object describing an interface you can clone it using the function lodash.cloneDeep described here :&nbsp;<a class="external-link" href="https://lodash.com/docs/#cloneDeep" rel="nofollow">https://lodash.com/docs/#cloneDeep</a></p><p>Note that the library 'lodash' comes by default with TACHL because it is needed for the main function of TACHL 'lodash.template'</p><h5 id="InterfaceDefinitionandusemodel(Manadher'sproposal)-Wouldyoucopytheparametersfromaninterface,modifythemandthencreateanewinterfaceusingthenewparametervalues?"><u><span data-colorid="io63b16lwq">Would you copy the parameters from an interface, modify them and then create a new interface using the new parameter values?</span></u></h5><p>You can clone an interface object at any level.</p><p>First you get the Interface type object on which you can add the 'Parameters' object using the function 'set_params' described above, then you can generate the resulting signals.</p><p>Cloning can happen at any time including OR NOT the parameters, the excluded list and the resulting signals.</p><h5 id="InterfaceDefinitionandusemodel(Manadher'sproposal)-Howdoyoupreventinstancenamecollisions?"><u>How do you prevent instance name collisions?</u></h5><p>The resulting signals have the base names of the signals on which we can add prefixes and postfixes (in the params) like we already do on old interfaces.</p><h5 id="InterfaceDefinitionandusemodel(Manadher'sproposal)-Wherewouldyougetthenumberofingressinterfacesandegressinterfacesfrom?"><u>&nbsp;Where would you get the number of ingress interfaces and egress interfaces from?</u></h5><p>From the parameters passed to the instance of the interface, just like TACHL module parameters.</p><h5 id="InterfaceDefinitionandusemodel(Manadher'sproposal)-Howwouldyouformtheparameters?"><u>How would you form the parameters?</u></h5><p>The parameters at the top level are read from a file or immediately passed to the TACHL command and at the TACHL module instance level are either generated from the instantiating TACHL module or pruned from the global param set by the instantiating module and passed down. either way they are passed to the 'new_instance' (replacing the TACHL 'instance' function )function in TACHL.</p><h5 id="InterfaceDefinitionandusemodel(Manadher'sproposal)-HowtodefinehewidthorParamobjectofasignalhavingtheattribute'isArray'setto&quot;Yes&quot;?"><u>How to define he width or Param object of a signal having the attribute 'isArray' set to &quot;Yes&quot; ?</u></h5><p>The parameter object has a field describing the array size and a param object that is in itself an array of the described size (one per signal)</p><h4 id="InterfaceDefinitionandusemodel(Manadher'sproposal)-AnsweringComment1"><strong>Answering Comment 1</strong>&nbsp;</h4><h5 id="InterfaceDefinitionandusemodel(Manadher'sproposal)-HowaswitchwilllookinthetoplevelJSONfile"><u><strong>How a switch will look in the top level JSON file</strong></u></h5><p>&nbsp;</p><blockquote><p>SwitchParams : {<br />&nbsp; &nbsp; ...<br />&nbsp; &nbsp; IO : SwitchInterface();<br />}</p><p><br />// The signals defined in the switch interface ( The rest is generic )</p><p>SwitchInterface.signals : {<br /> &nbsp; &nbsp;&nbsp;{</p><p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;Sname : 'Clk',</p><p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;Stype : 'logic',</p><p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;Sdir : 'm_in',</p><p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;Swidth : 1,</p><p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;Excludable : &quot;No&quot;</p><p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;isArray : &quot;No&quot;</p><p>&nbsp; &nbsp;&nbsp;},</p><p>&nbsp; &nbsp;&nbsp;{</p><p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;Sname : 'Ingr', // Rank in the vector added as a postfix =&gt; Ingr0, Ingr1, Ingr2 ...</p><p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;Stype : 'interface',</p><p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;Sdir : 'm_in', // Slave</p><p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;Sdef : InterfaceSimple(), // params.w1</p><p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;Swidth : params.wwIn</p><p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;Excludable : &quot;No&quot;</p><p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;isArray : &quot;Yes&quot;</p><p>&nbsp; &nbsp;&nbsp;},</p><p>&nbsp; &nbsp;&nbsp;{</p><p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;Sname : 'Egr', // Rank in the vector added as a postfix =&gt; Egr0, Egr1, Egr2 ...</p><p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;Stype : 'interface',</p><p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;Sdir : 'm_out', // Master</p><p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;Sdef : InterfaceSimple(), // Default type of Egr</p><p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;Swidth : params.wwEg</p><p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;Excludable : &quot;No&quot;</p><p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;isArray : &quot;Yes&quot;</p><p>&nbsp; &nbsp;&nbsp;}<br /> <br /> }</p><p><br />params: {</p><p>&nbsp; &nbsp;&nbsp;ClkW : null;&nbsp;// Does not need params<br /> &nbsp; &nbsp;&nbsp;wwIn : [ <br /> &nbsp; &nbsp;&nbsp;{<br /> &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;W1 : 12,<br /> &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;W2 : 06,<br /> &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;rout : [ 0, 1 ]<br /> &nbsp; &nbsp;&nbsp;},</p><p>&nbsp; &nbsp;&nbsp;{<br /> &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;W1 : 03,<br /> &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;W2 : 09,<br /> &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;rout : [ 1 ]<br /> &nbsp; &nbsp;&nbsp;},</p><p>&nbsp; &nbsp;&nbsp;{<br /> &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;W1 : 21,<br /> &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;W2 : 16,<br /> &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;rout : [ 0 ]<br /> &nbsp; &nbsp;&nbsp;}<br /> &nbsp; &nbsp;&nbsp;],<br /> wwEg : [ <br /> &nbsp; &nbsp;&nbsp;{<br /> &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;W4 : 03,<br /> &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;W5 : 06,<br /> &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;pMap : [ 0, 2 ]<br /> &nbsp; &nbsp;&nbsp;},</p><p>&nbsp; &nbsp;&nbsp;{<br /> &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;W4 : 03,<br /> &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;W5 : 09,<br /> &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;pMap : [ 0, 1 ]<br /> &nbsp; &nbsp;&nbsp;}<br /> &nbsp; &nbsp;&nbsp;]</p><p>}</p><p><u><strong><br /></strong></u></p><p><u><strong><br /></strong></u></p></blockquote><div><span class="legacy-color-text-blue1"><strong><u><br /></u></strong></span></div><div><span class="legacy-color-text-blue1"><strong><u>How does the specification look in CPR</u></strong></span></div><div>Presentation in the link :</div><div><a class="external-link" href="https://maestrodev.arteris.com/static/docs/sections/interfaces/#proposal" rel="nofollow">https://maestrodev.arteris.com/static/docs/sections/interfaces/#proposal</a></div><div><u><strong>Given the specification in CPR, how does software know which interface needs to be used where?</strong></u></div><p>Answered above. The other way around (User Choice)</p><h5 id="InterfaceDefinitionandusemodel(Manadher'sproposal)-HowTACHLcodeusesthisJSON"><u><strong>How TACHL code uses this JSON</strong></u></h5><p>I will use the example above to talk to John then make a more specific example.</p><h5 id="InterfaceDefinitionandusemodel(Manadher'sproposal)-Howwillthefinalnamesofthewirewilllooklike.(Ruleforconcatenationbasedontheinput)?"><u><strong>How will the final names of the wire will look like. (Rule for concatenation based on the input)?</strong></u></h5><p>Exactly as in the old interfaces plus the poet_fixint with index in the comment above.</p><p>&nbsp;</p><p>&nbsp;</p>