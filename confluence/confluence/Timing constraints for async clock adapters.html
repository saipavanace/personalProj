<p> </p><p>When data crosses a boundary between two always-on asynchronous clock domains <a class="external-link" href="https://confluence.arteris.com/display/ENGR/sym_async_adapter+and+sym_vc_async_adapter" rel="nofollow">sym_async_adapter </a>must be inserted on the link to prevent data loss. This adapter is basically a FIFO pipe with read and write Gray code pointers. </p><p>Notes:</p><ul><li>If even one of the domains can be independently turned off we must use another type of adapter - bidir, which is not yet supported by Maestro.</li><li>sym_asinc_adapter must be in asynchronous mode, which is set by async instance parameter set to true</li></ul><p>Within the adapter timing paths which are launched by Tx (write) clock and Rx (read) clock can't be left to a normal timing analysis in the synthesis tool. Instead we define Tx and Rx clocks as fully asynchronous (i.e relation between clock edges is unknown) and apply a set of special max_delay constraints which guarantee that adapter implementation works correctly.</p><p>Below is the explanation of constraints, written by Benoit</p><p><span class="legacy-color-text-default">A</span>. Is the default way of removing any synchronous path between the 2 clocks</p><p><span class="legacy-color-text-default">B</span>. Is the gray-coded write pointer <strong>exception</strong> meant to contain the jitter between signals to the launch clock period, which guarantee correctness at capture side</p><p><span class="legacy-color-text-default">C</span>. Is the gray-coded read pointer <strong>exception</strong> meant to contain the jitter between signals to the launch clock period, which guarantee correctness at capture side</p><p>D. Is not an exception and actually does not need any special SDF statement. (D) is fully synchronous in the Rx clock domain</p><p>E. Is a set of <strong>exception</strong> placed between the registers holding the data, and the Rx side. It is set to <strong>2 times the receive clock period</strong>, which is the minimum time it takes for the <strong>write pointer change</strong>s to be noticed by the <strong>read pointer logic</strong>, due to the 2 (or more) cycles of the resynchronizer in the path. In other words, after a write is done to a register, it takes at minimum 2 Rx clock cycles for the read pointer logic to realize it can advance the pointer and make use of the just written data; at which point the signal is guaranteed to be stable when the mux changes to the register in question.<br/><br/><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="400" src="https://arterisip.atlassian.net/wiki/download/attachments/16171288/AsyncAdapterConstr.JPG?api=v2"></span></p><p> </p><p>Here is how constraints B, C and E should be formed for each sym_async_adapter</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence"># write pointer crossing from write clock domain to read clock domain
set_max_delay &quot;${gen_async_adapter_wr_clk_period_minus_uncertainty}&quot; 
 -from [get_cells &quot;${GEN_ASYNC_ADAPTER_HIERARCHY}/u_gen_async_adapter_in/u_async_fifo_wt_ctl/u_ptr_reg/reg_out_dffre/q_reg[*]&quot;]
 -to [get_clock gen_async_adapter_rd_clk]

# read pointer crossing from read clock domain to write clock domain
set_max_delay &quot;${gen_async_adapter_rd_clk_period_minus_uncertainty}&quot; 
 -from [get_cells &quot;${GEN_ASYNC_ADAPTER_HIERARCHY}/u_gen_async_adapter_out/u_async_fifo_rd_ctl/u_ptr_reg/reg_out_dffre/q_reg[*]&quot;]
 -to [get_clock gen_async_adapter_wr_clk]

# write data array crossing from write clock domain to read clock domain 
set_max_delay 2*${gen_async_adapter_rd_clk_period_minus_uncertainty}
 -from [get_cells &quot;${GEN_ASYNC_ADAPTER_HIERARCHY}/u_gen_async_adapter_in/u_async_fifo_reg_dp/reg_out_*[*]&quot;]
 -to [get_clock gen_async_adapter_rd_clk]</pre>
</div></div><p> </p><p>All constraints, including the async ones are created by Aria's genDcSynScript() command. These 3 parameters allow customization of register cell search relative to adapter hierarchy</p><div class="code panel pdl" style="border-width: 1px;">
 <div class="codeHeader panelHeader pdl hide-border-bottom">
  <b class="code-title"></b><span class="collapse-source expand-control" style="display:none;"><span class="expand-control-icon icon">&nbsp;</span><span class="expand-control-text">Expand source</span></span><span class="collapse-spinner-wrapper"></span>
 </div>
 <div class="codeContent panelContent pdl hide-toolbar">
  <pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence; collapse: true" data-theme="Confluence">asyncAdapterWritePtrRegName
    String pattern indicating register cell of write pointer relative to async adapter cell hierarchy
    type: string
    default: u_gen_async_adapter_in/u_async_fifo_wt_ctl/u_ptr_reg/reg_out_dffre/q_reg[*]
asyncAdapterReadPtrRegName
    String pattern indicating register cell of read pointer relative to async adapter cell hierarchy
    type: string
    default: u_gen_async_adapter_out/u_async_fifo_rd_ctl/u_ptr_reg/reg_out_dffre/q_reg[*]
asyncAdapterDataRegName
    String pattern indicating data register cell relative to async adapter cell hierarchy
    type: string
    default: u_gen_async_adapter_in/u_async_fifo_reg_dp/reg_out_*[*]</pre>
 </div>
</div><p> </p><p>Finally here is an example of generated constraints for 2 adapters from 8x8 2 clock symphony testcase - one for mainRegime-&gt;anotherRegime clock crossing, and the other way around</p><div class="code panel pdl" style="border-width: 1px;">
 <div class="codeHeader panelHeader pdl hide-border-bottom">
  <b class="code-title"></b><span class="collapse-source expand-control" style="display:none;"><span class="expand-control-icon icon">&nbsp;</span><span class="expand-control-text">Expand source</span></span><span class="collapse-spinner-wrapper"></span>
 </div>
 <div class="codeContent panelContent pdl hide-toolbar">
  <pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence; collapse: true" data-theme="Confluence"># Adapter: csr_request_nw/Switch_to_targetSocket0_clka, write clk: mainRegime_Cm_root_clk, read clk: AnotherRegime_Cm_root_clk 
set_max_delay 0.900 -from [get_cells "csr_request_nw/Switch_to_targetSocket0_clka/u_gen_async_adapter_in/u_async_fifo_wt_ctl/u_ptr_reg/reg_out_dffre/q_reg[*]"] -to [get_clock AnotherRegime_Cm_root_clk]
set_max_delay 1.000 -from [get_cells "csr_request_nw/Switch_to_targetSocket0_clka/u_gen_async_adapter_out/u_async_fifo_rd_ctl/u_ptr_reg/reg_out_dffre/q_reg[*]"] -to [get_clock mainRegime_Cm_root_clk]
set_max_delay 2.000 -from [get_cells "csr_request_nw/Switch_to_targetSocket0_clka/u_gen_async_adapter_in/u_async_fifo_reg_dp/reg_out_*[*]"] -to [get_clock AnotherRegime_Cm_root_clk]
      
# Adapter: csr_request_nw/initiatorSocket0_to_Link6_clka, write clk: AnotherRegime_Cm_root_clk, read clk: mainRegime_Cm_root_clk 
set_max_delay 1.000 -from [get_cells "csr_request_nw/initiatorSocket0_to_Link6_clka/u_gen_async_adapter_in/u_async_fifo_wt_ctl/u_ptr_reg/reg_out_dffre/q_reg[*]"] -to [get_clock mainRegime_Cm_root_clk]
set_max_delay 0.900 -from [get_cells "csr_request_nw/initiatorSocket0_to_Link6_clka/u_gen_async_adapter_out/u_async_fifo_rd_ctl/u_ptr_reg/reg_out_dffre/q_reg[*]"] -to [get_clock AnotherRegime_Cm_root_clk]
set_max_delay 1.800 -from [get_cells "csr_request_nw/initiatorSocket0_to_Link6_clka/u_gen_async_adapter_in/u_async_fifo_reg_dp/reg_out_*[*]"] -to [get_clock mainRegime_Cm_root_clk]</pre>
 </div>
</div><p> </p><p> </p><p> </p><p>  </p><p> </p>