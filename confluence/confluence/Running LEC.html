<h1 id="RunningLEC-RTLvs.RTL(Supportsclockgatevs.noclockgate)">RTL vs. RTL (Supports clock gate vs. no clock gate)</h1><p>1) You need to create an Ncore or Symphony regression area and source the SOURCEME file for your shell type</p><p>2) When you generate the code it must be for synthesis</p><p>3) Copy the code you want to two directories (you need to modify it)</p><p style="margin-left: 30.0px;">mkdir lec_area<br/>cd lec_area<br/>cp -rf path_to_orig orig<br/>cp -rf path_to_modified modified</p><p>4) Move the memories out so they get blacked boxed automatically</p><p style="margin-left: 30.0px;">cd orig<br/>mkdir black_box<br/>mv internal_mem_* black_box<br/>cd ../modified<br/>mkdir black_box<br/>mv internal_mem_* black_box</p><p>5) Finally, you need to change the &quot;function&quot; to &quot;function automatic&quot; in ioaiu_lib_a.v</p><p style="margin-left: 30.0px;">cat ioaiu_lib_a.v | sed &quot;s/function integer/function automatic integer/&quot; &gt; tmp.v ; mv tmp.v ioaiu_lib_a.v<br/>cd ../orig<br/>cat ioaiu_lib_a.v | sed &quot;s/function integer/function automatic integer/&quot; &gt; tmp.v ; mv tmp.v ioaiu_lib_a.v<br/>cd ..</p><p>5a) For the IOAIU there're a number of other checks.</p><ol><li>There's an empty placeholder file for which there's no verilog, but only an attr file. This creates a number of undriven nets which makes LEC fail. To overcome this the verilog file must be generated. There's a script in ~kjeld/Scripts/PlaceHolderVGen.py for this.<br/>Note that the prober placeholder file (place_holder_e.v for ioaiu_top_a) must be generated. Check the RTL for which file is used. The script takes the attr file as input and generates the proper RTL with tie-offs and all.</li><li>The EVID in ioaiu_core may mismatch depending on how the RTL was built by Maestro. Fix this by making the EVIDs the same in orig and modified.</li><li>The apb_* files may mismatch. Copy the file from orig into modified is this is seen.Â </li></ol><p>6) Now you can run LEC (Symphony):</p><p style="margin-left: 30.0px;">$WORK_TOP/../../hw-lib/js/run_lec.sh ./orig ./modified/ &lt;top_block_module_name&gt;</p><p>(Ncore)</p><p style="margin-left: 30.0px;">$WORK_TOP/../hw-lib/js/run_lec.sh ./orig ./modified/ &lt;top_block_module_name&gt;</p><p>When the program ends, it exit. However, if you want to not exit to enter the GUI for debug, change the above to:</p><p>(Symphony):</p><p style="margin-left: 30.0px;">$WORK_TOP/../../hw-lib/js/run_lec.sh ./orig ./modified/ &lt;top_block_module_name&gt; debug</p><p>(Ncore)</p><p style="margin-left: 30.0px;">$WORK_TOP/../hw-lib/js/run_lec.sh ./orig ./modified/ &lt;top_block_module_name&gt; debug</p><p>and type &quot;start gui&quot; and use all the debug info available in the tool to find your problem.</p><h1 id="RunningLEC-RTLvs.Synthesis">RTL vs. Synthesis</h1><p>The scripting only supports Zero wire load 7nm runs.</p><p>1) You need to create an Ncore or Symphony regression area and source the SOURCEME file for your shell type</p><p>2) You generate the code the way you normally do for synthesis. From now on we're going to assume you generated this code using Maestro in you have the normal &quot;output&quot; directory.</p><p>3) Before you synthesize, but after you have generated the code from Maestro, you need to swap out the dffre.v file sitting in output/rtl/design:</p><p style="margin-left: 30.0px;">cp &lt;local_regress_area&gt;/hw-lib/js/dffre.v &lt;maestro&gt;/output/rtl/design</p><p>We want to prevent synthesis from flipping the stored state of a register to an inverted version. In the experiment I ran, using the modified dffre stopped this from happening. We're doing this so we don't have to load the hints file that synthesis generates to feed to LEC. We don't want to load the hints file because if synthesis finds a situation where it can't do a perfect map of RTL to gate, it will put that into the hints file so that LEC will pass and we're trying to find those situations to eliminate them from the code because they create a support nightmare for our AEs.</p><p>4) Run synthesis (however you are use to doing it).</p><p>5) Copy the code to separate directories, because we need to muck with them. For the &quot;RTL&quot; source, copy the memory wrappers, placeholders and code into a single directory. Assuming you've followed the synth instructions I did you would:</p><p style="margin-left: 30.0px;">mkdir orig<br/>cp &lt;maestro&gt;/output/rtl/design/*.v orig<br/>cp &lt;maestro&gt;/memories/*.v orig</p><p>Copy the generated gate level verilog from synthesis. Assuming you followed the synth instructions I did you would:</p><p style="margin-left: 30.0px;">mkdir gate<br/>cp &lt;maestro&gt;/output/synthesis/synopsys/scripts/&lt;block_module_name&gt;/outputs/&lt;block_module_name&gt;.gate_level.v gate</p><p>In this step we do not want to copy verilog of real SRAMs if they are being used because we want them to become black boxes.</p><p>6) Update the ioaiu_lib_a.v file to get rid of LEC errors:</p><p style="margin-left: 30.0px;">cd orig<br/>cat ioaiu_lib_a.v | sed &quot;s/function integer/function automatic integer/&quot; &gt; tmp.v ; mv tmp.v ioaiu_lib_a.v<br/>cd ..</p><p>7) Run LEC (Symphony)</p><p style="margin-left: 30.0px;">$WORK_TOP/../../hw-lib/js/run_lec_gate.sh ./orig ./gate &lt;block_module_name&gt;</p><p>(Ncore)</p><p style="margin-left: 30.0px;">$WORK_TOP/../hw-lib/js/run_lec_gate.sh ./orig ./gate &lt;block_module_name&gt;</p><p>run_lec_gate.sh supports the same debug feature as run_lec.sh.</p>