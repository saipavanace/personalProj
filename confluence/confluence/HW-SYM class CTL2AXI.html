<p>This is a JS class for use with Symphony <strong>AXI-ATU</strong> <strong>Target</strong>. The class definitions can be found in the following path:</p><p><strong>hw-sym/js/interfaceMapLibs.js</strong></p><p>Note: Although says CTL2AXI, AXI here is still the known interface X and CTL the known interface Y (interface X and interface Y as defined in the base class). A better name would have been AXI2CTLForTarget.</p><h2 id="HW-SYMclassCTL2AXI-BaseClass">Base Class</h2><p><a class="external-link" href="https://confluence.arteris.com/display/ENGR/InterfaceX2InterfaceY" rel="nofollow">InterfaceX2InterfaceY</a></p><h2 id="HW-SYMclassCTL2AXI-Purpose">Purpose</h2><p>The class is used to </p><ol><li>Generate internal CTL interface (unknown) from an external AXI interface (known) for the Target.</li><li>Generate mapping between signals of CTL and AXI interfaces in the AXI Native Layer (Target)</li><li>Provide an easy way of overwriting default mappings such as for mapping user bits ( refer <a class="external-link" href="https://confluence.arteris.com/display/ENGR/Generic+Assignment+Proposal" rel="nofollow">Generic Assignment Proposal</a> )</li></ol><p>This allows decoupling of JS code that performs the above tasks from TACHL code involving design, hence also making it more modular and maintainable (tables can be updated to change default mappings).</p><p>This class uses or refers three tables:</p><ol><li>axiInput2CtlOutputTargetMap - has all the signal mappings between AXI signal inputs and CTL signal outputs of the Native Layer. This becomes the Y2XMap of the base class <a class="external-link" href="https://confluence.arteris.com/display/ENGR/InterfaceX2InterfaceY" rel="nofollow">InterfaceX2InterfaceY</a>.</li><li>ctlInput2AxiOutputTargetMap - has all the signal mappings between CTL signal inputs and AXI signal outputs of the Native Layer. This becomes the X2YMap of the base class <a class="external-link" href="https://confluence.arteris.com/display/ENGR/InterfaceX2InterfaceY" rel="nofollow">InterfaceX2InterfaceY</a>.</li><li>ctlSignalWidthMap - is a dictionary object with CTL signal names as keys and their width parameters as values. This becomes the yParamMap of the base class <a class="external-link" href="https://confluence.arteris.com/display/ENGR/InterfaceX2InterfaceY" rel="nofollow">InterfaceX2InterfaceY</a>.</li></ol><h2 id="HW-SYMclassCTL2AXI-Interface">Interface</h2><p><strong><em>constructor( axiInterface, axiPrefix, userMapRequest, userMapResponse )</em></strong></p><p>This is called when an instance of this class is created. The instance object is initialized with the following arguments</p><p>The axiInterface argument is expected to be a hierarchical interface or signal bundle. It expects the signals and their widths to be grouped under &quot;aw_&quot;, &quot;ar_&quot;, &quot;w_&quot;, &quot;b_&quot;, &quot;r_&quot; sub-channels. This hierarchical interface is internally flattened attaching the sub-channel names as prefixes to the signal names. It is required to be flattened since the base-class expects a flat interface or a simple dictionary object.</p><p>The axiPrefix argument is a string (default empty string)  that can be added as a prefix to all the flattened signal names by certain methods.</p><p>The userMapRequest and userMapResponse arguments are expected to be arrays (default empty arrays). They are used to overwrite the signal mappings in the Initiator mapping table for the instance that is being created.</p><p><br/></p><p><em><strong>axiAxInterface ( )</strong></em></p><p>This returns the AXI REQ interface or the &quot;ax_&quot; interface which is used in the <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16163590/HW-CTF+axi_targ" data-linked-resource-id="16163590" data-linked-resource-version="45" data-linked-resource-type="page">HW-CTF axi_targ</a> (See block diagram). This interface is not part of the standard ARM AXI interface, and is created only as an internal interface for use within the AXI Native Layer in Symphony. It is the result of multiplexing the AR and AW channels of the AXI Interface and carries the same signals as the AR and AW signals in addition to the &quot;type&quot; signal to identify whether the request is a read-request or a write-request.</p><p><br/></p><p><strong><em>ctl2Axi ( ctlSignal, sel )</em></strong></p><p>This returns an array of strings which are either</p><p>1. AXI signal names</p><p>2. AXI signal bit-slices ( Ex: axi_ar_user[1:2], if axiPrefix = &quot;axi_&quot;)</p><p>3. Verilog Constant literals (Ex: 2'h0 )</p><p>All signal names will have the axiPrefix attached, which was passed as an argument in the constructor. All these values concatenated from MSB to LSB from array index to the last element, represents the value to be mapped to the given input CTL signal and in the selected channel ( argument sel) .</p><p><br/></p><p><em><strong>axi2Ctl ( axiSignal, sel )</strong></em></p><p>This returns an array of strings which are either</p><p>1. CTL signal names</p><p>2. AXI signal bit-slices ( Ex: axi_ar_user[1:2], if axiPrefix = &quot;axi_&quot;)</p><p>3. Verilog Constant literals (Ex: 2'h0 )</p><p>All signal names will have the axiPrefix attached, which was passed as an argument in the constructor. All these values concatenated from MSB to LSB from array index to the last element, represents the value to be mapped to the given input CTL signal and in the selected channel ( argument sel ).</p><p><br/></p><p><strong>ctlReqInterface ( direction, name )</strong></p><p>This returns an interface object (new-styled interface) of type <a class="external-link" href="https://confluence.arteris.com/display/ENGR/InterfaceCTL" rel="nofollow">InterfaceCTL</a>. This can then be directly used to generate CTL request interface internally inside the <a class="external-link" href="https://confluence.arteris.com/display/ENGR/atui_axi" rel="nofollow">atui_axi</a>.</p><p><br/></p><p><strong>ctlRespInterface ( direction, name )</strong></p><p>This returns an interface object (new-styled interface) of type <a class="external-link" href="https://confluence.arteris.com/display/ENGR/InterfaceCTL" rel="nofollow">InterfaceCTL</a>. This can then be directly used to generate CTL response interface internally inside the <a class="external-link" href="https://confluence.arteris.com/display/ENGR/atui_axi" rel="nofollow">atui_axi</a>.</p>