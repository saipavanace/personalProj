<h1 id="apb_async_adapter-parameters"><strong>parameters</strong></h1><h2 id="apb_async_adapter-apb_async_adapter"><strong>apb_async_adapter</strong></h2><pre>{<br/>  &quot;interfaces&quot; : { <br/>    &quot;inClkInterface&quot; : {InterfaceCLK},  // slave interface<br/>    &quot;outClkInterface&quot; : {InterfaceCLK}, // slave interface<br/>    &quot;inInterface&quot; : {InterfaceAPB},     // slave interface<br/>    &quot;outInterface&quot; : {InterfaceAPB},    // master interface<br/>    &quot;inPmaControlInterface&quot; : {InterfacePMAControl}, // Optional slave interface - required when inClkInterface clock domain is switchable<br/>    &quot;outPmaControlInterface&quot; : {InterfacePMAControl} // Optional slave interface - required when out ClkInterface clock domain is switchable <br/>  },<br/>  &quot;syncDepth&quot; : 2 or greater, <br/>  &quot;async&quot; :  boolean // true means clocks are async for timing reasons, false not async<br/>}</pre><h2 id="apb_async_adapter-apb_async_adapter_in"><strong>apb_async_adapter_in</strong></h2><pre>{<br/>  &quot;interfaces&quot; : { <br/>    &quot;clkInterface&quot; : {InterfaceCLK}, // slave interface<br/>    &quot;inInterface&quot; : {InterfaceAPB},  // slave interface<br/>    &quot;asyncInterfaceFwd&quot; : {InterfaceAsyncFIFO}, // master interface<br/>    &quot;asyncInterfaceBwd&quot; : {InterfaceAsyncFIFO}, // slave interface<br/>    &quot;pmaControlInterface&quot; : {InterfacePMAControl} // Optional slave interface - required when out ClkInterface clock domain is switchable <br/>  },<br/>  &quot;syncDepth&quot; : 2 or greater, <br/>  &quot;async&quot; : boolean // true means clocks are async for timing reasons, false not async<br/>}</pre><h2 id="apb_async_adapter-apb_async_adapter_out"><strong>apb_async_adapter_out</strong></h2><pre>{<br/>  &quot;interfaces&quot; : { <br/>    &quot;clkInterface&quot; : {InterfaceCLK}, // slave interface<br/>    &quot;outInterface&quot; : {InterfaceAPB}, // master interface<br/>    &quot;asyncInterfaceFwd&quot; : {InterfaceAsyncFIFO}, // slave interface<br/>    &quot;asyncInterfaceBwd&quot; : {InterfaceAsyncFIFO}, // master interface<br/>    &quot;pmaControlInterface&quot; : {InterfacePMAControl} // Optional slave interface - required when out ClkInterface clock domain is switchable <br/>  },<br/>  &quot;syncDepth&quot; : 2 or greater, <br/>  &quot;async&quot; : boolean // true means clocks are async for timing reasons, false not async<br/>}</pre><h2 id="apb_async_adapter-Interfacesused"><strong>Interfaces used</strong></h2><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168894/InterfaceCLK" data-linked-resource-id="16168894" data-linked-resource-version="5" data-linked-resource-type="page">InterfaceCLK</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168579/InterfaceAPB" data-linked-resource-id="16168579" data-linked-resource-version="2" data-linked-resource-type="page">InterfaceAPB</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16164503/InterfacePMAControl" data-linked-resource-id="16164503" data-linked-resource-version="6" data-linked-resource-type="page">InterfacePMAControl</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16169745/InterfaceAsyncFIFO" data-linked-resource-id="16169745" data-linked-resource-version="7" data-linked-resource-type="page">InterfaceAsyncFIFO</a></p><h2 id="apb_async_adapter-Modulesused"><strong>Modules used</strong></h2><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16158701/gen_async_adapter+and+gen_vc_async_adapter" data-linked-resource-id="16158701" data-linked-resource-version="20" data-linked-resource-type="page">gen_async_adapter_in</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16158701/gen_async_adapter+and+gen_vc_async_adapter" data-linked-resource-id="16158701" data-linked-resource-version="20" data-linked-resource-type="page">gen_async_adapter_out</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16163252/prot_reg" data-linked-resource-id="16163252" data-linked-resource-version="4" data-linked-resource-type="page">prot_reg</a></p><h2 id="apb_async_adapter-Description"><strong>Description</strong></h2><p>The below shows the block diagram:</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16170547/ApbAsyncBlkDiagram2ndVersion.png?api=v2"></span></p><p>In the above the depth of the async adapters is hard coded to 2. The reason for this is only one command can go back and forth at a time, so functionally a depth of one is only needed, but the gen_async_adapter blocks have a minimum depth of 2, because they use pointers into a circular FIFO.</p><h1 id="apb_async_adapter-Splittingcalculations">Splitting calculations</h1><p>There are two InterfaceAsyncFIFO interfaces that pass between in and out sides of the adapter. Here are there calculations for the two interfaces:</p><h2 id="apb_async_adapter-CommonCalculations">Common Calculations</h2><pre>var apb_params = interfaces.inInterface.params;<br/>var wData = apb_params.wData;<br/>var wAddr = apb_params.wAddr;<br/>var wPsel = 1;<br/>if (apb_params.wPsel !== undefined) {<br/>  wPsel = apb_params.wPsel;<br/>}<br/>var wProt = 0;<br/>if (apb_params.wProt !== undefined) {<br/>  wProt = apb_params.wProt;<br/>}<br/>var wStrb = 0;<br/>if (apb_params.wStrb !== undefined) {<br/>  if (apb_params.wStrb &gt; 0) {<br/>    wStrb = wData/8;<br/>  }<br/>}<br/>var wPSlverr = 0;<br/>if (apb_params.wPSlverr !== undefined) {<br/>  wPSlverr = apb_params.wPSlverr<br/>}</pre><h2 id="apb_async_adapter-asyncInterfaceFwd">asyncInterfaceFwd</h2><p>depth = 2<br/>async = async of block<br/>width = wAddr + wData + wStrb + wPsel + wProt + 1</p><h2 id="apb_async_adapter-asyncInterfaceBwd">asyncInterfaceBwd</h2><p>depth = 2<br/>async = async of block<br/>width = wData + wPSlverr</p>