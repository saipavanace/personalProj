<style type="text/css">/*<![CDATA[*/
div.rbtoc1759725306033 {padding: 0px;}
div.rbtoc1759725306033 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1759725306033 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class="toc-macro rbtoc1759725306033"><style>[data-colorid=v6fh2xoyh5]{color:#ffc400} html[data-color-mode=dark] [data-colorid=v6fh2xoyh5]{color:#ffc400}[data-colorid=y7edubmg7v]{color:#ffc400} html[data-color-mode=dark] [data-colorid=y7edubmg7v]{color:#ffc400}[data-colorid=ozj0lfzion]{color:#ffc400} html[data-color-mode=dark] [data-colorid=ozj0lfzion]{color:#ffc400}[data-colorid=irfkshk1oy]{color:#ffc400} html[data-color-mode=dark] [data-colorid=irfkshk1oy]{color:#ffc400}[data-colorid=rpr3ez229e]{color:#ffc400} html[data-color-mode=dark] [data-colorid=rpr3ez229e]{color:#ffc400}[data-colorid=tdqpbjeml0]{color:#ffc400} html[data-color-mode=dark] [data-colorid=tdqpbjeml0]{color:#ffc400}[data-colorid=b77b9p19um]{color:#ffc400} html[data-color-mode=dark] [data-colorid=b77b9p19um]{color:#ffc400}[data-colorid=mvxzdd8zrk]{color:#ffc400} html[data-color-mode=dark] [data-colorid=mvxzdd8zrk]{color:#ffc400}[data-colorid=q34cqwl6z3]{color:#ffc400} html[data-color-mode=dark] [data-colorid=q34cqwl6z3]{color:#ffc400}[data-colorid=g2cxn494jy]{color:#ffc400} html[data-color-mode=dark] [data-colorid=g2cxn494jy]{color:#ffc400}</style>
<ul class="toc-indentation">
<li><a href="#NCORESystemBooting-Introduction">Introduction</a></li>
<li><a href="#NCORESystemBooting-NcoreComponentDiscovery">Ncore Component Discovery</a>
<ul class="toc-indentation">
<li><a href="#NCORESystemBooting-xIDR:">xIDR:</a>
<ul class="toc-indentation">
<li><a href="#NCORESystemBooting-Check:">Check:</a></li>
</ul>
</li>
<li><a href="#NCORESystemBooting-xINFO:">xINFO:</a></li>
<li><a href="#NCORESystemBooting-GRBUNRRUCR:">GRBUNRRUCR:</a></li>
</ul>
</li>
<li><a href="#NCORESystemBooting-AddressSpaceConfiguration">Address Space Configuration</a>
<ul class="toc-indentation">
<li><a href="#NCORESystemBooting-DMIInterleavingConfiguration:">DMI Interleaving Configuration:</a>
<ul class="toc-indentation">
<li><a href="#NCORESystemBooting-xAMIGR:">xAMIGR:</a></li>
<li><a href="#NCORESystemBooting-xMIFSR:">xMIFSR:</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#NCORESystemBooting-ErrorDetectionandReportingConfiguration">Error Detection and Reporting Configuration</a></li>
<li><a href="#NCORESystemBooting-ProxyCacheConfiguration">Proxy Cache Configuration</a></li>
<li><a href="#NCORESystemBooting-SMCConfiguration">SMC Configuration</a></li>
<li><a href="#NCORESystemBooting-ScratchpadConfiguration">Scratchpad Configuration</a></li>
<li><a href="#NCORESystemBooting-VerifyifDCESnoopFilterisInitialized">Verify if DCE Snoop Filter is Initialized</a></li>
<li><a href="#NCORESystemBooting-CAIUCoherenceConfiguration">CAIU Coherence Configuration</a></li>
<li><a href="#NCORESystemBooting-Q-ChannelGatingSequence">Q-Channel Gating Sequence</a></li>
<li><a href="#NCORESystemBooting-SoftwareCreditProgramming">Software Credit Programming</a></li>
</ul>
</div><p /><h1 id="NCORESystemBooting-Introduction">Introduction</h1><p>This page is to thourougly document all the tasks we need to do as part of our booting sequence including documentation of all registers required to be accessed (read and write) and also mentioning the reference documents for these tasks. </p><h1 id="NCORESystemBooting-NcoreComponentDiscovery">Ncore Component Discovery</h1><p>This is for the software to read and identify the configuration of Ncore</p><h2 id="NCORESystemBooting-xIDR:">xIDR:</h2><p>Read this register for all AIUs in the system to get the following information:<br /></p><span class="confluence-embedded-file-wrapper image-left-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image image-left" alt="image-20240124-021724.png" width="450" src="https://arterisip.atlassian.net/wiki/download/attachments/444301322/image-20240124-021724.png?api=v2" /></span><h3 id="NCORESystemBooting-Check:">Check:</h3><p>Make sure bit 31 is always '1' after reading the register</p><p>NOTE: NRRI will always be '0' as Ncore does not support it.</p><h2 id="NCORESystemBooting-xINFO:">xINFO:</h2><p>Read this register to get information about the unit. <span data-colorid="ozj0lfzion">(Not needed in normal tests? - maybe we can skip the above register as well)</span></p><span class="confluence-embedded-file-wrapper image-left-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image image-left" alt="image-20240124-022728.png" width="450" src="https://arterisip.atlassian.net/wiki/download/attachments/444301322/image-20240124-022728.png?api=v2" /></span><h2 id="NCORESystemBooting-GRBUNRRUCR:">GRBUNRRUCR:</h2><p>Read this register to get the total number of AIUs in the system<span data-colorid="mvxzdd8zrk"> (Not needed in normal tests?)</span></p><span class="confluence-embedded-file-wrapper image-left-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image image-left" alt="image-20240124-022336.png" width="450" src="https://arterisip.atlassian.net/wiki/download/attachments/444301322/image-20240124-022336.png?api=v2" /></span><p /><h1 id="NCORESystemBooting-AddressSpaceConfiguration">Address Space Configuration</h1><h2 id="NCORESystemBooting-DMIInterleavingConfiguration:">DMI Interleaving Configuration:</h2><h3 id="NCORESystemBooting-xAMIGR:">xAMIGR: </h3><p>This must be configured to program desired MIGS (Memory Interleaving Groups) (--This is not programmed in cust_tb)</p><span class="confluence-embedded-file-wrapper image-left-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image image-left" alt="image-20240124-030744.png" width="450" src="https://arterisip.atlassian.net/wiki/download/attachments/444301322/image-20240124-030744.png?api=v2" /></span><h3 id="NCORESystemBooting-xMIFSR:">xMIFSR:</h3><p>This must be configured to program desired address bits for DMI interleaving (--This is not programmed in any of our environments)</p><span class="confluence-embedded-file-wrapper image-left-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image image-left" alt="image-20240124-030921.png" width="450" src="https://arterisip.atlassian.net/wiki/download/attachments/444301322/image-20240124-030921.png?api=v2" /></span><h1 id="NCORESystemBooting-ErrorDetectionandReportingConfiguration">Error Detection and Reporting Configuration</h1><p><span data-colorid="irfkshk1oy">We dont need to do these steps always to save time. We can just do them in a few testcases or error testcases</span></p><ul><li><p>Enable uncorrectable error detection by setting the appropriate error detection enable bits in xUEDR register of all Ncore units.</p></li><li><p>If desired enable uncorrectable error interrupts by setting the appropriate error interrupt enable bit in xUEIR register of all Ncore units.</p></li><li><p>Configure the correctable error control register xCECR to enable correctable error detection, interrupt and update the threshold as needed.</p></li><li><p>If desired timeout error threshold can be updated or disabled at xTOCR register of all Ncore units.</p></li></ul><h1 id="NCORESystemBooting-ProxyCacheConfiguration">Proxy Cache Configuration</h1><p>Following steps must be followed to configure and enable proxy cache:</p><ul><li><p>Read register XAIUPCISR to verify both tag and data RAM are initialized.</p><ul><li><p>IOAIU auto initializes SRAM for tag and data right out of reset.<span data-colorid="v6fh2xoyh5"> Hence most likely we can skip this step as by the time other registers are configured in boot sequence, this step is going to be complete (and thus we can save some cycles in Booting)</span></p></li></ul></li><li><p>Configure register XAIUPCTCR to enable the proxy cache in two steps:</p><ul><li><p>Enable cache look up by setting LookupEn</p></li><li><p>Enable cache allocation by setting AllocEn</p></li></ul></li></ul><h1 id="NCORESystemBooting-SMCConfiguration">SMC Configuration</h1><ul><li><p>Perform an &ldquo;Initialize all entries&rdquo; maintenance operation for the tag arrays by writing the appropriate values to the DMIUSMCMCR. <span data-colorid="q34cqwl6z3">(we can probably skip this step since tag arrays are automatically initialized)</span></p></li><li><p>Poll Maintenance Operation Active bit in DMIUSMCMAR until the bit equals zero.<span data-colorid="rpr3ez229e"> (skip this as well as most likely this will finish by the time other boot sequence configurations are complete)</span></p></li><li><p>Configure register DMIUSMCAPR to specify desired cache allocation policy</p></li><li><p>Perform an &ldquo;Initialize all entries&rdquo; maintenance operation for the data array by writing the appropriate values to DMIUSMCMCR.</p></li><li><p>Poll Maintenance Operation Active bit in DMIUSMCMAR until the bit equals zero.</p></li><li><p>If the DMI was configured with way partitioning capability, configure registers DMIUSMCWPCRx to setup way partitioning</p></li><li><p>Enable SMC lookups by writing a one to LookupEn bit in DMIUSMCCR.</p></li><li><p>Enable SMC fills by writing a one to AllocEn in DMIUSMCCR.</p></li></ul><h1 id="NCORESystemBooting-ScratchpadConfiguration">Scratchpad Configuration</h1><p>Following steps must be followed to configure and enable the scratchpad:</p><ul><li><p>Configure DMIUSMCSPBR 0 /1 with desired scratchpad base address.</p></li><li><p>Configure DMIUSMCPCR 0 with desired number of ways minus 1 to be used as scratchpad. Maximum value is limited by the total number of ways configured in the cache.</p></li><li><p>Configure DMIUSMCPCR1 with scratchpad size. The size must be be specified in number of cache lines and must be an integer multiple of the number of sets in the cache, times the desired number of ways for scratchpad size, minus 1.</p></li><li><p>Configure DMIUSMCPCR 0 to enable scratchpad by setting ScPadEn.</p></li></ul><h1 id="NCORESystemBooting-VerifyifDCESnoopFilterisInitialized">Verify if DCE Snoop Filter is Initialized</h1><ul><li><p>Read DCEUSFMAR register to check if DCE Snoop Filter is initialized (can be skipped to save time)</p></li></ul><h1 id="NCORESystemBooting-CAIUCoherenceConfiguration">CAIU Coherence Configuration</h1><ul><li><p>CHI, AXI4 with proxy cache, ACE, ACE-Lite and ACE-Lite-E are the interfaces which are considered coherent AIUs.</p></li><li><p>CAIU can attach itself to the coherency domain through the SYSCOREQ and SYSCOACK protocol as specified by ARM specification.</p></li><li><p>In case the CAIU does not have SYSCO signaling interface, they can attach themselves to coherency with the following protocol</p><ul><li><p>Read the xTAR register to confirm the current state of the AIU. <span data-colorid="g2cxn494jy">(check if we can skip this in normal testcases to save time)</span></p></li><li><p> Set SysCoAttach in xTCR to start the transition of the AIU into coherent state.</p></li><li><p>Poll the xTAR register SysCoAttached field to confirm that the AIU is in the coherent state. <span data-colorid="tdqpbjeml0">(check if we can skip this in normal testcases to save time)</span></p></li></ul></li><li><p>Steps to detach from coherency <span data-colorid="b77b9p19um">(not required during booting - check when we want to detach from coherency)</span></p><ul><li><p>Read the xTAR register to confirm the current state of the AIU.</p></li><li><p>Set SysCoAttach to '0' in xTCR to start the transition of the AIU into detached/Non-coherent state.</p></li><li><p>Poll the xTAR register SysCoAttached field to confirm that the AIU is in the detached/Non-coherent state</p></li></ul></li></ul><h1 id="NCORESystemBooting-Q-ChannelGatingSequence">Q-Channel Gating Sequence</h1><p><span data-colorid="y7edubmg7v">Not required during normal booting - need to find more information</span></p><h1 id="NCORESystemBooting-SoftwareCreditProgramming">Software Credit Programming</h1>