<p><style type='text/css'>/*<![CDATA[*/
div.rbtoc1759724685119 {padding: 0px;}
div.rbtoc1759724685119 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1759724685119 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class='toc-macro rbtoc1759724685119'>
<ul class='toc-indentation'>
<li><a href='#Ncore1.6-Requirements'>Requirements</a></li>
<li><a href='#Ncore1.6-Plan'>Plan</a>
<ul class='toc-indentation'>
<li><a href='#Ncore1.6-Usefuldiscussionemail:'>Useful discussion email:</a></li>
</ul>
</li>
</ul>
</div></p><h1 id="Ncore1.6-Requirements">Requirements</h1><ul><li>SystemC Models<ul><li class="O1">Loosely-Timed CCTI</li><li class="O1">Standalone pin adapter generation, for external interfaces</li><li class="O1">Optional TLM DMI support</li></ul></li></ul><p class="O1"> </p><p class="O1"> </p><h1 class="O1" id="Ncore1.6-Plan">Plan</h1><ul><li class="O1">v1.6 System Modeling Plan<ul><li class="O1">Automate Platform Architect Regression testing</li><li class="O1"><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168768/CCTI+Model+FD" data-linked-resource-id="16168768" data-linked-resource-version="7" data-linked-resource-type="page">CCTI Model</a></li><li class="O1">CSTI Model</li><li class="O1">TLM Interfaces on boundary of model (For Non-PA modeling)</li><li class="O1">Improve CSR Initilializer</li><li class="O1">Runtime Performance measuring infrastructure</li><li class="O1">Runtime Performance Improvements</li></ul></li><li class="O1">ARL paramterized custom validation support<br/><br/></li></ul><h2 class="O1" id="Ncore1.6-Usefuldiscussionemail:">Useful discussion email:</h2><p class="O1"><strong style="line-height: 1.42857;"><br/></strong></p><p class="O1"><strong style="line-height: 1.42857;">From:</strong><span style="line-height: 1.42857;"> Craig Forrest </span></p><p><strong>Sent:</strong> Monday, April 11, 2016 10:18 AM<br/> <strong>To:</strong> Benoit de Lescure &lt;benoit.delescure@<a class="external-link" href="http://arteris.com" rel="nofollow">arteris.com</a>&gt;<br/> <strong>Cc:</strong> Kent Orthner &lt;kent.orthner@<a class="external-link" href="http://arteris.com" rel="nofollow">arteris.com</a>&gt;; Alexis Boutillier &lt;alexis.boutillier@<a class="external-link" href="http://arteris.com" rel="nofollow">arteris.com</a>&gt;; Charlie Janac &lt;charlie.janac@<a class="external-link" href="http://arteris.com" rel="nofollow">arteris.com</a>&gt;; George Janac &lt;george.janac@<a class="external-link" href="http://arteris.com" rel="nofollow">arteris.com</a>&gt;; David Kruckemyer &lt;david.kruckemyer@<a class="external-link" href="http://arteris.com" rel="nofollow">arteris.com</a>&gt;; Kurt Shuler &lt;kurt.shuler@<a class="external-link" href="http://arteris.com" rel="nofollow">arteris.com</a>&gt;<br/> <strong>Subject:</strong> Re: Ncore Speed Enhancement for Loosely Timed Models: Requirements for V1.6</p><p> </p><p>Benoit, </p><p> </p><p>See below. </p><p> </p><p>On Apr 9, 2016, at 5:06 PM, Benoit de Lescure &lt;<a class="external-link" href="mailto:benoit.delescure@arteris.com" rel="nofollow">benoit.delescure@arteris.com</a>&gt; wrote:</p><p> </p><p>Hi Craig,</p><p> </p><p>Please find my comments in-line,</p><p> </p><p>Best Regards,</p><p>Benoit</p><p> </p><p> </p><p><strong>From: </strong>Craig Forrest &lt;<a class="external-link" href="mailto:craig.forrest@arteris.com" rel="nofollow">craig.forrest@arteris.com</a>&gt;<br/> <strong>Date: </strong>Friday, April 8, 2016 at 3:48 PM<br/> <strong>To: </strong>Benoit de Lescure &lt;<a class="external-link" href="mailto:benoit.delescure@arteris.com" rel="nofollow">benoit.delescure@arteris.com</a>&gt;, Kent Orthner &lt;<a class="external-link" href="mailto:kent.orthner@arteris.com" rel="nofollow">kent.orthner@arteris.com</a>&gt;<br/> <strong>Cc: </strong>Alexis Boutillier &lt;<a class="external-link" href="mailto:alexis.boutillier@arteris.com" rel="nofollow">alexis.boutillier@arteris.com</a>&gt;, Charlie Janac &lt;<a class="external-link" href="mailto:charlie.janac@arteris.com" rel="nofollow">charlie.janac@arteris.com</a>&gt;, George Janac &lt;<a class="external-link" href="mailto:george.janac@arteris.com" rel="nofollow">george.janac@arteris.com</a>&gt;, David Kruckemyer &lt;<a class="external-link" href="mailto:david.kruckemyer@arteris.com" rel="nofollow">david.kruckemyer@arteris.com</a>&gt;, Kurt Shuler &lt;<a class="external-link" href="mailto:kurt.shuler@arteris.com" rel="nofollow">kurt.shuler@arteris.com</a>&gt;<br/> <strong>Subject: </strong>Ncore Speed Enhancement for Loosely Timed Models: Requirements for V1.6</p><p> </p><p>Hi All, </p><p> </p><p>Here is a detailed list of a first stage in speed improvements for loosely timed models for Ncore, for a “Ncore 1.6 timeframe”.</p><p>Note that their is an explicit assumption that all of systemC integration capabilities described fro V1.5 are available. </p><p>Note: there are a longer term list of improvements that can be implemented. However, this needs to be done carefully and methodically, and based on learnings from this </p><p>first phase of work. </p><p> </p><p>A.<strong> </strong>Improve the ACHL RTL code generator with the goal of improving the execution speed of Concerto units. Specific improvements include, but are not limited to:</p><p>1. Merge separate “clocked” RTL procedural constructs, with the same clock and reset triggers, into single procedural constructs. </p><p>2. Eliminate the usage of “wire&quot; constructs as a container for constant values. </p><p>3. Only generate single RTL module definitions, that are instantiated multiple times, but are functionally identical. Note, currently in many instances, multiple module definitions </p><p>are created for *exactly* the same logic. </p><p> </p><p>B. Build a TLM to SFI “master” pin adapter. </p><p>1. The interface must have the capability to complete all phases of a SFI transaction on the SFI pins. </p><p>2. An SFI transaction will correspond to exactly one TLM transaction. There will *NOT* be a separate TLM transition per SFI transaction phase. </p><p>3. The SFI 2 TLM interface may transmit the corresponding TLM transaction from a SFI transaction after the first phase of the SFI transaction. It may not transmit a subsequent TLM transaction until the receipt of the first phase of the next SFI transaction. </p><p>4. There is no propagation of any flow control into the TLM transaction. </p><p>5. The data payload for the SFI transaction is discarded and is not included in the TLM transaction. </p><p> </p><p>[Benoit] As I reported to you in an email 4/7, it is not acceptable to discard the data payloads. Our first customer NXP has explicitly requested the model to be data accurate. Please add this requirement to the development.</p><p> </p><p>And as I reported in my email on April 5:</p><p>“Note that more precise functional modeling is achievable (<strong>in the future</strong>) by supporting DMI (TLM Direct Memory Interface) access to a single shared common coherent “main&quot; memory, </p><p>in the AIU’s [SFI pin interface to/from TLM] port adapters.”</p><p>I am happy to consider adding this after this initial phase of LT model speed optimizations. </p><p>Furthermore, all of our initial customers have communicated they are not interested in precise data modeling in their FT models. And if they are, the slower precise models are available. </p><p> </p><p> </p><p>C. Build a TLM to SFI “slave” pin adapter. </p><p>1. The interface must have the capability to complete all phases of a SFI transaction on the SFI pins. </p><p>2. An SFI transaction will correspond to exactly one TLM transaction. There will *NOT* be a separate TLM transition per SFI transaction phase. <br/> 3. The TLM 2 SFI interface may start the first phase of an SFI transaction when receiving a TLM transaction.</p><p>4. The TLM 2 SFI interface must observe the flow control handshake signals on the relevant SFI pins (i.e. Ready)</p><p>5. The TLM 2 SFI interface must complete all phases of the SFI transaction before accepting a new TLM transaction.</p><p>[NOTE: it is TBD where the data payload size value comes from in a TLM transaction for the data response in a read transaction].</p><p>6. The TLM 2 SFI interface must generate the data payload for transmitting the corresponding TLM transaction from a SFI transaction after the first phase of the SFI transaction. </p><p>The payload data may be either the transaction address replicated across the payload, or zero. Special handling may be necessary for DVM transactions. </p><p>7. The TLM 2 SFI interface must allocate Transaction IDs and maintain a table of Transaction IDs and TLM callback functions so that when a response is received on the pin interface, </p><p>the callback function is called to properly terminate the function. </p><p> </p><p>E. Build OCP slave pin adapters to keep the slave CS pin interfaces quiescent (one per unit). </p><p><br/> F. Implement CCTI in pure TLM systemC. </p><p>1. This is modeled essentially as a cross bar switch. </p><p>2. Each ingress point is bound to a single SFI 2 TLM master adapter. </p><p>3. Each egress point is bound to a TLM 2 SFI slave adapter. </p><p>4. Each egress point has a target address range. This is specified from a data structure generated by Concerto </p><p>5. Each TLM transaction received at an ingress points is examined and its transaction address is used to select an egress point. The transaction is forwarded to the egress point. </p><p>6. The transit delay from each ingress point to each egress point is selected from a Concerto generated delay table. </p><p>[Benoit] The model will have to correctly simulate the effects of the transport configuration on performances. It is especially critical that latencies be modeled accurately - since this is one of the basic metric all our prospects care about. </p><p>It is also critical that we model correctly the effects of clock domain crossings, as well as rate adaptation, since in v1.5 we will support different data width for different Ncore units. Rate adaptation is about sizing correctly buffers inside the transport. </p><p>From what I understand of your proposal, these mechanisms will not be modeled correctly. Can you comment? </p><p> </p><p>As I stated in my email on April 5th, the CCTI is managed with credit management. As such, there is no head-of-line blocking to be modeled. Therefore, ingress-egress pair wise latency is an excellent model for all of the effects you outline above. </p><p>[Clearly there needs to be some work in generating this data. And there are a variety of ways that this can be generated: from manual estimation to measurement from our latency tests in our generated RTL test benches]</p><p>And transient interference should be close to zero impact — and if it is an issue, we can adjust the pair-wise latency tables. </p><p>This is an excellent example on how to take architectural knowledge of the problem space and provide a modeling speedup. </p><p> </p><p>Furthermore, correlation of performance is always possible by creating a (slower) precise systemC model and re-running simulations. </p><p> </p><p> </p><p>At the moment engineering plan is to use a FlexNoC AV model for the CCTI, which seems to give adequate results both in term of feature set and performances. I agree that in the long term we need to become independent from FlexNoC but in the “v1.6” timeframe this solution seems the most appropriate. </p><p> </p><p>I am completely opposed to this FN AV integration plan. The reasons being:</p><p>1. It will be slower.  </p><p>2. At this stage any further integration of FN IP will have to be redone, so it is 100% wasted effort. </p><p>3. It is far easier to implement a pure TLM CCTI</p><p>4. Dealing with additional adapters and NTTP in CCTI is adding un-needed complexity. </p><p> </p><p> </p><p> </p><p>G. A new top level systemC module — for the Ncore coherent subsystem — with parameter values generated from Concerto, that:</p><p>1. Creates all of the Ncore units and the CCTI </p><p>2. Creates all of the SFI 2 TLM and TLM 2 SFI adapters and binds these to Ncore unit SFI pin interfaces<br/> 3. Binds all of the TLM interfaces from the adapters to the CCTI. An Ncore generated data structure is used bind the correct Ncore unit to the correct egress point. </p><p>4. Create and bind OCP pin adapters to all concerto unit CS OCP interfaces</p><p>5. Creates all necessary communication channels to implement the Ncore unit level connectivity and binds all of these channels to the appropriate port adapters</p><p>6. For all external connections, the appropriate FT-xxx to pin adapters need to be created and bound to all external facing pin interfaces. [Benoit] It should be the TLM-NTTP interface used by FlexNoC in the v1.6 timeframe, since seamless connectivity to FlexNoC is a must have.</p><p> </p><p>Please re-read. This is for the “Ncore coherent subsystem” only. There are no exposed FlexNoc interfaces. </p><p> </p><p> </p><p>H. For Ncore systems that include NCTIs, a 2 level system needs to be built.</p><p>1. The Ncore coherent subsystem is generated (as per G.). <em>This is a new, albeit straight forward capability to Ncore — the ability to generate a standalone </em></p><p><em>coherent subsystem from a larger design that includes one or more NCTIs.</em></p><p>2. Each individual NCTI is generated into a separate standalone FlexNoc systemC AV model, with external TLM NTTP interfaces. </p><p>3. All NCTI interfaces that are to be connected to the Ncore coherent subsystem have TLM NTTP to FT-xxx port adapters bound to them [Benoit] I do not understand the benefit. I think we should be natively TLM-NTTP in this version. I don’t think a dependency with Synopsys is better than one with Qualcomm. </p><p> </p><p>Firstly, why would be make Ncore NC-connectivity *only* compatible with NTTP? No-one outside of Qualcomm cares about NTTP. What they care about is connecting their 3rd party IP models up to the interconnect. </p><p>As such, at this point in time, FT-xxx is an excellent choice. FT-xxx has the following advantages:</p><p>            a. If it is used in a PA environment, the full advantages of FT semantics are available. </p><p>            b. If it is used outside of a PA environment — or to connect to non-FT-xxx compliant TLM interfaces —  the FT-xxx port adapter will adjust the exposed protocol to raw TLM semantics only. This is defined behavior for FT-xxx semantics. </p><p> </p><p> </p><p>4. All connections between each of the NCTI and the Ncore coherent subsystem are made at the TLM (or FT TLM level).</p><p>5. The complete Ncore interconnect is wrapped into its own “top” level model. </p><p> </p><p>Note, all of the description above is meant to be illustrative of what is required, not 100% complete. That is, I am certain some details hare missing. </p><p> </p><p>Please email and comments and/or corrections.</p><p> </p><p>regards</p><p>csf</p>