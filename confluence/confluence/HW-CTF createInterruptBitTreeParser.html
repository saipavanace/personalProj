<h2 id="HW-CTFcreateInterruptBitTreeParser-Path">Path</h2><p>hw-lib/js/sym_csr_lib.js</p><h2 id="HW-CTFcreateInterruptBitTreeParser-Description">Description</h2><p>This is a factory function that returns a parser object with methods to parse the &quot;<em>interruptBitTrees</em>&quot; JSON object (described here: <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156456/HW-CTF+Generating+Interrupt+Status+Bit+Trees+from+IP-XACT+register+descriptions" data-linked-resource-id="16156456" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF Generating Interrupt Status Bit Trees from IP-XACT register descriptions</a>). Internally the function converts and stores the &quot;<em>interruptBitTrees</em>&quot; JSON object as an array of trees one for each interrupt pin coming out of the DUT. A node in the tree stores an object that represents an interrupt valid/status bit. The children nodes represent interrupt bits that can set the interrupt bit in the parent node. An interrupt-bit object has the following structure:<br/><strong>Interrupt bit object</strong> structure:<br/>{<br/>     <em>statusBit</em>: A positive integer or zero. Bit position of the interrupt status or valid bit in the interrupt register.<br/>     <em>statusRegister</em>: A string. Name of the interrupt register that contains the above status bit.<br/>     <em>addrBlock</em>: A string. Name of the address block that has the above register.<br/>     <em>blockID</em>: A positive integer or zero. Block ID of the Symphony (software-visible) block that has the interrupt register.<br/>     <em>maskBit</em>: A positive integer or zero. Bit position of the interrupt mask bit in the interrupt mask register.<br/>     <em>maskRegister</em>: A string. Name of the mask register that contains the above mask bit.<br/>}<br/><br/>Most parser methods return arrays of <em>bit</em> objects described above. Sometimes however it's more useful for the parser methods to group together interrupt bits that belong to the same register into a single object with the following structure:<br/><strong>Interrupt register object</strong> structure:<br/>{<br/>  <em>name</em>: A string. Name of the register that has interrupt bits<br/>  <em>addrBlock</em>: A string. Name of the address block that has the above register.<br/>  <em>blockID</em>: A positive integer or zero. Block ID of the Symphony (software-visible) block that has the interrupt register.<br/>  <em>statusBits</em>: An array of <em>statusBit</em> types. Array of interrupt bit positions if any present in the register.<br/>  <em>maskBits</em>: An array of <em>maskBit</em> types. Array of mask bit positions if any present in the register.<br/>}</p><h2 id="HW-CTFcreateInterruptBitTreeParser-Usage">Usage</h2><p>const parser   = createInterruptBitTreeParser( interruptBitTrees );</p><p>The function takes a single parameter &quot;interruptBitTrees&quot; which is expected to be a JSON object with structure described here <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156456/HW-CTF+Generating+Interrupt+Status+Bit+Trees+from+IP-XACT+register+descriptions" data-linked-resource-id="16156456" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF Generating Interrupt Status Bit Trees from IP-XACT register descriptions</a>). It returns a parser object with a set of methods described below</p><h2 id="HW-CTFcreateInterruptBitTreeParser-Methods">Methods</h2><p>The parser provides the following functions to parse an &quot;<em>interruptBitTrees</em>&quot; JSON object:</p><h4 id="HW-CTFcreateInterruptBitTreeParser-getPinNames()">getPinNames( )</h4><p>Returns an array of pin names or tree names present in the &quot;<em>interruptBitTrees</em>&quot; JSON object.</p><h4 id="HW-CTFcreateInterruptBitTreeParser-getReg(addrBlock,name)"><br/>getReg( addrBlock, name  )</h4><p>Returns an interrupt register object (described above) with the matching addrBlock (string) and name (string). The name can match the name of either a register with only interrupt bits or a register with only mask bits or a register with both types of bits. The function searches through all nodes of the tree to gather all the status and mask bits in that register and puts them all together in one interrupt register object.<br/><br/></p><h4 id="HW-CTFcreateInterruptBitTreeParser-getTree(pinName)">getTree( pinName )</h4><p>Returns a tree object i.e. an object returned by the <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16157049/HW-CTF+createInterruptPinParser" data-linked-resource-id="16157049" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF createInterruptPinParser</a>( ) function.</p><h2 id="HW-CTFcreateInterruptBitTreeParser-Usageexamples:">Usage examples:</h2><p>// Creating a tree / pinParser object<br/>const parser                     = createInterruptBitTreeParser( interruptBitTrees );     // Parser for parsing the whole <em>interruptBitTrees</em><span> </span>array<br/>const ctlBwir                    = parser.getReg( &quot;atu_atuI_0&quot;, &quot;CTLBWIR&quot; );  // Returns an interrupt register object with matching addrBlock and register names.<br/>const maskValue              = computeMaskValue(ctlBwir.maskBits);       // ctlBwir.maskBits array can now be used to compute say mask value to enable its interrupt.<br/><br/>const pins                        = parser.getPinNames( );  // Returns an array of strings that must match the names of master interrupt interfaces of DUT<br/>const tree                         = parser.getTree( pins[0] ); // Returns a parser to pass an interrupt tree under an interrupt pin.</p><p>tree.find(bit =&gt; (bit.addrBlock === &quot;atu_atuI_0_CTL&quot;) &amp;&amp; (bit.statusRegister === &quot;CTLBWIR&quot;) &amp;&amp; (bit.statusBit === 0)); // Returns the corresponding<span> </span><em>bit</em><span> </span>object<br/>tree.findPath(bit =&gt; (bit.addrBlock === &quot;atu_atuI_0_CTL&quot;) &amp;&amp; (bit.statusRegister === &quot;CTLBWIR&quot;) &amp;&amp; (bit.statusBit === 0));  // Returns an array of<span> </span><em>bit</em><span> </span>objects from the top of the tree to the interrupt bit specified</p><p><span class="legacy-color-text-blue3">for( const register of tree) {</span><br/><span class="legacy-color-text-blue3">     // Print list of interrupt registers inside block with ID 3</span><br/><span class="legacy-color-text-blue3">}</span></p><p>const bitIterator           = parser.getTree( pins[1] );   // Returns an iterator to iterate over all interrupt bits that drive pins[1]<br/>const bitArray              = Array.from(bitIterator);    // Returns an array of all interrupt bits that drive interrupt pin, pins[1]</p><p>const topIntAccumulatorReg     = tree.getSrcReg( ); // Returns the top interrupt accumulator register object<br/>const level2InterruptReg            = topIntAccumulatorReg.getSrcReg( 3 ); // Returns the interrupt register that's driving bit 3 of the top interrupt accumulator register<br/>const level3InterruptReg            = level2InterruptReg.getSrcReg( 1 ); // Returns the interrupt register that's driving bit 1 of the level2InterruptReg returned above.</p><p><br/></p>