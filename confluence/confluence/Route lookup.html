<p>The SMI packetizer can perform route lookup inside it. Typically the route computed depends primarily on the target ID or destination that the packet is headed toward. The lookup table itself is specified via a parameter, ‘pathLut’.</p><p>An example of what the pathLut parameter looks like is shown below:</p><p>pathLut for I0: <br/>[ <br/>  { targ_id: “2’b00”, route: “4’b0010” },  <br/>  { targ_id: “2’b01”, route: “4’b0110” },<br/>  { targ_id: “2’b11”, route: “4’b1001” }<br/>]<br/><br/>In the above example, the width of the targ_id signal on the SMI interface is assumed to be 2 bits and the width of the ‘H_route’ field in the ATP packet is assumed to be 4 bits. The pathLut parameter for a packetizer is expected to be computed by Maestro software by looking at the switch-topology network and using a static routing method such as X-Y routing to compute routes for each of the destinations from the packetizer.</p><p /><p><strong>Proposed improvements for stamp-ability of packetizers:</strong></p><p>In the above example, if another source or initiator, say I1, requires sending packets to 3 other targets:</p><p>pathLut for I1:<br/>[<br/>  { targ_id: “2’b00”, route: “4’b1010” },<br/>  { targ_id: “2’b01”, route: “4’b1110” },<br/>  { targ_id: “2’b11”, route: “4’b1101” }<br/>]</p><p>The same packetizer as I0 cannot be stamped since the pathLut parameter values are different in both cases. One solution to allow stamp-ability is to expand the LUTs of both I0 and I1 to include entries in both of the original tables and to add extra bit(s) for the LUT key (“targ_id”) (now 3-bits) to keep the keys unique:</p><p>pathLut for both I0 and I1:<br/>[<br/>  { targ_id: “3’b<strong>0</strong>00”, route: “4’b0010” },  <br/>  { targ_id: “3’b<strong>0</strong>01”, route: “4’b0110” },<br/>  { targ_id: “3’b<strong>0</strong>11”, route: “4’b1001” },<br/>  { targ_id: “3’b<strong>1</strong>00”, route: “4’b1010” },<br/>  { targ_id: “3’b<strong>1</strong>01”, route: “4’b1110” },<br/>  { targ_id: “3’b<strong>1</strong>11”, route: “4’b1101” }<br/>]</p><p>The extra bit(s) added above will be called LUT ID bits, since they effectively allow choosing different sets of entries (or simply LUTs).  </p><p /><p><strong>Assigning LUT ID bits</strong></p><p>We propose assigning all possible Source ID values that can appear on these packetizer SMI messages as the LUT ID bits. The packetizer design will need to support the option of concatenating SMI Source and Target IDs to be used as input key to the LUT. This means the packetizer can use { SMI NDP SID, SMI NDP TID } as the input to the path LUT. A new boolean JS parameter, <strong>routeOnSid</strong>, will need to be set to true by Maestro software to enable this feature.</p><p>In <strong>Ncore CDTI</strong> case, the Source ID itself is a concatenation of two IDs - { FUnitID, PortID }. This means Maestro software however will need to enumerate all possible values of Source ID depending on its relationship with FUnitID and Port ID. The packetizer design itself can remain oblivious to what the Source ID is composed of or its relationship to FUnitIDs and PortIDs.</p><p /><p>As an example suppose, FUnit ID width = 1 bit, and Port ID width = 1 bit,</p><p>The various possible values of { FUnitID, PortID } = 2’b00, 2’b10, 2’b01, and 2’b11. Using this the pathLut pararm for both I0 and I1 can be written as:</p><p>pathLut for both I0 and I1:<br/>[<br/>  // Port ID 0 entries<br/>  { targ_id: “4’b<strong>00</strong>00”, route: “4’b0010” },  <br/>  { targ_id: “4’b<strong>00</strong>01”, route: “4’b0110” },<br/>  { targ_id: “4’b<strong>00</strong>11”, route: “4’b1001” },<br/>  { targ_id: “4’b<strong>10</strong>00”, route: “4’b1010” },<br/>  { targ_id: “4’b<strong>10</strong>01”, route: “4’b1110” },<br/>  { targ_id: “4’b<strong>10</strong>11”, route: “4’b1101” },<br/><br/>  // Port ID 1 entries<br/>  { targ_id: “4’b<strong>01</strong>00”, route: “4’b0010” },  <br/>  { targ_id: “4’b<strong>01</strong>01”, route: “4’b0110” },<br/>  { targ_id: “4’b<strong>01</strong>11”, route: “4’b1001” },<br/>  { targ_id: “4’b<strong>11</strong>00”, route: “4’b1010” },<br/>  { targ_id: “4’b<strong>11</strong>01”, route: “4’b1110” },<br/>  { targ_id: “4’b<strong>11</strong>11”, route: “4’b1101” }<br/>]</p><p>The above table values as expected to be passed by Maestro to create the packetizer that can now be stamped or tiled.</p><p /><p><strong>Support for tiling in Legato ATUs</strong></p><p>The solution discussed above for packetizer routing tables also applies to packetizers in <strong>Legato ATUs in the CSTI network</strong>. The SMI packetizer is part of the packet layer of the ATU. In this case, the ATU unit IDs are used directly as Source IDs in the SMI messages received by the packetizer. So the LUT ID values to be generated = all possible ATU ID values.</p><p>However the ATUs cannot yet be tiled because of another limitation today - their unit IDs are passed as a design parameter by Maestro software. For ATUs to support tiling, the unit IDs must instead come from tie-off bits, just as in the case of Ncore units.</p><p /><p /><p>Upper Bound for number of routing table entries for a 2 GHz clock</p><p>Number of logic levels = ceil( log2( N ) ) + c.</p><p>where c is a constant number of logic levels that doesn’t vary with number of entries = 3 or 4 today.</p><p>Clock period for 2GHz = 500 ps.</p><p />