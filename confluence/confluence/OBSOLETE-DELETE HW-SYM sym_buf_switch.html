<h1 id="OBSOLETE-DELETEHW-SYMsym_buf_switch-javascriptparameters">javascript parameters</h1><pre><span>interfaces:{</span></pre><pre>  clkInterface: {name: &quot;a_string&quot;, params: {}, direction: &quot;master&quot; or &quot;slave&quot;, interface: &quot;a_string&quot;},</pre><pre>  cfgInterface: {name: &quot;a_string&quot;, params: {}, direction: &quot;master&quot; or &quot;slave&quot;, interface: &quot;a_string&quot;}, // Optional based on weightsProg</pre><pre>  protectionInterface: {name: &quot;a_string&quot;, params: {}, direction: &quot;master&quot; or &quot;slave&quot;, interface: &quot;a_string&quot;}, // Optional based on protectionStyle</pre><pre>  inInterfaces: [</pre><pre>    {name: &quot;a_string&quot;,</pre><pre>     params: {nVc: positive integer, wBus: positive integer, wProt: non negative integer},</pre><pre>     direction: &quot;slave&quot;, </pre><pre>     interface: &quot;InterfaceATP&quot;, </pre><pre>     pktDef: {params: {ATP Packet Params}, packet: &quot;a_string&quot;}},</pre><pre>    {},{}], //array depth sets numIngress, width of &quot;valid&quot; in interface sets numVc</pre><pre>  outInterfaces: [</pre><pre>    {name: &quot;a_string&quot;,</pre><pre>     params: {nVc: positive integer, wBus: positive integer, wProt: non negative integer},</pre><pre>     direction: &quot;master&quot;,</pre><pre>     interface: &quot;InterfaceATP&quot;,</pre><pre>     pktDef: {params: {ATP Packet Params}, packet: &quot;a_string&quot;}},</pre><pre>    {},{}] //array depth sets numEgress</pre><pre>}, </pre><pre>bufLayer0: {depth: 1 or greater, pipeForward: boolean, simplePipe: boolean, circular: boolean}, // see sym_pipe_adapter for parameter descriptions</pre><pre>bufLayer1: {depth: 0 or greater, pipeForward: boolean, pipeBackward: boolean, simplePipe: boolean, circular: boolean}, // see sym_pipe_adapter for parameter descriptions</pre><pre>bufLayer2: {depth: 0 or greater, pipeForward: boolean, pipeBackward: boolean, simplePipe: boolean, circular: boolean}, // see sym_pipe_adapter for parameter descriptions</pre><pre>mstrArbLck: boolean // true master arb locks, false master arb doesn't lock. Default false.</pre><pre>vcLckStyleVld: boolean // Lock Style of VC arbiters. true locks on valid, false locks on ready. Default false.</pre><pre>mstrLckStyleVld: boolean // Lock Style of master arbiter. true locks on valid, false locks on ready. Default false.</pre><pre>weightsProg: Boolean, </pre><pre>numPri: positive integer, </pre><pre>routeFields: [{rf:[&quot;a_string&quot;,&quot;&quot;,&quot;&quot;]}, // array depth variable</pre><pre>  {rf:[]},{rf:[]}], // array depth = numIngress </pre><pre>routeShift: [non negative integer, , ,] array depth = numIngress </pre><pre>vcShiftMap: null or </pre><pre>            [{vcs:[</pre><pre>                   {mapFunc{ shiftFields: ['string','string'], // Header fields to concatenate to create shift bit pattern. Can be null of empty, but shiftTable can only have one entry.</pre><pre>                             shiftTable: [{vc: 0 or pos int, // VC to map to</pre><pre>                                           shiftPat: 'string'}, // Pattern to map to indicated VC. </pre><pre>                                           {},{}] // max array depth = numVc},<br/>                   {},{}]}, // array depth = numVc</pre><pre>             {},{}], // array depth = numIngress</pre><pre>routeMap: [{rm:[{bitPat: &quot;a_string&quot;, egressPort: non negative integer},{},{}]}, // array depth min = 1, array depth max = numEgress</pre><pre>           {rm:[]},{rm:[]}], // array depth = numIngress </pre><pre>arbType: {egress: ['string',,], // array depth = numEgress </pre><pre>          vcs: [{vc: ['string',,]} // array depth = numEgress</pre><pre>          ,{},{}] // array depth = numVc </pre><pre>weights: {egress: [{w: [1,1,1]}, // array depth = numVc</pre><pre>                   {},{}], // array depth = numEgress </pre><pre>          vcs: [{vc: [{w: [1,1,1]}, // array depth = number of ingress ports to switch vc0 if no port pruning in portMap</pre><pre>                         {},{}]}, // array depth = numEgress</pre><pre>               {},{}] // array depth = numVc</pre><pre>vcMap: {</pre><pre>  ingress: [{vm:[non negative integer,,]}, // array depth min = 1, array depth max = numVc</pre><pre>  {vm:[]},{vm:[]}], // array depth = numIngress</pre><pre>  egress: []}, // some format as ingress, array depth = numEgress </pre><pre>portMap: [</pre><pre>    {ports: [non negative integer,,]}, // array depth min = 1, array depth max = numIngress </pre><pre>    {},{}],  // array depth = numEgress, Maps which ingress inputs go to which egress ports. <br/>               (This filtering is done on the egress ports of the vc switches)</pre><pre>&quot;protectionStyle&quot; : null or {<a class="external-link" href="https://confluence.arteris.com/display/ENGR/protectionStyle" rel="nofollow">protectionStyle</a>} // applies to internal registers, not to interface.</pre><h1 id="OBSOLETE-DELETEHW-SYMsym_buf_switch-I/O">I/O</h1><pre>var clkInterfaceFunc = new obj.userLib[interfaces.clkInterface.interface];</pre><pre>var clkInterface = clkInterfaceFunc.getSignalsBundle(interfaces.clkInterface.params);</pre><pre>u.interface(interfaces.clkInterface.name, 'slave', clkInterface);</pre><pre>if (weightsProg === &quot;yes&quot;) {</pre><pre>  var cfgInterfaceFunc = new obj.userLib[interfaces.cfgInterface.interface];</pre><pre>  var cfgInterface = cfgInterfaceFunc.getSignalsBundle(interfaces.cfgInterface.params);</pre><pre>  u.interface(interfaces.cfgInterface.name, 'slave', cfgInterface);</pre><pre>} </pre><pre>var inInterfaceFuncs = []; </pre><pre>var inInterfaces = [];</pre><pre>for (i = 0; i &lt; interfaces.inInterfaces.length; i++) { </pre><pre>  inInterfaceFuncs[i] = new obj.userLib[interfaces.inInterfaces[i].interface]; </pre><pre>  inInterfaces[i] = inInterfaceFuncs[i].getSignalsBundle(interfaces.inInterfaces[i].params);</pre><pre>  u.interface(interfaces.inInterfaces[i].name, 'slave', inInterfaces[i]);</pre><pre>}</pre><pre>var outInterfaceFuncs = []; </pre><pre>var outInterfaces = [];</pre><pre>for (i = 0; i &lt; interface.outInterfaces.length; i++) {</pre><pre>  outInterfaceFuncs[i] = new obj.userLib[interfaces.outInterfaces[i].interface]; </pre><pre>  outInterfaces[i] = outInterfaceFuncs[i].getSignalsBundle(interfaces.outInterfaces[i].params);</pre><pre>  u.interface(interfaces.outInterfaces[I].name, 'master', outInterfaces[i]);</pre><pre>}</pre><pre>if (protectionStyle !== &quot;&quot;) {</pre><pre>  var protectionInterfaceFunc = new obj.userLib[interfaces.protectionInterface.interface];</pre><pre>  var protectionInterface = protectionInterfaceFunc.getSignalsBundle(interfaces.protectionInterface.params);</pre><pre> u.interface(protectionInterface.name, 'slave', protectionInterface);</pre><pre>}</pre><pre>or</pre><pre>u.nInterfaces(interfaces);</pre><h1 id="OBSOLETE-DELETEHW-SYMsym_buf_switch-FunctionsUsed">Functions Used</h1><p><br/></p><h1 id="OBSOLETE-DELETEHW-SYMsym_buf_switch-ModulesUsed">Modules Used</h1><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16169027/OBSOLETE-DELETE+HW-SYM+sym_switch" data-linked-resource-id="16169027" data-linked-resource-version="50" data-linked-resource-type="page">OBSOLETE-DELETE HW-SYM sym_switch</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168263/OBSOLETE-DELETE+HW-SYM+sym_pipe_adapter" data-linked-resource-id="16168263" data-linked-resource-version="19" data-linked-resource-type="page">OBSOLETE-DELETE HW-SYM sym_pipe_adapter</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16170467/OBSOLETE-DELETE+HW-SYM+sym_vc_pipe_adapter" data-linked-resource-id="16170467" data-linked-resource-version="13" data-linked-resource-type="page">OBSOLETE-DELETE HW-SYM sym_vc_pipe_adapter</a></p><h1 id="OBSOLETE-DELETEHW-SYMsym_buf_switch-InterfacesUsed">Interfaces Used</h1><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16164453/HW-SYM+InterfaceATP" data-linked-resource-id="16164453" data-linked-resource-version="12" data-linked-resource-type="page">HW-SYM InterfaceATP</a></p><p>InterfaceAPB</p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168667/InterfacePROT" data-linked-resource-id="16168667" data-linked-resource-version="16" data-linked-resource-type="page">InterfacePROT</a></p><h1 id="OBSOLETE-DELETEHW-SYMsym_buf_switch-Description">Description</h1><p>The below block diagram is an example of a 3x3 sym_buf_switch with 3 VCs. All switches shown are instantiations of <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16169027/OBSOLETE-DELETE+HW-SYM+sym_switch" data-linked-resource-id="16169027" data-linked-resource-version="50" data-linked-resource-type="page">OBSOLETE-DELETE HW-SYM sym_switch</a>. All buffers show are either <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168263/OBSOLETE-DELETE+HW-SYM+sym_pipe_adapter" data-linked-resource-id="16168263" data-linked-resource-version="19" data-linked-resource-type="page">OBSOLETE-DELETE HW-SYM sym_pipe_adapter</a> or <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16170467/OBSOLETE-DELETE+HW-SYM+sym_vc_pipe_adapter" data-linked-resource-id="16170467" data-linked-resource-version="13" data-linked-resource-type="page">OBSOLETE-DELETE HW-SYM sym_vc_pipe_adapter</a>. The buffers in Buffer Layer 0 are shown, but buffers are not shown in the optional buffer layers. In that case, where ever a dotted line intersects a solid line (with an arrow) a buffer is placed. Thin lines indicate ATP interfaces that contain only one VC. Thick lines indicate ATP interfaces that contain multiple VCs.</p><h2 id="OBSOLETE-DELETEHW-SYMsym_buf_switch-BlockDiagram">Block Diagram</h2><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16164385/BufferedSwitchBlockDiagram.svg?api=v2"></span></p><p>The parameters that drive the sym_buf_switch are the same as sym_switch so refer to the <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16169027/OBSOLETE-DELETE+HW-SYM+sym_switch" data-linked-resource-id="16169027" data-linked-resource-version="50" data-linked-resource-type="page">OBSOLETE-DELETE HW-SYM sym_switch</a> description for parameter descriptions except for parameters bufLayer0, bufLayer1, bufLayer2, bufLayer3 and vcShiftMap. MasterArbReadyAware is missing because all masterArbs are always ready aware.</p><h2 id="OBSOLETE-DELETEHW-SYMsym_buf_switch-BufferingandCredits">Buffering and Credits</h2><p>For the first implementation, credits are not explicitly used between two buffered switches, but conceptionally the ready lines connecting the two switches function as credits. By forcing the Master Arbiters to be ready aware, the Egress Switch Layer, and forcing there to be always at least one pipe stage in Buffer Layer 0, the ready signals can be interpreted as saying &quot;1 credit available&quot; for each VC.</p><h2 id="OBSOLETE-DELETEHW-SYMsym_buf_switch-BufferRestrictions">Buffer Restrictions</h2><p> The first buffer layer, bufLayer0, must always have at least a depth of 1 or greater. In addition, pipeBackward is always true, and so the parameter isn't specified.</p><p>The last active buffer layer, bufLayerN.depth &gt; 0, must have pipeForward = true.</p><p>In general, the fastest timing and performance will be achieved by having all buffer layers depths at least 2 or greater, simplePipe = false, pipeForward = true and pipeForward = true.  The value of circular that yields the best timing will be a function of the other parameters of the switch. The fastest timing would be to have the same as stated earlier, but with simplePipe = true, but it will not yield the best performance in terms of latency.</p><h2 id="OBSOLETE-DELETEHW-SYMsym_buf_switch-vcShiftMap">vcShiftMap</h2><div>The vcShiftMap controls how VCs are shifted, usually done to avoid deadlock. Most of the time, no VC shifting will happen. For this case, the structure is left empty.</div><div>The entries in array vcShiftMap[inputPort#].vcs corresponds to the VCs listed in the vcMap.ingress[inputPort#].vm array. The code will work for any order in vcMap.ingress[inputPort#].vm so 2,1,0 will work just as well as 0,1,2 or 2,0,1 and so on. But to avoid confusion it is recommended that the order be sorted from low to high. The following examples assume:</div><pre>vcMap.ingress = [{vm: [0,1]},{vm: [0,1]}]</pre><h3 id="OBSOLETE-DELETEHW-SYMsym_buf_switch-Example,2inputportswith2VCsandnoVCshifting.">Example, 2 input ports with 2 VCs and no VC shifting.</h3><pre>vcShiftMap: null;</pre><p>The next most common example is to always shift a VC on an input port from one value to another:</p><h3 id="OBSOLETE-DELETEHW-SYMsym_buf_switch-Example,2inputportswith2VCswhereVC0onport0isalwaysmappedtoVC1.">Example, 2 input ports with 2 VCs where VC0 on port 0 is always mapped to VC1.</h3><pre>vcShiftMap: [</pre><pre>              {vcs:[{mapFunc:{shiftTable:[{vc: 1}]}},mapFunc:{shiftTable:[{vc: 1}]}}}, // corresponds to port 0, 1st mapFunc is for incoming vc0, 2nd mapFunc is for incoming vc1</pre><pre>              {vcs:[{mapFunc:{shiftTable:[{vc: 0}]}},mapFunc:{shiftTable:[{vc: 1}]}}} // corresponds to port 1</pre><pre>            ],</pre><h3 id="OBSOLETE-DELETEHW-SYMsym_buf_switch-Example,2inputportswith2VCswhereVC0onport1isalwaysmappedtoVC1.">Example, 2 input ports with 2 VCs where VC0 on port 1 is always mapped to VC1.</h3><pre>vcShiftMap: [</pre><pre>              {vcs:[{mapFunc:{shiftTable:[{vc: 0}]}},mapFunc:{shiftTable:[{vc: 1}]}}}, // corresponds to port 0</pre><pre>              {vcs:[{mapFunc:{shiftTable:[{vc: 1}]}},mapFunc:{shiftTable:[{vc: 1}]}}} // corresponds to port 1</pre><pre>            ],</pre><h3 id="OBSOLETE-DELETEHW-SYMsym_buf_switch-Example,2inputportswith2VCswhereVCsareswappedonport0,butnotonport1.">Example, 2 input ports with 2 VCs where VCs are swapped on port 0, but not on port 1.</h3><pre>vcShiftMap: [</pre><pre>              {vcs:[{mapFunc:{shiftTable:[{vc: 1}]}},mapFunc:{shiftTable:[{vc: 0}]}}}, // corresponds to port 0</pre><pre>              {vcs:[{mapFunc:{shiftTable:[{vc: 0}]}},mapFunc:{shiftTable:[{vc: 1}]}}} // corresponds to port 1</pre><pre>            ],</pre><h3 id="OBSOLETE-DELETEHW-SYMsym_buf_switch-Example,2inputportswith2VCswhereVC0onport0isalwaysmappedtoVC1whenH_dst=3&#39;b100.">Example, 2 input ports with 2 VCs where VC0 on port 0 is always mapped to VC1 when H_dst = 3'b100.</h3><pre>vcShiftMap: [</pre><pre>              {vcs:[{mapFunc:{shiftFields:[&quot;H_dst[2:0]&quot;],shiftTable:[{vc: 1, shiftPat: &quot;3'b100&quot;},{vc: 0, shiftPat: &quot;default&quot;}]},</pre><pre>                    {mapFunc:{shiftTable:[{vc: 1}]}}},</pre><pre>              {vcs:[{mapFunc:{shiftTable:[{vc: 0}]}},mapFunc:{shiftTable:[{vc: 1}]}}}</pre><pre>            ]</pre><h3 id="OBSOLETE-DELETEHW-SYMsym_buf_switch-Example,2inputportswith2VCswhereVC0onport0isalwaysmappedtoVC1whenH_dst=3&#39;b100andH_src=3&#39;b001.">Example, 2 input ports with 2 VCs where VC0 on port 0 is always mapped to VC1 when H_dst = 3'b100 and H_src = 3'b001.</h3><pre>vcShiftMap: [</pre><pre>              {vcs:[{mapFunc:{shiftFields:[&quot;H_dst[2:0],&quot;H_src[2:0]&quot;],shiftTable[{vc: 1, shiftPat: &quot;6'b100001&quot;},{vc: 0, shiftPat: &quot;default&quot;}]},</pre><pre>                    {mapFunc:{shiftTable[{vc: 1}]}}},</pre><pre>              {vcs:[{mapFunc:{shiftTable[{vc: 0}]}},mapFunc:{shiftTable[{vc: 1}]}}}</pre><pre>            ]</pre>