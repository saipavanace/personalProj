<ol><li><h2 id="CHI(w/IssueB)BFM-Introduction">Introduction</h2></li></ol><p>This document describes in-detail implementation details of CHI(w/Issue B) BFM. Brief description of each component is specified and if required architecture/functionality of the component is mentioned. Document mentions list of knobs to modify stimulus behavior, list of Checks and Coverage collectors if exists and list of unit tests performed. Also HashTags are specified. Please refer to CHI Design specification for architecture details.</p><h2 id="CHI(w/IssueB)BFM-2.CHIInterface">2. CHI Interface</h2><p>File: $CONCERTO_TOP/dv/lib_tb/chi_if.sv</p><p>The System verilog CHI interface connects RN-F, RN-D &amp; RN-I BFM's to the CHI-AIU RTL. In Ncore systems, multiple interfaces of these instances are connected to various AIU's. In future, Slave nodes (Memory BFM's) can also be connected to this interface. All the required support is included.</p><p> </p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th class="confluenceTh">ModPort</th><th class="confluenceTh">Description</th></tr><tr><td class="confluenceTd"> </td><td class="confluenceTd"> </td></tr><tr><td class="confluenceTd"> </td><td class="confluenceTd"> </td></tr><tr><td class="confluenceTd"> </td><td class="confluenceTd"> </td></tr></tbody></table></div><p> </p><h2 id="CHI(w/IssueB)BFM-3.CHIUVMAgent">3. CHI UVM Agent</h2><h2 id="CHI(w/IssueB)BFM-3.1Introduction">3.1 Introduction</h2><h2 id="CHI(w/IssueB)BFM-3.2Sequenceitem">3.2 Sequence item</h2><p>pre randomize fields: rev_type, comp_type, tgtid, srcid, txnid, txreq opcode, txreq cache-line</p><h2 id="CHI(w/IssueB)BFM-4.CHIBFM">4. CHI BFM</h2><p> </p><p>Methods</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th class="confluenceTh">Public Methods</th><th colspan="1" class="confluenceTh">IP Arguments</th><th colspan="1" class="confluenceTh">OP return</th><th class="confluenceTh">Description</th></tr><tr><td class="confluenceTd"><p>get_rn_txreq()</p><p>          </p></td><td colspan="1" class="confluenceTd"><p>sel_req_op_t, cmd_type, address,initial state, final state</p></td><td colspan="1" class="confluenceTd"><p>chi_base_seq_item</p><p>chi_pkt_vld</p></td><td class="confluenceTd"><p>This method is a task that may consume simulation cycles. Multiple TXREQ sequences will call this method to get TXREQ sequence item. External sequences can alter the sequence item received but must call method 'altered_rn_txreq()' for BFM to update its copy in outstanding queues.</p><p>select operation type: &quot;FULL_RAND&quot;, &quot;CMD_VALID, &quot;ADDR_VALID&quot;, &quot;CMD_ADDR_VALID&quot;, &quot;STATE_VALID&quot;.</p></td></tr><tr><td class="confluenceTd">get_rn_txdat()</td><td colspan="1" class="confluenceTd"> </td><td colspan="1" class="confluenceTd">chi_base_seq_item</td><td class="confluenceTd">This method is a task that may consume simulation cycles. User can control to buffer up certain number of packets before forwarding them to sequence. Also user has the control to either send transactions in order or out of order. There is automatic timeout mechanism that will trigger to force drive any outstanding transactions even if threshold is not reached.</td></tr><tr><td class="confluenceTd">get_rn_txrsp()</td><td colspan="1" class="confluenceTd"> </td><td colspan="1" class="confluenceTd">chi_base_seq_item</td><td class="confluenceTd">This method is a task that may consume simulation cycles. User can control to buffer up certain number of packets before forwarding them to sequence. Also user has the control to either send transactions in order or out of order. There is automatic timeout mechanism that will trigger to force drive any outstanding transactions even if threshold is not reached.</td></tr><tr><td colspan="1" class="confluenceTd">put_rn_rxrsp()</td><td colspan="1" class="confluenceTd">chi_base_seq_item</td><td colspan="1" class="confluenceTd"> </td><td colspan="1" class="confluenceTd">This is a function. Forwards data-less response from DUT and updates the BFM on final state if required and adds Completion transaction to TXRSP pending queue if required. Also iterates over the Cache model to check if any silent cache state transactions are legal.</td></tr><tr><td colspan="1" class="confluenceTd">put_rn_rxdat()</td><td colspan="1" class="confluenceTd">chi_base_seq_item</td><td colspan="1" class="confluenceTd"> </td><td colspan="1" class="confluenceTd">This is a function. Forwards rd-data response from DUT and updates the BFM on final state if required. Adds completion transaction to TXRSP pending queue if required. Also iterates over the Cache model to check if any silent cache state transactions are legal.</td></tr><tr><td colspan="1" class="confluenceTd">put_rn_rxsnp()</td><td colspan="1" class="confluenceTd">chi_base_seq_item</td><td colspan="1" class="confluenceTd"> </td><td colspan="1" class="confluenceTd">This is a function.Forwards snoop requests received from DUT to BFM. Adds snoop responses to either TXDAT or TXRSP queue depending on if data must be forwarded.</td></tr></tbody></table></div><p> </p><p>Power Management support:</p><p>With CHI, either BFM or agent can initiate power down sequence. So whenever power down even happens, BFM will halt all request sequences from issuing more transactions. All other channel sequences will respond still. We will initiate a WRBACK sequence to invalidate all the valid cachelines in BFM. When power up event happens, BFM will unblock the request sequence.</p><p>Reset in middle Support:</p><p>Add method to drop all cachelines (outstanding &amp; installed) in BFM, Halt all transmit sequences until reset event is released.</p><p> </p><p> </p><p>Channel Specific Sequences</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th class="confluenceTh">Sequence Name</th><th class="confluenceTh">Desciption</th></tr><tr><td class="confluenceTd">chi_chnl_spfic_active_seq #(T)</td><td class="confluenceTd"><p>UVM sequence operates on specific channel, parametrized to channel specific sequence item. Active sequence meaning that sequence will initiate the transaction to drive packet on Interface to DUT.</p><p>Provides means (method) to alter the sequence item constructed before forwarding the packet to driver.</p></td></tr><tr><td class="confluenceTd">chi_chnl_spfic_reactive_seq #(T)</td><td class="confluenceTd"><p>UVM sequence operates on specific channel, parametrized to channel specific sequence item. Reactive sequence meaning that sequence will initiate the transaction to receive packet from DUT.</p><p>Blocking sequence, does not return control until there is a valid packet received from driver.</p></td></tr></tbody></table></div><p> </p><p>High level Blocking Sequence</p><p>chi_req_blocking_seq: Depending the request sequence item received from higher level sequence, initiates the request and forwards the response from DUT to caller. If read request, blocks until read response is received from DUT. If Write request (any requests that required DBID response), blocks until DBID response is received from DUT and issues TXRESP sequence item once high level sequence forwards. Blocks until completion response is received.</p><p> </p><p>6. TODO</p><ol><li>Implement 'static D.S cbi_agentids and chie_agentids' in addrMgrConst. currently referenced in chi_seq_item.svh</li></ol><p> </p><h2 id="CHI(w/IssueB)BFM-Notesfrom&#39;DiscussionsonCHItransactionflows&#39;meetingpresentedbySanjay(09/13/2017)">Notes from 'Discussions on CHI transaction flows' meeting presented by Sanjay(09/13/2017)</h2><p>What is new message encoding DTWMRGMRD_CC??</p><ul><li>DTW request issued by AIU is merged with data from memory within DMI and is forwarded to target has clean data. Note that in this scenario DCE will not issue a MRD but the packet type from AIU ‘DTWMRGMRD_CC’ indicates DMI that it needs to fetch data from memory</li></ul><p>For which Write transactions do we (CHI-AIU) issue combined CompDBIDResp and separate DBIDResp, CompData?</p><ul><li>For CopyBack transactions only combined CompDBIDResp is issued<u><span class="legacy-color-text-default">. Sanjay will confirm if this true? </span></u></li><li><span class="legacy-color-text-default">For AtomicLoad, AtomicSwap &amp; AtomicCompare transactions CompDBIDResp is not permitted. Separate requests are required.</span></li><li><span class="legacy-color-text-default">For all other requests, either DBIDResp or CompDBIDresp is issued by CHI-AIU only after STRReq is observed. Micro-architecture specific, need to confirm from Parimal?</span></li></ul><p><span class="legacy-color-text-default">What is SNARF in transaction flows?</span></p><ul><li>It is equivalent to 'Data Pull' in CHI spec. This information is communicated on Concerto protocol with field name SNARF.</li></ul><p>Questions about ordering.</p><ul><li>Did give an overview on ordering in CHI. How is ordering achieved in CHI-Issue B system without the need for explicit Barrier commands initiated by the processor on CHI interface. More detailed review coming up.</li></ul><p> </p>