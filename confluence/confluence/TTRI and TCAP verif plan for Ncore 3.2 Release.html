<p><style type='text/css'>/*<![CDATA[*/
div.rbtoc1759723802549 {padding: 0px;}
div.rbtoc1759723802549 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1759723802549 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class='toc-macro rbtoc1759723802549'>
<ul class='toc-indentation'>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-1.0TTRIverification'>1.0 TTRI verification</a>
<ul class='toc-indentation'>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-1.1TTRIchecking'>1.1 TTRI checking</a></li>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-1.2TTRIstimulus'>1.2 TTRI stimulus</a>
<ul class='toc-indentation'>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-TTRIstrategy.'>TTRI strategy.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-2.0TCAPverification'>2.0 TCAP verification</a>
<ul class='toc-indentation'>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-2.1TCAPchecking:TraceCaptureScoreboardchecking'>2.1 TCAP checking: Trace Capture Scoreboard checking</a>
<ul class='toc-indentation'>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-TCAPscoreboardintegration'>TCAP scoreboard integration</a></li>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-TCAPstrategy.'>TCAP strategy.</a></li>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-TCAPDroppedtracemessages.'>TCAP Dropped trace messages.</a></li>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-TCAPTimestampchecking.'>TCAP Timestamp checking.</a></li>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-TCAPTimestamprollovertesting.'>TCAP Timestamp rollover testing.</a></li>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-Uncorrectedtrace.'>Uncorrected trace.</a></li>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-Otherchecks.'>Other checks.</a></li>
</ul>
</li>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-2.2TCAPstimulus'>2.2 TCAP stimulus</a>
<ul class='toc-indentation'>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-Parameters'>Parameters</a></li>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-Othertraceanddebuglimitations'>Other trace and debug limitations</a>
<ul class='toc-indentation'>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-End2endDTWchecking'>End2end DTW checking</a></li>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-TraceRegisterprogramming'>Trace Register programming</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-3.0FunctionalChecks'>3.0 Functional Checks</a>
<ul class='toc-indentation'>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-3.1TTRIandTCAPfunctionalchecks'>3.1 TTRI and TCAP functional checks</a></li>
</ul>
</li>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-4.0FunctionalCoverage'>4.0 Functional Coverage</a>
<ul class='toc-indentation'>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-4.1TTRIfunctionalcoverage'>4.1 TTRI functional coverage</a></li>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-4.2TTRIfunctionalcoveragecrosses'>4.2 TTRI functional coverage crosses</a></li>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-4.3TCAPfunctionalcoverage'>4.3 TCAP functional coverage</a></li>
</ul>
</li>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-5.0MajorTCAP/TTRItestplanchangessinceBeta2.'>5.0 Major TCAP/TTRI testplan changes since Beta2.</a>
<ul class='toc-indentation'>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-5.1Throttling'>5.1 Throttling</a></li>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-5.2TTRIregisterrandomization'>5.2 TTRI register randomization</a></li>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-5.3TCAPregisterrandomization'>5.3 TCAP register randomization</a></li>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-5.4TMbitrandomization'>5.4 TM bit randomization</a></li>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-5.5TTRIandTCAPparameters'>5.5 TTRI and TCAP parameters</a></li>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-5.6TCAPtimeout'>5.6 TCAP timeout</a></li>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-5.7TCAPdroppedmessages'>5.7 TCAP dropped messages</a></li>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-5.8TCAPtimestamp'>5.8 TCAP timestamp</a></li>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-5.9TCAPtimestampincrementing'>5.9 TCAP timestamp incrementing</a></li>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-5.10TCAPtimestamprollover'>5.10 TCAP timestamp rollover</a></li>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-5.11TCAPcapturesuncorrectedtracemessages'>5.11 TCAP captures uncorrected trace messages</a></li>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-5.12TCAPdynamicregisterprogramming'>5.12 TCAP dynamic register programming</a></li>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-5.12TTRIandTCAPfunctionalcoverage'>5.12 TTRI and TCAP functional coverage</a></li>
</ul>
</li>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-6.0Coveragereviewnotes(held12/16/2021)'>6.0 Coverage review notes (held 12/16/2021)</a>
<ul class='toc-indentation'>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-5.1Trigger'>5.1 Trigger</a></li>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-5.2Capture'>5.2 Capture</a></li>
<li><a href='#TTRIandTCAPverifplanforNcore3.2Release-5.3DVEAccumulator'>5.3 DVE Accumulator</a></li>
</ul>
</li>
</ul>
</div></p><p>Feel free to jump to the end &quot;Major TCAP/TTRI testplan changes since Beta2&quot; to see a summary of the change from the 3.2 Beta2 test plan to this 3.2 Release test plan.</p><h1 id="TTRIandTCAPverifplanforNcore3.2Release-1.0TTRIverification">1.0 TTRI verification</h1><h3 id="TTRIandTCAPverifplanforNcore3.2Release-1.1TTRIchecking">1.1 TTRI checking</h3><p>The trigger checking is done the following way. <br/>Each AIU scoreboard (CHI and IOAIU) instantiates a trace_trigger_utils object.<br/>Each AIU calls trace_trigger_utils register write functions whenever a trigger register is written to pass along new register values.<br/>Each AIU calls the trace_trigger_utils function gen_expected_traceme() passing a set of native signals and is returned the expected value of traceme.<br/>Each AIU compares the actual traceme bit from the SMI with the expected traceme bit from gen_expected_traceme() and reports any miscompares as errors.</p><h3 id="TTRIandTCAPverifplanforNcore3.2Release-1.2TTRIstimulus">1.2 TTRI stimulus</h3><p>The following test variations should be created from a basic trigger test using the runsim &quot;flavors&quot; testlist feature.<br/>Plusargs will be used at CHI, IOAIU and FSYS levels to control trigger registers.<br/>Register values can either be fully specified, fully randomized, or a mix (some fields specified and others randomized). Register randomization will use weighted random with some biases toward interesting values.</p><p>3.2 beta had relatively few address matches. To improve this, there will be a new plusarg +TBAHR_TBALR_bench_control, when set to 1, the test bench will be responsible to pick values of tbahr and tbalr that align with the address regions that the test will use, sometimes being aligned to cover some or all of the used addresses, sometimes slightly lower than the used addresses, and sometimes slightly higher. See <a class="external-link" href="https://jira.arteris.com/browse/CONC-8051" rel="nofollow">CONC-8051</a>.</p><p>nTraceRegisters=1-4 will be tested.<br/>Each test should have at least 10 occurrences of traceme = 1, and at least 10 occurrences of traceme = 0.<br/>Some tests check connectivity and need to be run in all three testbenches. Other tests test the RTL trigger block internals and only need to be tested in CHI. This is specified below.<br/>Rerun most CHI and IOAIU tests at FSYS. See the table below.</p><p><br/></p><div class="table-wrap"><table class="relative-table wrapped confluenceTable" style="width: 100.0%;"><colgroup><col style="width: 5.91145%;"/><col style="width: 7.91721%;"/><col style="width: 9.73317%;"/><col style="width: 37.9745%;"/><col style="width: 38.4344%;"/></colgroup><tbody><tr><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><strong>Summary of trigger tests</strong></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><th class="confluenceTh">CHI</th><th class="confluenceTh">IOAIU</th><th class="confluenceTh">FSYS</th><th class="confluenceTh">test flavor name</th><th class="confluenceTh">description</th></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">master_init_only</td><td class="confluenceTd">simple master initiated trace</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">no</td><td class="confluenceTd">ncore_init_addr_match_rand</td><td class="confluenceTd">ncore-initiated, addr match with random base addr, range size=0</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y, some</td><td class="confluenceTd">ncore_init_addr_match_0s_size(00-1f)</td><td class="confluenceTd">ncore-initiated, addr match to address all 0's, different sizes</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y, some</td><td class="confluenceTd">ncore_init_addr_match_fs_size(00,1f)</td><td class="confluenceTd">ncore-initiated, addr match to address all f's, different sizes</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">ncore_init_op_code_match</td><td class="confluenceTd">ncore-initiated, op_code match, random TOPCR</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">no</td><td class="confluenceTd">ncore_init_op_code_match_no_valids</td><td class="confluenceTd">ncore-initiated, op_code match, valid1-4 all zero, corner case</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y, some</td><td class="confluenceTd">ncore_init_mem_attr_match(0-f)</td><td class="confluenceTd">ncore-initiated, mem_attr match, all values</td></tr><tr><td class="confluenceTd">n/a</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">ncore_init_mem_attr_match_aw</td><td class="confluenceTd">ncore-initiated, mem_attr match, writes only</td></tr><tr><td class="confluenceTd">n/a</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">ncore_init_mem_attr_match_ar</td><td class="confluenceTd">ncore-initiated, mem_attr match, reads only</td></tr><tr><td class="confluenceTd">n/a</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">ncore_init_mem_attr_match_aw_ar</td><td class="confluenceTd">ncore-initiated, mem_attr match, writes and reads</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">ncore_init_user_match</td><td class="confluenceTd">ncore-initiated, user bits match</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y, some</td><td class="confluenceTd">ncore_init_user_match_mask_0</td><td class="confluenceTd">ncore-initiated, user bits match, user mask all 0's, corner case</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y, some</td><td class="confluenceTd">ncore_init_target_type_dii_match(00-1f)</td><td class="confluenceTd">ncore-initiated, dii target type match, test for each HUI value</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y, some</td><td class="confluenceTd">ncore_init_target_type_dmi_match(00-1f)</td><td class="confluenceTd">ncore-initiated, dmi target type match, test for each HUI value</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">no</td><td class="confluenceTd">no</td><td class="confluenceTd">ncore_init_all</td><td class="confluenceTd">ncore-initiated, every match type (ANDed)</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">no</td><td class="confluenceTd">no</td><td class="confluenceTd">master_init_and_ncore_init_all</td><td class="confluenceTd">master-initiated trace ANDed with ncore-initiated, every match type</td></tr></tbody></table></div><p class="auto-cursor-target">To get more details than the test summary above, please look at the following:</p><p class="auto-cursor-target">(For CHI, nTraceRegisters=1-4) see hw-ncr/dv/chi_aiu/tb/runsim_testlist.json, tests ttrig_tcap, ttrig_tcap_2sets, trig_tcap_3sets and trig_tcap_4sets with all their flavors.</p><p class="auto-cursor-target">(For IOAIU, nTraceRegisters=1-4) see hw-ncr/dv/ioaiu/tb/runsim_testlist.json, tests ttrig_tcap, ttrig_tcap_2sets, trig_tcap_3sets and trig_tcap_4sets with all their flavors.</p><h5 id="TTRIandTCAPverifplanforNcore3.2Release-TTRIstrategy."><strong>TTRI strategy.</strong></h5><p>The primary test bench for testing trace trigger will be CHI. IOAIU tests will be primarily concerned with checking IOAIU trace trigger connectivity, not testing the internals of the trace trigger logic.</p><h1 id="TTRIandTCAPverifplanforNcore3.2Release-2.0TCAPverification">2.0 TCAP verification</h1><h3 id="TTRIandTCAPverifplanforNcore3.2Release-2.1TCAPchecking:TraceCaptureScoreboardchecking">2.1 TCAP checking: Trace Capture Scoreboard checking</h3><h5 id="TTRIandTCAPverifplanforNcore3.2Release-TCAPscoreboardintegration">TCAP scoreboard integration</h5><p>Each unit environment instantiates the Trace Capture Scoreboard.</p><p>The unit environment connects the SMI analysis ports to the Trace Capture Scoreboard.</p><p>The unit environment writes to the trace capture scoreboard static register fields whenever the Capture Control Register is written.</p><p>Once the Trace Capture Scoreboard knows the Capture Control Register value and has the SMI analysis port connections it can perform some checking of the actual DTWs output by the Trace Capture block versus what the scoreboard decides are the trace messages that should be seen in the DTWs.</p><h5 id="TTRIandTCAPverifplanforNcore3.2Release-TCAPstrategy."><strong>TCAP strategy.</strong></h5><p>The primary test bench for testing trace capture will be DMI. The other benches: DII, CHI, and IOAIU will be primarily concerned with checking trace capture connectivity in those units, not testing the internals of the trace capture logic.</p><h5 id="TTRIandTCAPverifplanforNcore3.2Release-TCAPDroppedtracemessages."><strong>TCAP Dropped trace messages.</strong></h5><p>If the capture system is full including the SMI network input FIFOs, new SMI messages with traceme set will not lead to trace messages that end being output as DTWs. These are dropped trace messages. RTL will use the performance counters to report how many trace messages are dropped, but not which exact trace messages are dropped. At the end of the simulation, the DMI test bench TCAP scoreboards will compare the drop count reported by RTL and report an error if it is different than the DV drop count, but not check which messages should have been dropped. DV will not determine whether it was appropriate for the RTL to drop a message. DV does not model the RTL trace FIFOs, accumulators and buffer. </p><p>Trace messages should not be stuck in the TCAP accumulators or trace buffer at the end of a simulation because the CHI, IOAIU, DMI and DII blocks wait for RTL to be not busy (including trace messages that have not been output) before ending the simulation. DV compares the number of trace messages processed with the number that RTL reports as completed, so we should report an error if any trace message were still stuck in TCAP at the end of the simulation.</p><h5 id="TTRIandTCAPverifplanforNcore3.2Release-TCAPTimestampchecking."><strong>TCAP Timestamp checking.</strong></h5><p><br/>Even within a single DTW, timestamp values are not guaranteed to be increasing, they can go up or down, unless only trace capture from one SMI network is specified in the Capture Control Register.</p><p>We do the following TCAP timestamp check.</p><p>The check has a timestamp check interval specified by +tStampChk=2000 (current default value).<br/>Once every 2000 Trace Messages from DTWs are observed, checker does the following.<br/>Compares the average of the timestamps in the current Trace Message, to the average of the timestamps in the Trace Message from 2000 Trace Messages ago (old_Trace_Message_timestamp_average).<br/>Basically, we check that Trace_Message_timestamp_average(n) &gt; Trace_Message_timestamp_average(n-2000).<br/>The new Trace Message timestamp average must be higher than the old Trace Message timestamp average.<br/>We don’t check the timestamp values for Trace Messages 2001-3999, 4001-5999, etc, just 2000, 4000, 6000, etc.<br/>This is clearly not very “rigorous” checking.</p><p>See <a class="external-link" href="https://jira.arteris.com/browse/CONC-8090" rel="nofollow">CONC-8090</a> for a block level test that fails with +tStampChk=1601.</p><h5 id="TTRIandTCAPverifplanforNcore3.2Release-TCAPTimestamprollovertesting.">TCAP Timestamp rollover testing.</h5><p><span class="legacy-color-text-blue3">In the DMI test bench, in some tests DV will force a non-zero initial value for the RTL timestamp value, often to a value, such as 'hFFFF_FF00, that will soon cause a timestamp rollover.</span></p><h5 id="TTRIandTCAPverifplanforNcore3.2Release-Uncorrectedtrace.">Uncorrected trace.</h5><p>For Ncore 3.2 release, the design create trace messages from the uncorrected SMI packet, not the corrected SMI packet. So, this is what DV will checks. See <a class="external-link" href="https://jira.arteris.com/browse/CONC-8091" rel="nofollow">CONC-8091</a>.<strong><br/></strong></p><h5 id="TTRIandTCAPverifplanforNcore3.2Release-Otherchecks.">Other checks.</h5><p><br/>The trace scoreboard can do some minimal checking of the legality of some DTW fields and which SMI can be used for DTW output.</p><h3 id="TTRIandTCAPverifplanforNcore3.2Release-2.2TCAPstimulus">2.2 TCAP stimulus</h3><p>The following test variations should be create from a basic test using the runsim flavors testlist feature.<br/>Rerunning CHI and ioaiu trigger+capture tests at FSYS should cover two things.<br/>1. Covers CHI and IOAIU TCAP.<br/>2. Provides some coverage of DMI and DII TCAP.</p><p><br/></p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">DMI</th><th class="confluenceTh">DII</th><th class="confluenceTh">CHI</th><th class="confluenceTh">IOAIU</th><th class="confluenceTh">FSYS</th><th class="confluenceTh">test flavor name</th><th class="confluenceTh">notes</th></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">capture_random</td><td class="confluenceTd">All register bits randomized, including SMI inputs, gain value and inc value.</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">capture_none</td><td class="confluenceTd">All SMI bits disabled.</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">capture_tx0</td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">capture_rx0</td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">capture_tx1</td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">capture_rx1</td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">n/a</td><td class="confluenceTd">n/a</td><td class="confluenceTd">n/a</td><td class="confluenceTd">y for DMI</td><td class="confluenceTd">capture_tx2</td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">n/a</td><td class="confluenceTd">n/a</td><td class="confluenceTd">n/a</td><td class="confluenceTd">y for DMI</td><td class="confluenceTd">capture_rx2</td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">capture_tx_other</td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">capture_rx_other</td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">n/a</td><td class="confluenceTd">n/a</td><td class="confluenceTd">n/a</td><td class="confluenceTd">y for DMI</td><td class="confluenceTd">capture_tx_all_dmi</td><td class="confluenceTd">tx-only: DMI</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">n/a</td><td class="confluenceTd">n/a</td><td class="confluenceTd">n/a</td><td class="confluenceTd">y for DMI</td><td class="confluenceTd">capture_rx_all_dmi</td><td class="confluenceTd">rx-only: DMI</td></tr><tr><td class="confluenceTd">no</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">capture_tx_all_others</td><td class="confluenceTd">tx-only: others (DII, CHI, IOAIU)</td></tr><tr><td class="confluenceTd">no</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">capture_rx_all_others</td><td class="confluenceTd">rx-only: others (DII, CHI, IOAIU)</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">n/a</td><td class="confluenceTd">n/a</td><td class="confluenceTd">n/a</td><td class="confluenceTd">y for DMI</td><td class="confluenceTd">capture_tx_rx_all_dmi</td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">no</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">capture_tx_rx_all_others</td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">n/a</td><td class="confluenceTd">n/a</td><td class="confluenceTd">n/a</td><td class="confluenceTd">y for DMI</td><td class="confluenceTd">capture_tx_rx_all_dmi_gain(0-f)</td><td class="confluenceTd">try all gain values</td></tr><tr><td colspan="1" class="confluenceTd">no</td><td colspan="1" class="confluenceTd">y</td><td colspan="1" class="confluenceTd">y</td><td colspan="1" class="confluenceTd">y</td><td colspan="1" class="confluenceTd">y</td><td colspan="1" class="confluenceTd">capture_tx_rx_all_others_gain(0-f)</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">several values</td><td colspan="1" class="confluenceTd">n/a</td><td colspan="1" class="confluenceTd">n/a</td><td colspan="1" class="confluenceTd">n/a</td><td colspan="1" class="confluenceTd">several values for DMI</td><td colspan="1" class="confluenceTd">capture_tx_rx_all_dmi_inc</td><td colspan="1" class="confluenceTd">try several inc values in 4.8 integer/fraction format</td></tr><tr><td colspan="1" class="confluenceTd">no</td><td colspan="1" class="confluenceTd">several values</td><td colspan="1" class="confluenceTd">several values</td><td colspan="1" class="confluenceTd">several values</td><td colspan="1" class="confluenceTd">several values</td><td colspan="1" class="confluenceTd">capture_tx_rx_all_others_inc</td><td colspan="1" class="confluenceTd"><br/></td></tr></tbody></table></div><p class="auto-cursor-target">To get more details than the test summary above, please look at the following:</p><p class="auto-cursor-target">For CHI, see hw-ncr/dv/chi_aiu/tb/runsim_testlist.json, test ttrig_tcap with all its flavors</p><p class="auto-cursor-target">For IOAIU, see hw-ncr/dv/ioaiu/tb/runsim_testlist.json, test ttrig_tcap with all its flavors</p><p class="auto-cursor-target">For DMI, see hw-ncr/dv/dmi/tb/runsim_testlist.json, label tcap_regr</p><p class="auto-cursor-target">For DII, see hw-ncr/dv/dii/tb/runsim_testlist.json, label tcap_regr</p><p class="auto-cursor-target">Most of DMI coverage comes from test &quot;random&quot; with randomized CCTRLR.</p><p><br/></p><h4 id="TTRIandTCAPverifplanforNcore3.2Release-Parameters">Parameters</h4><p>TCAP: nUnitTraceBufSize: values of 8 and 16 (the value 16 will only be tested in a single DMI block config) will be tested for the Ncore 3.2 release.<br/>TTRI: nTraceRegisters: values of 1-4 will be tested for in CHI and IOAIU block testing.</p><h4 id="TTRIandTCAPverifplanforNcore3.2Release-Othertraceanddebuglimitations">Other trace and debug limitations</h4><h5 id="TTRIandTCAPverifplanforNcore3.2Release-End2endDTWchecking"><br/>End2end DTW checking</h5><p>Ncore 3.2 currently has no end-to-end or Legato scoreboard instantiated in FYS simulations to make sure that DTW requests and responses travel correctly across different networks.</p><h5 id="TTRIandTCAPverifplanforNcore3.2Release-TraceRegisterprogramming">Trace Register programming</h5><p><br/>For most tests TTRI, TCAP and TACC control registers will only be programmed once at the beginning of the simulation, before any native traffic starts.<br/>Static variables are being used for trace registers inside DV. The unit needs to pass along the trace register writes to these static registers manually. Full 32-bit register accesses supported, not partial register access.<br/>DV has its own register data structures and does not use the RAL. This means we currently have to be aware of any register spec changes and update our DV code manually.</p><p><span class="legacy-color-text-blue3">For some blocks and tests, DV will sometimes change the trace register values in the middle of a block-level simulation (Dynamic Register Programming). This will require a careful sequence of events to quiesce the system and disable trace checking before changing the register values. These steps will be different for each of the blocks: CHI, IOAIU, and DMI. This will be tested for DMI, but not for DII.</span></p><h1 id="TTRIandTCAPverifplanforNcore3.2Release-3.0FunctionalChecks">3.0 Functional Checks</h1><h3 id="TTRIandTCAPverifplanforNcore3.2Release-3.1TTRIandTCAPfunctionalchecks">3.1 TTRI and TCAP functional checks</h3><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/><col/><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">ID</th><th class="confluenceTh">Checks</th><th class="confluenceTh">Hash Tag</th><th class="confluenceTh">Location</th><th class="confluenceTh">TestName</th><th class="confluenceTh">Scope</th><th class="confluenceTh">Status</th><th class="confluenceTh">Ref JIRA</th><th class="confluenceTh">Remarks</th></tr><tr><td class="confluenceTd">1</td><td class="confluenceTd">CHI: TTRI: Compare Traceme: RTL actual vs DV expected</td><td class="confluenceTd">#Check.CHI.TTRI.TM_compare</td><td class="confluenceTd"><br/></td><td class="confluenceTd">ttrig</td><td class="confluenceTd">CHI TB</td><td class="confluenceTd">Done</td><td class="confluenceTd"><br/></td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">2</td><td class="confluenceTd">IOAIU: TTRI: Compare Traceme: RTL actual vs DV expected</td><td class="confluenceTd">#Check.IOAIU.TTRI.TM_compare</td><td class="confluenceTd"><br/></td><td class="confluenceTd">ttrig</td><td class="confluenceTd">IOAIU TB</td><td class="confluenceTd">Done</td><td class="confluenceTd"><br/></td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">3</td><td class="confluenceTd">DMI: TCAP: Compare RTL and SB message count at end of sim.</td><td class="confluenceTd">#Check.DMI.TCAP.msg_captured_count</td><td class="confluenceTd"><br/></td><td class="confluenceTd">random</td><td class="confluenceTd">DMI</td><td class="confluenceTd">Done</td><td class="confluenceTd"><a class="external-link" href="https://jira.arteris.com/browse/CONC-8142" rel="nofollow">CONC-8142</a></td><td class="confluenceTd">checkRtlRegCount is only set by DMI top</td></tr><tr><td class="confluenceTd">4</td><td class="confluenceTd">DMI: TCAP: Compare RTL and SB DTW sent count at end of sim.</td><td class="confluenceTd">#Check.DMI.TCAP.dtw_seen_count</td><td class="confluenceTd"><br/></td><td class="confluenceTd">random</td><td class="confluenceTd">DMI</td><td class="confluenceTd">Done</td><td class="confluenceTd"><br/></td><td class="confluenceTd">checkRtlRegCount is only set by DMI top</td></tr><tr><td class="confluenceTd">5</td><td class="confluenceTd">DMI: TCAP: Compare RTL and SB messages dropped at end of sim.</td><td class="confluenceTd">#Check.DMI.TCAP.msg_dropped_count</td><td class="confluenceTd"><br/></td><td class="confluenceTd">random</td><td class="confluenceTd">DMI</td><td class="confluenceTd">Done</td><td class="confluenceTd"><br/></td><td class="confluenceTd">checkRtlRegCount is only set by DMI top</td></tr><tr><td class="confluenceTd">6</td><td class="confluenceTd">TCAP: Timestamp incremented after 2000 messages</td><td class="confluenceTd">#Check.TCAP.TS_increment</td><td class="confluenceTd"><br/></td><td class="confluenceTd">random</td><td class="confluenceTd">FSYS, CHI, IOAIU, DMI, DII</td><td class="confluenceTd">Done</td><td class="confluenceTd"><br/></td><td class="confluenceTd">Very relaxed checked, compare TS value with 2000 messages ago.</td></tr><tr><td class="confluenceTd">7</td><td class="confluenceTd">DMI: TCAP: Timestamp 32-bit wrap from all F's to all 0's</td><td class="confluenceTd">#Check.DMI.TCAP.TS_wrapped</td><td class="confluenceTd"><br/></td><td class="confluenceTd">random</td><td class="confluenceTd">DMI</td><td class="confluenceTd">Done</td><td class="confluenceTd"><br/></td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">8</td><td class="confluenceTd">TCAP: DTWDebugReq only sent out TX2</td><td class="confluenceTd">#Check.TCAP.DTWDebugReq_TX2</td><td class="confluenceTd"><br/></td><td class="confluenceTd">trig_tcap</td><td class="confluenceTd">CHI, IOAIU, DII</td><td class="confluenceTd">Done</td><td class="confluenceTd"><br/></td><td class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">9</td><td colspan="1" class="confluenceTd">DMI: TCAP: DTWDebugReq only sent out TX3</td><td colspan="1" class="confluenceTd">#Check.DMI.TCAP.DTWDebugReq_TX3</td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd">random</td><td colspan="1" class="confluenceTd">DMI</td><td colspan="1" class="confluenceTd">Done</td><td colspan="1" class="confluenceTd"><a class="external-link" href="https://jira.arteris.com/browse/CONC-8143" rel="nofollow">CONC-8143</a></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">10</td><td colspan="1" class="confluenceTd">TCAP: DTWDebugReq never sent out RX</td><td colspan="1" class="confluenceTd">#Check.TCAP.DTWDebugReq_RX</td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd">FSYS, CHI, IOAIU, DMI, DII</td><td colspan="1" class="confluenceTd">Done</td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">11</td><td colspan="1" class="confluenceTd">TCAP: DTWDebugReq cannot be all zeros</td><td colspan="1" class="confluenceTd">#Check.TCAP.DTWDebugReq_nonzero</td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd">FSYS, CHI, IOAIU, DMI, DII</td><td colspan="1" class="confluenceTd">Done</td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">12</td><td colspan="1" class="confluenceTd">TCAP: Trace message not found</td><td colspan="1" class="confluenceTd">#Check.TCAP.TraceMessage_not_found</td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd">FSYS, CHI, IOAIU, DMI, DII</td><td colspan="1" class="confluenceTd">Done</td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">13</td><td colspan="1" class="confluenceTd">TCAP: Check number of SMI ports</td><td colspan="1" class="confluenceTd">#Check.TCAP.Num_SMI_ports</td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd">FSYS, CHI, IOAIU, DMI, DII</td><td colspan="1" class="confluenceTd">Done</td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">14</td><td colspan="1" class="confluenceTd">TCAP: Check padding</td><td colspan="1" class="confluenceTd">#Check.TCAP.Padding</td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd">FSYS, CHI, IOAIU, DMI, DII</td><td colspan="1" class="confluenceTd">Done</td><td colspan="1" class="confluenceTd">need2file</td><td colspan="1" class="confluenceTd"><br/></td></tr></tbody></table></div><p><br/></p><h1 id="TTRIandTCAPverifplanforNcore3.2Release-4.0FunctionalCoverage">4.0 Functional Coverage</h1><h4 id="TTRIandTCAPverifplanforNcore3.2Release-4.1TTRIfunctionalcoverage">4.1 TTRI functional coverage</h4><p>The following functional coverage should be written for TTRI, sampled at trace_trigger_utils when gen_expected_traceme is called. </p><p>Functional coverage will be run on CHI and IOAIU block trace tests.</p><p><br/></p><p>Coverage for the following register field values passed to trace_trigger_utils.</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Functional Coverage ID (1 coverpoint per trigger set)</th><th class="confluenceTh">register</th><th class="confluenceTh">field</th><th colspan="1" class="confluenceTh">match type</th><th class="confluenceTh">scope</th><th colspan="1" class="confluenceTh">bins</th></tr><tr><td class="confluenceTd">R1</td><td class="confluenceTd">TCTRLR</td><td class="confluenceTd">native_trace_en</td><td colspan="1" class="confluenceTd">native_traceme</td><td class="confluenceTd">CHI-B, IOAIU ACE-lite-E</td><td colspan="1" class="confluenceTd">0,1</td></tr><tr><td class="confluenceTd">R2</td><td class="confluenceTd">TCTRLR</td><td class="confluenceTd">addr_match_en</td><td colspan="1" class="confluenceTd">addr</td><td class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">0,1</td></tr><tr><td class="confluenceTd">R3</td><td class="confluenceTd">TCTRLR</td><td class="confluenceTd">memattr_match_en</td><td colspan="1" class="confluenceTd">memattr</td><td class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">0,1</td></tr><tr><td class="confluenceTd">R4</td><td class="confluenceTd">TCTRLR</td><td class="confluenceTd">opcode_match_en</td><td colspan="1" class="confluenceTd">opcode</td><td class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">0,1</td></tr><tr><td class="confluenceTd">R5</td><td class="confluenceTd">TCTRLR</td><td class="confluenceTd">target_type_en</td><td colspan="1" class="confluenceTd">target_type</td><td class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">0,1</td></tr><tr><td class="confluenceTd">R6</td><td class="confluenceTd">TCTRLR</td><td class="confluenceTd">user_match_en</td><td colspan="1" class="confluenceTd">user</td><td class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">0,1</td></tr><tr><td class="confluenceTd">R7</td><td class="confluenceTd">TCTRLR</td><td class="confluenceTd">hut</td><td colspan="1" class="confluenceTd">target_type</td><td class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">0,1</td></tr><tr><td class="confluenceTd">R8</td><td class="confluenceTd">TCTRLR</td><td class="confluenceTd">hui</td><td colspan="1" class="confluenceTd">target_type</td><td class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">0x0:0xf </td></tr><tr><td class="confluenceTd">R9</td><td class="confluenceTd">TCTRLR</td><td class="confluenceTd">range</td><td colspan="1" class="confluenceTd">addr</td><td class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">0x00:0x1f</td></tr><tr><td class="confluenceTd">R10</td><td class="confluenceTd">TCTRLR</td><td class="confluenceTd">memattr</td><td colspan="1" class="confluenceTd">memattr</td><td class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">0x0:0xf</td></tr><tr><td colspan="1" class="confluenceTd">R11</td><td colspan="1" class="confluenceTd">TCTRLR</td><td colspan="1" class="confluenceTd">ar</td><td colspan="1" class="confluenceTd">memattr</td><td colspan="1" class="confluenceTd">IOAIU</td><td colspan="1" class="confluenceTd">0,1</td></tr><tr><td colspan="1" class="confluenceTd">R12</td><td colspan="1" class="confluenceTd">TCTRLR</td><td colspan="1" class="confluenceTd">aw</td><td colspan="1" class="confluenceTd">memattr</td><td colspan="1" class="confluenceTd">IOAIU</td><td colspan="1" class="confluenceTd">0,1</td></tr><tr><td class="confluenceTd">R13</td><td class="confluenceTd">TBAHR, TBALR</td><td class="confluenceTd">base addr</td><td colspan="1" class="confluenceTd">addr</td><td class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">0s, fs, 8 intermediate ranges</td></tr><tr><td class="confluenceTd">R14</td><td class="confluenceTd">TOPCR0</td><td class="confluenceTd"><div class="content-wrapper"><p class="auto-cursor-target">concat(valid4..1)</p></div></td><td colspan="1" class="confluenceTd">opcode</td><td class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">0x0:0xf</td></tr><tr><td class="confluenceTd">R15</td><td class="confluenceTd">TOPCR0</td><td class="confluenceTd">opcode 1</td><td colspan="1" class="confluenceTd">opcode</td><td class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">0x0000:0x3f, default, (:1f for CHI-A)</td></tr><tr><td colspan="1" class="confluenceTd">R17</td><td colspan="1" class="confluenceTd">TOPCR0</td><td colspan="1" class="confluenceTd">opcode 2</td><td colspan="1" class="confluenceTd">opcode</td><td colspan="1" class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">0x0000:0x3f, default, (:1f for CHI-A)</td></tr><tr><td colspan="1" class="confluenceTd">R19</td><td colspan="1" class="confluenceTd">TOPCR1</td><td colspan="1" class="confluenceTd">opcode 3</td><td colspan="1" class="confluenceTd">opcode</td><td colspan="1" class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">0x0000:0x3f, default, (:1f for CHI-A)</td></tr><tr><td colspan="1" class="confluenceTd">R21</td><td colspan="1" class="confluenceTd">TOPCR1</td><td colspan="1" class="confluenceTd">opcode 4</td><td colspan="1" class="confluenceTd">opcode</td><td colspan="1" class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">0x0000:0x3f, default, (:1f for CHI-A)</td></tr><tr><td colspan="1" class="confluenceTd">R22</td><td colspan="1" class="confluenceTd">TUBR</td><td colspan="1" class="confluenceTd">user bits</td><td colspan="1" class="confluenceTd">user</td><td colspan="1" class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">0x0:0xf (depends on width), 0xffff_ffff (if width ==32)</td></tr><tr><td colspan="1" class="confluenceTd">R23</td><td colspan="1" class="confluenceTd">TUBMR</td><td colspan="1" class="confluenceTd">TUBR masked by TUBMR</td><td colspan="1" class="confluenceTd">masked user</td><td colspan="1" class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">0x0:0xf (depends on width), 0xffff_ffff (if width ==32)</td></tr></tbody></table></div><p><br/><br/>Coverage for the following native signals passed to trace_trigger_utils.</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Functional Coverage ID</th><th class="confluenceTh">signal</th><th colspan="1" class="confluenceTh">match type</th><th class="confluenceTh">scope</th><th colspan="1" class="confluenceTh">bins</th></tr><tr><td class="confluenceTd">N1</td><td class="confluenceTd">native_traceme</td><td colspan="1" class="confluenceTd">native_traceme</td><td class="confluenceTd">CHI-B, IOAIU ACE-lite-E</td><td colspan="1" class="confluenceTd">0,1</td></tr><tr><td class="confluenceTd">N2</td><td class="confluenceTd">native_addr</td><td colspan="1" class="confluenceTd">addr</td><td class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd"><span class="legacy-color-text-red2">0s, fs, 8 intermediate ranges (only hitting 1/10 bins)</span></td></tr><tr><td class="confluenceTd">N3</td><td class="confluenceTd">native_ar </td><td colspan="1" class="confluenceTd">memattr</td><td class="confluenceTd">IOAIU</td><td colspan="1" class="confluenceTd">0,1</td></tr><tr><td class="confluenceTd">N4</td><td class="confluenceTd">native_aw</td><td colspan="1" class="confluenceTd">memattr</td><td class="confluenceTd">IOAIU</td><td colspan="1" class="confluenceTd">0,1</td></tr><tr><td class="confluenceTd">N5</td><td class="confluenceTd">native_dii_hit</td><td colspan="1" class="confluenceTd">target_type</td><td class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">0,1</td></tr><tr><td class="confluenceTd">N6</td><td class="confluenceTd">native_dmi_hit</td><td colspan="1" class="confluenceTd">target_type</td><td class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">0,1</td></tr><tr><td class="confluenceTd">N7</td><td class="confluenceTd">native_dii_hui_unitid</td><td colspan="1" class="confluenceTd">target_type</td><td class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd"><span class="legacy-color-text-red2">only hitting 0 and 1, (Khaeel said only 0x0:0x2 for HII hui nUnitId)</span></td></tr><tr><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd">native_dmi_hui_mig</td><td colspan="1" class="confluenceTd">target_type</td><td colspan="1" class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd"><span class="legacy-color-text-red2">0x0 to 0xf (only hitting 0 and 1)</span></td></tr><tr><td class="confluenceTd">N8</td><td class="confluenceTd">native_memattr</td><td colspan="1" class="confluenceTd">memattr</td><td class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd"><span class="legacy-color-text-red2">CHI: 0..5, d (ignoring c which might be illegal and is being seen), IOAIU: TBD</span></td></tr><tr><td class="confluenceTd">N9</td><td class="confluenceTd">native_opcode</td><td colspan="1" class="confluenceTd">opcode</td><td class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">CHI-A all 5-bit values -unsupported. CHI-B all 6-bit values -unsupported. IOAIU: TBD</td></tr><tr><td class="confluenceTd">N10</td><td class="confluenceTd">native_user</td><td colspan="1" class="confluenceTd">user</td><td class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">0,1 for each of bits 0..2 if they exist as well as for MSB.</td></tr></tbody></table></div><p><br/></p><p>Coverage for the following expected signals created by trace_trigger_utils. <br/><br/></p><div class="table-wrap"><table class="wrapped relative-table confluenceTable" style="width: 51.6731%;"><colgroup><col style="width: 18.491%;"/><col style="width: 16.0468%;"/><col style="width: 12.1148%;"/><col style="width: 28.9054%;"/><col style="width: 24.4421%;"/></colgroup><tbody><tr><th class="confluenceTh">Functional Coverage ID (1 coverpoint per trigger_set)</th><th class="confluenceTh">signal</th><th colspan="1" class="confluenceTh">match type</th><th class="confluenceTh">scope</th><th colspan="1" class="confluenceTh">bins</th></tr><tr><td class="confluenceTd">E1</td><td class="confluenceTd">native_matched</td><td colspan="1" class="confluenceTd">native_traceme</td><td class="confluenceTd">CHI-B, IOAIU ACE-lite-E</td><td colspan="1" class="confluenceTd">0,1</td></tr><tr><td class="confluenceTd">E2</td><td class="confluenceTd">addr_matched</td><td colspan="1" class="confluenceTd">addr</td><td class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">0,1</td></tr><tr><td class="confluenceTd">E3</td><td class="confluenceTd">memattr_matched</td><td colspan="1" class="confluenceTd">memattr</td><td class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">0,1</td></tr><tr><td class="confluenceTd">E4</td><td class="confluenceTd">opcode_matched</td><td colspan="1" class="confluenceTd">opcode</td><td class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">0,1</td></tr><tr><td class="confluenceTd">E5</td><td class="confluenceTd">target_type_matched</td><td colspan="1" class="confluenceTd">target_type</td><td class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">0,1</td></tr><tr><td class="confluenceTd">E6</td><td class="confluenceTd">user_matched</td><td colspan="1" class="confluenceTd">user</td><td class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">0,1</td></tr><tr><td colspan="1" class="confluenceTd">E7</td><td colspan="1" class="confluenceTd">trace[3:0]</td><td colspan="1" class="confluenceTd">all</td><td colspan="1" class="confluenceTd">CHI, IOAIU (depends on nTraceRegisters)</td><td colspan="1" class="confluenceTd">0x0:0xf <span class="legacy-color-text-red2">(need to create coverpoint)</span></td></tr><tr><td colspan="1" class="confluenceTd">E8</td><td colspan="1" class="confluenceTd">traceme</td><td colspan="1" class="confluenceTd">all</td><td colspan="1" class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">0,1</td></tr></tbody></table></div><p><br/></p><h4 id="TTRIandTCAPverifplanforNcore3.2Release-4.2TTRIfunctionalcoveragecrosses">4.2 TTRI functional coverage crosses</h4><p>Note that everything will be crossed with is_chi value to determine CHI or IOAIU.</p><p>All Individual cover points will be crossed with trigger register set number (0-3).</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Functional Coverage Cross ID</th><th class="confluenceTh">match type</th><th class="confluenceTh">Functional Coverage IDs crossed</th><th colspan="1" class="confluenceTh">scope</th><th colspan="1" class="confluenceTh">cross bins</th></tr><tr><td colspan="1" class="confluenceTd"><span class="legacy-color-text-red2">each of these still needs to be coded</span></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd"><br/></td><td class="confluenceTd"><br/></td><td class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">C2</td><td class="confluenceTd">memattr regs</td><td class="confluenceTd">R10, R11, R12</td><td colspan="1" class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">all combinations</td></tr><tr><td colspan="1" class="confluenceTd">C3</td><td colspan="1" class="confluenceTd">memattr</td><td colspan="1" class="confluenceTd">N3, N4, N8</td><td colspan="1" class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">all combinations</td></tr><tr><td class="confluenceTd">C4</td><td class="confluenceTd">opcode</td><td class="confluenceTd">N9, E4</td><td colspan="1" class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">all combinations</td></tr><tr><td class="confluenceTd"><br/></td><td class="confluenceTd"><br/></td><td class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">C6</td><td colspan="1" class="confluenceTd">match_enables</td><td colspan="1" class="confluenceTd">R1-R6</td><td colspan="1" class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">all combinations</td></tr><tr><td colspan="1" class="confluenceTd">C7</td><td colspan="1" class="confluenceTd">matches</td><td colspan="1" class="confluenceTd">E1-E6</td><td colspan="1" class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">all combinations</td></tr><tr><td colspan="1" class="confluenceTd">C8</td><td colspan="1" class="confluenceTd">native_matched</td><td colspan="1" class="confluenceTd">E1 for every trigger set</td><td colspan="1" class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">all combinations</td></tr><tr><td colspan="1" class="confluenceTd">C9</td><td colspan="1" class="confluenceTd">addr_matched</td><td colspan="1" class="confluenceTd">E2 for every trigger set</td><td colspan="1" class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">all combinations</td></tr><tr><td colspan="1" class="confluenceTd">C10</td><td colspan="1" class="confluenceTd">memattr_matched</td><td colspan="1" class="confluenceTd">E3 for every trigger set</td><td colspan="1" class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">all combinations</td></tr><tr><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">C12</td><td colspan="1" class="confluenceTd">target_type_matched</td><td colspan="1" class="confluenceTd">E5 for every trigger set</td><td colspan="1" class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">all combinations</td></tr><tr><td colspan="1" class="confluenceTd">C13</td><td colspan="1" class="confluenceTd">user_matched</td><td colspan="1" class="confluenceTd">E6 for every trigger set</td><td colspan="1" class="confluenceTd">CHI, IOAIU</td><td colspan="1" class="confluenceTd">all combinations</td></tr></tbody></table></div><h4 id="TTRIandTCAPverifplanforNcore3.2Release-4.3TCAPfunctionalcoverage">4.3 TCAP functional coverage</h4><p>The following functional coverage should be written for TCAP.</p><p><br/></p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Functional Coverage ID</th><th class="confluenceTh">Register</th><th class="confluenceTh">Field</th><th colspan="1" class="confluenceTh">scope</th><th class="confluenceTh">bins</th></tr><tr><td class="confluenceTd">R1</td><td class="confluenceTd">CCTRLR</td><td class="confluenceTd">snoop and capture enables (6 or 8)</td><td colspan="1" class="confluenceTd">DMI, DII, CHI, IOAIU</td><td class="confluenceTd">cover all combinations</td></tr><tr><td class="confluenceTd">R2</td><td class="confluenceTd">CCTRLR</td><td class="confluenceTd">gain (4 bits)</td><td colspan="1" class="confluenceTd">DMI, DII, CHI, IOAIU</td><td class="confluenceTd">cover all values</td></tr><tr><td class="confluenceTd">R3</td><td class="confluenceTd">CCTRLR</td><td class="confluenceTd">incr (12 bits, 4 integer, 8 fractional)</td><td colspan="1" class="confluenceTd">DMI, DII, CHI, IOAIU</td><td class="confluenceTd">cover all integers, cover each fractional bit </td></tr></tbody></table></div><p><br/></p><p>Other coverage for CHI, IOAIU, DMI, DII instances:</p><p><strong>Function coverage will be written for the following::</strong></p><p>Fcov::::: Check combinations of CCTRLR register. Fields such as:: (Inc, Gain, SMI Ports)<br/>Fcov::::: Check for free Running Counter (FRC) Altered and  Wrapped.<br/>Fcov::::: Make sure TM-Bit is set for all Concerto message request - block where TCap exists. <br/>            This might be very tricky, but nonetheless doable. That would include transactions from::<br/>            DMI, DII, CIAU and NCAIU[Ace, Axi with proxy and Axi without proxy]<br/>Fcov::::: During back pressure, new MSGs can be added into the accumulator that has a timeout counter less than 2^10.<br/>            This has been voided... not part of architecture defined.<br/>Fcov::::: This functional coverage is mostly for the arbiter, if accumulator_A timeout counter has expired and the buffers<br/>             are full.... under no conditions, accumulator_B or accumulator_C can bypass twice accumulator_A...<br/>This arbitration logic is share throughout Ncore, therefore, it would be considered wastefull to check it <br/>validity at this point.</p><p><strong>Function coverage will not be written for the scenarios listed below. The bench already has checks for them</strong>.</p><p>Bench:::: number of DTWDebugReq processed per simulation (per SMI input)<br/>Bench:::: Timeout counter should not exceed 2^10 under any conditions (Added here, no need for functional coverage)<br/>Bench:::: number of trace messages per DTW<br/>Bench:::: DTW_debug_req<br/>Bench:::: DTW_debug_rsp<br/>Bench:::: padding length<br/>Bench:::: trace message length</p><p>Perfmon:: number of trace messages processed per simulation (per SMI input)<br/>Perfmon:: number of trace messages dropped per simulation<br/>Perfmon:: percent of trace messages dropped per simulation</p><p><strong>The following required some discussions, as it is unclear at the moment.</strong></p><p>Not Clear:: trace message timestamp bit values</p><h1 id="TTRIandTCAPverifplanforNcore3.2Release-5.0MajorTCAP/TTRItestplanchangessinceBeta2.">5.0 Major TCAP/TTRI testplan changes since Beta2.</h1><h3 id="TTRIandTCAPverifplanforNcore3.2Release-5.1Throttling">5.1 Throttling</h3><p><span class="legacy-color-text-blue3">Trigger throttling was proposed as a feature for Ncore 3.2. But after significant discussion, including the difficulty in verifying it the way it was proposed, it was deferred until some time after Ncore 3.2.</span></p><h3 id="TTRIandTCAPverifplanforNcore3.2Release-5.2TTRIregisterrandomization">5.2 TTRI register randomization</h3><p><span class="legacy-color-text-blue3">The trigger register randomization will change for CHI and IOAIU environments.</span></p><p><span class="legacy-color-text-blue3">For Beta2, an entire register could be either fully randomized (unconstrained) or fully set by plusarg.</span></p><p><span class="legacy-color-text-blue3">For Ncore 3.2 Release, plusargs will be able to specify values for individual fields, while allowing the unspecified fields to be randomized, a mix of specifying and randomization.</span></p><p><span class="legacy-color-text-blue3">The randomization will change from unconstrained to weighted to focus on more important values.</span></p><p><span class="legacy-color-text-blue3">These changes will allow for better coverage with fewer tests.</span></p><p><span class="legacy-color-text-blue3">3.2 beta had relatively few address matches. To improve this, there will be a new plusarg +TBAHR_TBALR_bench_control, when set to 1, the test bench will be responsible to pick values of tbahr and tbalr that align with the address regions that the test will use.</span></p><h3 id="TTRIandTCAPverifplanforNcore3.2Release-5.3TCAPregisterrandomization">5.3 TCAP register randomization</h3><p><span class="legacy-color-text-blue3">The CCTRLR Capture Control Register randomization will change for DMI and DII environments. </span></p><p><span class="legacy-color-text-blue3">For trace tests, by default, weighted random will be used to determine the register value, but there will be plusargs if the test wants to set the value.</span></p><p><span class="legacy-color-text-blue3">The 4-bit gain field will use unconstrained randomization to set the initial value.</span></p><p><span class="legacy-color-text-blue3">The 12-bit incr field (4-bit integer and 8-bit fractional) will need weighted random to set the initial value to focus mostly on values that customers would likely choose.</span></p><p><span class="legacy-color-text-blue3">The six to eight capture and snoop enables will use weighted random to prioritize enable over disable.</span></p><h3 id="TTRIandTCAPverifplanforNcore3.2Release-5.4TMbitrandomization">5.4 TM bit randomization</h3><p>For DMI and DII, the TM bit randomization will be improved. For each block, TM randomization will have separate weighting for each SMI input, usually chosen by the environment.</p><p>For CHI and IOAIU block level testing, the TM bit randomization will be improved to have the environment (or a plusarg) chose the weighting of TM=1 vs TM=0.</p><h3 id="TTRIandTCAPverifplanforNcore3.2Release-5.5TTRIandTCAPparameters">5.5 TTRI and TCAP parameters</h3><p>TCAP: nUnitTraceBufSize: both values of 8 and 16 will be tested for Ncore 3.2 Release. Value of 8 is tested in all blocks with TCAP. Value of 16 will be tested in a single DMI config. See <a class="external-link" href="https://jira.arteris.com/browse/CONC-7944" rel="nofollow">CONC-7944</a> and <a class="external-link" href="https://jira.arteris.com/browse/CONC-7942" rel="nofollow">CONC-7942</a>. <em><u><strong>Double-check this interpretation during the review.</strong></u></em><br/>TTRI: nTraceRegisters: all values of 1-4 will be tested for Ncore 3.2 Release in CHI and IOAIU block testing. See <a class="external-link" href="https://jira.arteris.com/browse/CONC-8129" rel="nofollow">CONC-8129</a> for CHI config with nTraceRegisters=3 and <a class="external-link" href="https://jira.arteris.com/browse/CONC-8128" rel="nofollow">CONC-8128</a> for IOAIU config with nTraceRegisters=3.</p><h3 id="TTRIandTCAPverifplanforNcore3.2Release-5.6TCAPtimeout">5.6 TCAP timeout</h3><p><span class="legacy-color-text-blue3">The microarchitecture was changed so that the timeout counter does not increment every cycle, but only every cycle that the trace buffer is available. This changed the timeout from a fixed 2^16=64k cycles to an unknown number of cycles (&gt;500k cycles was observed in block level simulations, but it could millions of cycles, see <a class="external-link" href="https://jira.arteris.com/browse/CONC-8090" rel="nofollow">CONC-8090</a>. As long as DV cannot determine when a timeout should occur, it cannot check when a timeout should occur. We will still change the timeout parameter to a much smaller number in one DMI config and make sure that none of the ordinary TCAP functionality breaks.</span></p><h3 id="TTRIandTCAPverifplanforNcore3.2Release-5.7TCAPdroppedmessages">5.7 TCAP dropped messages</h3><p><span class="legacy-color-text-blue3">RTL has provided a variable that exists if `ASSERT_ON is specified that counts the number of dropped TCAP messages. For DMI test bench, the TCAP scoreboard will compare the RTL number of dropped messages the number of dropped messages that the scoreboard saw and report an error if there is a miscompare. This may be extremely difficult to debug, since DV does not report which messages RTL dropped that differ from DV's perspective. Neither of these counts includes the messages stuck in a TCAP accumulator or buffer at the end of the simulation. DV does not know if it was appropriate for the RTL to drop a particular message. DV will compare the % of packets dropped_or_stuck at the end of a simulation and report an error if it exceeds an acceptable % (provided by architecture) of dropped_or_stuck packets.</span></p><h3 id="TTRIandTCAPverifplanforNcore3.2Release-5.8TCAPtimestamp">5.8 TCAP timestamp </h3><p><span class="legacy-color-text-blue3">In discussions with architecture, there is no statement of what is success or failure for Trace and Debug timestamps in the system, especially with respect to how much ordering is guaranteed to be derived from the trace messages and timestamps, whether from the same master or different masters. Because of this, DV will create some FSYS tests, and architecture will look at those tests to judge whether timestamps are working well enough.</span></p><h3 id="TTRIandTCAPverifplanforNcore3.2Release-5.9TCAPtimestampincrementing">5.9 TCAP timestamp incrementing</h3><p><span class="legacy-color-text-blue3">We used to check that every 600 trace messages the Timestamp coming out of TCAP had a higher value than the timestamp that was output 600 trace messages ago. <a class="external-link" href="https://jira.arteris.com/browse/CONC-8090" rel="nofollow">CONC-8090</a> showed why in random block-level simulation we can have timestamps that are very out-of-order and we now can only check every 2000 trace messages.</span></p><p><span class="legacy-color-text-blue3">TCAP timestamp inc/gain will be randomized, but no checks specific to those fields will be done.</span></p><h3 id="TTRIandTCAPverifplanforNcore3.2Release-5.10TCAPtimestamprollover">5.10 TCAP timestamp rollover</h3><p><span class="legacy-color-text-blue3">In the DMI test bench, in some tests DV will force a non-zero initial value for the RTL timestamp value, often to a value, such as 'hFFFF_FF00, that will soon cause a timestamp rollover.</span></p><h3 id="TTRIandTCAPverifplanforNcore3.2Release-5.11TCAPcapturesuncorrectedtracemessages">5.11 TCAP captures uncorrected trace messages</h3><p><span class="legacy-color-text-blue3">TCAP will use the uncorrected SMI messages for trace. If there is a corrected single-bit-error, that correction will not be seen in the trace stream. See <a class="external-link" href="https://jira.arteris.com/browse/CONC-8091" rel="nofollow">CONC-8091</a>.</span></p><h3 id="TTRIandTCAPverifplanforNcore3.2Release-5.12TCAPdynamicregisterprogramming">5.12 TCAP dynamic register programming</h3><p><span class="legacy-color-text-blue3">DV will sometimes change the trace register values in the middle of a block-level simulation. This will require a careful sequence of events to quiesce the system and disable trace checking before changing the register values. These steps will be different for each of the blocks: CHI, IOAIU, and DMI. This will be tested for DMI, but not for DII.</span></p><h3 id="TTRIandTCAPverifplanforNcore3.2Release-5.12TTRIandTCAPfunctionalcoverage">5.12 TTRI and TCAP functional coverage</h3><p><span class="legacy-color-text-blue3">No functional coverage was done for Beta2. The list of functional coverage collected is in the main functional coverage section of the test plan.</span></p><h1 id="TTRIandTCAPverifplanforNcore3.2Release-6.0Coveragereviewnotes(held12/16/2021)">6.0 Coverage review notes (held 12/16/2021)</h1><h3 id="TTRIandTCAPverifplanforNcore3.2Release-5.1Trigger">5.1 Trigger</h3><p>Khaleel said that dii_hui_nunitid does not need to be &gt;2.</p><p>Khaleel said that dii_hui_mig probably will not get all the way to 0xf. More clarification will be needed.</p><p>We are seeing memattr=c for CHI which is unexpected. Balaji is looking into this. It may be an atomic transaction.</p><h3 id="TTRIandTCAPverifplanforNcore3.2Release-5.2Capture">5.2 Capture</h3><p>Hardy was asked to clarify which items are coverpoints (DV) and which items are cover properties? </p><p>Which items look at the RTL value, and which look at DV?</p><p>Hardy was asked to change CCTRLR bins for which SMI ports are enabled from only 1-hot values (1,2,4,...) which does not require us to enable multiple SMI ports at once to all values 0..255.</p><h3 id="TTRIandTCAPverifplanforNcore3.2Release-5.3DVEAccumulator">5.3 DVE Accumulator</h3><p>Andrew was asked about crossing both circular/linear and full/empty with most other coverpoints.</p><p>Chien mentioned that post-3.2, he would like to see Timestamp (FRC) be a register which could be written (or read) by DV.</p><p><br/></p><p><br/></p>