<h1 id="HW-SYMVCMicroarchitectureandRestrictions-History"><strong>History</strong></h1><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Version</th><th class="confluenceTh">Date</th><th colspan="1" class="confluenceTh">Comments</th><th class="confluenceTh">Editor</th></tr><tr><td class="confluenceTd">0.1</td><td class="confluenceTd">3/31/2020</td><td colspan="1" class="confluenceTd"><ul style="list-style-type: square;"><li>Initial Document</li></ul></td><td class="confluenceTd">Eric Taylor</td></tr><tr><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td></tr></tbody></table></div><h1 id="HW-SYMVCMicroarchitectureandRestrictions-Outline"><strong>Outline</strong></h1><p><style type='text/css'>/*<![CDATA[*/
div.rbtoc1759724652688 {padding: 0px;}
div.rbtoc1759724652688 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1759724652688 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class='toc-macro rbtoc1759724652688'>
<ul class='toc-indentation'>
<li><a href='#HW-SYMVCMicroarchitectureandRestrictions-History'>History</a></li>
<li><a href='#HW-SYMVCMicroarchitectureandRestrictions-Outline'>Outline</a></li>
<li><a href='#HW-SYMVCMicroarchitectureandRestrictions-Description'>Description</a></li>
<li><a href='#HW-SYMVCMicroarchitectureandRestrictions-Introduction'>Introduction</a>
<ul class='toc-indentation'>
<li><a href='#HW-SYMVCMicroarchitectureandRestrictions-NativeLayertoCommonLayer(MappinganIncomingNativeLayerTxntoaCommonLayerTxn)'>Native Layer to Common Layer (Mapping an Incoming Native Layer Txn to a Common Layer Txn)</a>
<ul class='toc-indentation'>
<li><a href='#HW-SYMVCMicroarchitectureandRestrictions-AXI'>AXI</a></li>
<li><a href='#HW-SYMVCMicroarchitectureandRestrictions-APB'>APB</a></li>
</ul>
</li>
<li><a href='#HW-SYMVCMicroarchitectureandRestrictions-CommonLayertoQueueMapping(MappingaCommonLayerTxntoaFlowQueue)'>Common Layer to Queue Mapping (Mapping a Common Layer Txn to a Flow Queue)</a></li>
<li><a href='#HW-SYMVCMicroarchitectureandRestrictions-QueuetoVCMapping(MappingaFlowQueuetoaVC)'>Queue to VC Mapping (Mapping a Flow Queue to a VC)</a></li>
<li><a href='#HW-SYMVCMicroarchitectureandRestrictions-Summary'>Summary</a></li>
</ul>
</li>
<li><a href='#HW-SYMVCMicroarchitectureandRestrictions-ParameterRestrictions'>Parameter Restrictions</a></li>
<li><a href='#HW-SYMVCMicroarchitectureandRestrictions-PossibleMappingsforRelease1.0'>Possible Mappings for Release 1.0</a></li>
</ul>
</div></p><h1 id="HW-SYMVCMicroarchitectureandRestrictions-Description"><strong>Description</strong></h1><p>This document contains microarcitectual information about how VCs are implemented within Symphony and their restrictions.</p><p><strong style="font-size: 24.0px;">Reference Specification</strong></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166695/HW-SYM+Base+Packet+Parameters+Relationships" data-linked-resource-id="16166695" data-linked-resource-version="108" data-linked-resource-type="page">Base Packet Parameters &amp; Relationships<br /></a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16169110/Symphony+Architecture+Spec" data-linked-resource-id="16169110" data-linked-resource-version="18" data-linked-resource-type="page">Symphony Architecture Spec</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16171451/HW-SYM+Common+Layer+Transformations" data-linked-resource-id="16171451" data-linked-resource-version="65" data-linked-resource-type="page">HW-SYM Common Layer Transformations</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156349/HW-SYM+Common+Transaction+Layer+Microarchitecture+Specification" data-linked-resource-id="16156349" data-linked-resource-version="327" data-linked-resource-type="page">HW-SYM Common Transaction Layer Microarchitecture Specification</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16171836/OBSOLETE-DELETE+HW-SYM+No+VC+to+MultiVC+map" data-linked-resource-id="16171836" data-linked-resource-version="11" data-linked-resource-type="page">OBSOLETE-DELETE HW-SYM No VC to MultiVC map</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166990/OBSOLETE-DELETE+HW-SYM+Symphony+Block+Common+Characteristics" data-linked-resource-id="16166990" data-linked-resource-version="47" data-linked-resource-type="page">OBSOLETE-DELETE HW-SYM Symphony Block Common Characteristics</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166911/OBSOLETE-DELETE+HW-SYM+ATU+Common+Characteristics" data-linked-resource-id="16166911" data-linked-resource-version="20" data-linked-resource-type="page">OBSOLETE-DELETE  HW-SYM ATU Common Characteristics</a></p><h1 id="HW-SYMVCMicroarchitectureandRestrictions-Introduction"><strong>Introduction</strong></h1><p>Virtual Channels (VCs) are channels with independent flow control through a network. A packet enters a VC on the SMI interface before a packetizer and exits on the SMI interface after a depacketizer.</p><p>Flow Channels (FCs) are channels with independent flow control into a Common Layer interface. Each channel has independent flow control. A packet comes in on a FC and is forwarded to a VC at the SMI layer.</p><p><br/></p><p>In summary a transaction comes in on the Native Layer. The Native Layer puts the transaction on a specific FC. Then inside the Common Layer a transaction is mapped to a queue, and each queue is mapped to a VC.</p><p><strong style="font-size: 24.0px;">Mappings</strong></p><div><strong><br/></strong></div><div>A transaction comes into the Native Layer, and then ends up on a specific VC after a series of mappings and modifications.</div><h2 id="HW-SYMVCMicroarchitectureandRestrictions-NativeLayertoCommonLayer(MappinganIncomingNativeLayerTxntoaCommonLayerTxn)">Native Layer to Common Layer (Mapping an Incoming Native Layer Txn to a Common Layer Txn)</h2><p>A transaction comes in on the Native Layer and is forwarded to a specific FC. Each FC has independent ordering so two transactions with ordering dependencies cannot go to separate FCs. If a second transaction needs to go on a separate FC it must be barrier-ed. </p><h3 id="HW-SYMVCMicroarchitectureandRestrictions-AXI">AXI</h3><p>Currently for AXI all transactions go into a single FC. </p><p>A transaction can be modified going from AXI to the Common Layer. This is done through the parameters <strong>nativeToCommon</strong> and <strong>commonToNative</strong> using the <a class="external-link" href="https://confluence.arteris.com/display/ENGR/Generic+Assignment+Proposal" rel="nofollow">Generic Assignment Proposal</a>. The one to focus on for request is nativeToCommon.</p><p>This allows any field of the Common Layer to be driven from any AXI signal, however this space is restricted per release:</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Common Layer Signal (To)</th><th class="confluenceTh">AXI Layer Signal (From)</th><th class="confluenceTh">Release</th></tr><tr><td class="confluenceTd">user</td><td class="confluenceTd">user</td><td class="confluenceTd">1.0</td></tr><tr><td class="confluenceTd">qos</td><td class="confluenceTd">user, qos</td><td class="confluenceTd">1.0</td></tr><tr><td colspan="1" class="confluenceTd">channel_id</td><td colspan="1" class="confluenceTd">Read/Write Channel</td><td colspan="1" class="confluenceTd">1.0</td></tr><tr><td colspan="1" class="confluenceTd">multicast_mask</td><td colspan="1" class="confluenceTd">user</td><td colspan="1" class="confluenceTd">1.0</td></tr><tr><td colspan="1" class="confluenceTd">multicast_label</td><td colspan="1" class="confluenceTd">user</td><td colspan="1" class="confluenceTd">1.0</td></tr></tbody></table></div><p>Note: Syed needs to review.</p><h3 id="HW-SYMVCMicroarchitectureandRestrictions-APB">APB</h3><p>Currently for APB all transactions go into a single FC. </p><p>No remapping can be done for APB. </p><h2 id="HW-SYMVCMicroarchitectureandRestrictions-CommonLayertoQueueMapping(MappingaCommonLayerTxntoaFlowQueue)">Common Layer to Queue Mapping (Mapping a Common Layer Txn to a Flow Queue)</h2><p>Once a transaction is inside the Common Layer it will be mapped to a queue. Each queue is independent in terms of ordering so two transactions with ordering dependencies cannot go to separate queues. If a second transaction needs to go on a separate queue it must be barrier-ed. </p><p>The queue mapping is done through the parameter <strong>queueMap. </strong>queueMap is an array of Verilog statements which resolve into a 1 or 0. Each entry represents a queue. If a queues verilog statement evaluates to 1 that transaction will go into that queue. If more than 1 Verilog statesment resolves to 1 the first queue is selected. </p><p>The Common Layer Signals that can be used in this queueMap parameter are as follows (Use these specific signal names when populating queueMap):</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Common Layer Signal (ATUi)</th><th colspan="1" class="confluenceTh">SMI Signal (ATUt)</th><th class="confluenceTh">Release</th><th colspan="1" class="confluenceTh">Notes</th></tr><tr><td class="confluenceTd"><span>ctl_</span>user</td><td colspan="1" class="confluenceTd"><br/></td><td class="confluenceTd">1.0</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd"><span>ctl_</span>qos</td><td colspan="1" class="confluenceTd"><br/></td><td class="confluenceTd">1.0</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">ctl_txn_channel_id (Read/Write)</td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd">1.0</td><td colspan="1" class="confluenceTd">It is suggested that this is included (if Read/Writes arent ordered seperatly)</td></tr><tr><td colspan="1" class="confluenceTd"><span>ctl_txn_ordering_id</span></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd">1.0</td><td colspan="1" class="confluenceTd">It is suggested that this is included.</td></tr><tr><td colspan="1" class="confluenceTd"><span>ctl_multicast_label</span></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd">1.0</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd"><span>ctl_targ_id</span></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd">1.0</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd">smi_ctl_msg_valid</td><td colspan="1" class="confluenceTd">1.0</td><td colspan="1" class="confluenceTd">VCs Map directly to Queues for 1.0 so only valid can be used.</td></tr></tbody></table></div><p>Example Queue Setup:</p><p>queueMap = [</p><p>                          &quot;(<span>ctl_txn_channel_id == 0) &amp; (<span>ctl_</span><span>qos &gt; 2) &amp; (<span>ctl_txn_ordering_id[0])&quot;,</span></span></span></p><p>                          &quot;(ctl_txn_channel_id == 0) &amp; (ctl_qos &lt;= 2) &amp; (ctl_txn_ordering_id[0])&quot;,</p><p>                          &quot;(ctl_txn_channel_id == 0) &amp; (ctl_txn_ordering_id[1])&quot;,</p><p>                          &quot;(ctl_txn_channel_id == 1) &amp; (ctl_txn_ordering_id[1])&quot;</p><p>                     ]</p><p>vcMap = [ </p><p>                        0,</p><p>                        0,</p><p>                        1,</p><p>                        2</p><p>             ]</p><p>queuePriMap = [ </p><p>                        0,</p><p>                        1,</p><p>                        3,</p><p>                        3</p><p>             ]</p><h2 id="HW-SYMVCMicroarchitectureandRestrictions-QueuetoVCMapping(MappingaFlowQueuetoaVC)">Queue to VC Mapping (Mapping a Flow Queue to a VC)</h2><p>A queue has a direct map to a vc using the parameter <strong>vcMap </strong>which is am array of integers. Each entry indicates which VC the queue goes to. There are no restrictions on this.</p><h2 id="HW-SYMVCMicroarchitectureandRestrictions-Summary">Summary</h2><p>For any transaction, it will go through the Native Layer. This layer will modify the transaction based on <strong>nativeToCommon</strong> and put the transaction on a FC.</p><p>It will go through the Common Layer. The transaction will go to a queue using <strong>queueMap,</strong> and then to a VC using <strong>vcMap.</strong></p><p>The transaction will enter a VC and then exit that VC at a depacketizer.  At this point its response must go on the same VC when entering the response packetizer. </p><h1 id="HW-SYMVCMicroarchitectureandRestrictions-ParameterRestrictions"><strong>Parameter Restrictions</strong></h1><p>In a multi VC system:</p><ul style="list-style-type: square;"><li>Every ATUT must have the maxPduSize set:<ul style="list-style-type: square;"><li>To either the maxPduSize of the Network</li><li>or to a smaller size. This smaller size must be propagated to pamTargMaxBurst of each initiator for this target, and splitting must be enabled.</li></ul></li><li>Every ATUT must have a queueDpeth set to (maxPduSize / (width/8))</li><li>Every ATUT must have a queueMap indicating VC0 -&gt; queue 0. VC1 -&gt; queue 1, etc. (Release 1.0)</li><li>Arbiters with VCs must:<br/><ul style="list-style-type: square;"><li><p>If mstrArbLck is true then mstrArbRdyAware must be true.</p></li><li>lckStyleVld: True unless a pipe stage or flop follows it. (Needs to be set to false for performance reasons in this case)</li><li>mstrArbRdyAware must feed into an ATP pipe.</li></ul></li><li>All switches must be buffered switches.</li><li>Suggested: Any  {ordering_id, channle_id} should only map to 1 queue. <ul style="list-style-type: square;"><li>Not needed if the master guarantees unique ids per txn, or whatever mapping they so decide.</li></ul></li></ul><p><br/></p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Version</th><th class="confluenceTh">Restriction</th></tr><tr><td class="confluenceTd">1.0</td><td class="confluenceTd"><ul><li>Number of VCs == Number of Queues in ATUt &gt;= Number of Queues in ATUi</li><li>At the ATUt each VC will map directly to a Queue.</li></ul></td></tr><tr><td class="confluenceTd"><br/></td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd"><br/></td><td class="confluenceTd"><br/></td></tr></tbody></table></div><p><br/></p><h1 id="HW-SYMVCMicroarchitectureandRestrictions-PossibleMappingsforRelease1.0"><strong>Possible Mappings for Release 1.0</strong></h1><p><strong>AXI to Queue</strong></p><p>The following AXI signals can determine which queue a transaction goes into:</p><ul><li>Label - PAM[<strong>AxADDR</strong>].label or <strong>AxUSER</strong>[LABEL] - Bits of user that indicate multicast label - Depending on if label comes from User or PAM</li><li>User <strong>- AxUSER</strong>[CUSTOM] - Some custom user bits that are used for queue mapping</li><li>ID <strong>- AxID</strong></li><li>QoS <strong>- AxQoS</strong></li><li>R/W - Sourced from <strong>AWVALID</strong> or <strong>ARVALID</strong> - Read Write Channel</li><li>Target - PAM[<strong>AxADDR</strong>].tid - The target ID of a pam Lookup for an address.</li></ul><p>Any combination of above can be used to determine which queue a transaction goes in to. </p><p>Below are some example combinations of above which can map a transaction into a queue:</p><ul><li>(ID &gt;= 4) &amp; (label == 1)</li><li>(R/W == R) &amp; (QoS &lt; 3)</li><li>(Target == 3) &amp; (ID &lt;=2) &amp; (label == 2)</li></ul><p><strong>Queue to Map</strong></p><p>vcMap the will map a queue to a specific VC</p><p><br/></p><p><br/></p><p><br/></p><p><br/></p><p><br/></p>