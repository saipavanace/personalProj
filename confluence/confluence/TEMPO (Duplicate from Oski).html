<h1 id="TEMPO(DuplicatefromOski)-Introduction">Introduction</h1><p> Tempo is an Arteris developed system-level coherency checker. It monitors the NoC AMBA (CHI-A/B, ACE/ACI-Lite-E/AXI-4) interfaces and the DCE and checks that the data passed between units is done so consistently and coherently with the ordering set by the DCE. At the same time, the states kept by the Noc attached units are checked to assure data is kept in the units coherently, i.e., with the prober state as determined from a system-level perspective.</p><p> Tempo is written in python (v3.7) and compiled into a single binary that DV can easily integrate into the DV environment independently of python revisions and other complicating circumstantial compute environment conditions. This allows Tempo to be run stand-alone independently of the RTL, facilitating development.</p><p> The Tempo flow is based on a trace generated by the ncore_trace_module.sv file compiled with the DV-RTL. As a test is run, a trace is accordingly generated which is then passed to Tempo along with a .json file. The .json file holds the system configuration for which the trace was generated. Tempo interpreted the .json file to determine how the trace should be interpreted. This permits an unlimited set of configurations for Tempo to check.</p><p> Tempo permits the intermixing of coherent and non-coherent operations as long as there's no address-space overlap. Tempo supports all the operation types on all the listed interface types, including non-data operations, which though may have line state implications. Tempo supports all the state transitions possible in the AMBA spec. including operations which are the result of silent evictions and internal software invalidations. For cases where Tempo is not able to check due to software operations that legally (as per the spec) upset the system coherency, Tempo will void checking but can recover checking provided coherent operation is recommenced.</p><h1 id="TEMPO(DuplicatefromOski)-ChecksbyTempo">Checks by Tempo</h1><p> Tempo conducts checks for coherent operations. This means coherent reads and writes, including the outcome of coherent atomic operations. In general read-data in the trace is checked against the last ordered produced data. If no data was produced prior to a read, Tempo conducts an end-2-end check with the last data read on the DMI interface.</p><p> Tempo checks full and partial lines and observes the address offsets and BEs for the data checks.</p><p> Tempo checks that the line states across units are legal. Three conditions are observed (by line is meant line for a given address):</p><ol><li>If one master has a unique line, all other masters must have invalid lines.</li><li>If more than one master has a valid line, all masters lines must be marked shared or invalid</li><li> If one master has a shared-dirty line, all other masters lines must be marked shared-clean or invalid</li></ol><h1 id="TEMPO(DuplicatefromOski)-Tempolimitations">Tempo limitations</h1><p> Tempo will not work if coherent and non-coherent address-space is overlapped and write operations are issued by non-coherent agents. By 'not work' is meant the coherent checking will likely fail. Tempo will catch this, so in a sense, it does work for this scenario, and thus can be used for software debug.</p><p> At the time of writing, Tempo does not include checking on exclusives.</p><h1 id="TEMPO(DuplicatefromOski)-Tempointernals">Tempo internals</h1><p> Tempo is organized in an object-oriented manner, to facilitate independent development of the various AMBA interface types and future expansion, be that new interfaces or updates to existing interfaces. Like the Arteris NoC, AMBA operations are converted to an internal (transaction) format which is passed to a top-level. This permits the top-level checker to be agnostic to the AMBA interfaces used in a given configuration.</p><p> The hierarchical organization is checker -&gt; unit -&gt; interface. When Tempo is started up the .json file is read and interpreted. This is used to configure the .json specified units of Tempo with the .json specified interface. There's no limit to the number of units supported by Tempo, besides possibly server memory limitations.</p><p> After configuration, Tempo reads the trace file line by line. Each trace line is passed to the associated unit and from there to the associated interface for interpretation. The interface trace-line interpreter builds a record for each transaction and gathers all information (address, data, response etc.) into a single record that is passed back to the top-level. The top-level passes the outcome of each completed transaction (address, data and address order) to a data checker and a state checker. The top-level also passes each completed transaction to a debugger, which records the transaction into an order list, handy for error reporting, and debug. </p><p> The Tempo data checker builds a last-producer-data-record based on the transactions passed to it. This record is updated by writes. As read transactions are passed to the checker, they can be checked against the last-producer-record. If a mismatch is found, this is flagged and Tempo will return a failure outcome.</p><p> The Tempo state checker builds a unit state record for each line operated in the system. The unit state record holds the line state for each master in the system. The unit-state-record is updated on data returns where the state is returned with the data. </p><p> Tempo also builds a memory data record, which records the reads from the DMI interface. This is used for the cases where no prior write occurred to a given address, so a reference data point can be obtained, even without writes. </p><h1 id="TEMPO(DuplicatefromOski)-Historicals">Historicals</h1><p> Tempo was originally attempted built in C++, which hit some snags. The documentation from this effort is kept below for reference.</p><h1 id="TEMPO(DuplicatefromOski)-ExternalDependencies"><s>External Dependencies</s></h1><p><s>Checker depends on following Libraries</s></p><ul><li><s>nlohmann_json</s><ul><li><s>Version:</s></li><li><s>Location: Currently in my 'home/anippuleti/third_party/'. TODO: need to move it to central location.</s></li><li><s>Description: For JSON parser</s></li></ul></li><li><s>Boost File system</s><ul><li><s>Version: 1.53 and above</s></li><li><s>Location: Available on gr6-3 (/usr/include/boost)</s></li><li><s>Description: For file handling</s></li></ul></li><li><s>Catch2</s><ul><li><s>Version:</s></li><li><s>Location: Currently in my 'home/anippuleti/third_party/'. TODO: need to move it to central location.</s></li><li><s>Description: This library is unit testing framework. None of the production executables require this library.</s></li></ul></li></ul><h1 id="TEMPO(DuplicatefromOski)-BuildStepsforTempo"><s>Build Steps for Tempo</s></h1><ul><li><s>git clone <a class="external-link" href="http://gitlab.arteris.com/hardware/tempo.git" rel="nofollow">http://gitlab.arteris.com/hardware/tempo.git</a></s></li><li><s>module load maestro</s></li><li><s>git clone <a class="external-link" href="http://gitlab.arteris.com/hardware/hw-test-projects" rel="nofollow">http://gitlab.arteris.com/hardware/hw-test-projects</a></s></li><li><s>setenv TEST_PRJ `pwd`/hw-test-projects</s></li><li><s>cd tempo</s></li><li><s>mkdir -p build_rls &amp;&amp; mkdir -p build_dbg</s></li><li><s>cd build_rls</s></li><li><s>cmake -DCMAKE_BUILD_TYPE=Release ..</s></li><li><s>make -j 12</s></li><li><s>cd build_dbg</s></li><li><s>cmake -DCMAKE_BUILD_TYPE=Debug ..</s></li><li><s>make -j 12</s></li></ul><p><s>Above steps will create a binary ‘wrappers/tempo_hw’ in build_rls/ and build_dbg/ directory that needs to be shipped to a common location visible to all other scripts like ‘/engr/dev/tools/tempo/release/tempo_hw’ and ‘/engr/dev/tools/tempo/debug/tempo_hw’ respectively.</s></p><p><s>Steps to run executable</s></p><ul><li><s>./tempo_hw      &lt;ARG1&gt;                &lt;ARG2&gt;</s></li><ul><li><s>&lt;ARG1&gt; : full path to “maestro generated DV-JSON”.</s></li><li><s>&lt;ARG2&gt; : full path to “concerto_trace.txt” generated from Full system simulations.</s></li></ul></ul><p><s>Qualifications to release binary.</s></p><ul><li><s>Following unit tests must pass to release the binary. I will include a couple more tests to run on actual full system traces for various configurations.</s></li><ul><li><s>cd build</s></li><li><s>./config/test_config</s></li><li><s>./interfaces/test_inf</s></li><li><s>./ncr-ckr/test_ncr-ckr</s></li></ul></ul><p><s>After above steps, we will modify the “run_sim” script to execute above command after Full system runs if “+en_tempo” knob is specified on command line. Execution of above script returns 0 if test pass or else return a non-zero value. Also result log “tempo.log” is always generated in the directory specified by &lt;ARG2&gt;.</s></p><p><s>Conditions of Bucketize script to evaluate if Full system test passed or failed from Checker perspective.</s></p><ul><li><s>If buctktize can open file “tempo.log” in directory specified by &lt;ARG2&gt; and if last line in the file is “TEST PASSED”. In all other scenarios, script can safely that test failed.</s></li></ul><h1 id="TEMPO(DuplicatefromOski)-Assumptions">Assumptions</h1><ul><li><s>If fabric supports 0 cycle delay then we must add #0 delay on all RX SMI ports. Checker does not has logic to perform scheduling if RX-flit is observed in trace before TX-flit is observed</s>.</li><li>Due to limitations in &quot;Flit_scheduler&quot;, current checker supports only 1 SMI DP port per ncore unit (1 in TX direction and one in RX direction). Ncore-v3.0 supports only one (TX, RX) SMI DP port per ncore unit. Will require fixes for &quot;Flit_scheduler&quot; logic if in future Ncore architecture supports multiple DP ports per Ncore unit.</li><li>For Ncore-v3.0, Can we constrain the system to have 1 DMI per Interleaved Group? Current implementation only supports 1 DMI per interleaved group. <br/><ul><li>Changes required in Ncore_config<ul><li>Calculation of nDmis</li><li>Change to method dmi_dii_unitid_assoc2addr()</li></ul></li></ul></li></ul><h2 id="TEMPO(DuplicatefromOski)-MissingChecks">Missing Checks</h2><ul><li>No checks to predict Recalls in DCE directory. Checker monitors this RTL interface to determine if recall will happen.</li><li>No checks to detrermine which transactions will allocate in CCP (both in IO-AIU and in DMI). Checker monitors this RTL interface to determine if allocation will happen.</li><li>No checks to determne CCP evicitions. Checker monitors this RTL interface asuumes it has an input.</li></ul><h1 id="TEMPO(DuplicatefromOski)-Flits">Flits</h1><p>Below are various flits captured and forwarded to &quot;Nc_env::System_checker&quot;. Depending on Ncore configuration certain flits may not ever generate.</p><ul><li>CHI Flit (Nc_cmn::Chi_flit)</li><li>AXI Flit (Nc_cmn::Axi_flit) &quot;all variations of AXI are captured in this class, ACE/ACE-LITE/ACE-LITE-E&quot;</li><li>SMI Flit (Nc_cmn::Smi_flit)</li><li>DRM Flit (Nc_cmn::Drm_flit) DCE's directory interface information is captured in this class.</li><li>CCP Flit (Nc_cmn::Ccp_flit) CCP in either IO-AIU and DMI is captured by this class.</li></ul><p>Actual data that is transferred along the flit is captured by &quot;Nc_cmn::Data_flit_stream&lt;Nc_cmn::Flit_interfaces V&gt;&quot; class. This interface specific template class holds the data and byte-enables. Control information in every flit is stored until this transaction is active from NCORE perspective. But associated data is not stored on every interface hop. We either compare on every interface hop or store it in &quot;Nc_env::Data_cache&quot; or both might happen.</p><p>Below are generic methods that are present in every Flit class. Couple of overload functions depend on return &quot;type&quot; of these methods. Depending on the return &quot;type&quot;, correct method in overload set is invoked. This simplifies the user code. Hence below methods must be implemented for every flit to compile successfully. Method signatures must also be same.</p><ul><li>&lt;IF&gt;_flit_type <span class="legacy-color-text-orange1">get_flit_type() const</span>;     //&lt;IF&gt; is either CHI or AXI or SMI or DRM or CCP.</li><li>Flit_dir <span class="legacy-color-text-orange1">get_flit_direction() const;</span></li><li>unsigned <span class="legacy-color-text-orange1">get_probed_unitid() cons</span>t;</li><li>unsigned long long <span class="legacy-color-text-orange1">get_cur_time() const;</span></li><li>&lt;return type&gt; <span class="legacy-color-text-orange1">get_msg_type() const</span>;</li><li>std::string <span class="legacy-color-text-orange1">get_unit_type() const</span>;</li></ul><h1 id="TEMPO(DuplicatefromOski)-SystemCheckerDescription">System Checker Description</h1><p><br/></p><h2 id="TEMPO(DuplicatefromOski)-FlitScheduler">Flit Scheduler</h2><p>This component holds certain flits until entire information (other flits) are received or might store certain fields within control flit so that when data flit arrives, it is able to map it to associated scoreboard transaction. Below explanation is per flit type.</p><h3 id="TEMPO(DuplicatefromOski)-CHIFlits">CHI Flits</h3><p>Nothing to store in flit scheduler for CHI flits. All the information is received on single channel.</p><h3 id="TEMPO(DuplicatefromOski)-AXIFlits">AXI Flits</h3><p>For Writes on AXI channel, WrReq and WrDat flits appear on different channels. As per AXI specification, Only the order requests and associated is guaranteed either can appear one before the other and WrDat are multi-beat transactions. Hence below Data structures and methods are provided by this class to map WrReq to WrDat</p><ul><li>Data Structures<ul><li>awid2dat_map  //Queue associating agent-id to WR request AxId.</li><li>axi_wdatq         //Queue holds all WR-DAT flits.</li></ul></li><li>Methods<ul><li>pending_rsps4req( WrReq )                //Method returns true if there exists a WrData flit for incoming WrReq.</li><li>store_copy4future_lkup( WrReq )       //Method stores agent-id and its AxId to map WrDat</li><li>req_exists4rsp( WDat )                       //Method returns true if Request is already received for incoming WrDat</li><li>pop_req_copy( WrDat )                      //Method returns AxID associated to WrData</li><li>pop_pending_rsps( AwReq )              //Method returns all the AwData associated to this AwReq.</li><li>store_inc_flit( WDat )                          //Method to store WData.</li></ul></li><li>Usage<ul><li>If a WrReq is received, then the Ncore_sys will check if pending WrData flits exists (invoke pending_rsps4req). If flits exist, then pop_pending_rsps() is invoked to get all WrData flits. If last is not observed then a copy of axid and agent-id are stored in scheduler for future associated WDAT flits. If pending_rsps4req() returns false, then store_copy4future_lkup() is invoked.</li><li>If WrData flit is received, req_exists4rsp() is invoked to check if request has already arrived. if true, then pop_req_copy is invoked else store_inc_flit() will be invoked.</li></ul></li></ul><h3 id="TEMPO(DuplicatefromOski)-SMIFlits">SMI Flits</h3><p>For SMI data flits (DTW and DTR requests), NDP and DP flits travel in two different channels. Smilar to AXI-WR requests, same set of SMI specific data structures and methods are used. Only difference is, we store the pointer to actual copy of NDP control packet.</p><h3 id="TEMPO(DuplicatefromOski)-DRMFlits">DRM Flits</h3><p>For Directory flits, DCE LKUP-REQ flit is stored has they arrive and when associated DCE LKUP-RSP is observed, request is forwarded. Response associated to a request is always ordered (i.e. request arrives prior). Within Directory, when a correctable error RSP gets stalled, gets corrected and issued on next cycle. Everything in pipeline gets stalled. Hence no special handling is required.</p><ul><li>Data Structure<ul><li>drm_lkupq      //Queue stores &lt;agent-id, LKUP-REQ&gt;</li></ul></li><li>Methods<ul><li>pop_org_req( LKUP-RSP )  //Returns LKUP-REQ flit associated to response</li><li>store_inc_flit( LUUP-REQ ) //Stores requests in order.</li></ul></li></ul><h3 id="TEMPO(DuplicatefromOski)-CCPFlits">CCP Flits</h3><p>CCP can exist in either IO-AIU or DMI. Both the interfaces are monitored. In addition for CCP inside DMI, scratchpad interface is also monitored.Similar to DRM flits, a LKUP-RSP cannot appear before REQ. Also correctable errors are handled by this block.</p><ul><li>Data Structures<ul><li>ccp_lkupq          //Queue</li><li>ccp_ce_detect   //Stores the time stamp when correctable error happened.</li></ul></li></ul><h2 id="TEMPO(DuplicatefromOski)-TransactionManagerandDataCacheinteractions">Transaction Manager and Data Cache interactions</h2><p><a href="/wiki/spaces/ENGR/pages/16777371/TEMPO+Duplicate+from+Oski?preview=%2F16777371%2F16784277%2FTransaction_senarios.xlsx"><span style="background: url('/wiki/s/-672721829/6452/d621ad2a33e27b90ca05c475b216bfab745e08a2/1000.0.0-d621ad2a33e2/_/download/resources/com.atlassian.confluence.plugins.confluence-view-file-macro:view-file-macro-resources/images/placeholder-medium-spreadsheet.png'); width: 250px; height: 95px; display: inline-block; padding-top: 155px; margin: 2px; border: 1px solid #ddd; text-align: center; vertical-align: text-bottom; text-decoration: none; font-size: 12px; color: #000;">Transaction_senarios.xlsx</span></a></p><p><br/></p><h1 id="TEMPO(DuplicatefromOski)-CheckerTraceFormat">Checker Trace Format</h1><p>Goal here is to create module 'ncore_probe_monitor' that probes various interfaces of NCORE units and prints data in a specific format into a file 'concerto_trace.txt'. Data is printed into the file only if valid data on respective interface. For some blocks, certain internal interfaces are also probed (Ex: CCP). Below description is detailed explanation of these interfaces.<br/>All the signals must be sampled on negative edge of the clock. Since we want to implement synthesizable Verilog code to monitor these signals, sampling on neg-edge will avoid us from hitting race conditions due to simulator behavior.<br/>For Ncore 3 System testbench, we will instantiate this module in system TB-TOP (concerto_tb_top).</p><h2 id="TEMPO(DuplicatefromOski)-Unit-IDCalculation">Unit-ID Calculation</h2><p>For Ncore-3, CPP system checker views ncore units in following order. Later when 'MyID' is properly defined for each block, we can create an internal map between them. Unit ID ordering starts from 0 and goes all the way to total number of blocks minus 1. The order is</p><ul><li>AIU's (includes CHI-AIU's, ACE-AIU's, ACE-Lite AIU's, ACE-Lite-E AIU's and various proxy caches)</li><li>DCE's</li><li>DVE</li><li>DMI's</li><li>CSR-DII</li><li>DII's</li></ul><p>AIU's:</p><ul><li>start = 0</li><li>end = total AIU's – 1</li></ul><p>DCE's:</p><ul><li>start = total AIU's</li><li>end = total AIU's + total DCE's – 1</li></ul><p>DVE:</p><ul><li>start = total AIU's + total DCE's</li><li>end = total AIU's + total DCE's + 1 (DVE) – 1</li></ul><p>DMI's</p><ul><li>start = total AIU's + total DCE's + 1</li><li>end = total AIU's + total DCE's + 1 + total DMI's – 1</li></ul><p>CSR-DII</p><ul><li>start = total AIU's + total DCE's + 1 + total DMI's</li><li>end = total AIU's + total DCE's + 1 + total DMI's + 1 (CSR-DII) – 1</li></ul><p>DII's</p><ul><li>start = total AIU's + total DCE's + 1 + total DMI's + 1</li><li>end = total AIU's + total DCE's + 1 + total DMI's + 1 + total DII's – 1</li></ul><h2 id="TEMPO(DuplicatefromOski)-Limitations">Limitations</h2><ol><li>pkt_type: [0, 256) //Value of pkt_type can be within 0 to 255 (including). Refer below for definition of pkt_type</li><li>All values logged into the trace must be Hex-decimal values.</li><li>Depending on size of the signal, required number of zeros must be pre-appended by the trace generator logic (by ncore_probe_module)<ol><li>Example: If SMI NDP length is 120 bits then the length of the string in trace must be 30 charters. Below last column is 30 characters <br/><ol><li>24:10: &lt;...&gt;:000000000000007C0F93FF0505F0F0</li></ol></li></ol></li></ol><h2 id="TEMPO(DuplicatefromOski)-CHITraceFormat">CHI Trace Format</h2><p>Below is the format that the values must be displayed in the file. Colon ':' is the separator. For the details about each field, refer to the description.<br/>&lt;pkt_type&gt;:&lt;Time&gt;:&lt;UnitID&gt;:&lt;Flit&gt;</p><ul><li>pkt_type: Packet type indicates channel on which flit is observed. It also implies the direction of the flit (TX/RS). Directions are with respect to RTL (NCORE DUT). Please refer to CHI specification &quot;Chapter 12.5&quot; for additional details.</li></ul><p><br/></p><div class="table-wrap"><table class="wrapped confluenceTable"><tbody><tr><td class="confluenceTd"><p>Channel</p></td><td class="confluenceTd"><p>Value</p></td><td class="confluenceTd"><p>Description</p></td></tr><tr><td class="confluenceTd"><p>RXREQ</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>Channel on which RTL receives requests from BFM</p></td></tr><tr><td class="confluenceTd"><p>RXRSP</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>Channel on which RTL receives responses from BFM</p></td></tr><tr><td class="confluenceTd"><p>RXDAT</p></td><td class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>Channel on which RTL receives data from BFM.</p></td></tr><tr><td class="confluenceTd"><p>TXREQ (in future)</p></td><td class="confluenceTd"><p><br/></p></td><td class="confluenceTd"><p><br/></p></td></tr><tr><td class="confluenceTd"><p>TXRSP</p></td><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>Channel on which RTL drives responses to BFM</p></td></tr><tr><td class="confluenceTd"><p>TXDAT</p></td><td class="confluenceTd"><p>5</p></td><td class="confluenceTd"><p>Channel on which RTL drives responses to BFM.</p></td></tr><tr><td class="confluenceTd"><p>TXSNP</p></td><td class="confluenceTd"><p>6</p></td><td class="confluenceTd"><p>Channel on which RTL drives snoop requests to BFM</p></td></tr><tr><td class="confluenceTd"><p>RX-link</p></td><td class="confluenceTd"><p>8</p></td><td class="confluenceTd"><p>Signals {rxactivereq, rxactiveack} values of RTL are concatenated and displayed in &lt;Flit&gt; field.</p></td></tr><tr><td class="confluenceTd"><p>TX-link</p></td><td class="confluenceTd"><p>9</p></td><td class="confluenceTd"><p>Signals {txactivereq, txactiveack} values of RTL are concatenated and displayed in &lt;Flit&gt; field. <br class="atl-forced-newline"/><br class="atl-forced-newline"/>Below table is true for both TX and RX links</p></td></tr><tr><td class="confluenceTd"><p>REQ</p></td><td class="confluenceTd"><p>ACK</p></td><td class="confluenceTd"><p>STATE</p></td></tr><tr><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>STOP</p></td></tr><tr><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>ACTIVE</p></td></tr><tr><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>RUN</p></td></tr><tr><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>DEACTIVE</p></td></tr><tr><td class="confluenceTd"><p><br/></p></td><td class="confluenceTd"><p><br/></p></td><td class="confluenceTd"><p><br/></p></td></tr></tbody></table></div><p><br/></p><ul><li>time: This is current simulation time $time</li><li>UnitID: Blocks ID that's being monitored. Refer to Unit-ID description for additional details</li><li>Flit: flit is the data that is being transferred to the NCORE CHI-AIU. For TXREQ, TXRSP, TXDAT, RXRSP, RXDAT and RDAT channels corresponding valid signals must be monitored only if valid asserted, then on neg-edge corresponding FLIT signal value is printed into the file.</li></ul><p>Below is the sample code example for one such example:<br/>NOTE: Below example is for reference on what we want to view in the generated file. Implementation may vary. One advantage of directly referring to RTL signals without assigning to local variables is that we don't have to figure out the signal bus widths. <br/>NOTE: In general, we want to print all the fields in hex-decimal format.</p><p>NOTE: When ever there is a change in value on TXLINK and RXLINK signals then these values must be logged. Exception only for these signals.</p><p>module ncore_probe_monitor();</p><p>      `include &quot;ncore_defines.svh&quot; //File contains all macors.<span class="confluence-anchor-link" id="TEMPO(DuplicatefromOski)-_GoBack"><span class="confluence-anchor-link" id="_GoBack"></span></span> <br class="atl-forced-newline"/>&lt;% obj.AiuInfo.foreach(function(bundle, indx) { %&gt;<br/>&lt;% var unitID = indx; %&gt;<br/>&lt;% if (bundle.fnNativeInterface === &quot;CHI&quot;) { %&gt;<br/>              always @(negedge `AIU&lt;%=unitID&gt;.clk) /<strong>`AIU0 is the hierarchical path</strong>/<br/>                    if (`AIU&lt;%=unitID&gt;.RXREQFLITV)<br/>                         $fdisplay(file_handle, &quot;%0h:%0h:%0h:%0h&quot;,<br/>                                        pkt_type, $time, &lt;%=unitID%&gt;, AIU&lt;%=unitID%&gt;.RXREQFLIT);<br/>              end</p><p><br/>            wire clk&lt;%=unitID%&gt; = `AIU&lt;%=unitID&gt;.clk; /<strong>`AIU0 is the hierarchical path</strong>/<br/>            wire flit_vld&lt;%=unitID%&gt;;<br/>&lt;% } %&gt;<br/>&lt;% }); %&gt;</p><p><br/>endmodule: ncore_probe_monintor</p><h2 id="TEMPO(DuplicatefromOski)-AXITraceFormat">AXI Trace Format</h2><p>For AXI, formats vary depending on the channel type. Below description is per channel</p><h3 id="TEMPO(DuplicatefromOski)-Readrequestchannel">Read request channel</h3><p>If AR-valid and AR-ready are asserted on negedge of clock, then below information is gathered. Description of these signals will be in AXI specification. <br/>&lt;pkt_type&gt;:&lt;Time&gt;:&lt;UnitID&gt;:&lt;arid&gt;:&lt;araddr&gt;:&lt;arlen&gt;:&lt;arsize&gt;:&lt;arburst&gt;:&lt;arlock&gt;:&lt;arcache&gt;:&lt;arprot&gt;:&lt;arqos&gt;:&lt;arregion&gt;:&lt;aruser&gt;:&lt;ardomain&gt;:&lt;arsnoop&gt;:&lt;arbar&gt;</p><ul><li>pkt_type: Value for read request channel is 12</li><li>time: This is current simulation time $time</li><li>UnitID: ID of the block whose native interface type is AXI.</li></ul><p>All the other fields are standard AXI fields</p><h3 id="TEMPO(DuplicatefromOski)-Writerequestchannel">Write request channel</h3><p>If AW-valid and AWR-ready are asserted on neg-edge of clock, then below information is gathered.<br/>&lt;pkt_type&gt;:&lt;Time&gt;:&lt;UnitID&gt;:&lt;awid&gt;:&lt;awaddr&gt;:&lt;awlen&gt;:&lt;awsize&gt;:&lt;awburst&gt;:&lt;awlock&gt;:&lt;awcache&gt;:&lt;awprot&gt;:&lt;awqos&gt;:&lt;awregion&gt;:&lt;awuser&gt;:&lt;awdomain&gt;:&lt;awsnoop&gt;:&lt;awbar&gt;:&lt;awunique&gt;</p><ul><li>pkt_type: Value for read request channel is 13</li></ul><p>All other fields are standard AXI fields. Time and UnitID are specified above.</p><h3 id="TEMPO(DuplicatefromOski)-Writedatachannel">Write data channel</h3><p>If Wvalid and Wready are asserted on neg-edge of clock, then below information is gathered.<br/>&lt;pkt_type&gt;:&lt;Time&gt;:&lt;UnitID&gt;:&lt;wuser&gt;:&lt;wdata&gt;:&lt;wbe&gt;:&lt;wlast&gt;</p><ul><li>pkt_type: Value for read request channel is 14</li></ul><p>All other fields are standard AXI fields. Time and UnitID are specified above.</p><h3 id="TEMPO(DuplicatefromOski)-WriteResponsechannel">Write Response channel</h3><p>If B-valid and B-ready are asserted on neg-edge of clock, then below information is gathered.<br/>&lt;pkt_type&gt;:&lt;Time&gt;:&lt;UnitID&gt;:&lt;bid&gt;:&lt;bresp&gt;:&lt;buser&gt;</p><ul><li>pkt_type: Value for read request channel is 15</li></ul><p>All other fields are standard AXI fields. Time and UnitID are specified above.</p><h3 id="TEMPO(DuplicatefromOski)-ReadDatachannel">Read Data channel</h3><p>If R-valid and R-ready are asserted on neg-edge of clock, then below information is gathered.<br/>&lt;pkt_type&gt;:&lt;Time&gt;:&lt;UnitID&gt;:&lt;rid&gt;:&lt;rresp&gt;:&lt;ruser&gt;:&lt;rdata&gt;<span class="inline-comment-marker" data-ref="d41eee61-a2f2-416e-be37-7f02544e2ec8">:&lt;rlast&gt;</span></p><ul><li>pkt_type: Value for read request channel is 16</li></ul><p>All other fields are standard AXI fields. Time and UnitID are specified above.</p><h3 id="TEMPO(DuplicatefromOski)-SnoopRequestchannel">Snoop Request channel</h3><p>Snoop address channel information is logged if acvalid and acready are asserted. This channel is valid for ACE interface</p><p>&lt;pkt_type&gt;:&lt;Time&gt;:&lt;UnitID&gt;:&lt;acaddr&gt;:&lt;acsnoop&gt;:&lt;acprot&gt;</p><ul><li>pkt_type: Value for Snoop request channel is 17.</li></ul><h3 id="TEMPO(DuplicatefromOski)-SnoopResponsechannel">Snoop Response channel</h3><p>Snoop response channel information is logged if crvalid and crready are asserted. This channel is valid for ACE interface</p><p>&lt;pkt_type&gt;:&lt;Time&gt;:&lt;UnitID&gt;:&lt;crrsp&gt;</p><ul><li>pkt_type: Value for Snoop response channel is 18.</li></ul><h3 id="TEMPO(DuplicatefromOski)-SnoopDataChannel">Snoop Data Channel</h3><p>Snoop data channel information is logged if cdvalid and cdready are asserted This channel is valid for ACE interface</p><p>&lt;pkt_type&gt;:&lt;Time&gt;:&lt;UnitID&gt;:&lt;cddata&gt;:&lt;cdlast&gt;</p><ul><li>pkt_type: Value for Snoop response channel is 19.</li></ul><h3 id="TEMPO(DuplicatefromOski)-RACK">RACK</h3><p>Below information is logged if signal rack is asserted. This signal exists if it is a ACE interface</p><p>&lt;pkt_type&gt;:&lt;Time&gt;:&lt;UnitID&gt;</p><ul><li>pkt_type: Value for RACK is 20</li></ul><h3 id="TEMPO(DuplicatefromOski)-WACK">WACK</h3><p>Below information is logged if signal rack is asserted. This signal exists if it is a ACE interface</p><p>&lt;pkt_type&gt;:&lt;Time&gt;:&lt;UnitID&gt;</p><p>pkt_type: Value for WACK is 21</p><h2 id="TEMPO(DuplicatefromOski)-SMITraceFormat">SMI Trace Format</h2><p>SMI has total 4 different formats of logging. Two are for NDP (1 for RX and 1 for TX) and two for DP. When &quot; ***_ndp_ready &quot; &amp;&amp; &quot; ***_ndp_valid &quot; is asserted below information is logged.<br/>Directions TX and RX are determined from NCORE unit perspective.</p><h3 id="TEMPO(DuplicatefromOski)-NDPMessage">NDP Message</h3><p>NDP message must be latched when ndp_valid and ndp_ready are asserted and dp_present is set to 0 on neg-edge of the clock. <br/>&lt;pkt_type&gt;:&lt;Time&gt;:&lt;UnitID&gt;:&lt;ndp_length&gt;:&lt;target_id&gt;:&lt;source_id&gt;:&lt;message_id&gt;:&lt;msg_type&gt;:&lt;h_prot&gt;:&lt;msg_tier&gt;:&lt;steering&gt;:&lt;priority&gt;:&lt;qos&gt;:&lt;body&gt;:&lt;ndp_dp_preasent&gt;</p><ul><li>pkt_type:For TX-port value is 24 and for RX-port value is 25, TX and RX are with respect to Ncore unit (DUT).</li></ul><p>All the other fields are standard SMI NDP fields.</p><h3 id="TEMPO(DuplicatefromOski)-DPMessage">DP Message</h3><p>DP message must logged when &quot; ***_dp_valid &quot; &amp;&amp;  &quot; ***_dp_ready &quot; on neg-edge to latch the message information. <br/>&lt;pkt_type&gt;:&lt;Time&gt;:&lt;UnitID&gt;:&gt;:&lt;{dp_data, dp_user}&gt;:&lt;dp_last&gt;</p><ul><li>pkt_type:For TX-port value is 26 and for RX-port value is 27, TX and RX are with respect to Ncore unit (DUT).</li><li>dp_data and dp_user information must be concatenated in above specified order to reuse the parsing logic implemented for CHI interface.</li></ul><p>Each Ncore unit has multiple SMI port. We don't differentiate per Ncore unit. For example, AIU has 2 TX-NDP ports (1 for CMD and UPD requests and 1 for responses); 2 RX-NDP ports (1 for SNP, STR requests and one for all response); 1TX-DP and 1 RX-DP. Note that DP message consists all of NDP too. <br/>Hence in logs following values are latched</p><ul><li>24:t1:0: etc (For TX-NDP -1)</li><li>24:t2:0: etc (For TX-NDP -2)</li><li>25:t3:0: etc (For RX-NDP -1)</li><li>25:t6:0: etc (For RX-NDP -2)</li><li>26:t5:0: etc (For TX-DP -1)</li><li>27:t6:0: etc (For RX-DP -1)</li></ul><p><br/></p><h2 id="TEMPO(DuplicatefromOski)-CCPTraceFormat">CCP Trace Format</h2><p>Depending on configuration, CCP sub-block might exists in IO-AIU, DMI. If the block exists, then CCP interface P2 signals are monitored for Ncore system checker. Below information is logged depending ready and valid signals</p><div class="table-wrap"><table class="wrapped confluenceTable"><tbody><tr><th class="confluenceTh">pkt_type</th><th class="confluenceTh">Logged if expression in true</th><th class="confluenceTh">Trace format</th></tr><tr><td class="confluenceTd">64 (LKUP REQ)</td><td class="confluenceTd">ctrl_op_valid_p0 &amp;&amp; <span class="inline-comment-marker" data-ref="163186bd-9120-4ac9-8ed8-a8a39e89c11c">cache_op_ready_p0</span></td><td class="confluenceTd">&lt;pkt_type&gt;:&lt;Time&gt;:&lt;UnitID&gt;:&lt;addr&gt;:&lt;ns&gt;</td></tr><tr><td class="confluenceTd">65 (LKUP RSP)</td><td class="confluenceTd">cache_valid_p2</td><td class="confluenceTd">&lt;pkt_type&gt;:&lt;Time&gt;:&lt;UnitID&gt;:&lt;cur_state&gt;:&lt;map2ntvif&gt;:&lt;op_state&gt;:&lt;misc_info&gt;</td></tr><tr><td class="confluenceTd">66 (EVICT)</td><td class="confluenceTd">cache_evict_valid_p2</td><td class="confluenceTd">&lt;pkt_type&gt;:&lt;Time&gt;:&lt;UnitID&gt;:&lt;addr&gt;:&lt;ns&gt;:&lt;evict_state&gt;</td></tr><tr><td class="confluenceTd">67 (SCHP REQ)</td><td class="confluenceTd">scratch_op_valid &amp; scratch_op_ready</td><td class="confluenceTd">&lt;pkt_type&gt;:&lt;Time&gt;:&lt;UnitID&gt;:&lt;addr&gt;:&lt;rd_req&gt;:&lt;wr_req&gt;:&lt;burst_len&gt;:&lt;burst_wrap&gt;</td></tr><tr><td colspan="1" class="confluenceTd">68 (SCH WRDAT)</td><td colspan="1" class="confluenceTd">wr_valid &amp;&amp; wr_ready</td><td colspan="1" class="confluenceTd">&lt;pkt_type&gt;:&lt;Time&gt;:&lt;UnitID&gt;:&lt;wr_data&gt;:&lt;wr_be&gt;:&lt;wr_beat_num&gt;:&lt;wr_last&gt;</td></tr><tr><td colspan="1" class="confluenceTd">69 (SCH RDDAT)</td><td colspan="1" class="confluenceTd">rdrsp_valid &amp;&amp; rdrsp_ready</td><td colspan="1" class="confluenceTd">&lt;pkt_type&gt;:&lt;Time&gt;:&lt;UnitID&gt;:&lt;rd_data&gt;:&lt;rd_be&gt;:&lt;rd_cancel&gt;:&lt;rd_last&gt;</td></tr></tbody></table></div><h3 id="TEMPO(DuplicatefromOski)-Lookuprequest(64):">Lookup request (64):</h3><p>Below signals are logged when both 'ctrl_op_valid_p0' and 'cache_op_ready_p0' are asserted. Following information is logged along with pkt_type, time, probed unit ID</p><ul><li>ctrl_op_address_p0</li><li>ctrl_op_security_p0</li></ul><h3 id="TEMPO(DuplicatefromOski)-Lookupresponse(65):">Lookup response (65):</h3><p>Below signals are logged if 'cache_valid_p2' is asserted. Following information is logged along with pkt_type, time, probed unit ID</p><ul><li>cache_current_state_p2</li><li>ctrl_op_state_p2</li></ul><p>All below signals are concatenated in following order and logged has &lt;misc_info&gt;.</p><ul><li><div class="error"><span class="error">Unknown macro: {ctrl_op_write_data_p2, ctrl_op_read_data_p2, ctrl_op_allocate_p2, nack_no_allocate_p2, nack_ce_p2, nack_uce_p2, nack_p2}</span> </div><p><strong>  MSB</strong><strong>LSB</strong><br/><br/></p><p>bit [6:0] misc_info;<br/>assign misc_info = {ctrl_op_write_data_p2, ctrl_op_read_data_p2, ctrl_op_allocate_p2, nack_no_allocate_p2, nack_ce_p2, nack_uce_p2, nack_p2};</p></li></ul><p>map2ntvif:</p><ul><li>This is the controller signal indicating if the lookup req/rsp was for Read or Write or Snoop. Since this information is not provided to CCP, we need to probe controller signals. This information varies for IO-AIU with CCP and DMI with CCP.</li><li>For IO-AIU with CCP, below are the signals probed.<ul><li>map2ntvif: 1 for Read</li><li>map2ntvif: 2 for Write</li><li>map2ntvif: 3 for Snoop</li></ul></li></ul><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="https://arterisip.atlassian.net/wiki/download/attachments/16777371/ioaiu_w_ccp.png?api=v2"></span></p><ul><li>For DMI with CCP, below signal is probed. This signal actually represents the SMI message.<ul><li>     assign u_ccp_if.msgType_p2           = tb_top.dut.dmi_unit.dmi_resource_control.dmi_cache_wrap.ccp_p2_cm_type;</li></ul></li></ul><p>Ccp_flit encapsulates these different behaviors and provides a single interface to external world.</p><ul><li>ntv_req_is_rd()        #Returns true for IO-AIU lookups due to AxArReq or for DMI lookups due to MRDreq. Returns false in all other senarios.</li><li>ntv_req_wr()            #Returns true for IO-AIU lookups due to AxAwReq or for DMI lookups due to DTWreq. Returns false in all other senarios.</li><li>ntv_req_snp()          #Returns true for IO-AIU lookups due to SMI Snoop requests. Returns false in all other senarios.</li></ul><h3 id="TEMPO(DuplicatefromOski)-Evict(66):">Evict (66):</h3><p>Below signals are logged if 'cache_evict_valid_p2'  is asserted. Following information is logged along with pkt_type, time, probed unit ID.</p><ul><li>cache_evict_address_p2</li><li>cache_evict_security_p2<br/><br/></li><li>Instead of adding logic to probe_module to handle various NACK scenarios, its easier for CPP checker to decide what needs to be done.  If 'nack_p0' or 'nack_uce_p2' is triggered,  CPP checker will drop the Lookup request and Lookup response. For 'nack_ce_p2' case, CPP checker will drop the current response and all prior Lookup requests in the queue. Also drops future incoming Lookup requests that match the timestamp of 'nack_uce_p2'. Since P0 are P2 two separate requests, on a given cycle, there is possible race scenario on what gets logged first to trace. For this reason, we match timestamps to determine if P0 request must be dropped.</li></ul><h3 id="TEMPO(DuplicatefromOski)-Scratchpadrequest(67)"><span class="inline-comment-marker" data-ref="500811a7-68fd-459e-8769-0b1d9aaf71a7">Scratchpad request (67)</span></h3><p>Below signals must  be logged if &quot;bitwise and&quot; operation on signals 'scratch_op_valid' and 'scratch_op_ready'. Since these signals are one-hot encoded, if the 'bitwise and' operation results in value other than 0 then that means valid information is forwarded. Scratchpad operations are only supported for DMI.</p><ul><li><p>&lt;addr&gt; means concatenation of below signals. System checker will pad required number of 0's to the right to transform it to AXI address.</p><div class="error"><span class="error">Unknown macro: {scratch_op_way_num, scratch_op_index_addr, scratch_op_beat_num}</span> </div></li><li>&lt;rd_req&gt; = scratch_op_read_data</li><li>&lt;wr_req&gt; = scratch_op_write_data</li><li>&lt;burst_len&gt; = scratch_op_burst_len</li><li>&lt;burst_wrap&gt; = scratch_op_burst_wrap</li></ul><h3 id="TEMPO(DuplicatefromOski)-Scratchpadwritedata(68)">Scratchpad write data(68)</h3><p>Below signal are logged if &quot;scratch_wr_valid &amp;&amp; scratch_wr_ready&quot; is true.</p><ul><li>&lt;wr_data&gt; = scratch_wr_data</li><li>&lt;wr_be&gt; = scratch_wr_byte_en</li><li>&lt;wr_beat_num&gt; = scratch_wr_beat_num</li><li>&lt;wr_last&gt; = scrach_wr_last<br/><br/></li></ul><h3 id="TEMPO(DuplicatefromOski)-Scratchpadreaddata(69)">Scratchpad read data(69)</h3><p>Below signals are logged if &quot;scratch_rdrsp_valid &amp;&amp; scratch_rdrsp_ready&quot; is true.</p><ul><li>&lt;rd_data&gt; = scratch_rdrsp_data</li><li>&lt;rd_be&gt; = scratch_rdrsp_byteen</li><li>&lt;rd_cancel&gt; = scratch_rdrsp_cancel</li><li>&lt;rd_last&gt; = scrach_rdrsp_last</li></ul><h2 id="TEMPO(DuplicatefromOski)-DCEDirectoryTraceFormat">DCE Directory Trace Format</h2><div class="table-wrap"><table class="wrapped confluenceTable"><tbody><tr><th class="confluenceTh">pkt_type</th><th class="confluenceTh">Trace format</th></tr><tr><td class="confluenceTd">32 (LKUP REQ)</td><td class="confluenceTd">&lt;pkt_type&gt;:&lt;Time&gt;:&lt;UnitID&gt;:&lt;addr&gt;:&lt;ns&gt;:&lt;type&gt;:&lt;iid&gt;:&lt;attid&gt;:&lt;sid&gt;</td></tr><tr><td class="confluenceTd">33 (UPD REQ)</td><td class="confluenceTd">&lt;pkt_type&gt;:&lt;Time&gt;:&lt;UnitID&gt;:&lt;addr&gt;:&lt;ns&gt;:&lt;iid&gt;</td></tr><tr><td colspan="1" class="confluenceTd">34 (CMT REQ)</td><td colspan="1" class="confluenceTd">&lt;pkt_type&gt;:&lt;Time&gt;:&lt;UnitID&gt;:&lt;addr&gt;:&lt;ns&gt;:&lt;owner_vld&gt;:&lt;owner_num&gt;:&lt;sharer_vec&gt;</td></tr><tr><td colspan="1" class="confluenceTd">35 (LKUP RSP)</td><td colspan="1" class="confluenceTd">&lt;pkt_type&gt;:&lt;Time&gt;:&lt;UnitID&gt;:&lt;attid&gt;:&lt;owner_vld&gt;:&lt;owner_num&gt;:&lt;sharer_vec&gt;</td></tr><tr><td class="confluenceTd">36 (RECALL)</td><td class="confluenceTd">&lt;pkt_type&gt;:&lt;Time&gt;:&lt;UnitID&gt;:&lt;addr&gt;:&lt;ns&gt;:&lt;owner_vld&gt;:&lt;owner_num&gt;:&lt;sharer_vec&gt;</td></tr><tr><td colspan="1" class="confluenceTd">37 (RETRY)</td><td colspan="1" class="confluenceTd">&lt;pkt_type&gt;:&lt;Time&gt;:UnitID&gt;:&lt;attid&gt;</td></tr></tbody></table></div><p><br/></p><p>CMD REQ: coherent requests command input interface to directory.</p><ul><li>&lt;type&gt;: Logs the value of signal 'dm_cmd_req_type_i'. This signal indicates concerto message type</li><li>&lt;iid&gt;: Logs the value of signal 'dm_cmd_req_iid_i. This signals indicates initiator-id (Funit-ID).</li><li>&lt;sid&gt;: Logs the value of signal 'dm_cmd_req_sid_i'. This signal indicates Stash-id (Funit-ID).</li><li>&lt;attid&gt;: Signal 'dm_cmd_req_attid_vec_i'  is one-hot encoding of ATTID. When logging this value, logic must convert it to actual value instead of printing one-hot encoded value. This simplifies CPP checker interpretation.  For example if the value of this signal is 0x0001 then '0' is logged into the trace.</li></ul><p>WRITE:  final commit interface to directory.</p><ul><li>&lt;owner_vld&gt;: Logs the value of signal 'dm_write_owner_val_i'. This signal indicates of owner cacheing ID value is valid or not.</li><li>&lt;owner_num&gt;: Logs the value of signal 'dm_write_owner_num_i'. Caching ID of the owner.</li><li>&lt;sharer_vec&gt;: Logs the value of 'dm_write_sharer_vec_i'.'<br/><br/></li></ul><p>RETRY: Directory indicates ATT that current request is cancelled and retry at appropriate time. From Checker prespective, we cancel the associated LKUPREQ in Scheduler. It is expexted that we will observe corresponding lkupreq in future or remains has a pending transaction if test prematurly fails.</p><p>For each interface most of the signals are common. just the naming convection changes. All values must be logged in Hexa-decimal format.</p><h1 id="TEMPO(DuplicatefromOski)-References">References</h1><p>For additional references on implementation:<br/>Specifications:</p><ul><li>CHI specification</li><li>AXI specification</li><li>SMI Specification<ul><li><a class="external-link" href="https://svn.arteris.com/engdocs/trunk/Sonata%20Project/Concerto%20Rev%20C%20-%20Working/CSymLayers.xlsx?view=log" rel="nofollow">https://svn.arteris.com/engdocs/trunk/Sonata%20Project/Concerto%20Rev%20C%20-%20Working/CSymLayers.xlsx?view=log</a></li></ul></li><li>CCP Specification<ul><li><a class="external-link" href="https://confluence.arteris.com/display/ENGR/Ncore+3.0+CCP+Micro-Architecture+Specification" rel="nofollow">https://confluence.arteris.com/display/ENGR/Ncore+3.0+CCP+Micro-Architecture+Specification</a></li></ul></li></ul><p>Example design files</p><ul><li>$WORK_TOP/concerto/dv/sub_sys/env/concerto_ref_wrapper.svh</li><li>$WORK_TOP/concerto/dv/sub_sys/env/concerto_ref_helper.svh</li></ul><h1 id="TEMPO(DuplicatefromOski)-SCRATCHNOTES">SCRATCH NOTES</h1>