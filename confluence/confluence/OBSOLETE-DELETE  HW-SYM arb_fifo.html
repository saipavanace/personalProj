<div class="wiki-content"><style>[data-colorid=yqarcy3qsg]{color:#707070} html[data-color-mode=dark] [data-colorid=yqarcy3qsg]{color:#8f8f8f}</style><h1 id="OBSOLETE-DELETEHW-SYMarb_fifo-module_name"><strong>module_name</strong></h1><div class="page view"><div class="wiki-content"><p>arb_fifo</p><h1 id="OBSOLETE-DELETEHW-SYMarb_fifo-parameters"><strong>parameters</strong></h1><h2 id="OBSOLETE-DELETEHW-SYMarb_fifo-java_script:"><strong>java_script:</strong></h2><pre>{
	&quot;width&quot; : any positive integer<br />        &quot;numPri&quot; : any positive integer 1 or greater.</pre><pre><span>}</span></pre><h2 id="OBSOLETE-DELETEHW-SYMarb_fifo-verilog:"><strong>verilog:</strong></h2><p style="margin-left: 30.0px;">none.</p><h1 id="OBSOLETE-DELETEHW-SYMarb_fifo-I/O"><strong>I/O</strong></h1><pre>u.port('input', 'in_req', width); // a set of port requests<br />for (i = 0; i &lt; numPri; i++) {<br />  u.port('input', 'in_req_'+i, width); // a set of port requests per priority level; it can change every clock cycle, but the ORing of the array of &quot;in_req_&lt;i&gt;&quot; must equal &quot;in_req&quot;.<br />}<br />u.port('input', 'next', 1; // Move to next state. At the next level <br />u.port('output', 'out_gnt', width); // output grant; onehot0 bit vector<br />u.port('input', 'in_state', log2ceil(width)+(width*width)); // input state which represents the current state of the collapsible FIFO storage.<br />u.port('output', 'out_state', log2ceil(width)+(width*width)); // output state which represents the next state of the collapsible FIFO storage.</pre><p><strong>Functions Used</strong></p><p>N/A</p><h1 id="OBSOLETE-DELETEHW-SYMarb_fifo-ModulesUsed"><strong>Modules Used</strong></h1><p>logic_tree</p><p>arb_spri&nbsp; (simple priority encoder)</p><h1 id="OBSOLETE-DELETEHW-SYMarb_fifo-Description"><strong>Description</strong></h1><p>Priority FIFO Arbiter. The earliest request at the highest priority level wins.</p><p>The highest priority is 0, followed by 1 and so on.</p><p>Conceptually, a port request will come in with a priority. The input of this block assumes a set of port requests, as well as a set of port requests per priority level.</p><p><s>last is onehot0; when onehot it indicates to move to next state in the round robin arbiter. last has a constraint on it that it can never assert if there are no gnts (or therefor no requests.) </s><span class="legacy-color-text-red2">You only need a single wide next signal to do this.</span></p><p>out_gnt indicates the winner of the arbitration and is onehot0.</p><p>in_state and out_state are used to maintain state in an external register. The organization of the in_state and out_state is:<br />{fifo_wr_ptr[log2ceil(width)-1:0],fifo_entries[width-1:0][width-1:0]}<br />where<br />fifo_entries where 0 is the top and width-1 is the bottom.</p><p>Each entry in the FIFO represents a port request encoded as onehot bit vector.<br />Each entry in the FIFO contains width bits, and must be onehot0, where the one hot bit represents a port request first asserted at a fixed point in time.<br />FIFO storage bits are organized as nEntries=numPorts, wEntries=numPorts as a 2-D matrix; see below for numPorts=3.</p><pre>    \ &lt;------Time<br />Port \ 2 1 0<br />------+----------<br />    0 | <br />    1 |<br />    2 |</pre><p>NOTE: each row in the 2-D matrix above is onehot0.<br />NOTE: each column in the 2-D matrix above is onehot0. When onehot, it indicates the port corresponding to the one hot bit is active. When zero, the column is invalid.<br />NOTE: fifo entry0 (i.e. column0 is the earliest entry).</p><p>The set of port requests carried in &quot;in_req&quot; are stored in the FIFO, spray across multiple entries, one port request per entry.<br />For example, for in_req[2:0]=3'b111, when FIFO write pointer is at entry 0, then port 0 request is active and is written to FIFO entry 0 as 3'b001, port 1 request active written to FIFO entry 1 as 3'b010, port 2 request active written to FIFO entry 2 as 3'b100.</p><p>When a FIFO entry is popped, the FIFO collapses, i.e. the entries below the popped entry moves one level up. The entry that is chosen to be popped is the one that has the highest priority and is the earliest.</p><p>A simple priority encoder is used to select from the array of &quot;in_req_&lt;priority&gt;&quot;.<br />Say in_req_0 = 3'b011 is selected, and it indicates that port 0 and port 1 are requesting at priority level 0 (the highest priority).<br />Say FIFO entry 0 carries 3'b001 (port 0 request), FIFO entry 1 carries 3'b010 (port 1 request), FIFO entry 2 carries 3'b000 (invalid).<br />Since FIFO entry 0 is earlier than FIFO entry 1, FIFO entry 0 i.e. port 0 request wins.</p><p>If one or more FIFO entries are valid, All the FIFO entries are bit ORed and used to mask off requests that first asserted in previous cycles. If there are any requests left over after this mask, they are pushed onto the first non-valid entry in the FIFO.</p><p>When the FIFO is empty, the set of port requests for each priority level &quot;in_req_&lt;prio&gt;&quot; flows to &quot;out_gnt&quot; via two simple priority encoders and a output MUX.</p><p>The multiport FIFO will be pushed with the winning request and non-winning requests if last is not asserted for the winning request.</p><p>The multiport FIFO will be pushed with the non-winning requests if last is asserted for the winning request.</p><pre>width=3=numPorts, numPri=3.<br />===========================</pre><pre>                                          +---+ <br /> in_req_0[2:0]---------------------------&gt;| M | in_req_prio[2:0] <br /> in_req_1[2:0]---------------------------&gt;| U |-------------------&gt;<br /> in_req_2[2:0]---------------------------&gt;| X | <br />                                          +-+-+ <br />                           +------+         | <br />OR_REDUCE(in_req_0[2:0])--&gt;|      |         | <br />OR_REDUCE(in_req_1[2:0])--&gt;| arb  |---------+ <br />OR_REDUCE(in_req_2[2:0])--&gt;| spri | in_req_prio_sel[2:0]<br />                           |      |<br />                           +------+</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+------+<br />                           |  C   |                      +---+<br />       in_req_prio[2:0]---&gt;|  O   |                      |   | <br />                           |  M   |    entry_winner[2:0] |   |<br />            entry0[2:0]---&gt;|  P   |---------------------&gt;|0  |<br />            entry1[2:0]---&gt;|  A   |                      |   |<br />            entry2[2:0]---&gt;|  R   |                      | M | out_gnt[2:0]<br />                           |  E   |                      | U |--------------&gt;<br />                           +------+                      | X |<br />                           +------+                      |   |<br />                           |      |   in_req_winner[2:0] |   |<br />       in_req_prio[2:0]---&gt;| arb  |---------------------&gt;|1  |<br />                           | spri |                      |   |<br />                           |      |                      |   |<br />                           +------+                      +---+<br />                                                           |<br />                                                       fifo_empty</pre><pre><br />winning_request[2:0] = out_gnt[2:0];&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last[2:0]={3{next}};</pre><pre>winning_and_non_winning_requests[2:0] = in_req_prio[2:0];    non_winning_requests[2:0] = in_req_prio[2:0] AND NOT winning_request[2:0];</pre><pre>last_asserted_for_winning_request[2:0] = winning_request[2:0] AND last[2:0];</pre><pre>last_not_asserted_for_winning_request[2:0] = winning_request[2:0] AND NOT last[2:0];</pre><pre><br /></pre><pre>                      Multiport Collapsible FIFO (nEntries=numPorts, wEntries=numPorts)<br />              +---+   +-------------+<br />              |   |   |             |<br /> win_req[0]--&gt;| M |--&gt;|push0    pop0|&lt;-- out_gnt[0] &amp; last[0]<br /> win_req[1]--&gt;| a |--&gt;|push1    pop1|&lt;-- out_gnt[1] &amp; last[1]<br /> win_req[2]--&gt;| s |--&gt;|push2    pop2|&lt;-- out_gnt[2] &amp; last[2]<br />              | k |   |             |<br />              |   |   |  entry0[2:0]|--&gt; pop0_valid=OR_REDUCE(entry0)<br />              |   |   |  entry1[2:0]|--&gt; pop1_valid=OR_REDUCE(entry1)<br />              |   |   |  entry2[2:0]|--&gt; pop2_valid=OR_REDUCE(entry2)<br />              +-+-+   +-------------+<br />                |<br />                &lt;--------entry0[2:0] OR entry1[2:0] OR entry2[2:0]</pre><pre><br />win_req[0]=(last_asserted_for_winning_request AND non_winning_requests[0]) OR <br />           (last_not_asserted_for_winning_request AND winning_and_non_winning_requests[0]);</pre><pre>win_req[1]=(last_asserted_for_winning_request AND non_winning_requests[1]) OR <br />           (last_not_asserted_for_winning_request AND winning_and_non_winning_requests[1]);</pre><pre>win_req[2]=(last_asserted_for_winning_request AND non_winning_requests[2]) OR <br />           (last_not_asserted_for_winning_request AND winning_and_non_winning_requests[2]));</pre><p><br /></p></div></div></div><div><div><a class="external-link" href="https://confluence.arteris.com/" rel="nofollow"><span data-colorid="yqarcy3qsg" class="aui-icon aui-icon-small aui-iconfont-like">&nbsp;</span></a></div></div>