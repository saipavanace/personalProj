<h1 id="HW-CTFsym_ibuf_switch-module_name"><strong>module_name</strong></h1><p>sym_ibuf_switch</p><h1 id="HW-CTFsym_ibuf_switch-parameters"><strong>parameters</strong></h1><pre>{</pre><pre> interfaces:{</pre><pre>   clkInterface: {name: &quot;a_string&quot;, params: {}, direction: &quot;master&quot; or &quot;slave&quot;, interface: &quot;a_string&quot;},</pre><pre>   cfgInterface: {name: &quot;a_string&quot;, params: {}, direction: &quot;master&quot; or &quot;slave&quot;, interface: &quot;a_string&quot;}, // Optional based on weightsProg</pre><pre>   protectionInterface: {name: &quot;a_string&quot;, params: {}, direction: &quot;master&quot; or &quot;slave&quot;, interface: &quot;a_string&quot;}, // Optional based on protectionStyle</pre><pre>   inInterfaces: [</pre><pre>     {name: &quot;a_string&quot;,</pre><pre>      params: {nVc: positive integer, wBus: positive integer, wProt: non negative integer},</pre><pre>      direction: &quot;slave&quot;, </pre><pre>      interface: &quot;InterfaceATP&quot;, </pre><pre>      pktDef: {params: {ATP Packet Params}, packet: &quot;a_string&quot;}},</pre><pre>     {},{}], //array depth sets numIngress, width of &quot;valid&quot; in interface sets numVc</pre><pre>   outInterfaces: [</pre><pre>     {name: &quot;a_string&quot;,</pre><pre>      params: {nVc: positive integer, wBus: positive integer, wProt: non negative integer},</pre><pre>      direction: &quot;master&quot;,</pre><pre>      interface: &quot;InterfaceATP&quot;,</pre><pre>      pktDef: {params: {ATP Packet Params}, packet: &quot;a_string&quot;}},</pre><pre>     {},{}] //array depth sets numEgress</pre><pre> }, </pre><pre> bufLayer: [{inPort: 0 or greater, // index in interfaces.inInterfaces </pre><pre>             outPort, 0 or greater, // index in interfaces.outInterfaces</pre><pre>             depth: 0 or greater, </pre><pre>             pipeForward: boolean,</pre><pre>             pipeBackward: boolean, </pre><pre>             simplePipe: boolean, </pre><pre>             circular: boolean}, // see sym_pipe_adapter for parameter descriptions<br/>            {},<br/>            .<br/>            .], // depth of array is at most interfaces.inInterfaces.length (number of inputs) * interfaces.outInterfaces.length (number of outputs)</pre><pre> assertOn: boolean // Simulation only, used to turn on asserts.</pre><pre> mstrArbLck: boolean // true master arb locks, false master arb doesn't lock. Default false.</pre><pre> vcLckStyleVld: boolean // Lock Style of VC arbiters. true locks on valid, false locks on ready. Default false.</pre><pre> mstrLckStyleVld: boolean // Lock Style of master arbiter. true locks on valid, false locks on ready. Default false.</pre><pre> weightsProg: Boolean, </pre><pre> numPri: positive integer, </pre><pre> routeFields: [{rf:[&quot;a_string&quot;,&quot;&quot;,&quot;&quot;]}, // array depth variable</pre><pre>   {rf:[]},{rf:[]}], // array depth = numIngress </pre><pre> routeShift: [non negative integer, , ,] array depth = numIngress </pre><pre> routeMap: [rm:{[{bitPat: &quot;a_string&quot;, egressPort: non negative integer},{},{}]}, // array depth min = 1, array depth max = numEgress</pre><pre>   {rm:[]},{rm:[]}], // array depth = numIngress </pre><pre> arbType: [{</pre><pre>   master: &quot;a_string&quot;, </pre><pre>   vcs: [&quot;a_string&quot;,&quot;a_string&quot;] // array depth = vcMap depth for given egress port.</pre><pre>   },{},{}], // array depth = numEgress </pre><pre> masterArbReadyAware: [boolean,,], // array depth = numEgress </pre><pre> vcMap: [{vm:[non negative integer,,]}, // array depth min = 1, array depth max = numVc</pre><pre>   {vm:[]},{vm:[]}], // array depth = numEgress </pre><pre> portMap: [</pre><pre>     {ports: [non negative integer,,], // array depth min = 1, array depth max = numIngress</pre><pre>      vcs: [{vc:[non negative integer,,]}, // array depth min = 1, array depth max = ports.length</pre><pre>        {vc:[]},{vc:[]}] // array depth = vcMap depth for given egress port</pre><pre>     },</pre><pre>   {},{}], // array depth = numEgress </pre><pre> weights: [{master: [positive integer,,], // array depth = vcMap depth for given egress port</pre><pre>            vcs: [{vc:[positive integer,,]}, // array depth = portMap depth for given egress port per given VC</pre><pre>                  {vc:[]},{vc:[]}] // array depth = vcMap depth for given egress port},</pre><pre>           {},{}], // array depth = numEgress </pre><pre> protectionStyle: &quot;&quot; or {<a class="external-link" href="https://confluence.arteris.com/display/ENGR/protectionStyle" rel="nofollow">protectionStyle</a>} // applies to internal registers, not to interface.</pre><pre>}</pre><h1 class="page view" id="HW-CTFsym_ibuf_switch-ParameterDescription:">Parameter Description:</h1><p>The parameters are identical to sym_switch with the addition of the bufLayer parameter. The sym_ibuf_switch doesn't support more than one virtual channel. Because of this, there are no restrictions on pipeForward and pipeBackward, other than what is imposes by the topology they are used in and there are parameters that are never used:</p><p style="margin-left: 30.0px;">mstrArbLck<br/>mstrLckStyleVld<br/>masterArbReadyAware</p><p>These are left in for future compatibility should the block be expanded in the future to support more than one virtual channel and to make it easily swapped with the sym_switch.</p><h2 id="HW-CTFsym_ibuf_switch-bufLayer">bufLayer</h2><p>bufLayer is used to set the depth of the buffering between input/output pairs. Because of the pruning that can happen with portMap, not all combinations need to be specified, just the ones that are used.</p><p>The code actually tests the parameter to see if it is an array. If it's an array, it uses inPort and outPort to determine the depth of the buffer to put between the input and output. If the parameter is not array, it uses that object to configure all the buffers it places between ports. The object has the same structure as an individual entry definition, minus inPort and outPort. This was the original definition and is included to provide backward compatibility with old designs. </p><h1 id="HW-CTFsym_ibuf_switch-I/O:"><strong>I/O:</strong><span style="font-size: 14.0px;"> </span></h1><pre>var clkInterfaceFunc = new obj.userLib[interfaces.clkInterface.interface];</pre><pre>var clkInterface = clkInterfaceFunc.getSignalsBundle(interfaces.clkInterface.params);</pre><pre>u.interface(interfaces.clkInterface.name, 'slave', clkInterface);</pre><pre>if (weightsProg === &quot;yes&quot;) {</pre><pre>  var cfgInterfaceFunc = new obj.userLib[interfaces.cfgInterface.interface];</pre><pre>  var cfgInterface = cfgInterfaceFunc.getSignalsBundle(interfaces.cfgInterface.params);</pre><pre>  u.interface(interfaces.cfgInterface.name, 'slave', cfgInterface);</pre><pre>} </pre><pre>var inInterfaces = []; </pre><pre>var inInterfaceFuncs = [];</pre><pre>for (i = 0; i &lt; interfaces.inInterfaces.length; i++) { </pre><pre>  inInterfaceFuncs[i] = new obj.userLib[interfaces.inInterfaces[i].interface]; </pre><pre>  inInterfaces[i] = inInterfaceFuncs[i].getSignalsBundle(interfaces.inInterfaces[i].params);</pre><pre>  u.interface(interfaces.inInterfaces[i].name, 'slave', inInterfaces[i]);</pre><pre>}</pre><pre>var outInterfaceFuncs = []; </pre><pre>var outInterfaces = [];</pre><pre>for (i = 0; i &lt; interface.outInterfaces.length; i++) {<span style="font-family: Arial , sans-serif;"> </span></pre><pre>  outInterfaceFuncs[i] = new obj.userLib[interfaces.outInterfaces[i].interface]; <span style="font-family: Arial , sans-serif;"> </span></pre><pre>  outInterfaces[i] = outInterfaceFuncs[i].getSignalsBundle(interfaces.outInterfaces[i].params);<span style="font-family: Arial , sans-serif;"> </span></pre><pre>  u.interface(interfaces.outInterfaces[I].name, 'master', outInterfaces[i]);</pre><pre>}</pre><pre>if (protectionStyle !== &quot;&quot;) {</pre><pre>  var protectionInterfaceFunc = new obj.userLib[interfaces.protectionInterface.interface];</pre><pre>  var protectionInterface = protectionInterfaceFunc.getSignalsBundle(interfaces.protectionInterface.params);</pre><pre> u.interface(protectionInterface.name, 'slave', protectionInterface);</pre><pre>}</pre><pre>or</pre><pre>u.nInterfaces(interfaces);</pre><pre><strong style="font-size: 24.0px;font-family: Arial , sans-serif;">Functions Used</strong></pre><p>N/A</p><h1 id="HW-CTFsym_ibuf_switch-ModulesUsed"><strong>Modules Used</strong></h1><p>sym_switch<br/>sym_pipe_adapter</p><h1 id="HW-CTFsym_ibuf_switch-Description"><strong>Description</strong></h1><p>The top block diagram is shown below assuming a 3x3 switch that is fully mapped.</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16156488/InternallyBufferedSwitch.svg?api=v2"></span></p><p>A NxM sym_ibuf_switch is functionally equivalent to the NxM sym_switch with the addition of a pipe stage added between every input to output combination. When mapping removes a ingress to egress flow, then the buffers along those pruned flows are removed and ports on the associated ingress switch and egress switch are also removed. The bufLayer parameter is used to configure all the pipes.</p>