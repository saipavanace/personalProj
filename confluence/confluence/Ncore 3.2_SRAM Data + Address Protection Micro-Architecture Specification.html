<h1 id="Ncore3.2_SRAMData+AddressProtectionMicro-ArchitectureSpecification-RevisionNotes">Revision Notes</h1><div class="table-wrap"><div class="table-wrap"><table class="wrapped tablesorter tablesorter-default confluenceTable"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr class="tablesorter-headerRow"><th scope="col" style="text-align: left;" class="tablesorter-header sortableHeader tablesorter-headerUnSorted confluenceTh"><div class="tablesorter-header-inner">Revision</div></th><th scope="col" style="text-align: left;" class="tablesorter-header sortableHeader tablesorter-headerUnSorted confluenceTh"><div class="tablesorter-header-inner">Notes</div></th><th scope="col" style="text-align: left;" class="tablesorter-header sortableHeader tablesorter-headerUnSorted confluenceTh"><div class="tablesorter-header-inner">Reviser</div></th><th class="tablesorter-header sortableHeader tablesorter-headerUnSorted confluenceTh" colspan="1">Date</th></tr><tr><td style="text-align: left;" class="confluenceTd">v0.3</td><td style="text-align: left;" class="confluenceTd">Initial Structure and Top-Level Diagram</td><td style="text-align: left;" class="confluenceTd"><p>Boon Chuan</p></td><td colspan="1" class="confluenceTd">23-Aug-2021</td></tr><tr><td style="text-align: left;" class="confluenceTd">v0.7</td><td style="text-align: left;" class="confluenceTd">Added and Updated Information</td><td style="text-align: left;" class="confluenceTd"><p>Akarsh Hebbar</p></td><td colspan="1" class="confluenceTd"><p>23-Mar-2022</p></td></tr><tr><td style="text-align: left;" class="confluenceTd">v0.9</td><td style="text-align: left;" class="confluenceTd">Final version post reviews</td><td style="text-align: left;" class="confluenceTd">Boon Chuan</td><td colspan="1" class="confluenceTd">31-May-2023</td></tr><tr><td colspan="1" class="confluenceTd">v0.91</td><td colspan="1" class="confluenceTd">Added clarification for ECC scheme: address error detection is using the syndrome from the ECC Decoder; not using corrected address.</td><td colspan="1" class="confluenceTd">Boon Chuan</td><td colspan="1" class="confluenceTd">7-June-2023</td></tr></tbody></table></div></div><h1 class="auto-cursor-target" id="Ncore3.2_SRAMData+AddressProtectionMicro-ArchitectureSpecification-TableofContents">Table of Contents</h1><p><style type='text/css'>/*<![CDATA[*/
div.rbtoc1759723896496 {padding: 0px;}
div.rbtoc1759723896496 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1759723896496 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class='toc-macro rbtoc1759723896496'>
<ul class='toc-indentation'>
<li><a href='#Ncore3.2_SRAMData+AddressProtectionMicro-ArchitectureSpecification-RevisionNotes'>Revision Notes</a></li>
<li><a href='#Ncore3.2_SRAMData+AddressProtectionMicro-ArchitectureSpecification-TableofContents'>Table of Contents</a></li>
<li><a href='#Ncore3.2_SRAMData+AddressProtectionMicro-ArchitectureSpecification-SRAMprotectionrequirements'>SRAM protection requirements</a></li>
<li><a href='#Ncore3.2_SRAMData+AddressProtectionMicro-ArchitectureSpecification-SRAMECCprotectionimplementation'>SRAM ECC protection implementation</a></li>
<li><a href='#Ncore3.2_SRAMData+AddressProtectionMicro-ArchitectureSpecification-SRAMParityprotectionimplementation'>SRAM Parity protection implementation</a></li>
<li><a href='#Ncore3.2_SRAMData+AddressProtectionMicro-ArchitectureSpecification-Referencedocument'>Reference document</a></li>
<li><a href='#Ncore3.2_SRAMData+AddressProtectionMicro-ArchitectureSpecification-Detailedimplementationdescription'>Detailed implementation description</a></li>
</ul>
</div></p><h1 id="Ncore3.2_SRAMData+AddressProtectionMicro-ArchitectureSpecification-SRAMprotectionrequirements">SRAM protection requirements</h1><p>Blocks that would need to support SRAM data + address protection on Ncore 3.2 are:</p><ul><li>IOAIU</li><li>DCE</li><li>DMI</li><li>DVE</li></ul><p>Two protection schemes are supported: ECC, and Parity.</p><p><br/></p><h1 id="Ncore3.2_SRAMData+AddressProtectionMicro-ArchitectureSpecification-SRAMECCprotectionimplementation">SRAM ECC protection implementation</h1><p>For Write using ECC protection scheme:</p><p>  The address is not written into the SRAM.</p><p>  The ECC is calculated over a concatenation of address bits and data bits, with address bits being placed as the upper bits.</p><p>  The ECC and the data is written to the SRAM.</p><p>For Read using ECC protection scheme:</p><p>   A concatenation of the expected address bits and the data bits from SRAM, together with the ECC bits from SRAM, is fed into the ECC logic for error detection and correction.</p><p>   If the ECC syndrome points to any of the address bits, then an uncorrectable error is detected.</p><p>   A single-bit error in the address bits is considered an uncorrectable error. </p><p>   An error, when detected, is either uncorrectable error or correctable error. It cannot be both.</p><p><br/></p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16164230/image2023-6-7_19-3-24.png?api=v2"></span></p><p><br/></p><h1 id="Ncore3.2_SRAMData+AddressProtectionMicro-ArchitectureSpecification-SRAMParityprotectionimplementation">SRAM Parity protection implementation</h1><p>For Write using Parity protection scheme:</p><p>  The address is not written into the SRAM.</p><p>  The Parity bit (odd parity) is calculated over a concatenation of address bits and data bits, with address bits being placed as the upper bits.</p><p>  The Parity bit and the data is written to the SRAM.</p><p>For Read using Parity protection scheme:</p><p>   A concatenation of the expected address bits and the data bits from SRAM, together with the Parity bit from SRAM, is fed into the Parity logic for error detection.</p><p>   An uncorrectable error is detected when the calculated Parity bit does not match the Parity bit from SRAM.</p><p><br/></p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16164230/image2023-5-31_14-30-33.png?api=v2"></span></p><p><br/></p><h1 id="Ncore3.2_SRAMData+AddressProtectionMicro-ArchitectureSpecification-Referencedocument">Reference document</h1><p>See also:</p><p><a class="external-link" href="https://confluence.arteris.com/display/ENGR/ecc_addr_err" rel="nofollow">ecc_addr_err - Engineering - Confluence (arteris.com)</a></p><p>for another implementation for detecting a fault in SRAM address in a Read operation.</p><p><br/></p><h1 id="Ncore3.2_SRAMData+AddressProtectionMicro-ArchitectureSpecification-Detailedimplementationdescription">Detailed implementation description</h1><p>Currently Ncore3 DMI and IOAIU are calling the functions ccpTagMemoryParams and ccpDataMemoryParams to create the data structure required by the generic memory wrapper em_mem_external.tachl module for the CCP.</p><p>Similarly, DMI and IOAIU are calling the function dataBufferMemoryParams for DMI wrDataBuffer and IOAIU ottDataBuffer.</p><p>Also, Ncore3 DVE is calling the function dataBufferMemoryParams for the trace accumulator buffer.</p><p>These functions have a default parameter container called moreParams that carries the default parameter sramAddressProtection. By default, sramAddressProtection is 0, meaning the feature is turned off by default.</p><p><br/></p><p>hw-lib/js/lib_utils.js</p><p><strong><code><span class="kd">function</span> <span class="nx">ccpTagMemoryParams</span><span class="p">(</span><span class="nx">dmi</span><span class="p"><span class="idiff left">,</span></span><span class="idiff"> </span><span class="nx"><span class="idiff">moreParams</span></span><span class="idiff"> </span><span class="o"><span class="idiff">=</span></span><span class="idiff"> </span><span class="p"><span class="idiff">{</span></span><span class="dl"><span class="idiff">&quot;</span></span><span class="s2"><span class="idiff">sramAddressProtection</span></span><span class="dl"><span class="idiff">&quot;</span></span><span class="idiff"> </span><span class="p"><span class="idiff">:</span></span><span class="idiff"> </span><span class="mi"><span class="idiff">0</span></span><span class="p"><span class="idiff right">}</span>)</span> </code></strong></p><p><strong><code><span class="kd">function</span> <span class="nx">ccpDataMemoryParams</span><span class="p">(</span><span class="nx">dmi</span><span class="p"><span class="idiff left">,</span></span><span class="idiff"> </span><span class="nx"><span class="idiff">moreParams</span></span><span class="idiff"> </span><span class="o"><span class="idiff">=</span></span><span class="idiff"> </span><span class="p"><span class="idiff">{</span></span><span class="dl"><span class="idiff">&quot;</span></span><span class="s2"><span class="idiff">sramAddressProtection</span></span><span class="dl"><span class="idiff">&quot;</span></span><span class="idiff"> </span><span class="p"><span class="idiff">:</span></span><span class="idiff"> </span><span class="mi"><span class="idiff">0</span></span><span class="p"><span class="idiff right">}</span>)</span> </code></strong></p><p><strong><code><span class="kd">function</span> <span class="nx">dataBufferMemoryParams</span><span class="p">(</span><span class="nx">width</span><span class="p">,</span> <span class="nx">nSets</span><span class="p">,</span> <span class="nx">nBeats</span><span class="p">,</span> <span class="nx">nBanks</span><span class="p">,</span> <span class="nx">errorInfo</span><span class="p">,</span> <span class="nx">moreParams</span> <span class="o">=</span> <span class="p">{</span><span class="dl">&quot;</span><span class="s2">sramAddressProtection</span><span class="dl">&quot;</span> <span class="p">:</span> <span class="mi">0</span><span class="p">})</span> </code></strong></p><p>For ccpTagMemoryParams function, the function argument dmi is an object carrying the following fields:</p><p>dmi.ccpParams.TagErrInfo;<br/>dmi.ccpParams.PriSubDiagAddrBits.length;<br/>dmi.ccpParams.wSecurity;<br/>dmi.ccpParams.wAddr;<br/>dmi.ccpParams.nWays;<br/>dmi.ccpParams.nSets;<br/>dmi.ccpParams.nTagBanks;<br/>dmi.ccpParams.PriSubDiagAddrBits.length;<br/>dmi.ccpParams.RepPolicy;<br/>dmi.ccpParams.nRPPorts;<br/>dmi.ccpParams.wStateBits;</p><p>For ccpDataMemoryParams function, the function argument dmi is an object carrying the following fields:</p><p>dmi.ccpParams.wData;<br/>dmi.ccpParams.DataErrInfo;;<br/>dmi.ccpParams.nSets;<br/>dmi.ccpParams.nWays;<br/>dmi.ccpParams.nDataBanks;</p><p>For dataBufferMemoryParams function:</p><p> (nBeats * nSets) / nBanks is the depth of the memory i.e. the number of rows in the memory</p><p>  width is the data width</p><p>    var dataWidth = width;</p><p>    var blockWidths = [sramAddressProtectionWidth + dataWidth];<br/>    var memWidth = dataWidth + getErrorEncodingWidth(errorInfo, sramAddressProtectionWidth + dataWidth, blockWidths);</p><p>  </p><p><br/></p><p>For ccpTagMemoryParams, ccpDataMemoryParams, dataBufferMemoryParams functions, the following object is returned, with the following fields:</p><p>legacy fields:</p><p>  width =&gt; the width of the SRAM, which is the sum of the data payload width plus ECC width.<br/>  depth =&gt; the depth of the SRAM, i.e. the number of row entries in the SRAM.<br/>  widthWithoutEcc =&gt; the data payload width</p><p>  blockWidths =&gt; an array of block widths, each block has its own ECC. </p><p>  eccOnlyBlocks, eccBlocks =&gt; are computed by taking an array of block widths and returning an array of arrays that contain the data bits for each ECC logical block as it would appear in memory. </p><p>newly added fields:</p><p>  depthWidth =&gt; number of bits to represent the depth of the SRAM<br/>  sramAddressProtectionWidth =&gt;the address width for SRAM protection</p><p><br/></p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">dmi.tachl
=========
    var ccpParams       = obj.lib.getParam(&#39;ccpParams&#39;);
    ccpParams[&#39;TagMemAddressProtection&#39;] = 1;
    ccpParams[&#39;DataMemAddressProtection&#39;] = 1;
//NOTE: DMI passes ccpParams as the only parameter object to CCP, and CCP treats TagMemAddressProtection and DataMemAddressPrection as default parameters.
//            instanceName: &#39;dmi_ccp&#39;,
//            moduleName: &#39;ccp_top&#39;,
//            params: ccpParams,
    var ccpTagGen       = obj.lib.getParam(&#39;MemoryGeneration&#39;, &#39;tagMem&#39;);
    var ccpDataGen      = obj.lib.getParam(&#39;MemoryGeneration&#39;, &#39;dataMem&#39;);
    var tagP            = memFunctions.ccpTagMemoryParams(obj.lib.getParam(), { sramAddressProtection : ccpParams.TagMemAddressProtection });
    var dataP           = memFunctions.ccpDataMemoryParams(obj.lib.getParam(), { sramAddressProtection : ccpParams.DataMemAddressProtection });
    var tagStructures   = [];
    var dataStructures  = [];
    var portNum          = 0; // unused

    for (var i = 0; i &lt; ccpParams.nTagBanks; i++) {
        tagStructures[i] =
            memFunctions.createMemoryDataStructure(
                ccpTagGen[i],
                tagP, 
                &#39;sp&#39;,
                1,
                ccpTagGen[i].rtlPrefixString,
                &#39;&#39;,
                portNum);
    }

    for (var i = 0; i &lt; ccpParams.nDataBanks; i++) {
        dataStructures[i] =
            memFunctions.createMemoryDataStructure(
                ccpDataGen[i],
                dataP,
                &#39;sp&#39;,
                0,
                ccpDataGen[i].rtlPrefixString,
                &#39;&#39;,
                portNum);
    }
//Adding to ccpParams object
    ccpParams[&#39;tagStructures&#39;]  = tagStructures;
    ccpParams[&#39;dataStructures&#39;] = dataStructures;

//Creating Ports
    for (var i = 0; i &lt; ccpParams.nTagBanks; i++) {
        if (tagStructures[i].memoryType === &quot;SYNOPSYS&quot;) {
            /* istanbul ignore if */
            if (Object.keys(tagStructures[i].signals).length &gt; 0) {
                utilFunctions.defineMasterPortsFromInterface(tagStructures[i].rtlPrefixString + i + &#39;_&#39;, tagStructures[i].signals, obj.lib.port);
            }
        }
    }
    for (var i = 0; i &lt; ccpParams.nDataBanks; i++) {
        if (dataStructures[i].memoryType === &quot;SYNOPSYS&quot;) {
            /* istanbul ignore if */
            if (Object.keys(dataStructures[i].signals).length &gt; 0) {
                utilFunctions.defineMasterPortsFromInterface(dataStructures[i].rtlPrefixString + i + &#39;_&#39;, dataStructures[i].signals, obj.lib.port);
            }
        }
    }

//Creating CCP Memory Interface object
   for(var bank = 0; bank &lt; tagStructures.length; bank++) {
       for(var signal in tagStructures[bank].controlSignals) {
           ccpMemoryInterface[tagStructures[bank].rtlPrefixString+bank+&#39;_&#39;+signal] = tagStructures[bank].controlSignals[signal];
       }

   }
   for(var bank = 0; bank &lt; dataStructures.length; bank++) {
       for(var signal in dataStructures[bank].controlSignals) {
           ccpMemoryInterface[dataStructures[bank].rtlPrefixString+bank+&#39;_&#39;+signal] = dataStructures[bank].controlSignals[signal];
       }
   }

</pre>
</div></div><p><br/></p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">ccp_top.tachl
=============

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// CCP Tag Memory external interface
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if (useCache) {
    for (var i = 0; i &lt; u.getParam(&quot;nTagBanks&quot;); i++) {
        var rtlPrefixString = u.getParam(&#39;tagStructures&#39;)[i].rtlPrefixString + i;
        var memoryControlInterface = u.getParam(&#39;tagStructures&#39;)[i].controlSignals;
        utilFunctions.defineMasterPortsFromInterface(rtlPrefixString + &#39;_&#39;, memoryControlInterface, obj.lib.port);
    }
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// CCP Data Memory external interface
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
for (var i = 0; i &lt; u.getParam(&quot;nDataBanks&quot;); i++) {
    var rtlPrefixString = u.getParam(&#39;dataStructures&#39;)[i].rtlPrefixString + i;
    var memoryControlInterface = u.getParam(&#39;dataStructures&#39;)[i].controlSignals;
    utilFunctions.defineMasterPortsFromInterface(rtlPrefixString + &#39;_&#39;, memoryControlInterface, obj.lib.port);
}


ccp.tachl
=========

//BOON: addr_w should be log2ceil(tagStructures[0].depth)
var addr_w             = log2ceil(nSets / nTagBanks);

//BOON: wDataBankAddr should be log2ceil(dataStructures[0].depth)
var wDataBankAddr = wWays
                    + u.getParam(&#39;PriSubDiagAddrBits&#39;).length
                    - u.getParam(&#39;DataBankSelBits&#39;).length
                    + log2ceil(nBeats);

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// CCP Tag Memory external interface
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

if (useCache) {
    for (var i = 0; i &lt; u.getParam(&quot;nTagBanks&quot;); i++) {
u.port(&#39;output&#39;, &#39;tag_mem&#39;+i+&#39;_reinit&#39;,         1);
u.port(&#39;output&#39;, &#39;tag_mem&#39;+i+&#39;_address&#39;,        addr_w);
u.port(&#39;output&#39;, &#39;tag_mem&#39;+i+&#39;_chip_en&#39;,        1);
u.port(&#39;output&#39;, &#39;tag_mem&#39;+i+&#39;_write_en&#39;,       1);
u.port(&#39;output&#39;, &#39;tag_mem&#39;+i+&#39;_write_en_mask&#39;,  nWays);
u.port(&#39;output&#39;, &#39;tag_mem&#39;+i+&#39;_data_in&#39;,        tagStructures[0].width);
u.port(&#39;input&#39;,  &#39;tag_mem&#39;+i+&#39;_data_out&#39;,       tagStructures[0].width);
u.port(&#39;input&#39;,  &#39;tag_mem&#39;+i+&#39;_ready_out&#39;,      1);
    }
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// CCP Data Memory external interface
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
for (var i = 0; i &lt; u.getParam(&quot;nDataBanks&quot;); i++) {
u.port(&#39;output&#39;, &#39;data_mem&#39;+i+&#39;_reinit&#39;,   1);
u.port(&#39;output&#39;, &#39;data_mem&#39;+i+&#39;_data_in&#39;,  dataStructures[0].width);
u.port(&#39;output&#39;, &#39;data_mem&#39;+i+&#39;_write_en&#39;, 1);
u.port(&#39;output&#39;, &#39;data_mem&#39;+i+&#39;_chip_en&#39;,  1);
u.port(&#39;output&#39;, &#39;data_mem&#39;+i+&#39;_address&#39;,  wDataBankAddr);
u.port(&#39;input&#39;,  &#39;data_mem&#39;+i+&#39;_data_out&#39;, dataStructures[0].width);
u.port(&#39;input&#39;,  &#39;data_mem&#39;+i+&#39;_ready_out&#39;,1);
}


</pre>
</div></div><p><br/></p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">hw-lib/js/lib_utils.js
======================
/************************************************************
 * Returns the number of bits required for error encoding.
 *
 * @arg {string} fnErrDetectCorrect - error encoding type.
 * @arg {Number} width - data width before encoding.
 * @return {Number} - The number of bits required for the error code.
 */
function getErrorEncodingWidth(fnErrDetectCorrect, width, blockWidths) {
    //u.log(&quot;EncodingWidth ... &quot;+fnErrDetectCorrect+&quot;, &quot;+width);
    var errWidth = 0;
    var resolution;

    if (fnErrDetectCorrect === &#39;PARITYENTRY&#39;) {
        errWidth = 1;
    } else if (fnErrDetectCorrect === &#39;PARITY16BITS&#39;) {
        errWidth = Math.ceil(width / 16);
    } else if (fnErrDetectCorrect === &#39;PARITY8BITS&#39;) {
        errWidth = Math.ceil(width / 8);
    } else if (fnErrDetectCorrect === &#39;SECDED&#39;) {
        if (width === 1) {
            errWidth = 3;
        } else if (width === 2) {
            errWidth = 4;
        } else {
            errWidth = Math.ceil(Math.log2(width + Math.ceil(Math.log2(width)) + 1)) + 1;
        }
        if (width &lt;= 2) {
            throw new Error(&#39;SECDED Entry is not supported if data width &lt;= 2.: &#39;);
        }
    } else if (fnErrDetectCorrect === &#39;SECDED64BITS&#39;) {
        resolution = 64;
    } else if (fnErrDetectCorrect === &#39;SECDED128BITS&#39;) {
        resolution = 128;
    }


    var numInst;
    var wInstData;
    var inst;
    if (fnErrDetectCorrect === &#39;SECDED64BITS&#39; ||
        fnErrDetectCorrect === &#39;SECDED128BITS&#39;) {
        if (blockWidths) {
            numInst = blockWidths.length;
            for (inst = 0; inst &lt; numInst; inst++) {
                wInstData = blockWidths[inst];
                if (wInstData === 1) {
                    errWidth += 3;
                } else if (wInstData === 2) {
                    errWidth += 4;
                } else {
                    errWidth += Math.ceil(Math.log2(wInstData + Math.ceil(Math.log2(wInstData)) + 1)) + 1;
                }
            }
        } else {
            numInst = Math.ceil(width / resolution);
            for (inst = 0; inst &lt; numInst; inst++) {
                if ((resolution * (inst + 1)) &gt; width) {
                    wInstData = width % resolution;
                } else {
                    wInstData = resolution;
                }
                if (wInstData === 1) {
                    errWidth += 3;
                } else if (wInstData === 2) {
                    errWidth += 4;
                } else {
                    errWidth += Math.ceil(Math.log2(wInstData + Math.ceil(Math.log2(wInstData)) + 1)) + 1;
                }
            }
        }
    }

    return errWidth;
}</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">hw-lib/js/lib_utils.js
======================
function dataBufferMemoryParams(width, nSets, nBeats, nBanks, errorInfo, moreParams = {&quot;sramAddressProtection&quot; : 0}) {

    if (moreParams.sramAddressProtection) { } else { moreParams.sramAddressProtection = 0 };

    var dataWidth = width;

    var memDepth = nBeats * nSets / nBanks;

    var memDepthWidth = log2ceil(memDepth);
    var sramAddressProtectionWidth = moreParams.sramAddressProtection ? memDepthWidth : 0;

    // ECC Calculations

    var memEccBlocks = [];
    var eccOnlyBlocks = [];
    var blockWidths = [sramAddressProtectionWidth + dataWidth];
    var eccIndexes = getEccIndexes(blockWidths, 0, errorInfo);

    memEccBlocks = eccIndexes.memEccBlocks;
    eccOnlyBlocks = eccIndexes.eccOnlyBlocks;

    var memWidth = dataWidth + getErrorEncodingWidth(errorInfo, sramAddressProtectionWidth + dataWidth, blockWidths);

    return {
        depthWidth: memDepthWidth,
        sramAddressProtectionWidth: sramAddressProtectionWidth,

        widthWithoutEcc: dataWidth,
        blockWidths: blockWidths,
        width: memWidth,
        depth: memDepth,
        eccOnlyBlocks: eccOnlyBlocks,
        eccBlocks: memEccBlocks
    }
}</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">hw-lib/js/lib_utils.js
======================
// returns an object with the following bit fields:
//   controlSignals
//    widthWithoutEcc
//    width
//    depth
//    blockWidths
//    rtlPrefixingString
//    memoryType
//    nSignals
//    signals -&gt; this is an old-style interface object
//    modulePrefix

function createMemoryDataStructure(memoryStructure, memoryCalculatedParams, memoryPorts, bitEnable, modulePrefix, identifier, moduleIndex) {
    var dataStructure = {};
    // Create default prefix
    var defaultPrefix = modulePrefix + identifier;
    if (memoryStructure) {
        // Add control signals and their widths to the data structure
        var memoryControlSignals = getMemoryControlSignals(
            memoryStructure.MemType,
            memoryCalculatedParams,
            memoryPorts, // &#39;tp&#39;,
            bitEnable // moduleParams.NativeInfo.useIoCache //bitEnable
        );

        dataStructure.controlSignals = memoryControlSignals;
        // Memory Calculations
        dataStructure.widthWithoutEcc = memoryCalculatedParams.widthWithoutEcc;
        dataStructure.width = memoryCalculatedParams.width;
        dataStructure.depth = memoryCalculatedParams.depth;
        dataStructure.blockWidths = memoryCalculatedParams.blockWidths;
        // Add test signals
        if ((!memoryStructure.rtlPrefixString) || memoryStructure.MemType === &#39;NONE&#39;) {
            // set name to default name
            // If the memory type is none, set the rtlStringPrefix so a default value
            // this is because the created memory uses this default name for all
            // memories accross ports
            dataStructure.rtlPrefixString = defaultPrefix;
            dataStructure.memoryType = memoryStructure.MemType;
            // if rtlPrefixString is 0 or memoryType is none, delete signals
            dataStructure.nSignals = 0;
            dataStructure.signals = {};
        } else {
            // set name to default name
            dataStructure.rtlPrefixString = memoryStructure.rtlPrefixString;
            dataStructure.modulePrefix = modulePrefix + moduleIndex;
            dataStructure.memoryType = memoryStructure.MemType;

            var signals = {};
            dataStructure.nSignals = memoryStructure.Signals.length;
            for (var i = 0; i &lt; dataStructure.nSignals; i++) {
                if (memoryStructure.Signals[i].Direction === &#39;IN&#39;) {
                    signals[memoryStructure.Signals[i].Name] = 0 - memoryStructure.Signals[i].Width;
                } else {
                    signals[memoryStructure.Signals[i].Name] = memoryStructure.Signals[i].Width;
                }
            }
            dataStructure.signals = signals;
        }
    } else {
        throw &#39;createMemoryDataStructure: memoryStructure is not valid; default prefix is &#39; + defaultPrefix;
    }
    return dataStructure;
}</pre>
</div></div>