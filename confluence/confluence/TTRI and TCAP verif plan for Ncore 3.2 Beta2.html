<p><br/></p><h3 id="TTRIandTCAPverifplanforNcore3.2Beta2-TTRIchecking">TTRI checking</h3><p>The trigger checking is done the following way. <br/>Each AIU scoreboard (CHI and IOAIU) instantiates a trace_trigger_utils object.<br/>Each AIU calls trace_trigger_utils register write functions whenever a trigger register is written to pass along new register values. Limitation: trigger registers are only written at the beginning of the test, never after that.<br/>Each AIU calls the trace_trigger_utils function gen_expected_traceme() passing a set of native signals and is returned the expected value of traceme.<br/>Each AIU compares the actual traceme bit from the SMI with the expected traceme bit from gen_expected_traceme() and reports any miscompares as errors.</p><h3 id="TTRIandTCAPverifplanforNcore3.2Beta2-TTRIstimulus">TTRI stimulus</h3><p>The following test variations should be created from a basic trigger test using the runsim &quot;flavors&quot; testlist feature.<br/>Plusargs will be used at CHI, IOAIU and FSYS levels to control trigger registers.<br/>All registers can be either fully specified with a 32-bit plusarg value or fully randomized (unconstrained).<br/>For Beta2, nTraceRegisters=1, 2, 4 will be tested.<br/>Each test should have at least 10 occurrences of traceme = 1, and at least 10 occurrences of traceme = 0.<br/>Some tests check connectivity and need to be run in all three testbenches. Other tests test the RTL trigger block internals and only need to be tested in CHI. This is specified below.<br/>Rerun most CHI and ioaiu tests at FSYS. See the table below.</p><p><br/></p><div class="table-wrap"><table class="relative-table wrapped confluenceTable" style="width: 100.0%;"><colgroup><col style="width: 5.91145%;"/><col style="width: 7.91721%;"/><col style="width: 9.73317%;"/><col style="width: 37.9745%;"/><col style="width: 38.4344%;"/></colgroup><tbody><tr><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><strong>Summary of trigger tests</strong></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><th class="confluenceTh">CHI</th><th class="confluenceTh">IOAIU</th><th class="confluenceTh">FSYS</th><th class="confluenceTh">test flavor name</th><th class="confluenceTh">description</th></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">master_init_only</td><td class="confluenceTd">simple master initiated trace</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">no</td><td class="confluenceTd">ncore_init_addr_match_rand</td><td class="confluenceTd">ncore-initiated, addr match with random base addr, range size=0</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y, some</td><td class="confluenceTd">ncore_init_addr_match_0s_size(00-1f)</td><td class="confluenceTd">ncore-initiated, addr match to address all 0's, different sizes</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y, some</td><td class="confluenceTd">ncore_init_addr_match_fs_size(00,1f)</td><td class="confluenceTd">ncore-initiated, addr match to address all f's, different sizes</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">ncore_init_op_code_match</td><td class="confluenceTd">ncore-initiated, op_code match, random TOPCR</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">no</td><td class="confluenceTd">ncore_init_op_code_match_no_valids</td><td class="confluenceTd">ncore-initiated, op_code match, valid1-4 all zero, corner case</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y, some</td><td class="confluenceTd">ncore_init_mem_attr_match(0-f)</td><td class="confluenceTd">ncore-initiated, mem_attr match, all values</td></tr><tr><td class="confluenceTd">n/a</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">ncore_init_mem_attr_match_aw</td><td class="confluenceTd">ncore-initiated, mem_attr match, writes only</td></tr><tr><td class="confluenceTd">n/a</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">ncore_init_mem_attr_match_ar</td><td class="confluenceTd">ncore-initiated, mem_attr match, reads only</td></tr><tr><td class="confluenceTd">n/a</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">ncore_init_mem_attr_match_aw_ar</td><td class="confluenceTd">ncore-initiated, mem_attr match, writes and reads</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">ncore_init_user_match</td><td class="confluenceTd">ncore-initiated, user bits match</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y, some</td><td class="confluenceTd">ncore_init_user_match_mask_0</td><td class="confluenceTd">ncore-initiated, user bits match, user mask all 0's, corner case</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y, some</td><td class="confluenceTd">ncore_init_target_type_dii_match(00-1f)</td><td class="confluenceTd">ncore-initiated, dii target type match, test for each HUI value</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y, some</td><td class="confluenceTd">ncore_init_target_type_dmi_match(00-1f)</td><td class="confluenceTd">ncore-initiated, dmi target type match, test for each HUI value</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">no</td><td class="confluenceTd">no</td><td class="confluenceTd">ncore_init_all</td><td class="confluenceTd">ncore-initiated, every match type (ANDed)</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">no</td><td class="confluenceTd">no</td><td class="confluenceTd">master_init_and_ncore_init_all</td><td class="confluenceTd">master-initiated trace ANDed with ncore-initiated, every match type</td></tr></tbody></table></div><p class="auto-cursor-target">To get more details than the test summary above, please look at the following:</p><p class="auto-cursor-target">(For CHI, nTraceRegisters=1) see hw-ncr/dv/chi_aiu/tb/runsim_testlist.json, test ttrig with all its flavors</p><p class="auto-cursor-target">(For CHI, nTraceRegisters=2, 4) see hw-ncr/dv/chi_aiu/tb/runsim_testlist.json, test TBD with all its flavors</p><p class="auto-cursor-target">(For IOAIU) TBD</p><p class="auto-cursor-target">After Beta2: allow for better trigger register randomization. Create a mechanism where some register fields can be fixed and other fields randomized. Allow for constraints and weighting. This would reduce the number of trigger tests but increase the coverage.</p><h5 id="TTRIandTCAPverifplanforNcore3.2Beta2-TTRIstrategy."><strong>TTRI strategy.</strong></h5><p>The primary test bench for testing trace trigger will be CHI. IOAIU tests will be primarily concerned with checking IOAIU trace trigger connectivity, not testing the internals of the trace trigger logic.</p><h3 id="TTRIandTCAPverifplanforNcore3.2Beta2-TCAPchecking:TraceCaptureScoreboardcheckingandlimitations">TCAP checking: Trace Capture Scoreboard checking and limitations</h3><h5 id="TTRIandTCAPverifplanforNcore3.2Beta2-TCAPscoreboardintegration">TCAP scoreboard integration</h5><p>Each unit environment instantiates the Trace Capture Scoreboard.</p><p>The unit environment connects the SMI analysis ports to the Trace Capture Scoreboard.</p><p>The unit environment writes to the trace capture scoreboard static register fields whenever the Capture Control Register is written.</p><p>Once the Trace Capture Scoreboard knows the Capture Control Register value and has the SMI analysis port connections it can perform some checking of the actual DTWs output by the Trace Capture block versus what the scoreboard decides are the trace messages that should be seen in the DTWs.</p><h5 id="TTRIandTCAPverifplanforNcore3.2Beta2-TCAPstrategy."><strong>TCAP strategy.</strong></h5><p>The primary test bench for testing trace capture will be DMI. The other benches: DII, CHI, and IOAIU will be primarily concerned with checking trace capture connectivity in those units, not testing the internals of the trace capture logic.</p><h5 id="TTRIandTCAPverifplanforNcore3.2Beta2-Droppedandstucktracemessages."><strong>Dropped and stuck trace messages.</strong></h5><p>There are two ways that RTL trace messages will not show up in DTWs. <br/>1. If the capture system is full including the new SMI network input FIFOs, new SMI messages with traceme set will not lead to trace messages that end up in the TCAP accumulators or DTWs. These are <strong>dropped</strong> trace messages. <br/>2. Trace messages might make it to a TCAP accumulator. If there is not enough for that accumulator to create a full DTW, then that trace message is <strong>stuck</strong> in an unsent partial DTW for a period of time, up to 2^16 cycles.</p><p><br/>This timeout period is currently a parameter set to 2^16 cycles, and there is no register to allow tests to control it.<br/>Our tests will not have a drain time of 2^16 cycles to allow all the trace messages to be send out in DTWs.<br/>We do not have the capability in the scoreboard to peek into the RTL to see if there are stuck trace messages in the accumulators.<br/>Both of these types will lead to the following situation. There will be expected trace messages in the scoreboard, generated from SMI messages with traceme, that will not show up in DTWs. <br/>We will not be able to distinguish dropped trace messages from stuck trace messages. <br/>We will not be able to report errors for dropped or stuck messages since we do not have enough information to determine whether it was correct for the design to have a dropped or stuck message. We can only report a simple combined count of dropped_or_stuck_trace_message_count per trace capture scoreboard. <br/>The trace scoreboard comparisons between expected trace messages and actual trace messages from DTWs can only report an error if an actual trace message occurs with no expected, but no other combination of expected and actual trace messages can be checked. <br/>For example, if 1000 trace messages should have been generated, but all were dropped or stuck and no DTWs were output, the scoreboard would report no error and report dropped_or_stuck_trace_message_count = 1000.</p><h5 id="TTRIandTCAPverifplanforNcore3.2Beta2-Timestampchecking."><strong>Timestamp checking.</strong></h5><p>The trace capture scoreboard does not have access to the RTL internal timestamp value.<br/>Even within a single DTW, timestamp values are not guaranteed to be increasing, they can go up or down, unless only trace capture from one SMI network is specified in the Capture Control Register.</p><p>There are three possible ways of doing partial timestamp with the current limitations.<br/>1. Narrow timestamp checking. When only a single SMI network is enabled for capture, and the block level testbench does not allow for negative timestamp corrections, we could check that within a DTW, timestamps never decrement.<br/>2. Wide timestamp checking. When multiple SMI networks are enabled for capture, and the block level testbench does not allow for negative timestamp corrections, we could use the algorithm below for checking.<br/>3. Extra-wide timestamp checkin. Same as #2, but works for any timestamp corrections (negative or positive).</p><p>The check has a timestamp check interval. This could be a plusarg with a default. Let’s say that the value is 100.<br/>Once every 100 Trace Messages from DTWs are observed, checker does the following.<br/>Compares the average of the timestamps in the current Trace Message, to the average of the timestamps in the Trace Message from 100 Trace Messages ago (old_Trace_Message_timestamp_average).<br/>Basically, we check that Trace_Message_timestamp_average(n) &gt; Trace_Message_timestamp_average(n-100).<br/>The new Trace Message timestamp average must be higher than the old Trace Message timestamp average.<br/>We don’t check the timestamp values for Trace Messages 101-199, 201-299, etc, just 100, 200, 300, etc.<br/>We might try to see how low our interval can be and have all tests still pass (100? 50? 7?).<br/>This is clearly not very “rigorous” checking. <br/>We are doing the checking for #3 for Beta2. We could do more rigorous testing after Beta2 if we have access to the RTL internal timestamp value.</p><p>Also, the TCAP scoreboard does not look at the new CCTRLR gain and inc fields or check their effect.</p><p>*** UPDATE *** It turns out that the difference in timestamp between the different accumulators can be more than 2^16 cycles. A partial DTW can be stuck in the first accumulator for 2^16 cycles while the other accumulators can output hundreds or even thousands of Trace Messages. When we change to check every 600 Trace Messages, things mostly pass so far (one failure).</p><h5 id="TTRIandTCAPverifplanforNcore3.2Beta2-NoRollovertesting.">No Rollover testing.</h5><p>We have no front-door or back-door control of the RTL internal timestamp value. Since a timestamp rolls over after 2^32 cycles (except for corrections), none of our tests will ever see a rollover and we cannot do any rollover testing.<strong><br/></strong></p><h5 id="TTRIandTCAPverifplanforNcore3.2Beta2-Uncorrectedtrace.">Uncorrected trace.</h5><p>For correctable errors for Beta2, the design create trace messages from the uncorrected SMI packet, not the corrected SMI packet. So, this is what DV will check for Beta2.<strong><br/></strong></p><h5 id="TTRIandTCAPverifplanforNcore3.2Beta2-Otherchecks.">Other checks.</h5><p><br/>The trace scoreboard can do some minimal checking of the legality of some DTW fields and which SMI can be used for DTW output.</p><h5 id="TTRIandTCAPverifplanforNcore3.2Beta2-Summaryofchecking.">Summary of checking.</h5><p>So in summary, the trace capture scoreboard can only report four error types. <br/>1. An actual trace message was received that has no equivalent expected trace message.<br/>2. Some extremely large timestamp errors.<br/>3. Some minimal legality checking of DTW_debug fields.</p><p>4. DTB_debug_req coming out from the wrong SMI port (wrong TX or any RX).</p><h5 id="TTRIandTCAPverifplanforNcore3.2Beta2-AfterBeta2.">After Beta2.</h5><p>Improved timestamp checking.</p><p>Design and DV deal with correctable errors.</p><p>Stricter trace message checking when trace is only captured from one SMI network.</p><h3 id="TTRIandTCAPverifplanforNcore3.2Beta2-TCAPstimulus">TCAP stimulus</h3><p>The following test variations should be create from a basic test using the runsim flavors testlist feature.<br/>Rerunning CHI and ioaiu trigger+capture tests at FSYS should cover two things.<br/>1. Covers CHI and IOAIU TCAP.<br/>2. Provides some coverage of DMI and DII TCAP.</p><p><br/></p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">DMI</th><th class="confluenceTh">DII</th><th class="confluenceTh">CHI</th><th class="confluenceTh">IOAIU</th><th class="confluenceTh">FSYS</th><th class="confluenceTh">test flavor name</th><th class="confluenceTh">notes</th></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">capture_random</td><td class="confluenceTd">All register bits randomized, including SMI inputs, gain value and inc value.</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">capture_none</td><td class="confluenceTd">All SMI bits disabled.</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">capture_tx0</td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">capture_rx0</td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">capture_tx1</td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">capture_rx1</td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">n/a</td><td class="confluenceTd">n/a</td><td class="confluenceTd">n/a</td><td class="confluenceTd">y for DMI</td><td class="confluenceTd">capture_tx2</td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">n/a</td><td class="confluenceTd">n/a</td><td class="confluenceTd">n/a</td><td class="confluenceTd">y for DMI</td><td class="confluenceTd">capture_rx2</td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">capture_tx_other</td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">capture_rx_other</td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">n/a</td><td class="confluenceTd">n/a</td><td class="confluenceTd">n/a</td><td class="confluenceTd">y for DMI</td><td class="confluenceTd">capture_tx_all_dmi</td><td class="confluenceTd">tx-only: DMI</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">n/a</td><td class="confluenceTd">n/a</td><td class="confluenceTd">n/a</td><td class="confluenceTd">y for DMI</td><td class="confluenceTd">capture_rx_all_dmi</td><td class="confluenceTd">rx-only: DMI</td></tr><tr><td class="confluenceTd">no</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">capture_tx_all_others</td><td class="confluenceTd">tx-only: others (DII, CHI, IOAIU)</td></tr><tr><td class="confluenceTd">no</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">capture_rx_all_others</td><td class="confluenceTd">rx-only: others (DII, CHI, IOAIU)</td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">n/a</td><td class="confluenceTd">n/a</td><td class="confluenceTd">n/a</td><td class="confluenceTd">y for DMI</td><td class="confluenceTd">capture_tx_rx_all_dmi</td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">no</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">y</td><td class="confluenceTd">capture_tx_rx_all_others</td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">y</td><td class="confluenceTd">n/a</td><td class="confluenceTd">n/a</td><td class="confluenceTd">n/a</td><td class="confluenceTd">y for DMI</td><td class="confluenceTd">capture_tx_rx_all_dmi_gain(0-f)</td><td class="confluenceTd">try all gain values</td></tr><tr><td colspan="1" class="confluenceTd">no</td><td colspan="1" class="confluenceTd">y</td><td colspan="1" class="confluenceTd">y</td><td colspan="1" class="confluenceTd">y</td><td colspan="1" class="confluenceTd">y</td><td colspan="1" class="confluenceTd">capture_tx_rx_all_others_gain(0-f)</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">several values</td><td colspan="1" class="confluenceTd">n/a</td><td colspan="1" class="confluenceTd">n/a</td><td colspan="1" class="confluenceTd">n/a</td><td colspan="1" class="confluenceTd">several values for DMI</td><td colspan="1" class="confluenceTd">capture_tx_rx_all_dmi_inc</td><td colspan="1" class="confluenceTd">try several inc values in 4.8 integer/fraction format</td></tr><tr><td colspan="1" class="confluenceTd">no</td><td colspan="1" class="confluenceTd">several values</td><td colspan="1" class="confluenceTd">several values</td><td colspan="1" class="confluenceTd">several values</td><td colspan="1" class="confluenceTd">several values</td><td colspan="1" class="confluenceTd">capture_tx_rx_all_others_inc</td><td colspan="1" class="confluenceTd"><br/></td></tr></tbody></table></div><p class="auto-cursor-target">To get more details than the test summary above, please look at the following:</p><p class="auto-cursor-target">For CHI, see hw-ncr/dv/chi_aiu/tb/runsim_testlist.json, test ttrig_tcap with all its flavors</p><p class="auto-cursor-target">For IOAIU, see hw-ncr/dv/ioaiu/tb/runsim_testlist.json, test ttrig_tcap with all its flavors</p><p class="auto-cursor-target">For DMI, see hw-ncr/dv/dmi/tb/runsim_testlist.json, label tcap_regr</p><p class="auto-cursor-target">Most of DMI coverage comes from test &quot;random&quot; with randomized CCTRLR.</p><p class="auto-cursor-target">Manually check a long test to make sure that after 2^16 cycles, a partial DTW is sent out.</p><p><br/></p><p>After Beta2:</p><p>Allow for better trigger capture randomization. Create mechanism where some register fields can be fixed and other fields randomized. Allow for constraints and weighting. This would reduce the number of trigger tests but increase the coverage.</p><p>Create tests that do a Timed Send of a partial DTW after 2^16 cycles. Discuss additional checking for this.<br/>Create a test to do rollover testing. Requires the ability to overwrite the RTL timestamp value.</p><p><br/></p><h4 id="TTRIandTCAPverifplanforNcore3.2Beta2-Parameters">Parameters</h4><p>TCAP: nUnitTraceBufSize: default value only will be tested for Beta2 (clarify this during the review).<br/>TTRI: nTraceRegisters: values of 1 (default value), 2 and 4 will be tested for Beta2.</p><h4 id="TTRIandTCAPverifplanforNcore3.2Beta2-OtherBeta2traceanddebuglimitations">Other Beta2 trace and debug limitations</h4><h5 id="TTRIandTCAPverifplanforNcore3.2Beta2-End2endDTWchecking"><br/>End2end DTW checking</h5><p>Ncore 3.2 currently has no end-to-end or Legato scoreboard instantiated in FYS simulations to make sure that DTW requests and responses travel correctly across different networks.</p><h5 id="TTRIandTCAPverifplanforNcore3.2Beta2-Registers">Registers</h5><p><br/>TTRI, TCAP and TACC control registers will only be programmed once at the beginning of the simulation, before any native traffic starts.<br/>Static variables are being used for trace registers inside DV. The unit needs to pass along the trace register writes to these static registers manually. Full 32-bit register accesses supported, not partial register access.<br/>DV has its own register data structures and does not use the RAL. This means we currently have to be aware of any register spec changes and update our DV code manually.</p><p><br/></p><h5 id="TTRIandTCAPverifplanforNcore3.2Beta2-RTLaccess">RTL access</h5><p><br/>We currently have no access to RTL values other than SMI. This significantly restricted our ability to check timestamp values.</p><p><br/></p><h4 id="TTRIandTCAPverifplanforNcore3.2Beta2-TTRIfunctionalcoverage">TTRI functional coverage</h4><p>After beta2, the following functional coverage should be written for TTRI.</p><p>DV trigger register field values (crossed with other fields, including those from related trigger registers). <br/>TCTRLR:  native_trace_en, addr_match_en, memattr_match_en, opcode_match_en, target_type_en, user_match_en, hut, hui, range/size, aw, ar, memattr<br/>TBALR+TBAHR: base_addr<br/>TOPCR: valid1-4, opcode1-4<br/>TUBR+TUBMR: user, user_mask</p><p>Values for the following native signals and some crosses between. <br/>traceme<br/>addr<br/>ar<br/>aw<br/>dii_hit<br/>dmi_hit<br/>hui<br/>memattr<br/>opcode<br/>user<br/><br/>Values for the following expected signals from DV. <br/>addr_matched<br/>user_matched<br/>mem_attr_matched<br/>opcode_matched<br/>target_type_matched<br/>traceme_out</p><p><br/></p><h4 id="TTRIandTCAPverifplanforNcore3.2Beta2-TCAPfunctionalcoverage">TCAP functional coverage</h4><p>After beta2, the following functional coverage should be written for TCAP.</p><p>(Separate coverage for CHI, IOAIU, DMI, DII instances)<br/>traceme in<br/>DTW_debug_req coverage<br/>DTW_debug_rsp coverage<br/>smi.len</p><p><br/></p><p><br/></p><p><br/></p><p><br/></p><p><br/></p><p><br/></p>