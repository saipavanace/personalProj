<p><strong>module_name</strong></p><p>gen_wrapper</p><h1 id="gen_wrapper-parameters"><strong>parameters</strong></h1><pre>{ </pre><pre>  &quot;interfaces&quot; : </pre><pre>    {&quot;slaveInterfaces&quot; : [],</pre><pre>     &quot;masterInterfaces&quot; : []}, </pre><pre>  &quot;wireInterfaces&quot;: [], </pre><pre>  &quot;instances&quot; : [], </pre><pre>  &quot;assigns&quot; : [], </pre><pre>  &quot;tieOffs&quot; : []</pre><pre>}</pre><h3 id="gen_wrapper-InterfaceArrayFormat:">Interface Array Format:</h3><p>All three Interface arrays use the format as follows:</p><pre>{</pre><pre>  &quot;name&quot; : &quot;g_&quot;,  // a string </pre><pre>  &quot;_SKIP_&quot; : true or false, // If _SKIP_ is true, the interface is ignored</pre><pre>  &quot;params&quot; : {},  // params format is a function of the params the interface object is expecting</pre><pre>  &quot;direction&quot; : &quot;master&quot; or &quot;slave&quot;, </pre><pre>  &quot;interface&quot; : &quot;interface object name&quot; // a string that names the interface from a standard library</pre><pre>}</pre><h3 id="gen_wrapper-InstanceArrayFormat:">Instance Array Format:</h3><p>The elements in the instance array have one of the following formats:</p><pre> {</pre><pre>  &quot;name&quot;: &quot;i0&quot;, // Instance name</pre><pre>  &quot;module&quot; : &quot;module_name&quot;, // TACHL module name </pre><pre>  &quot;rtlModule&quot; : &quot;rtl_module_name&quot;, // Name of module in exported RTL, can be undefined. If undefined takes on value of module.</pre><pre>  &quot;mergeInterfaces&quot; : true or false, // merge interfaces described in connectivity into model params if true.</pre><pre>  &quot;moduleParams&quot; : {},</pre><pre>  &quot;interfaces&quot; : [</pre><pre>    {&quot;local&quot;: &quot;b_&quot;,  // The name of the interface at the level of the gen_wrapper</pre><pre>     &quot;module&quot;: &quot;a_&quot;,  // The name of the interface in the module being instanced </pre><pre>     &quot;direction&quot; : &quot;master&quot; or &quot;slave&quot;}, // which direction is the interface, needed for mergeInterfaces = true</pre><pre>    {},{}]</pre><pre>} </pre><h3 id="gen_wrapper-AssignArrayFormat:"><strong>Assign Array Format:</strong></h3><pre>{ </pre><pre>  &quot;master&quot; : &quot;a_&quot;, // The interface to be assigned to </pre><pre>  &quot;slave&quot; : &quot;b_&quot; // The interface to be assigned from</pre><pre>}</pre><h3 id="gen_wrapper-TieOffArrayFormat:"><strong>TieOff Array Format:</strong></h3><pre>{</pre><pre>  &quot;interface&quot; : &quot;g_&quot;, // an interface name that exists in the three interface arrays.</pre><pre>  &quot;direction&quot;: &quot;master&quot; or &quot;slave&quot;, // Only used when the interface is found in the wireInterfaces array.</pre><pre>  &quot;values&quot; : [</pre><pre>    {&quot;signal&quot; : &quot;string&quot;, // Name of the signal to be tied off.</pre><pre>     &quot;value&quot;: &quot;string&quot;},  // Value the signal is tied off to.</pre><pre>    {},{}]</pre><pre>}</pre><h1 id="gen_wrapper-I/O"><strong>I/O</strong></h1><h2 id="gen_wrapper-obj.lib.nInterfaces(interfaces);"><span style="font-size: 14.0px;"> obj.lib.nInterfaces(interfaces);</span></h2><h1 id="gen_wrapper-ModulesUsed"><strong>Modules Used</strong></h1><p>Any</p><h1 id="gen_wrapper-Description"><strong>Description</strong></h1><p>This is a generic wrapper that can be used to wrap any group of modules written in TACHL than can be connected by point to point interfaces or one to many interfaces, even if that module doesn't support interfaces. The generic wrapper can call itself as one of the instance modules. There is no mechanism for doing logic directly. You can assign interfaces to each other or tie them off.</p><p>The list of slave interfaces are nominally the input interfaces into the block.</p><p>The list of master interfaces are nominally the output interfaces out of the block.</p><p>The list of wire interfaces are the list interfaces that go between the modules instantiated in the wrapper.</p><p>There are three types of nodes that are passed in three arrays: instances, assigns and tieOffs. Instances are used to put down an instance, assigns are used to assign one interface to another and tieOffs are used to tieOff an interface with constants.</p><p>In an instance element you must decide whether to merge or not merge the interfaces defined in interfaces. When you merge (which is only guaranteed to work if you are instancing a generic_wrapper,) it will create an instances parameter to merge with the parameters defined in moduleParams. It uses direction to put the interface either the slaveInterfaces or masterInterfaces array. If you don't merge, generic wrapper will look up the name of the interfaces in the interfaces parameter in moduleParams. If gen_wrapper can't find an interface it errors out.</p><p>In the assign elements are interfaces to tie together. The &quot;master&quot; interface is assigned to the &quot;slave&quot; interface. If the interfaces are different, gen_wrapper errors out. If the master is from the slave list or the slave is from the master list, gen_wrapper errors out.</p><p>For tieOffs elements all outputs are tied off for the mode of the interface is in (master or slave) and the inputs are left alone. If an output signal name matches to a signal that exists in values, it is tied to the value indicated, otherwise it is tied to all 0s.</p><p>NOTE: If you want to instance a module that doesn't use the new interface objects, setup your parameters for that instance as you would normally do, then set mergeInterface to true. This will only work if you don't already have a parameter for that module named &quot;interfaces&quot;. &quot;interfaces&quot; will be added to the parameters passed to the module but they will then be ignored.</p><h2 id="gen_wrapper-OptionalInterfaces">Optional Interfaces</h2><p>The generic wrapper looks in instances[I].moduleParams.interfaces and makes sure that all the interfaces described are connected in instances[i].interfaces. If an interface is missing an error is thrown. However, if the _SKIP_ parameter of an interface in instances[I].moduleParams.interfaces is set to true, then an error is not thrown and the interface is skipped.</p>