<p>Matrix Arbiter. Its fairness is Last Used Last Served.<br/>The Matrix Arbiter keeps a complete order of request grants. <br/>The information is maintained in a matrix form where each row<br/>corresponds to an input and each column corresponds to an output. <br/>A 1 at row &lt;a&gt; and column &lt;b&gt; means requestor &lt;a&gt; beats requestor &lt;b&gt;<br/>in acquiring the resource.<br/><br/>An example of a Matrix Arbiter for 4 requestors.<br/>Below is the Initial Priority Sequence of the Matrix Arboter.<br/>X 1 1 1 <br/>0 X 1 1 <br/>0 0 X 1 <br/>0 0 0 X <br/>Priority Sequence = {0,1,2,3}<br/>We only need 4 *(4-1) /2 = 4*3/2 = 6 flip flops for the matrix. <br/><br/>Now let's say Requestor 1 gets processed.<br/>All elements in Column 1 become ones: all inputs now beat input 1.<br/>All elements in Row 1 become zeroes: input 1 cannot beat any other input.<br/>The new matrix will be:<br/>X 1 1 1 <br/>0 X 0 0 <br/>0 1 X 1 <br/>0 1 0 X <br/>Priority Sequence = {0,2,3,1}<br/><br/>Now let's say Requestor 3 gets processed.<br/>All elements in Column 3 become ones: all inputs now beat input 3.<br/>All elements in Row 3 become zeroes: input 3 cannot beat any other input.<br/>The new matrix will be:<br/>X 1 1 1 <br/>0 X 0 1 <br/>0 1 X 1 <br/>0 0 0 X <br/>Priority Sequence = {0,2,1,3}</p><p><br/></p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">input clk;
input reset_n;
input [3:0] alloc_i;
input [3:0] bv_i; //input bit vector
output [3:0] wbv_o; //output winner bit vector

//               wbv_o[0]      wbv_o[1]      wbv_o[2]      wbv_o[3]
//          +--------------------------------------------------------
// bv_i[0]  |  X             ~q_matrix[0]  ~q_matrix[1]  ~q_matrix[2]
// bv_i[1]  |  q_matrix[0]   X             ~q_matrix[3]  ~q_matrix[4]
// bv_i[2]  |  q_matrix[1]   q_matrix[3]   X             ~q_matrix[5]
// bv_i[3]  |  q_matrix[2]   q_matrix[4]   q_matrix[5]   X

wire [5:0] n_matrix;
reg  [5:0] q_matrix;

assign n_matrix[5]   =    alloc_i[2]   | (~alloc_i[3]   &amp; q_matrix[5]);
assign n_matrix[4:3] = {2{alloc_i[1]}} | (~alloc_i[3:2] &amp; q_matrix[4:3]);
assign n_matrix[2:0] = {3{alloc_i[0]}} | (~alloc_i[3:1] &amp; q_matrix[2:0]);

always @ (posedge clk or negedge reset_n)
if (!reset_n) begin
    q_matrix &lt;= 6&#39;b0;
end else begin
    q_matrix &lt;= {|{alloc_i}} ? n_matrix : q_matrix;
end

// output winner bit vector
assign wbv_o[0] = bv_i[0] &amp; ~{|{bv_i[3:1] &amp; q_matrix[2:0]}};
assign wbv_o[1] = bv_i[1] &amp; ~{|{bv_i[3:2] &amp; q_matrix[4:3]}} &amp; ~{|{bv_i[0] &amp;   {                            ~q_matrix[0]}}};
assign wbv_o[2] = bv_i[2] &amp; ~{|{bv_i[3]   &amp; q_matrix[5]}}   &amp; ~{|{bv_i[1:0] &amp; {              ~q_matrix[3], ~q_matrix[1]}}};
assign wbv_o[3] = bv_i[3]                                   &amp; ~{|{bv_i[2:0] &amp; {~q_matrix[5], ~q_matrix[4], ~q_matrix[2]}}};

</pre>
</div></div>