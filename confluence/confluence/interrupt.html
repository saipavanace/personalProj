<h1 id="interrupt-module_name"><strong>module_name</strong></h1><p>interrupt</p><h1 id="interrupt-SWVisible:"><strong>SW Visible:</strong></h1><p>yes</p><h1 id="interrupt-Parameters:"><strong>Parameters:</strong></h1><h2 id="interrupt-Javascript:"><strong>Javascript:</strong></h2><pre>{</pre><pre>  &quot;createCSR&quot; : boolean, // Should always be true. Used when instanced in other blocks.</pre><pre>  &quot;interfaces&quot;: {<br/>    &quot;clkInterface&quot;: { &quot;name&quot;: &quot;&lt;a_name&gt;&quot;, &quot;params&quot;: {}, &quot;direction&quot;: &quot;slave&quot;, &quot;interface&quot;: &quot;InterfaceCLK&quot; },</pre><pre>    &quot;apbInterface&quot;: { &quot;name&quot;: &quot;&lt;a_name&gt;&quot;, &quot;params&quot;: { &quot;wAddr&quot;: &lt;wAddr&gt;, &quot;wData&quot;: 32, &quot;wPSlverr&quot;: &lt;wPSlverr&gt; }, &quot;direction&quot;: &quot;slave&quot;, &quot;interface&quot;: &quot;InterfaceAPB&quot; },</pre><pre>    &quot;inIntInterface&quot;: [{ &quot;name&quot;: &quot;&lt;a_name&gt;&quot;, &quot;params&quot;: { &quot;width&quot;: &lt;N&gt; }, &quot;direction&quot;: &quot;slave&quot;, &quot;interface&quot;: &quot;InterfaceINT&quot; },{}{},],</pre><pre>    &quot;outIntInterface&quot;: { &quot;name&quot;: &lt;a_name&gt;&quot;, &quot;params&quot; : { &quot;width&quot;: &lt;N&gt; }, &quot;direction&quot;: &quot;master&quot;, &quot;interface&quot;: &quot;InterfaceINT&quot; }<br/>  },</pre><pre>  id : integer // ID of the interrupt block; the value can be read out by software via a CSR register. </pre><pre>}</pre><pre><br/></pre><h1 id="interrupt-InterfacesUsed:"><strong>Interfaces Used:</strong></h1><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168894/InterfaceCLK" data-linked-resource-id="16168894" data-linked-resource-version="5" data-linked-resource-type="page">InterfaceCLK</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168579/InterfaceAPB" data-linked-resource-id="16168579" data-linked-resource-version="2" data-linked-resource-type="page">InterfaceAPB</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16160508/InterfaceINT" data-linked-resource-id="16160508" data-linked-resource-version="3" data-linked-resource-type="page">InterfaceINT</a></p><h1 id="interrupt-FunctionsUsed:"><strong>Functions Used:</strong></h1><p>none</p><h1 id="interrupt-ModulesUsed:"><strong>Modules Used:</strong></h1><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16160014/HW-CTF+sym_apb_csr" data-linked-resource-id="16160014" data-linked-resource-version="74" data-linked-resource-type="page">apb_csr</a></p><p>diffr_sync</p><h1 id="interrupt-Description:"><strong>Description:</strong></h1><p>This module implements the interrupt accumulation function - using an Interrupt Valid register and an Interrupt Mask Register - so as to group N number of interrupts together into one interrupt output, or N number of interrupt outputs. See Chapter 16 Interrupts in the Symphony Architecture spec.</p><p>The value for N must be in the range of 1 to the APB interface data width.</p><p>All interrupts coming to this module is assumed to be synchronous to the input clock of this module.</p><p>All interrupts are level sensitive. 0 indicates no interrupt. 1 indicates interrupt asserted. An interrupt is generated when an Interrupt Valid register interrupt bit is 1 and its corresponding Interrupt mask register bit is 1.</p><p>This module implements two registers: Interrupt Valid register, Interrupt Mask register.</p><p>Interrupt Valid register: Interrupt valid bit goes to 1 when state is 0, and input is 1. Interrupts are cleared by writing 1 to bit corresponding to that interrupt valid bit. Register is readable and writable (write 1 to clear an interrupt valid bit). Power on reset value is 0.</p><p>Interrupt Mask register: One mask bit for every interrupt vald bit. Indicates interrupt is enabled. 0 indicates interrupt is disabled. All 1's is the default value. Register is readable and writable.</p><p>The implementation is that software writes via the APB interface have priority over hardware writes, such that hardware write would happen on the cycle after the software APB write. The interrupt bits are treated as a whole for hardware reads/writes and software reads/writes, so as to facilitate clock gating for the flops for the interrupt bits.</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="https://arterisip.atlassian.net/wiki/download/attachments/16160510/SymphonyInterruptModule.JPG?api=v2"></span></p><h1 id="interrupt-Synchronization">Â Synchronization</h1><p>inIntInterface is passed through a dffr_sync block to synchronize signals to the clock domain the registers are in. The signals are assumed to be levels, and so sophisticated synchronization across clock boundaries is not needed.</p><h1 id="interrupt-CSR">CSR</h1><p>The CSR is internally generated with the following description:</p><pre>&quot;registers&quot;: [<br/> {<br/> &quot;name&quot;: &quot;INTVR&quot;,<br/> &quot;description&quot;: &quot;Interrupt Valid Register&quot;,<br/> &quot;fields&quot;: [<br/>   {<br/>   &quot;name&quot;: &quot;valid&quot;,<br/>   &quot;bitOffset&quot;: 0,<br/>   &quot;bitWidth&quot;: &lt;interrupt width&gt;,<br/>   &quot;access&quot;: &quot;W1C&quot;,<br/>   &quot;hardware&quot;: &quot;RW&quot;,<br/>   &quot;opOrder&quot;: &quot;SW&quot;,<br/>   &quot;reset&quot;: 0<br/>   }<br/>   ]<br/> },<br/> {<br/> &quot;name&quot;: &quot;INTMR&quot;,<br/> &quot;description&quot;: &quot;Interrupt Mask Register&quot;,<br/> &quot;fields&quot;: [<br/>   {<br/>   &quot;name&quot;: &quot;mask&quot;,<br/>   &quot;bitOffset&quot;: 0,<br/>   &quot;bitWidth&quot;: &lt;interrupt width&gt;,<br/>   &quot;access&quot;: &quot;RW&quot;,<br/>   &quot;hardware&quot;: &quot;RO&quot;,<br/>   &quot;opOrder&quot;: &quot;NULL&quot;,<br/>   &quot;reset&quot;: {inIntInterface.length{1'b1}}<br/>   }<br/>   ]<br/> }<br/> ]</pre><h1 id="interrupt-UseCase:"><strong>Use Case:</strong></h1><p>This block is used to accumulate interrupt from multiple sources for interrupt grouping purposes. See Figure 16-1 Example Interrupt Network, Chapter 16 in the Symphony Architecture spec.</p>