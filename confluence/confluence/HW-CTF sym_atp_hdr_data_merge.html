<h2 id="HW-CTFsym_atp_hdr_data_merge-module_name">module_name</h2><p>sym_atp_hdr_data_merge</p><h2 id="HW-CTFsym_atp_hdr_data_merge-JavaScriptparameters">JavaScript parameters</h2><p><strong><em>pktArray</em></strong>: (Required only if using old styled interfaces). Array of packet field description objects, generated by the getPacketArray() function for the <em>outInterface</em>.</p><h2 id="HW-CTFsym_atp_hdr_data_merge-Interfaces">Interfaces</h2><p><em>clkInterface</em>: A slave interface of type <a class="external-link" href="https://confluence.arteris.com/display/ENGR/InterfaceCLK" rel="nofollow" style="text-decoration: none;">InterfaceCLK</a>.</p><p><em>outInterface</em>: A master interface of type <a class="external-link" href="https://confluence.arteris.com/display/ENGR/InterfaceATP" rel="nofollow" style="text-decoration: none;">InterfaceATP</a> for the ingress ATP link.</p><p><em>hdrInterface</em>: A slave interface of type <a class="external-link" href="https://confluence.arteris.com/display/ENGR/InterfaceATP" rel="nofollow" style="text-decoration: none;">InterfaceATP</a>. The bus-width is expected to be the same as <em>outInterface</em>. This link carries header only.</p><p><em>dataInterface</em>: A slave interface of type <a class="external-link" href="https://confluence.arteris.com/display/ENGR/InterfaceATP" rel="nofollow" style="text-decoration: none;">InterfaceATP</a>. The bus-width is expected to be the same as <em>outInterface</em>. This link carries payload only.</p><h2 id="HW-CTFsym_atp_hdr_data_merge-Description">Description</h2><p>The sym_atp_hdr_data_merge block merges two separate links that carry header and payload (data) separately onto a single egress ATP link. This allows reusability of code by blocks that need to separately process header and payload. This means the valid on the <em>hdrInterface</em><span> </span>is expected to go high only for valid header beats on the <em>inInterface</em>, and valid on the <em>dataInterface</em><span> </span>is expected to go high only for valid payload beats on the <em>inInterface</em>.</p><p>For serial this is straightforward. But for other packet styles this requires counters and state-machines to control the assertion of valids as described below.</p><p><br/></p><h3 id="HW-CTFsym_atp_hdr_data_merge-Forpacketstyle,&quot;fixed&quot;">For packet style, &quot;<em>fixed</em>&quot;</h3><p><br/></p><p><span class="confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image image-center" height="150" src="https://arterisip.atlassian.net/wiki/download/attachments/16157294/image2020-6-16_15-15-30.png?api=v2"></span></p><p style="text-align: center;">State-machine diagram for splitting &quot;<em>fixed</em>&quot; style packets. All state-transitions are qualified by <em>outInterface</em> valid.</p><p style="text-align: left;"><br/></p><p style="text-align: left;"><br/></p><p style="text-align: left;">The ready signals for the <em>hdrInterface</em> and <em>dataInterface</em> are generated as below:</p><p style="text-align: left;"><em>hdrInterface</em>.ready   = <em>outInterface</em>.valid &amp; ( state != DATA )</p><p><em>dataInterface</em>.ready = <em>outInterface</em>.valid &amp; ( state == DATA )</p><p style="text-align: left;"><br/></p><p style="text-align: left;">The valid for the <em>inInterface</em> is generated as below:</p><p style="text-align: left;"><em>outInterface</em>.valid   = state != DATA ? <em>hdrInterface</em>.valid : <em>dataInterface</em>.valid</p><p style="text-align: left;"><br/></p><p style="text-align: left;">In order to detect whether the last header beat is sent, a counter that counts the number of header beats is maintained. It stops counting as soon as the last header-beat is sent and resets when <em>outInterface</em> last is high<em>.</em></p><h3 style="text-align: left;" id="HW-CTFsym_atp_hdr_data_merge-Forpacketstyle,&quot;serial&quot;">For packet style, &quot;serial&quot;</h3><p style="text-align: left;">Serial styled packets are considered a limiting case of &quot;fixed&quot; style packets (i.e. a fixed packet with a single header beat). Hence the same design ( as for &quot;fixed&quot;) works for &quot;serial&quot; packets also, expect there is no need of a state-machine. Instead a high on the <em>outInterface</em> first implies HDR state, and a low on the same indicates a DATA state. There is no need for a counter to count the header beats either.</p><p><br/></p><p><br/></p><p><br/></p><p><br/></p><p><br/></p>