<h1 id="HW-CTFsym_fifo_rate_adapter-module_name"><strong>module_name</strong></h1><p>sym_fifo_rate_adapter</p><h1 id="HW-CTFsym_fifo_rate_adapter-parameters"><strong>parameters</strong></h1><pre>{</pre><pre><span> interfaces: {</span></pre><pre>    clkInterface: {name: &quot;a_string&quot;, params: {}, direction: &quot;master&quot; or &quot;slave&quot;, interface: &quot;a_string&quot;},  // Optional based on depth &gt; 0</pre><pre>    protectionInterface: {name: &quot;a_string&quot;, params: {}, direction: &quot;master&quot; or &quot;slave&quot;, interface: &quot;a_string&quot;}, // Optional based on protectionStyle</pre><pre>    inInterface: </pre><pre>      {name: &quot;a_string&quot;,</pre><pre>       params: {interface parameters},</pre><pre>       direction: &quot;slave&quot;, </pre><pre>       pktStyle: &quot;serial&quot;, &quot;parallel&quot; or &quot;fixed&quot;, </pre><pre>       wData: int // power of 2 8 or greater. </pre><pre>       pktDef: {packet: &quot;a_string&quot;} // link packet definition</pre><pre>       interface: &quot;InterfaceATP&quot;}, // Interface must have a 1 bit wide ready and valid.</pre><pre>    outInterface:</pre><pre>      {name: &quot;a_string&quot;,</pre><pre>       params: {interface parameters}, // parameters must match inInterface</pre><pre>       direction: &quot;master&quot;, </pre><pre>       pktStyle: &quot;serial&quot;, &quot;parallel&quot; or &quot;fixed&quot;, </pre><pre>       wData: int // power of 2 8 or greater. </pre><pre>       pktDef: {packet: &quot;a_string&quot;} // link packet definition</pre><pre>       interface: &quot;InterfaceATP&quot;}, // Interface must match inInterface </pre><pre>    genericIoMem : [ </pre><pre>      {name: &quot;a_string&quot;, // The name of the memory module is derived from the name of the generic interface</pre><pre>       params: {interface parameters}, </pre><pre>       interfaceObjType: &quot;a_string&quot;, //matches the interfaceObjType in MemoryGeneration</pre><pre>       direction: &quot;slave&quot;, </pre><pre>       _SKIP_: boolean // true means interface is removed, false means interface is instanced</pre><pre>       interface: &quot;InterfaceGeneric&quot;</pre><pre>    ]</pre><div>    }, </div><pre>  &quot;ratio&quot; : [I,J], // I is then number of in valid beats per J beats on the output. Specifies ratio of beats.</pre><pre>  &quot;split&quot; : boolean, // Split off header field from data if true and pktStyoe = parallel, otherwise ignored (default is false) </pre><pre>  &quot;memName&quot; : string // What do you want to name the memory module. </pre><pre>  &quot;portType&quot; : string // 2p for separate read/write ports or 1p for merged</pre><pre>  &quot;depth&quot; : 4 or greater integer, // The depth of the pipeline. </pre><pre>  &quot;hDepth&quot; : 0 or any positive integer, // If split=true and pktStyle=parallel, depth of header FIFO, </pre><pre>                                        // If split=true and pktStyle~=parallel, FIFO depth is depth+hDepth, otherwise ignored. Default is 0.</pre><pre>  &quot;MemoryGeneration&quot;: [</pre><pre>    {&quot;rtlPrefixString&quot;: &quot;a_string&quot;, // deprecated, must match corresponding generic interface name. </pre><pre>     &quot;memoryType&quot; : &quot;a_string&quot;, // NONE or SYNOPSYS. Type of memory to be generated </pre><pre>     &quot;interfaceObjType: &quot;a_string&quot; // Used to match memory to genericInterface</pre><pre>    },</pre><pre>  ],</pre><pre>  &quot;sramRatio&quot; : integer, // Default: 1. Allowed values: 1,2,4. Indicates the ratio of incoming clock frequency divided by SRAM clock frequency.</pre><pre>  &quot;protectionStyle&quot; : <a class="external-link" href="https://confluence.arteris.com/display/ENGR/protectionStyle" rel="nofollow">protectionStyle</a>}</pre><pre>}</pre><h1 id="HW-CTFsym_fifo_rate_adapter-ModulesUsed"><strong>Modules Used</strong></h1><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166765/rdy_vld_pipe" data-linked-resource-id="16166765" data-linked-resource-version="33" data-linked-resource-type="page">rdy_vld_pipe</a><br/><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156339/HW-CTF+sym_fifo_rate_mem_2p" data-linked-resource-id="16156339" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF sym_fifo_rate_mem_2p</a><br/><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156303/HW-CTF+sym_fifo_rate_mem_1p" data-linked-resource-id="16156303" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF sym_fifo_rate_mem_1p</a> </p><h1 id="HW-CTFsym_fifo_rate_adapter-Description"><strong>Description</strong></h1><p>inInterface.signals and outInterface.signals, pktStyle, wData and pktDef must be identical.</p><p>There is no pipeForward and pipeBackward parameters associated with the sym_fifo_rate_adapter. For timing purposes, the block is equivalent to pipeForward = false and pipeBackward = true. The reason pipeBackward is equal true is because most SRAMs do not allow reads and writes to occur to the same address at the same time, so if the FIFO is full, the FIFO can only be read and not written.</p><p><strong>ratio: </strong>I represents the number of valid beats per J beats on the output. So, if a packet is coming into the block with a valid every other beat, which can happen from a data width adapter, then I = 1 and J = 2. Another way of saying this is the in side has a bubble every other cycle. If the in side has a bubble once ever three cycles, then I = 2 and J = 3. If the in side had two bubbles every 5 cycles, then I = 3 and J = 5.</p><p>The parameter spit changes the internal microarchitecture of the block.</p><h2 id="HW-CTFsym_fifo_rate_adapter-Split=false">Split = false</h2><p>When split = false, the microarchitecture is shown in the figure below:</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16156387/sym_fifo_rate_adapter_noSplit.svg?api=v2"></span></p><p>All the block does is feed atp interfaces directly to the sym_fifo_rate_mem. There are two flavors of the sym_fifo_rate_mem, one for SRAMs with separated read and write ports (<a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156339/HW-CTF+sym_fifo_rate_mem_2p" data-linked-resource-id="16156339" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF sym_fifo_rate_mem_2p</a>) and one for SRAMs with a single port for both reads and writes (<a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156303/HW-CTF+sym_fifo_rate_mem_1p" data-linked-resource-id="16156303" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF sym_fifo_rate_mem_1p</a>). Refer to the microarchitecture documents of these blocks to understand how they work.</p><h2 id="HW-CTFsym_fifo_rate_adapter-Split=true">Split = true</h2><p>When split = true and pktStyle is not parallel, the microarchitecture is the same as shown for split = false, except the depth passed to the sym_fifo_mem is the sum of depth + hDepth.</p><p>When split = true and pktStyle = parable, the microarchitecture is shown in the figure below:</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16156387/sym_fifo_rate_adapter_split.svg?api=v2"></span></p><p>The headers fields are put in a separate rdy_vld_pipe from the data where the depth of the sym_fifo_mem is hDepth. The signals first, last and sb_prot are pushed onto the data sym_fifo_mem. The bus signal is split between header fields and data fields and the headers fields are put into the header rdy_vld_pipe and the data fields are pushed onto the data sym_fifo_mem.</p><p>When lckStyleVld = false a third rdy_vld_pipe is added between the input and the splitting of the packet between header and data. It's parameters are hard coded as:</p><p style="margin-left: 30.0px;">depth = 1<br/>pipeForward = false<br/>pipeBackward = false<br/>circular = false<br/>simplePipe = false</p><p>When lckStyleVld = false, the ATP interfaces are retracting. To keep ready from being a function of vld, this pipe stage grabs a beat of data so that internal logic can determine when to push data onto the header and data blocks. The loading equations in pseudo code are (where \=int_in_name=\ represents the atp interface that feeds the header and data rdy_vld_pipes and ndp_ is header and dp_ is data):</p><p style="margin-left: 30.0px;">reg dp_ready_valid_first;<br/>reg ndp_ready_valid_first;</p><p style="margin-left: 30.0px;">assign next_dp_ready_valid_first = <br/>  ( dp_ready_valid_first &amp; \=int_in_name=\valid &amp; \=int_in_name=\first &amp; ~ndp_\=int_in_name=\ready) |<br/>  (~ndp_ready_valid_first &amp; \=int_in_name=\valid &amp; \=int_in_name=\first &amp; dp_\=int_in_name=\ready &amp; ~ndp_\=int_in_name=\ready);</p><p style="margin-left: 30.0px;">assign next_ndp_ready_valid_first =<br/>  (ndp_ready_valid_first &amp; \=int_in_name=\valid &amp; \=int_in_name=\first &amp; ~dp_\=int_in_name=\ready) |<br/>  (~dp_ready_valid_first &amp; \=int_in_name=\valid &amp; \=int_in_name=\first &amp; ~dp_\=int_in_name=\ready &amp; ndp_\=int_in_name=\ready);</p><p style="margin-left: 30.0px;">assign ndp_\=int_in_name=\valid = \=int_in_name=\first ? \=int_in_name=\valid &amp; ~(ndp_ready_valid_first &amp; ~dp_ready_valid_first) : 1'b0;<br/>assign dp_\=int_in_name=\valid = \=int_in_name=\first ? \=int_in_name=\valid &amp; ~(dp_ready_valid_first &amp; ~ndp_ready_valid_first) : \=int_in_name=\valid;<br/>assign \=int_in_name=\ready = \=int_in_name=\first ? <br/> (ndp_\=int_in_name=\ready &amp; dp_\=int_in_name=\ready) | <br/> (~ndp_ready_valid_first &amp; dp_ready_valid_first &amp; ndp_\=int_in_name=\ready) | <br/> (ndp_ready_valid_first &amp; ~dp_ready_valid_first &amp; dp_\=int_in_name=\ready) : <br/> dp_\=int_in_name=\ready;</p><p>The unloading equations in pseudo code are (where \int_out_name\ comes from the header and data rdy_vld_pipes and ndp_ represents header and dp_ represents data):</p><p style="margin-left: 30.0px;">assign \=outInterface.name=\valid = \=outInterface.name=\first ? ndp_\=int_out_name=\valid &amp; dp_\=int_out_name=\valid : dp_\=int_out_name=\valid;<br/>assign ndp_\=int_out_name=\ready = \=outInterface.name=\ready &amp; \=outInterface.name=\first &amp; dp_\=int_out_name=\valid ;<br/>assign dp_\=int_out_name=\ready = \=outInterface.name=\ready;</p><div><span style="text-decoration: none;" class="legacy-color-text-blue3">The genericIO are matched up with the memories by the use of the interfaceObjType parameters in genericMemIo array entries and MemoryGeneration array entries. The only value supported at this time is 'pipe'.</span></div><h1 id="HW-CTFsym_fifo_rate_adapter-sramRatio"><span style="text-decoration: none;" class="legacy-color-text-blue3">sramRatio</span></h1><p><span style="text-decoration: none;" class="legacy-color-text-blue3">When sram Ratio is 1, the block is as described above. When sram Ratio is 2 or larger, the block becomes:</span></p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16156387/SlowSRAM_FIFO_adapter.svg?api=v2"></span></span></p><p>The sramRatio is the amount the clock is divided by and the amount the wData of the ATP interface is multiplied by. The depth of the sym_fifo_rate_adapter is divided by sramRatio and rounded up. The hDepth is not modified. The sym_fifo_rate_adapter actually instances a version of itself, but in the internal version sramRatio is forced to 1. As indicated, depth is modified, but all other parameters are passed to the internal sym_fifo_adapter unmodified.</p>