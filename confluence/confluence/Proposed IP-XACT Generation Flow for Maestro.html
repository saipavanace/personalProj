<p><style>[data-colorid=hmser0zhp2]{color:#333333} html[data-color-mode=dark] [data-colorid=hmser0zhp2]{color:#cccccc}[data-colorid=ard1mn86j2]{color:#333333} html[data-color-mode=dark] [data-colorid=ard1mn86j2]{color:#cccccc}[data-colorid=i128y1504v]{color:#333333} html[data-color-mode=dark] [data-colorid=i128y1504v]{color:#cccccc}[data-colorid=j8vnd7ffxv]{color:#333333} html[data-color-mode=dark] [data-colorid=j8vnd7ffxv]{color:#cccccc}</style><u><strong>Problems</strong></u></p><p>Multiple flows to generate CSR. This is more work for the software team to maintain multiple flows.&nbsp;</p><ol><li>Ncore team<ul><li>All CSR generation happens before RTL generation using CSR CPR files defined by the HW team. So, software can generate Ncore CSR memory map in IP-XACT before RTL generation.</li></ul></li><li>Symphony team<ul><li>CSR generation can be divided into two parts:<ul><li>CSR CPR files for fixed set of register fields and register field positions.</li><li>CSR generation based on the RTL TACHL code. These registers cannot be easily described in CSR CPR and if described, the JavaScript code gets duplicated in both CSR CPR and TACHL. This is difficult to maintain in the long run.</li></ul></li></ul></li></ol><p><u><strong><br /></strong></u></p><p><u><strong>Requirements</strong></u></p><ol><li>Need to come up with a single flow to generate IP-XACT for Ncore and Symphony.</li><li>Need to generate RAL using IP-XACT CSR Memory Map for Design Verification</li></ol><p>&nbsp;</p><p><u><strong>Proposal</strong></u></p><p>&nbsp;</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16163427/flow.png?api=v2" /></span></p><p>&nbsp;</p><p>The Block Diagram shows the proposed flow for IP-XACT Generation. The explanation is as follows:</p><ol><li>When the <span class="legacy-color-text-blue5"><strong>Maestro Server</strong></span> receives the <strong><span class="legacy-color-text-red1">Intermediate JSON</span></strong> from <strong><span class="legacy-color-text-yellow1">Maestro Client</span></strong>, it:<ol><li>Invokes <span class="legacy-color-text-blue5"><strong>CSR JavaScript Functions</strong></span> (generated by Stitcher from <span class="legacy-color-text-yellow2"><strong>CSR CPR Files</strong></span>) to generate CSRs for the corresponding block (e.g. Ncore Unit, ATU, System, etc.).</li><li>Runs <strong><span class="legacy-color-text-blue5">JavaScript Utility Functions</span></strong> to pass the generated CSR + TACHL Parameters <u>(<strong>Ncore: Mapped from Maestro User parameters in Intermediate JSON</strong></u>,<strong><u> Presto: Same as Maestro User parameters in Intermediate JSON</u></strong>) + other information in Intermediate JSON to generate the <span class="legacy-color-text-red1"><strong>Generic Wrapper JSON</strong></span>.</li></ol></li><li>The <span class="legacy-color-text-red1"><strong>Generic Wrapper</strong></span> + <strong><span class="legacy-color-text-yellow2">HW TACHL Files</span></strong>+ <strong><span class="legacy-color-text-blue5">HW JavaScript Functions</span></strong> are passed to <strong><span class="legacy-color-text-blue5">TACHL</span></strong>.</li><li><strong><span class="legacy-color-text-blue5">TACHL</span> </strong>generates <span data-colorid="i128y1504v"><strong>RTL</strong></span> and the corresponding <strong><span class="legacy-color-text-red1">metadata</span></strong> in JSON format. The <strong><span class="legacy-color-text-red1">metadata</span></strong> contains following:<ol><li><span class="legacy-color-text-red1"><strong>Hierarchy</strong></span> (Filename: hierarchy.json): Provides RTL module hierarchy</li><li><strong><span class="legacy-color-text-red1">Instances</span></strong>&nbsp;(Filename: instanceMap.json): Provides a map of instance : module name</li><li><strong><span class="legacy-color-text-red1">Module Ports</span></strong>&nbsp;(Filename: gen_wrapper.attr): top level Input and output ports present in the module .v file.</li><li><strong><span class="legacy-color-text-red1">CSR</span> </strong>(Filename: &lt;RTL module name&gt;.attr containing CSR information): CSR associated with module .v file</li><li><strong><span class="legacy-color-text-red1">FF count </span></strong><span data-colorid="hmser0zhp2">(Filename: &lt;RTL module name&gt;.attr containing CSR information): The number of dffre instances created in a module .v file</span></li><li><strong><span class="legacy-color-text-red1">attributesMap</span></strong><span class="legacy-color-text-red1">&nbsp;</span>(Filename: attributesMap.json): Provides a map of all .attr files that contains attributes dumped by using TACHL setAttribute API.</li></ol></li><li>Every HW block owner must write out the csr object in the attribute metadata (.attr) file by using the following API provided by TACHL : obj.lib.setAttribute('csr', &lt;csr object&gt;);</li><li>Maestro defines the order in the which the CSRs of top level block instances will generated in the CSRMap. This order is passed within the <strong><span class="legacy-color-text-red1">Intermediate JSON</span></strong> to <span class="legacy-color-text-blue5"><strong>Maestro Server</strong></span>. A CSRMap is generated using the instance names and their order from the <span class="legacy-color-text-red1"><strong>Intermediate JSON</strong></span> and by reading <strong><span class="legacy-color-text-red1">instanceMap JSON</span></strong>, <strong><span class="legacy-color-text-red1">attributesMap JSON</span></strong> and the &lt;RTL module name&gt;.attr files.</li><li>The <strong><span class="legacy-color-text-red1">gen_wrapper.attr + </span></strong><span data-colorid="j8vnd7ffxv">CSRMap</span>&nbsp;is used to generate the <span data-colorid="ard1mn86j2"><strong>Top-level IP-XACT</strong></span> for the system.</li></ol><p>&nbsp;</p><p>&nbsp;</p>