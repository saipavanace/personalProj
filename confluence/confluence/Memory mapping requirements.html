<ul><li>Allow each initiator to have its own view of the memory map</li><li>Allow striping (i.e. address interleaving).  Address interleaving capability – allows users to select the address bits, perform xor, etc. (see Ncore capabilities)</li><li>Allow address holes</li><li>Granularity: smallest address space allowed = data width of the IP, largest = full address width of the IP</li><li>Based on different operating modes (e.g. boot, operational, custom), there can be a different view of address map</li><li>Different virtual networks can have different views of address map (? Check with Syed)</li><li>Allow translation of interconnect address to an IP-visible address (e.g. initiator sends a transaction to address 0x1000.  It reaches a target IP, but in the IP’s point of view, the address it sees is 0x0)<ul><li>This translation should also allow address bit(s) swapping, and bit(s) tie-offs, don’t cares</li></ul></li><li>Based on security level of a transaction, there can be a different view of address map (and also read/write access address mapping should also be independent)</li><li>Have a graphical visualization of the resulting memory map</li><li>Good to have: Pseudo mmu / simple address translation unit – a way to statically (upon reset / during idle) change the address map<ul><li>Cortina access, Seagate, and some others have asked for this; this may also be useful if we allow reuse of subsystem NoCs in derivative chips</li></ul></li></ul>