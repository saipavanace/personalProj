<h1 id="HW-CTFsym_fifo_mem_1p_ctl-module_name"><strong>module_name</strong></h1><p>sym_fifo_mem_1p_ctl</p><h1 id="HW-CTFsym_fifo_mem_1p_ctl-parameters"><strong>parameters</strong></h1><h2 id="HW-CTFsym_fifo_mem_1p_ctl-java_script:"><strong>java_script:</strong></h2><pre class="page view">{
	&quot;width&quot; : any positive integer <br/>        &quot;depth&quot; : any positive integer 4 or greater <br/>        &quot;protectionStyle&quot; : protectionStyle, <br/>        &quot;protectionInterface&quot; : protectionInterface</pre><pre>}</pre><h2 id="HW-CTFsym_fifo_mem_1p_ctl-verilog:"><strong>verilog:</strong></h2><p style="margin-left: 30.0px;">none.</p><h1 id="HW-CTFsym_fifo_mem_1p_ctl-I/O"><strong>I/O</strong></h1><p>u.port('input', 'in_valid', 1);<br/>u.port('output', 'in_ready', 1);<br/>u.port('output', 'out_valid', 1);<br/>u.port('input', 'out_ready', 1);</p><p>// Ports to read buffer<br/>// A rdy_vld_pipe, depth = 2, pF = false, pB = true, exposeValids = true<br/>u.port('input', 'pipe_out_valid', 1);<br/>u.port('output', 'pipe_out_ready', 1);<br/>u.port('output', 'pipe_in_valid', 1);<br/>u.port('input', 'pipe_in_ready', 1);</p><p>// Ports to SRAM<br/>u.port('output', 'sel', 1);<br/>u.port('output', 'addr', addr_width);<br/>u.port('output', 'we', 1);</p><p>// Ports to data max<br/>u.port('output', 'empty', 1); // The SRAM and external pipe is empty.</p><p>u.interface(<a class="external-link" href="http://protectionInterface.name" rel="nofollow">protectionInterface.name</a>, 'master', protectionInterface.signal); </p><h1 id="HW-CTFsym_fifo_mem_1p_ctl-ModulesUsed"><strong>Modules Used</strong></h1><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16163252/prot_reg" data-linked-resource-id="16163252" data-linked-resource-version="4" data-linked-resource-type="page">prot_reg</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16155739/logic_tree" data-linked-resource-id="16155739" data-linked-resource-version="15" data-linked-resource-type="page">logic_tree</a></p><h1 id="HW-CTFsym_fifo_mem_1p_ctl-Description"><strong>Description</strong></h1><p>The block diagram for <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156385/HW-CTF+sym_fifo_mem_1p" data-linked-resource-id="16156385" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF sym_fifo_mem_1p</a>, which this block is used in, is shown below:</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16156364/sym_fifo_mem_1p_ctl.svg?api=v2"></span></p><p>The control logic to turn a single read/write port SRAM into a FIFO using ready and valids. Since a single port can only do a read or write every cycle, A filter is added to the logic of the <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156403/HW-CTF+sym_fifo_mem_2p_ctl" data-linked-resource-id="16156403" data-linked-resource-version="1" data-linked-resource-type="page">sym_mem_2p_ctl</a> that allows only one operation based on what happened on the previous cycle. The filter is if you can do both ops, and the previous transaction was a write, you read, otherwise you write. This means if nothing was done on the previous cycle, the preference is given to write.</p><p>There are the following internal registers:</p><p style="margin-left: 30.0px;">prev_op: 1 = write, 0 = read or nothing.<br/>wt_addr: The write pointer for a circular FIFO<br/>rd_addr: The read pointed for a circular FIFO<br/>wrap: When asserted and wt_addr = rd_addr indicates FIFO is full. When deserted and wt_addr = rd_addr FIFO is empty.<br/>rd_sel_p: Indicates a read was issued on the previous cycle</p><p>These registers are actually store in one register in the following order: </p><p style="margin-left: 30.0px;">{prev_op,wrap,rd_sel_p,wt_addr,rd_addr} </p><p>This is done so the protection can be automatically generated using the prot_reg in the most efficient manner possible.</p><p>Internally there are the following wires:</p><p style="margin-left: 30.0px;">wire int_empty;<br/>wire equal;<br/>wire next_equal;<br/>wire full;<br/>wire wrap;<br/>wire next_wrap;<br/>wire rd_sel;<br/>wire wt_sel;<br/>wire [\=addr_width-1=\:0] wt_addr;<br/>wire [\=addr_width-1=\:0] next_wt_addr;<br/>wire [\=addr_width-1=\:0] rd_addr;<br/>wire [\=addr_width-1=\:0] next_rd_addr;<br/>wire rd_sel_p;<br/>wire prev_op;<br/>wire next_prev_op;<br/>wire [\=state_width-1=\:0] state;<br/>wire [\=state_width-1=\:0] next_state;</p><p>The loading and unloading of the single register:</p><p style="margin-left: 30.0px;">assign next_state[\=state_width-1=\] = next_prev_op;<br/>assign next_state[\=state_width-2=\] = next_wrap;<br/>assign next_state[\=state_width-3=\] = rd_sel;<br/>assign next_state[\=2*addr_width-1=\:\=addr_width=\] = next_wt_addr;<br/>assign next_state[\=addr_width-1=\:0] = next_rd_addr;</p><p style="margin-left: 30.0px;">assign prev_op = state[\=state_width-1=\];<br/>assign wrap = state[\=state_width-2=\];<br/>assign rd_sel_p = state[\=state_width-3=\];<br/>assign wt_addr = state[\=2*addr_width-1=\:\=addr_width=\];<br/>assign rd_addr = state[\=addr_width-1=\:0];</p><p>The logic_tree block is used twice to calculate equal and next_equal. The two pointers are exclusive NORed, the resulting bits are ORed using the logic_tree module, and the output for the OR tree is whether the two pointers are equal or not.</p><p>Here are the logic equations with descriptions of what they are doing. It shows both the original equation from <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156403/HW-CTF+sym_fifo_mem_2p_ctl" data-linked-resource-id="16156403" data-linked-resource-version="1" data-linked-resource-type="page">sym_mem_2p_ctl</a> and the modified one.</p><p><strong>New Equations:</strong></p><p style="margin-left: 30.0px;">assign addr = we ? wt_addr : rd_addr;</p><p>Depending on what the operation is, the address changes.</p><p style="margin-left: 30.0px;">assign we   = wt_sel;</p><p>we to the SRAM is just wt_sel;</p><p style="margin-left: 30.0px;">assign next_prev_op   = sel &amp; we;</p><p>Was a write performed on the previous cycle.</p><p><strong>Equations that didn't change (see <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156403/HW-CTF+sym_fifo_mem_2p_ctl" data-linked-resource-id="16156403" data-linked-resource-version="1" data-linked-resource-type="page">sym_mem_2p_ctl</a> for descriptions):</strong></p><p style="margin-left: 30.0px;">assign full = equal &amp; wrap;</p><p style="margin-left: 30.0px;">assign empty = equal &amp; ~wrap &amp; ~pipe_out_valid;</p><p style="margin-left: 30.0px;">assign int_empty = equal &amp; ~wrap;</p><p style="margin-left: 30.0px;">assign out_valid = pipe_out_valid | empty &amp; in_valid;</p><p style="margin-left: 30.0px;">assign pipe_out_ready = ~empty &amp; out_ready;</p><p style="margin-left: 30.0px;">assign pipe_in_valid = rd_sel_p;</p><p style="margin-left: 30.0px;">assign rd_sel = ~int_empty &amp; (~pipe_in_valid &amp; pipe_in_ready | ~pipe_in_valid &amp; out_ready | pipe_in_valid &amp; out_ready);</p><p style="margin-left: 30.0px;">assign next_wt_addr = wt_sel ? ((wt_addr == \=addr_width=\'d\=depth-1=\) ? \=addr_width=\'b0 : wt_addr + 1'b1) : wt_addr;</p><p style="margin-left: 30.0px;">assign next_rd_addr = rd_sel ? ((rd_addr == \=addr_width=\'d\=depth-1=\) ? \=addr_width=\'b0 : rd_addr + 1'b1) : rd_addr;</p><p style="margin-left: 30.0px;">assign next_wrap = (~wrap &amp; wt_sel &amp; ~rd_sel &amp; next_equal) | (wrap &amp; (~rd_sel | (wt_sel &amp; rd_sel)));</p><p><strong>Equations that changed:</strong></p><p style="margin-left: 30.0px;">assign wt_sel = in_valid &amp; ((~empty &amp; ~full) | (~full &amp; ~out_ready));</p><p style="margin-left: 30.0px;">changed to:</p><p style="margin-left: 30.0px;">assign wt_sel = in_valid &amp; (int_empty | ~in_pipe_ready | ~(~int_empty &amp; prev_op)) &amp; ((~empty &amp; ~full) | (~full &amp; ~out_ready));</p><p>The SRAM FIFO is written if there's an input coming in and the block is not empty (not int_empty) and not full or the block is not full and output doesn't have a ready. I don't want to write the SRAM if the SRAM FIFO is empty, the external pipe is empty and the output is ready. In that case, the data is routed around the internal storage and straight to the output. This is what makes the block pipeForward equals false.</p><p>The filter is (int_empty | ~in_pipe_ready | ~(~int_empty &amp; prev_op)). Since the external pipe can read and write in a single cycle, if we are doing a write into the SRAM, you can still read the contents of the external pipe, so you can't just look at the total empty status to determine if you can do a write or not. In this case you can always write if the SRAM is empty (int_empty, because you won't do a read of an empty FIFO), if the prev_op wasn't a write and you are not empty or you can write if the external pipe is full (in_pipe_ready = 0).</p><p style="margin-left: 30.0px;">assign in_ready = ~full;</p><p style="margin-left: 30.0px;">changed to:</p><p style="margin-left: 30.0px;">assign in_ready = ~full &amp; (int_empty | ~in_pipe_ready | ~(~int_empty &amp; prev_op));</p><p>The block can't accept data if the SRAM FIFO is full. This is what makes the block pipeBackward equals true. The reason for doing this is most SRAMs can't read and write the same word in the same cycle, so the logic prevents that from happening.</p><p>The filter is (int_empty | ~in_pipe_ready | ~(~int_empty &amp; prev_op)) which is the same as above, because ready is the ability the write.</p><p style="margin-left: 30.0px;"><br/></p>