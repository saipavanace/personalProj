<p>DUT for the <em>top_axi_axi_pmon</em> configuration:</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="https://confluence.arteris.com/download/attachments/13437445/image2019-11-14%2015%3A55%3A33.png?version=1&amp;modificationDate=1573768533208&amp;api=v2" data-image-src="https://confluence.arteris.com/download/attachments/13437445/image2019-11-14%2015%3A55%3A33.png?version=1&amp;modificationDate=1573768533208&amp;api=v2" loading="lazy"></span></p><p> </p><p>RTL confluence page:</p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16171321/1x1+topology+with+PMON" data-linked-resource-id="16171321" data-linked-resource-version="18" data-linked-resource-type="page">1x1 topology with PMON</a></p><p> </p><p>TOP_RAND_VSEQ:</p><ul><li>Program stats and prob registers (In later configurations we need to move this inside AXI sequences).</li><li>Create and start AXI sequences.</li><li>Check if stats and prob registers are collecting data as programmed.</li></ul><p>TOP_RAND_TEST:</p><ul><li>Run bit bash test.</li></ul><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th class="confluenceTh"> </th><th class="confluenceTh">Feature</th><th class="confluenceTh">Programming</th><th class="confluenceTh">Stimulus</th><th class="confluenceTh">Reporting/Checking</th><th class="confluenceTh">status</th><th colspan="1" class="confluenceTh">Notes</th></tr><tr><td class="confluenceTd">1</td><td class="confluenceTd">reg_bit_bash</td><td class="confluenceTd">none</td><td class="confluenceTd">uvm_reg_bit_bash_seq</td><td class="confluenceTd">Automatic</td><td class="confluenceTd">done</td><td colspan="1" class="confluenceTd">Bit bash checks for reset value of write on clear registers hence we won't know if those registers were actually written using bit bash test.</td></tr><tr><td class="confluenceTd">2</td><td class="confluenceTd">packet count</td><td class="confluenceTd"><p>    Probe req:</p><p>      PMON_PROBE_COND_req_id_match_0.sel = 1</p><p>      PMON_PROBE_USER_0 = aw_id/ar_id = msg_id</p><p>      PMON_PROBE_USER_2 = msg_type_id = 0/1 (write/read)</p><p> </p><p>      PMON_PROBE_COND_req_id_match_0.sel = 0</p><p>      PMON_PROBE_USER_1 = aw_id/ar_id = msg_id</p><p>      PMON_PROBE_USER_3 = msg_type_id = 0/1 (write/read)</p><p> </p><p>    PMON stats:</p><p>      PKT_CTR_en_mode</p><p>        en = 1 (to enable individual counter)</p><p>        ct = 0 (0 = counter, 1 = timer)</p><p>        inc_mode = 2 (Wrap (0), Freeze(1), Run(2))</p><p>      GLBL_EN = 1</p><p>      GLBL_MASK = 8’hff</p><p> </p><p>Note: inc_mode must be 2 for packet count</p></td><td class="confluenceTd">AXI4-AXI4 stimulus</td><td class="confluenceTd">Compare the no. of packets observed in scoreboard to values stored in the stats register.</td><td class="confluenceTd">done</td><td colspan="1" class="confluenceTd"> </td></tr><tr><td class="confluenceTd">3</td><td class="confluenceTd">Latency binning</td><td class="confluenceTd"><p>Pmon stats:</p><p>PMON_STATS_USER_0</p><p>bin0_ul = Upper limit of bin0</p><p>PMON_STATS_USER_1</p><p>bin1_ul = Upper limit of bin1</p><p> </p><p>LAT_TMR0_en_mode</p><p>en = 1 (to enable individual counter)</p><p>ct = 1 (0 = counter, 1 = timer)</p><p>inc_mode = 2 <span>(Wrap (0), Freeze(1), Run(2))</span></p><p>LAT_TMR1_en_mode</p><p>en = 1 (to enable individual counter)</p><p>ct = 1 (0 = counter, 1 = timer)</p><p>inc_mode = 2 (Wrap (0), Freeze(1), Run(2))</p><p>LAT_TMR2_en_mode</p><p>en = 1 (to enable individual counter)</p><p>ct = 1 (0 = counter, 1 = timer)</p><p>inc_mode = 2 (Wrap (0), Freeze(1), Run(2))</p><p>LAT_TMR3_en_mode</p><p>en = 1 (to enable individual counter)</p><p>ct = 1 (0 = counter, 1 = timer)</p><p>inc_mode = 2 (Wrap (0), Freeze(1), Run(2))</p><p> </p><p>Bin0_en_mode</p><p>en = 1</p><p>inc_mode = 2 <span>(Wrap (0), Freeze(1), Run(2))</span></p><p>Bin1_en_mode</p><p>en = 1</p><p>inc_mode = 2 (Wrap (0), Freeze(1), Run(2))</p><p>Bin2_en_mode</p><p>en = 1</p><p>inc_mode = 2 (Wrap (0), Freeze(1), Run(2))</p><p> </p><p>Pmon stats interrupt 0</p><p>INTMR.mask = 1</p><p> </p><p>GLBL_EN = 1</p><p>GLBL_MASK = 8'hff</p></td><td class="confluenceTd"><span>AXI4-AXI4 stimulus</span></td><td class="confluenceTd">Report values in each latency bin.</td><td class="confluenceTd">done</td><td colspan="1" class="confluenceTd"> </td></tr><tr><td colspan="1" class="confluenceTd">4</td><td colspan="1" class="confluenceTd">bandwidth utilization</td><td colspan="1" class="confluenceTd"><p>Pmon stats</p><p>BW_en_mode</p><p>en = 1</p><p>inc_mode = 2 (Wrap (0), Freeze (1), Run (2))</p><p> </p><p>BW_REF_limit</p><p>limit = 100 (Limit of cycle count, stop counting after these number of cycles)</p><p> </p><p>BW_REF_en_mode</p><p>en = 1</p><p>inc_mode = 1 (Wrap (0), Freeze (1), Run (2))</p><p>ct = 1 ( 0 = counter, 1 = timer)</p><p> </p><p>GLBL_EN = 1</p><p>GLBL_MASK = 8'hff</p><p> </p><p>PMON_STATS_USER_2 = 1</p></td><td colspan="1" class="confluenceTd"><span>AXI4-AXI4 stimulus</span></td><td colspan="1" class="confluenceTd"><span>Report no. of beats, no. of cycles, no. of bytes and bandwidth = no. of beats/no. of cycles values measured.</span></td><td colspan="1" class="confluenceTd">done</td><td colspan="1" class="confluenceTd"><p>Measurement needs to be done on both request and response path for Initiator and target (4 measurements over all)</p><p>But for 1x1 configuration since we have only 1 stats, 1 request and 1 response blocks we will make 1 measurement in the request path and at the source.</p></td></tr></tbody></table></div>