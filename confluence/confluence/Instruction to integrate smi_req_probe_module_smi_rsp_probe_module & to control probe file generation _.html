<h2 id="Instructiontointegratesmi_req_probe_module/smi_rsp_probe_module&amp;tocontrolprobefilegeneration:-1)Pathofsmi_probe_moduledefintionfile:"><style>[data-colorid=ww8l0ox7jj]{color:#009100} html[data-color-mode=dark] [data-colorid=ww8l0ox7jj]{color:#6eff6e}[data-colorid=hu5vba0s0j]{color:#009100} html[data-color-mode=dark] [data-colorid=hu5vba0s0j]{color:#6eff6e}[data-colorid=wkxcv18juy]{color:#009100} html[data-color-mode=dark] [data-colorid=wkxcv18juy]{color:#6eff6e}[data-colorid=orqysoxqmo]{color:#009100} html[data-color-mode=dark] [data-colorid=orqysoxqmo]{color:#6eff6e}[data-colorid=axuuevmkdb]{color:#009100} html[data-color-mode=dark] [data-colorid=axuuevmkdb]{color:#6eff6e}[data-colorid=frkne7zf2e]{color:#009100} html[data-color-mode=dark] [data-colorid=frkne7zf2e]{color:#6eff6e}</style>1)&nbsp;<strong>Path of smi_probe_module defintion file :</strong>&nbsp;</h2><p style="">Module definition in this path - hw-dv/vip/smi/lib/smi_probe_module.sv.tachl&nbsp;(
    

            

    <span class="aui-message aui-message-warning jim-error-message jim-error-message-single">
        <span class="icon-in-pdf" />
                            Unable to locate Jira server for this macro. It may be due to Application Link configuration.
            </span>
)</p><p style=""><strong>module smi_&lt;req_or_rsp&gt;_probe_module&lt;nodeId&gt;</strong></p><p style="">(input logic clk,<strong><br /></strong>input logic reset_n,<br />smi_&lt;req_or_rsp&gt;intf_&lt;nodeId&gt; smi_if_&lt;nodeId&gt;);</p><p style=""><span>where,&nbsp;</span></p><p style=""><span>nodeId = from tb.json</span></p><p style=""><span>req_or_rsp = valid values are &quot;req_&quot; , &quot;rsp_&quot;</span></p><p style="">We have to generate two <strong>smi</strong> package <strong>per node.</strong> Hence there are two packages as shown below</p><p style=""><strong>smi_req_pkg_&lt;nodeId&gt; : </strong>Corresponding to req path</p><p style=""><strong>smi_rsp_pkg_&lt;nodeId&gt; : </strong>Corresponding to resp path</p><h2 style="" id="Instructiontointegratesmi_req_probe_module/smi_rsp_probe_module&amp;tocontrolprobefilegeneration:-2)Integratemodules-smi_req_probe_module&amp;smi_rsp_probe_moduleinTB,"><strong>2) Integrate modules - smi_req_probe_module &amp;&nbsp;</strong><strong>smi_rsp_probe_module&nbsp;</strong><strong>in TB,</strong></h2><p style="">Include smi_req_probe_module and&nbsp;smi_req_intf in package - smi_req<strong>_pkg</strong>&nbsp;(imported in tb_top) to make it available to testbench top module -&nbsp;<strong>tb_top (from tb_wrapper.tachl)</strong></p><p style="">Include smi_rsp_probe_module and&nbsp;smi_rsp_intf in package - smi_rsp<strong>_pkg</strong>&nbsp;(imported in tb_top) to make it available to testbench top module -&nbsp;<strong>tb_top (from tb_wrapper.tachl)</strong></p><p style="">Since smi interface is internal interface, bit <strong>smi_passive_agent</strong> needs to be set to 1 from top_tb_package <strong>(hw-sym/dv/tb/top/<a class="external-link" href="http://top_tb_pkg.sv" rel="nofollow">top_tb_pkg.sv</a>.tachl) </strong>which will take care of everything else. FYI, top_tb_pkg is top level package instantiated in top level Test bench. Each vip package is imported in top_tb_pkg.</p><p style=""><strong>package top_tb_pkg;</strong></p><p style="">obj.lib.instance({ moduleName : nodeId+'<a rel="nofollow">_smi_req_pkg.sv</a>',tachlName : '<a class="external-link" href="http://smi_req_pkg.sv" rel="nofollow">smi_req_pkg.sv</a>',params:{ &quot;checker&quot;:checker, &quot;params&quot;: axi4Params[nodeId], &quot;smi_passive_agent&quot;:1, &quot;smi_req_if&quot;:1}, script:true })<br />obj.lib.instance({ moduleName : nodeId+'<a rel="nofollow">_smi_rsp_pkg.sv</a>',tachlName : '<a class="external-link" href="http://smi_rsp_pkg.sv" rel="nofollow">smi_rsp_pkg.sv</a>',params:{ &quot;checker&quot;:checker, &quot;params&quot;: axi4Params[nodeId], &quot;smi_passive_agent&quot;:1, &quot;smi_rsp_if&quot; :1}, script:true })</p><p style=""><strong>endpackage: top_tb_pkg;</strong></p><p style=""><br /></p><p style=""><strong>package smi_req_pkg_&lt;%=obj.lib.getParam('BlockId')%&gt;;</strong></p><p style="">obj.lib.instance({ moduleName : 'smi_req_probe_module_'+id+'.sv',tachlName : '<a class="external-link" href="http://smi_probe_module.sv" rel="nofollow">smi_probe_module.sv</a>',params:{ &quot;params&quot; : cparams, &quot;<strong>smi_passive_agent</strong>&quot;:1 , &quot;checker&quot;:checker, &quot;smi_req_if&quot;:1}, script:true });</p><p style="">`include &quot;smi_req_probe_module_&lt;%=BlockId%&gt;.sv&quot;</p><p style=""><strong>endpackage : smi_req_pkg_&lt;%=obj.lib.getParam('BlockId')%&gt;</strong></p><p style=""><br /></p><p style=""><strong>package smi_rsp_pkg_&lt;%=obj.lib.getParam('BlockId')%&gt;;</strong></p><p style="">obj.lib.instance({ moduleName : 'smi_rsp_probe_module_'+id+'.sv',tachlName : '<a class="external-link" href="http://smi_probe_module.sv" rel="nofollow">smi_probe_module.sv</a>',params:{ &quot;params&quot; : cparams, &quot;<strong>smi_passive_agent</strong>&quot;:1 , &quot;checker&quot;:checker, &quot;smi_rsp_if&quot;:1}, script:true });</p><p style="">`include &quot;smi_rso_probe_module_&lt;%=BlockId%&gt;.sv&quot;</p><p style=""><strong>endpackage : smi_rsp_pkg_&lt;%=obj.lib.getParam('BlockId')%&gt;</strong></p><p style=""><br /></p><p style=""><span>Take instances of <strong>smi_req</strong></span><strong>_probe_module,&nbsp;</strong><strong><span>smi_rsp</span>_probe_module and corresponding interfaces&nbsp;</strong><span>in&nbsp;</span><strong>tb_top</strong><span>&nbsp;(from&nbsp;</span><strong>tb_wrapper</strong><span>) to probe initiator and target interfaces. Partial code from tb_wrapper.tachl is shown below.</span></p><p style="">// All initiator nodes,</p><p style="">// where smi_req_intf signals are tied to ATUI smi packetizer signals</p><p style="">// where smi_rsp_intf signals are tied to ATUI smi depacketizer signals</p><p style=""><span>for(var i=0; i&lt;nAxi4Masters; i++) {</span></p><p style=""><span>inst = axi4MasterAgents[i];<br /></span></p><p style="">smi_req_intf_\=inst=\ smi_in_req_if_\=inst=\();<br />smi_rsp_intf_\=inst=\ smi_in_rsp_if_\=inst=\();<br />smi_req_probe_module_\=inst=\ smi_req_probe_module_\=inst=\(smi_in_req_if_\=inst=\.clk, smi_in_req_if_\=inst=\.reset_n, smi_in_req_if_\=inst=\);<br />smi_rsp_probe_module_\=inst=\ smi_rsp_probe_module_\=inst=\(smi_in_rsp_if_\=inst=\.clk, smi_in_rsp_if_\=inst=\.reset_n, smi_in_rsp_if_\=inst=\);</p><p style=""><span>}</span></p><p style=""><span>// All target nodes</span></p><p style="">// where smi_req_intf signals are tied to ATUT smi depacketizer signals</p><p style="">// where smi_rsp_intf signals are tied to ATUT smi packetizer signals</p><p style=""><span>for(var i=0; i&lt;nAxi4Slaves; i++) {</span></p><p style=""><span>inst = axi4SlaveAgents[i];<br /></span></p><p style="">smi_req_intf_\=inst=\ smi_in_req_if_\=inst=\();<br />smi_rsp_intf_\=inst=\ smi_in_rsp_if_\=inst=\();<br />smi_req_probe_module_\=inst=\ smi_req_probe_module_\=inst=\(smi_in_req_if_\=inst=\.clk, smi_in_req_if_\=inst=\.reset_n, smi_in_req_if_\=inst=\);<br />smi_rsp_probe_module_\=inst=\ smi_rsp_probe_module_\=inst=\(smi_in_rsp_if_\=inst=\.clk, smi_in_rsp_if_\=inst=\.reset_n, smi_in_rsp_if_\=inst=\);</p><p style=""><span>}</span></p><p style=""><span>3)&nbsp;<strong style="">Generation of&nbsp;probe files&nbsp;- smi_&lt;&quot;req&quot; or &quot;rsp&quot;&gt;_probe_&lt;nodeId&gt;.txt</strong></span></p><ul style="" class="alternate"><li><strong>Compiler directive</strong><span>&nbsp;</span>:<ul><li><strong>+define+SMI_REQ_PROBE_ON</strong><span>&nbsp;</span>: +define+SMI_REQ_PROBE_ON (for all initiator and target interfaces) can enable logic inside all smi_req_probe_module that generates probe file.</li><li><strong>+define+SMI_REQ_PROBE_ON_&lt;nodeId&gt;</strong> : If user doesn't need all initiator and target interfaces probe file, then user can have choice to do the same using this compiler directive.</li><li><strong>+define+SMI_RESP_PROBE_ON</strong><span>&nbsp;</span>: +define+SMI_RESP_PROBE_ON (for all initiator and target interfaces) can enable logic inside all smi_resp_probe_module that generates probe file.</li><li><strong>+define+SMI_RESP_PROBE_ON_&lt;nodeId&gt;</strong> : If user doesn't need all initiator and target interfaces probe file, then user can have choice to do the same using this compiler directive.</li></ul></li></ul><p style="">Some of the examples,<br /><br /></p><p style=""><strong>Command-line :</strong></p><pre class="code-java">runsim -c maestro_4x4_AXI4_256_128_256_64_32_AXI4_32_256_64_32_32_hp -t axi4_single_beat_wr -s 0 -w -co <span data-colorid="hu5vba0s0j" class="code-quote">&quot;+define+SMI_REQ_PROBE_ON_0 +define+SMI_REQ_PROBE_ON_2 +define+SMI_RESP_PROBE_ON_1 SMI_RESP_PROBE_ON_3&quot;</span>
</pre><pre class="code-java">Now, above command generates four probe files.<br />smi_req_probe_0.txt (Enabled by <span data-colorid="orqysoxqmo" class="code-quote">+define+SMI_REQ_PROBE_ON_0</span>)<br />smi_req_probe_2.txt (Enabled by <span data-colorid="axuuevmkdb" class="code-quote">+define+SMI_REQ_PROBE_ON_2</span>)<br />smi_resp_probe_1.txt (Enabled by <span data-colorid="ww8l0ox7jj" class="code-quote">+define+SMI_RESP_PROBE_ON_1</span>)<br />smi_resp_probe_3.txt (Enabled by <span data-colorid="frkne7zf2e" class="code-quote">+define+SMI_RESP_PROBE_ON_3</span>)
</pre><p style=""><strong>Command-line :</strong></p><pre class="code-java">runsim -c maestro_4x4_AXI4_256_128_256_64_32_AXI4_32_256_64_32_32_hp -t axi4_single_beat_wr -s 0 -w -co <span data-colorid="wkxcv18juy" class="code-quote">&quot;+define+SMI_REQ_PROBE_ON +define+SMI_RSP_PROBE_ON&quot;</span>
</pre><p style="">this command would generate smi probe files for all initiator and target nodes</p><pre class="code-java">smi_req_probe_0.txt<br />smi_req_probe_1.txt<br />smi_req_probe_2.txt<br />smi_req_probe_3.txt<br />smi_req_probe_4.txt<br />smi_req_probe_5.txt<br />smi_req_probe_6.txt<br />smi_req_probe_7.txt<br />smi_rsp_probe_0.txt<br />smi_rsp_probe_1.txt<br />smi_rsp_probe_2.txt<br />smi_rsp_probe_3.txt<br />smi_rsp_probe_4.txt<br />smi_rsp_probe_5.txt<br />smi_rsp_probe_6.txt<br />smi_rsp_probe_7.txt</pre>