<h1 id="HW-CTFsym_vc_multicast-module_name">module_name</h1><p>sym_vc_multicast</p><h1 id="HW-CTFsym_vc_multicast-parameters">parameters</h1><pre><span>{</span></pre><pre><span> interfaces:{</span></pre><pre>  clkInterface: {name: &quot;a_string&quot;, params: {}, direction: &quot;slave&quot;, interface: &quot;InterfaceCLK&quot;},</pre><pre>  intInterface: {name: &quot;a_string&quot;, params: {}, direction: &quot;master&quot;, interface: &quot;InterfaceINT&quot;},</pre><pre>  cfgInterface: {name: &quot;a_string&quot;, params: {}, direction: &quot;slave&quot;, interface: &quot;InterfaceAPB&quot;}, // Optional based on register definition</pre><pre>  protectionInterface: {name: &quot;a_string&quot;, params: {}, direction: &quot;master&quot;, interface: &quot;InterfacePROT&quot;}, // Optional based on protectionStyle</pre><pre>  inReqInterface:</pre><pre>    {name: &quot;a_string&quot;,</pre><pre>     params: {nVc: positive integer, wBus: positive integer, wProt: non negative integer},</pre><pre>     direction: &quot;slave&quot;, </pre><pre>     interface: &quot;InterfaceATP&quot;, </pre><pre>     pktDef: {params: {ATP Packet Params}, packet: &quot;a_string&quot;}},</pre><pre>  inRspInterfaces:</pre><pre>    {name: &quot;a_string&quot;,</pre><pre>     params: {nVc: positive integer, wBus: positive integer, wProt: non negative integer},</pre><pre>     direction: &quot;master&quot;, </pre><pre>     interface: &quot;InterfaceATP&quot;, </pre><pre>     pktDef: {params: {ATP Packet Params}, packet: &quot;a_string&quot;}},</pre><pre>  outReqInterfaces: [</pre><pre>    {name: &quot;a_string&quot;,</pre><pre>     params: {nVc: positive integer, wBus: positive integer, wProt: non negative integer},</pre><pre>     direction: &quot;master&quot;,</pre><pre>     interface: &quot;InterfaceATP&quot;,</pre><pre>     pktDef: {params: {ATP Packet Params}, packet: &quot;a_string&quot;}},</pre><pre>    {},{}] //</pre><pre>  outRspInterface:[</pre><pre>    {name: &quot;a_string&quot;,</pre><pre>     params: {nVc: positive integer, wBus: positive integer, wProt: non negative integer},</pre><pre>     direction: &quot;slave&quot;,</pre><pre>     interface: &quot;InterfaceATP&quot;,</pre><pre>     pktDef: {params: {ATP Packet Params}, packet: &quot;a_string&quot;}},</pre><pre>    {},{}], //array depth must match outReqInterfaces array depth</pre><pre>  }, </pre><pre>  id : integer, // ID of this block; the value can be read out by software via a CSR register. </pre><pre>  numLabels: integer, // 1 or greater</pre><pre>  noRegs: boolean, // false is default. When true indicates registers do not exist and values into logic are hardcoded. </pre><pre>                   // noRegs does not affect the registers associated with interrupts</pre><pre>  enBufWrite: boolean, //default value is false. When true, it enables early response for buffered writes.<br/>  labelProps: [ </pre><pre>    {labels: [strings,,]}, // depth = numLabels, value is default label in verilog constant form. </pre><pre>    {},{},{}], // depth array = number VCs.</pre><pre>  maskField: &quot;a_string&quot; // name and bits of mask field in ATP packet definition </pre><pre>  arbType: </pre><pre>    {master: &quot;a_string&quot;, // master arbType for all internal switches</pre><pre>     vc: &quot;a_string&quot;},    // Used by arbiters between labels. </pre><pre>  weights: </pre><pre>    {master: [0,1,...], // depth equals number of VCs </pre><pre>     vc: [0,1,...]},    // depth is the number labels.</pre><pre>  lckStyleValid: boolean, </pre><pre>  mstrArbLock: boolean, </pre><pre>  masterArbRdyAware: boolean,</pre><pre>  pktSize: int, // size of multicast packet, in beats, to be buffered in block. Does not have to be entire packet. </pre><pre>  numOutStanding : positive integer // Number of outstanding transactions </pre><pre>  mask2TrgGrp: [string,string,...], // Which mask bits are group to witch targets.</pre><pre>  trgPathLut: [{targ_id: int, route: string}, . . . ],</pre><pre>  srcPathLut: [{targ_id: int, route: string}, . . . ], // The targ_id is the source id in the request packet.  </pre><pre>  protectionStyle: {protectionStyle)</pre><pre>}</pre><h1 id="HW-CTFsym_vc_multicast-Description">Description</h1><p>The block puts down a <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156510/HW-CTF+sym_multicast" data-linked-resource-id="16156510" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF sym_multicast</a> block per VC, using a <a class="external-link" href="https://confluence.arteris.com/display/ENGR/sym_vc_demux" rel="nofollow">sym_vc_demux</a> for the inReqInterface, a <a class="external-link" href="https://confluence.arteris.com/display/ENGR/sym_vc_mux" rel="nofollow">sym_vc_mux</a> for the inRspInterface, a <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156677/HW-CTF+sym_vc_mux" data-linked-resource-id="16156677" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF sym_vc_mux</a> for each outReqInterface, a <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156548/HW-CTF+sym_vc_demux" data-linked-resource-id="16156548" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF sym_vc_demux</a> for each outRspInterface. For a description of what the parameters do, refer to <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156510/HW-CTF+sym_multicast" data-linked-resource-id="16156510" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF sym_multicast</a>.</p><p>This block also puts down an <a class="external-link" href="https://confluence.arteris.com/display/ENGR/interrupt" rel="nofollow">interrupt</a> accumulator module to accumulate each interrupt from the <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156510/HW-CTF+sym_multicast" data-linked-resource-id="16156510" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF sym_multicast</a> per VC into one output interrupt. </p><p>This block also puts down an <a class="external-link" href="https://confluence.arteris.com/display/ENGR/apb_demux" rel="nofollow">apb_demux</a> to drive the APB interface of the <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156510/HW-CTF+sym_multicast" data-linked-resource-id="16156510" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF sym_multicast</a> per VC and the <a class="external-link" href="https://confluence.arteris.com/display/ENGR/interrupt" rel="nofollow">interrupt</a> accumulator module, by forwarding the incoming APB transaction based on the APB address decode.</p><p><span>This block writes out a <strong>csr</strong> object that has an array of spaceBlock entries, each entry is a complete description for a set of registers per device, accessible via the device's APB interface. Each spaceBlock entry (i.e. each device) takes 256 bytes out of 4 K bytes of address space that's assigned to this block. As a result, this block supports maximum nVC = (4K / 256) - 1 = 15</span></p><p><span> For nVC = 2:</span></p><p><span>  csr.spaceBlock</span><span class="error">[0] is for sym_multicast@VC=0</span></p><p><span class="error"> </span><span>  csr.spaceBlock</span><span class="error">[1] is for sym_multicast@VC=1</span></p><p><span class="error"> </span><span>  csr.spaceBlock</span><span class="error">[2] is for interrupt accumulator</span><span>.</span></p><p><span><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="400" src="https://arterisip.atlassian.net/wiki/download/attachments/16157980/sym_vc_multicast.JPG?api=v2"></span><br/></span></p><p><span><br/></span></p>