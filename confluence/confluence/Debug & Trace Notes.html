<p><a class="external-link" href="https://confluence.arteris.com/pages/viewpage.action?pageId=30509843&amp;src=mail&amp;src.mail.product=confluence-server&amp;src.mail.timestamp=1624494603060&amp;src.mail.notification=com.atlassian.confluence.plugins.confluence-notifications-batch-plugin%3Abatching-notification&amp;src.mail.recipient=40288a3163e37344016872d312e10013&amp;src.mail.action=view" rel="nofollow">Ncore Trace &amp; Debug Verification questions and answers</a></p><p><br/></p><p><br/></p><ol><li>Based on the parameter nTraceRegisters, which register can have multiple instances, or which will always have just one (From DV to design engineer)? TBALR, TBAHR, TOPCR, TUBR, TUMBR, and also <strong>TCTRLR</strong> registers - each of these will have as many instances as specified by the parameter <em>nTraceRegisters</em>.</li><li>Should “size of IG(interleaved group)” come from a register the same way it is specified when using GPRAR registers to specify boot or general purpose regions ? If not what should the size of IG be (design engineer to architect) ? This doesn’t have anything to do with ncore3 address map. Spec will be updated to remove size of IG and we will always assume it to be 1.</li><li>If master-initiated trace or native trace is enabled in the register, should ncore initiated trace options be completely ignored for setting the TraceMe bit (CONC-7844, designer to architect) ? No. Trace trigger block should still look at possible matches based on ncore-initiated trace options to set the TraceMe bit.</li><li>When there are no user bits, but “user_match_en” field is set, should the TraceMe bit be set (CONC-7956, DV to architect) ? Updated the description of the ‘user_match_en’ field saying that it will be reserved when there are no user-bits used.</li></ol><p><br/></p><p><br/></p><p>We went over the Trace &amp; Debug bringup schedule. We did not have time to go over post-bringup Trace &amp; Debug tasks.</p><p><br/></p><p>There was a concern that <strong>data network routing</strong> might not immediately work and that a Maestro change may be needed.</p><p>The recommendation was to try using the data network as soon as the Trace Capture unit can output trace, whether it is correct trace or not.</p><p><br/></p><p>Khaleel mentioned that we cannot actually “bypass” the <strong>Trace Trigger</strong> unit.</p><p>We are counting on the default state of the Trace Trigger unit not interfering with Trace Capture, and will have to resolve any issues that come up.</p><p><br/></p><p>Right now, much of the DV testing starts within a day or two after the July 12 and July 16 integration dates. If RTL delivers early RTL that is ready for testing some features, I mentioned that DV could begin testing early in parallel with some of the test plan development.</p><p><br/></p><p>There was talk about the idea of RTL doing some of the bringup testing. While this would be appreciated by DV and could accelerate the DV schedule, this is not currently part of the RTL plan.</p><p><br/></p><p>It was suggested that DV run a <strong>ralgen</strong> test on the Trace &amp; Debug registers.</p><p><br/></p><p>Chien asked whether Trace &amp; Debug work will occur on <strong>main or a branch</strong>. I don’t know. Chien said main is ok. Khaleel said we don’t need to branch after RC8.</p><p><br/></p><p>It was asked if someone can help out Boon with <strong>CHI Trace &amp; Debug integration</strong>.</p><p><br/></p><p>RTL mentioned that if we needed their help after July 16, we should let them know. I’m sure we will ask, but the specifics are TBD.</p><p><br/></p><p>There was a discussion of <strong>FSYS vs block testing</strong>.</p><p>I mentioned that for the August release, we plan on doing all our testing at FSYS, and not the 8 block environments. After the August release we may do block testing.</p><p>It would be easier to hit coverage will block testing, especially, DMI, DII and DVE/Trace Accumulator.</p><p><br/></p><p>Thanks for the participation today. Feel free to respond to add anything I missed or correct any of the notes.</p><p><br/></p><p>----------------------</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/><col/></colgroup><tbody><tr><td colspan="4" class="confluenceTd"><p><strong>Trace Capture checking limitations</strong></p></td><td class="confluenceTd"><p><br/></p></td></tr><tr><td class="confluenceTd"><br/></td><td class="confluenceTd"><br/></td><td class="confluenceTd"><br/></td><td class="confluenceTd"><br/></td><td class="confluenceTd"><p><br/></p></td></tr><tr><td colspan="4" class="confluenceTd"><p>dropped and stuck trace messages</p></td><td class="confluenceTd"><p><br/></p></td></tr><tr><td class="confluenceTd"><br/></td><td colspan="4" class="confluenceTd"><p>There are two ways that RTL trace messages will not show up in DTWs.</p></td></tr><tr><td class="confluenceTd"><br/></td><td colspan="4" class="confluenceTd"><p>1. If the capture system is full including the new SMI network input FIFOs, new SMI messages with traceme set will not lead to trace messages that end up in the TCAP accumulators or DTWs. These are dropped trace messages.</p></td></tr><tr><td class="confluenceTd"><br/></td><td colspan="4" class="confluenceTd"><p>2. Trace messages might make it to a TCAP accumulator. If there is not enough for that accumulator to create a full DTW, then that trace message is stuck for a period of time, up to 2^16 cycles.</p></td></tr><tr><td class="confluenceTd"><br/></td><td class="confluenceTd"><br/></td><td colspan="3" class="confluenceTd"><p>This timeout period is currently a parameter set to 2^16 cycles, and there is no register to allow tests to control it.</p></td></tr><tr><td class="confluenceTd"><br/></td><td class="confluenceTd"><br/></td><td colspan="3" class="confluenceTd"><p>Our tests will not have a drain time of 2^16 cycles to allow all the trace messages to be send out in DTWs.</p></td></tr><tr><td class="confluenceTd"><br/></td><td class="confluenceTd"><br/></td><td colspan="3" class="confluenceTd"><p>We do not have the capability in the scoreboard to peek into the RTL to see if there are stuck trace messages in the accumulators.</p></td></tr><tr><td class="confluenceTd"><br/></td><td colspan="4" class="confluenceTd"><p>Both of these types will lead to the following situation. There will be expected trace messages in the scoreboard, generated from SMI messages with traceme, that will not show up in DTWs.</p></td></tr><tr><td class="confluenceTd"><br/></td><td colspan="4" class="confluenceTd"><p>We will not be able to distinguish dropped trace messages from stuck trace messages.</p></td></tr><tr><td class="confluenceTd"><br/></td><td colspan="4" class="confluenceTd"><p>We will not be able to report errors for dropped or stuck messages. We can just report a simple combined count of dropped_or_stuck_trace_message_count per trace capture scoreboard.</p></td></tr><tr><td class="confluenceTd"><br/></td><td colspan="4" class="confluenceTd"><p>The trace scoreboard comparisons between expected trace messages and actual trace messages from DTWs can only report an error if an actual trace message occurs with no expected, but no other combination of expected and actual trace messages.</p></td></tr><tr><td class="confluenceTd"><br/></td><td colspan="4" class="confluenceTd"><p>The trace scoreboard can do some minimal checking of the legality of some DTW fields.</p></td></tr><tr><td class="confluenceTd"><br/></td><td class="confluenceTd"><br/></td><td class="confluenceTd"><br/></td><td class="confluenceTd"><br/></td><td class="confluenceTd"><p><br/></p></td></tr><tr><td class="confluenceTd"><br/></td><td class="confluenceTd"><br/></td><td class="confluenceTd"><br/></td><td class="confluenceTd"><br/></td><td class="confluenceTd"><p><br/></p></td></tr><tr><td colspan="2" class="confluenceTd"><p>Timestamp</p></td><td class="confluenceTd"><br/></td><td class="confluenceTd"><br/></td><td class="confluenceTd"><p><br/></p></td></tr><tr><td class="confluenceTd"><br/></td><td colspan="4" class="confluenceTd"><p>The trace capture scoreboard does not have access to the RTL internal timestamp value.</p></td></tr><tr><td class="confluenceTd"><br/></td><td colspan="4" class="confluenceTd"><p>Even within a single DTW, timestamp values are not guaranteed to be increasing, they can go up or down.</p></td></tr><tr><td class="confluenceTd"><br/></td><td colspan="4" class="confluenceTd"><p>So, there is nothing about timestamp that the scoreboard can check.</p></td></tr><tr><td class="confluenceTd"><p>(rollover)</p></td><td colspan="4" class="confluenceTd"><p>We have no front-door or back-door control of the RTL internal timestamp value. Since a timestamp rolls over after 2^32 cycles (except for corrections), none of our tests will ever see a rollover and we cannot do any rollover testing.</p></td></tr><tr><td class="confluenceTd"><br/></td><td class="confluenceTd"><br/></td><td class="confluenceTd"><br/></td><td class="confluenceTd"><br/></td><td class="confluenceTd"><p><br/></p></td></tr><tr><td colspan="5" class="confluenceTd"><p>So in summary, the trace capture scoreboard can only report two errors.</p></td></tr><tr><td class="confluenceTd"><br/></td><td colspan="4" class="confluenceTd"><p>1. An actual trace message was received that has no equivalent expected trace message.</p></td></tr><tr><td class="confluenceTd"><br/></td><td colspan="4" class="confluenceTd"><p>2. Some minimal legality checking of DTW_debug fields.</p></td></tr></tbody></table></div><p><br/></p><p>----------------------------</p><p><br/></p><p>DTW Dbg event sent probably does not need to be counted we can count it at the accumulate block as to how many it captured and dropped</p><p>Adding Bob for Accumulate block</p><p><br/></p><p><strong>From: </strong>Jason Villanueva &lt;<a class="external-link" href="mailto:Jason.Villanueva@arteris.com" rel="nofollow">Jason.Villanueva@arteris.com</a>&gt;<br/><strong>Date: </strong>Tuesday, August 24, 2021 at 6:47 PM<br/><strong>To: </strong>Mohammed Khaleeluddin &lt;<a class="external-link" href="mailto:Mohammed.Khaleeluddin@arteris.com" rel="nofollow">Mohammed.Khaleeluddin@arteris.com</a>&gt;, Darshan Alagud &lt;<a class="external-link" href="mailto:Darshan.Alagud@arteris.com" rel="nofollow">Darshan.Alagud@arteris.com</a>&gt;<br/><strong>Cc: </strong>Akarsh Hebbar &lt;<a class="external-link" href="mailto:Akarsh.Hebbar@arteris.com" rel="nofollow">Akarsh.Hebbar@arteris.com</a>&gt;<br/><strong>Subject: </strong>RE: Capture block question</p><p><br/></p><p>Hi Khaleel.</p><p>The trace capture block has the following signals ready to be connected to a perf interface.  I'll add a Jira to get them hooked up to the performance monitor interface.</p><p>(4-bits are needed, not 3 since 8 is the max number in a cycle)</p><p><br/></p><p>4-bit signal representing the number of SMI messages captured in a given cycle. </p><p><br/></p><p>4-bit signal representing the number of SMI messages dropped in a given cycle. </p><p><br/></p><p>1-bit signal representing when a DTW DBG request was sent. </p><p><br/></p><p>These were the original events mentioned in one our reviews.  However in the architecture doc only the first two events are reported. </p><p><br/></p><p>So do you want all three of these, or just the SMI message events. </p><p><br/></p><p>--------------------------</p><p><br/></p><p><br/></p><p>Hi Chien,</p><p>Talking from the point of view of the trace_capture block.</p><p>First the threshold is only in powers of 2. The threshold will be either 0, 2, 4, or 8 (max value). However in your question for example, when it is set to 2.</p><p>That means that the capture block will build and store up to 2 DTW DBG requests in the Capture Buffer before it can be allowed to be driven on the DTW DBG request interface. When the threshold is set to 0, as soon as there is a DTW DBG request within the Capture Buffer, it will send it out on the DTW DBG request interface.</p><p>It has nothing to do with building the DTW DBG and the size. The capture continues to try to store as many msgs as it can into the 64Byte buffer before it loads it into the Capture FIFO Buffer.</p><p><br/></p><p>For the DVE trace_accumulator question I’ll defer to <a class="external-link" href="mailto:Robert.Podnar@arteris.com" rel="nofollow">@Robert Podnar</a>, do you care about padding? Do you examine the BE for those cases or just write as the data is received?</p><p><br/></p><p><br/></p><p><br/></p><p><strong>From:</strong> Chien Chen &lt;<a class="external-link" href="mailto:Chien.Chen@arteris.com" rel="nofollow">Chien.Chen@arteris.com</a>&gt; <br/><strong>Sent:</strong> Tuesday, July 27, 2021 10:08 AM<br/><strong>To:</strong> Jason Villanueva &lt;<a class="external-link" href="mailto:Jason.Villanueva@arteris.com" rel="nofollow">Jason.Villanueva@arteris.com</a>&gt;; Robert Podnar &lt;<a class="external-link" href="mailto:Robert.Podnar@arteris.com" rel="nofollow">Robert.Podnar@arteris.com</a>&gt;<br/><strong>Cc:</strong> Akarsh Hebbar &lt;<a class="external-link" href="mailto:Akarsh.Hebbar@arteris.com" rel="nofollow">Akarsh.Hebbar@arteris.com</a>&gt;<br/><strong>Subject:</strong> Questions with tracebuffer behavior</p><p><br/></p><p>Hi Jason and Bob,</p><p>I sent questions to Khaleel, but did not get answers back (I guess he is buried under MobilEye stuff).</p><p>Would you help me out?</p><p>My questions are at the end of the message.</p><p>Thanks</p><p>-Chien</p><p><br/></p><p>Hi Khaleel, for trace/dbg: what is the behavior when threshold is set to less than 7? Would the unit send DTW with less than 64B payload? All will always send 64B but use BE to mark if payload is valid? Fot DVE, In this case, would DVE only put valid DW in the main buffer? Thanks</p><p><br/></p><p><br/></p><p>--------------------</p><p><br/></p><p><a class="external-link" href="https://confluence.arteris.com/display/ENGR/TCAP+initial+testplan+Ncore+3.2+Beta2" rel="nofollow">https://confluence.arteris.com/display/ENGR/TCAP+initial+testplan+Ncore+3.2+Beta2</a></p><p><br/></p><p><a class="external-link" href="https://arterisip.atlassian.net/browse/CONC-7795" rel="nofollow">https://arterisip.atlassian.net/browse/CONC-7795</a></p><p><br/></p><p><a class="external-link" href="https://confluence.arteris.com/display/ENGR/TTRI+and+TCAP+verif+plan+for+beta2" rel="nofollow">https://confluence.arteris.com/display/ENGR/TTRI+and+TCAP+verif+plan+for+beta2</a></p><p><br/></p>