<ol><li><p>Replace current instantiation of em_mem_v2 with em_mem_v3</p><ol><li><p>Example</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeHeader panelHeader pdl" style="border-bottom-width: 1px;"><b>Require em_mem_v3</b></div><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: js; gutter: false; theme: Confluence" data-theme="Confluence"> var em_mem_v3 = require(&#39;../../lib/src/em_mem_v3.achl.js&#39;);</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeHeader panelHeader pdl" style="border-bottom-width: 1px;"><b>em_mem_v3 instantiation</b></div><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: js; gutter: false; theme: Confluence" data-theme="Confluence">//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// RTT Data
//
if (u.getParam(&#39;useRttDataEntries&#39;)) {
	this.instance({
		name: &#39;rtt_data&#39;,
		moduleName: em_mem_v3,
		params: {
			rtlPrefixString: u.getParam(&#39;rttDataStructure&#39;).rtlPrefixString,
			memoryType: u.getParam(&#39;rttDataStructure&#39;).memoryType,
			nSignals: u.getParam(&#39;rttDataStructure&#39;).signals.length,
			useHandshake: 1,
			no_mem_init: 1,
			ports: &#39;tp&#39;,
			bitEnable: 0,
			width: u.getParam(&#39;rttDataStructure&#39;).width,
			depth: u.getParam(&#39;rttDataStructure&#39;).depth
		}
	});
}</pre>
</div></div></li></ol></li><li><p>Map memory object (done in param map file in DMI)</p><ol><li><p>Create a object (rttDataStructure was used in the DMI) to pass as a parameter through the design. To get the interface needed requires a call to memCalc, which is the memory_calculations.js file in memgen. This needs to be required by the param map.</p><ol><li><p>This data structure is copied from the corresponding key in the JSON. JSON Structure names with their corresponding memCalc function (to get interfaces and memory params) are shown below .</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" class="confluenceTh">Unit</th><th colspan="1" class="confluenceTh">JSON Structure Name</th><th colspan="1" class="confluenceTh">memCalc Function Name</th></tr><tr><th class="confluenceTh">AgentAiuInfo</th><td class="confluenceTd">DataMem(x)</td><td class="confluenceTd">aiuOttMemoryParams</td></tr><tr><th class="confluenceTh">BridgeAiuInfo</th><td class="confluenceTd">DataMem(x)</td><td class="confluenceTd">bridgeOttMemoryParams</td></tr><tr><th colspan="1" class="confluenceTh"> </th><td colspan="1" class="confluenceTd">NativeInfo.IoCacheInfo.DataMem(x)</td><td colspan="1" class="confluenceTd">bridgeIoCacheDataMemoryParams</td></tr><tr><th colspan="1" class="confluenceTh"> </th><td colspan="1" class="confluenceTd">NativeInfo.IoCacheInfo.TagMem</td><td colspan="1" class="confluenceTd">bridgeIoCacheTagMemoryParams</td></tr><tr><th colspan="1" class="confluenceTh"> </th><td colspan="1" class="confluenceTd">TODO RP memories</td><td colspan="1" class="confluenceTd">bridgeIoCacheRPMemoryParams</td></tr><tr><th class="confluenceTh">SnoopFilterInfo</th><td class="confluenceTd">TagMem </td><td class="confluenceTd">snoopFilterMemoryParams</td></tr><tr><th class="confluenceTh">DmiInfo</th><td class="confluenceTd">RttDataMem </td><td class="confluenceTd">dmiRttMemoryParams</td></tr><tr><th colspan="1" class="confluenceTh"> </th><td colspan="1" class="confluenceTd">TODO CMCTag</td><td colspan="1" class="confluenceTd">dmiCMCTagMemoryParams</td></tr><tr><th colspan="1" class="confluenceTh"> </th><td colspan="1" class="confluenceTd">TODO CMCData</td><td colspan="1" class="confluenceTd">dmiCMCDataMemoryParams</td></tr></tbody></table></div></li></ol></li><li><p>The two memCalc functions are used to add information to paramter (rttDataStructure)</p><ol><li><p>memCalc.getMemoryControlSignals() gets the interface of signals that need to get passed through the design. The second function below must be passed as an argument. This is added to the rttDataStructure.</p></li><li><p>memCalc.dmiRttMemoryParams() this is specific to DMI and is used to get the width and depth of the memory. It is not necessary to get the memory parameters this way, but ensures that the RTL instantiation dimension and the external verilog dimensions are the same. You can also get the width not including the ecc bits this way to use with the ECC modules.</p></li></ol></li><li><p>Example</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeHeader panelHeader pdl" style="border-bottom-width: 1px;"><b>require memgen</b></div><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: js; gutter: false; theme: Confluence" data-theme="Confluence">var memCalc = require(&#39;@arteris/memgen&#39;).memCalc;</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeHeader panelHeader pdl" style="border-bottom-width: 1px;"><b>RTT Data Memory Map</b></div><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: js; gutter: false; theme: Confluence" data-theme="Confluence">    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // RTT Data Memory
    // Copy the rttDataStructure directly from the params
    // This used to be flattened out, but since then we
    // have accepted using objects in the parameters
    //
    var rttDataStructure;
    var blockWidths = [];
    if (p.DmiInfo[dmiIndex].CmpInfo.useRttDataEntries) {
        if (p.DmiInfo[dmiIndex][&#39;RttDataMem&#39;]) {
            rttDataStructure = p.DmiInfo[dmiIndex][&#39;RttDataMem&#39;];
            // Add control signals and their widths to the data structure
            var rttParams = memCalc.dmiRttMemoryParams(p.DmiInfo[dmiIndex]);
            var controlSignals = memCalc.getMemoryControlSignals(
                rttDataStructure.memoryType,
                rttParams,
                &#39;tp&#39;,
                0
            );
            rttDataStructure.controlSignals = controlSignals;
            // Memory Calculations
            rttDataStructure.widthWithoutEcc = rttParams.widthWithoutEcc;
            rttDataStructure.width = rttParams.width;
            rttDataStructure.depth = rttParams.depth;
            blockWidths = rttParams.blockWidths;
            // If the memory type is none, set the rtlStringPrefix so a default value
            // this is because the created memory uses this default name for all
            // memories accross ports
            if (rttDataStructure.memoryType === &#39;none&#39;) {
                rttDataStructure.rtlPrefixString = p.MemRegionInfo[dmiIndex].strRtlNamePrefix + &#39;_rtt&#39;;
            }
        }
    }</pre>
</div></div></li></ol></li><li><p>Plumb new 'internal memory' signals from em_mem_v3 instantiation to top level</p><ol><li><p>This uses the function u.getMemoryControlInterface from the utils library.</p></li><li>It can then be used as a normal interface. i.e. passed to u.defineMasterPortsFromInterface and u.addConnectionfromInterface</li><li>Be sure to include the rtlPrefixString in the signal name to make it unique.</li><li><p>Example</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeHeader panelHeader pdl" style="border-bottom-width: 1px;"><b>Plumbing out of transaction_control</b></div><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: js; gutter: false; theme: Confluence" data-theme="Confluence">// Make connections
var rtlPrefixString = u.getParam(&#39;rttDataStructure&#39;).rtlPrefixString;
var memoryControlInterface = u.getMemoryControlInterface(&#39;rttDataStructure&#39;);
u.defineMasterPortsFromInterface(rtlPrefixString + &#39;_&#39;, memoryControlInterface);
u.addConnectionfromInterface(&#39;rtt_data.&#39;,
								rtlPrefixString + &#39;_&#39;,
								memoryControlInterface);</pre>
</div></div></li></ol></li><li>Instantiate em_mem_external to module top level<ol><li><p>Example</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeHeader panelHeader pdl" style="border-bottom-width: 1px;"><b>Require em_mem_external</b></div><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: js; gutter: false; theme: Confluence" data-theme="Confluence">var em_mem_external = require(&#39;../../lib/src/em_mem_external.achl.js&#39;);</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeHeader panelHeader pdl" style="border-bottom-width: 1px;"><b>em_mem_external instantiation</b></div><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: js; gutter: false; theme: Confluence" data-theme="Confluence">//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Transaction Control Memory Connections
// In both CMC and nonCMC design
//
if (u.getParam(&#39;useRttDataEntries&#39;)) {
	this.instance({
		name: &#39;rtt_data&#39;,
		moduleName: em_mem_external,
		params: {
			rtlPrefixString: u.getParam(&#39;rttDataStructure&#39;).rtlPrefixString,
			memoryType: u.getParam(&#39;rttDataStructure&#39;).memoryType,
			nSignals: u.getParam(&#39;rttDataStructure&#39;).signals.length,
			useHandshake: 1,
			no_mem_init: 1,
			ports: &#39;tp&#39;,
			bitEnable: 0,
			width: u.getParam(&#39;rttDataStructure&#39;).width,
			depth: u.getParam(&#39;rttDataStructure&#39;).depth
		}
	});
	var rtlPrefixString = u.getParam(&#39;rttDataStructure&#39;).rtlPrefixString;
	u.addConnectionfromInterface(&#39;dmi_unit.&#39; + rtlPrefixString + &#39;_&#39;,
									&#39;rtt_data.&#39;,
									u.getMemoryControlInterface(&#39;rttDataStructure&#39;));
}</pre>
</div></div></li></ol><p> </p></li></ol>