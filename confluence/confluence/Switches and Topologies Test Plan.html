<h1 id="SwitchesandTopologiesTestPlan-History">History</h1><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th class="confluenceTh"> </th><th class="confluenceTh">Date</th><th class="confluenceTh">Owner</th><th class="confluenceTh">Comment</th></tr><tr><td class="confluenceTd">0.1</td><td class="confluenceTd">14-Nov-2018</td><td class="confluenceTd">Andrew Brock</td><td class="confluenceTd">Initial version</td></tr><tr><td class="confluenceTd">0.2</td><td class="confluenceTd">16-Nov-2018</td><td class="confluenceTd">Andrew Brock</td><td class="confluenceTd">Major edits after review</td></tr><tr><td class="confluenceTd">1.0</td><td class="confluenceTd">11-Jan-2018</td><td class="confluenceTd">Andrew Brock</td><td class="confluenceTd">Add conclusions</td></tr></tbody></table></div><p style="text-align: left;"> </p><h1 id="SwitchesandTopologiesTestPlan-ReviewHistory">Review History</h1><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th class="confluenceTh"> </th><th class="confluenceTh">Date</th><th class="confluenceTh">Presenter</th><th class="confluenceTh">Attendees</th></tr><tr><td class="confluenceTd">0.1</td><td class="confluenceTd">14-Nov-2018</td><td class="confluenceTd">Andrew Brock</td><td class="confluenceTd">Khaled, Syed, John, Saad</td></tr><tr><td class="confluenceTd">0.2</td><td class="confluenceTd">16-Nov-2018</td><td class="confluenceTd">Andrew Brock</td><td class="confluenceTd">Khaled, Syed, John, Saad</td></tr><tr><td class="confluenceTd">1.0</td><td class="confluenceTd"> </td><td class="confluenceTd">Andrew Brock</td><td class="confluenceTd">Khaled, Syed, John, Saad</td></tr></tbody></table></div><p><style type='text/css'>/*<![CDATA[*/
div.rbtoc1759723861525 {padding: 0px;}
div.rbtoc1759723861525 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1759723861525 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class='toc-macro rbtoc1759723861525'>
<ul class='toc-indentation'>
<li><span class='TOCOutline'>1</span> <a href='#SwitchesandTopologiesTestPlan-History'>History</a></li>
<li><span class='TOCOutline'>2</span> <a href='#SwitchesandTopologiesTestPlan-ReviewHistory'>Review History</a></li>
<li><span class='TOCOutline'>3</span> <a href='#SwitchesandTopologiesTestPlan-ProblemStatement'>Problem Statement</a></li>
<li><span class='TOCOutline'>4</span> <a href='#SwitchesandTopologiesTestPlan-ModelandInvariant'>Model and Invariant</a></li>
<li><span class='TOCOutline'>5</span> <a href='#SwitchesandTopologiesTestPlan-TestPlan'>Test Plan</a></li>
<li><span class='TOCOutline'>6</span> <a href='#SwitchesandTopologiesTestPlan-Conclusions'>Conclusions</a></li>
</ul>
</div></p><h1 id="SwitchesandTopologiesTestPlan-ProblemStatement">Problem Statement</h1><p>Symphony switches use two-stage arbitration networks on each egress port. To facilitate wormholing, the first stage of arbiters can &quot;lock&quot; on a given packet, preventing it from being preempted. When cascading two switches together, however, a later switch may lock onto a packet that can be preempted by traffic on another VC</p><h1 id="SwitchesandTopologiesTestPlan-ModelandInvariant">Model and Invariant</h1><p>This proof will require an abstract arbiters model. Each switch arbiter will be modeled by a series of VC arbiters, which simply lock onto the first packet they see, and a master arbiter, which will be strict priority. A tree with one egress port will be modeled, with the hierarchy of arbiters that feed into it extracted into a tree. Packets will be injected on each link/priority, with associated VC information, until a switch reports that it no longer has access on any of its immediate parents to the packet it is locked on.</p><p>I believe it is sufficient to assign a state in which every switch has access to the packet that has won its arbitration and a packet to be injected that will cause this invariant to be violated to detect deadlock. Since this can be phrased as a system invariant, it is easier to prove than a proof that requires packets to be injected one-by-one to build up state.</p><p>We are looking for deadlock here, not livelock or starvation, so it is sufficient to use only priority master arbiters. RR and WRR arbiters change the winner of arbitration every cycle in which they are not locked, so if they do not lock they cannot deadlock, and if they do lock, the wormhole is maintained until the packet clears. The per-VC arbiters are simplified because, since we are generating the initial state from an invariant and not packet-by-packet, they need not actually arbitrate and there need be no provision for unlocking. The per-VC arbiters then consist only of lock logic.</p><p>Take, for example, the following state assignment, derived from John's example:</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="400" src="https://arterisip.atlassian.net/wiki/download/attachments/16163639/simplified-arb-tree-init.png?api=v2"></span></p><p>Initially, the SW2 VC1 ARB is locked on SW2 port B, which is carrying a VC1 packet, so this is a legal state and all is well.</p><p>Trying to inject the new packet would cause the SW1 VC0 ARB to lock on port B and the SW1 priority level to rise to 0. SW2 port B then is carrying packet (0, 0), but the SW2 VC0 ARB is locked on port A, and the SW2 VC1 ARB is locked on port B, so SW2 is no longer passing packets. The invariant is violated.</p><h1 id="SwitchesandTopologiesTestPlan-TestPlan">Test Plan</h1><p>For any given topology, we will need to extract the arbiter hierarchy for all upstream switches of each egress port. This has potential to be a lot of hierarchies, but it also has a lot of symmetry. All 8 egress ports in the standard topology have the same upstream hierarchy: a 4x4 switch followed by a 4x4 switch. All egress ports on a single switch have the same hierarchy behind them and are susceptible to the same deadlocks.</p><p>Modelling this in ACL2 and representing priorities and VCs as naturals avoids the question of how many VCs or priority levels are necessary to trigger deadlock behavior. I think that N VCs and N priority levels are necessary, where N is maximum number of ingress ports on a switch, but I'm not sure yet.</p><h1 id="SwitchesandTopologiesTestPlan-Conclusions">Conclusions</h1><p>Tests using a SAT solver-based methodology on a 2x2 arbiter network were able to determine that deadlocks are not possible if priorities and VCs have a 1:1 mapping. The model used 2 priority levels and 2 VCs, with strict priority master arbiters. However, these conclusions do not apply to any other arbiter style and require a number of assumptions and restrictions, which make them of limited utility. To wit:</p><ol><li>If the injection port is locked, in either VC on its input switch, we must be in a bubble, and we must be able to trace back from some output to the injection port. We can discard this case regardless. Either:<ol><li>This is an illegal case: we are trying to interleave packets on a link when those packets are on the same VC.</li><li>This is not a deadlock: we have such a path and can make forward progress.</li></ol></li><li>If low-priority packets currently control a link, the scenario is not a deadlock, because these packets can be preempted.</li><li>Downstream switch VC arbiters for different outputs must, if locked, be locked on different inputs.</li><li>Any upstream switch that a downstream switch has locked on must itself be locked.</li></ol><p>Assumptions 1 and 2 concern detecting deadlock conditions and assumptions 3 and 4 concern preventing illegal arbiter initial states. There is nothing wrong with these assumptions and we (Andrew, John, Syed) believe them to be correct, but they are for the most part quite brittle both in applicability and implementation.</p><p>Andrew believes that a better implementation would use Murphi (or a similar, custom system) to simulate the arbiters as they evolve across multiple steps. This would allow pluggable arbiter specifications and eliminate the need for the assumptions above that exist only to remove the need for multistep simulation. If the system is allowed to evolve for multiple steps from an idle state until a definite deadlock is detected, much broader applicability of findings is possible, at the expense of run time. By using a simplified model of switching and arbitration, a significant performance gain is still realized over RTL simulation.</p>