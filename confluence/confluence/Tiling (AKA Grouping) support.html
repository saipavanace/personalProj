<p><a class="confluence-userlink user-mention" data-account-id="624b374545ece00069cca858" href="https://arterisip.atlassian.net/wiki/people/624b374545ece00069cca858?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">Ben Chen (Deactivated)</a> :</p><p>Below is the task breakdown from our meeting yesterday.  Please add time estimates as appropriate in man days as well as anything I might have missed.<br/>If a task estimates more than 5 man days, please break it down further such that the maximum estimate for a given task is 5d or mark it as need more input, e.g.  some of the automation as well as the GUI probably needs further breakdown.</p><p>I can create the JIRA stories and tasks with the appropriate Agile_S label.</p><p><a class="confluence-userlink user-mention" data-account-id="624b36f5ed4d6b0070161efb" href="https://arterisip.atlassian.net/wiki/people/624b36f5ed4d6b0070161efb?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">Benny Winefeld (Deactivated)</a></p><p>First we need to define what is tiling. Here is my rough definition, please feel free to change: <br/>Tiling a general capability in Maestro client and server allowing the user to rearrange the design hierarchy and optimize the creation of networks wrt the hierarchy structure - primarily minimize the amount of wiring between top level hier blocks ( aka tiles or groups). </p><p>It looks that on the client side we should at first support only one level of tiling, i.e tiles can't be nested.  However I believe on the server side we have to support an arbitrary hierarchy depth from the very beginning, for ex chip-&gt;tile→network-&gt;unit</p><p><a class="confluence-userlink user-mention" data-account-id="624b36daed4d6b0070161eea" href="https://arterisip.atlassian.net/wiki/people/624b36daed4d6b0070161eea?ref=confluence" target="_blank" data-linked-resource-id="754406" data-linked-resource-version="1" data-linked-resource-type="userinfo" data-base-url="https://arterisip.atlassian.net/wiki">Federico Angiolini</a></p><p>Agree with <a class="confluence-userlink user-mention" data-account-id="624b36f5ed4d6b0070161efb" href="https://arterisip.atlassian.net/wiki/people/624b36f5ed4d6b0070161efb?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">Benny Winefeld (Deactivated)</a>'s definition, with a couple of clarifications:</p><ol><li>We have historically used the term &quot;<strong>Grouping</strong>&quot; for clarity and to differentiate from the sibling approach, that has been called &quot;Tiling&quot; or more recently &quot;Stamping&quot;. I'd encourage the use of the word &quot;Grouping&quot; as it leads to less ambiguity.</li><li>It is important to differentiate that:<ol><li>Grouping is a <strong>design decomposition</strong> technique: the design is built whole, then broken down in parts. This requires limited HW support, mostly at the level of wrappers. Arteris as a company has experience with this flow.</li><li>Tiling (stamping) is a <strong>design composition </strong>technique: a tile is built first, then the design is built by juxtaposition. This is significantly harder for Maestro to implement, and it requires new HW capabilities as well, for example in the area of routing or memory maps. It appears that this would be a new capability that the company's software has never supported. We will look at tiling/stamping later.</li></ol></li></ol><p>Based on latest discussions, these simplifications and points of convergence have been discussed:</p><ol><li>The design (at least the main networks) is built first, then groups are defined by the user. Grouping is not an a-priori notion. Later, the user is free to reassign units between groups at any time.</li><li>For R1, grouping can be 1-deep, no nesting. However nesting will be required at some point, e.g. to break down a large entity that takes too many gates.</li><li>For R1, it will be assumed that the main cost function to minimize is the number of wires across groups.</li><li>Ancillary Maestro automation, e.g. interrupt/PMON/CSR insertion, should be given a light coat of awareness of groups, in an attempt to optimize the cost function above. The optimization may not be particularly efficient but some steps need to be taken so that the automation is at least group-friendly.<ol><li>In this respect, grouping supersedes domains. For example, if a domain spans across two groups, where the current logic optimizes the number of crossings between domains, we should now break logic down more to minimize the crossings between domains. It would be appropriate to print a warning if the user does this, however.</li></ol></li><li> There is a &quot;default group&quot; or &quot;no group&quot; that coincides with the toplevel. When Maestro automatically generates any unit that does not clearly belong to a group (e.g. because global, or because no groups are defined yet) the unit will be placed in the toplevel. This is legitimate. The user can always reassign such units later by hand.</li><li>For the purpose of SDC generation, i.e. timing estimation, it shall be assumed that group-to-group interfaces are always either pipelined, or coincide with a domain crossing, in which case the group boundary runs down the middle of the async interface. This allows SW to deploy a simple HW model, e.g. &quot;this block needs a 20% setup time so the input delay needs to be 80% of the clock period&quot;. In flow-through-switch-to-flow-through-switch connections that cross a group boundary, either pipes or (if appropriate) async/rate adapters need to be instantiated. </li></ol><p><br/></p><p>Data Model</p><ul><li>Group representation<ul><li>Introduce a concept of tile or group in Maestro, and toplevel as a default tile,  <strong>Agile S</strong></li><li>Convenience APIs for mass moving/hierarchical moving (e.g. if a unit is moved to another group, move its children), <strong>Agile S</strong></li><li>Convenience APIs for group merging,<strong> Agile S</strong></li><li><em><u>If nesting to be supported</u></em>: Convenience APIs for pulling up/pushing down <strong>Agile S</strong></li></ul></li><li>Optional/related: <a class="external-link" href="https://arterisip.atlassian.net/browse/MAES-2030" rel="nofollow" style="text-decoration: none;">MAES-2030</a> <span class="legacy-color-text-blue3">Async adapters halves to be explicitly written as genwrapper instances</span><ul><li><span class="legacy-color-text-blue3">ADM support - adapter &quot;in&quot; and &quot;out&quot; become instance objects in Maestro under the hood, but not in the GUI. </span>All the grouping features described above can be applied to adapter &quot;halves&quot;, <strong>Agile S</strong><ul><li>This task will probably ripple across to the backend<span class="legacy-color-text-blue3"><strong><span class="legacy-color-text-pink2"> - Agile ?</span></strong></span></li></ul></li></ul></li></ul><p>Automation</p><ul><li>Automate config network insertion<ul><li>Tiles have priority over domains; first-level switches are one per tile - <strong>Agile S</strong></li></ul></li><li>Interrupt network<ul><li>Tiles have priority over domains; one accumulator per tile - <strong>Agile S</strong></li></ul></li><li>Pmon network<ul><li>This automation doesn't exist yet, but it should be similar to the work for CSR insertion - <strong>Agile S/M</strong></li></ul></li></ul><p>UI (GUI/Tcl)</p><ul><li>Add ability to assign/move any leaf instance to a group with TCL commands. <strong>Agile S</strong></li><li>Add ability to display groups in GUI with colors <strong>Agile S</strong><ul><li><u><em>If nesting to be supported</em></u>: this becomes much harder, probably with a notion of hierarchical boxes and entering/exiting the groups, plus handling the interfaces somehow<strong><span class="legacy-color-text-pink2"> - TBD</span></strong></li></ul></li><li>Add ability to assign/move any leaf instance to a group in GUI (easiest implementation is with a new widget, tree and drag/drop or multiselection)<span class="legacy-color-text-blue3"><strong><span class="legacy-color-text-pink2"> - Agile M?</span></strong></span></li></ul><p>Checker</p><ul><li>Warn when hierarchy doesn’t match clock and power domain boundaries, <strong>Agile XS</strong></li><li>Error if a group boundary is not pipelined or not on an async boundary,<strong> Agile XS</strong></li></ul><p>Gen_collateral</p><ul><li><span class="legacy-color-text-blue3">librtl to write groups and association of instances to groups to intermediate json<strong><span class="legacy-color-text-pink2"> - </span><span class="legacy-color-text-default">Agile_XS</span></strong></span></li><li>By default, generate groups based on clock domain.  Tile have priority over domains<span class="legacy-color-text-blue3"><strong><span class="legacy-color-text-pink2"> - <span class="legacy-color-text-default">Agile_S</span></span></strong></span></li></ul><p>Maestro server</p><ul><li><a class="external-link" href="https://arterisip.atlassian.net/browse/MAES-1735" rel="nofollow" style="text-decoration: none;">MAES-1735</a> Server side hierarchy handling<ul><li><a class="external-link" href="https://arterisip.atlassian.net/browse/MAES-1913" rel="nofollow" style="text-decoration: underline;">MAES-1913</a> Prototype script for injecting hierarchy into intermediate json  <strong>Agile_S</strong></li><li>Server to generate genwrapper json with hierarchies reflecting grouping in the intermediate json <strong>Agile_S  <br/> Dan says this is already ready </strong>- but never tested, need to verify if generated genwrapper will be legal and won't break rtl gen and DV flow</li><li><span class="legacy-color-text-blue3">Adjust constraint generator to create async constraints reflecting the actual hierarchy <br/>currently there is a hardcoded assumption that interface connecting adapter halves is always inside atomic adapter instance. <strong>Agile_S</strong></span></li><li><span class="legacy-color-text-blue3">Extensions to SDC generation? Very hard to estimate, effort depends on the hierarchy structure. Let's assume <strong>Agile_S</strong>, but it can be more <strong><span class="legacy-color-text-pink2"> </span></strong></span></li></ul></li></ul>