<p><em>Chi-aiu* integration is taken as an example. </em></p><p><br/></p><p><br/></p><p><span class="confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image image-center" height="400" src="https://arterisip.atlassian.net/wiki/download/attachments/16164369/image2021-8-27_11-55-23.png?api=v2"></span></p><p><br/></p><p><br/></p><h2 id="HowtointegratePMONintoNcoreunits-AdditionofregistersinCSR-CPR">Addition of registers in CSR-CPR</h2><p>Each unit requires the addition of the below Ncore Perfmon registers starting at address-offset: <strong>0xB00</strong>. The <em>nPerfCounters</em> parameter determines how many times each of these registers are repeated.</p><p><br/>{<br/>  &quot;name&quot;: &quot;CAIUCNTCR&quot;,<br/>  &quot;description&quot;: &quot;PMON Counter Control Register&quot;,<br/>  &quot;csrDescription&quot;: &quot;PMON Counter Control Register&quot;,<br/>  &quot;addressOffset&quot;: &quot;0xb00&quot;,<br/>  &quot;condition&quot;: &quot;return derived.nPerfCounters&quot;,<br/>  &quot;offsetStep&quot;: 0,<br/>  &quot;fields&quot;: {<br/>    &quot;descFields&quot;: [],<br/>    &quot;reference&quot;: &quot;$HW_NCR_CSR/ncr_pmon_CSR.json#xCNTCR&quot;<br/>  }<br/>},<br/>{<br/>  &quot;name&quot;: &quot;CAIUCNTVR&quot;,<br/>  &quot;description&quot;: &quot;PMON Counter Value Register&quot;,<br/>  &quot;csrDescription&quot;: &quot;PMON Counter Value Register Register&quot;,<br/>  &quot;addressOffset&quot;: &quot;0xb04&quot;,<br/>  &quot;condition&quot;: &quot;return derived.nPerfCounters&quot;,<br/>  &quot;offsetStep&quot;: 16,<br/>  &quot;fields&quot;: {<br/>    &quot;descFields&quot;: [],<br/>    &quot;reference&quot;: &quot;$HW_NCR_CSR/ncr_pmon_CSR.json#xCNTVR&quot;<br/>  }<br/>},<br/>{<br/>  &quot;name&quot;: &quot;CAIUCNTSR&quot;,<br/>  &quot;description&quot;: &quot;PMON Counter Saturation Register&quot;,<br/>  &quot;csrDescription&quot;: &quot;PMON Counter Saturation Register&quot;,<br/>  &quot;addressOffset&quot;: &quot;0xb08&quot;,<br/>  &quot;condition&quot;: &quot;return derived.nPerfCounters&quot;,<br/>  &quot;offsetStep&quot;: 16,<br/>  &quot;fields&quot;: {<br/>    &quot;descFields&quot;: [],<br/>    &quot;reference&quot;: &quot;$HW_NCR_CSR/ncr_pmon_CSR.json#xCNTSR&quot;<br/>  }<br/>}</p><p><br/></p><h2 id="HowtointegratePMONintoNcoreunits-Parameters">Parameters</h2><p>The Ncore PMON block  (ncr_pmon.tachl) requires passing the following parameters:</p><p style="margin-left: 30.0px;">nPerfCounters: Type: number. Number of performance counters. This is passed as an input parameter to all Ncore units.</p><p><br/></p><p>The above parameters must be added in the unit's tachl.cpr file. Refer chi_aiu.tachl.cpr to add these parameters.</p><p><br/></p><h2 id="HowtointegratePMONintoNcoreunits-EventTable">Event Table</h2><p>It is recommended that an event table data-structure is created in each Ncore unit that instantiates the Ncore PMON (ncr_pmon) block, called <em>pmonEventTable</em>. The <em>pmonEventTable</em> data-structure will be array of objects with the following structure:</p><p>[<br/>  { <br/>    width: A number that specifies the width of the event,<br/>    value: A string that contains a Verilog signal or expression to drive this event<br/>  },<br/>  { },<br/>  .<br/>  .<br/>  .</p><p>]</p><p>The index of each event in the above array must map to the event number in the unit's event mapping table specified in the arch document. The <em>pmonEventTable</em> is then expected to be used to derive event interfaces as well as to generate event assignment statements. This is expected to simplify adding new events or change mappings in the table, without requiring changes in the rest of the code. All reserved or unused events can be declared with a width of 1 and be tied off to logic 0.</p><p>The event-mapping table is unique to each Ncore unit and can be found in the latest version of the Arch spec here: <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16159850/Arch+Ncore+3.2+Docs" data-linked-resource-id="16159850" data-linked-resource-version="57" data-linked-resource-type="page">Arch Ncore 3.2 Docs</a></p><h2 id="HowtointegratePMONintoNcoreunits-GeneratingNcorePmonInterfaces">Generating Ncore Pmon Interfaces</h2><p>The block supports only new-style interfaces, all of which are listed below:</p><ol><li><em>clkInterface</em>: An interface of type <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168894/InterfaceCLK" data-linked-resource-id="16168894" data-linked-resource-version="5" data-linked-resource-type="page">InterfaceCLK</a></li><li><em>evtInterfaces</em>: An <strong>array</strong> <strong>of interfaces</strong> of type <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16169167/InterfaceEvt" data-linked-resource-id="16169167" data-linked-resource-version="7" data-linked-resource-type="page">InterfaceEvt</a>. Most units will support either 32 or 64 events in this array. Each event interface in this array can be of a different width.</li><li><em>csrInterface</em>: An interface of type <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16164444/InterfaceGeneric" data-linked-resource-id="16164444" data-linked-resource-version="15" data-linked-resource-type="page">InterfaceGeneric</a>, with synonymsOn and synonymsExpand set to true. This is used to carry all the register bits going to and from the PerfMon registers and can be derived from the CSR register definitions.</li></ol><p>Generating the clock interface is straightforward and so the remaining part of this section is focused on generating the other two interfaces.</p><h3 id="HowtointegratePMONintoNcoreunits-GeneratingcsrInterface">Generating <em>csrInterface</em></h3><p>The csrInterface can be generated using the flow described in <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16160703/Auto+generation+of+CSR+register+ports+and+interfaces" data-linked-resource-id="16160703" data-linked-resource-version="14" data-linked-resource-type="page">Auto generation of CSR register ports and interfaces</a>. This involves calling some library functions as described below:</p><p>The first step is to grep out register definitions for the Ncore Pmon block only from the superset of all registers in the <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16154965/csr" data-linked-resource-id="16154965" data-linked-resource-version="35" data-linked-resource-type="page">csr</a> object passed to the unit:</p><p>const pmonRegisters = obj.userLib.genNcorePmonRegisters( csr.spaceBlock[0].registers, prefix, { nPerfCounters } );  // Returns the array of PMON registers only.</p><p>The <em>prefix</em> parameter is a unit-specific string that will be prefixed to every register in that Ncore-unit. Ex: &quot;CAIU&quot; for CHI-AIU, &quot;XAIU&quot; for IOAIU, &quot;DMI&quot; for DMI and so on.</p><p><br/></p><p>Next, using pmonRegisters, create an interface-generator object. This object provides methods that allow you to create signal bundles, old-style interfaces, and new-style (InterfaceGeneric) interfaces for the register bits.</p><p>const pmonCsrIfGenerator = obj.userLib.createCSRInterfaceGenerator( pmonRegisters );   // Create interface-generator object for PMON CSR<br/>const pmonCsrOldStyle      = { name: <em>prefix</em>, signals: pmonCsrIfGenerator.signalBundle( direction ) };   // Create an old-style interface. direction can be &quot;master&quot; or &quot;slave&quot;<br/>const pmonCsrNewStyle     = pmonCsrIfGenerator.interfaceGeneric( direction, <em>prefix</em> )  // Create a new-style interface. <em>prefix</em> = &quot;CAIU&quot;, &quot;XAIU&quot;, etc.<br/><br/></p><p>The old-style interface maybe required to connect the other end of CSR interface signals to the apb_csr or unit_csr module if that supports only old-style interfaces.</p><h3 id="HowtointegratePMONintoNcoreunits-GeneratingevtInterfaces">Generating evtInterfaces</h3><p>It is recommended to derive <em>evtInterfaces</em> from the <em>pmonEventTable</em> (described in the section 'Event Table') data-structure, by looping through the array and using the widths specified in the table for width of the event. </p><p>The <em>pmonEventTable</em> and the generated <em>evtInterfaces</em> together could be used to generate Verilog assign statements to drive each of the events in the table, in a loop.</p><p><br/></p><h3 id="HowtointegratePMONintoNcoreunits-Instantiatingdivby16Counter">Instantiating div by 16 Counter</h3><p>An instance of clk_divider is needed to support divide by 16. The clk_divider module needs the following parameters:</p><ul><li><em>clkDivisors</em>: an array of clk divisors. Currently, the array has a single element, and its value is equal to 16.</li><li><em>clkInterface</em>: An interface of type <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168894/InterfaceCLK" data-linked-resource-id="16168894" data-linked-resource-version="5" data-linked-resource-type="page">InterfaceCLK</a>.</li><li><em>clkOutInterface</em>: an array of <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168894/InterfaceCLK" data-linked-resource-id="16168894" data-linked-resource-version="5" data-linked-resource-type="page">InterfaceCLK</a>, same size as <em>clkDivisors</em>, which is generated by the clk_divider module. Currently, <em>clk16Interface</em> is the only element of the array because <em>clkDivisors </em>is a single element array, with a value of 16. </li></ul><p>clk_divider unit needs a clkInterface as the input and generates an array of clkInterfaces as the output. It is only needed to connect clk signal of the generated output clkInterface from clk_divider to the related event in <em>pmonEventTable</em>. </p><h1 id="HowtointegratePMONintoNcoreunits-PMON3.4"><strong>PMON 3.4</strong></h1><h2 id="HowtointegratePMONintoNcoreunits-Newfeatures"><strong>New features</strong></h2><p>The new <em>ncr_pmon</em> block used in Ncore 3.4 introduces the following new features in order to support Bandwidth measurement and Latency binning:</p><ol><li><strong>Parallel mode</strong>: Previously a pair of two 32-bit counters (CNTVR and CNTSR) were daisy chained to form a 64-bit performance counter that counted or accumulated a single event. In Ncore 3.4, a new parallel mode allows two 32-bit counters CNTVR and CNTSR to be used to count or accumulate two separate events simultaneously. This allows bandwidth measurement using a reference event (div16 event) to count CNTSR and a bandwidth event to count CNTVR.</li><li><strong>Event filtering</strong>: Events can be conditionally turned on or off depending on whether a set of attributes such as (Funit ID, user-bits) associated with the event, match programmed values in registers. This feature is primarily meant for bandwidth events but not limited to them.</li><li><strong>Latency binning</strong>: This feature is used with a pair of allocation and deallocation events along with the IDs of the transactions being allocated or deallocated.</li></ol><p><br/></p><h2 id="HowtointegratePMONintoNcoreunits-Newinterfaces"><strong>New interfaces</strong></h2><p>The new interfaces are made optional (can be left undefined) for backward compatibility. The following two new interface-arrays are introduced on the ncr_pmon block for Ncore 3.4:</p><ol><li><strong><em>filterAttrInterfaces</em></strong>: This is an array of slave interfaces of type <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16164444/InterfaceGeneric" data-linked-resource-id="16164444" data-linked-resource-version="15" data-linked-resource-type="page">InterfaceGeneric</a>, with synonyms expanded. This interface is used to bring the values that determine when an associated event is to be filtered on or off. The synonyms param in the interface will be used to specify the filtering attributes and their width.</li><li><strong><em>latencyInterfaces</em></strong>: This is an array of slave interfaces of type <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16164444/InterfaceGeneric" data-linked-resource-id="16164444" data-linked-resource-version="15" data-linked-resource-type="page">InterfaceGeneric</a>, with synonyms expanded. The synonyms are used to specify signals required for latency binning: <em>alloc</em> and <em>dealloc</em>.</li></ol><p>The filterAttrInterfaces can be generated from a table called filterAttributesMap described later. No ports ( that are not part of an interface) are introduced. </p><p><br/></p><h2 id="HowtointegratePMONintoNcoreunits-Newparams"><strong>New params</strong></h2><p>Only two new params are introduced:</p><ol><li><strong><em>bwEvtMapping</em></strong>: Array of numbers. Each number specifies an event number or index in the event table. The event specified is associated with the corresponding filtering attribute signals in the filterAttrInterfaces array.</li><li><strong><em>nLatencyCounters</em></strong>: A number that specifies the number of latency counters used in the latency counter table OR, in other words, the max. number of transactions whose latencies can be tracked simultaneously.</li></ol><h2 id="HowtointegratePMONintoNcoreunits-IntegratingBandwidthsupporttoNcoreUnits"><strong>Integrating Bandwidth support to Ncore Units</strong></h2><p><em>dmi* integration is taken as an example.<br/><br/></em></p><h3 id="HowtointegratePMONintoNcoreunits-AdditionofregistersinCSR-CPR.1"><strong>Addition of registers in CSR-CPR</strong></h3><p>The following Perfmon registers needs to be added to AIU, CHI-AIU, DMI and DII. nPerfCounters determines the number of each of these registers. </p><p>{<br/>&quot;name&quot;: &quot;DMIBCNTFR&quot;,<br/>&quot;description&quot;: &quot;PMON BandWidth Counter Filter Register&quot;,<br/>&quot;csrDescription&quot;: &quot;PMON BW Counter Filter Register&quot;,<br/>&quot;addressOffset&quot;: &quot;0xb0c&quot;,<br/>&quot;condition&quot;: &quot;return derived.nPerfCounters&quot;,<br/>&quot;offsetStep&quot;: 16,<br/>&quot;fields&quot;: {<br/>&quot;descFields&quot;: [],<br/>&quot;reference&quot;: &quot;$HW_NCR_CSR/ncr_pmon_CSR.json#xBCNTFR&quot;<br/>}<br/>},<br/>{<br/>&quot;name&quot;: &quot;DMIBCNTMR&quot;,<br/>&quot;description&quot;: &quot;PMON BandWidth Counter Mask Register&quot;,<br/>&quot;csrDescription&quot;: &quot;PMON BW Counter Mask Register&quot;,<br/>&quot;addressOffset&quot;: &quot;0xbc4&quot;,<br/>&quot;condition&quot;: &quot;return derived.nPerfCounters&quot;,<br/>&quot;offsetStep&quot;: 16,<br/>&quot;fields&quot;: {<br/>&quot;descFields&quot;: [],<br/>&quot;reference&quot;: &quot;$HW_NCR_CSR/ncr_pmon_CSR.json#xBCNTMR&quot;<br/>}<br/>},</p><p><br/></p><h3 id="HowtointegratePMONintoNcoreunits-Generatinginterfacesandparamsforevent-filtering">Generating interfaces and params for event-filtering </h3><p>To support event-filtering feature, attributes like funit_id and user bits need to be sent to the PMON block, which are done through the <em>filterAttrInterfaces</em> interface array. In order to generate this interface array, it is recommended to first create a table as described below and then use that to generate the <em>filterAttrInterfaces</em> as explained below:</p><p>filterAttributesMap needs to be defined as follows:</p><p>                   var filterAttributesMap = [<br/>                                { <strong>eventIndex</strong>: 17, <strong>name</strong>:&quot;dtwreq_evt_&quot; , <strong>signals</strong>: { &quot;funit_id&quot;: wFUnitId, &quot;user&quot;: wUser } },  // Each filtering attribute is specified as a signal in the &quot;signals&quot; bundle<br/>                                { eventIndex: 18, name: &quot;dtrreq_evt&quot; , signals: { &quot;funit_id&quot;: wFUnitId, &quot;user&quot;: wUser} }<br/>                         ];</p><p>Each object in the above table must include the following properties:</p><ol><li><em>eventIndex: </em>Number of the event that is associated with this interface as specified in the event table for the Ncore unit.</li><li><em>name:</em> name/prefix of the interface and</li><li><em>signals: </em> A signal-bundle object with filter-attribute names as keys and their widths as values. </li></ol><p>The <strong>filterAttrInterfaces</strong> can then be generated from the above table as follows:</p><p>filterAttrInterfaces = genFilterAttrInterfaces( filterAttributesMap ) ; // Returns an array of InterfaceGeneric-type new-style interfaces</p><p><br/></p><p>The filterAttributesMap is also used to generate the <em>bwEvtMapping</em> param as follows:</p><p>                  var bwEvtMapping = generateBwEvtMapping( filterAttributesMap );</p><p>                  generateBwEvtMapping is a function in lib_utils which returns an array of event indexes coming from the input table.</p><p>The filter-attribute inputs are expected to be driven explicitly using Verilog <em>assign</em> statements in your TACHL code.</p><h2 id="HowtointegratePMONintoNcoreunits-IntegratingLatencysupporttoNcoreUnits"><strong>Integrating Latency support to Ncore Units</strong></h2><h3 id="HowtointegratePMONintoNcoreunits-AdditionofregistersinCSR-CPR.2"><strong>Addition of registers in CSR-CPR</strong></h3><p>{<br/>&quot;name&quot;: &quot;DMILCNTCR&quot;,<br/>&quot;description&quot;: &quot;PMON Latency Conter Control Register&quot;,<br/>&quot;csrDescription&quot;: &quot;PMON Latency Counter Control Register&quot;,<br/>&quot;addressOffset&quot;: &quot;0xbc8&quot;,<br/>&quot;condition&quot;: &quot;return true&quot;,<br/>&quot;offsetStep&quot;: 16,<br/>&quot;fields&quot;: {<br/>&quot;descFields&quot;: [],<br/>&quot;reference&quot;: &quot;$HW_NCR_CSR/ncr_pmon_CSR.json#xLCNTCR&quot;<br/>}<br/>}</p><h3 id="HowtointegratePMONintoNcoreunits-Parameters.1">Parameters</h3><p>A new parameter called nLatencyCounters needs to be defined in .tachl.cpr files and it needs to be passed to PMON block in Ncore units supporting latency counters. </p><p>{<br/>&quot;parameterName&quot;: &quot;nLatencyCounters&quot;,<br/>&quot;type&quot;: &quot;integer&quot;,<br/>&quot;parameterType&quot;: &quot;architecture&quot;,<br/>&quot;default&quot;: 16,<br/>&quot;minimum&quot;: 0,<br/>&quot;maximum&quot;: 32,<br/>&quot;formula&quot;: &quot;return unit.nLatencyCounters&quot;<br/>}</p><p>Also, the minimum and maximum of parameter nPerfCounters needs to be updated according to the Arch document. </p><h3 id="HowtointegratePMONintoNcoreunits-Generatinginterfacesforlatencybinning">Generating interfaces for latency binning</h3><ul><li>We recommend defining a signal bundle for the latency interface and reusing them for each interface in the <em>latencyInterfaces</em> array:  </li></ul><p>              var latencyInterfaceSignals = { alloc: 1, dealloc: 1 };</p><ul><li>Each interface in the <em>latencyInterfaces</em> array is expected to be a new style interface which can be generated by calling the function oldStyleToNewStyleGenericInterface in lib_utils.js. This function needs a direction and an old style interface as follows:  </li></ul><p>               pmonInterfaces = {....</p><p>                       latencyInterfaces: [<br/>                         oldStyleToNewStyleGenericInterface(&quot;slave&quot;, { name: &quot;read_latency_&quot;, signals: latencyInterfaceSignals }),<br/>                         oldStyleToNewStyleGenericInterface(&quot;slave&quot;, { name: &quot;wr_latency_&quot;, signals: latencyInterfaceSignals })<br/>                       ] <br/>               };</p><ul><li>Each signal in a latency interface is expected to be driven explicitly using Verilog <em>assign</em> statements in your TACHL code.</li></ul><p><br/></p>