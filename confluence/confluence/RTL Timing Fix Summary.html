<p>This pages lists all changes made to achieve 1.2GHz with 100% RVT for 1.6/1.7 release</p><h1 id="RTLTimingFixSummary-AIU">AIU</h1><ol><li> Path to / from<ol><li>specify the violation </li><li>specify the fix</li><li>specify if flops were added and if they are configurable at build time </li><li>specify if this is a critical path and adds latency</li><li>Verification</li></ol></li><li> .........</li></ol><h1 id="RTLTimingFixSummary-BridgeIO">Bridge IO </h1><ol><li>Path: <strong>FROM</strong> TC_R_sel_* <strong>TO</strong> tag memory input address and data<ol><li>The violation is about <strong>-40 ps</strong> via ctt.lookup_en, ctt.ctt_index, ctt.ctt_index_vld  (i.e. input to CTT lookup path) that is a combinatorial decode of TC_R_sel_* signals.</li><li>The fix is to generate ctt.lookup_en, ctt.ctt_index, ctt.ctt_index_vld direct from flops by decoding the corresponding TR_R_sel_* signals and latching it to flops during the TR stage.</li><li>Flops is needed. </li><li>This is not a latency critical path.</li><li>Verification is by running IOCache full regression.</li></ol></li><li>Path: <strong>FROM</strong> PCMCR_Mnt* reg <strong>TO</strong> tag memory input address<ol><li>The violation is about <strong>-32 ps</strong> via the pipeline_lkpsnp_ctrl_cache_addr_index that is an OR tree of three sources of addresses (snoop, lookup, maintenance) that is fed to an address-to-index generator. </li><li>The fix is to remove the other two sources of addresses (snoop, lookup) that is irrelevant in that path. Essentially the fix is to speed up  mntop_tagmem_raddr,   mntop_tagaddr.</li><li>No flops is needed. </li><li>This is not a latency critical path.</li><li>Verification is by running IOCache full regression that involves maintenance by address/index operations. </li></ol></li><li>Path: <strong>FROM</strong> pkt_sfi_cmd_req* and ace_acaddr <strong>TO</strong> tag memory input address<ol><li>The violation is about <strong>-32 ps</strong> via the pipeline_lkpsnp_ctrl_cache_addr_index that is an OR tree of three sources of addresses (snoop, lookup, maintenance) that is fed to an address-to-index generator. </li><li>The fix is to remove the source of address (maintenance) that is irrelevant in that path. Essentially the fix is to speed up  tagpipe_tag_rd_addr.</li><li>No flops is needed. </li><li>This is not a latency critical path.</li><li>Verification is by running IOCache full regression that involves maintenance by address/index operations. </li></ol></li><li>Path: <strong>VIA</strong> tag_mem_address <strong>TO</strong> tag memory input address<br/><ol><li>The violation is about <strong>-19 ps</strong> caused by the condA ? A : condB : B : condC ? C : D  that is effectively an if elseif elseif else   priority structure. </li><li>The fix is to replace the if elseif priority structure with an OR tree.</li><li>No flops is needed. </li><li>This is not a latency critical path.</li><li>Verification is by running IOCache full regression that involves maintenance by address/index operations.</li></ol></li><li>Path: <strong>VIA</strong> tagpipe_replay <strong>TO</strong> SnpRspFifo input<br/><ol><li>The violation is about <strong>-19 ps</strong> caused by tagpipe_replay.</li><li>The fix is to remove tagpipe_replay because tagpipe_replay is an irrelevant signal to snoop request; as tagpipe_replay is only for coherent read/write (i.e. lookup) request.</li><li>No flops is needed. </li><li>This is not a latency critical path.</li><li>Verification is by running IOCache full regression.</li></ol></li><li>Path: <strong>VIA</strong> tagpipe_TC_wrdata_PreEcc <strong>TO</strong> tag memory input data<br/><ol><li>The violation is about <strong>-3 ps</strong>  </li><li>The fix is to speed up tagpipe_TC_wrdata_PreEcc that is an OR tree by removing unnecessary tree branches that outputs zero. For example, state=IX=0 for fill in error, for mntop_flush, for snoop hit invalidate;  NRU bit=0 for mntop flush.</li><li>No flops is needed.</li><li>This is not a latency critical path.</li><li>Verification is by running IOCache full regression.</li></ol></li><li>Path: <strong>VIA</strong> tagpipe_replay <strong>TO</strong> tag memory input address and data<br/><ol><li>The violation is about <strong>-69 ps</strong> caused by the OR term &quot;utt_full &amp; utt_init_req&quot; in tagpipe_replay that is an input to the correctable_error_detected signal that is very timing critical. </li><li>The fix is to speed up tagpipe_replay by replacing the OR term &quot;utt_full &amp; utt_init_req&quot; with &quot;utt_full &amp; tagpipe_TC_R_vld &amp; ((TC_R_sel_lookup &amp; TC_allocate_override) | (TC_R_sel_mntop &amp; mntop_flush))&quot;. After this fix, the violation is down to -6 ps.</li><li>No flops is needed.</li><li>This is not a latency critical path.</li><li>Verification is by running IOCache full regression.</li></ol></li><li>Path: <strong>VIA </strong>way_selected <strong>TO</strong> tag memory input address and data<br/><ol><li>The violation is about <strong>-9 ps</strong> caused by way_selected </li><li>The fix is to speed up way_selected. Note that way_selected is always used for non-flush operation, therefore the flush_way in the way_selected expression is unnecessary and thus removed.</li><li>No flops is needed.</li><li>This is not a latency critical path.</li><li>Verification is by running IOCache full regression.</li></ol></li><li>...</li></ol><p> </p><h1 id="RTLTimingFixSummary-DCE">DCE </h1><ol><li> Path to / from<ol><li>specify the violation </li><li>specify the fix</li><li>specify if flops were added and if they are configurable at build time </li><li>specify if this is a critical path and adds latency</li><li>verification</li></ol></li><li> .........</li></ol><h1 id="RTLTimingFixSummary-DMI">DMI</h1><ol><li> Path: axi_mst_rvalid <strong>TO</strong> sfi_mst_req_*<ol><li>The violation is  <strong>-372ps</strong> This path is from AXI  to SFI, it is a zero cycle pass through path. The logic on this path reads the correct RTT/HTT entire goes through a bypass mux and then a Muxarb. As this is a pass-through path it has only 167ps to accomplish this.      </li><li>logic optimization would have given back only 50ps at max, as this would not fix the path. We decided to flop this path. A 2 entry non by-passable FIFO was added, A fifo is used to meet AXI ready valid flow control requirements.   </li><li>A build time configurable flop is added on the pass-through path. parameter used is <strong>&quot;useRspPipeStage&quot;</strong></li><li>Yes this is a latency critical path. </li><li>TB update required (<strong><span class="legacy-color-text-red2">Verification Pending</span></strong>)</li></ol></li><li> Path RTT/HTT <strong>TO</strong> SFI interface<ol><li>The violation is <strong>TBR </strong>this path is form memory output  to SFI it includes memory output delay,  ECC check, ECC correct and final mux arb. available time is 625ps out of which memory takes about 450ps. </li><li>Plan is to flop the memory output.(<strong><span class="legacy-color-text-red2">RTL change pending</span></strong>)</li><li>This will add a <span class="inline-comment-marker" data-ref="674a80f1-5c2d-42ba-b178-b1c7b1c2b4ab">non configurable</span> flop on the data path.</li><li>No this will not effect latency in non interleaved mode as DMI has a memory bypass path. In interleaved mode with RTT memory enabled we will see one clock cycle latency increment  </li><li>verification pending  <br/><br/></li></ol></li></ol><h1 id="RTLTimingFixSummary-ParameterChangeSummary">Parameter Change Summary  </h1><p> </p><pre>AgentAiuInfo[] : 
        useBypassPipeStage          : (user.agentInterfaces[].exportNonCoherentTransactions ? true : false ) // Adds a pipe stage apiece to AR, AW, W, B, and R channels between ACE and AXI (non-coherent transactions)</pre><pre>        useCdPipeStage              : user.agentInterfaces[].enableRegisteredExternalInterfaces // Adds a pipe stage to snoop data (between ACE CD-channel and SFI)</pre><pre>        useAgentInterfacePipeStage  : user.agentInterfaces[].enableRegisteredExternalInterfaces // <span class="Apple-tab-span"> </span>Adds a pipe stage to ACE/AXI input from the Agent.</pre><pre> </pre><pre>BridgeAiuInfo[] :</pre><pre>        useAgentInterfacePipeStage  : user.agentInterfaces[].enableRegisteredExternalInterfaces // <span class="Apple-tab-span"> </span>Adds a pipe stage to ACE/AXI input from the Agent.</pre><pre> </pre><pre>DmiInfo[] : </pre><pre>    	useRspPipeStage : user.memRegion[]. enableRegisteredExternalInterfaces  // Adds a pipe stage on the response path AXI to SFI</pre><p> </p><p><br/><br/></p>