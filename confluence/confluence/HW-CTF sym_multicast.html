<h1 id="HW-CTFsym_multicast-module_name">module_name</h1><p>sym_multicast</p><h1 id="HW-CTFsym_multicast-parameters">parameters</h1><p>Note: The parameters needed for Presto 1.0 are different a subset of these and documented below.</p><pre><span>{</span></pre><pre><span> interfaces:{</span></pre><pre>  clkInterface: {name: &quot;a_string&quot;, params: {}, direction: &quot;slave&quot;, interface: &quot;InterfaceCLK&quot;},</pre><pre>  intInterface: {name: &quot;a_string&quot;, params: {}, direction: &quot;master&quot;, interface: &quot;InterfaceINT&quot;},</pre><pre>  cfgInterface: {name: &quot;a_string&quot;, params: {}, direction: &quot;slave&quot;, interface: &quot;InterfaceAPB&quot;},</pre><pre>  protectionInterface: {name: &quot;a_string&quot;, params: {}, direction: &quot;master&quot;, interface: &quot;InterfacePROT&quot;}, // Optional based on protectionStyle</pre><pre>  inReqInterface:</pre><pre>    {name: &quot;a_string&quot;,</pre><pre>     params: {nVc: positive integer, wBus: positive integer, wProt: non negative integer},</pre><pre>     direction: &quot;slave&quot;, </pre><pre>     interface: &quot;InterfaceATP&quot;, </pre><pre>     pktDef: {params: {ATP Packet Params}, packet: &quot;a_string&quot;}},</pre><pre>  inRspInterfaces:</pre><pre>    {name: &quot;a_string&quot;,</pre><pre>     params: {nVc: positive integer, wBus: positive integer, wProt: non negative integer},</pre><pre>     direction: &quot;master&quot;, </pre><pre>     interface: &quot;InterfaceATP&quot;, </pre><pre>     pktDef: {params: {ATP Packet Params}, packet: &quot;a_string&quot;}},</pre><pre>  outReqInterfaces: [</pre><pre>    {name: &quot;a_string&quot;,</pre><pre>     params: {nVc: positive integer, wBus: positive integer, wProt: non negative integer},</pre><pre>     direction: &quot;master&quot;,</pre><pre>     interface: &quot;InterfaceATP&quot;,</pre><pre>     pktDef: {params: {ATP Packet Params}, packet: &quot;a_string&quot;}},</pre><pre>    {},{}],</pre><pre>  outRspInterface:[</pre><pre>    {name: &quot;a_string&quot;,</pre><pre>     params: {nVc: positive integer, wBus: positive integer, wProt: non negative integer},</pre><pre>     direction: &quot;slave&quot;,</pre><pre>     interface: &quot;InterfaceATP&quot;,</pre><pre>     pktDef: {params: {ATP Packet Params}, packet: &quot;a_string&quot;}},</pre><pre>    {},{}], //array depth must match outReqInterfaces array depth</pre><pre>  },</pre><pre>  id : integer, // ID of the multicast block. </pre><pre>  numLabels: integer, // 1 or greater</pre><pre>  labelProps: </pre><pre>    {labels: [strings,,]}, // depth = numLabels, value is default label in verilog constant form. </pre><pre>  createCSR: boolean, // true is default. False prevents block from writing CSR file. </pre><pre>  noRegs: boolean, // false is default. When true indicates registers do not exist and values into logic are hardcoded.</pre><pre>                   // noRegs does not affect the registers associated with interrupts</pre><pre>  enBufWrite: boolean, //default value is false. When true, it enables early response for buffered writes.<br/>  maskField: &quot;a_string&quot; // name and bits of mask field in ATP packet definition</pre><pre>    // When the maskField is empty, you can't get the width to the mask from some field in the packet, you need to get it from the length of trgPathLut or trgPathEgress.</pre><pre>    // When the maskField is empty, it means Multicast needs to broadcast to all target ports.</pre><pre>    // When the maskField is empty, the parameter mask2TrgGrp is ignored. </pre><pre>  arbType: &quot;a_string&quot;, // Used by arbiters between labels. </pre><pre>  weights: [0,1,...],    // depth is the number of labels.</pre><pre>  lckStyleValid: boolean, </pre><pre>  pktSize: int, // size of multicast packet, in beats, to be buffered in block. Does not have to be entire packet. </pre><pre>  numOutStanding : positive integer // Number of outstanding transactions </pre><pre>  mask2TrgGrp: [string,string,...], // Which mask bits are group to witch targets.</pre><pre>  trgPathLut: [{targ_id: int, route: string}, . . . ], // The route to the target from the multicast block</pre><pre>  trgPathEgress: [{targ_id: int, egress: int},. . .],  // The multicast block egress port to use for a target </pre><pre>  srcPathLut: [{targ_id: int, route: string}, . . . ], // The targ_id is the source id in the request packet.  </pre><pre>  protectionStyle: {protectionStyle)</pre><pre>}</pre><h1 id="HW-CTFsym_multicast-Description">Description</h1><p>Block Diagram shown below:</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16156510/MultiCastBlockDiagram.svg?api=v2"></span></p><p>The initial multicast block only supports multicasting writes.</p><p>The multicast block gets the multicast label from the ATP packet field H_multi_label. This field must be present in the request link packet definition. It is optional in the response link packet definition if there is only one label per multicast block.</p><p>The multicast block gets the packet mask from the parameter maskField, which is going to be the entirety of H_multi_mask or a continuous bit range of H_multi_mask. If the maskField is &quot;&quot; then the mask is only a function of register mask, Label_N_mask.</p><p>If packets are being routed by a route field, the multicast block uses the ATP packet field H_route. If there is no route field in the ATP packet definition, either request or response, the multicast block will assume H_tid is being used to in the fabric to route.</p><p>Each label has numOutStanding outstanding broadcast associated with it. The mask determines the targets a label will broadcast to and is the AND between the mask that comes with that packet (if no mask with packet, assumed all 1s) and the label's mask register. A label has an outstanding broadcast if at least one of the targets associated with a broadcast packet hasn't responded.</p><p>If a packet is marked as bufferable, a response will be sent by the the multicast block upon receipt of the entire broadcast packet. If not, then all responses from all targets must be received before a response is sent.  </p><p>The broadcast of a packet can happen in parallel to multiple egress ports.</p><h2 id="HW-CTFsym_multicast-Orderingrules">Ordering rules</h2><p>Responses from the multicast block is ordered with respect to incoming requests. Incoming requests are not allocated to a label block until all ordering rules are guaranteed. </p><h2 id="HW-CTFsym_multicast-Buffering">Buffering</h2><p>Buffering can be achieved by buffering the ATP links that enter and exit the block external to the block.</p><p>The multicast block does not require the entire packet to begin rebroadcast nor the ability to hold the entire packet to rebroadcast.</p><p>However, if multicast trees overlap in a given network, to prevent deadlock, those multicast blocks must be able to hold the maximum size packet that can be broadcast. </p><p>Another case that causes the need to buffer the entire packet is if the packet is being sent multiple times on the same egress port from the block. </p><h2 id="HW-CTFsym_multicast-Mask2TrgGrp">Mask2TrgGrp</h2><p>When maskField = &quot;&quot;, the incoming mask2TrgGrp is ignored and re-generated internally. This means software generated parameters can use the same algorithm to generate mask2TrgGrp regardless of the value of maskField.</p><p>The number of mask bits can be the same or greater than the number of targets. The mask2TrgGrp indicates the mapping of mask bits to targets. The strings are 0s and 1s, where a 1 indicates that particular mask bit is associated with the indicated target. A mask bit can only be one in a single entry in the mask2TrgGrp array. The mask2TrgGrp and trgPathLut are arrays with equal depth and the entries correlate one to one, so the first entry in the mask2TrgGrp corresponds to the first entry in the trgPathLut. </p><p>For example, if the number of mask bits and targets are the same, and example set of mask2TrgGrp for five mask bits and targets could be:</p><p style="margin-left: 30.0px;">mask2TrgGrp = ['00001',00010','00100','01000','10000']</p><p>If there were six mask bits and 2 targets, the maks2TrgGrp could be:</p><p style="margin-left: 30.0px;">mask2TrgGrp = ['000111','111000']</p><p>The bits a mask2TrgGrp group entry are bitwise ANDed with the bitwise AND of the incoming mask and label mask and then the bits are OR reduced. If the result is a 1, then a packet is sent to that target.  </p><p>The intended use case is for when sym_multicast blocks are being cascaded in a design. If there were two levels, the first level fanning out four in the second level and the second level blocks fanning out to four targets each for a total of 16 targets. The mask sent in the multicast packet is 16 bits wide and in the first level sym_multicast block is pointed at all 16 bits and a four entry mask2TrgGrp is created where four unique mask bits is set in each group. In the second level the sym_multicast is only directed to 4 bits out of the mask for each instance and the mask2TrgGrp will be four entry with a single mask bit set in each group. Here's an example of what it could be:</p><p><br/></p><p style="margin-left: 30.0px;">1st level sym_multicast<br/>maskField = 'H_user[31:16]'<br/>mask2TrgGrp = ['1111000000000000','0000111100000000','0000000011110000','0000000000001111'] <br/>2nd level sym_multicast 0<br/>maskField = 'H_user[31:28]'<br/>mask2TrgGrp = ['1000','0100','0010','0001']<br/>2nd level sym_multicast 1<br/>maskField = 'H_user[27:24]'<br/>mask2TrgGrp = ['1000','0100','0010','0001']<br/>2nd level sym_multicast 2<br/>maskField = 'H_user[23:20]'<br/>mask2TrgGrp = ['1000','0100','0010','0001']<br/>2nd level sym_multicast 3<br/>maskField = 'H_user[19:16]'<br/>mask2TrgGrp = ['1000','0100','0010','0001']  </p><h2 id="HW-CTFsym_multicast-RequestFlow">Request Flow</h2><p>Upon receiving a packet, the block will check if incoming label is available and ordering rules have been met. Referred to the CTL interface definition for ordering rules. Only then will the packet progress to the label block. In addition, there must be space in the context blocks. Each context block can store context for up to numOutstanding. Context will be indexed based on Label, Sequence Number and Source ID. For a given broadcast packet, Context will be stored in the Per Label Context Block. Context could be dynamic based on the label mask in the Per Resp Port Context Block, but because all blocks have the same number of context that can be stored, if the Per Label Context Block has a location available then all the Per Responses Port Context Blocks will have a location available. The Per Label Context Block will store a mask or count that indicates the how many ports are involved a given broadcast. The Pre Resp Port Context Block will have a count that indicates the number of responses for that port that are expected to return for a given broadcast.</p><p>If the incoming broadcast request is able to pass ordering, the label is available and it's able to allocate context, the request is transferred to the Label block. The label block stores the header of the request packet and determines which targets it needs to clone the message to. Each label block will be able to send to all outReq ports simultaneously. It can do this with either a storage structure that can be read in parallel by the number of outReq ports or it can have buffering per outReq port that it can place packet in. These structures should not be store and forward, but should begin requesting the Egress ports as soon as enough information to complete the first beat is available. </p><p>The label block with change the target and route in the incoming request packet, but leave all other fields unmodified.</p><p>Some fields of the request must be stored to drive the correct values in the response. This will only occur if both the request and response packet definitions have these fields:</p><ul><li>H_vnid</li><li>H_sid -&gt; Drives H_tid</li><li>H_msg_type_attr</li><li>H_msg_id</li><li>H_msg_seqnum</li><li>H_ordering_id</li><li>H_chi_id</li></ul><h2 id="HW-CTFsym_multicast-ResponseFlow">Response Flow</h2><p>The Per Response Port Context Block will key off a label, request srcID and sequence number to determine which context is being accessed. It will merge the response information for the number of request in indicate by it count register and when the count is complete, forward the merged response to the Per Label Context Block.</p><p>The  Per Label Context Block will store all context that is needed to generate a proper response and will accumulate responses from the Per Response Port Context Block and merge them. When it has received all response as indicate by it's count or mask, it will construct a response and send it unless ordering rules prevent it.</p><p>Some response fields will be driven from the context which originated from the response. Those fields are listed above.</p><h2 id="HW-CTFsym_multicast-SmiMux">SmiMux</h2><p>The SmiMux needs to follow locking conventions followed by the network in which it is embedded. For simplicity of arbitration the SmiMux can require the synchronization of ready and valids between the two sub interfaces.</p><h2 id="HW-CTFsym_multicast-LabelBlock">Label Block</h2><p>Label Block block diagram shown below:</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16156510/LabelBlock.svg?api=v2"></span></p><p>The Next Target block takes in a mask where each bit in the masks represents a potential target, 1 indicated send to the target and 0 indicating don't send to the target. The mask is stored internally and every time a packet is sent, the corresponding mask bit is cleared. Logic in the Next Target determines based on the mask if any targets are on a given out request port. If there is more than one it picks one of them to forward to the Packet Creation block. Once the packet creation block has successfully transmitted a packet to an out request port, it signals with the next signal that it is ready to accept the next packet. The next signal is used by the Next Target Block to clear the corresponding bit in its internally stored mask. When the mask is all cleared, the Next Target block asserts ready which cause the SMI bus bring in the next packet to command and Data registers.  </p><h1 id="HW-CTFsym_multicast-Presto1.0Version">Presto 1.0 Version</h1><h2 id="HW-CTFsym_multicast-parameters.1">parameters</h2><p>arbType, weights, lckStyleValid aren't needed in the Presto 1.0 version because the it only supports one label and these parameters control how labels are arbitrated for.</p><pre>{</pre><pre> interfaces:{</pre><pre>  clkInterface: {name: &quot;a_string&quot;, params: {}, direction: &quot;slave&quot;, interface: &quot;InterfaceCLK&quot;},</pre><pre>  intInterface: {name: &quot;a_string&quot;, params: {}, direction: &quot;master&quot;, interface: &quot;InterfaceINT&quot;},</pre><pre>  cfgInterface: {name: &quot;a_string&quot;, params: {}, direction: &quot;slave&quot;, interface: &quot;InterfaceAPB&quot;},</pre><pre>  protectionInterface: {name: &quot;a_string&quot;, params: {}, direction: &quot;master&quot;, interface: &quot;InterfacePROT&quot;}, // Optional based on protectionStyle</pre><pre>  inReqInterface:</pre><pre>    {name: &quot;a_string&quot;,</pre><pre>     params: {nVc: positive integer, wBus: positive integer, wProt: non negative integer},</pre><pre>     direction: &quot;slave&quot;, </pre><pre>     interface: &quot;InterfaceATP&quot;, </pre><pre>     pktDef: {params: {ATP Packet Params}, packet: &quot;a_string&quot;}},</pre><pre>  inRspInterfaces:</pre><pre>    {name: &quot;a_string&quot;,</pre><pre>     params: {nVc: positive integer, wBus: positive integer, wProt: non negative integer},</pre><pre>     direction: &quot;master&quot;, </pre><pre>     interface: &quot;InterfaceATP&quot;, </pre><pre>     pktDef: {params: {ATP Packet Params}, packet: &quot;a_string&quot;}},</pre><pre>  outReqInterfaces: [</pre><pre>    {name: &quot;a_string&quot;,</pre><pre>     params: {nVc: positive integer, wBus: positive integer, wProt: non negative integer},</pre><pre>     direction: &quot;master&quot;,</pre><pre>     interface: &quot;InterfaceATP&quot;,</pre><pre>     pktDef: {params: {ATP Packet Params}, packet: &quot;a_string&quot;}},</pre><pre>    {},{}],</pre><pre>  outRspInterface:[</pre><pre>    {name: &quot;a_string&quot;,</pre><pre>     params: {nVc: positive integer, wBus: positive integer, wProt: non negative integer},</pre><pre>     direction: &quot;slave&quot;,</pre><pre>     interface: &quot;InterfaceATP&quot;,</pre><pre>     pktDef: {params: {ATP Packet Params}, packet: &quot;a_string&quot;}},</pre><pre>    {},{}], //array depth must match outReqInterfaces array depth</pre><pre>  },</pre><pre>  id : integer, // ID of the multicast block. </pre><pre>  numLabels: integer, // 1 or greater</pre><pre>  labelProps: </pre><pre>    {labels: [strings,,]}, // depth = numLabels, value is default label in verilog constant form. </pre><pre>  createCSR: boolean, // true is default. False prevents block from writing CSR file. </pre><pre>  noRegs: boolean, // false is default. When true indicates registers do not exist and values into logic are hardcoded.</pre><pre>                   // noRegs does not affect the registers associated with interrupts</pre><pre>  maskField: &quot;a_string&quot; // name and bits of mask field in ATP packet definition </pre><pre>  pktSize: int, // size of multicast packet, in beats, to be buffered in block. Does not have to be entire packet. </pre><pre>  numOutStanding : positive integer // Number of outstanding transactions </pre><pre>  mask2TrgGrp: [string,string,...], // Which mask bits are group to witch targets.</pre><pre>  trgPathLut: [{targ_id: int, route: string}, . . . ], // The route to the target from the multicast block</pre><pre>  trgPathEgress: [{targ_id: int, egress: int},. . .],  // The multicast block egress port to use for a target </pre><pre>  srcPathLut: [{targ_id: int, route: string}, . . . ], // The targ_id is the source id in the request packet.  </pre><pre>  protectionStyle: {protectionStyle)</pre><pre>}</pre><p>The version being implemented for Presto 1.0 will have the following reductions in function:</p><ol><li>Only one label support per Multicast Block.</li><li>Only one packet will be sent to an egress port per request.</li></ol><p>Based on these restrictions, the Multicast Block will have the following block diagram:</p><p><br/></p><p>The need for the SmiMux goes away and there is no need to check order before sending to the Label Block. In addition, the Per Resp Port Context Block will not need to have a count or mask, because only one request will be outstanding per context and it will not need the functionality to merge requests. However, the Per Label Context Block will need its full functionality.</p><p>The Per Label Context Block generates error interrupt for any bufferable transaction that has error indicated in the its late response.</p><p>The number of targets per Multicast Block is limited to maximum 32 if the LABEL mask register is implemented and the number of mask bits is the same as the number of targets. Note that the number of mask bits can be the same or greater than the number of targets.</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16156510/MultiCastBlockDiagram_1.svg?api=v2"></span></p><h1 id="HW-CTFsym_multicast-ResponseMerging">Response Merging</h1><p>The H_msg_err bit fields from the multicast responses are merged into one response by ORing them together (because the H_msg_err bit fields are onehot encoded). The other bit fields - only those that must be used to drive the response - are taken from the bit fields from the request that are stored in the context table (Note that these bit fields from the request are used to drive early response if the request packet is marked bufferable).</p><h1 id="HW-CTFsym_multicast-TheLifeofaMulticastPacket">The Life of a Multicast Packet</h1><p>In the initiator ATU, the only thing that differentiates a normal packet from a multicast packet is the address of the transaction. When the address of the transaction hits in the multicast address space, it causes a different route and target ID to be put into the packet. There will be bits in the incoming user bits of the native interface that get mapped to fields H_multi_label and H_multi_mask (formally one field H_multi) but this mapping happens for all transactions. The thing to understand is from the viewpoint of the initiator there is only one transaction.</p><p>When a packet hits a multicast block, it will store context under the source id, multi_label and sequence number. What gets stored in context is a function of what’s in the two link packet descriptions (request and response flavors). </p><p>The number of transactions broadcast from the multicast block is a function of the multi_mask coming in, the mask2TrgGRp parameter and the csr mask register for the label stored in the packet. In the outgoing packet, two things are changed, the target ID and route.</p><p>The target ATU will generate a route for the response based on the H_multi_label value and source ID of the original transaction. The only way the target ATU differentiates a normal response vs a multicast response is by the H_multi_label field. This means that label 0 is reserved for normal transactions. This also means that H_multi_label will always be at least 1 bit even in a system that has only one broadcast tree.</p><p>Because the present multicast block only supports writes, it will be getting back from each of the packets broadcast a response. It must take those responses and merge them. To do this, it uses the target ID (which is the original source ID of the initiator ATU,) the multicast label and sequence number to merge the responses into one response. The only thing that is envisioned to be different at this time are the error fields. A merging function should be describe about how the error fields are merged. Once all the responses for a broadcast have been accumulated and all the ordering rules have been maintained, the multicast adapter forms a packet from context. It will look up the route using the target ID (the original source ID) from the srcPathLut.  If there are no errors this packet will look identical to the incoming responses except the route and srcID if it exists.</p><h1 id="HW-CTFsym_multicast-DeadlockAvoidance">Deadlock Avoidance</h1><p>In topologies that don't have cycles if there is only one multicast tree, than nothing needs to be done. If there are multiple multicast trees but they share no common resources on the broadcast side, nothing needs to be done. However, if they share common resources, such as a common ATP link or a common ATU target, then to avoid dead lock buffering associated with a multicast block must be able to store the largest multicast packet. The buffering can be built into the multicast block itself (through the use of pktSize) or it can put on the ATP links directly connected to the multicast block.</p><p>In topologies that have cycles, like a mesh, ring or toroid, a multicast block must be able to store the largest multicast packet. </p><p><br/></p><h1 id="HW-CTFsym_multicast-RTLMicro-architectureBlockDiagram">RTL Micro-architecture Block Diagram</h1><p><br/></p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16156510/MultiCastRTLmicroArchDiagram.svg?api=v2"></span></p><p><br/></p>