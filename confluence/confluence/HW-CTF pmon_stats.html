<h2 id="HW-CTFpmon_stats-module_name:">module_name<strong>:</strong></h2><p>pmon_stats</p><h2 id="HW-CTFpmon_stats-JavaScriptparameters:">JavaScript parameters:</h2><p><strong><em>nodeId</em> </strong>: a non-negative integer.</p><p><strong><em>tmrEvtMap</em></strong>: An array of objects. Each array element object defines a timer/counter. The object must have the following fields:<br/>{<br/>   <em>name</em> : A string parameter that specifies the name of a timer instance,<br/>   <em>width</em> : a positive integer. Width of the timer,<br/>   <em>start</em> : A string parameter to specify the signal or event to start the timer. Optional if skipped, this will be tied to a one,<br/>   <em>stop</em> : A string parameter to specify the signal or event to stop the timer. Optional if skipped, this will be tied to a zero,<br/>   <em>reset</em> : A string parameter to specify the signal or event to reset the timer. Optional if skipped, this will be tied to a zero,<br/>   <em>count</em> : A string parameter to specify the signal or event to increment the timer. Optional. If skipped, this will be tied to a one,<br/>   <em>wCount</em> : A positive number that specifies the width of the <em>count</em> input. Optional. If skipped, this will default to 1.<br/>   <em>en</em>: A string parameter to specify when the timer must be enabled. Optional. If skipped, this will be tied to a one.<br/>   <em>mode</em>: Must take one of the following values: &quot;2'd0&quot;: Wrap mode, &quot;2'd1&quot;: Freeze mode. &quot;2'd2&quot;: Run mode, &quot;2'd3&quot;: Load mode<br/>   <em>tmrEvt</em> : A string parameter that matches an event-name (See below). Optional. If skipped, timer won't have this output generated.<br/>   <em>internalState</em>: A boolean parameter. Default false. When true all timer state is stored inside the PMON Timers and no timer registers are created. When false timer state is created inside the register block so that they can be accessesible through the APB interface.<br/>  <em>pmonTmrAssertOn</em>: A boolean parameter. Default false. When true this enables some cover asserts to ensure timer expire and rollover conditions.</p><p>  // Filtering options<br/>  <em>filterOn </em>: A boolean that generates logic for low-pass filtering of the <em>count</em> input.<br/>  <em>alpha </em>: A string parameter that specifies an expression for controlling alpha. Ignored if <em>filterOn</em> is false.<br/>  <em>depth </em>: Filter depth (Width of depth + 1).<br/>  <em>precision</em>: Number of bits after the decimal point to be preserved. </p><p><br/>},</p><p><strong><em>evtDefines</em></strong>: An array of objects. The structure of such an object is described below: <br/>{<br/><em>name</em> : A string that specifies the name of an internal signal or event.<br/><em>width</em> : A positive integer that specifies the width of the signal or event.<br/><em>interrupt</em> : A Boolean true or false. True means this event should trigger interrupt. An interrupt bit is allocated in the INTVR register.<br/><em>outEvt </em>: A string that matches the name of one of the event names on the <em>evtInterfaces</em>. If not defined or empty-string, this event will remain internal to the block and doesn't go out as an output of the probe block.<br/><em>description</em>: Optional string parameter describing the event. This is passed to interrupt block if marked interrupt.<br/><em>conditions</em> : An array of strings each of which is expected to be a syntactically correct Verilog expression. The names of signals should match either one of the following:</p><ol><li>Names of events described in the <em>evtDefines</em> data-structure</li><li>User-defined register field described in the <em>regFieldDefines</em> data-structure</li><li>Register fields in Timer registers Val and Limit. Name of the signal is described as <em>RegisterName</em>_<em>FieldName_</em>out, where<em><em> RegisterName = 'TimerName</em>_</em>val' or '<em>TimerName</em>_limit', and <em>FieldName</em> = 'val' or 'limit'.</li><li>Verilog constant literal</li></ol><p><em>reduceOp</em>: A string. This parameter is ignored if the <em>conditions</em> array has only one element. The parameter can take the following values:</p><ol><li>&quot;|&quot;: Expressions in 'conditions' array will all be Or-ed to generate this event.</li><li>&quot;&amp;&quot;: Expressions in 'conditions array will be logically AND-ed.</li><li>&quot;?&quot;: Expressions in 'conditions' array will be multiplexed using the <em>'select</em>' lines  specified parameter to generate this event.</li></ol><p><em>select</em>: Optional parameter. Array of legal Verilog expressions of single-width (string). Must be specified if <em>reduceOp</em> = &quot;?&quot;, in which case each element of the array is interpreted as a one-hot select line for multiplexing.<em><br/>edgeDetect</em>: Optional parameter to detect posedge, negedge or simply flop the generated signal or event. It can take the following values: &quot;posedge, negedge, flop&quot;.<br/><em>edgeDetectEn</em>: Optional parameter to specify an enable signal for the <em>edgeDetect</em> flops.</p><p>}</p><p><strong><em>regFieldDefines</em></strong>: An array of objects each of which describes a user-defined register field. The structure of such an object is defined below:<br/>{<br/><em>  name</em> : A string that specifies the name of the internal event. This needs to match the name of the signal as used in the Verilog expressions in the <em>conditions</em> array in <em>evtDefines</em>.<br/>  <em>width</em> : A positive integer that specifies the width of the field.<br/>  <em>access</em> : A string that can take one of the following values - &quot;RW&quot;, &quot;RO&quot;.<br/><em>  description</em>: A string describing the register field.<br/>}</p><p><strong><em>protectionStyle</em></strong>: <a class="external-link" href="https://confluence.arteris.com/display/ENGR/protectionStyle" rel="nofollow">protectionStyle</a></p><p>An <strong>event-name</strong> string must match either</p><ol><li>An event name defined in <em>evtDefines </em>data-structure. or </li><li>An input event name i.e. name (property of that event)+&quot;_val&quot;</li></ol><p>If a timer event (<em>tmrEvt</em>) of a timer is to be used as an input event to another timer, then it must be defined in the evtDefines and then connected to the <em>tmrEvt</em> output of the driving timer.</p><p><br/></p><p><strong>Interfaces:</strong></p><p><em>clkInterface</em>: A slave interface of type <a class="external-link" href="https://confluence.arteris.com/display/ENGR/InterfaceCLK" rel="nofollow">InterfaceCLK</a>.</p><p><em>cfgInterface</em>: A slave interface of type <a class="external-link" href="https://confluence.arteris.com/display/ENGR/InterfaceAPB" rel="nofollow">InterfaceAPB</a>. This interface is used to program the probe registers.</p><p><em>evtInterfaces</em>: An array of slave interfaces of type <a class="external-link" href="https://confluence.arteris.com/display/ENGR/InterfaceEvt" rel="nofollow">InterfaceEvt</a>.</p><p><em>protInterface</em>: (Optional interface. Not in Presto 1.0). A master interface of type <a class="external-link" href="https://confluence.arteris.com/display/ENGR/InterfacePROT" rel="nofollow">InterfacePROT</a>.</p><p><em>intInterface</em>: Optional. A master interface of type <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16160508/InterfaceINT" data-linked-resource-id="16160508" data-linked-resource-version="3" data-linked-resource-type="page">InterfaceINT</a>.</p><p><em>ctiInterface</em>: (Optional interface for future use. Not in Presto 1.0). A slave interface of type InterfaceCTI.</p><h2 id="HW-CTFpmon_stats-ModulesUsed">Modules Used</h2><div><strong><strong><a class="external-link" href="https://confluence.arteris.com/display/ENGR/sym_apb_csr" rel="nofollow">sym_apb_csr</a></strong></strong></div><div><strong><strong><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16170326/HW-CTF+pmon_tmr" data-linked-resource-id="16170326" data-linked-resource-version="14" data-linked-resource-type="page">HW-CTF pmon_tmr</a></strong></strong></div><div><strong><strong><br/></strong></strong></div><div><h2 id="HW-CTFpmon_stats-BlockDescription">Block Description</h2><p>The link probe or the pmon_probe block listens to packets on an ATP link. It can be configured to read specific fields in packets which can then be used</p><p><br/></p><p><span class="confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image image-center" height="250" src="https://arterisip.atlassian.net/wiki/download/attachments/16163552/image2019-12-5%2015:29:43.png?api=v2"></span></p><p><br/></p><p>The PMON stats consists of the following sub-blocks:</p><ol><li>Timers. This block contains a set of PMON Timers. Each of these timers has:<ol><li>A <em>cfgTmrInterface</em> which are bits coming from and going to the APB CSR Block for software control.</li><li>An <em>evtTmrInterface</em> which includes:</li></ol></li></ol><p>                                                               i.      Input events to the timer – start, stop, count, reset</p><p>                                                             ii.      An Output event from the timer - tmr</p><ol><li>APB CSR: This implements a set of configuration registers to configure each of the timers in the <em>tmrEvtMap</em>, and a set of select values to choose from, from a pool of input and internal events as described in the <em>tmrEvtMap</em> data-structure. The CSR structure for this block is generated, based on <em>tmrEvtMap</em>, dynamically during TACHL run.</li><li>Input Events Mapping: This consists of a set of muxes and wire-mappings of input events, <em>iEvt</em>[X], and internal events, <em>tEvt</em>[X], to <em>evtTmrInterface </em>interfaces of all the Timers. The wire-mappings are done based on the <em>iEvtMap</em> object in the <em>tmrEvtMap</em>.</li><li>Output Events Mapping: This is just a set of wire-mapping of all timer outputs (‘<em>tmr</em>’) to output events, <em>oEvt</em>[X], and internal events, <em>tEvt</em>[X]. The wire-mappings are done based on the <em>oEvtMap</em> object in the <em>tmrEvtMap</em>.</li></ol><h2 id="HW-CTFpmon_stats-RegisterDescriptions">Register Descriptions</h2><p>The number of registers the probe block will have depends on the parameters <em>tmrEvtMap</em>, <em>evtDefines</em>, and <em>regFieldDefines</em>. The exact number of registers generated can be calculated this way:</p><p>Number of timer registers = <em>tmrEvtMap</em>.length * 4.<br/>Number of select registers = 1 if (ceil(log2(<em>evtDefines</em>[ i ].conditions.length)) &gt; 0) else 0, for i from 0 to number of events in evtDefines-1<br/>Number of user-defined registers = <em>regFieldDefines</em>.length;<br/>Number of global registers = 2.</p><p>Total Number of registers = global registers + user-defined registers + select registers + timer registers.      </p><h4 id="HW-CTFpmon_stats-1.1.1PMON_STATS_USER_N(N=0,1,2,…)">1.1.1      PMON_STATS_USER_<em>N</em> (N = 0,1, 2, …)</h4><p>These registers are generated to hold register-fields defined in the <em>regFieldDefines</em> data-structure. Currently a separate register is generated for each register field in the <em>regFieldDefines</em> data-structure. However, this might change in future to optimize utilization of an address space.</p><p><br/></p><div class="table-wrap"><table class="wrapped confluenceTable"><tbody><tr><td class="confluenceTd"><p>Field</p></td><td class="confluenceTd"><p>Bits</p></td><td class="confluenceTd"><p>RW</p></td><td class="confluenceTd"><p>Parameterized</p></td><td class="confluenceTd"><p>Description</p></td></tr><tr><td class="confluenceTd"><p align="center">Matches the name of field in <em>regFieldDefines</em></p></td><td class="confluenceTd"><p>Matches the width of field in <em>regFieldDefines</em></p></td><td class="confluenceTd"><p>RW</p></td><td class="confluenceTd"><p>Yes</p></td><td class="confluenceTd"><p>Used to generate conditional events according to user-specified conditions</p></td></tr></tbody></table></div><p><br/></p><h4 id="HW-CTFpmon_stats-1.1.3TimerName_val">1.1.3      <em>TimerName</em>_val</h4><p>This register holds the current timer or counter value. This register is created only if <em>internalState</em> is set to false for the timer in the <em>tmrEvtMap</em>.</p><p><br/></p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/><col/></colgroup><tbody><tr><td class="confluenceTd"><p>Field</p></td><td class="confluenceTd"><p>Bits</p></td><td class="confluenceTd"><p>SW access</p></td><td class="confluenceTd"><p>Parameterized</p></td><td class="confluenceTd"><p>Description</p></td></tr><tr><td class="confluenceTd"><p>Val</p></td><td class="confluenceTd"><p>W = ‘<em>width</em>’ in <em>tmrEvtMap</em></p></td><td class="confluenceTd"><p>RO</p></td><td class="confluenceTd"><p>No</p></td><td class="confluenceTd"><p>Current timer value</p></td></tr></tbody></table></div><p><br/></p><h4 id="HW-CTFpmon_stats-1.1.4TimerName_limit">1.1.4      <em>TimerName</em>_limit</h4><p>This register holds the limit or threshold value used to generate the timer output event. This register is created only if <em>internalState</em> is set to false for the timer in the <em>tmrEvtMap</em>.</p><p><br/></p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/><col/></colgroup><tbody><tr><td class="confluenceTd"><p>Field</p></td><td class="confluenceTd"><p>Bits</p></td><td class="confluenceTd"><p>SW access</p></td><td class="confluenceTd"><p>Parameterized</p></td><td class="confluenceTd"><p>Description</p></td></tr><tr><td class="confluenceTd"><p>limit</p></td><td class="confluenceTd"><p>W = ‘<em>width</em>’ in <em>tmrEvtMap</em></p></td><td class="confluenceTd"><p>RW</p></td><td class="confluenceTd"><p>No</p></td><td class="confluenceTd"><p>Limit value for comparison with timer value to generate timer output event.</p></td></tr></tbody></table></div><p><br/></p></div>