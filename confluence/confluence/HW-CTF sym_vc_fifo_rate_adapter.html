<h1 id="HW-CTFsym_vc_fifo_rate_adapter-module_name"><strong>module_name</strong></h1><p>sym_vc_fifo_rate_adapter</p><h1 id="HW-CTFsym_vc_fifo_rate_adapter-parameters"><strong>parameters</strong></h1><pre>{</pre><pre>  &quot;numPri&quot; : positive number 1 or greater.</pre><pre>  &quot;mstrArbLck&quot; : true or false,</pre><pre>  &quot;mstLckStyleVld&quot; : true or false,</pre><pre>  &quot;arbType&quot; : &quot;string&quot;,  // Any arbType allowed by sym_switch.</pre><pre>  &quot;arbRdyAware&quot; : true or false,</pre><pre>  &quot;weights&quot; : [wl,wm,wn], // if arbType arb_wrr_*, what are the weights.</pre><pre>  &quot;weightsProg&quot; true or false, // if the weights are programmable, the weights above represent registers widths, if not, represent hard value weights.</pre><pre>  interfaces: {</pre><pre>    clkInterface: {name: &quot;a_string&quot;, params: {}, direction: &quot;master&quot; or &quot;slave&quot;, interface: &quot;a_string&quot;},  // Optional based on depth &gt; 0</pre><pre>    protectionInterface: {name: &quot;a_string&quot;, params: {}, direction: &quot;master&quot; or &quot;slave&quot;, interface: &quot;a_string&quot;}, // Optional based on protectionStyle</pre><pre>    inInterface: </pre><pre>      {name: &quot;a_string&quot;,</pre><pre>       params: {interface parameters},</pre><pre>       direction: &quot;slave&quot;, </pre><pre>       _SKIP_: false, </pre><pre>       pktStyle: &quot;serial&quot;, &quot;parallel&quot; or &quot;fixed&quot;, </pre><pre>       wData: int // power of 2 8 or greater. </pre><pre>       pktDef: {packet: &quot;a_string&quot;} // link packet definition</pre><pre>       interface: &quot;InterfaceATP&quot;}, // Interface must have a 1 bit wide ready and valid.</pre><pre>    outInterface:</pre><pre>      {name: &quot;a_string&quot;,</pre><pre>       params: {interface parameters}, // parameters must match inInterface</pre><pre>       direction: &quot;master&quot;, </pre><pre>       _SKIP_: false </pre><pre>       pktStyle: &quot;serial&quot;, &quot;parallel&quot; or &quot;fixed&quot;, </pre><pre>       wData: int // power of 2 8 or greater. </pre><pre>       pktDef: {packet: &quot;a_string&quot;} // link packet definition</pre><pre>       interface: &quot;InterfaceATP&quot;}, // Interface must match inInterface </pre><pre>    genericIoMem : [ </pre><pre>      {name: &quot;a_string&quot;, // The name of the memory module is derived from the name of the generic interface</pre><pre>       params: {interface parameters}, </pre><pre>       interfaceObjType: &quot;a_string&quot;, //matches the interfaceObjType in MemoryGeneration</pre><pre>       direction: &quot;slave&quot;, </pre><pre>       _SKIP_: boolean // true means interface is removed, false means interface is instanced</pre><pre>       interface: &quot;InterfaceGeneric&quot;</pre><pre>    ]</pre><pre>  }, </pre><pre>  &quot;lckStyleVld&quot; : boolean, // defaults to false</pre><pre>  &quot;split&quot; : boolean, // Split off header field from data if true and pktStyoe = parallel, otherwise ignored (default is false)</pre><pre>  &quot;ratio&quot; : [I,J], // I is then number of in valid beats per J beats on the output. Specifies ratio of beats.</pre><pre>  &quot;depth&quot; : 4 or greater integer, // The depth of the pipeline. </pre><pre>  &quot;hDepth&quot; : 0 or any positive integer, // If split=true and pktStyle=parallel, depth of header FIFO, </pre><pre>                                        // If split=true and pktStyle~=parallel, FIFO depth is depth+hDepth, otherwise ignored. Default is 0. </pre><pre>  &quot;portType&quot; : &quot;a_string&quot;, // 2p or 1p. Indicates port style on SRAM  </pre><pre>  &quot;MemoryGeneration&quot;: [</pre><pre>  {&quot;rtlPrefixString&quot;: &quot;a_string&quot;, // deprecated, must match corresponding generic interface name. </pre><pre>   &quot;memoryType&quot; : &quot;a_string&quot;, // NONE or SYNOPSYS. Type of memory to be generated </pre><pre>   &quot;interfaceObjType: &quot;a_string&quot; // Used to match memory to genericInterface</pre><pre>  },</pre><pre>  ],</pre><pre>  &quot;protectionStyle&quot; : <a class="external-link" href="https://confluence.arteris.com/display/ENGR/protectionStyle" rel="nofollow">protectionStyle</a>}</pre><pre>}</pre><pre><strong style="font-size: 24.0px;font-family: Arial , sans-serif;">Modules Used</strong></pre><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156387/HW-CTF+sym_fifo_rate_adapter" data-linked-resource-id="16156387" data-linked-resource-version="2" data-linked-resource-type="page">HW-CTF sym_fifo_rate_adapter</a></p><p><a class="external-link" href="https://confluence.arteris.com/display/ENGR/sym_switch" rel="nofollow">sym_switch</a></p><h1 id="HW-CTFsym_vc_fifo_rate_adapter-Description"><strong>Description</strong></h1><p><strong><strong>ratio: </strong></strong>I represents the number of valid beats per J beats on the output. So, if a packet is coming into the block with a valid every other beat, which can happen from a data width adapter, then I = 1 and J = 2. Another way of saying this is the in side has a bubble every other cycle. If the in side has a bubble once ever three cycles, then I = 2 and J = 3. If the in side had two bubbles every 5 cycles, then I = 3 and J = 5<strong>.</strong></p><p>The block diagram is shown below for numVc equal 3. &quot;n&quot; equals numVc parameter.</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16156531/vc_fifo_rate_adapter.svg?api=v2"></span></p><p>A sym_fifo_rate adapter is put down per VC and inInterface is split into the a separate single VC interface per VC. This is done purely with wires, where the vector valids are split to form single valids to the sym_fifo_adapters and the ready signals from the sym_fifo_rate_adapters are concatenated together to form the VC ready. A similar wire munging happens from the output of the sym_fifo_rate_adapters to the sym_switch. The sym_switch is configured such that it only has a master arbiter.</p><p>As mentioned in the documentation for the sym_fifo_adapter, the genericIO are matched up with the memories by the use of the interfaceObjType parameters in genericMemIo array entries and MemoryGeneration array entries. The only values supported are in the form of &quot;pipe_vcN&quot; where N represents the VC number. This is how the memory is associated with a VC.</p><h1 id="HW-CTFsym_vc_fifo_rate_adapter-Presto1.0Implementation"><strong>Presto 1.0 Implementation</strong></h1><p>weightsProg is always false. There is no support for runtime programmable weights.</p>