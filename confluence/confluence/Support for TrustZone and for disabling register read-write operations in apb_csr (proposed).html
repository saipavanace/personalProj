<p>The proposal is to implement two new JSON parameters for the <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16171929/apb_csr" data-linked-resource-id="16171929" data-linked-resource-version="3" data-linked-resource-type="page">apb_csr</a> block:</p><ol><li>&quot;<strong>tzEn</strong>&quot;: A Boolean type. If true this will create single-bit <em>regName_tz</em> input ports per register for <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16171929/apb_csr" data-linked-resource-id="16171929" data-linked-resource-version="3" data-linked-resource-type="page">apb_csr</a> block, where regName is the name of the register.</li><li>&quot;<strong>regOpEn</strong>&quot;: A Boolean type. If true this will create single-bit <em>regName_wr_en</em> inputs and single-bit <em>regName_rd_en</em> inputs per register, for the apb_csr block.</li></ol><p> </p><p>A <em>regName_wr_en</em> input signal will disable writing for the associated register when low. And a <em>regName_rd_en</em> input signal will disable reading for the associated register (returns zero on data bus).</p><p>A <em>regName_tz</em> input signal will disable writing and reading for the associated register if the value on it differs from that on the PPROT[1] (Secure(0) or Non-secure(1)) signal on the APB interface.</p><p> </p><p>The proposed solution is an attempt to also support security features involving writing a certain key into a certain register to disable writing and reading into other registers. But it is more generic in the sense that any block that instantiates the <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16171929/apb_csr" data-linked-resource-id="16171929" data-linked-resource-version="3" data-linked-resource-type="page">apb_csr</a> can now implement it's own logic to control when the read or write operations on a set of registers can be disabled.</p><h1 id="SupportforTrustZoneandfordisablingregisterread-writeoperationsinapb_csr(proposed)-FlowSupport">Flow Support</h1><p>While modifying the hardware to support this is relatively simple, extra work needs to be done to determine if our RAL verification flow can support the functionality automatically. The steps are as follows:</p><ol><li>A csr is generated (from either CPR or the block itself) that feeds the apb_csr block.</li><li>The csr is passed through stitcher to generate an IP-XACT description</li><li>Maestro SW joins all the IP-XACT descriptions together into a single IP-XACT description.</li><li>The unified IP-XACT description is pass to our automated register verification software to verify the IP-XACT description match the behavior.</li></ol><p>To automate this we would have to add keywords to the csr to identify registers that can lose their ability to read and write based on other register transactions in a defined sequence. The new keyword would have to be added to stitcher and map it to a corresponding IP-XACT format that documents this behavior.</p><p>If no such support can be found in the IP-XACT universe, then implementing this functionality would render the registers unverifiable by automated means and therefore unverifiable by our automated test benches that we provide to the customer. Then a decision will have to be made whether this functionality is exposed to customers because of the risk incurred by not being able to automatically verify the functionality.</p><p>There are other examples where we provide functionality with no means to automatically verify it. This functionality exists in the firewall adapter and the PMON (basically any place a customer can drop in a custom verilog statement.) </p><p> </p><p> </p>