<h1 id="req_rsp_mux-SWVisible:"><strong>SW Visible:</strong></h1><p>no</p><h1 id="req_rsp_mux-Parameters:"><strong>Parameters:</strong></h1><h2 id="req_rsp_mux-Javascript:"><strong>Javascript:</strong></h2><pre>{</pre><pre>  &quot;requestInterfaces&quot; : [ {<br/>                             &quot;name&quot; : String,<br/>                             &quot;signals&quot; : {}, // Signal Width Pair<br/>                             &quot;hasLast&quot; : boolean, // Indicates if packet is multiple beats<br/>                             &quot;numInterfaces&quot; : int, // Number of interfaces of this type<br/>                             &quot;selectionMap&quot; : String, // Signal name to concatenate selection to. Empty Means no map. // Optional<br/>                          }, ...],</pre><pre>  &quot;responseInterfaces&quot; : [ {<br/>                             &quot;name&quot; : String,<br/>                             &quot;signals&quot; : {}, // Signal Width Pair.<br/>                             &quot;hasLast&quot; : boolean, // Indicates if packet is multiple beats<br/>                             &quot;numInterfaces&quot; : int, // Number of interfaces of this type<br/>                             &quot;selectionMap&quot; : String, // Signal name to concatenate selection to. Empty Means no map. // Optional<br/>                             &quot;demuxSignal&quot; : String // Verilog String to select how to demux interface. (Could be same as selectionMap)<br/>                          }, ...],</pre><pre>}</pre><h2 id="req_rsp_mux-Verilog:"><strong>Verilog:</strong></h2><p>N/A</p><h1 id="req_rsp_mux-I/O:"><strong>I/O:</strong></h1><pre>// Incoming Request Interfaces<br/>for (i = 0; i &lt; requestInterfaces.length; i++) {<br/>    for (interface = 0; interface  &lt; requestInterfaces[i].numInterfaces; interface++) {</pre><pre>       u.interface('in_req_'+i+'_'+requestInterfaces[i].name,'slave',requestInterfaces[i].signals);<br/>    }<br/>}<br/><br/>// Outgoing Request Interface</pre><pre>for (i = 0; i &lt; requestInterfaces.length; i++) {<br/>   u.interface('out_req_'+requestInterfaces[i].name,'master',requestInterfaces[i].signals, [requestInterfaces[i].signals.selectionMap]); <br/>   if (requestInterfaces[i].signals.selectionMap != &quot;&quot;) <br/>       u.port('out_req_'+requestInterfaces[i].name+'_'+requestInterfaces[i].selectionMap,'master',requestInterfaces[i].signals[requestInterfaces[i].signals.selectionMap]+log2(requestInterfaces[i].numInterfaces))<br/>}<br/><br/></pre><pre>// Outgoing Response Interfaces<br/>for (i = 0; i &lt;.length; i++) {<br/>    for (interface = 0; interface  &lt; responseInterfaces[i].numInterfaces; interface++) {</pre><pre>       u.interface('out_resp_'+i+'_'+responseInterfaces[i].name,'master',responseInterfaces[i].signals);<br/>    }<br/>}<br/><br/>// Incoming Response Interface</pre><pre>for (i = 0; i &lt; responseInterfaces.length; i++) {<br/>   u.interface('in_resp_'+responseInterfaces[i].name,'slave',responseInterfaces[i].signals, [responseInterfaces[i].signals.selectionMap]);<br/>   if (requestInterfaces[i].signals.selectionMap != &quot;&quot;) <br/>       u.port('in_resp_'+responseInterfaces[i].name+'_'+responseInterfaces[i].selectionMap,'slave',responseInterfaces[i].signals[requestInterfaces[i].signals.selectionMap]+log2(responseInterfaces[i].numInterfaces))<br/>}</pre><h1 id="req_rsp_mux-FunctionsUsed:"><strong>Functions Used:</strong></h1><p><br/></p><h1 id="req_rsp_mux-ModulesUsed:"><strong>Modules Used:</strong></h1><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16160324/rr_arb_comb_mux" data-linked-resource-id="16160324" data-linked-resource-version="2" data-linked-resource-type="page">rr_arb_comb_mux</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16155739/logic_tree" data-linked-resource-id="16155739" data-linked-resource-version="15" data-linked-resource-type="page">logic_tree</a></p><p>ao_mux</p><h1 id="req_rsp_mux-Description:"><strong>Description:</strong></h1><p>This mux is used to mux out different request types and demux responses coming back. The feature set will include </p><ul style="list-style-type: square;"><li>The ability to define multiple request interfaces using signal bundles.</li><li>The ability to arbitrate between multiple request interfaces of a certain request interface type.</li><li>Ability to insert selection inside the outgoing request message.</li><li>The ability to define multiple response interfaces using signal bundles.</li><li>The ability to demux between multiple response interfaces of a certain response interface type.</li><li>Ability to mask certain fields going back.</li><li>Ability to demux based on logic of the response signaling.</li></ul><p>Limitations: Only a single downstream request and response channel per interface type. </p><h1 id="req_rsp_mux-UseCase:"><strong>Use Case:</strong></h1><h2 id="req_rsp_mux-IOAIU">IOAIU</h2><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="900" src="https://arterisip.atlassian.net/wiki/download/attachments/16166303/image2022-1-14_13-5-44.png?api=v2"></span></p><p>The Core Mux (req_rsp_mux) will be used to arbitrate and demux Concerto Messages to and from each of the cores through a master Concerto Mux. In addition the Core Mux will be responsible for inserting and masking the message id field of all messages used to control the internal mux and demuxing.</p><p>The Core Mux (req_rsp_mux) will look at the top bits of the r_message_id or the SNP Address to demux a response message. </p><p>The Core Mux (req_rsp_mux) will use RR arbitration to select a Core to service.</p><p><br/></p><p><br/></p><p><br/></p>