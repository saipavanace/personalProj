<h1 id="protectionScheme-Format:">Format:</h1><pre>{</pre><pre>  &quot;all&quot; : [protectionList],  // All signals forward (outputs), every beat. If specified, no H or FC can be specified.</pre><pre>  H : [protectionList], //All signals forward on header beats. Can be further subdivided into H_0, H_1 . . . </pre><pre>  FC : [protectionList], //All signals forward on data beats. Can't be subdivided.</pre><pre>  &quot;all_b&quot; : [protectionList], // All signals backward (inputs), every beat. Backward doesn't support H and FC styles.</pre><pre>}</pre><h1 id="protectionScheme-FormatofprotectionListelements:">Format of protectionList elements:</h1><pre>{ signals : [], // array of signals. &quot;all&quot; represents all signals. Portions of signals can be specified</pre><pre>  protectionStyle : {<a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16169044/protectionStyle" data-linked-resource-id="16169044" data-linked-resource-version="15" data-linked-resource-type="page">protectionStyle</a>} // Same definition as used in registers. All signals above concatenated in order and have the protectionStyle applied to them.</pre><pre>}</pre><h1 id="protectionScheme-Description:">Description:</h1><p>ProtectionSchemes apply to interfaces. There is an assumption that there will a outgoing signal named &quot;sb_prot&quot; which contains all the protections bits generated concated in the order that are described in protectionList for the output signals and a signal name &quot;sb_prot_b&quot; for all the input signals.</p><p>When multiple schemes are described for header and data beats, the scheme that requires the widest prot bits sets the width of prot and the smaller is right justified in field.</p><p>For an interface, all forward signals must be covered by a protectionStyle. If the signals are not covered, then protectionStyle.protection = 'none'.</p><h1 id="protectionScheme-Examples:">Examples:</h1><pre>I have an ATP Interface:</pre><pre>{&quot;name&quot; : &quot;a_&quot;,<br/> &quot;params&quot; : {&quot;nVc&quot; : 1, &quot;wBus&quot; : 46, &quot;wProt&quot; : 9, &quot;wProt_b&quot; : 0},<br/> &quot;interface&quot; : &quot;InterfaceATP&quot;,<br/> &quot;lnkPktDef&quot; : {&quot;params&quot; : {}, &quot;packet&quot;: &quot;PacketATP_a&quot;}<br/>}</pre><pre>The signal defintions for an InterfaceATP are:</pre><pre>{&quot;valid&quot;: nVc, &quot;ready&quot;: -nVc, &quot;first&quot;: 1, &quot;last&quot;: 1, &quot;bus&quot; : wBus, &quot;sb_prot&quot; : wProt}</pre><pre>The field definitions for PacketATP_a are: </pre><pre>[{&quot;type&quot;: &quot;H&quot;, &quot;name&quot;: &quot;H_route&quot;,  &quot;width&quot;: 3,  &quot;minWidth&quot;: 0, &quot;mf&quot;: &quot;&quot;,   &quot;payload&quot;: 0}, // bus[45:43] first beat</pre><pre> {&quot;type&quot;: &quot;H&quot;, &quot;name&quot;: &quot;H_pri&quot;,    &quot;width&quot;: 1,  &quot;minWidth&quot;: 0, &quot;mf&quot;: &quot;&quot;,   &quot;payload&quot;: 0}, // bus[42] first beat</pre><pre> {&quot;type&quot;: &quot;H&quot;, &quot;name&quot;: &quot;H_tid&quot;,    &quot;width&quot;: 1,  &quot;minWidth&quot;: 0, &quot;mf&quot;: &quot;&quot;,   &quot;payload&quot;: 0}, // bus[41] first beat</pre><pre> {&quot;type&quot;: &quot;H&quot;, &quot;name&quot;: &quot;H_tier&quot;,   &quot;width&quot;: 4,  &quot;minWidth&quot;: 0, &quot;mf&quot;: &quot;&quot;,   &quot;payload&quot;: 0}, // bus[40:37] first beat</pre><pre> {&quot;type&quot;: &quot;F&quot;, &quot;name&quot;: &quot;F_data_0&quot;, &quot;width&quot;: 32, &quot;minWidth&quot;: 8, &quot;mf&quot;: &quot;&quot;,   &quot;payload&quot;: 1}, // bus[36:5] first beat</pre><pre> {&quot;type&quot;: &quot;F&quot;, &quot;name&quot;: &quot;F_be_0&quot;,   &quot;width&quot;: 4,  &quot;minWidth&quot;: 1, &quot;mf&quot;: &quot;&quot;,   &quot;payload&quot;: 1}, // bus[4:1] first beat</pre><pre> {&quot;type&quot;: &quot;C&quot;, &quot;name&quot;: &quot;C_err_0&quot;,  &quot;width&quot;: 1,  &quot;minWidth&quot;: 0, &quot;mf&quot;: &quot;OR&quot;, &quot;payload&quot;: 1}, // bus[0] first beat</pre><pre> {&quot;type&quot;: &quot;N&quot;, &quot;name&quot;: &quot;NULL_0&quot;,   &quot;width&quot;: 9,  &quot;minWidth&quot;: 0, &quot;mf&quot;: &quot;&quot;,   &quot;payload&quot;: 1}, // bus[45:37] 2nd-&gt;all beats</pre><pre> {&quot;type&quot;: &quot;F&quot;, &quot;name&quot;: &quot;F_data_1&quot;, &quot;width&quot;: 32, &quot;minWidth&quot;: 8, &quot;mf&quot;: &quot;&quot;,   &quot;payload&quot;: 1}, // bus[36:5] 2nd-&gt;all beats</pre><pre> {&quot;type&quot;: &quot;F&quot;, &quot;name&quot;: &quot;F_be_1&quot;,   &quot;width&quot;: 4,  &quot;minWidth&quot;: 1, &quot;mf&quot;: &quot;&quot;,   &quot;payload&quot;: 1}, // bus[4:1] 2nd-&gt;all beats</pre><pre> {&quot;type&quot;: &quot;C&quot;, &quot;name&quot;: &quot;C_err_1&quot;,  &quot;width&quot;: 1,  &quot;minWidth&quot;: 0, &quot;mf&quot;: &quot;OR&quot;, &quot;payload&quot;: 1}] // bus[0] 2nd-&gt;all beats</pre><pre><span style="font-family: Arial , sans-serif;"> </span></pre><pre>That I want to put a bit 32 bit ECC on the data portion of the packet (F_data_*) and parity on H_route and parity on F_be_* and C_err_* combined:</pre><pre> </pre><pre>{ &quot;all&quot; : [{&quot;signals&quot; : [&quot;valid&quot;,&quot;first&quot;,&quot;last&quot;], &quot;protectionStyle&quot; : {&quot;protection&quot; : &quot;none&quot;, &quot;scrub&quot; : false, &quot;useCorrected&quot; : false, &quot;protWidth&quot; : 0 }},</pre><pre>           {&quot;signals&quot; : [&quot;bus[45:43]&quot;], &quot;protectionStyle&quot; : {&quot;protection&quot; : &quot;parity&quot;, &quot;scrub&quot; : false, &quot;useCorrected&quot; : false, &quot;protWidth&quot; : 3 }},</pre><pre>           {&quot;signals&quot; : [&quot;bus[36:5]&quot;], &quot;protectionStyle&quot; : {&quot;protection&quot; : &quot;ecc&quot;, &quot;scrub&quot; : false, &quot;useCorrected&quot; : false, &quot;protWidth&quot; : 32 }},</pre><pre>           {&quot;signals&quot; : [&quot;bus[4:0]&quot;], &quot;protectionStyle&quot; : {&quot;protection&quot; : &quot;parity&quot;, &quot;scrub&quot; : false, &quot;useCorrected&quot; : false, &quot;protWidth&quot; : 5 }}</pre><pre>}</pre><pre> </pre><pre>This means:</pre><pre>sb_prot = {parity(bus[45:43],ecc[bus[36:5],parity(bus[4:0])} </pre><pre>or is 9 bits wide, which conveniently matches the prot width given in the Interface definition.</pre><p> </p><p> </p><p> </p>