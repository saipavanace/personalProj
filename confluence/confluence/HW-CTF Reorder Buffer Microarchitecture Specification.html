<h1 id="HW-CTFReorderBufferMicroarchitectureSpecification-History"><strong>History</strong></h1><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Version</th><th class="confluenceTh">Date</th><th colspan="1" class="confluenceTh">Comments</th><th class="confluenceTh">Editor</th></tr><tr><td class="confluenceTd">0.1</td><td class="confluenceTd">4/17/2019</td><td colspan="1" class="confluenceTd"><ul style="list-style-type: square;"><li>Initial ROB uArch Copied over from word.</li></ul></td><td class="confluenceTd">Eric Taylor</td></tr><tr><td colspan="1" class="confluenceTd">0.5</td><td colspan="1" class="confluenceTd">8/19/2019</td><td colspan="1" class="confluenceTd"><ul><li>Update for P0 Implementation</li></ul></td><td colspan="1" class="confluenceTd">Eric Taylor</td></tr><tr><td colspan="1" class="confluenceTd">0.7</td><td colspan="1" class="confluenceTd">11/18/2020</td><td colspan="1" class="confluenceTd"><ul style="list-style-type: square;"><li>Update for whats currently in R1</li><li>Updated to use memories</li></ul></td><td colspan="1" class="confluenceTd">Eric Taylor</td></tr></tbody></table></div><h1 id="HW-CTFReorderBufferMicroarchitectureSpecification-Outline"><strong>Outline</strong></h1><p><style type='text/css'>/*<![CDATA[*/
div.rbtoc1759723726627 {padding: 0px;}
div.rbtoc1759723726627 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1759723726627 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class='toc-macro rbtoc1759723726627'>
<ul class='toc-indentation'>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-History'>History</a></li>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-Outline'>Outline</a></li>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-Description'>Description</a></li>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-Configurations'>Configurations</a></li>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-Interfaces'>Interfaces</a></li>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-ReferenceSpecification'>Reference Specification</a></li>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-Parameters'>Parameters</a></li>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-Ports'>Ports</a></li>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-ParameterMapping'>Parameter Mapping</a>
<ul class='toc-indentation'>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-ATUI_AXI(SingleVC)'>ATUI_AXI (Single VC)</a></li>
</ul>
</li>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-TopLevel'>Top Level</a>
<ul class='toc-indentation'>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-Standalonenon-VCVersion'>Standalone non-VC Version</a></li>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-StandaloneVCVersion'>Standalone VC Version</a>
<ul class='toc-indentation'>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-NonEfficientStorage(SeparateContextforAllVC,CouldacceptVCresponsespercycle(howeverwontforR1))'>Non Efficient Storage (Separate Context for All VC, Could accept VC responses per cycle (however wont for R1))</a></li>
</ul>
</li>
</ul>
</li>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-UnitLevel'>Unit Level</a>
<ul class='toc-indentation'>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-RequestPath'>Request Path</a>
<ul class='toc-indentation'>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-ContextSelection'>Context Selection</a></li>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-RequestContext'>Request Context</a></li>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-RequestDependencySource'>Request Dependency Source</a></li>
</ul>
</li>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-ResponsePath'>Response Path</a>
<ul class='toc-indentation'>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-ResponseContextAllocation'>Response Context Allocation</a></li>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-ResponseDataBuffer'>Response Data Buffer</a>
<ul class='toc-indentation'>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-SupportedConfigurations'>Supported Configurations</a></li>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-SingleSRAM(Configuration1)'>Single SRAM ( Configuration 1 )</a></li>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-SingleSRAMwithLatency(Configuration2,3)'>Single SRAM with Latency ( Configuration 2,3 )</a></li>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-DoubleSRAMwithAddressBanking(Configuration4,5)'>Double SRAM with Address Banking ( Configuration 4,5 )</a></li>
</ul>
</li>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-ResponsePathBypass'>Response Path Bypass</a></li>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-DependencyClearingOperation'>Dependency Clearing Operation</a></li>
</ul>
</li>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-Timing'>Timing</a>
<ul class='toc-indentation'>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-Pipeing'>Pipeing</a></li>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-TimingOptimizationsandSignalNaming'>Timing Optimizations and Signal Naming</a></li>
</ul>
</li>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-OtherFeatures'>Other Features</a>
<ul class='toc-indentation'>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-ExternalPortDescriptions'>External Port Descriptions</a></li>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-ErrorChecking'>Error Checking</a></li>
</ul>
</li>
</ul>
</li>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-Appendix.'>Appendix.</a>
<ul class='toc-indentation'>
<li><a href='#HW-CTFReorderBufferMicroarchitectureSpecification-EfficientStorage(SharedContextforAllVC,Accept1responsepercycle)(notSupportedR1)'>Efficient Storage (Shared Context for All VC, Accept 1 response per cycle) (not Supported R1)</a></li>
</ul>
</li>
</ul>
</div></p><h1 id="HW-CTFReorderBufferMicroarchitectureSpecification-Description"><strong>Description</strong></h1><p>This is the micro-architecture specification for the Reorder Buffer Bidirectional Adapter.</p><p>This bi-directional adapter has both request and response link going though it. It checks the requests for order dependencies and then stores responses in data buffer as required to satisfy the ordering requirement. The request ATP link can be of different size/format than the response ATP link but the base packet format is same for both. All responses coming into the reorder buffer must have their corresponding requests go through the requested link connected through it.</p><p>The Reorder buffer can be used two different ways:</p><ul><li>Inside the fabric: ATP Links are used. Dependencies generated inside the block.</li><li>Inside the CTL Block: SMI Links are used. Dependencies generated from outside the block.</li></ul><p><strong style="font-size: 24.0px;">Features</strong></p><ul><li>Reorders - read response or write responses or both</li><li>Reorder - all responses or only based on CTL ordering requirements</li><li>Extended reordering support for multiple initiators/masters</li><li>VC-support (store VC# per buffered packet) and handle per-VC flow control</li><li>Filters packets based on packet type (control packets bypassed).</li><li>Can be attached to a CTL or a ATP interface. </li></ul><p><br/></p><div><h1 id="HW-CTFReorderBufferMicroarchitectureSpecification-Configurations"><strong>Configurations</strong></h1><ul><li>Reorder – only read or write responses</li><li>Reorder – both read and write responses</li><li>Reorder – read/(write) responses all</li><li>Reorder – read/(write) responses per Common Layer ordering</li><li>Reorder – for multiple initiators</li><li>Reorder – with VC</li></ul></div><h1 id="HW-CTFReorderBufferMicroarchitectureSpecification-Interfaces"><strong>Interfaces</strong></h1><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156986/HW-CTF+InterfaceATP" data-linked-resource-id="16156986" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF InterfaceATP</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168667/InterfacePROT" data-linked-resource-id="16168667" data-linked-resource-version="16" data-linked-resource-type="page">InterfacePROT</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156984/HW-CTF+InterfaceSMI" data-linked-resource-id="16156984" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF InterfaceSMI</a></p><h1 id="HW-CTFReorderBufferMicroarchitectureSpecification-ReferenceSpecification"><strong>Reference Specification</strong></h1><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156610/HW-CTF+Base+Packet+Parameters+Relationships" data-linked-resource-id="16156610" data-linked-resource-version="4" data-linked-resource-type="page">Base Packet Parameters &amp; Relationships<br /></a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16169110/Symphony+Architecture+Spec" data-linked-resource-id="16169110" data-linked-resource-version="18" data-linked-resource-type="page">Symphony Architecture Spec</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16161575/HW-CTF+Common+Transaction+Layer+Microarchitecture+Specification" data-linked-resource-id="16161575" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF Common Transaction Layer Microarchitecture Specification</a></p><h1 id="HW-CTFReorderBufferMicroarchitectureSpecification-Parameters"><strong style="font-size: 20.0px;">Parameters</strong></h1><p>{</p><p>   enRob : 0 or 1, // ENable the ROB Operation. Pass through if dissabled.</p><p>   maxBurst : 1 to inf, // The maximum transaction size in Bytes. Has to be multiple of bus width.</p><p>   pipeLevelRob : 0,1,2, // Indicates the pipe level in and out of the ROB. </p><p>   nOutstandingReq : 1 to inf, // Power of Two. Number of outstanding transactions.</p><p>   nContextEntries: 1 to inf, // How many entries the RoB has. (Number of transactions that can be held for reordering)</p><p>   nDataEntries: 1 to inf, // Needs to be equal to the max beats per transaction times the max number of outstanding transactions.</p><p>   nReads: 1 to inf, // Number of reads that could be outstanding. Used to determine when to backpressure when there isnt enough space inside the read buffer.</p><p>   mstrArbLck :   &lt;true or false&gt; , // Indicates whether the arbiters will lock on a VC. </p><p>   vcLckStyleVld : &lt;true or false&gt; ,  // Indicates whether the arbiters will lock on valid.</p><p>   mstrLckStyleVld : &lt;true or false&gt; ,  // Indicates whether the arbiters will lock on valid.</p><p>   arbType : </p><p>          {</p><p>                master : &lt;&quot;arb_rr2&quot;,&quot;arb_wrr_rr1&quot;, ...&gt;</p><p>                vcs : [ &quot;string&quot;, &quot;string&quot; , ... ]  // Each String is an arb type</p><p>           } // The arbiter types of the master for VC selection</p><p>   masterArbRdyAware :  &lt;true or false&gt; ,  // Indicates whether the arbiters are ready aware</p><p>   weights: </p><p>         {</p><p>                master : &lt;1,2,3, ...&gt;</p><p>                vcs : [int, int, , ... ]  // Each String is an arb type</p><p>           } // The weights of the master for VC selection</p><p>   orderMode :  0 or 1, // 0 - Reorder all responces. 1 - Reorder per Common Layer</p><p>   orderRd :0 or 1, // 1 - Order Read Responce</p><p>   orderWr: 0 or 1, // 1 - Order Write Responce</p><p>   nSource: 1 to inf, // Number of sources feeding the ROB</p><p>   externalDepnd : 0 or 1, // 0 - Create dependencies inside ROB, 1 - take in dependencies from outside ROB</p><p>   externalPoison : 0 or 1, // 0 - Create dependencies inside ROB, 1 - take in dependencies from outside ROB</p><p>   externalReserve : 0 or 1, // 0 - Create dependencies inside ROB, 1 - take in dependencies from outside ROB</p><p>   MemoryGeneration: [</p><p>     {<br/>          &quot;rtlPrefixString&quot;: &quot;a_string&quot;, // deprecated, must match corresponding generic interface name. </p><p>          &quot;interfaceObjType: &quot;a_string&quot; // Used to match memory to genericInterface. ( &quot;rob_x_y&quot; where x is vc and y is which memory within the rob)</p><p>          &quot;nMemDataRatio&quot; : integer, // Ratio of data widths between the external and internal memory, </p><p>          &quot;fnMemLatency&quot; : integer, // latency of the connected memory.</p><p>          &quot;fnMemCycle&quot; : integer, // Clock cycles required for memory to complete operation</p><p>          &quot;fnMemPorts&quot; : 1, // Is fixed to 1 for R1</p><p>          &quot;fnMemType&quot; : &quot;a_string&quot;, // Flops, SRAM, or CLOGSRAM</p><p>          &quot;useMemWrBitEn&quot; : true, // Is fixed to false for R1</p><p>          &quot;useMemExternal&quot; : false // Is fixed to false for R1</p><p>       }, ...</p><p>]</p><p><strong>   // Interface Parameters</strong></p><p>    &quot;interfaces&quot; :{</p><p>           &quot;clkInt&quot; : { &quot;name&quot; : &quot;a_string&quot;,  &quot;params&quot; : {}, &quot;direction&quot; : &quot;slave&quot;,  &quot;interface&quot; : &quot;<a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168894/InterfaceCLK" data-linked-resource-id="16168894" data-linked-resource-version="5" data-linked-resource-type="page">InterfaceCLK</a>&quot;},</p><p>           &quot;clkMem&quot; : [</p><p>                           { &quot;name&quot; : &quot;a_string&quot;,  &quot;params&quot; : {}<span class="legacy-color-text-blue3">, interfaceObjType: &quot;a_string&quot;</span>, &quot;direction&quot; : &quot;slave&quot;,  &quot;interface&quot; : &quot;<a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168894/InterfaceCLK" data-linked-resource-id="16168894" data-linked-resource-version="5" data-linked-resource-type="page">InterfaceCLK</a>&quot;},</p><p>            ]</p><p>           &quot;requestInterfacesIn&quot;  :  [{ &quot;name&quot; : &quot;a_string&quot;,  &quot;params&quot; : {}, &quot;direction&quot; : &quot;slave&quot;,  &quot;interface&quot; : &quot;<a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168894/InterfaceCLK" data-linked-resource-id="16168894" data-linked-resource-version="5" data-linked-resource-type="page">InterfaceA</a>TP or <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156992/HW-CTF+InterfaceCTL" data-linked-resource-id="16156992" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF InterfaceCTL</a>&quot;, ...}, ... ],</p><p>           &quot;requestInterfacesOut&quot; :  [{ &quot;name&quot; : &quot;a_string&quot;,  &quot;params&quot; : {}, &quot;direction&quot; : &quot;slave&quot;,  &quot;interface&quot; : &quot;<a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168894/InterfaceCLK" data-linked-resource-id="16168894" data-linked-resource-version="5" data-linked-resource-type="page">InterfaceA</a>TP or <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156992/HW-CTF+InterfaceCTL" data-linked-resource-id="16156992" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF InterfaceCTL</a>&quot;, ...},  ... ],</p><p>           &quot;responceInterfacesIn&quot;  : [{ &quot;name&quot; : &quot;a_string&quot;,  &quot;params&quot; : {}, &quot;direction&quot; : &quot;master&quot;,  &quot;interface&quot; : &quot;<a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168894/InterfaceCLK" data-linked-resource-id="16168894" data-linked-resource-version="5" data-linked-resource-type="page">InterfaceA</a>TP or <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156992/HW-CTF+InterfaceCTL" data-linked-resource-id="16156992" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF InterfaceCTL</a>&quot;, ...}, ... ],</p><p>           &quot;responceInterfacesOut&quot; :  [{ &quot;name&quot; : &quot;a_string&quot;,  &quot;params&quot; : {}, &quot;direction&quot; : &quot;master&quot;,  &quot;interface&quot; : &quot;<a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168894/InterfaceCLK" data-linked-resource-id="16168894" data-linked-resource-version="5" data-linked-resource-type="page">InterfaceA</a>TP or <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156992/HW-CTF+InterfaceCTL" data-linked-resource-id="16156992" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF InterfaceCTL</a>&quot;, ...},  ... ],        </p><p>           &quot;genericIoMem&quot; : [ </p><p>                {<br/>                    name: &quot;a_string&quot;, // The name of the memory module is derived from the name of the generic interface</p><p>                    params: {interface parameters}, </p><p>                    interfaceObjType: &quot;a_string&quot;, //matches the interfaceObjType in MemoryGeneration (rob0, rob1, ...)</p><p>                    direction: &quot;slave&quot;, </p><p>                    _SKIP_: boolean // true means interface is removed, false means interface is instanced</p><p>                    interface: &quot;InterfaceGeneric&quot;</p><p>                   }</p><p>           ]</p><p>    },</p><p>    &quot;stateProtectionStyle&quot; : &quot;&quot; or <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16169044/protectionStyle" data-linked-resource-id="16169044" data-linked-resource-version="15" data-linked-resource-type="page">protectionStyle</a></p><p>    &quot;registerProtectionStyle&quot; : &quot;&quot; or <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16169044/protectionStyle" data-linked-resource-id="16169044" data-linked-resource-version="15" data-linked-resource-type="page">protectionStyle</a></p><p>    &quot;memoryProtectionStyle&quot; : &quot;&quot; or <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16169044/protectionStyle" data-linked-resource-id="16169044" data-linked-resource-version="15" data-linked-resource-type="page">protectionStyle</a></p><p>}</p><h1 id="HW-CTFReorderBufferMicroarchitectureSpecification-Ports"><strong>Ports</strong></h1><p>These ports will only be instantiated in a non standalone version of the ROB.</p><p>if (externalDepnd) {<br/>    u.port('input', <a class="external-link" href="http://requestInterfaceIn.name" rel="nofollow">requestInterfaceIn.name</a>+'ndp_dependency' , 1); <br/>    u.port('input', <a class="external-link" href="http://requestInterfaceIn.name" rel="nofollow">requestInterfaceIn.name</a>+'ndp_dependency_seqnum', requestInterfaceIn.signals['ndp_'].msg_seqnum); <br/>}</p><p>if (externalPoison) {<br/>    u.port('input', 'seqnum_poison' , 2*maxOut); <br/>}</p><p>if (externalReserve) {<br/>   u.port('input', <a class="external-link" href="http://requestInterfaceIn.name" rel="nofollow">requestInterfaceIn.name</a>+'ndp_reserveBeatBuffer' , 1);<br/>   u.port('output', <a class="external-link" href="http://requestInterfaceOut.name" rel="nofollow">requestInterfaceOut.name</a>+'ndp_reserveBeatBuffer' , 1); <br/>}</p><h1 id="HW-CTFReorderBufferMicroarchitectureSpecification-ParameterMapping"><strong>Parameter Mapping</strong></h1><h2 id="HW-CTFReorderBufferMicroarchitectureSpecification-ATUI_AXI(SingleVC)"><strong>ATUI_AXI (Single VC)</strong></h2><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/></colgroup><tbody><tr><th class="confluenceTh">RoB Parameter</th><th class="confluenceTh">atui_axi Parameter</th></tr><tr><td class="confluenceTd">enRob</td><td class="confluenceTd">enReordering</td></tr><tr><td class="confluenceTd">nOutstandingReq</td><td class="confluenceTd">maxOutTotal</td></tr><tr><td class="confluenceTd">nContextEntries</td><td class="confluenceTd">reorderingEntries</td></tr><tr><td class="confluenceTd">nDataEntries</td><td class="confluenceTd">(Math.min(maxOutRd,reorderingEntries)*maxPduSize)/(smiDpRespInterface.data/8)</td></tr><tr><td class="confluenceTd">nWrites</td><td class="confluenceTd">maxOutWr</td></tr><tr><td class="confluenceTd">nReads</td><td class="confluenceTd">maxOutRd</td></tr><tr><td class="confluenceTd">orderMode</td><td class="confluenceTd">2</td></tr><tr><td class="confluenceTd">nSource</td><td class="confluenceTd">1</td></tr><tr><td class="confluenceTd">orderRd</td><td class="confluenceTd">1</td></tr><tr><td colspan="1" class="confluenceTd">orderWr</td><td colspan="1" class="confluenceTd">1</td></tr><tr><td colspan="1" class="confluenceTd">maxBurst</td><td colspan="1" class="confluenceTd">maxPduSize</td></tr><tr><td colspan="1" class="confluenceTd">MemoryGeneration</td><td colspan="1" class="confluenceTd">MemoryGeneration</td></tr></tbody></table></div><h1 id="HW-CTFReorderBufferMicroarchitectureSpecification-TopLevel"><strong>Top Level </strong></h1><h2 id="HW-CTFReorderBufferMicroarchitectureSpecification-Standalonenon-VCVersion">Standalone non-VC Version </h2><p><strong><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" data-image-src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" loading="lazy"></span></strong></p><div class="page view"><div class="wiki-content"><h2 id="HW-CTFReorderBufferMicroarchitectureSpecification-StandaloneVCVersion">Standalone VC Version</h2><h4 id="HW-CTFReorderBufferMicroarchitectureSpecification-NonEfficientStorage(SeparateContextforAllVC,CouldacceptVCresponsespercycle(howeverwontforR1))"><strong>Non Efficient Storage (Separate Context for All VC, Could accept VC responses per cycle (however wont for R1))</strong></h4><div>In the non-efficient ROB each VC will have a separate ROB unit since no two transactions in separate VCs will need to be ordered. This enables the ROB to accept responses from each VC at the same time.</div><div>The unit-level ROB will get request information from a SMI VC demux. The request information will then go out and be selected through a SMI Arb.</div><div><br/></div><div>The responses work similarly. Each response in interface will be driven from a SMI Demux . The response out will then drive a SMI Arb.</div><div><br/></div><div><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" data-image-src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" loading="lazy"></span></div></div></div><h1 id="HW-CTFReorderBufferMicroarchitectureSpecification-UnitLevel"><strong>Unit Level </strong></h1><h2 id="HW-CTFReorderBufferMicroarchitectureSpecification-RequestPath">Request Path</h2><ul style="list-style-type: square;"><li>Red : Internal Dependency Determination</li><li>Green : External Dependency Determination</li><li>Ordering Vector : {Src Id, Ordering Id, Channel Id} based on Ordering Model</li></ul><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" data-image-src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" loading="lazy"></span></p><h3 id="HW-CTFReorderBufferMicroarchitectureSpecification-ContextSelection">Context Selection</h3><p>A ROB will have nContextEntries entries. </p><p>The first min(nRead, nContextEntries) entries are used for reads. Each entry has a direct mapping to a location in the read data buffer that is the size of (maxBurstSize/wDataBytes). Reads are allocated bottom to top. A read with will be backpressured if the first min(nRead, nContextEntries) entries are used.</p><p>All entries could be used for write transactions, however they are allocated top to bottom. Writes are backpressured when all entries are used. </p><p>An entry will only be allocated if the transaction has a dependency on a sequence number that is outstanding according to the Outstanding Sequence Number register. </p><h3 id="HW-CTFReorderBufferMicroarchitectureSpecification-RequestContext">Request Context</h3><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Request Context Entry</th><th class="confluenceTh">Description</th></tr><tr><td class="confluenceTd">valid</td><td class="confluenceTd"><p>On Context Allocation to 1 and is set to 0 when any of the following conditions occur:</p><ul><li>clear_from_poison - seqnum was indicated to be poisoned from the context</li><li>resp_valid_clear_write - clear from write txn</li><li>resp_valid_clear_read  - clear from read txn</li><li>resp_valid_clear_read_after_data - clear from read txn after data has already been sent</li><li>resp_valid_clear_no_reorder - clear if dependency is cleared without receiving a response yet. So no reorder operation is needed.</li><li>resp_valid_clear_read_partial - clear if any portion of that entries data is sent</li></ul></td></tr><tr><td class="confluenceTd">read_count</td><td class="confluenceTd">On Context Allocation to 0, then as each beat is sent out it is increased.</td></tr><tr><td class="confluenceTd">beat_count</td><td class="confluenceTd">On Context Allocation to 0, then as each beat is read in it is increased.</td></tr><tr><td class="confluenceTd">depnd</td><td class="confluenceTd">On Context Allocation to dependency signal in. (Should always be 1)</td></tr><tr><td class="confluenceTd">depnd_seqnum</td><td class="confluenceTd">On Context Allocation to dependency_seqnum</td></tr><tr><td colspan="1" class="confluenceTd">trans_seqnum</td><td colspan="1" class="confluenceTd">On Context Allocation to transactions sequence number.</td></tr><tr><td colspan="1" class="confluenceTd">ordering_vec</td><td colspan="1" class="confluenceTd">(Needed for Internal Dependency Determination) {Src Id, Ordering Id, Channel Id} based on Ordering Model</td></tr></tbody></table></div><h3 id="HW-CTFReorderBufferMicroarchitectureSpecification-RequestDependencySource">Request Dependency Source</h3><p>Currently the context of the CTL layer indicates if and what dependency the transaction has based on sequence number. In the future this dependency can be determined internally inside the ROB. This is controlled by extenalDepnd. </p><h2 id="HW-CTFReorderBufferMicroarchitectureSpecification-ResponsePath">Response Path</h2><p>High Level View of the Response Path</p><p><br/></p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" data-image-src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" loading="lazy"></span></p><h3 id="HW-CTFReorderBufferMicroarchitectureSpecification-ResponseContextAllocation">Response Context Allocation</h3><p>A ROB will have nOutstandingReq response entries. No backpressure will be given as there is an entry for every outstanding transaction. </p><p>A response will know which response context entry to use based on a sequence number lookup. It will use the same entry as the request entry.</p><p>The context is split for the sake of easier reading and tachl.</p><p><br/></p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Request Context Entry</th><th class="confluenceTh">Description</th></tr><tr><td class="confluenceTd">response_dp_last_recieved</td><td class="confluenceTd"><p>Is set the cycle the NDP response comes in to last_dp_recieved otherwise it will be set whenever last_dp_reseived goes high</p><ul style="list-style-type: square;"><li>last_dp_recieved goes high when the last beat of data comes in according to dp_last</li></ul></td></tr><tr><td class="confluenceTd">response_dp_sent</td><td class="confluenceTd">Is cleared when request entry is cleared. Is set when the data from the Read Data Buffer has been fully sent. </td></tr><tr><td class="confluenceTd">response_dp_sent_last</td><td class="confluenceTd">Is cleared when request entry is cleared. Is set when the last data beat of the transaction as a whole leaves the ROB.</td></tr><tr><td class="confluenceTd">response_sent</td><td class="confluenceTd">Is cleared when request entry is cleared. Is set when the NDP portion of the response has been sent. </td></tr><tr><td class="confluenceTd">response</td><td class="confluenceTd">Is set when the NDP of the transaction is recieved. This field stores all of the packet fields to be sent as an NDP at a later time. </td></tr><tr><td colspan="1" class="confluenceTd">resp_entry</td><td colspan="1" class="confluenceTd">UNUSED, NEEDS TO BE DELETED</td></tr><tr><td colspan="1" class="confluenceTd">resp_valid</td><td colspan="1" class="confluenceTd">Is set when an NDP response is seen and it has NOT bypassed the ROB.</td></tr><tr><td colspan="1" class="confluenceTd">dependency</td><td colspan="1" class="confluenceTd">Is set when the context is allocated and cleared once the dependent sequence number is cleared from the Outstanding Sequence Number register. </td></tr></tbody></table></div><h3 id="HW-CTFReorderBufferMicroarchitectureSpecification-ResponseDataBuffer">Response Data Buffer</h3><p>Each context entry from 0 to nReads-1 has a specific entry inside the read data buffer. It holds (maxBurstSize/wDataBytes) beats of read data. This storage is used to store any read data that comes in for a transaction when it still has an outstanding dependency. </p><p>An entry's beat_count is how far inside its own buffer it needs to write data.</p><p>An entry's read_count is how far inside its own buffer it needs to read out data. </p><p>When reading out of the data buffer p_last may artificially need to be driven as multiple beats may have been combined inside the buffer. This is indicated by last_dp_beat which is driven from (beat_count - 1 == read_count).</p><p>When reading out of the data buffer last may artificially need to be driven if the ROB recorded it recieved last and that last beat of data exits the memory as indicated by last_dp_beat which is driven from (beat_count - 1 == read_count).</p><h4 id="HW-CTFReorderBufferMicroarchitectureSpecification-SupportedConfigurations">Supported Configurations</h4><p>1) memCycle = 1, memLatency = 1, memType = SRAM/flop<span style="color: inherit;">/CLOGSRAM</span></p><p>2) memCycle = 1, memLatency = 2, memType = SRAM/flop<span style="color: inherit;">/CLOGSRAM</span></p><p>3) memCycle = 1, memLatency = 3, memType = SRAM/flop/CLOGSRAM</p><p>4) memCycle = 2, memLatency = 2, memType = CLOGSRAM (RAMs are at 1/2 Fast Clock)</p><p>5) memCycle = 2, memLatency = 3, memType = CLOGSRAM <span style="color: inherit;">(RAMs are at 1/2 Fast Clock)</span></p><p><br/></p><p>For 1,2,3 there will be a single memory so MemoryGeneration and genericIoMem will have a single object.</p><ul class="x_alternate"><li>This object has interfaceObjType = rob_0_0</li><li>Width will be : wF_data + wF_be + wF_user + wC_err + wC_resp + wC_dummy </li><li>Depth will be : nContextEntries</li></ul><p>For 4,5 there will be two identical memories so MemoryGeneration and genericIoMem will have two objects.</p><ul class="x_alternate"><li>These objects will have interfaceObjType = rob_0_0 and rob_0_1</li><li>Then the rtlPrefixString is different and supplied from the user. Otherwise, they have the same parameters inside MemoryGeneration.</li><li>Width will be : wF_data + wF_be + wF_user + wC_err + wC_resp + wC_dummy </li><li>Depth will be : nContextEntries/2</li></ul><p>The rest of the parameters are fixed:</p><ul><li><span style="color: inherit;">nMemDataRatio = 1</span></li><li><span style="color: inherit;">fnMemPorts = 1</span></li><li>useMemWrBitEn = false</li><li>useMemExternal = false</li></ul><h4 id="HW-CTFReorderBufferMicroarchitectureSpecification-SingleSRAM(Configuration1)">Single SRAM ( Configuration 1 )</h4><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" data-image-src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" loading="lazy"></span></p><h4 id="HW-CTFReorderBufferMicroarchitectureSpecification-SingleSRAMwithLatency(Configuration2,3)">Single SRAM with Latency ( Configuration 2,3 )</h4><p>Note: Small Pipe on the Output is a Simple Pipe. The Large is a Transparent Pipe</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" data-image-src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" loading="lazy"></span></p><h4 id="HW-CTFReorderBufferMicroarchitectureSpecification-DoubleSRAMwithAddressBanking(Configuration4,5)">Double SRAM with Address Banking ( Configuration 4,5 )</h4><p>Note: Small Pipe on the Output is a Simple Pipe. The Large is a Transparent Pipe</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" data-image-src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" loading="lazy"></span></p><p>TODO A address_memory_bank uArch</p><h3 id="HW-CTFReorderBufferMicroarchitectureSpecification-ResponsePathBypass">Response Path Bypass</h3><p>A response ndp can bypass the Response Context if it does not depend on any other transaction as indicated by either the dependency or sent_dp field.</p><p>A response dp can bypass the Response Data Buffer if it is does not depend on any other transaction as indicated by either the dependency or sent_dp field. </p><h3 id="HW-CTFReorderBufferMicroarchitectureSpecification-DependencyClearingOperation">Dependency Clearing Operation</h3><p>Once an entry's dependency is cleared it has first priority to be sent. This means once there is a valid waiting transaction that has no more dependencies the response path will be back pressured and the ndp/dp will be sent. All future responses to this entry will bypass the context and the read buffer. </p><h2 id="HW-CTFReorderBufferMicroarchitectureSpecification-Timing">Timing </h2><h3 id="HW-CTFReorderBufferMicroarchitectureSpecification-Pipeing"><span style="letter-spacing: -0.006em;">Pipeing</span></h3><p><span style="letter-spacing: -0.006em;">pipeLevelRob can indicate that pipes be put on the boundaries of the block. They will be put on each of the in and out interfaces.</span></p><h3 id="HW-CTFReorderBufferMicroarchitectureSpecification-TimingOptimizationsandSignalNaming"><span style="letter-spacing: -0.006em;">Timing Optimizations and Signal Naming</span></h3><p>To make timing optimizations many signals were moved a cycle back. This is indicated if the signal has &quot;early&quot; or &quot;early_in&quot; in its name. The registered version usually has &quot;early_reg&quot; or &quot;early_out&quot; in its name. </p><h2 id="HW-CTFReorderBufferMicroarchitectureSpecification-OtherFeatures">Other Features</h2><h3 id="HW-CTFReorderBufferMicroarchitectureSpecification-ExternalPortDescriptions">External Port Descriptions</h3><p>It is possible with the stand alone ROB for indipendent ports to come into and out of the ROB:</p><ul style="list-style-type: square;"><li>dependency - Indicates there is a dependency for this transaction as signaled by the context </li><li>dependency_seqnum - Indicates what sequence number the transaction is dependent on</li><li>seqnum_poison - Indicates a sequence number is poisoned. If so the entry and all dependencies on that entry is cleared.</li><li>reserveBeatBuffer - A pass through signal for use inside the beatBuffer</li></ul><p><br/></p><div class="page view"><div class="wiki-content"><h3 id="HW-CTFReorderBufferMicroarchitectureSpecification-ErrorChecking">Error Checking</h3><ul><li>Context timeout – This is an optional (parameterized) timeout check for context entries. The timeout logic walks through the context entries and takes snapshot of the active context entries. If after a configurable number of cycles, the context entry is not de-allocated or updated, it will result in a timeout interrupt being set.</li><li>ECC for data/header buffer – There can be optional (parametrized) ECC protection enabled for the data buffer and/or header buffer. The ECC check is done when data is read out and any ECC failure results in an interrupt being set and also error bit set in the corresponding packet.</li><li>Context lookup Error - Response received with no corresponding entry in the context buffer.</li></ul></div></div><p><br/></p><h1 id="HW-CTFReorderBufferMicroarchitectureSpecification-Appendix."><strong>Appendix.</strong></h1><p><br/></p><div class="page view"><div class="wiki-content"><h4 id="HW-CTFReorderBufferMicroarchitectureSpecification-EfficientStorage(SharedContextforAllVC,Accept1responsepercycle)(notSupportedR1)"><strong>Efficient Storage (Shared Context for All VC, Accept 1 response per cycle) (not Supported R1)</strong></h4><p>The Packet layer ATP interface can handle VC based ready-valid handshake for both the request and response links. The ordering requirement for responses has priority over the VC associated with a response. The arbitration between VC can be RR or PRR (library component arbiter will be used wherever possible).</p><p>Request Control:</p><p>The request control logic has packet state-maintained per-VC and performs the following per-VC–</p><ul><li>Check the packet/message type, extract the header attributes for the context, and maintains the packet state.</li><li>Context access/update is done only for 1 VC in a given cycle.</li></ul><p>Response Input Control:</p><p>The input response logic is similar to the Request control logic, that it maintains packet state per-VC-</p><ul><li>Check the packet/message type, extract the header attributes for the context, and maintains the packet state.</li><li>Context lookup/update is done only for 1 VC in a given cycle.</li><li>Forward the packets to response output control or write them to data/header buffer. In a given cycle, only one selected VC has this control.</li></ul><p><br/></p><p><strong>Response input control with VC diagram</strong></p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" data-image-src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" loading="lazy"></span></p><p>Response output control:</p><ul><li>Reorder-all mode: The responses are read out in the fixed order independent of VC. The selected response that is ready to be sent out has the valid corresponding to the VC asserted. Thus, there is no per-VC FSM.</li><li>Reorder-AXI mode: The responses are read out per-VC. There is one FSM per-VC that sends out the response. In a given cycle, only one of the VC flow has access to read from the data buffer. There is memory read latency if the VC is changed very cycle, thus the arbiter requests a VC change only if the currently selected VC is back-pressured (as opposed to every cycle selection), and there are multiple “data-pipe” stages (per VC), to hold read data beats.</li></ul><p><strong>Response output control with VC diagram</strong></p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" data-image-src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" loading="lazy"></span></p><p><br/></p><p><br/></p></div></div>