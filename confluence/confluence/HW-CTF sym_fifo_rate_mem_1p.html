<h1 id="HW-CTFsym_fifo_rate_mem_1p-module_name"><strong>module_name</strong></h1><p>sym_fifo_rate_mem_2p</p><h1 id="HW-CTFsym_fifo_rate_mem_1p-parameters"><strong>parameters</strong></h1><h2 id="HW-CTFsym_fifo_rate_mem_1p-java_script:"><strong>java_script:</strong></h2><pre>{</pre><pre>	&quot;width&quot; : any positive integer         </pre><pre>        &quot;depth&quot; : any positive integer 4 or greater         </pre><pre>        &quot;hDepth&quot; : any positive integer, </pre><pre>        &quot;ratio&quot; : [I,J], // I is then number of in valid beats per J beats on the output. Specifies ratio of beats.</pre><pre>        &quot;memName&quot; : string // the name for the memory module </pre><pre class="page view">        &quot;protectionStyle&quot; : protectionStyle, </pre><pre class="page view">        &quot;protectionInterface&quot; : protectionInterface, </pre><pre class="page view">        &quot;genInterfaceNew&quot; : InterfaceGeneric, // Used to bring customer defined I/O to SRAM</pre><pre class="page view">        &quot;genIntSynOn&quot; : true or false,</pre><pre class="page view">        &quot;genIntSyns&quot; : {synonyms object} // See InterfaceGeneric for definition</pre><pre><span style="font-family: Arial , sans-serif;">}</span>
</pre><h2 id="HW-CTFsym_fifo_rate_mem_1p-verilog:"><strong>verilog:</strong></h2><p style="margin-left: 30.0px;">none.</p><h1 id="HW-CTFsym_fifo_rate_mem_1p-I/O"><strong>I/O</strong></h1><pre>u.port('input', 'clk', 1);<br/>u.port('input', 'reset_n', 1);<br/>u.port('input', 'in_valid', 1);<br/>u.port('output', 'in_ready', 1);<br/>u.port('input', 'in_data', width);<br/>u.port('output', 'out_valid', 1);<br/>u.port('input', 'out_ready', 1);<br/>u.port('output', 'out_data', width);<br/>u.interface(<a class="external-link" href="http://geninterfacenew.name/" rel="nofollow">genInterfaceNew.name</a>, 'master', genInterfaceSignals);<br/>u.interface(<a class="external-link" href="http://protectioninterface.name/" rel="nofollow">protectionInterface.name</a>, 'master', protectionInterface.signal); </pre><h1 id="HW-CTFsym_fifo_rate_mem_1p-ModulesUsed"><strong>Modules Used</strong></h1><p><a class="external-link" href="https://confluence.arteris.com/display/ENGR/prot_mux" rel="nofollow">prot_mux</a></p><p><a class="external-link" href="https://confluence.arteris.com/display/ENGR/rdy_vld_pipe" rel="nofollow">rdy_vld_pipe</a></p><p><a class="external-link" href="https://confluence.arteris.com/display/ENGR/logic_tree_bus" rel="nofollow">logic_tree_bus</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156283/HW-CTF+sym_fifo_rate_mem_1p_ctl" data-linked-resource-id="16156283" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF sym_fifo_rate_mem_1p_ctl</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156472/HW-CTF+sym_mem_1p" data-linked-resource-id="16156472" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF sym_mem_1p</a></p><h1 id="HW-CTFsym_fifo_rate_mem_1p-Description"><strong>Description</strong></h1><p><strong>ratio: </strong>I represents the number of valid beats per J beats on the output. So, if a packet is coming into the block with a valid every other beat, which can happen from a data width adapter, then I = 1 and J = 2. Another way of saying this is the in side has a bubble every other cycle. If the in side has a bubble once ever three cycles, then I = 2 and J = 3. If the in side had two bubbles every 5 cycles, then I = 3 and J = 5.</p><p>This block implements a pipe adapter using a sym_mem_1p. The block as a whole is hardcode pipeForward = false and pipeBackward = true. The block diagram is shown below:</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16156303/sym_fifo_rate_mem_1p_ctl.svg?api=v2"></span></p><p>The signals going from the sym_fifo_rate_mem_1p_ctl to the SRAM are</p><p style="margin-left: 30.0px;">port ctl:<br/>sel (input to sym_mem_1p)<br/>we (input to sym_mem_1p) // we = 1, doing a write, we = 0, doing a read<br/>addr (input to sym_mem_1p)<br/>wt_data (input to sym_mem_1p)<br/>rd_data (output from sym_mem_1p)</p><p>The mux is created using a two input logic_tree_bus, where the two inputs are qualified with the empty signal from sym_fifo_rate_mem_1p_ctl. When the empty is asserted, the FIFO pulls the data directly from in_data, otherwise it pulls data from rdy_vld_pipe. </p><p>The rdy_vld_pipe block forms an external pipe and is used to maintain throughput from the SRAM FIFO and because when a read is occurring on the SRAM FIFO, it isn't known if on the next cycle the out_ready will be asserted, so the data will need to be stored somewhere. It is configured with pipeForward = false, pipeBackward = true with a depth of 2. This means the output of SRAM can flow straight to the outputs if there is nothing in the rdy_vld_pipe and it can maintain throughput if there's a beat in it.</p><p>The sym_mem_1p registers all inputs into it, but does not register the data coming out of the SRAM.</p><p>The sym_fifo_mem_1p_ctl block controls the ready and valids signals into the rdy_vld_pipe and uses it's knowledge of where data is to properly assert out_vld. For a complete description of the logic inside, refer to the sym_fifo_mem_rate_1p_ctl microarchitecture document (click on the link).</p><p>The genInterfaceNew goes to the sym_mem_1p and is used to bring customer specified signals to the SRAM wrapper, such is MBIST signals.</p><p>The protectionInterface is used to report errors detected in the control registers in sym_fifo_mem_1p_ctl (all registers) and rdy_vld_pipe (not the registers that hold data). A prot_mux is used to combined the output from these two blocks before sending it to the outside world.</p><p><br/></p>