<p><strong>Example: DMI Coherent Write Buffer</strong></p><p><br/></p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">nxp_config_v4_128OTT_23april/output/debug/debug_json/dmi0_dmi.json
==================================================================
  &quot;wCacheLineOffset&quot;: 6,
  &quot;wData&quot;: 256,
  &quot;fnErrDetectCorrect&quot;: &quot;SECDED&quot;,
  &quot;cmpInfo&quot;: {
    &quot;nDceRbEntries&quot;: 20,
  },
  &quot;MemoryGeneration&quot;: {
    &quot;wrDataMem&quot;: {
      &quot;Signals&quot;: [],
      &quot;rtlPrefixString&quot;: &quot;DMI_wrDataMem&quot;,
      &quot;MemType&quot;: &quot;SYNOPSYS&quot;
    }
  },</pre>
</div></div><p><br/></p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">hw-ncr/rtl/dmi/src/dmi.tachl
============================
\jsbegin
var memFunctions       = obj.userLib;
var cmpInfo            = obj.lib.getParam(&#39;cmpInfo&#39;);
var wCacheLineOffset   = obj.lib.getParam(&#39;wCacheLineOffset&#39;);
var wData              = obj.lib.getParam(&#39;wData&#39;);
var nBeats             = (1&lt;&lt;wCacheLineOffset) / (wData/8);
var fnErrDetectCorrect = obj.lib.getParam(&#39;fnErrDetectCorrect&#39;);
var wrDataBufferMemoryInterface = {};
var cWrDataGen      = obj.lib.getParam(&#39;MemoryGeneration&#39;, &#39;wrDataMem&#39;);
var cWrMemRtlPrefix = cWrDataGen.rtlPrefixString;
var useExWrDataMem  = (cWrDataGen.MemType !== &quot;NONE&quot;);
var cWrMemPorts     = &quot;sp&quot;;
var nWrDataBanks    = 2;
var wrBufferProtType= fnErrDetectCorrect;
var cWrDataWidth    = wData;
var cWrDataParam    = memFunctions.dataBufferMemoryParams(cWrDataWidth, cmpInfo.nDceRbEntries, nBeats, nWrDataBanks, wrBufferProtType);
var wrDataStructures= [];
for (var i = 0; i &lt; nWrDataBanks; i++) {
    wrDataStructures[i] =
            memFunctions.createMemoryDataStructure(
                cWrDataGen,
                cWrDataParam,
                cWrMemPorts,
                0, // biten
                cWrMemRtlPrefix,
                &#39;&#39;,
                0 // unused
            );
}
// pass information to lower hierarchy
cWrDataParam[&#39;nBanks&#39;] = nWrDataBanks;
cWrDataParam[&#39;nPorts&#39;] = cWrMemPorts;
// External Memory signals
for (var i = 0; i &lt; nWrDataBanks; i++) {
    if (wrDataStructures[i].memoryType === &quot;SYNOPSYS&quot;) {
        /* istanbul ignore if */
        if (Object.keys(wrDataStructures[i].signals).length &gt; 0) {
            utilFunctions.defineMasterPortsFromInterface(wrDataStructures[i].rtlPrefixString + i + &#39;_&#39;, wrDataStructures[i].signals, obj.lib.port);
        }
    }
}

for(var bank = 0; bank &lt; wrDataStructures.length; bank++) {
    for(var signal in wrDataStructures[bank].controlSignals) {
        wrDataBufferMemoryInterface[cWrDataGen.rtlPrefixString+bank+&#39;_&#39;+signal] = wrDataStructures[bank].controlSignals[signal];
    }
}

    if (useExWrDataMem) {
        DMI_UNIT_INTF.push({
                modulePrefix: &#39;&#39;,
                localPrefix: &#39;&#39;,
                interface: wrDataBufferMemoryInterface,
                    direction : &quot;master&quot;
        });
    } // useExWrDataMem

    var dmi_unit_params = {
            wrDataBufferMemoryInterface : wrDataBufferMemoryInterface,
            cWrDataGen                  : cWrDataGen,
            cWrDataParam                : cWrDataParam,
};

\jsend

    \=obj.lib.instance({
        instanceName: &#39;dmi_unit&#39;,
        moduleName: &#39;dmi_unit&#39;,
        params: dmi_unit_params,
        verilogParams: {},
        ports: DMI_UNIT_PORTS,
        interfaces: DMI_UNIT_INTF,
        portsDelimiter: &#39;\n        &#39;
    })=\

\jsbegin
if (useExWrDataMem) {
        var instance_ports_for_ram = [];
        for (var i = 0; i &lt; nWrDataBanks; i++) {
            instance_ports_for_ram[i] = {clk : clkInterfaceName+&#39;clk&#39;};
            var rtlPrefixString = cWrDataGen.rtlPrefixString + i;
            var memoryControlInterface = wrDataStructures[i].controlSignals;
            for (var signal in memoryControlInterface) {
                instance_ports_for_ram[i][signal]  = &#39;mem__&#39; + rtlPrefixString + &#39;_&#39; + signal;
            }

\jsend
        \=obj.lib.instance({
                    instanceName: cWrMemRtlPrefix + i,
                    moduleName: cWrMemRtlPrefix + &#39;_em_mem_external&#39;,
                    tachlName: &#39;em_mem_external&#39;,
                    params: {
                        sverilog        : assertOn,
                        memEccBlocks    : cWrDataParam.eccBlocks,
                        rtlPrefixString : cWrMemRtlPrefix,
                        modulePrefix    : &#39;dmi&#39;,
                        memoryType      : wrDataStructures[i].memoryType,
                        nSignals        : wrDataStructures[i].signals.length,
                        signals         : wrDataStructures[i].signals,
                        useHandshake    : 0,
                        no_mem_init     : 0,
                        ports           : cWrMemPorts,
                        bitEnable       : 0,
                        numberOfEnables : wrDataStructures[i].width,
                        width           : wrDataStructures[i].width,
                        depth           : wrDataStructures[i].depth
                    },
                    verilogParams: {},
                    ports: instance_ports_for_ram[i],
                    portsDelimiter: &#39;\n&#39;
        })=\
\jsbegin
        }

        var str = &#39;&#39;;
        for (var i = 0; i &lt; nWrDataBanks; i++) {
            var rtlPrefixString = cWrDataGen.rtlPrefixString + i;
            var memoryControlInterface = wrDataStructures[i].controlSignals;
            str += memFunctions.string_addConnectionfromInterface(&#39;&#39;      + rtlPrefixString + &#39;_&#39;,
                                                                  &#39;mem__&#39; + rtlPrefixString + &#39;_&#39;,
                                                                   memoryControlInterface);
        }
\jsend
\=str=\

\js }
</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Generated Verilog RTL
=====================
module dmi_a (
input   clk_reg_1300_clk_dom_1300_clk_subdom_1300_clk
);

    dmi_unit_a dmi_unit (
        .DMI_wrDataMem0_int_data_in     (DMI_wrDataMem0_int_data_in),
        .DMI_wrDataMem0_int_address     (DMI_wrDataMem0_int_address),
        .DMI_wrDataMem0_int_chip_en     (DMI_wrDataMem0_int_chip_en),
        .DMI_wrDataMem0_int_write_en    (DMI_wrDataMem0_int_write_en),
        .DMI_wrDataMem0_int_data_out    (DMI_wrDataMem0_int_data_out),
        .DMI_wrDataMem1_int_data_in     (DMI_wrDataMem1_int_data_in),
        .DMI_wrDataMem1_int_address     (DMI_wrDataMem1_int_address),
        .DMI_wrDataMem1_int_chip_en     (DMI_wrDataMem1_int_chip_en),
        .DMI_wrDataMem1_int_write_en    (DMI_wrDataMem1_int_write_en),
        .DMI_wrDataMem1_int_data_out    (DMI_wrDataMem1_int_data_out));

        DMI_wrDataMem_em_mem_external_a DMI_wrDataMem0 (
.clk    (clk_reg_1300_clk_dom_1300_clk_subdom_1300_clk),
.int_data_in    (mem__DMI_wrDataMem0_int_data_in),
.int_address    (mem__DMI_wrDataMem0_int_address),
.int_chip_en    (mem__DMI_wrDataMem0_int_chip_en),
.int_write_en   (mem__DMI_wrDataMem0_int_write_en),
.int_data_out   (mem__DMI_wrDataMem0_int_data_out));

        DMI_wrDataMem_em_mem_external_a DMI_wrDataMem1 (
.clk    (clk_reg_1300_clk_dom_1300_clk_subdom_1300_clk),
.int_data_in    (mem__DMI_wrDataMem1_int_data_in),
.int_address    (mem__DMI_wrDataMem1_int_address),
.int_chip_en    (mem__DMI_wrDataMem1_int_chip_en),
.int_write_en   (mem__DMI_wrDataMem1_int_write_en),
.int_data_out   (mem__DMI_wrDataMem1_int_data_out));

assign mem__DMI_wrDataMem0_int_data_in[265:0] = DMI_wrDataMem0_int_data_in;
assign mem__DMI_wrDataMem0_int_address[4:0] = DMI_wrDataMem0_int_address;
assign mem__DMI_wrDataMem0_int_chip_en = DMI_wrDataMem0_int_chip_en;
assign mem__DMI_wrDataMem0_int_write_en = DMI_wrDataMem0_int_write_en;
assign DMI_wrDataMem0_int_data_out[265:0] = mem__DMI_wrDataMem0_int_data_out;
assign mem__DMI_wrDataMem1_int_data_in[265:0] = DMI_wrDataMem1_int_data_in;
assign mem__DMI_wrDataMem1_int_address[4:0] = DMI_wrDataMem1_int_address;
assign mem__DMI_wrDataMem1_int_chip_en = DMI_wrDataMem1_int_chip_en;
assign mem__DMI_wrDataMem1_int_write_en = DMI_wrDataMem1_int_write_en;
assign DMI_wrDataMem1_int_data_out[265:0] = mem__DMI_wrDataMem1_int_data_out;

</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">hw-lib/js/lib_utils.js
======================
function dataBufferMemoryParams(width, nSets, nBeats, nBanks, errorInfo) {
    var dataWidth = width;
    // ECC Calculations

    var memEccBlocks = [];
    var eccOnlyBlocks = [];
    var blockWidths = [dataWidth];
    var eccIndexes = getEccIndexes(blockWidths, 0, errorInfo);

    memEccBlocks = eccIndexes.memEccBlocks;
    eccOnlyBlocks = eccIndexes.eccOnlyBlocks;


    var memWidth = dataWidth + getErrorEncodingWidth(errorInfo, dataWidth, blockWidths);
    var memDepth = nBeats * nSets / nBanks;

    return {
        widthWithoutEcc: dataWidth,
        blockWidths: blockWidths,
        width: memWidth,
        depth: memDepth,
        eccOnlyBlocks: eccOnlyBlocks,
        eccBlocks: memEccBlocks
    }
}

function getMemoryControlSignals(memoryType, memoryParams, ports, bitEnable) {
    var result;
    if (ports === &#39;sp&#39;) {
        result = {
            int_data_in: memoryParams.width,
            int_address: Math.max(1, Math.ceil(Math.log2(memoryParams.depth))),
            int_chip_en: 1,
            int_write_en: 1,
            int_data_out: -1 * memoryParams.width
        }

        if (bitEnable) {
            result.int_write_en_mask = memoryParams.width;
        }
    } else if (ports === &#39;tp&#39;) {
        result = {
            int_data_in: memoryParams.width,
            int_address_write: Math.max(1, Math.ceil(Math.log2(memoryParams.depth))),
            int_address_read: Math.max(1, Math.ceil(Math.log2(memoryParams.depth))),
            int_chip_en_write: 1,
            int_chip_en_read: 1,
            int_data_out: -1 * memoryParams.width
        }
        if (bitEnable) {
            result.int_write_en_mask = memoryParams.width;
        }
    }
    return result;
}

function createMemoryDataStructure(memoryStructure, memoryCalculatedParams, memoryPorts, bitEnable, modulePrefix, identifier, moduleIndex) {
    var dataStructure = {};
    // Create default prefix
    var defaultPrefix = modulePrefix + identifier;
    if (memoryStructure) {
        // Add control signals and their widths to the data structure
        var memoryControlSignals = getMemoryControlSignals(
            memoryStructure.MemType,
            memoryCalculatedParams,
            memoryPorts, // &#39;tp&#39;,
            bitEnable // moduleParams.NativeInfo.useIoCache //bitEnable
        );

        dataStructure.controlSignals = memoryControlSignals;
        // Memory Calculations
        dataStructure.widthWithoutEcc = memoryCalculatedParams.widthWithoutEcc;
        dataStructure.width = memoryCalculatedParams.width;
        dataStructure.depth = memoryCalculatedParams.depth;
        dataStructure.blockWidths = memoryCalculatedParams.blockWidths;
        // Add test signals
        if ((!memoryStructure.rtlPrefixString) || memoryStructure.MemType === &#39;NONE&#39;) {
            // set name to default name
            // If the memory type is none, set the rtlStringPrefix so a default value
            // this is because the created memory uses this default name for all
            // memories accross ports
            dataStructure.rtlPrefixString = defaultPrefix;
            dataStructure.memoryType = memoryStructure.MemType;
            // if rtlPrefixString is 0 or memoryType is none, delete signals
            dataStructure.nSignals = 0;
            dataStructure.signals = {};
        } else {
            // set name to default name
            dataStructure.rtlPrefixString = memoryStructure.rtlPrefixString;
            dataStructure.modulePrefix = modulePrefix + moduleIndex;
            dataStructure.memoryType = memoryStructure.MemType;

            var signals = {};
            dataStructure.nSignals = memoryStructure.Signals.length;
            for (var i = 0; i &lt; dataStructure.nSignals; i++) {
                if (memoryStructure.Signals[i].Direction === &#39;IN&#39;) {
                    signals[memoryStructure.Signals[i].Name] = 0 - memoryStructure.Signals[i].Width;
                } else {
                    signals[memoryStructure.Signals[i].Name] = memoryStructure.Signals[i].Width;
                }
            }
            dataStructure.signals = signals;
        }
    } else {
        throw &#39;createMemoryDataStructure: memoryStructure is not valid; default prefix is &#39; + defaultPrefix;
    }
    return dataStructure;
}
</pre>
</div></div>