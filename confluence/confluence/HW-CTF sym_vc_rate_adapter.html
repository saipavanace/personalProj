<h1 id="HW-CTFsym_vc_rate_adapter-modulename"><strong>module name</strong></h1><p>sym_rate_adapter</p><p>sym_rate_adapter_in</p><p>sym_rate_adapter_out</p><h1 id="HW-CTFsym_vc_rate_adapter-parameters"><strong>parameters</strong></h1><h2 id="HW-CTFsym_vc_rate_adapter-sym_rate_adapter:"><strong style="font-size: 16.0px;">sym_rate_adapter:</strong></h2><pre>{</pre><pre>  &quot;numPri&quot; : positve inteteger, </pre><pre>  &quot;ratio&quot; : [I,J], // I is then number of in clocks, J is the number of out clocks. Specifies ratio of clocks. </pre><pre>  &quot;jitterOn&quot; : 0 or 1, defaults to 0. 1 is for verification use only. </pre><pre>  &quot;async&quot; : &quot;yes&quot; or &quot;no&quot;.  // are the two clocks asynchronous to one another.</pre><pre>  &quot;vcParams : [{  // Unique parameters per VC</pre><pre>      &quot;depth&quot; : positive integer, // Buffer depth in terms of ATP beats.</pre><pre>      &quot;maxPkt&quot; : 0 or positive integer., // 0 means maxPkt is assumed to be depth.</pre><pre>      &quot;minPkts&quot; : 0 or positive integer, // less than or equal to depth/maxPkt. 0 means minPkts is depth/maxPkt</pre><pre>      &quot;maxTime&quot; : 0 or positive integer}, // Number of slave clocks that the block can stall with a packet to send. 0 or minPkts=1 means no check.</pre><pre>    {params for vc1}, </pre><pre>    . . . </pre><pre>    {params for vc(numVc-1)}],</pre><pre>  &quot;mstrArbLck&quot; : true or false,</pre><pre>  &quot;mstLckStyleVld&quot; : true or false,</pre><pre>  &quot;arbType&quot; : &quot;type&quot;,</pre><pre>  &quot;arbRdyAware&quot; : &quot;yes&quot; or &quot;no&quot;,</pre><pre>  &quot;weights&quot; : [wi,wj,wk],</pre><pre>  &quot;weightsProg&quot; : &quot;yes&quot; or &quot;no&quot;,</pre><pre>  &quot;protectionStyle&quot; : null or {<a class="external-link" href="https://confluence.arteris.com/display/ENGR/protectionStyle" rel="nofollow">protectionStyle</a>},</pre><pre>  &quot;interfaces&quot; : {</pre><pre>    &quot;inClkInterface&quot; : {InterfaceCLK},</pre><pre>    &quot;outClkInterface&quot; : {InterfaceCLK},</pre><pre>    &quot;cfgInterface&quot; : {InterfaceAPB}, // For the sym_switch if needed.</pre><pre>    &quot;inInterface&quot; :  {InterfaceATP},  // number of VCs is implied in the width of valid.</pre><pre>    &quot;outInterface&quot; : {InterfaceATP},</pre><pre>    &quot;inProtectionInterface&quot; : {InterfacePROT}, // optional, expected if protectionStyle is not null</pre><pre>    &quot;outProtectionInterface&quot; : {InterfacePROT}, // optional, expected if protectionStyle is not null</pre><pre>}</pre><h3 id="HW-CTFsym_vc_rate_adapter-sym_rate_adapter_in:"><strong>sym_rate_adapter_in:</strong></h3><pre>{</pre><pre>  &quot;ratio&quot; : [I,J], // I is then number of in clocks, J is the number of out clocks. Specifies ratio of clocks. </pre><pre>  &quot;jitterOn&quot; : 0 or 1, defaults to 0. 1 is for verification use only. </pre><pre>  &quot;async&quot; : &quot;yes&quot; or &quot;no&quot;.  // are the two clocks asynchronous to one another.</pre><pre>  &quot;vcParams : [{  // Unique parameters per VC</pre><pre>      &quot;depth&quot; : positive integer, // Buffer depth in terms of ATP beats.</pre><pre>      &quot;maxPkt&quot; : 0 or positive integer., // 0 means maxPkt is assumed to be depth.</pre><pre>      &quot;minPkts&quot; : 0 or positive integer, // less than or equal to depth/maxPkt. 0 means minPkts is depth/maxPkt</pre><pre>      &quot;maxTime&quot; : 0 or positive integer}, // Number of slave clocks that the block can stall with a packet to send. 0 or minPkts=1 means no check.</pre><pre>    {params for vc1}, </pre><pre>    . . . </pre><pre>    {params for vc(numVc-1)}],</pre><pre>  &quot;protectionStyle&quot; : &quot;&quot; or {<a class="external-link" href="https://confluence.arteris.com/display/ENGR/protectionStyle" rel="nofollow">protectionStyle</a>},</pre><pre>  &quot;interfaces&quot; : {</pre><pre>    &quot;clkInterface&quot; : {InterfaceCLK},</pre><pre>    &quot;inInterface&quot; :  {InterfaceATP},  // number of VCs is implied in the width of valid.</pre><pre>    &quot;asyncInterfaces&quot; : [{InterfaceAsyncFIFO}, . . . ], // One per VC</pre><pre>    &quot;asyncCrInterfaces&quot; : [{InterfaceAsyncCrFIFO, . . . ], // One per VC if needed</pre><pre>    &quot;protectionInterface&quot; : {IntefacePROT} // Optional, expected if protectionStyle is not null</pre><pre><span style="font-family: Arial , sans-serif;">}</span></pre><h3 id="HW-CTFsym_vc_rate_adapter-sym_rate_adapter_out:">sym_rate_adapter_out:</h3><pre>{</pre><pre>  &quot;numPri&quot; : positve inteteger, </pre><pre>  &quot;ratio&quot; : [I,J], // I is then number of in clocks, J is the number of out clocks. Specifies ratio of clocks. </pre><pre>  &quot;jitterOn&quot; : 0 or 1, defaults to 0. 1 is for verification use only. </pre><pre>  &quot;async&quot; : &quot;yes&quot; or &quot;no&quot;.  // are the two clocks asynchronous to one another.</pre><pre>  &quot;vcParams : [{  // Unique parameters per VC</pre><pre>      &quot;depth&quot; : positive integer, // Buffer depth in terms of ATP beats.</pre><pre>      &quot;maxPkt&quot; : 0 or positive integer., // 0 means maxPkt is assumed to be depth.</pre><pre>      &quot;minPkts&quot; : 0 or positive integer, // less than or equal to depth/maxPkt. 0 means minPkts is depth/maxPkt</pre><pre>      &quot;maxTime&quot; : 0 or positive integer}, // Number of slave clocks that the block can stall with a packet to send. 0 or minPkts=1 means no check.</pre><pre>    {params for vc1}, </pre><pre>    . . . </pre><pre>    {params for vc(numVc-1)}],</pre><pre>  &quot;mstrArbLck&quot; : true or false, </pre><pre>  &quot;mstLckStyleVld&quot; : true or false,</pre><pre>  &quot;arbType&quot; : &quot;type&quot;,</pre><pre>  &quot;arbRdyAware&quot; : &quot;yes&quot; or &quot;no&quot;,</pre><pre>  &quot;weights&quot; : [wi,wj,wk],</pre><pre>  &quot;weightsProg&quot; : &quot;yes&quot; or &quot;no&quot;,</pre><pre>  &quot;protectionStyle&quot; : &quot;&quot; or {<a class="external-link" href="https://confluence.arteris.com/display/ENGR/protectionStyle" rel="nofollow">protectionStyle</a>},</pre><pre>  &quot;interfaces&quot; : {</pre><pre>    &quot;clkInterface&quot; : {InterfaceCLK},</pre><pre>    &quot;cfgInterface&quot; : {InterfaceAPB}, // For the sym_switch if needed.</pre><pre>    &quot;asyncInterfaces&quot; : [{InterfaceAsyncFIFO}, . . . ], // One per VC</pre><pre>    &quot;asyncCrInterfaces&quot; : [{InterfaceAsyncCrFIFO}, . . . ], // One per VC if needed</pre><pre>  &quot;outInterface&quot; : {InterfaceATP},</pre><pre>  &quot;protectionInterface&quot; : {InterfacePROT} // Optional. Expected if protectionStyle is no null.</pre><pre>}</pre><h1 id="HW-CTFsym_vc_rate_adapter-I/O:"><strong>I/O:</strong></h1><h2 id="HW-CTFsym_vc_rate_adapter-sym_vc_rate_adapter:"><strong>sym_vc_rate_adapter:</strong></h2><pre>u.interface(<a class="external-link" href="http://inClkInterface.name" rel="nofollow">inClkInterface.name</a>,'slave',inClkInterface.signals);<br/>u.interface(<a class="external-link" href="http://outClkInterface.name" rel="nofollow">outClkInterface.name</a>,'slave',outClkInterface.signals);<br/>u.interface(<a class="external-link" href="http://inInterface.name" rel="nofollow">inInterface.name</a>,'slave',inInterface.signals);<br/>u.interface(<a class="external-link" href="http://outInterface.name" rel="nofollow">outInterface.name</a>,'master',outInterface.signals);<br/>if (weightsProg === 'yes') {<br/>  u.interface(<a class="external-link" href="http://cfgInterface.name" rel="nofollow">cfgInterface.name</a>,'slave',cfgInterface.signals);<br/>}<br/>if (protectionStyle !== &quot;&quot;) {<br/>  u.interface(<a class="external-link" href="http://inProtectionInterface.name" rel="nofollow">inProtectionInterface.name</a>,'master',inProtectionInterface.signals);<br/>  u.interface(<a class="external-link" href="http://outProtectionInterface.name" rel="nofollow">outProtectionInterface.name</a>,'master',outProtectionInterface.signals); </pre><pre>}</pre><h2 id="HW-CTFsym_vc_rate_adapter-sym_vc_rate_adapter_in:"><strong>sym_vc_rate_adapter_in:</strong></h2><pre>u.interface(<a class="external-link" href="http://clkInterface.name" rel="nofollow">clkInterface.name</a>,'slave',clkInterface.signals);<br/>u.interface(<a class="external-link" href="http://inInterface.name" rel="nofollow">inInterface.name</a>,'slave',inInterface.signals);<br/>for (i = 0; i &lt; numVc; i++) {<br/>  u.interface(asyncInterfaces[i].name,'master',asyncInterfaces[i].signals);<br/>  if (style === 'slow2fast') {<br/>    u.interface(asyncCrInterfaces[i].name,'master',asyncCrInterfaces[i].signals);<br/>  }<br/>}<br/>if (protectionStyle !== &quot;&quot;) {<br/>  u.interface(<a class="external-link" href="http://protectionInterface.name" rel="nofollow">protectionInterface.name</a>,'master',protectionInterface.signals);<br/>}</pre><h2 id="HW-CTFsym_vc_rate_adapter-sym_vc_rate_adapter_out:"><strong>sym_vc_rate_adapter_out:</strong></h2><pre>u.interface(<a class="external-link" href="http://clkInterface.name" rel="nofollow">clkInterface.name</a>,'slave',clkInterface.signals);<br/>u.interface(<a class="external-link" href="http://outInterface.name" rel="nofollow">outInterface.name</a>,'master',outInterface.signals);<br/>for (i = 0; i &lt; numVc; i++) {<br/>  u.interface(asyncInterfaces[i].name,'slave',asyncInterfaces[i].signals);<br/>  if (style === 'slow2fast') {<br/>    u.interface(asyncCrInterfaces[i].name,'slave',asyncCrInterfaces[i].signals);<br/>  }<br/>}<br/>if (weightsProg === 'yes') {<br/>  u.interface(<a class="external-link" href="http://cfgInterface.name" rel="nofollow">cfgInterface.name</a>,'master',cfgInterface.signals);<br/>}<br/>if (protectionStyle !== &quot;&quot;) {<br/>  u.interface(<a class="external-link" href="http://protectionInterface.name" rel="nofollow">protectionInterface.name</a>,'master',protectionInterface.signals);<br/>}</pre><h1 id="HW-CTFsym_vc_rate_adapter-ModulesUsed"><strong>Modules Used</strong></h1><p>sym_vc_rate_adapter_in</p><p>sym_vc_rate_adapter_out</p><p>sym_rate_adapter_in</p><p>sym_rate_adapter_out</p><p>sym_vc_demux</p><p>sym_vc_mux</p><p>sym_switch</p><h1 id="HW-CTFsym_vc_rate_adapter-Description"><strong>Description</strong></h1><p>This block instantiates sym_rate_adapter per VC and an arbiter that arbitrates between the VC sym_rate_adapters for the master port. See Figure below:</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16156669/VC_rateAdapter.svg?api=v2"></span></p><p>The in and out interfaces used by sym_rate_adapters_in and sym_rate_adapter_out are different than the in and out interfaces given to the block; they only have single bit ready and valid signals. The master interface arbiter supports all the available primitive arbiter types: arb_rr1, arb_rr2, arb_pri_rr1, arb_pri_rr2, arb_wrr_rr1 and arb_wrr_rr2. For a description of those arbitration schemes, refer to their microarchitecture documents.</p><p>The protection style applies only to the registers inside the block. The protection scheme of an interface is describe with additional parameters in the interface definition not shown here.</p><p>Everything in sym_vc_adapter_in is clocked by inClkInterface and uses inProtectionInterface. Everything in sym_vc_adapter_out is clocked by outClkInterface and uses outProtectionInterface.</p><p><br/></p>