<h1 id="ConcertoSystemArchitectureSpecification-_Toc447207624ConcertoSystemArchitectureSpecification"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207624"><span class="confluence-anchor-link" id="_Toc447207624"></span></span><strong>Concerto System Architecture Specification</strong></h1><h1 id="ConcertoSystemArchitectureSpecification-_Toc447207625Version0.17,31March2016"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207625"><span class="confluence-anchor-link" id="_Toc447207625"></span></span>Version 0.17, 31 March 2016</h1><p> </p><p> </p><p>Blah blah blah</p><ul><li><em><strong>Bullt</strong></em></li></ul><p> </p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th class="confluenceTh">This</th><th class="confluenceTh">is</th><th class="confluenceTh">a</th><th class="confluenceTh">table</th><th class="confluenceTh"> </th></tr><tr><td class="confluenceTd"> </td><td class="confluenceTd"> </td><td class="confluenceTd"> </td><td class="confluenceTd"> </td><td class="confluenceTd"> </td></tr><tr><td class="confluenceTd"> </td><td class="confluenceTd"> </td><td class="confluenceTd"> </td><td class="confluenceTd"> </td><td class="confluenceTd"> </td></tr><tr><td class="confluenceTd"> </td><td class="confluenceTd"> </td><td class="confluenceTd"> </td><td class="confluenceTd"> </td><td class="confluenceTd"> </td></tr><tr><td class="confluenceTd"> </td><td class="confluenceTd"> </td><td class="confluenceTd"> </td><td class="confluenceTd"> </td><td class="confluenceTd"> </td></tr></tbody></table></div><p> </p><p><br class="atl-forced-newline"/> <strong>History</strong>:</p><ul><li>Version 0.1, 28 April 2015.</li><li>Initial version</li><li>Version 0.2, 11 August 2015.</li><li>Reorganize major sections</li><li>Clean up power management section</li><li>Clean up error architecture section</li><li>Miscellaneous edits</li><li>Version 0.3, 21 August 2015.</li><li>Add CSR definitions</li><li>Clean up sections to be consistent with CSR definitions</li><li>Change IO cache fill error behavior</li><li>Add error logging description</li><li>Add memory array maintenance description</li><li>Version 0.4, 24 September 2015.</li><li>Add information on allowed data widths</li><li>Add minimum width for coherence window</li><li>Change reset value for agent transaction enable bit</li><li>Change behavior of coherent address error</li><li>Clarify error behavior on memory update</li><li>Change definition of error status register</li><li>Limit CSR accesses to 32 bits</li><li>Fill in more details on CSRs</li><li>Version 0.5, 7 October 2015.</li><li>Define ErrResult encodings</li><li>Update behavior of error status register</li><li>Update software access to error status register</li><li>Add behavior on multiple errors</li><li>Add unit and proxy cache identification registers</li><li>Version 0.6, 16 October 2015.</li><li>Change DCE hint enable register</li><li>Define caching agent ID in AIU ID register</li><li>Modify some ID register fields</li><li>Version 0.7, 2 November 2015.</li><li>Change data width restrictions</li><li>Clarify coherence window alignment</li><li>Clarify terminal error behavior</li><li>Update UPDrsp error signaling</li><li>Fix typo in register name</li><li>Version 0.8, 19 November 2015.</li><li>Define system connectivity based on protocol messages and addresses</li><li>Update error status register behavior</li><li>Version 0.9, 30 November 2015.</li><li>Update behavior of snoop filter enable bits</li><li>Update IO cache fill error behavior</li><li>Define behaviors for registers in the context of different configurations</li><li>Version 0.10, 14 December 2015.</li><li>Clarify SNPrsp message for disabled DVM agents</li><li>Change behavior of AIU transport errors</li><li>Clarify propagation of errors in data transfer messages that result from snoops</li><li>Clarify behavior of the error count field</li><li>Version 0.11, 14 January 2016.</li><li>Update power management behavior</li><li>Clarify certain error behaviors</li><li>Remove all terminal errors</li><li>Accommodate multi-bit security attributes in errors and maintenance operations</li><li>Clarify certain maintenance operation behaviors</li><li>Version 0.12, 28 January 2016.</li><li>Clarify upgrade behavior when fill enable is clear</li><li>Change meaning of snoop filter enable for null filter</li><li>Clean up some error behaviors and typos</li><li>Update error logging tables for IO cache</li><li>Specify more details about index/way flush operations</li><li>Update identification register information</li><li>Version 0.13, 15 February 2016.</li><li>Change behavior of AIU transaction active bit</li><li>Rename transaction active and snoop transaction active bits</li><li>Change IO cache and AIU offline sequence</li><li>Change DCE transport error behavior</li><li>Change the label for the maintenance set field</li><li>Change the name of set and way operations</li><li>Clarify the conditions under which debug operations return undefined values</li><li>Add transaction table debug section</li><li>Fix description of ACE DVM registers</li><li>Version 0.14, 26 February 2016.</li><li>Update data width restrictions for release 1.5</li><li>Remove structure identifier assignments for transaction table debug accesses</li><li>Add support for agent isolation mode</li><li>Add release code for 1.5</li><li>Version 0.15, 9 March 2016.</li><li>Clarify agent isolation mode behavior</li><li>Clarify prerequisites for AIU transitions to the <em>offline</em> state</li><li>Define single agent low-power state</li><li>Define victim buffer maintenance</li><li>Add victim buffers to snoop filter ID registers</li><li>Version 0.16, 22 March 2016.</li><li>Change Error Type code for a certain proxy cache error</li><li><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_GoBack"><span class="confluence-anchor-link" id="_GoBack"></span></span>Version 0.17, 31 March 2016.</li><li>Add coherent transaction active bit</li><li>Modify the behavior of AIU active bits to match implementation</li><li>Add failure result bit for debug operations</li></ul><p> </p><h1 id="ConcertoSystemArchitectureSpecification-_Toc447207626TableofContents"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207626"><span class="confluence-anchor-link" id="_Toc447207626"></span></span>Table of Contents</h1><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207624">Concerto System Architecture Specification </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207625">Version 0.17, 31 March 2016 </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207626">Table of Contents </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207627">1.0 Introduction </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207628">2.0 System Topology </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207629">2.1 Concerto Transport Interconnects </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207630">2.2 Non-Coherent Transport Interconnects </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207631">2.3 Agent AIU Connectivity </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207632">2.4 Bridge AIU Connectivity </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207633">2.4.1 Restrictions </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207634">2.5 DCE Connectivity </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207635">2.6 DMI Connectivity </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207636">2.6.1 Restrictions </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207637">2.7 Initiator-Target Connectivity </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207638">2.7.1 Message Connectivity </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207639">2.7.2 Address Connectivity </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207640">2.7.3 Implementation Notes </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207641">2.8 Data Widths </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207642">2.8.1 Release 1.0 </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207643">2.8.2 Release 1.5 </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207644">3.0 Memory Addressing </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207645">3.1 AIU Addresses </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207646">3.2 DCE Addresses </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207647">3.3 DMI Addresses </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207648">3.4 Address Mapping </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207649">3.5 Notes </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207650">4.0 Secure Accesses </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207651">4.1 Background </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207652">4.2 SFI Signaling </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207653">4.3 Concerto V1 Security Models </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207654">5.0 Quality of Service </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207655">5.1 Background </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207656">5.2 SFI Signaling </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207657">6.0 Reset and Initialization </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207658">6.1 Background </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207659">6.2 AIU Reset and Initialization </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207660">6.3 DCE Reset and Initialization </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207661">6.4 DMI Reset and Initialization </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207662">7.0 Power Management </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207663">7.1 Background </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207664">7.2 Unit Control and Status </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207665">7.2.1 AIU Control and Status </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207666">7.2.2 DCE Control and Status </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207667">7.2.3 DMI Status </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207668">7.3 Unit and Subunit Activity States </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207669">7.3.1 IO Cache (Proxy Cache) Activity States </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207670">7.3.2 AIU (Coherent Agent Interface Unit/Non-coherent Bridge Unit) Activity States </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207671">7.3.3 Directory Segment (Snoop Filter Segment) Activity States </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207672">7.3.4 DCE (Directory Unit) Activity States </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207673">7.3.5 DMI (Coherent Memory Interface Unit) Activity States </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207674">7.4 Subsystem Activity States </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207675">7.4.1 Interleaved AIU (Coherent Agent Interface/Non-coherent Bridge) Activity States </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207676">7.4.2 Directory Slice (Snoop Filter) Activity States </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207677">7.4.3 Interleaved DMI (Coherent Memory Interface) Activity States </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207678">7.4.4 Coherence Domain (Coherent Subsystem) Activity States </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207679">7.4.5 Single Agent Low-Power State </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207680">8.0 Error Architecture </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207681">8.1 Background </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207682">8.2 Features </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207683">8.3 Correctable Errors </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207684">8.3.1 AIU Correctable Errors </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207685">8.3.2 DCE Correctable Errors </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207686">8.3.3 DMI Correctable Errors </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207687">8.4 Uncorrectable Errors </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207688">8.4.1 AIU Uncorrectable Errors </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207689">8.4.2 DCE Uncorrectable Errors </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207690">8.4.3 DMI Uncorrectable Errors </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207691">8.5 Transport Errors </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207692">8.5.1 Transport Requirements </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207693">8.5.2 AIU Transport Errors </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207694">8.5.3 DCE Transport Errors </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207695">8.5.4 DMI Transport Errors </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207696">8.6 Propagated Errors </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207697">8.6.1 AIU Propagated Errors </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207698">8.6.2 DCE Propagated Errors </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207699">8.6.3 DMI Propagated Errors </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207700">8.7 Error Logging and Interrupts </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207701">8.7.1 Implementation Notes </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207702">9.0 Maintenance and Debug </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207703">9.1 Memory Array Maintenance and Debug </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207704">9.1.1 IO Cache (Proxy Cache) Maintenance and Debug </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207705">9.1.2 Directory Segment (Snoop Filter) Maintenance and Debug </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207706">9.2 Transaction Table Debug </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207707">9.2.1 Implementation Notes </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207708">9.3 Transaction Tracing </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207709">9.4 Programming Errors </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207710">10.0 Performance Monitoring </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207711">11.0 Software Model </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207712">11.1 Background </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207713">11.2 Coherent Agent Interface Unit Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207714">11.2.1 CAIU Transaction Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207715">11.2.2 CAIU Proxy Cache Transaction Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207716">11.2.3 CAIU Proxy Cache Maintenance Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207717">11.2.4 CAIU Correctable Error Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207718">11.2.5 CAIU Uncorrectable Error Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207719">11.2.6 CAIU Identification Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207720">11.3 Non-coherent Bridge Unit Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207721">11.3.1 NCBU Transaction Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207722">11.3.2 NCBU Proxy Cache Transaction Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207723">11.3.3 NCBU Proxy Cache Maintenance Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207724">11.3.4 NCBU Correctable Error Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207725">11.3.5 NCBU Uncorrectable Error Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207726">11.3.6 NCBU Identification Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207727">11.4 Directory Unit Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207728">11.4.1 DIRU Transaction Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207729">11.4.2 DIRU Snoop Filter Control Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207730">11.4.3 DIRU Caching Agent Snoop Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207731">11.4.4 DIRU Hint Control Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207732">11.4.5 DIRU Snoop Filter Maintenance Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207733">11.4.6 DIRU Correctable Error Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207734">11.4.7 DIRU Uncorrectable Error Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207735">11.4.8 DIRU Identification Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207736">11.5 Coherent Memory Interface Unit Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207737">11.5.1 CMIU Transaction Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207738">11.5.2 CMIU Correctable Error Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207739">11.5.3 CMIU Uncorrectable Error Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207740">11.5.4 CMIU Identification Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207741">11.6 Coherent Subsystem Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207742">11.6.1 Coherent Subsystem ACE DVM Transaction Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207743">11.6.2 Coherent Subsystem Error Interrupt Status Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207744">11.6.3 Coherent Subsystem Identification Registers </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207745">12.0 Random Stuff </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207746">12.1 Topology Notes </a><br/> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-_Toc447207747">12.2 Power Management Notes </a></p><h1 id="ConcertoSystemArchitectureSpecification-_Toc447207627Introduction"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207627"><span class="confluence-anchor-link" id="_Toc447207627"></span></span> Introduction</h1><p>This specification describes the high-level Concerto System Architecture, which defines the following:</p><ul><li>System Topology</li><li>Memory Addressing</li><li>Secure Accesses</li><li>Quality of Service</li><li>Reset and Initialization</li><li>Power Management</li><li>Error Architecture</li><li>Maintenance and Debug</li><li>Performance Monitoring</li><li>Software Model</li></ul><p>Additional information may be found in the following documents:</p><ul><li><em>Concerto Messaging Protocol Specification</em></li><li><em>Concerto ACE AIU Architecture Specification</em></li><li><em>Concerto ACE-Lite AIU Architecture Specification</em></li><li><em>Concerto DCE Architecture Specification</em></li><li><em>Concerto DMI Architecture Specification</em></li><li><em>Concerto System Parameter Specification</em></li></ul><h1 id="ConcertoSystemArchitectureSpecification-_Ref416205723_Toc447207628SystemTopology"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref416205723"><span class="confluence-anchor-link" id="_Ref416205723"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207628"><span class="confluence-anchor-link" id="_Toc447207628"></span></span>System Topology</h1><p>A Concerto-based system consists of one or more <strong><em>transport interconnects</em></strong>, which act as a substrate for transferring Concerto protocol messages between units and for carrying transactions between other system agents. This section describes the requirements related to how Concerto units interface to various transport interconnects in the system.<br/> <strong><em>Note:</em></strong> In Concerto V1, a transport interconnect is a FlexNoC instance.</p><h2 id="ConcertoSystemArchitectureSpecification-_Ref416187723_Ref416205397_Toc447207629ConcertoTransportInterconnects"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref416187723"><span class="confluence-anchor-link" id="_Ref416187723"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref416205397"><span class="confluence-anchor-link" id="_Ref416205397"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207629"><span class="confluence-anchor-link" id="_Toc447207629"></span></span>Concerto Transport Interconnects</h2><p>Concerto units perform coherent protocol transactions by communicating via protocol messages sent and received on SFI interfaces. Concerto units are grouped into coherence domains, and in a system with a single coherence domain, all SFI master and slave interfaces are connected to a default transport interconnect known as the <strong><em>ConcertoDomainTI</em></strong>. The connectivity matrix and global address map (see Section 3.4) for the ConcertoDomainTI are defined based on the system configuration and <em>must not</em> be modified by a user.<br/> An additional service network, the <strong><em>ConcertoServiceTI</em></strong>, transports CSR accesses to all the units in a coherence domain. Each Concerto unit implements an OCP-Lite slave interface for receiving CSR requests and sending CSR responses. The ConcertoServiceTI connects these interfaces and presents an OCP slave interface that may be connected to a transport interconnect specified and configured by a user to transport non-coherent transactions (see Section 2.2). The connectivity matrix and global address map for the ConcertoServiceTI are defined based on the system configuration and <em>must not</em> be modified by a user.<br/> The two Concerto transport interconnects <em>must not</em> share any internal transport resources.<br/> <strong><em>Note:</em></strong> Future versions of the architecture may support multiple coherence domains. In such a system, each coherence domain has a unique ConcertoDomainTI and ConcertoServiceTI.<br/> The protocol assigns each Concerto unit a logical UnitID, which determines the default SFI slave ID, known as a <strong>SFISlvID</strong>, for the slave interface on that unit. The <strong>SFISlvID</strong> is a transport layer identifier that is used to direct traffic from an SFI master interface to an SFI slave interface. Both UnitIDs and <strong>SFISlvID</strong>s are numbered from 0 to (<em>N</em>-1), where <em>N</em> equals the number of Concerto units, and each unit, based on its type, is numbered within this namespace as follows:</p><ul><li>0 to (<em>A</em>-1): Agent AIUs, where <em>A</em> equals the number of Agent AIUs</li><li><em>A</em> to (<em>A</em>+<em>B</em>-1): Bridge AIUs, where <em>B</em> equals the number of Bridge AIUs</li><li>(<em>A</em><span style="text-decoration: underline;"><em>B</em>) to (<em>A</em></span><em>B</em>+<em>D</em>-1): DCEs, where <em>D</em> equals the number of DCE instances</li><li>(<em>A</em><span style="text-decoration: underline;"><em>B</em></span><em>D</em>) to (<em>A</em><span style="text-decoration: underline;"><em>B</em></span><em>D</em>+<em>M</em>-1): DMIs, where <em>M</em> equals the number of DMI instances</li></ul><p><strong><em>Note:</em></strong> <em>A</em><span style="text-decoration: underline;"><em>B</em></span><em>D</em>+<em>M</em> equals <em>N</em>.<br/> <strong><em>Note:</em></strong> In future versions of the architecture, units may implement additional SFI slave ports, which will be assigned <strong>SFISlvID</strong>s that are greater than or equal to <em>N</em>.</p><h2 id="ConcertoSystemArchitectureSpecification-_Ref413924440_Toc447207630Non-CoherentTransportInterconnects"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref413924440"><span class="confluence-anchor-link" id="_Ref413924440"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207630"><span class="confluence-anchor-link" id="_Toc447207630"></span></span>Non-Coherent Transport Interconnects</h2><p>To transport non-coherent traffic between non-coherent initiators and targets, a user may configure the ConcertoDomainTI to carry non-coherent traffic in addition to coherent traffic or may specify and configure one or more additional transport interconnects. In the latter case, such a transport interconnect is known generically as a <strong><em>NonCoherentTI</em></strong>.</p><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207631AgentAIUConnectivity"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207631"><span class="confluence-anchor-link" id="_Toc447207631"></span></span>Agent AIU Connectivity</h2><p>An AIU configured to communicate directly with a fully-coherent or IO-coherent agent is an <strong><em>Agent AIU</em></strong> that functions as an <strong><em>agent interface</em></strong> to the coherence domain. By definition, the slave native agent interface on an Agent AIU is defined to be external to any transport interconnect. As required, the SFI master and slave interfaces are connected to the ConcertoDomainTI, and the OCP-Lite slave interface is connected to the ConcertoServiceTI.<br/> The AXI master interface on an Agent AIU may be configured to be external to any transport interconnect or may be configured to connect to the ConcertoDomainTI or one of a number of user-specified NonCoherentTIs.</p><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207632BridgeAIUConnectivity"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207632"><span class="confluence-anchor-link" id="_Toc447207632"></span></span>Bridge AIU Connectivity</h2><p>An AIU configured to communicate indirectly with one or more non-coherent agents is a <strong><em>Bridge AIU</em></strong> that functions as a <strong><em>bridge interface</em></strong> to the coherence domain. As required, the SFI master and slave interfaces are connected to the ConcertoDomainTI, and the OCP-Lite slave interface is connected to the ConcertoServiceTI.<br/> The slave native agent interface on a Bridge AIU may be configured to be external to any transport interconnect or may be configured to connect to the ConcertoDomainTI or one of a number of user-specified NonCoherentTIs.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207633Restrictions"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207633"><span class="confluence-anchor-link" id="_Toc447207633"></span></span>Restrictions</h3><p>A Bridge AIU may block inbound native agent requests on its slave native agent interface if either the unit runs out of internal resources or its outbound SFI master interface is blocked. The unit must also receive protocol request messages in order to complete a native agent transaction. As a result, the configuration of the transport interconnects <em>must</em> meet the following requirements:</p><ul><li>Blocking the slave native agent interface <em>must not</em> prevent the Bridge AIU from issuing protocol request messages on its SFI master interface.</li><li>Blocking the slave native agent interface <em>must not</em> prevent the Bridge AIU from receiving protocol request messages on its SFI slave interface.</li></ul><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207634DCEConnectivity"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207634"><span class="confluence-anchor-link" id="_Toc447207634"></span></span>DCE Connectivity</h2><p>The connectivity of a DCE is fixed. As required, the SFI master and slave interfaces are connected to the ConcertoDomainTI, and the OCP-Lite slave interface is connected to the ConcertoServiceTI.</p><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207635DMIConnectivity"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207635"><span class="confluence-anchor-link" id="_Toc447207635"></span></span>DMI Connectivity</h2><p>A DMI directly or indirectly connects the coherence domain to a memory. As required, the SFI master and slave interfaces are connected to the ConcertoDomainTI, and the OCP-Lite slave interface is connected to the ConcertoServiceTI.<br/> The master native memory interface may be configured to be external to any transport interconnect (to connect to a memory controller directly) or may be configured to connect to the ConcertoDomainTI or one of a number of user-specified NonCoherentTIs (to connect to a memory controller indirectly).</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207636Restrictions"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207636"><span class="confluence-anchor-link" id="_Toc447207636"></span></span>Restrictions</h3><p>A DMI may block inbound protocol request messages on its SFI slave interface if the unit runs out of internal resources; may block inbound memory read responses on its master native memory interface if its outbound SFI request is blocked; or may block memory write responses if its ou<span class="inline-comment-marker" data-ref="8889f247-893a-456a-977e-18f906b7707e">tbound SFI response interface is blocked. In addition, the master native memory interface or the path from the master native memory interface to the memory may implement shared resources for any combination of protocol messages, memory read transactions, and memory write transac</span>tions. As a result, the configuration of the transport interconnects and the DMI <em>must</em> meet the following requirements:</p><ul><li>Protocol messages and memory write transactions <em>must not</em> share transport interconnect resources.</li><li>If protocol messages and memory read transactions share transport interconnect resources (<em>and</em> protocol messages and memory write transactions <em>do not</em> share transport interconnect resources), the DMI <em>must</em> be configured with RTT-Data resources to accept memory read responses.</li><li>If memory read transactions and memory write transactions share transport interconnect resources (<em>and</em> protocol messages and memory write transactions <em>do not</em> share transport interconnect resources), the DMI <em>must</em> be configured with RTT-Data resources to accept memory read responses.</li></ul><p><strong><em>Note:</em></strong> By design, FlexNoC shares resources between AXI read and AXI write channels, so the above bullet applies when FlexNoC is used as a transport interconnect between a DMI and a memory controller.<br/> <strong><em>Note:</em></strong> The above requirements ensure that DTW messages and memory write transactions make forward progress to memory.</p><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207637Initiator-TargetConnectivity"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207637"><span class="confluence-anchor-link" id="_Toc447207637"></span></span>Initiator-Target Connectivity</h2><p>This section describes the connectivity between initiator units and target units in the system. These requirements are divided into two sets: the first set describes connectivity between initiator units and target units based on protocol messages and ACE DVM transaction support, and the second set further qualifies the connectivity based on the set of cacheline addresses associated with each unit.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207638MessageConnectivity"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207638"><span class="confluence-anchor-link" id="_Toc447207638"></span></span>Message Connectivity</h3><p>In terms of message connectivity, AIUs are classified as one of the following:</p><ul><li>A fully-coherent Agent AIU or a Bridge AIU configured with an IO cache (AIU-FC)</li><li>An IO-coherent Agent AIU or a Bridge AIU configured without an IO cache (AIU-IO)</li></ul><p>Table 1 shows the connectivity between pairs of units based on protocol control messages. Each cell lists the message types issued from an initiator unit (Init) to a target unit (Tgt). A cell marked &quot;---&quot; indicates that an initiator is <em>not</em> required to be connected to a target for protocol control messages.</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><strong>Tgt →</strong> <br class="atl-forced-newline"/> <strong>Init ↓</strong></p></td><td class="confluenceTd"><p><strong>AIU-FC</strong></p></td><td class="confluenceTd"><p><strong>AIU-IO</strong></p></td><td class="confluenceTd"><p><strong>DCE</strong></p></td><td class="confluenceTd"><p><strong>DMI</strong></p></td></tr><tr><td class="confluenceTd"><p><strong>AIU-FC</strong></p></td><td class="confluenceTd"><p>—</p></td><td class="confluenceTd"><p>—</p></td><td class="confluenceTd"><p><strong>CMD, UPD</strong></p></td><td class="confluenceTd"><p>—</p></td></tr><tr><td class="confluenceTd"><p><strong>AIU-IO</strong></p></td><td class="confluenceTd"><p>—</p></td><td class="confluenceTd"><p>—</p></td><td class="confluenceTd"><p><strong>CMD</strong></p></td><td class="confluenceTd"><p>—</p></td></tr><tr><td class="confluenceTd"><p><strong>DCE</strong></p></td><td class="confluenceTd"><p><strong>SNP, STR</strong></p></td><td class="confluenceTd"><p><strong>STR</strong></p></td><td class="confluenceTd"><p>—</p></td><td class="confluenceTd"><p><strong>HNT, MRD</strong></p></td></tr><tr><td class="confluenceTd"><p><strong>DMI</strong></p></td><td class="confluenceTd"><p>—</p></td><td class="confluenceTd"><p>—</p></td><td class="confluenceTd"><p>—</p></td><td class="confluenceTd"><p>—</p></td></tr></tbody></table></div><p><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref435696031"><span class="confluence-anchor-link" id="_Ref435696031"></span></span><strong>Table 1: Protocol Control Message Pairs</strong><br/> Table 2 shows the connectivity between pairs of units based on protocol data transfer messages. Each cell lists the message types issued from an initiator unit (Init) to a target unit (Tgt). A cell marked &quot;---&quot; indicates that an initiator is <em>not</em> required to be connected to a target for protocol data transfer messages.</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><strong>Tgt →</strong> <br class="atl-forced-newline"/> <strong>Init ↓</strong></p></td><td class="confluenceTd"><p><strong>AIU-FC</strong></p></td><td class="confluenceTd"><p><strong>AIU-IO</strong></p></td><td class="confluenceTd"><p><strong>DCE</strong></p></td><td class="confluenceTd"><p><strong>DMI</strong></p></td></tr><tr><td class="confluenceTd"><p><strong>AIU-FC</strong></p></td><td class="confluenceTd"><p><strong>DTR</strong></p></td><td class="confluenceTd"><p><strong>DTR</strong></p></td><td class="confluenceTd"><p>—</p></td><td class="confluenceTd"><p><strong>DTW</strong></p></td></tr><tr><td class="confluenceTd"><p><strong>AIU-IO</strong></p></td><td class="confluenceTd"><p>—</p></td><td class="confluenceTd"><p>—</p></td><td class="confluenceTd"><p>—</p></td><td class="confluenceTd"><p><strong>DTW</strong></p></td></tr><tr><td class="confluenceTd"><p><strong>DCE</strong></p></td><td class="confluenceTd"><p>—</p></td><td class="confluenceTd"><p>—</p></td><td class="confluenceTd"><p>—</p></td><td class="confluenceTd"><p>—</p></td></tr><tr><td class="confluenceTd"><p><strong>DMI</strong></p></td><td class="confluenceTd"><p><strong>DTR</strong></p></td><td class="confluenceTd"><p><strong>DTR</strong></p></td><td class="confluenceTd"><p>—</p></td><td class="confluenceTd"><p>—</p></td></tr></tbody></table></div><p><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref435696101"><span class="confluence-anchor-link" id="_Ref435696101"></span></span><strong>Table 2: Protocol Data Transfer Message Pairs</strong><br/> In terms of ACE DVM transaction support, AIUs are classified as one of the following:</p><ul><li>An AIU configured to issue DVM transactions (AIU-ISS)</li><li>An AIU configured to receive DVM transactions (AIU-RCV)</li></ul><p>Table 3 shows the connectivity between pairs of units based on ACE DVM transaction support. Each cell lists the message types issued from an initiator unit (Init) to a target unit (Tgt). A cell marked &quot;---&quot; indicates that an initiator is <em>not</em> required to be connected to a target for DVM-related protocol messages. Note that only DCE0 participates in DVM transactions.</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><strong>Tgt →</strong> <br class="atl-forced-newline"/> <strong>Init ↓</strong></p></td><td class="confluenceTd"><p><strong>AIU-ISS</strong></p></td><td class="confluenceTd"><p><strong>AIU-RCV</strong></p></td><td class="confluenceTd"><p><strong>DCE0</strong></p></td></tr><tr><td class="confluenceTd"><p><strong>AIU-ISS</strong></p></td><td class="confluenceTd"><p>—</p></td><td class="confluenceTd"><p>—</p></td><td class="confluenceTd"><p><strong>CMD</strong></p></td></tr><tr><td class="confluenceTd"><p><strong>AIU-RCV</strong></p></td><td class="confluenceTd"><p><strong>DTR</strong></p></td><td class="confluenceTd"><p>—</p></td><td class="confluenceTd"><p>—</p></td></tr><tr><td class="confluenceTd"><p><strong>DCE0</strong></p></td><td class="confluenceTd"><p><strong>STR</strong></p></td><td class="confluenceTd"><p><strong>SNP</strong></p></td><td class="confluenceTd"><p>—</p></td></tr></tbody></table></div><p><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref435696794"><span class="confluence-anchor-link" id="_Ref435696794"></span></span><strong>Table 3: ACE DVM-related Message Pairs</strong><br/> Only fully-coherent Agent AIUs may issue DVM transactions, and only fully-coherent Agent AIUs and IO-coherent Agent AIUs may receive DVM transactions.<br/> <strong><em>Note:</em></strong> DVM-related CMD and SNP messages contain 16B of payload, while DVM-related DTR messages contain no payload. An implementation may optimize the datapaths for these messages accordingly.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207639AddressConnectivity"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207639"><span class="confluence-anchor-link" id="_Toc447207639"></span></span>Address Connectivity</h3><p>In addition to the association with a set of protocol messages, each unit is also associated with a set of cacheline addresses. Alternatively, each cacheline address is associated with a set of units. By definition, a cacheline address is associated with one and only one DCE and with one and only one DMI. In addition, a cacheline address is typically associated with <em>all</em> AIUs. However, depending on the system configuration, a given cacheline address may be associated with a subset of AIUs, which implies that a given AIU issues and receives messages for a subset of cacheline addresses.<br/> <strong><em>Note:</em></strong> A set of Agent AIUs may be associated with disjoint sets of cacheline addresses when an agent implements more than one native agent interface and interleaves transactions among the native agent interfaces based on the transaction address. This case also applies to interleaving cacheline addresses across multiple Bridge AIUs.<br/> An initiator unit connected to a target unit because of protocol message connectivity is <em>not</em> required to be connected to that target unit if the set of cacheline addresses associated with the initiator unit is disjoint from the set of cacheline addresses associated with the target unit. In other words, if Table 1 or Table 2 indicate that an initiator unit should be connected to a target unit, but the two units do <em>not</em> share <em>any</em> cacheline addresses in common, the initiator is <em>not</em> required to be connected to the target.

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2041" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2041?src=confmacro" class="jira-issue-key">CONC-2041</a>
                            </span>
<br/> Units connected by DVM-related messages, as shown in Table 3, <em>must</em> always be connected regardless of their association with cacheline addresses.<br/> <strong><em>FIXME:</em></strong> Need to distinguish between interleaved AIUs that cannot process transactions that cross the interleave boundary (sets of cacheline addresses are disjoint) and interleaved AIUs that can process transactions that cross the interleave boundary (sets of cacheline addresses are equal).</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207640ImplementationNotes"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207640"><span class="confluence-anchor-link" id="_Toc447207640"></span></span>Implementation Notes</h3><p>To minimize transport interconnect implementation costs, Concerto <em>should not</em> implement connectivity between units when connectivity is <em>not</em> required.</p><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207641DataWidths"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207641"><span class="confluence-anchor-link" id="_Toc447207641"></span></span>Data Widths</h2><p>Concerto units do not perform any data width conversion between their inbound slave and outbound master interfaces. However, individual units may have different data widths, necessitating data width conversion in the transport interconnect. Additional logic may be instantiated in the units to support such conversion.<br/> The rules and restrictions for each release are outlined below.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207642Release1.0"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207642"><span class="confluence-anchor-link" id="_Toc447207642"></span></span>Release 1.0</h3><p>FlexNoC may be used to convert the width of data transferred between two units as long as the data width of the unit that initiates a protocol transaction, i.e. the <strong><em>requesting unit</em></strong>, is greater than or equal to the data width of the unit that supplies data in response to the protocol transaction, i.e. the <strong><em>responding unit</em></strong>. This requirement ensures that the address of the protocol transaction from the requesting unit is always aligned to the address of the responding unit and that, at most, FlexNoC only needs to gather data beats to provide data to the requesting unit (as opposed to reordering data beats to meet the requesting unit's address alignment).<br/> As a result of the above restriction, the width of the data bus for an AIU associated with a caching agent (i.e. an Agent AIU associated with a fully-coherent agent or a Bridge AIU configured with an IO cache) must be less than or equal to the width of the data bus for an AIU associated with a non-caching agent (i.e. an Agent AIU associated with an IO-coherent agent or a Bridge AIU configured without an IO cache). Furthermore, the width of the data bus for a DMI must be less than or equal to the widths of the data buses for all AIUs.<br/> <strong><em>Note:</em></strong> A DCE does not supply data in response to a protocol transaction, so its data width is not subject to the above requirements.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207643Release1.5"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207643"><span class="confluence-anchor-link" id="_Toc447207643"></span></span>Release 1.5</h3><p>DTR messages are initiated by an AIU in response to a SNP message or by a DMI in response to an MRD message. A responding AIU or a DMI aligns the address received in a SNP message or MRD message to its data width by zeroing the address bits that would result in an unaligned access, and the unit drives the resulting aligned address on its native agent or native memory interface. The unit also stores the values of the address bits zeroed in the alignment process, with the exception of the two least significant bits, to identify the critical word offset, in 32-bit granules, relative to the data width of the unit. When the responding unit issues the DTR message, the critical word offset is indicated in the <strong>SFIPriv</strong> field of the message.<br/> FlexNoC packs or unpacks the bytes as necessary to perform the data width conversion between the responding unit and the requesting unit but does not reorder any data. As a result, the DTR message is formatted to the data width of the requesting unit in the transport interconnect but the critical word may not be in the first data beat.<br/> Upon receiving the DTR message, the requesting unit buffers a number of 32-bit granules based on the offset transmitted in the DTR message to get to its critical word and then bypasses the data beat containing the critical word to the requesting agent. Once the remaining data beats have been bypassed, the buffered data beats are supplied to the requesting agent.<br/> DTW messages are initiated by the requesting unit. In this case, FlexNoC is used to convert the width and order of data transferred between any two units, regardless of the data width of either.<br/> Because of the above conversions, no width restrictions apply among the units. However, if the data width of a requesting unit is greater than or equal to the data widths of all responding units, the unit never needs to buffer data from a DTR message, and any buffering logic should be removed.</p><h1 id="ConcertoSystemArchitectureSpecification-_Ref435620269_Ref435620285_Toc447207644MemoryAddressing"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref435620269"><span class="confluence-anchor-link" id="_Ref435620269"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref435620285"><span class="confluence-anchor-link" id="_Ref435620285"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207644"><span class="confluence-anchor-link" id="_Toc447207644"></span></span>Memory Addressing</h1><p>An agent directly connected to a Concerto system through an Agent AIU, i.e. a fully-coherent agent or an IO coherent agent, views the layout of memory locations through its <strong><em>agent local address space</em></strong>, the size of which is determined by the width of the address bus on the agent's native interface. To enable shared memory semantics, each agent local address space is mapped directly into the Concerto <strong><em>system address space</em></strong>, i.e. address zero in an agent local address space corresponds to address zero in the system address space. The size of the system address space is equal to the size of the smallest agent local address space of the agents connected through an Agent AIU. Although addresses in an agent local address space outside the system address space may be mapped to memory locations in a system, Concerto does <em>not</em> keep the memory locations associated with those addresses coherent.<br/> <strong><em>Example:</em></strong> If Concerto agent A implements a 44b address bus and Concerto agent B implements a 40b address bus, the sizes of the agent local address spaces for agents A and B are 16TB and 1TB, respectively. The Concerto system address space is defined to be the common subset of all fully-coherent and IO-coherent agent local address spaces, or 1TB.<br/> Within the Concerto system address space, a number of <strong><em>cache coherence capable memory regions</em></strong> may be defined. These regions represent the set of addresses in the Concerto system address space on which Concerto units may enforce hardware cache coherence. Each cache coherence capable memory region <em>must</em> consist of &quot;normal&quot; system memory, and typically, such a region defines a large contiguous block of addresses that correspond to off-chip DRAM, on-chip SRAM, etc.<br/> <strong><em>Note:</em></strong> These memory regions define the set of address on which cache coherence is <em>possible</em>, and software may choose to map addresses in these regions as non-coherent.<br/> Since the addresses in the cache coherence capable memory regions represent a subset of the total system address space, Concerto units transmit and store a compressed form of the system address that represents an offset into the <strong><em>cache coherence window</em></strong>. The cache coherence window is defined to be the smallest memory region that encompasses all the cache coherence capable memory regions and that is aligned to a power-of-two bytes. Within the window, the cache coherence capable memory regions maintain their relative locations, and cache coherence may not be possible on all addresses in the window. In addition, by definition, the high-order address bits of the cache coherence window, or the <strong><em>cache coherence window prefix</em></strong>, equal the high-order address bits common to <em>all</em> cache coherence capable memory regions. Since these bits are constant for all possible coherent addresses, the bits are not transmitted between or stored in Concerto units. Regardless of the total address space represented by the cache coherence capable memory regions, the minimum size of the cache coherence window is 1MB, so that that minimum width of the address offset is 20 bits.

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2042" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2042?src=confmacro" class="jira-issue-key">CONC-2042</a>
                            </span>
<br/> <strong><em>Note:</em></strong> To minimize the number of bits required to represent the cache coherence window, this specification recommends that the cache coherence capable memory regions be located as close to each other as possible in the Concerto system address space.<br/> The remaining subsections describe the addressing of each of the Concerto unit interfaces. A final subsection describes how the Concerto address spaces and regions map into FlexNoC.</p><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207645AIUAddresses"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207645"><span class="confluence-anchor-link" id="_Toc447207645"></span></span>AIU Addresses</h2><p>The interfaces of an AIU transmit and receive addresses in different address spaces. For an Agent AIU, the native agent interface receives and transmits addresses in the agent local address space; for a Bridge AIU, the native agent interface receives addresses in the cache coherence window. Also, for an Agent AIU, the AXI master transmits addresses in the agent local address space. The SFI master interface transmits addresses in the cache coherence window, while the SFI slave interface receives addresses in the cache coherence window. <br/> When translating an address in the agent local address space to an address in the cache coherence window, e.g. when transmitting a transaction from the native agent interface to the SFI master interface, the AIU removes the cache coherence window prefix from the agent local address. When translating an address in the cache coherence window to an address in the agent local address space, e.g. when transmitting a transaction from the SFI slave interface to the native agent interface, the AIU prepends the cache coherence window prefix to the address in the cache coherence window.<br/> In the case where the width of the agent local address is greater than the width of the Concerto system address, the leading zeros are also removed and added as appropriate.</p><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207646DCEAddresses"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207646"><span class="confluence-anchor-link" id="_Toc447207646"></span></span>DCE Addresses</h2><p>The SFI interfaces of a DCE transmit and receive addresses in the cache coherence window.</p><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207647DMIAddresses"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207647"><span class="confluence-anchor-link" id="_Toc447207647"></span></span>DMI Addresses</h2><p>The SFI master interface of a DMI transmits addresses in the cache coherence window, and the SFI slave interface receives addresses in the address space of the associated cache coherence capable memory region. On the native memory interface, this address space is known as the <strong><em>memory local address space</em></strong>.</p><h2 id="ConcertoSystemArchitectureSpecification-_Ref413921374_Toc447207648AddressMapping"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref413921374"><span class="confluence-anchor-link" id="_Ref413921374"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207648"><span class="confluence-anchor-link" id="_Toc447207648"></span></span>Address Mapping</h2><p>Internally, FlexNoC implements a <strong><em>global address space</em></strong> into which <strong><em>initiator local address spaces</em></strong> are mapped and from which <strong><em>target local address spaces</em></strong> are mapped. In effect, the FlexNoC global address space is a common frame of reference for all initiator and target local address spaces. An address in the FlexNoC global address space is a 63b value.<br/> In Concerto, each AXI master and each SFI master has a corresponding initiator local address space, and each SFI slave has a corresponding target local address space:</p><ul><li>For an AXI master on an Agent AIU, the initiator local address space is equal to the agent local address space, which may be greater than or equal to the Concerto system address space.</li><li>For an SFI master on an AIU or a DCE, the initiator local address space is equal to the Concerto cache coherence window.</li><li>For an SFI master on a DMI, the initiator local address space is equal to the Concerto cache coherence window.</li><li>For an SFI slave on an AIU or a DCE, the target local address space is equal to the Concerto cache coherence window.</li><li>For an SFI slave on a DMI, the target local address space is equal to the address space of the associated cache coherence capable memory region.</li></ul><p>Depending on the configuration of the system, certain native interfaces may also have an initiator or target local address space:</p><ul><li>For a native agent interface on a Bridge AIU, which may be connected to FlexNoC as a target, the target local address space is equal to the Concerto cache coherence window.</li><li>For a native memory interface on a DMI, which may be connected to FlexNoC as an initiator, the initiator local address space is equal to the address space of the associated cache coherence capable memory region.</li></ul><p>Starting at FlexNoC global address 0x4000_0000_0000_0000, the <strong><em>SFI mapping region</em></strong> is reserved for mapping the Concerto cache coherence window among SFI masters and SFI slaves. For all SFI masters, the initiator local address space is mapped into the global address space by concatenating the SFISlvID of a transaction with the initiator's local address relative to the cache coherence window and then adding that value to the base address of the SFI mapping region. As a result, each SFI slave has a corresponding alias of the Concerto cache coherence window in the FlexNoC global address space. For SFI slaves on AIUs and DCEs, the corresponding alias is mapped into the target local address space in its entirety, and for SFI slaves on DMIs, only the portion of the corresponding alias associated with the cache coherence capable memory region is mapped into the target local address space.<br/> For an Agent AIU, the initiator local address space of the AXI master <em>must</em> be mapped into the FlexNoC global address space. All or a portion of the initiator local address space may be mapped into the global address space, and the local to global address mappings do not need to be contiguous.<br/> For a Bridge AIU, a portion of the FlexNoC global address space <em>must</em> be mapped into the target local address space of the native interface. This portion of the FlexNoC global address space becomes an alias for the cache coherence window, and all or a portion of the initiator local address space for an agent may be mapped into the alias. A non-coherent access by that agent to a local address mapped into the alias becomes IO-coherent through the corresponding Bridge AIU.<br/> Memory locations corresponding to addresses in the cache coherence capable memory regions may be accessed coherently or non-coherently. In the coherent case, the addresses in the agent local address space correspond to addresses in the memory local address space of a particular cache coherence capable memory region. In the non-coherent case, the addresses in the agent local address space correspond to addresses in a target local address space. The memory local address space and target local address space <em>must</em> access the same memory locations through a mechanism such as a multi-port memory controller or a FlexNoC instance. In the latter case, the memory local address space equals an initiator local address space that <em>must</em> be mapped into the defined target local address space for those memory locations.<br/> Unless explicitly noted, the initiator and target local address spaces are aligned to their respective sizes in the FlexNoC <span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-Section9.1"><span class="confluence-anchor-link" id="Section 9.1"></span></span>address space.</p><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207649Notes"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207649"><span class="confluence-anchor-link" id="_Toc447207649"></span></span>Notes</h2><ul><li>All agent local address spaces start at zero in the Concerto system address space.</li><li>Cache coherence capable memory regions are specified relative to system address zero. Each memory region is located at a delta relative to system address zero, where the delta is equal to some integer multiple of the size of the memory region. This multiple represents the cache coherence capable memory region prefix.</li><li>A shared address X in each agent local address space must map to the same destination memory location in the system, regardless of whether the access is coherent (i.e. via an SFI master) or non-coherent (i.e. via an AXI master).</li><li>Concerto units do not perform any address translation between an agent local address space and the cache coherence window other than removing and adding the high-order address bits corresponding to the cache coherence window prefix.</li></ul><h1 id="ConcertoSystemArchitectureSpecification-_Toc447207650SecureAccesses"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207650"><span class="confluence-anchor-link" id="_Toc447207650"></span></span>Secure Accesses</h1><p>This section describes how Concerto performs secure accesses.</p><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207651Background"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207651"><span class="confluence-anchor-link" id="_Toc447207651"></span></span><span class="inline-comment-marker" data-ref="88d60a59-81ee-4359-a28e-559e0a2a3056">Background</span></h2><p>Concerto defines a protocol transaction <strong><em>security attribute</em></strong> that allows a system to implement multiple <strong><em>security models</em></strong>. The behavior of a security model is a function of the security architecture of the system agents, and the security attribute defines the type of security required for a given protocol transaction.<br/> A Concerto system can be configured to enable or disable the security attribute. If the security attribute is enabled, each AIU translates the security status of a native agent request into the security attribute, which is propagated in CMDreq messages to the Home DCE, in SNPreq messages to the snooping AIUs, in HNTreq and MRDreq messages to the Home DMI, and in DTWreq messages to the Home DMI. The individual units interpret the security attribute and perform security functionality based on the security model. On the other hand, if the security attribute is disabled, the security attribute is neither propagated nor interpreted in the Concerto units, and all coherent transactions from system agents must have the same security status for proper system operation.

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2043" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2043?src=confmacro" class="jira-issue-key">CONC-2043</a>
                            </span>
</p><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207652SFISignaling"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207652"><span class="confluence-anchor-link" id="_Toc447207652"></span></span>SFI Signaling</h2><p>The security attribute is transmitted in transport transactions on the SFI <strong>Security</strong> signal. In Concerto V1, if the security attribute is enabled, this signal is implemented as a single bit; otherwise, the signal is omitted.</p><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207653ConcertoV1SecurityModels"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207653"><span class="confluence-anchor-link" id="_Toc447207653"></span></span>Concerto V1 Security Models</h2><p>Concerto V1 supports the ARM TrustZone security model. In this model, the security attribute represents the <strong><em>NS bit</em></strong>, or non-secure bit. When the NS bit equals zero, the agent is performing a secure memory access, and when the NS bit equals one, the agent is performing a non-secure access. On ACE and ACE-Lite agents, the NS bit is signaled on bit [1] of the <strong>AxPROT</strong> signal, and the value of the NS bit is copied into the <strong>Security</strong> signal.<br/> To support the TrustZone model in general, the security attribute <em>must</em> be stored in address buffers and tag filter entries, and any address comparisons <em>must</em> include comparison of the security attribute as well. To avoid security model violations, any address comparison where the security attribute mismatches is considered to be a mismatch.

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2044" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2044?src=confmacro" class="jira-issue-key">CONC-2044</a>
                            </span>
</p><h1 id="ConcertoSystemArchitectureSpecification-_Toc447207654QualityofService"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207654"><span class="confluence-anchor-link" id="_Toc447207654"></span></span>Quality of Service</h1><p>This section describes how Concerto supports Quality of Service features in the transport interconnect.</p><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207655Background"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207655"><span class="confluence-anchor-link" id="_Toc447207655"></span></span>Background</h2><p>Each Concerto protocol transaction has an associated <strong><em>transaction priority level</em></strong>, ranging from a value of 0 (the lowest priority) to a configurable value (the highest priority) specified by a Concerto parameter. The transaction priority level of the protocol transaction is applied to all transport transactions that result from that protocol transaction. In the transport interconnect, where multiple transport transactions are vying for shared resources, the transport transaction with the highest transaction priority level is given access to those resources.

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2045" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2045?src=confmacro" class="jira-issue-key">CONC-2045</a>
                            </span>
<br/> Upon accepting a native agent transaction from an agent, the AIU maps any native QOS attribute to the transaction priority level. This value is assigned to the initiating CMDreq message, and each Concerto unit buffers and propagates the transaction priority level in subsequent messages issued by the unit. The DMI maps the transaction priority level to a native QOS attribute when issuing memory read and memory write requests.<br/> In addition, each unit tracks the transaction priority level of the transport transactions that are ready to be issued but have not been issued. The highest transaction priority level of these transactions is signaled as sideband information to the transport interconnect as the <strong><em>unit priority level</em></strong>. The transport interconnect may use the unit priority level to temporarily raise the transaction priority level of preceding transport transactions to minimize head-of-line blocking in the transport interconnect.</p><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207656SFISignaling"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207656"><span class="confluence-anchor-link" id="_Toc447207656"></span></span>SFI Signaling</h2><p>The transaction priority level is transmitted in transport transaction on the SFI <strong>Urgency</strong> signal, while the unit priority level is transmitted on the SFI <strong>Pressure</strong> signal. The SFI <strong>Hurry</strong> signal is tied to all zeros. The width of these signals is determined by a configuration parameter, and if the value of that parameter is zero, the transaction priority level and unit priority level are not implemented.</p><h1 id="ConcertoSystemArchitectureSpecification-_Toc447207657ResetandInitialization"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207657"><span class="confluence-anchor-link" id="_Toc447207657"></span></span>Reset and Initialization</h1><p>This section describes reset and initialization of the Concerto units.</p><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207658Background"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207658"><span class="confluence-anchor-link" id="_Toc447207658"></span></span>Background</h2><p>Each unit implements a single reset domain controlled by a single reset signal, <strong>RESET</strong>. When <strong>RESET</strong> is asserted, the following actions occur:</p><ul><li>The state machines and logic in the unit are initialized to a known and quiescent state</li><li>The &quot;ready&quot; signals on the slave interfaces of the unit are deasserted</li><li>The &quot;valid&quot; signals on the master interfaces of the unit are deasserted</li></ul><p><strong>RESET</strong> <em>must</em> be asserted a sufficient number of cycles to guarantee the above. Additionally, the assertion of <strong>RESET</strong> is asynchronous; however, its effects may be synchronous to a clock edge. <br/> <strong><em>Note:</em></strong> The architecture does not specify a polarity for the <strong>RESET</strong> signal.<br/> When <strong>RESET</strong> is deasserted, the unit may assert the &quot;ready&quot; signals on its slave interfaces. The deassertion of <strong>RESET</strong> is synchronous, and its effects must be synchronous.<br/> The following sections describe reset and initialization for each type of unit in more detail.</p><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207659AIUResetandInitialization"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207659"><span class="confluence-anchor-link" id="_Toc447207659"></span></span>AIU Reset and Initialization</h2><p>The assertion of <strong>RESET</strong> to an AIU causes the following actions to be performed:</p><ul><li>All OTT-Ctrl resources are initialized to invalid</li><li>All STT-Ctrl resources are initialized to invalid</li><li>All DSB resources are initialized to invalid</li><li>All DMB resources are initialized to invalid</li><li>All DCF resources are initialized to invalid</li><li>The Agent Transaction Enable bit is initialized to one

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2048" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2048?src=confmacro" class="jira-issue-key">CONC-2048</a>
                            </span>
</li></ul><p>The Agent Transaction Enable bit controls the &quot;ready&quot; signals on the native agent interface and is reset to one, meaning the &quot;ready&quot; signals may be asserted as soon as <strong>RESET</strong> is deasserted.<br/> For a Bridge AIU configured with an IO cache, the following actions are also performed:</p><ul><li>All CTT resources are initialized to invalid</li><li>All UTT resources are initialized to invalid</li><li>The Proxy Cache Lookup Enable bit is cleared (see Sections 11.2.2 and 11.3.2)</li><li>The Proxy Cache Fill Enable bit is cleared (see Sections 11.2.2 and 11.3.2)</li></ul><p>Software enables an IO cache by executing the &quot;Transition to Online&quot; sequence in Section 7.3.1.<br/> The effect of <strong>RESET</strong> on all AIU CSRs is described in Section 11.2.

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2049" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2049?src=confmacro" class="jira-issue-key">CONC-2049</a>
                            </span>
</p><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207660DCEResetandInitialization"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207660"><span class="confluence-anchor-link" id="_Toc447207660"></span></span>DCE Reset and Initialization</h2><p>The assertion of <strong>RESET</strong> to a DCE causes the following actions to be performed:</p><ul><li>All ATT skid entries are initialized to invalid</li><li>All ATT-Ctrl resources are initialized to invalid</li><li>All ATT-Snp resources are initialized to invalid</li><li>All ATT-Dmi resources are initialized to invalid</li></ul><p>For DCE0, the following actions are also performed:</p><ul><li>All DTF resources are initialized to invalid</li><li>All DSB resources are initialized to invalid</li><li>All DVM Agent Snoop Enable bits are cleared</li></ul><p>Finally, for all directory segments, the following actions are also performed:</p><ul><li>All Snoop Filter Enable bits are cleared (see Section 11.4.2)</li><li>All Caching Agent Snoop Enable bits are cleared (see 11.4.3)

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2050" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2050?src=confmacro" class="jira-issue-key">CONC-2050</a>
                            </span>
</li></ul><p>Software enables a directory segment by executing the &quot;Transition to Online&quot; sequence in Section 7.3.3.<br/> The effect of <strong>RESET</strong> on all DCE CSRs is described in Sections 11.4 and 11.6.</p><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207661DMIResetandInitialization"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207661"><span class="confluence-anchor-link" id="_Toc447207661"></span></span>DMI Reset and Initialization</h2><p>The assertion of <strong>RESET</strong> to a DMI causes the following actions to be performed:</p><ul><li>All HTT-Ctrl resources are initialized to invalid</li><li>All RTT skid entries are initialized to invalid</li><li>All RTT-Ctrl resources are initialized to invalid</li><li>All WTT-Ctrl resources are initialized to invalid

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2051" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2051?src=confmacro" class="jira-issue-key">CONC-2051</a>
                            </span>
</li></ul><p>The effect of <strong>RESET</strong> on all DMI CSRs is described in Section 11.5.</p><h1 id="ConcertoSystemArchitectureSpecification-_Toc447207662PowerManagement"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207662"><span class="confluence-anchor-link" id="_Toc447207662"></span></span>Power Management</h1><p>This section describes the Concerto power management architecture.</p><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207663Background"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207663"><span class="confluence-anchor-link" id="_Toc447207663"></span></span>Background</h2><p>Concerto power management features are divided into hardware-controlled features, such as fine-grained clock gating, and software-controlled features, such as control registers that disable protocol messages and status registers that provide unit activity status. Software that manages the power features is known as <strong><em>power management software</em></strong> (<strong><em>PMSW</em></strong>).<br/> Architecturally, a Concerto unit sits within a single voltage domain that may consist of one or more synchronous clock domains, depending on the type of unit. This organization implies that there are no voltage domain crossings or synchronizers implemented within a unit. Furthermore, clock gating at a clock domain level, or <strong><em>coarse-grained clock gating</em></strong>, is managed by software (or hardware) and is implemented outside the unit, while clock gating at a local level, or <strong><em>fine-grained clock gating</em></strong>, is performed by hardware based on local state to minimize dynamic power. Power and clock domains for any embedded IP, such as an SRAM, are outside the scope of the Concerto power management features.<br/> Depending on its configuration, a unit may have multiple clock domains. An AIU has a single clock domain for its core logic, and in a Bridge AIU with an IO cache, an additional clock domain may be implemented.

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2052" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2052?src=confmacro" class="jira-issue-key">CONC-2052</a>
                            </span>
 Likewise, a DCE has a single clock domain for its core logic, and if the DCE has been configured with one or more directory segments, one or more additional clock domains may be implemented for the directory entry storage. Finally, a DMI has a single clock domain for its core logic.<br/> Each unit or subunit, i.e. IO cache or directory segment, may be in one of two <strong><em>activity states</em></strong>: <em>online</em> or <em>offline</em>. A unit or subunit in the <em>online</em> state is capable of processing protocol transactions, while a unit or subunit in the <em>offline</em> state is <em>not</em> capable of processing protocol transactions. System agents initiate protocol transactions by performing <strong><em>native agent coherent transactions</em></strong>, and when a unit is in the <em>offline</em> state, system agents <em>must not</em> perform native agent coherent transactions that result in activity in that unit. System agents may perform <strong><em>native agent non-coherent</em></strong> <strong><em>transactions</em></strong>, which do not initiate protocol transactions, to access system memory locations without causing activity in units that are <em>offline</em>. On the other hand, when a subunit within a unit is in the <em>offline</em> state, the core logic in the unit must ensure that no activity occurs in the subunit.<br/> <strong><em>Note:</em></strong> The power management architecture assumes that agents have a mechanism to determine when all native agent coherent transactions have completed and can prevent further native agent coherent transactions from being issued by managing the translation tables or by disabling TLBs. In addition, to prevent an agent from performing a native agent coherent transaction that accesses an <em>offline</em> unit, agent caches may need to be flushed and disabled, and certain hardware features, e.g. prefetchers, may need to be disabled.<br/> <strong><em>Note:</em></strong> To perform a native agent non-coherent transaction, an agent typically maps a system memory location as either non-coherent or non-cacheable in its translation tables. A non-coherent mapping does not imply that the memory location is non-cacheable, however, and an agent may cache a non-coherent copy of the location.<br/> <strong><em>Note:</em></strong> In ACE and ACE-Lite, native agent non-coherent transactions correspond to ReadNoSnoop and WriteNoSnoop transactions.<br/> Once a unit or subunit is <em>offline</em>, the system may put the unit or subunit into a lower power state by reducing the clock frequency, gating the clock domain, or lowering the supply voltage to a retention level or ground. These steps may be taken only after other system requirements, which are outside the scope of the Concerto architecture, have been met.<br/> <strong><em>Note:</em></strong> The activity state applies only to the ability to process protocol transactions. As a result, transitioning a unit or subunit to the <em>offline</em> state is a necessary, but not sufficient, condition for entering lower power states.<br/> In addition to unit and subunit activity states, a number of <strong><em>subsystem activity states</em></strong> are defined relative to sets of units that are <em>online</em> or <em>offline</em>.</p><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207664UnitControlandStatus"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207664"><span class="confluence-anchor-link" id="_Toc447207664"></span></span>Unit Control and Status</h2><p>Concerto units implement control and status bits to allow PMSW to enable and disable certain protocol behaviors and to monitor activity within each unit. The following sections describe these bits.</p><h3 id="ConcertoSystemArchitectureSpecification-_Ref425156526_Toc447207665AIUControlandStatus"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref425156526"><span class="confluence-anchor-link" id="_Ref425156526"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207665"><span class="confluence-anchor-link" id="_Toc447207665"></span></span>AIU Control and Status</h3><p><span style="text-decoration: underline;">Control Bits</span><br/> An AIU implements an Agent Transaction Enable bit that controls whether native agent requests are accepted by the AIU. If the bit is set, the &quot;ready&quot; signal may be asserted on the native agent interface. If the bit is clear, the &quot;ready&quot; signal <em>must not</em> be asserted on the native agent interface.<br/> An Agent AIU also implements an Agent Isolation Enable bit that controls the translation of native agent coherent transactions into protocol transactions. If the bit is set, all native agent coherent transactions are translated into native agent non-coherent transactions or are terminated within the associated AIU. If the bit is clear, all native agent coherent transactions are processed normally.<br/> <strong><em>Note:</em></strong> For more information, see the <em>Concerto ACE AIU Architecture Specification</em>.<br/> A Bridge AIU configured with an IO cache implements a Proxy Cache Lookup Enable bit that controls whether a native agent request performs an IO cache lookup. If the bit is set, a native agent request accesses the IO cache, and data may be supplied from the IO cache or updated in the IO cache on a hit. If the bit is clear, a native agent request does <em>not</em> access the IO cache, and the IO cache lookup results in a miss.<br/> A Bridge AIU configured with an IO cache also implements a Proxy Cache Fill Enable bit that controls whether data are filled into the IO cache when an IO cache lookup results in a miss. If the bit is set, cacheline data are filled on a miss based on the IO cache allocation policy. If the bit is clear, cacheline data are <em>not</em> filled on a miss; additionally, if the cacheline data require an upgrade from shared to unique to perform a write, the copy of the cacheline is invalidated. If the Proxy Cache Lookup Enable bit is clear, the Proxy Cache Fill Enable bit <em>must</em> be clear also.<br/> <strong><em>Note:</em></strong> In effect, the state of the Proxy Cache Fill Enable bit is sampled as part of the IO cache lookup, and if the Proxy Cache Fill Enable bit is clear at that point, an IO cache entry is <em>not</em> allocated even if the state of the bit changes before the fill.

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2053" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2053?src=confmacro" class="jira-issue-key">CONC-2053</a>
                            </span>
<br/> <span style="text-decoration: underline;">Status Bits</span><br/> The AIU implements a Transaction Active bit that indicates transaction activity within the AIU. This bit is clear until a native agent transaction is received on the native agent interface and is set until all internal resources have been deallocated, all required protocol messages have been issued and received, and all native agent responses have been provided. In particular, this bit is clear when <em>all</em> of the following are true:</p><ul><li>For each native agent transaction received, a corresponding native agent response has been issued by the AIU and has been acknowledged by the agent</li><li>The Coherent Transaction Active bit is clear (see below)</li><li>The Snoop Transaction Active bit is clear (see below)

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2058" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2058?src=confmacro" class="jira-issue-key">CONC-2058</a>
                            </span>
</li></ul><p>If <em>any</em> of the above are false, the Transaction Active bit <em>must</em> be set.<br/> <strong><em>Note:</em></strong> The conditions for setting the Transaction Active bit are the same conditions that are used to enable the unit clock in hardware power management. As a result, the Transaction Active bit <em>must</em> be set whenever an active clock is required.<br/> The AIU also implements a Coherent Transaction Active bit that indicates protocol transaction activity within the AIU. This bit is clear until a native agent coherent transaction is received on the native agent interface and is set until all internal protocol transaction resources have been deallocated and all required protocol messages have been issued and received. In particular this bit is clear when <em>all</em> of the following are true:</p><ul><li>For each CMDreq message issued, a corresponding CMDrsp message has been received</li><li>For each DTWreq message issued from the OTT, a corresponding DTWrsp message has been received</li><li>For each UPDreq message issued, a corresponding UPDrsp message has been received</li><li>For each SNPreq message received, a corresponding SNPrsp message has been issued</li><li>For each STRreq message received, a corresponding STRrsp message has been issued</li><li>For each DTRreq message received, a corresponding DTRrsp message has been issued</li><li>All OTT resources have been deallocated</li><li>All DSB resources have been deallocated

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2040" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2040?src=confmacro" class="jira-issue-key">CONC-2040</a>
                            </span>
</li></ul><p>If <em>any</em> of the above are false, the Coherent Transaction Active bit <em>must</em> be set.<br/> The AIU also implements a Snoop Transaction Active bit that indicates protocol snoop transaction activity within the AIU. This bit is clear until a SNPreq message is received on the SFI slave interface and is set until all internal snoop transaction resources have been deallocated and all required protocol messages have been issued and received. In particular, this bit is clear when <em>all</em> of the following are true:</p><ul><li>For each native snoop request issued, a corresponding native snoop response has been received</li><li>All required DTRreq messages have been issued</li><li>For each DTRreq message issued, a corresponding DTRrsp message has been received</li><li>For each DTWreq message issued from the STT, a corresponding DTWrsp message has been received</li><li>All STT resources have been deallocated</li><li>All DMB resources have been deallocated</li><li>All DCF resources have been deallocated</li></ul><p>If <em>any</em> of the above are false, the Snoop Transaction Active bit <em>must</em> be set.<br/> A Bridge AIU configured with an IO cache also implements a Proxy Cache Fill Active bit that is clear when all of the following are true:</p><ul><li>All CTT resources have been deallocated</li></ul><p>If <em>any</em> of the above are false, the Proxy Cache Fill Active bit <em>must</em> be set. In addition, if <em>any</em> of the above are false, the Transaction Active bit and the Coherent Transaction Active bit <em>must</em> also be set.<br/> A Bridge AIU configured with an IO cache also implements a Proxy Cache Evict Active bit that is clear when all of the following are true:</p><ul><li>All UTT resources have been deallocated</li></ul><p>If <em>any</em> of the above are false, the Proxy Cache Evict Active bit <em>must</em> be set. In addition, if <em>any</em> of the above are false, the Transaction Active bit and the Coherent Transaction Active bit <em>must</em> also be set.

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2062" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2062?src=confmacro" class="jira-issue-key">CONC-2062</a>
                            </span>
</p><h3 id="ConcertoSystemArchitectureSpecification-_Ref427619776_Toc447207666DCEControlandStatus"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427619776"><span class="confluence-anchor-link" id="_Ref427619776"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207666"><span class="confluence-anchor-link" id="_Toc447207666"></span></span>DCE Control and Status</h3><p><span style="text-decoration: underline;">Control Bits</span><br/> For each caching agent, the DCE implements a Caching Agent Snoop Enable bit that controls whether a SNPreq message is issued to the AIU associated with the caching agent. If the bit is set, SNPreq messages may be issued to the AIU; if the bit is clear, SNPreq messages <em>must not</em> be issued to the AIU

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2063" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2063?src=confmacro" class="jira-issue-key">CONC-2063</a>
                            </span>
. If the state of the enable bit prevents a SNPreq message from being sent to an agent, the DCE assumes a SNPrsp message in which the protocol snoop response {RV, DN, DC, DT} equals {0, 0, 0, 0} for that agent.<br/> For each agent that can process DVM transactions, DCE0 also implements a DVM Agent Snoop Enable bit that controls whether a DVM-related SNPreq message is issued to the AIU associated with the agent. If the bit is set, DVM-related SNPreq messages may be issued to the AIU; if the bit is clear, DVM-related SNPreq messages <em>must not</em> be issued to the AIU.

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2064" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2064?src=confmacro" class="jira-issue-key">CONC-2064</a>
                            </span>
 If the state of the enable bit prevents a DVM-related SNPreq message from being sent to an agent, DCE0 assumes a SNPrsp message in which the protocol snoop response {RV, DN, DC, DT} equals {0, 0, 0, 0} for that agent.<br/> For each directory segment, the DCE implements a Snoop Filter Enable bit that controls the behavior of the corresponding directory segment. For a null filter, the bit is RAZ/WI (see Section 11.1) and has no effect on the system directory lookup result or the system directory commit result for the directory segment. For a tag filter, if the bit is set, a system directory lookup returns the contents of the directory segment, and a system directory commit updates the contents of the directory segment. If the bit is clear, the directory segment is <em>not</em> accessed on a lookup, and cacheline ownership and cacheline validity are <em>uncertain</em> for all caching agents associated with the segment. Furthermore, if the bit corresponds to an explicit owner-sharer filter, ownership filtering is <em>not</em> performed with respect to that filter, i.e. the lookup result for the filter is isolated from the lookup results of other filters. Finally, for a given protocol transaction, if a directory segment is <em>not</em> accessed on the lookup, the system directory commit for that transaction does <em>not</em> access that segment.<br/> <span style="text-decoration: underline;">Status Bits</span><br/> The DCE implements a Transaction Active bit that indicates transaction activity within the DCE. This bit is clear until a CMDreq message is received on the SFI slave interface and is set until all internal protocol transaction resources have been deallocated and all required protocol message responses have been received and issued. In particular, this bit is clear when <em>all</em> of the following are true:</p><ul><li>For each CMDreq message received, a corresponding CMDrsp message has been issued</li><li>For each UPDreq message received, a corresponding UPDrsp message has been issued</li><li>For each SNPreq message issued, a corresponding SNPrsp message has been received</li><li>For each HNTreq message issued, an corresponding HNTrsp message has been received</li><li>For each MRDreq message issued, an corresponding MRDrsp message has been received</li><li>For each STRreq message issued, an corresponding STRrsp message has been received</li><li>All ATT skid entries have been deallocated</li><li>All ATT resources have been deallocated</li><li>All tag filter victim buffer resources have been deallocated</li><li>All DTF resources have been deallocated (DCE0 only)</li><li>All DSB resources have been deallocated (DCE0 only)

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2065" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2065?src=confmacro" class="jira-issue-key">CONC-2065</a>
                            </span>
</li></ul><p>If <em>any</em> of the above are false, the Transaction Active bit <em>must</em> be set.<br/> <strong><em>Note:</em></strong> The conditions for setting the Transaction Active bit are the same conditions that are used to enable the unit clock in hardware power management. As a result, the Transaction Active bit <em>must</em> be set whenever an active clock is required.<br/> <strong><em>Note:</em></strong> While in a DCE, a protocol transaction is tracked by either the ATT skid entries or the ATT resources. In addition, an ATT resource is not deallocated until after a required system directory commit has been performed.<br/> For each caching agent, the DCE implements a Caching Agent Snoop Active bit that is clear when <em>all</em> of the following are true:</p><ul><li>All required SNPreq messages have been issued to the caching agent</li><li>For each SNPreq message issued to the caching agent, a corresponding SNPrsp message has been received</li></ul><p>If <em>any</em> of the above are false, the Caching Agent Snoop Active bit <em>must</em> be set.

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2075" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2075?src=confmacro" class="jira-issue-key">CONC-2075</a>
                            </span>
<br/> <strong><em>Note:</em></strong> Once the DCE has committed to issue a SNPreq message to a caching agent, the message becomes required and the Caching Agent Snoop Active bit must be set.<br/> For each agent that can process DVM transactions, DCE0 also implements a DVM Agent Snoop Active bit that is clear when <em>all</em> of the following are true:</p><ul><li>All required DVM-related SNPreq messages have been issued to the DVM agent</li><li>For each DVM-related SNPreq message issued to the DVM agent, a corresponding SNPrsp message has been received</li></ul><p>If <em>any</em> of the above are false, the DVM Agent Snoop Active bit <em>must</em> be set.<br/> <strong><em>Note:</em></strong> Once DCE0 has committed to issue a DVM-related SNPreq message to a DVM agent, the message becomes required and the DVM Agent Snoop Active bit must be set.</p><h3 id="ConcertoSystemArchitectureSpecification-_Ref427504939_Toc447207667DMIStatus"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427504939"><span class="confluence-anchor-link" id="_Ref427504939"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207667"><span class="confluence-anchor-link" id="_Toc447207667"></span></span>DMI Status</h3><p><span style="text-decoration: underline;">Status Bits</span><br/> The DMI implements a Transaction Active bit that indicates transaction activity within the DMI. This bit is clear until a protocol message is received on the SFI slave interface and is set until all internal protocol transaction resources have been deallocated and all required protocol message responses have been received and issued. In particular, this bit is clear when <em>all</em> of the following are true:</p><ul><li>For each HNTreq message received, a corresponding HNTrsp message has been issued</li><li>For each MRDreq message received, a corresponding MRDrsp message has been issued</li><li>For each DTWreq message received, a corresponding DTWrsp message has been issued</li><li>All required DTRreq messages have been issued</li><li>For each DTRreq message issued, a corresponding DTRrsp message has been received</li><li>For each memory read request issued, a corresponding memory read response has been received</li><li>For each memory write request issued, a corresponding memory write response has been received</li><li>All HTT resources have been deallocated</li><li>All RTT skid entries have been deallocated</li><li>All RTT resources have been deallocated</li><li>All WTT resources have been deallocated</li></ul><p>If <em>any</em> of the above are false, the Transaction Active bit <em>must</em> be set.

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2026" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2026?src=confmacro" class="jira-issue-key">CONC-2026</a>
                            </span>
<br/> <strong><em>Note:</em></strong> The conditions for setting the Transaction Active bit are the same conditions that are used to enable the unit clock in hardware power management. As a result, the Transaction Active bit <em>must</em> be set whenever an active clock is required.</p><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207668UnitandSubunitActivityStates"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207668"><span class="confluence-anchor-link" id="_Toc447207668"></span></span>Unit and Subunit Activity States</h2><p>In the following sections, the following terms are used interchangeably:</p><ul><li>Proxy cache ⇔ IO cache</li><li>Coherent agent interface unit (CAIU) ⇔ Agent AIU</li><li>Non-coherent bridge unit (NCBU) ⇔ Bridge AIU</li><li>Snoop filter segment ⇔ directory segment</li><li>Directory unit (DIRU) ⇔ DCE</li><li>Coherent memory interface unit (CMIU) ⇔ DMI</li></ul><p>The former terms reflect the terminology presented to users and are synonymous with the latter terms.</p><h3 id="ConcertoSystemArchitectureSpecification-_Ref426058736_Toc447207669IOCache(ProxyCache)ActivityStates"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref426058736"><span class="confluence-anchor-link" id="_Ref426058736"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207669"><span class="confluence-anchor-link" id="_Toc447207669"></span></span>IO Cache (Proxy Cache) Activity States</h3><p>This section describes the transitions between activity states in an IO cache.<br/> <span style="text-decoration: underline;">Transition to Offline</span><br/> The prerequisites for transitioning an IO cache to the <em>offline</em> state follow:</p><ul><li>None</li></ul><p>Once the prerequisites have been satisfied, PMSW performs the following steps to complete the transition to <em>offline</em> state:</p><ol><li>Clear the Proxy Cache Fill Enable bit (<strong>Proxy Cache</strong> <strong>Transaction Control Register</strong>)</li><li>Poll the Proxy Cache Fill Active bit (<strong>Proxy Cache</strong> <strong>Transaction Activity Register</strong>) until clear</li><li>Initiate and complete a Proxy Cache Flush operation (<strong>Proxy Cache Maintenance Control Register</strong> and <strong>Proxy Cache Maintenance Activity Register</strong>).</li><li>Poll the Proxy Cache Eviction Active bit (<strong>Proxy Cache</strong> <strong>Transaction Activity Register</strong>) until clear</li><li>In each directory unit, clear the Caching Agent Snoop Enable bit (<strong>Caching Agent Snoop</strong> <strong>Enable Register</strong>) for the caching agent</li><li>Poll the Caching Agent Snoop Active bit (<strong>Caching Agent Snoop</strong> <strong>Activity Register</strong>) for the caching agent until clear</li><li>Clear the Proxy Cache Lookup Enable bit (<strong>Proxy Cache</strong> <strong>Transaction Control Register</strong>)</li><li>Poll the Snoop Transaction Active bit (<strong>Transaction Activity Register</strong>) in the AIU until clear

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2100" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2100?src=confmacro" class="jira-issue-key">CONC-2100</a>
                            </span>
</li></ol><p>Once an IO cache is <em>offline</em>, the IO cache is no longer accessed. At this point, PMSW may gate the IO cache clock and may lower the IO cache supply voltage, if desired.<br/> <strong><em>Note:</em></strong> At a minimum, the <em>offline</em> state must sufficiently isolate any RAM arrays that implement IO tag and data storage so that the RAM arrays may be clock gated and powered down.<br/> <span style="text-decoration: underline;">Transition to Online</span><br/> The prerequisites for transitioning an IO cache to the <em>online</em> state follow:</p><ul><li>The IO cache clock <em>must</em> be running</li><li>The IO cache supply voltage <em>must</em> be raised to an operational level</li><li>An IO cache reset sequence <em>must</em> be performed if the supply voltage was below the retention level</li></ul><p>Once the prerequisites have been satisfied, PMSW performs the following steps to complete the transition to <em>online</em> state:</p><ol><li>Initiate and complete a Proxy Cache Initialization operation (<strong>Proxy Cache Maintenance Control Register</strong> and <strong>Proxy Cache Maintenance Activity Register</strong>)</li><li>Set the Proxy Cache Lookup Enable bit (<strong>Proxy Cache Transaction Control Register</strong>)</li><li>In each directory unit, set the Caching Agent Snoop Enable bit (<strong>Caching Agent Snoop</strong> <strong>Enable Register</strong>) for the caching agent</li><li>Set the Proxy Cache Fill Enable bit (<strong>Proxy Cache</strong> <strong>Transaction Control Register</strong>)</li></ol><p>Once an IO cache is <em>online</em>, data from protocol transactions may be cached in the IO cache.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207670AIU(CoherentAgentInterfaceUnit/Non-coherentBridgeUnit)ActivityStates"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207670"><span class="confluence-anchor-link" id="_Toc447207670"></span></span>AIU (Coherent Agent Interface Unit/Non-coherent Bridge Unit) Activity States</h3><p>This section describes the transitions between activity states in an AIU.<br/> <span style="text-decoration: underline;">Transition to Offline</span><br/> The prerequisites for transitioning an AIU to the <em>offline</em> state follow:</p><ul><li>All outstanding native agent coherent transactions that can allocate data into the agent's cache <em>must</em> be completed</li><li>The agent's cache <em>must</em> be cleaned and invalidated</li><li>All remaining outstanding native agent coherent transactions <em>must</em> be completed</li><li>Additional native agent coherent transactions <em>must not</em> be performed</li><li>If a Bridge AIU is configured with an IO cache, the IO cache <em>must</em> be offline</li></ul><p>Once the prerequisites have been satisfied, PMSW performs the following steps to complete the transition to <em>offline</em> state:</p><ol><li>In each directory unit, clear the Caching Agent Snoop Enable bit (<strong>Caching Agent Snoop</strong> <strong>Enable Register</strong>) for the caching agent, if appropriate</li><li>Clear the ACE DVM Snoop Enable bit (<strong>ACE DVM Snoop Enable Register</strong>) for the AIU, if appropriate</li><li><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref425978327"><span class="confluence-anchor-link" id="_Ref425978327"></span></span>In each directory unit, poll the Caching Agent Snoop Active bit (<strong>Caching Agent Snoop Activity Register</strong>) for the caching agent until clear, if appropriate</li><li>Poll the ACE DVM Snoop Active bit (<strong>ACE DVM Snoop Activity Register</strong>) for the AIU until clear, if appropriate</li><li>Poll the Snoop Transaction Active bit (<strong>Transaction Activity Register</strong>) in the AIU until clear</li></ol><p>An AIU that is <em>offline</em> may still perform native agent non-coherent transactions and may map native agent coherent transactions into non-coherent transactions (see Transition to Isolated below). Before gating the AIU core logic clock and before lowering the AIU core logic supply voltage, if desired, PMSW must ensure that the associated agent cannot initiate any activity that requires the AIU core logic.<br/> <span style="text-decoration: underline;">Transition to Isolated</span><br/> The prerequisites for transitioning an AIU to the <em>isolated</em> state follow:</p><ul><li>None</li></ul><p>Once the prerequisites have been satisfied, PMSW performs the following steps to complete the transition to <em>isolated</em> state:</p><ol><li>Perform the steps required to transition the AIU to the <em>offline</em> state, ignoring the prerequisites; in other words, stopping coherent transactions from the agent or flushing the agent's caches is <em>not</em> required</li><li>Set the Agent Isolation Enable bit (<strong>Transaction Control Register</strong>) for the AIU</li><li>Poll the Coherent Transaction Active bit (<strong>Transaction Activity Register</strong>) in the AIU <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification#ConcertoSystemArchitectureSpecification-Section9">until clear&nbsp;</a></li></ol><p>Once the AIU is in the <em>isolated</em> state, the agent may begin executing coherent transactions and allocating data into its cache. The AIU will map certain coherent transactions into non-coherent transactions and will terminate other coherent transactions locally, effectively isolating the agent from the coherent subsystem.<br/> Before transitioning to the <em>online</em> state from the <em>isolated</em> state, the AIU must first transition to the <em>offline</em> state, including cleaning and invalidating the agent's caches.<br/> <span style="text-decoration: underline;">Transition to Online</span><br/> The prerequisites for transitioning an AIU to the <em>online</em> state follow:</p><ul><li>The AIU core logic clock <em>must</em> be running</li><li>The AIU core logic supply voltage <em>must</em> be raised to an operational level</li><li>An AIU core logic reset sequence <em>must</em> be performed if the supply voltage was below the retention level</li></ul><p>Once the prerequisites have been satisfied, PMSW performs the following steps to complete the transition to <em>online</em> state:</p><ol><li>In each directory unit, set the Caching Agent Snoop Enable bit (<strong>Caching Agent Snoop Control Register</strong>) for the AIU, if appropriate</li><li>Set the DVM Agent Snoop Enable bit (<strong>ACE DVM</strong> <strong>Snoop Control Register</strong>) for the AIU, if appropriate

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2104" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2104?src=confmacro" class="jira-issue-key">CONC-2104</a>
                            </span>
</li></ol><p>Once an AIU is <em>online</em>, the associated agent may begin to issue native agent coherent transactions.</p><h3 id="ConcertoSystemArchitectureSpecification-_Ref426058881_Toc447207671DirectorySegment(SnoopFilterSegment)ActivityStates"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref426058881"><span class="confluence-anchor-link" id="_Ref426058881"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207671"><span class="confluence-anchor-link" id="_Toc447207671"></span></span>Directory Segment (Snoop Filter Segment) Activity States</h3><p>This section describes the transitions between activity states in a directory segment.<br/> <span style="text-decoration: underline;">Transition to Offline</span><br/> The prerequisites for transitioning a directory segment to the <em>offline</em> state follow:</p><ul><li>None</li></ul><p>Once the prerequisites have been satisfied, PMSW performs the following steps to complete the transition to <em>offline</em> state:</p><ol><li>Clear the Snoop Filter Enable bit (<strong>Snoop Filter</strong> <strong>Enable Register</strong>) for the directory segment

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2110" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2110?src=confmacro" class="jira-issue-key">CONC-2110</a>
                            </span>
</li></ol><p>Once a directory segment is <em>offline</em>, the directory segment is no longer accessed and may lose coherence with respect to the cache state of the caching agents associated with the segment. At this point, PMSW may gate the directory segment clock and may lower the directory segment supply voltage, if desired.<br/> <strong><em>Note:</em></strong> At a minimum, the <em>offline</em> state must sufficiently isolate any RAM arrays that implement tag filter storage so that the RAM arrays may be clock gated and powered down.<br/> <span style="text-decoration: underline;">Transition to Online</span><br/> The prerequisites for transitioning a directory segment to the <em>online</em> state follow:</p><ul><li>The directory segment clock <em>must</em> be running</li><li>The directory segment supply voltage <em>must</em> be raised to an operational level</li><li>A directory segment reset sequence <em>must</em> be performed if the supply voltage was below the retention level</li><li>All outstanding native agent coherent transactions from caching agents associated with the directory segment <em>must</em> be completed</li><li>Additional native agent coherent transactions from caching agents associated with the directory segment <em>must not</em> be performed if the resulting protocol transactions may allocate an entry in the directory segment</li><li>The coherent caches in the caching agents associated with the directory segment <em>must</em> be cleaned and invalidated</li></ul><p>Once the prerequisites have been satisfied, PMSW performs the following steps to complete the transition to <em>online</em> state:</p><ol><li>Initiate and complete a Snoop Filter Initialization operation (<strong>Snoop Filter</strong> <strong>Maintenance Control Register</strong> and <strong>Snoop Filter Maintenance Activity Register</strong>)</li><li>Set the Snoop Filter Enable bit (<strong>Snoop Filter</strong> <strong>Enable Register</strong>) for the directory segment

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2111" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2111?src=confmacro" class="jira-issue-key">CONC-2111</a>
                            </span>
</li></ol><p>Once a directory segment is <em>online</em>, the caching agents associated with the directory segment may resume issuing native agent coherent transactions that allocate entries in the directory segment.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207672DCE(DirectoryUnit)ActivityStates"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207672"><span class="confluence-anchor-link" id="_Toc447207672"></span></span>DCE (Directory Unit) Activity States</h3><p>This section describes the transitions between activity states in a DCE.<br/> <span style="text-decoration: underline;">Transition to Offline</span><br/> The prerequisites for transitioning a DCE to the <em>offline</em> state follow:</p><ul><li>All AIUs <em>must</em> be in the <em>offline</em> state</li><li>All directory segments associated with the DCE <em>must</em> be in the <em>offline</em> state</li></ul><p>Once the prerequisites have been satisfied, PMSW performs the following steps to complete the transition to <em>offline</em> state:</p><ol><li>Poll the Transaction Active bit (<strong>Transaction Activity Register</strong>) in the DCE until clear</li></ol><p>Once a DCE is <em>offline</em>, PMSW may gate the DCE core logic clock and may lower the DCE core logic supply voltage, if desired.<br/> <span style="text-decoration: underline;">Transition to Online</span><br/> The prerequisites for transitioning a DCE to the <em>online</em> state follow:</p><ul><li>The DCE core logic clock <em>must</em> be running</li><li>The DCE core logic supply voltage <em>must</em> be raised to an operational level</li><li>A DCE core logic reset sequence <em>must</em> be performed if the supply voltage was below the retention level</li></ul><p>Once the prerequisites have been satisfied, the DCE is in the <em>online</em> state.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207673DMI(CoherentMemoryInterfaceUnit)ActivityStates"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207673"><span class="confluence-anchor-link" id="_Toc447207673"></span></span>DMI (Coherent Memory Interface Unit) Activity States</h3><p>This section describes the transitions between activity states in a DMI.<br/> <span style="text-decoration: underline;">Transition to Offline</span><br/> The prerequisites for transitioning a DMI to the <em>offline</em> state follow:</p><ul><li>All outstanding native agent coherent transactions that access the DMI <em>must</em> be completed</li><li>Additional native agent coherent transactions that access the DMI <em>must not</em> be performed</li></ul><p>Once the prerequisites have been satisfied, PMSW performs the following steps to complete the transition to <em>offline</em> state:</p><ol><li>Poll the Transaction Active bit (<strong>Transaction Activity Register</strong>) in the DMI until clear

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2112" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2112?src=confmacro" class="jira-issue-key">CONC-2112</a>
                            </span>
</li></ol><p>Once a DMI is <em>offline</em>, PMSW may gate the DMI clock and may lower the DMI supply voltage, if desired.<br/> <span style="text-decoration: underline;">Transition to Online</span><br/> The prerequisites for transitioning a DMI to the <em>online</em> state follow:</p><ul><li>The DMI clock <em>must</em> be running</li><li>The DMI supply voltage <em>must</em> be raised to an operational level</li><li>A DMI reset sequence <em>must</em> be performed if the supply voltage were below the retention level</li></ul><p>Once the prerequisites have been satisfied, the DMI is in the <em>online</em> state.</p><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207674SubsystemActivityStates"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207674"><span class="confluence-anchor-link" id="_Toc447207674"></span></span>Subsystem Activity States</h2><p>Subsystem activity states are determined by the activity states of the units within a particular set of units. If all units in the set are <em>online</em>, the corresponding subsystem activity state is <em>online</em>, and if all units in the set are <em>offline</em>, the corresponding subsystem activity state is <em>offline</em>. Otherwise, the subsystem activity state is <em>partially offline</em> when a subset of the units are <em>offline</em>.<br/> In the following sections, the following terms are used interchangeably:</p><ul><li>Snoop filter ⇔ directory slice</li><li>Coherent subsystem ⇔ coherence domain</li></ul><p>The former terms reflect the terminology presented to users and are synonymous with the latter terms.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207675InterleavedAIU(CoherentAgentInterface/Non-coherentBridge)ActivityStates"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207675"><span class="confluence-anchor-link" id="_Toc447207675"></span></span>Interleaved AIU (Coherent Agent Interface/Non-coherent Bridge) Activity States</h3><p>A set of interleaved AIUs is <em>offline</em> when all related AIUs are <em>offline</em>.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207676DirectorySlice(SnoopFilter)ActivityStates"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207676"><span class="confluence-anchor-link" id="_Toc447207676"></span></span>Directory Slice (Snoop Filter) Activity States</h3><p>A directory slice is <em>offline</em> when all directory segments in the directory slice are <em>offline</em>.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207677InterleavedDMI(CoherentMemoryInterface)ActivityStates"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207677"><span class="confluence-anchor-link" id="_Toc447207677"></span></span>Interleaved DMI (Coherent Memory Interface) Activity States</h3><p>A set of interleaved DMIs is <em>offline</em> when all related DMIs are <em>offline</em>.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207678CoherenceDomain(CoherentSubsystem)ActivityStates"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207678"><span class="confluence-anchor-link" id="_Toc447207678"></span></span>Coherence Domain (Coherent Subsystem) Activity States</h3><p>The coherence domain is <em>offline</em> when all units in the coherence domain are <em>offline</em>.<br/> <strong><em>Note:</em></strong> A coherence domain in the <em>offline</em> state does not imply that non-coherent transactions from agents and AIUs have ceased. If non-coherent transactions are no longer issued by any agent, all Concerto logic may enter a low power state.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207679SingleAgentLow-PowerState"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207679"><span class="confluence-anchor-link" id="_Toc447207679"></span></span>Single Agent Low-Power State</h3><p>The <strong><em>single agent low-power state</em></strong> is entered when a single AIU is in the <em>isolated</em> state and the remaining units in the coherence domain are in the <em>offline</em> state. PMSW transitions the units to the offline or isolated state in the following order:</p><ul><li>All other AIUs are <em>offline</em></li><li>The given AIU is <em>isolated</em></li><li>All DMIs are <em>offline</em></li><li>All DCEs are <em>offline</em></li></ul><p>Once the above units are in the specified states, the coherence domain is effectively offline, but the agent associated with the isolated AIU may still issue coherent and non-coherent transactions.</p><h1 id="ConcertoSystemArchitectureSpecification-_Ref440533168_Toc447207680ErrorArchitecture"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref440533168"><span class="confluence-anchor-link" id="_Ref440533168"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207680"><span class="confluence-anchor-link" id="_Toc447207680"></span></span>Error Architecture</h1><p>This section describes the Concerto error architecture.</p><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207681Background"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207681"><span class="confluence-anchor-link" id="_Toc447207681"></span></span>Background</h2><p>In a Concerto system, an <strong><em>error</em></strong> is a deviation from correct system behavior due to a <strong><em>hardware fault</em></strong>, as opposed to a <strong><em>software fault</em></strong>. An <strong><em>undetectable error</em></strong> is a deviation that hardware is unable to detect, while a <strong><em>detectable error</em></strong> is a deviation that hardware is able to detect. Detectable errors may be further classified as <strong><em>correctable</em></strong>, if the hardware is able to correct the deviation upon its detection, or <strong><em>uncorrectable</em></strong>, if the hardware is unable to correct the deviation. Additionally, a transport interconnect signals a <strong><em>transport error</em></strong> if a protocol message transaction completes in error.<br/> An uncorrectable error may be transmitted in data or state from the logical entity that detected the error to another logical entity. In this case, the uncorrectable error is a <strong><em>propagated error</em></strong>, which is <strong><em>silently propagated</em></strong> if the transmission of the corrupted data or state does not include any error indication. Otherwise, the corrupted data or state is <strong><em>poisoned</em></strong> if the transmission of the data or state includes an error indication.<br/> Errors may be propagated in protocol request messages in the <strong>ErrResult</strong> field in the <strong>SFIPriv</strong> field or by deasserted byte enables and may be propagated in protocol response messages in the SFI response signals. The <strong>ErrResult</strong> field has the following encodings:</p><ul><li><strong>0b00</strong> – No error</li><li><strong>0b01</strong> – Transport error (see Section 8.5)</li><li><strong>0b10</strong> – Address corruption error (See Section 8.4)</li><li><strong>0b11</strong> – Data corruption error (See Section 8.4)</li></ul><p>If a protocol transaction encounters multiple detected or propagated errors, a single error indication is propagated in subsequent protocol messages, based on the following rules: a <em>transport error</em> takes precedence over an <em>address corruption error</em> and a <em>data corruption error</em>, and an <em>address corruption error</em> takes precedence over a <em>data corruption error</em>.

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2113" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2113?src=confmacro" class="jira-issue-key">CONC-2113</a>
                            </span>
<br/> <strong><em>Note:</em></strong> Data corruption errors and address corruption errors are mapped into SLVERR responses in ACE, while transport errors are mapped into DECERR responses in ACE.

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2114" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2114?src=confmacro" class="jira-issue-key">CONC-2114</a>
                            </span>
<br/> The logical entity that detects an error is responsible for <strong><em>logging</em></strong> information about the fault and optionally <strong><em>signaling</em></strong> an error, e.g. raising a hardware interrupt or taking a software exception. If the error is correctable, the logical entity corrects the error; if not, the logical entity poisons the data or state and propagates the poisoned data or state if required for the continued operation of the system, e.g. the return of read data. If the poisoned data or state is propagated to another logical entity and that logical entity either consumes the data or updates its state without retaining the error indication, the logical entity that received the propagated error is also responsible for logging and optionally signaling the error.<br/> <strong><em>Note:</em></strong> The error architecture is based on some additional guiding principles that are not strictly requirements:</p><ul><li>No logical entity should corrupt additional data unnecessarily.</li><li>Propagating poisoned data stored in a structure is indistinguishable from propagating a detectable error from that structure.</li></ul><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207682Features"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207682"><span class="confluence-anchor-link" id="_Toc447207682"></span></span>Features</h2><p>Concerto implements a number of features to detect errors in the system. These include</p><ul><li>Configurable error detection and error correction on the following address and data storage arrays:</li><li>OTT data buffers in an AIU</li><li>IO cache tag and data entries in an Bridge AIU, if configured with an IO cache</li><li>Tag filter storage in a DCE</li><li>HTT data buffers in a DMI</li><li>RTT data buffers in a DMI, if configured with RTT-Data resources</li><li>Address error detection logic for coherent accesses to <em>reserved</em> memory locations in the cache coherence window and to memory locations outside the cache coherence window</li><li>Transport error support (see Section 8.5)</li></ul><p><strong><em>Note:</em></strong> Though the SFI interface supports the transmission of protection bits in transport requests and responses, protocol messages are not protected.<br/> These features allow detectable errors to be classified into correctable errors and uncorrectable errors. Typically, correctable errors may add latency, since data cannot be provided until an error is detected and can be corrected; however, uncorrectable errors do not add latency as long as the error can be detected and the transaction flagged with the error in the same cycle.<br/> The following sections describe correctable errors, uncorrectable errors, transport errors, and propagated errors.</p><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207683CorrectableErrors"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207683"><span class="confluence-anchor-link" id="_Toc447207683"></span></span>Correctable Errors</h2><p>Correctable errors are those errors that a Concerto unit detects and corrects. No error indication is propagated, and once the number of correctable errors reaches a programmable threshold, an interrupt is raised and the error log registers contain information about the correctable error that caused the interrupt. Each Concerto unit implements a local set of control and status registers for correctable error

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2115" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2115?src=confmacro" class="jira-issue-key">CONC-2115</a>
                            </span>
s.<br/> The following sections describe the different types of correctable errors in each unit.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207684AIUCorrectableErrors"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207684"><span class="confluence-anchor-link" id="_Toc447207684"></span></span>AIU Correctable Errors</h3><p>An AIU correctable error is detected when any of the following occur:</p><ul><li>The OTT-Data resources are configured with single-bit error correction, e.g. SECDED ECC, and a single-bit corruption is detected</li><li>An IO cache data array is configured with single-bit error correction, e.g. SECDED ECC, and a single-bit corruption is detected</li><li>An IO cache tag array is configured with single-bit error correction, e.g. SECDED ECC, and a single-bit corruption is detected</li></ul><p>The following subsections describe in more detail how the above errors are handled.<br/> <span style="text-decoration: underline;">OTT-Data Error</span><br/> A correctable OTT-Data error occurs when the AIU reads the OTT-Data resources for either an agent read response or a DTWreq message and detects a fault that is correctable in one of the data words. Upon detecting the fault, the AIU delays the data beat containing the corrupted data word to correct the data word. Additionally, the AIU increments the count of correctable errors, and if the count equals the programmed correctable error threshold, the relevant information about the error is logged, and if enabled, the correctable error interrupt signal is asserted.<br/> <strong><em>Note:</em></strong> The above also applies to IO cache flush maintenance operations, which behave like IO cache evictions.<br/> <span style="text-decoration: underline;">IO Cache Data Error</span><br/> A correctable IO cache data error occurs when the AIU performs an IO cache data array access and detects a fault that is correctable in one of the data words. In the cycle the fault is detected, the AIU stalls the transaction pipeline to correct the corrupted data entry. On the clock edge following the data entry correction, the data entry is written into the data array and is bypassed to the stalled transaction that accessed the corrupted data, and the transaction pipeline resumes processing. Additionally, the AIU increments the count of correctable errors, and if the count equals the programmed correctable error threshold, the relevant information about the error is logged, and if enabled, the correctable error interrupt signal is asserted.<br/> <strong><em>Note:</em></strong> The cycle in which the error is detected and the clock edge on which the corrected entry is available need not be the same cycle.<br/> When the transaction pipeline is stalled, subsequent transactions are also stalled. The result of the data array access for a subsequent transaction may be buffered in the pipeline, or the data array access for a subsequent transaction may be performed again once the corrected data entry has been written into the data array. <br/> <strong><em>Note:</em></strong> The above also applies to IO cache flush maintenance operations, which behave like IO cache evictions.<br/> <span style="text-decoration: underline;">IO Cache Tag Error</span><br/> A correctable IO cache tag error occurs when the AIU performs an IO cache tag array access and detects a fault that is correctable in one of the tag entries in the accessed set. In the cycle the fault is detected, the AIU stalls the transaction pipeline to correct the corrupted tag entry. On the clock edge following the tag entry correction, the tag entry is written into the tag array and is bypassed to the stalled transaction that accessed the corrupted tag, and the transaction pipeline resumes processing. Additionally, the AIU increments the count of correctable errors, and if the count equals the programmed correctable error threshold, the relevant information about the error is logged, and if enabled, the correctable error interrupt signal is asserted.<br/> <strong><em>Note:</em></strong> The cycle in which the error is detected and the clock edge on which the corrected entry is available need not be the same cycle.<br/> When the transaction pipeline is stalled, subsequent transactions are also stalled. The result of the tag array access for a subsequent transaction may be buffered in the pipeline, or the tag array access for a subsequent transaction may be performed again once the corrected tag entry has been written into the tag array.<br/> <strong><em>Note:</em></strong> The above also applies to IO cache flush maintenance operations, which behave like IO cache evictions.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207685DCECorrectableErrors"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207685"><span class="confluence-anchor-link" id="_Toc447207685"></span></span>DCE Correctable Errors</h3><p>A DCE correctable error is detected when any of the following occur:</p><ul><li>A tag filter is configured with single-bit error correction, e.g. SECDED ECC, and a single-bit corruption is detected</li></ul><p>The following subsections describe in more detail how the above errors are handled.<br/> <span style="text-decoration: underline;">Tag Filter Entry Error</span><br/> A correctable tag filter entry error occurs when the DCE performs a system directory lookup and detects a fault that is correctable in one of the tag filter entries in the accessed set. In the cycle the fault is detected, the DCE stalls the transaction pipeline to correct the corrupted tag filter entry. On a clock edge following the tag filter entry correction, the entry is written into the system directory and is bypassed to the stalled transaction that accessed the corrupted entry, and the transaction pipeline resumes processing. Additionally, the DCE increments the count of correctable errors, and if the count equals the programmed correctable error threshold, the relevant information about the error is logged, and if enabled, the correctable error interrupt signal is asserted.

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2116" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2116?src=confmacro" class="jira-issue-key">CONC-2116</a>
                            </span>
<br/> <strong><em>Note:</em></strong> The cycle in which the error is detected and the clock edge on which the corrected entry is available need not be the same cycle.<br/> When the transaction pipeline is stalled, subsequent transactions are also stalled. The result of the system directory lookup for a subsequent transaction may be buffered in the pipeline, or the system directory lookup for a subsequent transaction may be performed again once the corrected directory entry has been written into the system directory.<br/> <strong><em>Note:</em></strong> The above also applies to directory segment recall maintenance operations, which behave like directory recall transactions.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207686DMICorrectableErrors"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207686"><span class="confluence-anchor-link" id="_Toc447207686"></span></span>DMI Correctable Errors</h3><p>A DMI correctable error is detected when any of the following occur:</p><ul><li>The HTT-Data resources are configured with single-bit error correction, e.g. SECDED ECC, and a single-bit corruption is detected</li><li>The RTT-Data resources are configured with single-bit error correction, e.g. SECDED ECC, and a single-bit corruption is detected

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2117" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2117?src=confmacro" class="jira-issue-key">CONC-2117</a>
                            </span>
</li></ul><p>The following subsections describe in more detail how the above errors are handled.<br/> <span style="text-decoration: underline;">HTT-Data</span><br/> A correctable HTT-Data error occurs when the DMI reads the HTT-Data resources for a DTRreq message and detects a fault that is correctable in one of the data words. Upon detecting the fault, the DMI delays the data beat containing the corrupted data word to correct the data word. Additionally, the DMI increments the count of correctable errors, and if the count equals the programmed correctable error threshold, the relevant information about the error is logged, and if enabled, the correctable error interrupt signal is asserted.<br/> <span style="text-decoration: underline;">RTT-Data</span><br/> A correctable RTT-Data error occurs when the DMI reads the RTT-Data resources for a DTRreq message and detects a fault that is correctable in one of the data words. A correctable RTT-Data error is handled in the same manner as a correctable HTT-Data error.</p><h2 id="ConcertoSystemArchitectureSpecification-_Ref431460535_Toc447207687UncorrectableErrors"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref431460535"><span class="confluence-anchor-link" id="_Ref431460535"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207687"><span class="confluence-anchor-link" id="_Toc447207687"></span></span>Uncorrectable Errors</h2><p>Uncorrectable errors are those errors that a Concerto unit detects and cannot or does not correct. An error indication is propagated, an interrupt is raised, and the error log registers contain information about the uncorrectable error that caused the interrupt. Each Concerto unit implements a local set of control and status registers for uncorrectable errors.<br/> Uncorrectable errors are further classified as data corruption errors or address corruption errors. A <strong><em>data corruption error</em></strong> indicates that data in the protocol transaction is corrupted, and the error is propagated as one of the following:</p><ul><li>For SNPrsp messages and DTWrsp messages, the error is propagated by asserting the <strong>Status</strong> signal and signaling the <strong>DErr</strong> error type in the <strong>ErrCode</strong> field on the SFI master response interface</li><li>For STRreq messages, the error is propagated by signaling <strong>0b11</strong> in the <strong>ErrResult</strong> field of the <strong>SFIPriv</strong> field on the SFI slave request interface</li><li>For DTRreq messages, the error is propagated by deasserting the byte enable for each corrupted byte in the data transfer</li><li>For DTWreq messages, the error is propagated by deasserting the byte enable for each corrupted byte in the data transfer

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2118" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2118?src=confmacro" class="jira-issue-key">CONC-2118</a>
                            </span>
</li></ul><p><strong><em>Note:</em></strong> In Concerto V1, errors in data are propagated as deasserted byte enables in the data transfer messages. When a byte enable is deasserted, FlexNoC forces the corresponding byte to zero.<br/> A <em>data corruption error</em> propagated in a response message or a control message is classified as a <strong><em>control-propagated</em></strong> error, implying all data bytes in any data transfers have been corrupted. On the other hand, a <em>data corruption error</em> propagated in a data transfer message is classified as a <strong><em>data-propagated</em></strong> error, indicating that only specified data bytes have been corrupted.<br/> An <strong><em>address corruption error</em></strong> indicates that an error occurred during an address comparison during the protocol transaction, and this error is propagated as one of the following:</p><ul><li>For SNPrsp messages, the error is propagated by asserting the <strong>Status</strong> signal and signaling the <strong>Slv</strong> error type in the <strong>ErrCode</strong> field on the SFI master response interface</li><li>For STRreq messages, the error is propagated by signaling <strong>0b10</strong> in the <strong>ErrResult</strong> field of the <strong>SFIPriv</strong> field on the SFI slave request interface

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2119" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2119?src=confmacro" class="jira-issue-key">CONC-2119</a>
                            </span>
</li></ul><p>An <em>address corruption error</em> is classified as a <em>control-propagated</em> error, implying that all data bytes in any data transfers have been corrupted.<br/> The following sections describe the different types of uncorrectable errors in each unit.</p><h3 id="ConcertoSystemArchitectureSpecification-_Ref440532876_Toc447207688AIUUncorrectableErrors"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref440532876"><span class="confluence-anchor-link" id="_Ref440532876"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207688"><span class="confluence-anchor-link" id="_Toc447207688"></span></span>AIU Uncorrectable Errors</h3><p>An AIU uncorrectable error is detected when any of the following occur:</p><ul><li>The OTT-Data resources are configured either with single-bit error detection, e.g. parity, and a single-bit corruption is detected or with multi-bit error detection, e.g. SECDED ECC, and a multi-bit corruption is detected</li><li>The IO cache data array is configured either with single-bit error detection, e.g. parity, and a single-bit corruption is detected or with multi-bit error detection, e.g. SECDED ECC, and a multi-bit corruption is detected</li><li>The IO cache tag array is configured either with single-bit error detection, e.g. parity, and a single-bit corruption is detected or with multi-bit error detection, e.g. SECDED ECC, and a multi-bit corruption is detected</li><li>An IO cache fill encounters an error during a protocol coherent transaction</li><li>An IO cache eviction encounters an error during a protocol update transaction

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2120" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2120?src=confmacro" class="jira-issue-key">CONC-2120</a>
                            </span>
</li></ul><p>The following subsections describe in more detail how the above errors are handled.<br/> <span style="text-decoration: underline;">OTT-Data Error</span><br/> An uncorrectable OTT-Data error occurs when the AIU reads the OTT-Data resources for either an agent read response or a DTWreq message and detects a fault that is uncorrectable in one of the data words. Upon detecting the fault, the AIU logs the relevant information about the error and asserts the uncorrectable error interrupt signal, if enabled.<br/> For a native agent read response, the AIU marks each data beat in the native agent read response with a <em>data corruption error</em> if that data beat contains a corrupted byte. For a native agent write request, the AIU indicates a <em>data corruption error</em> in the native agent write response. For a DTWreq message, the AIU deasserts the byte enable for each corrupted byte in the data transfer.<br/> <strong><em>Note:</em></strong> The above also applies to IO cache flush maintenance operations, which behave like IO cache evictions.<br/> <span style="text-decoration: underline;">IO Cache Data Error</span><br/> An uncorrectable IO cache data error occurs when the AIU performs an IO cache data array access and detects a fault that is uncorrectable in one of the data words. Upon detecting the fault, the AIU logs the relevant information about the error and asserts the uncorrectable error interrupt signal, if enabled.<br/> For a native agent read request, the AIU marks each data beat in the native agent read response with a <em>data corruption error</em> if that data beat contains a corrupted byte. For a native agent write request, the AIU indicates a <em>data corruption error</em> in the native agent write response. For a DTWreq message due to an IO cache eviction, the AIU deasserts the byte enable for each corrupted byte in the data transfer. Finally, for a protocol snoop message, the AIU completes the snoop message and marks each data beat in the DTRreq message with a <em>data corruption error</em> if that data beat contains a corrupted byte. The AIU does <em>not</em> indicate a <em>data corruption error</em> in the SNPrsp message.<br/> In addition, if the IO cache retains the data entry, the AIU poisons each data quantum (typically, the size of the protected data word) that contains a corrupted byte. A poisoned IO cache data quantum may propagate a <em>data corruption error</em> in response to a later IO cache access, and no error logging or signaling is performed when the <em>data corruption error</em> is propagated with a poisoned data quantum (see Section 8.6.1).<br/> <strong><em>Note:</em></strong> The above also applies to IO cache flush maintenance operations, which behave like IO cache evictions.<br/> <span style="text-decoration: underline;">IO Cache Tag Error</span><br/> An uncorrectable IO cache tag error occurs when the AIU performs an IO cache tag array access and detects a fault that is uncorrectable in one of the tag entries in the accessed set. Upon detecting the fault, the AIU logs the relevant information about the error and asserts the uncorrectable error interrupt signal, if enabled.<br/> For an IO cache lookup due to a native agent transaction, the AIU completes the transaction and marks each data beat in the native agent read response with an <em>address corruption error</em> or indicates an <em>address corruption error</em> in the native agent write response. No IO cache updates are performed and no protocol transactions are initiated. For an IO cache lookup due to a snoop request, the AIU signals an <em>address corruption error</em> in the SNPrsp message, in which the protocol snoop response {<strong>RV</strong>, <strong>DN</strong>, <strong>DC</strong>, <strong>DT</strong>} equals {0, 0, 0, 0}.<br/> <strong><em>Note:</em></strong> The above also applies to IO cache flush maintenance operations, which behave like IO cache evictions.<br/> <span style="text-decoration: underline;">IO Cache Fill Error</span><br/> An uncorrectable IO cache fill error occurs when an IO cache access allocates an IO cache entry for an IO cache fill and the resulting protocol coherent transaction receives a <em>data corruption error</em> (see Section 8.6.1), an <em>address corruption error</em> (see Section 8.6.1), or a <em>transport error</em> (see Section 8.6.1 and Section 8.5.2). Upon receiving the error, the AIU logs the relevant information about the error and asserts the uncorrectable error interrupt signal, if enabled.<br/> For a <em>data-propagated</em> <em>data corruption error</em>, the AIU completes the protocol transaction and signals a <em>data corruption error</em> in the native agent read or write response, as described in Section 8.6.1. In addition, the IO cache fill is completed, and the AIU poisons each data quantum (typically, the size of the protected data word) that contains a corrupted byte. A poisoned IO cache data quantum may propagate a <em>data corruption error</em> in response to a later IO cache access, and no error logging or signaling is performed when the <em>data corruption error</em> is propagated with a poisoned data quantum (see Section 8.6.1).<br/> For a <em>control-propagated data corruption error</em>, the AIU completes the protocol transaction and signals a <em>data corruption error</em> in the native agent read or write response, as described in Section 8.6.1. In addition, the IO cache fill is suppressed, and the allocated IO cache entry is invalidated.<br/> Likewise, for an <em>address corruption error</em>, the AIU completes the protocol transaction and signals an <em>address corruption error</em> in the native agent read or write response, as described in Section 8.6.1. In addition, the IO cache fill is suppressed, and the allocated IO cache entry is invalidated.<br/> Finally, for a <em>transport error</em>, the AIU completes the protocol transaction and signals a <em>transport error</em> in the native agent read or write response, as described in Section 8.6.1, if the error was signaled in a STRreq message, or in Section 8.5.2, if the error was signaled in a protocol response message. In addition, the IO cache fill is suppressed, and the allocated IO cache entry is invalidated.<br/> <strong><em>Note:</em></strong> The IO cache fill is suppressed for all control-propagated errors.<br/> <span style="text-decoration: underline;">IO Cache Eviction Error</span><br/> An uncorrectable IO cache eviction error occurs when an IO cache access causes an IO cache eviction and the resulting protocol update transaction receives a <em>data corruption error</em> (see Section 8.6.1) or a <em>transport error</em> (see Section 8.5.2). Upon receiving the error, the AIU logs the relevant information about the error and asserts the uncorrectable error interrupt signal, if enabled.<br/> For a <em>data corruption error</em>, the AIU completes the update transaction as described in Section 8.6.1.<br/> For a <em>transport error</em>, the AIU completes the update transaction as described in Section 8.5.2.<br/> <strong><em>Note:</em></strong> An <em>address corruption error</em> cannot occur on an IO cache eviction since such an error is <em>not</em> signaled in either a DTWrsp message or an UPDrsp message.<br/> <span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref426648722"><span class="confluence-anchor-link" id="_Ref426648722"></span></span><strong><em>Note:</em></strong> The above also applies to IO cache flush maintenance operations, which behave like IO cache evictions.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207689DCEUncorrectableErrors"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207689"><span class="confluence-anchor-link" id="_Toc447207689"></span></span>DCE Uncorrectable Errors</h3><p>A DCE uncorrectable error is detected when any of the following occur:</p><ul><li>A tag filter is configured either with single-bit error detection, e.g. parity, and a single-bit corruption is detected or with multi-bit error detection, e.g. SECDED ECC, and a multi-bit corruption is detected</li><li>A recall transaction receives an error in a SNP message transaction

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2122" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2122?src=confmacro" class="jira-issue-key">CONC-2122</a>
                            </span>
</li></ul><p>The following subsections describe in more detail how the above errors are handled.<br/> <span style="text-decoration: underline;">Tag Filter Entry Error</span><br/> An uncorrectable tag filter entry error occurs when the DCE performs a system directory lookup and detects a fault that is uncorrectable in one of the tag filter entries in the accessed set. In the cycle the fault is detected, the DCE stalls the transaction pipeline and clears the Snoop Filter Enable for the directory segment in which the fault was detected. On a subsequent clock edge, the directory lookup result for the disabled directory segment is forced to equal the lookup result as described in Section 7.2.2, and the result is bypassed to the stalled transaction that accessed the corrupted entry. The transaction pipeline then resumes processing. Additionally, the DCE logs the relevant information about the error and asserts the uncorrectable error interrupt signal, if enabled.<br/> <strong><em>Note:</em></strong> The cycle in which the error is detected and the clock edge on which the corrected entry is available need not be the same cycle.<br/> When the transaction pipeline is stalled, subsequent transactions are also stalled. The result of the system directory lookup for a subsequent transaction may be buffered in the pipeline, or the system directory lookup for a subsequent transaction may be performed again once the corrected directory entry has been written into the system directory. <br/> <strong><em>Note:</em></strong> The above also applies to directory segment recall maintenance operations, which behave like directory recall transactions.<br/> <span style="text-decoration: underline;">Recall Error</span><br/> An uncorrectable recall error occurs when the DCE performs a recall transaction and one of the resulting snoop messages receives a <em>data corruption error</em> (see Section 8.6.2), an <em>address corruption error</em> (see Section 8.6.2), or a <em>transport error</em> (see Section 8.5.3). Upon receiving the error, the DCE logs the relevant information about the error and asserts the uncorrectable error interrupt signal, if enabled.<br/> For all three errors, the DCE completes the recall transaction as if no error had occurred.<br/> <strong><em>Note:</em></strong> The above also applies to directory segment recall maintenance operations, which behave like directory recall transactions.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207690DMIUncorrectableErrors"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207690"><span class="confluence-anchor-link" id="_Toc447207690"></span></span>DMI Uncorrectable Errors</h3><p>A DMI uncorrectable error is detected when any of the following occur:</p><ul><li>The HTT-Data resources are configured either with single-bit error detection, e.g. parity, and a single-bit corruption is detected or with multi-bit error detection, e.g. SECDED ECC, and a multi-bit corruption is detected</li><li>The RTT-Data resources are configured either with single-bit error detection, e.g. parity, and a single-bit corruption is detected or with multi-bit error detection, e.g. SECDED ECC, and a multi-bit corruption is detected

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2123" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2123?src=confmacro" class="jira-issue-key">CONC-2123</a>
                            </span>
</li></ul><p>The following subsections describe in more detail how the above errors are handled.<br/> <span style="text-decoration: underline;">HTT-Data Error</span><br/> An uncorrectable HTT-Data error occurs when the DMI reads the HTT-Data resources for a DTRreq message and detects a fault that is uncorrectable in one of the data bytes. Upon detecting the fault, the DMI logs the relevant information about the error and asserts the uncorrectable error interrupt signal, if enabled.<br/> When issuing the DTRreq message, the DMI deasserts the byte enable for each corrupted byte in the data transfer.<br/> <span style="text-decoration: underline;">RTT-Data Error</span><br/> An uncorrectable RTT-Data error occurs when the DMI reads the RTT-Data resources for a DTRreq message and detects a fault that is uncorrectable in one of the data bytes. An uncorrectable RTT-Data error is handled in the same manner as an uncorrectable HTT-Data error (see above).</p><h2 id="ConcertoSystemArchitectureSpecification-_Ref426367041_Toc447207691TransportErrors"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref426367041"><span class="confluence-anchor-link" id="_Ref426367041"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207691"><span class="confluence-anchor-link" id="_Toc447207691"></span></span>Transport Errors</h2><p>A <em>transport error</em> indicates that a transport interconnect has encountered an error condition, and this error is propagated as one of the following:</p><ul><li>For all protocol response messages, the error is propagated by asserting the <strong>Status</strong> signal and signaling the error type in the <strong>ErrCode</strong> field on the SFI master response interface</li><li>For STRreq messages, the error is propagated by signaling <strong>0x01</strong> in the <strong>ErrResult</strong> field of the <strong>SFIPriv</strong> field on the SFI slave request interface</li></ul><p>A <em>transport error</em> is classified as a <em>control-propagated</em> error, implying that all data bytes in any data transfers have been corrupted. Logging and signaling for transport errors is performed by the transport interconnect.<br/> The following are errors detected in the FlexNoC transport interconnect and signaled on the SFI interface. The following subsections detail the transport interconnect configuration requirements and restrictions and describe the Concerto behavior.</p><h3 id="ConcertoSystemArchitectureSpecification-_Ref427014310_Toc447207692TransportRequirements"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427014310"><span class="confluence-anchor-link" id="_Ref427014310"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207692"><span class="confluence-anchor-link" id="_Toc447207692"></span></span>Transport Requirements</h3><p>This section describes the transport interconnect requirements for error configuration, logging, and signaling.<br/> <span style="text-decoration: underline;">Slave Error</span><br/> A slave error is signaled by a snooping AIU to propagate an <em>address corruption error</em> in a SNPrsp message. Slave errors in any other message class are UNDEFINED.<br/> <span style="text-decoration: underline;">Decode Error</span><br/> The decode error is UNDEFINED for all message classes, and all SFI NIUs must be configured to transmit all addresses.<br/> <span style="text-decoration: underline;">Access Violation Error</span><br/> The access violation error is UNDEFINED for all message classes, and all SFI NIUs must be configured to support all Concerto messages.<br/> <span style="text-decoration: underline;">Disconnected Power Domain Error</span><br/> A disconnected power domain error occurs when a unit issues a protocol request message that targets a unit whose clocks have been gated or whose power has been removed. Disconnected power domain errors apply to all message classes.<br/> To support this functionality, all power domain disconnects must be configured or programmed to generate an error response when the target side has been disconnected.<br/> Any error logging or signaling <em>must</em> be implemented in the transport logic that performs the power domain disconnection.<br/> <span style="text-decoration: underline;">Security Error</span><br/> A security error occurs when an AIU issues a CMDreq message, a DTWreq message, or an UPDreq message to a memory location behind a firewall in the transport interconnect. Security errors in any other message class are UNDEFINED.<br/> To support this functionality, firewalls may be instantiated either with each AIU initiator or with each DCE and DMI target. Additionally, each firewall must be configured or programmed to check only messages initiated by an AIU and targeting a DCE or a DMI.<br/> A security error is propagated in the native agent response, and a Concerto system <em>does not</em> require any error logging or signaling to be implemented in the transport logic that performs the security function.<br/> <span style="text-decoration: underline;">Data Error</span><br/> A data error is signaled by a snooping AIU to propagate a <em>data corruption</em> error in a SNPrsp message or a DTWrsp message. Data errors in any other message class are UNDEFINED.<br/> <span style="text-decoration: underline;">Timeout Error</span><br/> A timeout error occurs when a target NIU does not receive a protocol response message within a configurable or programmable amount of time after issuing a protocol request message to a unit. Timeout errors apply to all message classes.<br/> To support this functionality, target NIUs may be configured to instantiate the transport interconnect timeout logic.<br/> Any error logging or signaling <em>must</em> be implemented in the transport logic that performs the timeout detection.</p><h3 id="ConcertoSystemArchitectureSpecification-_Ref426997191_Toc447207693AIUTransportErrors"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref426997191"><span class="confluence-anchor-link" id="_Ref426997191"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207693"><span class="confluence-anchor-link" id="_Toc447207693"></span></span>AIU Transport Errors</h3><p>An AIU transport error is detected when any of the following occur:</p><ul><li>A fully-coherent agent or IO-coherent agent attempts to perform a coherent access to an address outside of all the cache coherence capable memory regions</li><li>A CMDreq message, a DTWreq message, or an UPDreq message from the requesting AIU is completed with a security error from the transport interconnect</li><li>A CMDreq message, a DTWreq message, or an UPDreq message from the requesting AIU is completed with a disconnected power domain error from the transport interconnect; a DTRreq message from a snooping AIU is completed with a disconnected power domain error</li><li>A CMDreq message, a DTWreq message, or an UPDreq message from the requesting AIU is completed with a timeout error from the transport interconnect; a DTRreq message from a snooping AIU is completed with a timeout error

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2124" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2124?src=confmacro" class="jira-issue-key">CONC-2124</a>
                            </span>
</li></ul><p>The following subsections describe in more detail how the above errors are handled.<br/> <span style="text-decoration: underline;">Coherent Address Error</span><br/> A coherent address error occurs when an agent issues a coherent transaction to an address that is <em>not</em> in one of the cache coherence memory regions. Upon detecting the error, the AIU terminates the protocol transaction immediately and marks each data beat in the native agent read response with a <em>transport error</em> or indicates a <em>transport error</em> in the native agent write response.<br/> <strong><em>Note:</em></strong> If this error is detected, the AIU does <em>not</em> issue any protocol messages or perform an IO cache lookup.<br/> <span style="text-decoration: underline;">Transport Security Error</span><br/> A transport security error occurs when a CMDrsp message, DTWrsp message, or UPDrsp message returns with a security error from the transport interconnect (see Section 8.5.1). Upon detecting the error, the AIU terminates the protocol transaction and marks each data beat in the native agent read response with a <em>transport error</em> or indicates a <em>transport error</em> in the native agent write response.<br/> <span style="text-decoration: underline;">Transport Power Management Error</span><br/> A transport power management error occurs when a CMDrsp message, a DTRrsp message, a DTWrsp message, or an UPDrsp message returns with a disconnected power domain error from the transport interconnect (see Section 8.5.1). Upon receiving a CMDrsp message, a DTWrsp message, or an UPDrsp message with this error, the AIU terminates the protocol transaction and marks each data beat in the native agent read response with a <em>transport error</em> or indicates a <em>transport error</em> in the native agent write response. Upon receiving a DTRrsp message with this error, the AIU completes the protocol message transaction and takes no further action.<br/> <strong><em>Note:</em></strong> In the case of a DTRrsp message, this error is <em>not</em> propagated to the requesting agent.<br/> <strong><em>Note:</em></strong> The above behavior assumes that these errors are programming errors, so the behavior is effectively fatal to the system.<br/> <span style="text-decoration: underline;">Transport Timeout Error</span><br/> A transport timeout error occurs when a CMDrsp message, a DTRrsp message, a DTWrsp message, or an UPDrsp message returns with a timeout error from the transport interconnect (see Section 8.5.1). A transport timeout error is handled in the same manner as a transport power management error (see above).<br/> <strong><em>Note:</em></strong> In the case of a DTRrsp message, this error is <em>not</em> propagated to the requesting agent.<br/> <strong><em>Note:</em></strong> The above behavior assumes that these errors are programming errors, so the behavior is effectively fatal to the system.</p><h3 id="ConcertoSystemArchitectureSpecification-_Ref426997129_Toc447207694DCETransportErrors"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref426997129"><span class="confluence-anchor-link" id="_Ref426997129"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207694"><span class="confluence-anchor-link" id="_Toc447207694"></span></span>DCE Transport Errors</h3><p>A DCE transport error is detected when any of the following occur:</p><ul><li>A SNPreq message, an HNTreq message, an MRDreq message, or a STRreq message is completed with a disconnected power domain error from the transport interconnect</li><li>A SNPreq message, an HNTreq message, an MRDreq message, or a STRreq message is completed with a timeout error from the transport interconnect

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2125" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2125?src=confmacro" class="jira-issue-key">CONC-2125</a>
                            </span>
</li></ul><p>The following subsections describe in more detail how the above errors are handled.<br/> <span style="text-decoration: underline;">Transport Power Management Error</span><br/> A transport power management error occurs when a SNPrsp message, an HNTrsp message, an MRDrsp message, or a STRrsp message returns with a disconnected power domain error from the transport interconnect (see Section 8.5.1). Upon receiving a SNPrsp message with this error, the DCE interprets the corresponding snoop result {<strong>RV</strong>, <strong>DN</strong>, <strong>DC</strong>, <strong>DT</strong>} as {0, 0, 0, 0} and logs a <em>transport error</em> in the corresponding ATT-Ctrl resource. Likewise, upon receiving an HNTrsp message with this error, the DCE logs a <em>transport error</em> in the corresponding ATT-Ctrl resource. In the case of a protocol transaction, once the required SNPrsp messages and HNTrsp messages have been received, the DCE terminates the protocol transaction and signals a <em>transport error</em> to the requesting AIU in the STRreq message. Once the STRrsp message has been received, the DCE completes the protocol transaction, including performing the directory commit, or the recall transaction.<br/> Upon receiving an MRDrsp message with this error, the DCE terminates the protocol transaction and signals a <em>transport error</em> to the requesting AIU in the STRreq message. Once the STRrsp message has been received, the DCE completes the protocol transaction, including performing the directory commit.<br/> Upon receiving a STRrsp message with this error, the DCE interprets the corresponding transaction result <strong>TR</strong> as 00 and completes the protocol transaction, including performing the directory commit.<br/> <strong><em>Note:</em></strong> In the case of a STRrsp message, this error is <em>not</em> propagated to the requesting agent.<br/> <strong><em>Note:</em></strong> The above behavior assumes that these errors are programming errors, so the behavior is effectively fatal to the system.<br/> <span style="text-decoration: underline;">Transport Timeout Error</span><br/> A transport timeout error occurs when a SNPrsp message, an HNTrsp message, an MRDrsp message, or a STRrsp message returns with a timeout error from the transport interconnect (see Section 8.5.1). A transport timeout error is handled in the same manner as a transport power management error (see above).<br/> <strong><em>Note:</em></strong> In the case of a STRrsp message, this error is <em>not</em> propagated to the requesting agent.<br/> <strong><em>Note:</em></strong> The above behavior assumes that these errors are programming errors, so the behavior is effectively fatal to the system.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207695DMITransportErrors"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207695"><span class="confluence-anchor-link" id="_Toc447207695"></span></span>DMI Transport Errors</h3><p>A DMI transport error is detected when any of the following occur:</p><ul><li>A DTRreq message is completed with a disconnected power domain error from the transport interconnect</li><li>A DTRreq message is completed with a timeout error from the transport interconnect

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2126" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2126?src=confmacro" class="jira-issue-key">CONC-2126</a>
                            </span>
</li></ul><p>The following subsections describe in more detail how the above errors are handled.<br/> <span style="text-decoration: underline;">Transport Power Management Error</span><br/> A transport power management error occurs when a DTRrsp message returns with a disconnected power domain error from the transport interconnect (see Section 8.5.1). Upon receiving a DTRrsp message with this error, the DMI completes the protocol message transaction and takes no further action.<br/> <strong><em>Note:</em></strong> This error is <em>not</em> propagated to the requesting agent.<br/> <strong><em>Note:</em></strong> The above behavior assumes that these errors are programming errors, so the behavior is effectively fatal to the system.<br/> <span style="text-decoration: underline;">Transport Timeout Error</span><br/> A transport timeout error occurs when a DTRrsp message returns with a timeout error from the transport interconnect (see Section 8.5.1). A transport timeout error is handled in the same manner as a transport power management error (see above).<br/> <strong><em>Note:</em></strong> This error is <em>not</em> propagated to the requesting agent.<br/> <strong><em>Note:</em></strong> The above behavior assumes that these errors are programming errors, so the behavior is effectively fatal to the system.</p><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207696PropagatedErrors"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207696"><span class="confluence-anchor-link" id="_Toc447207696"></span></span>Propagated Errors</h2><p>The following are propagated errors from external interfaces and internal units through Concerto. Propagated errors are not signaled or logged by any Concerto units.</p><h3 id="ConcertoSystemArchitectureSpecification-_Ref439950515_Toc447207697AIUPropagatedErrors"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref439950515"><span class="confluence-anchor-link" id="_Ref439950515"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207697"><span class="confluence-anchor-link" id="_Toc447207697"></span></span>AIU Propagated Errors</h3><p>An AIU propagates an error in any of the following cases:</p><ul><li>A requesting AIU receives a STRreq message, a DTWrsp message, or a DTRreq message that indicates a <em>data corruption error</em></li><li>A requesting AIU receives a STRreq message that indicates an <em>address corruption error</em></li><li>A requesting AIU receives a STRreq message that indicates a <em>transport error</em></li><li>A native agent write request indicates an error in the write data</li><li>A native snoop response returns with an error indication and does or does not include data</li><li>An IO cache access supplies data from an IO cache data entry that has been poisoned

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2127" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2127?src=confmacro" class="jira-issue-key">CONC-2127</a>
                            </span>
</li></ul><p>The following subsections describe in more detail how the above errors are propagated.<br/> <span style="text-decoration: underline;">Propagated Data Corruption Error</span><br/> A propagated data corruption error occurs when a requesting AIU receives a <em>data corruption error</em> in a DTRreq message, classified as a <em>data-propagated data corruption error</em>, or in either a STRreq message or a DTWrsp message, classified as a <em>control-propagated data corruption error</em>.<br/> For a <em>data-propagated data corruption error</em>, the AIU completes the protocol transaction and marks each data beat in the native agent read response with a <em>data corruption error</em> if that data beat contains a corrupted byte or indicates a <em>data corruption error</em> in the native agent write response. If the AIU is <em>not</em> permitted to return dirty data to the agent and must update memory, the AIU issues the DTWreq message and deasserts the byte enable for each corrupted byte in the data transfer.<br/> For a <em>control-propagated data corruption error</em>, the AIU completes the protocol transaction and marks each data beat in the native agent read response with a <em>data corruption error</em> or indicates a <em>data corruption error</em> in the native agent write response. The AIU does <em>not</em> issue a DTWreq message if the AIU would otherwise be required to update memory.<br/> <span style="text-decoration: underline;">Propagated Address Corruption Error</span><br/> A propagated address corruption error occurs when a requesting AIU receives an <em>address corruption error</em> in a STRreq message.<br/> In the case of an <em>address corruption error</em>, the AIU completes the protocol transaction and marks each data beat in the native agent read response with an <em>address corruption error</em> or indicates an <em>address corruption error</em> in the native agent write response. If the <strong>ST</strong> bit equals zero, the AIU generates the necessary response beats. The AIU does <em>not</em> issue a DTWreq message if the AIU would otherwise be required to update memory.<br/> <strong><em>Note:</em></strong> The above also applies to propagating errors in DVM transactions.<br/> <span style="text-decoration: underline;">Propagated Transport Error</span><br/> A propagated transport error occurs when a requesting AIU receives a <em>transport error</em> in a STRreq message.<br/> In the case of a <em>transport error</em>, the AIU completes the protocol transaction and marks each data beat in the native agent read response with a <em>transport error</em> or indicates a <em>transport error</em> in the native agent write response. If the <strong>ST</strong> bit equals zero, the AIU generates the necessary response beats. The AIU does <em>not</em> issue a DTWreq message if the AIU would otherwise be required to update memory.<br/> <span style="text-decoration: underline;">Agent Write Data Error</span><br/> <strong><em>FIXME:</em></strong> This cannot be signaled in ACE, but it can be in CHI. Concerto V1 currently poisons write data by deasserting the byte enables for the corrupted data words. This behavior will need to be revisited in a future version.<br/> <span style="text-decoration: underline;">Native Snoop Response Data Error</span><br/> A native snoop response data error occurs when a snooping AIU issues a native snoop request and either the native snoop response indicates an error and indicates a data transfer or the native snoop response indicates a data transfer and the snooping AIU issues a DTWreq message that completes with a <em>data corruption error</em>.<br/> If a DTRreq message is required in response to the SNPreq message, the AIU issues the DTRreq message to the requesting AIU. On the other hand, if a DTWreq message is required in response to the SNPreq message, the AIU does <em>not</em> issue the DTWreq message.<br/> When issuing the SNPrsp message, the snooping AIU signals a <em>data corruption error</em>.<br/> <strong><em>Note:</em></strong> In ACE, this scenario corresponds to a snoop response where the <strong>Error</strong> signal is one and the <strong>DataTransfer</strong> signal is one.<br/> <span style="text-decoration: underline;">Native Snoop Response Address Error</span><br/> A native snoop response address error occurs when a snooping AIU issues a native snoop request and the native snoop response indicates an error and does <em>not</em> indicate a data transfer.<br/> When issuing the SNPrsp message, the snooping AIU signals an <em>address corruption error</em>.<br/> <strong><em>Note:</em></strong> In ACE, this scenario corresponds to a snoop response where the <strong>Error</strong> signal is one and the <strong>DataTransfer</strong> signal is zero.<br/> <strong><em>Note:</em></strong> The above also applies to propagating errors in DVM transactions.<br/> <span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref440016680"><span class="confluence-anchor-link" id="_Ref440016680"></span></span><span style="text-decoration: underline;">Poisoned Data Error</span><br/> A poisoned data error occurs when a native agent transaction or a snoop message results in the propagation of poisoned data from the IO cache.<br/> In the case of an IO cache hit due to a native agent transaction, the AIU completes the transaction and marks each data beat in the native agent read response with a <em>data corruption error</em> if that data beat contains a corrupted byte or indicates a <em>data corruption error</em> in the native agent write response.<br/> In the case of an IO cache miss due to a native agent transaction, the AIU performs the update transaction and marks each data beat in the DTWreq message with a <em>data corruption error</em> if that data beat contains a corrupted byte.<br/> In the case of an IO cache hit due to a snoop message, the AIU completes the snoop message and marks each data beat in the DTRreq message with a <em>data corruption error</em> if that data beat contains a corrupted byte. The AIU does <em>not</em> indicate a <em>data corruption error</em> in the SNPrsp message.<br/> <strong><em>Note:</em></strong> This behavior is indistinguishable from the uncorrectable IO cache data error behavior.</p><h3 id="ConcertoSystemArchitectureSpecification-_Ref440376004_Toc447207698DCEPropagatedErrors"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref440376004"><span class="confluence-anchor-link" id="_Ref440376004"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207698"><span class="confluence-anchor-link" id="_Toc447207698"></span></span>DCE Propagated Errors</h3><p>A DCE propagates an error in any of the following cases:</p><ul><li>A DCE receives a SNPrsp message that indicates a data corruption error</li><li>A DCE receives a SNPrsp message that indicates an address corruption error

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2128" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2128?src=confmacro" class="jira-issue-key">CONC-2128</a>
                            </span>
</li></ul><p>The following subsections describe in more detail how the above errors are propagated.<br/> <span style="text-decoration: underline;">Propagated Snoop Response Data Error</span><br/> A propagated snoop response data error occurs when a DCE receives a SNPrsp message that indicates a <em>data corruption error</em>.<br/> For a protocol coherent transaction, the DCE logs the <em>data corruption error</em> in the corresponding ATT-Ctrl resource and signals a <em>data corruption error</em> to the requesting AIU in the STRreq message. Upon receiving the STRrsp message, the DCE performs the system directory commit and completes the protocol transaction.<br/> <span style="text-decoration: underline;">Propagated Snoop Response Address Error</span><br/> A propagated snoop response address error occurs when a DCE receives a SNPrsp message that indicates an <em>address corruption error</em>.<br/> For a protocol coherent transaction, the DCE logs the <em>address corruption error</em> in the corresponding ATT-Ctrl resource and signals an <em>address corruption error</em> to the requesting AIU in the STRreq message. Upon receiving the STRrsp message, the DCE performs the system directory commit and completes the protocol transaction.<br/> <strong><em>Note:</em></strong> The above also applies to propagating errors in DVM transactions.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207699DMIPropagatedErrors"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207699"><span class="confluence-anchor-link" id="_Toc447207699"></span></span>DMI Propagated Errors</h3><p>A DMI propagates an error in any of the following cases:</p><ul><li>A memory read response returns with an error indication</li><li>A DMI receives a DTWreq message that indicates a <em>data corruption error</em></li><li>A memory write response returns with an error indication

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2129" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2129?src=confmacro" class="jira-issue-key">CONC-2129</a>
                            </span>
</li></ul><p>The following subsections describe in more detail how the above errors are propagated.<br/> <span style="text-decoration: underline;">Memory Read Response Error</span><br/> A memory read response error occurs when a DMI issues a memory read request and the memory read response indicates an error.<br/> For a memory read response error due to an HNTreq message, the DMI behavior depends on whether an MRDreq message that matches the HNTreq message has been received. If a matching MRDreq message has <em>not</em> been received, the DMI discards the read response data and deallocates the HTT resources. If a matching MRDreq message has been received, the DMI logs a <em>data corruption error</em> in the corresponding HTT-Data resource for each corrupted byte received in the read response data. In the resulting DTRreq message, the DMI deasserts the byte enable for each corrupted byte, indicated by the <em>data corruption error</em>, in the data transfer.<br/> For a memory read response error due to an MRDreq message, the DMI logs a <em>data corruption error</em> in the corresponding RTT-Data resource for each corrupted byte in the read response data, if the DMI is configured with RTT-Data resources. In the resulting DTRreq message, the DMI deasserts the byte enable for each corrupted byte, indicated by the <em>data corruption error</em>, in the data transfer.<br/> In either case, the read response data may not be buffered, and the DTRreq message may be issued directly. If so, the DMI deasserts the byte enable for each corrupted byte, indicated by the memory read response error signal, in the data transfer.<br/> <strong><em>Note:</em></strong> No distinction is made between SLVERR and DECERR in the AXI response.<br/> <span style="text-decoration: underline;">Memory Write Data Error</span><br/> A memory write data error occurs when a DMI receives a DTWreq message that indicates a <em>data corruption error</em>. The DMI simply issues the memory write request.<br/> <strong><em>Note:</em></strong> At present, this error condition is indistinguishable from a normal DTWreq message.<br/> <span style="text-decoration: underline;">Memory Write Response Error</span><br/> A memory write response error occurs when a DMI issues a memory write request and the memory write response indicates an error.<br/> When issuing the DTWrsp message, the DMI signals a <em>data corruption error</em>.<br/> <strong><em>Note:</em></strong> No distinction is made between SLVERR and DECERR in the AXI response.</p><h2 id="ConcertoSystemArchitectureSpecification-_Ref427608790_Toc447207700ErrorLoggingandInterrupts"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427608790"><span class="confluence-anchor-link" id="_Ref427608790"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207700"><span class="confluence-anchor-link" id="_Toc447207700"></span></span>Error Logging and Interrupts</h2><p>Each unit implements a two sets of error control and logging registers, one for correctable errors and one for uncorrectable errors. Each set consists of an error control register, an error status register, a pair of error location registers, and an error status alias register.<br/> The error control register consists of an error detection enable bit, an error interrupt enable bit, and an error threshold field. When the error detection enable bit is one, error detection, correction, and logging is enabled,

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2130" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2130?src=confmacro" class="jira-issue-key">CONC-2130</a>
                            </span>
 meaning that hardware detects faults and takes action to correct the faults and capture information about them; otherwise, error detection, correction, and logging is disabled. When the error interrupt enable bit is one, any logged error asserts the appropriate interrupt signal wire; otherwise, the interrupt signal wire is not asserted.<br/> For correctable errors, the error threshold field specifies the number of corrected errors for which logging is suppressed. Once the threshold is reached, the next corrected error is logged in the error status register and error location register. For uncorrectable errors, the error threshold field is read-only and is equal to zero, meaning that error logging is never suppressed.<br/> The error status register consists of an error valid bit, an error overflow bit, and an error count field, in addition to an error type field and an error information field. Depending on the type of error, the error valid bit is set when the conditions for logging the error are met. For correctable errors, the error count value is incremented when the value of the error count field is not equal to the error threshold field and when a new error is corrected. If the error count field is equal to the error threshold field, the error valid bit is set when a new error is corrected, and once the error valid bit becomes set, the error count field is frozen at its current value. If the error valid bit is set and a new error is corrected, the error overflow bit is set. For uncorrectable errors, the process is the same, except that the value of the error threshold field, and therefore the error count field, is always zero. Finally, when the error valid bit gets set, the type of error is captured in the error type field, and additional information is captured in the error information field.

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2131" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2131?src=confmacro" class="jira-issue-key">CONC-2131</a>
                            </span>
<br/> <strong><em>Note:</em></strong> The above implies that no state is required to implement the error threshold field or the error count field for uncorrectable errors.<br/> <strong><em>Note:</em></strong> In effect, if the error threshold field equals <em>N</em>, the error status register counts <em>N</em> errors and logs the next error (i.e. error <em>N</em>+1). Once an error is logged, any subsequent errors cause the error overflow bit to be set.<br/> In addition, the location of the logged error is captured in the pair of error location registers, which includes a lower-addressed error location register and a higher-addressed error location register. The lower register consists of an error entry field, an error way field, and an error word field, and the higher register consists of an error address field. The error type field determines which fields are valid and the content of the field if valid. Typically, the error entry field captures the entry or the set of the logged error, the error way field captures the way of the logged error, and the error word captures the word offset, in 32-bit granules, into the entry of the logged error. In some cases, however, the error word field may simply capture the memory array instance in which the error was detected.<br/> <strong><em>Note:</em></strong> In general, the error word field indicates the word address in a system cacheline.<br/> <strong><em>Note:</em></strong> A typical ECC codeword covers 64b of data, and in such a case, the error word field would indicate the 32b word offset aligned to a 64b granule (i.e. bit [0] of the error word field would be 0).<br/> For some errors, the error location registers contain a representation of the address of the transaction that encountered the error. This representation is the cache coherence window offset shifted by the system cacheline offset. If the difference between the number of bits in the former and the number of bits in the latter is greater than 32, the higher-addressed error location register is required to log the high-order address bits; otherwise, the higher-addressed error location register is not required. The cache coherence window offset can be determined by concatenating the error address field, if required, the error word field, the error way field, and the error entry field. The Concerto system address may be determined by concatenating the cache coherence window prefix with the cache coherence window offset, as calculated from the error location registers, shifted left by the system cacheline offset. In addition, for these errors, the security attribute is logged in the error information field of the error status register.<br/> Table 4 and Table 5 list the error type encoding, the meaning of the error type code and the interpretation of the error information field, and the information logged in the fields of the error location registers. (MBZ indicates &quot;must be zero.&quot;)</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><strong>Error Type Code</strong></p></td><td class="confluenceTd"><p><strong>Error Type and Information</strong></p></td><td class="confluenceTd"><p><strong>Addr</strong></p></td><td class="confluenceTd"><p><strong>Word</strong></p></td><td class="confluenceTd"><p><strong>Way</strong></p></td><td class="confluenceTd"><p><strong>Entry</strong></p></td></tr><tr><td class="confluenceTd"><p>0x0</p></td><td class="confluenceTd"><p>CAIU/NCBU data correctable error <br class="atl-forced-newline"/> 0x00 – OTT-Data</p></td><td class="confluenceTd"><p><strong><em>MBZ</em></strong></p></td><td class="confluenceTd"><p><strong>Word</strong></p></td><td class="confluenceTd"><p><strong><em>MBZ</em></strong></p></td><td class="confluenceTd"><p><strong>Entry</strong></p></td></tr><tr><td class="confluenceTd"><p>0x1</p></td><td class="confluenceTd"><p>Proxy cache correctable error <br class="atl-forced-newline"/> 0x00 – Tag array <br class="atl-forced-newline"/> 0x01 – Data array</p></td><td class="confluenceTd"><p><strong><em>MBZ</em></strong></p></td><td class="confluenceTd"><p><strong>Word</strong></p></td><td class="confluenceTd"><p><strong>Way</strong></p></td><td class="confluenceTd"><p><strong>Set</strong></p></td></tr><tr><td class="confluenceTd"><p>0x2</p></td><td class="confluenceTd"><p><em>Reserved</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td></tr><tr><td class="confluenceTd"><p>0x3</p></td><td class="confluenceTd"><p><em>Reserved</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td></tr><tr><td class="confluenceTd"><p>0x4</p></td><td class="confluenceTd"><p>Snoop filter entry correctable error <br class="atl-forced-newline"/> [7:5] – Reserved (0) <br class="atl-forced-newline"/> [4:0] – Snoop filter identifier</p></td><td class="confluenceTd"><p><strong><em>MBZ</em></strong></p></td><td class="confluenceTd"><p><strong><em>MBZ</em></strong></p></td><td class="confluenceTd"><p><strong>Way</strong></p></td><td class="confluenceTd"><p><strong>Set</strong></p></td></tr><tr><td class="confluenceTd"><p>0x5</p></td><td class="confluenceTd"><p><em>Reserved</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td></tr><tr><td class="confluenceTd"><p>0x6</p></td><td class="confluenceTd"><p>CMIU data correctable error <br class="atl-forced-newline"/> 0x00 – HTT-Data <br class="atl-forced-newline"/> 0x01 – RTT-Data</p></td><td class="confluenceTd"><p><strong><em>MBZ</em></strong></p></td><td class="confluenceTd"><p><strong>Word</strong></p></td><td class="confluenceTd"><p><strong><em>MBZ</em></strong></p></td><td class="confluenceTd"><p><strong>Entry</strong></p></td></tr><tr><td class="confluenceTd"><p>0x7</p></td><td class="confluenceTd"><p><em>Reserved</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td></tr></tbody></table></div><p><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427580534"><span class="confluence-anchor-link" id="_Ref427580534"></span></span><strong>Table 4: Correctable Error Logging</strong></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><strong>Error Type Code</strong></p></td><td class="confluenceTd"><p><strong>Error Type and Information</strong></p></td><td class="confluenceTd"><p><strong>Addr</strong></p></td><td class="confluenceTd"><p><strong>Word</strong></p></td><td class="confluenceTd"><p><strong>Way</strong></p></td><td class="confluenceTd"><p><strong>Entry</strong></p></td></tr><tr><td class="confluenceTd"><p>0x8</p></td><td class="confluenceTd"><p>CAIU/NCBU data uncorrectable error <br class="atl-forced-newline"/> 0x00 – OTT-Data</p></td><td class="confluenceTd"><p><strong><em>MBZ</em></strong></p></td><td class="confluenceTd"><p><strong>Word</strong></p></td><td class="confluenceTd"><p><strong><em>MBZ</em></strong></p></td><td class="confluenceTd"><p><strong>Entry</strong></p></td></tr><tr><td class="confluenceTd"><p>0x9</p></td><td class="confluenceTd"><p>Proxy cache uncorrectable error <br class="atl-forced-newline"/> 0x00 – Tag array <br class="atl-forced-newline"/> 0x01 – Data array</p></td><td class="confluenceTd"><p><strong><em>MBZ</em></strong></p></td><td class="confluenceTd"><p><strong>Word</strong></p></td><td class="confluenceTd"><p><strong>Way</strong></p></td><td class="confluenceTd"><p><strong>Set</strong></p></td></tr><tr><td class="confluenceTd"><p>0xA</p></td><td class="confluenceTd"><p>Proxy cache transaction <em>control-propagated</em> error: <br class="atl-forced-newline"/> [7:6] – Reserved (0) <br class="atl-forced-newline"/> [5] – Security attribute <br class="atl-forced-newline"/> [4] – Address logged (0) <br class="atl-forced-newline"/> [3] – Agent read (0)/Agent write (1) <br class="atl-forced-newline"/> [2] – Fill (0)/Eviction (1) <br class="atl-forced-newline"/> [1:0] – Same as <strong>ErrResult</strong> encoding</p></td><td class="confluenceTd"><p><strong>Cache Coherence Window Offset</strong></p></td><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>0xB</p></td><td class="confluenceTd"><p>Proxy cache transaction <em>data-propagated</em> error: <br class="atl-forced-newline"/> [7:6] – Reserved (0) <br class="atl-forced-newline"/> [5] – Security attribute <br class="atl-forced-newline"/> [4] – Set/Way logged (1) <br class="atl-forced-newline"/> [3] – Agent read (0)/Agent write (1) <br class="atl-forced-newline"/> [2] – Fill (0) <br class="atl-forced-newline"/> [1:0] – Same as <strong>ErrResult</strong> encoding</p></td><td class="confluenceTd"><p><strong><em>MBZ</em></strong></p></td><td class="confluenceTd"><p><strong><em>MBZ</em></strong></p></td><td class="confluenceTd"><p><strong>Way</strong></p></td><td class="confluenceTd"><p><strong>Set</strong></p></td></tr><tr><td class="confluenceTd"><p>0xC</p></td><td class="confluenceTd"><p>Snoop filter entry uncorrectable error <br class="atl-forced-newline"/> [7:5] – Reserved (0) <br class="atl-forced-newline"/> [4:0] – Snoop filter identifier</p></td><td class="confluenceTd"><p><strong><em>MBZ</em></strong></p></td><td class="confluenceTd"><p><strong><em>MBZ</em></strong></p></td><td class="confluenceTd"><p><strong>Way</strong></p></td><td class="confluenceTd"><p><strong>Set</strong></p></td></tr><tr><td class="confluenceTd"><p>0xD</p></td><td class="confluenceTd"><p>Recall transaction error <br class="atl-forced-newline"/> [7:6] – Reserved (0) <br class="atl-forced-newline"/> [5] – Security attribute <br class="atl-forced-newline"/> [4:2] – Reserved (0) <br class="atl-forced-newline"/> [1:0] – Same as <strong>ErrResult</strong> encoding</p></td><td class="confluenceTd"><p><strong>Cache Coherence Window Offset</strong></p></td><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>0xE</p></td><td class="confluenceTd"><p>CMIU data uncorrectable error <br class="atl-forced-newline"/> 0x00 – HTT-Data <br class="atl-forced-newline"/> 0x01 – RTT-Data</p></td><td class="confluenceTd"><p><strong><em>MBZ</em></strong></p></td><td class="confluenceTd"><p><strong>Word</strong></p></td><td class="confluenceTd"><p><strong><em>MBZ</em></strong></p></td><td class="confluenceTd"><p><strong>Entry</strong></p></td></tr><tr><td class="confluenceTd"><p>0xF</p></td><td class="confluenceTd"><p><em>Reserved</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td></tr></tbody></table></div><p><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref436067453"><span class="confluence-anchor-link" id="_Ref436067453"></span></span><strong>Table 5: Uncorrectable Error Logging</strong><br/> If the error valid bit is set in the error status register, software can clear the error valid bit and reset the error count field to zero by writing a one to the error valid bit. Additionally, if the error overflow bit is set in the error status register, software can clear the error overflow bit by writing a one to the error overflow bit. If a given bit is <em>not</em> set, writing a one to that bit is ignored, i.e. the write does <em>not</em> clear the bit and does <em>not</em> reset the error count field to zero, in the case of a write to the error valid bit.<br/> An error handler is expected to read the contents of the error status and error location registers and to acknowledge the error by clearing either or both of the error valid and error overflow bits depending on the state of those bits when the error status register was read. Writing a one to either bit when the corresponding bit is <em>not</em> set is UNDEFINED, since that write may cause an error to be lost. Software also has diagnostic access to the fields in the error status register via the error status alias register, which provides read-write access to the read-only and write-one-to-clear fields defined in the error status register.<br/> In the case that multiple errors of the same type are detected in the same cycle, the corresponding error status register is modified as if a single error occurred, e.g. the error count field is incremented by one or the error is logged, except that the error overflow bit is also set to indicate that an error was not reflected in the state of the register. If the current state of the error status register causes an error to be logged, the selection of the logged error is <em>implementation-defined</em>.<br/> Additionally, in the case that software is writing the error status register in the same cycle that one or more errors occur, the result appears as if first the error occurred and then the write updated the state of the register. In the case that software is writing the error status alias register in the same cycle that one or more errors occur, the write simply updates the state of the register.<br/> The error interrupt signal wire is asserted for either a correctable or uncorrectable error when the corresponding error interrupt enable bit is set and either the corresponding error valid bit or error overflow bit is set. The correctable and uncorrectable interrupt wires are routed from each unit to DCE0, where the interrupt signals are combined into status registers and each class of interrupts is logically ORed into two output pins that may be connected to an external interrupt controller.<br/> Additional interrupt wires may be routed from the various transport interconnects to output pins, depending on the configuration of the transport interconnect.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207701ImplementationNotes"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207701"><span class="confluence-anchor-link" id="_Toc447207701"></span></span>Implementation Notes</h3><p>The following define the various events that can affect the state of the error status register:</p><ul><li>A <strong><em>single error event</em></strong> occurs when the error detection logic detects a single error of a given type in a cycle.</li><li>A <strong><em>multiple error event</em></strong> occurs when the error detection logic detects multiple errors of a given type in a cycle; a multiple error event updates the error status register in the same manner as a single error event with the exception that the error overflow bit is also set; a multiple error event cannot occur in the same cycle as a single error event.</li><li>An <strong><em>error valid write event</em></strong> occurs when software writes a one to the error valid bit via the error status register and the error valid bit is set.</li><li>An <strong><em>error overflow write event</em></strong> occurs when software writes a one to the error overflow bit via the error status register and the error overflow bit is set.</li><li>A <strong><em>register alias write event</em></strong> occurs when software writes error status register via the error status alias register; a register alias write event cannot occur in the same cycle as either an error valid write event or an error overflow write event.</li></ul><p>The following describe the behavior of the error logic for the above events:</p><ul><li>If the error valid bit is <em>not</em> set and either a single or multiple error event occurs, the error logic either (1) increments the error count field or (2) sets the error valid bit and logs information about the error. (<strong><em>Note:</em></strong> This behavior is independent of the state of the error overflow bit.)</li><li>If the error valid bit is set and an error valid write event occurs, the error logic clears the error valid bit. (<strong><em>Note:</em></strong> This behavior is independent of whether a single or multiple error event occurs in the same cycle.)</li><li>If the error overflow bit is <em>not</em> set and either (1) a multiple error event occurs or (2) a single error event occurs and the error valid bit is set, the error logic sets the error overflow bit.</li><li>If the error overflow bit is set and an error overflow write event occurs, the error logic clears the error overflow bit. (<strong><em>Note:</em></strong> This behavior is independent of whether a single or multiple error event occurs in the same cycle.)</li><li>If register alias write event occurs, the error logic masks all other events and updates the error status register based on the write data.</li></ul><p>For combinations of events not listed above, the state of the error status register does not change.</p><h1 id="ConcertoSystemArchitectureSpecification-_Toc447207702MaintenanceandDebug"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207702"><span class="confluence-anchor-link" id="_Toc447207702"></span></span>Maintenance and Debug</h1><p>This section describes the hardware maintenance and debug features for Concerto units.</p><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207703MemoryArrayMaintenanceandDebug"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207703"><span class="confluence-anchor-link" id="_Toc447207703"></span></span>Memory Array Maintenance and Debug</h2><p>This section describes the memory array maintenance and debug for an IO cache and a directory segment.</p><h3 id="ConcertoSystemArchitectureSpecification-_Ref427766533_Toc447207704IOCache(ProxyCache)MaintenanceandDebug"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427766533"><span class="confluence-anchor-link" id="_Ref427766533"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207704"><span class="confluence-anchor-link" id="_Toc447207704"></span></span>IO Cache (Proxy Cache) Maintenance and Debug</h3><p>An AIU implements a set of proxy cache maintenance registers, which consists of a maintenance control register, a maintenance activity register, a pair of maintenance location registers, and a maintenance data register.<br/> The maintenance control register consists of a maintenance operation field, an array identifier bit, and a security attribute bit (see below). On a write to the maintenance control register, the maintenance operation written to the maintenance operation field is performed on the tag or data array identified by the value written to the array identifier bit. The maintenance operation is performed on the tag array when the identifier bit equals zero, and the maintenance operation is performed on the data array when the identifier bit equals one.<br/> <strong><em>Note:</em></strong> The array identifier bit and the security attribute bit values and register locations are consistent with the information reported in the error information register described in Section 8.7.<br/> <strong><em>Note:</em></strong> The security attribute may be configured to be up to three bits; however, in Concerto V1, the two most significant bits are RESERVED.<br/> The maintenance activity register consists of a maintenance operation active bit. When the maintenance control register is written, the maintenance operation active bit is set, and the maintenance operation active bit remains set until the maintenance operation is complete.<br/> The location or address on which the maintenance operation is performed is indicated by the pair of maintenance location registers, which includes a lower-addressed maintenance location register and a higher-addressed error location register. The lower register consists of a maintenance set field, a maintenance way field, and a maintenance word field, and the higher register consists of a maintenance address field. The type of maintenance operation determines which fields are used for the operation. Typically, the maintenance set field indicates the set for the operation, the error way field indicates the way for the operation, and the maintenance word indicates the word offset, in 32-bit granules, into the entry.<br/> For some operations, the maintenance location registers indicate a representation of an address. This representation is the cache coherence window offset shifted by the system cacheline offset. If the difference between the number of bits in the former and the number of bits in the latter is greater than 32, the higher-addressed maintenance location register is required to indicate the high-order address bits; otherwise, the higher-addressed error location register is not required. The cache coherence window offset can be derived by shifting the Concerto system address right by the system cacheline offset and by removing the cache coherence window prefix bits. In addition, for these errors, the security attribute is indicated in the security attribute bit of the maintenance control register.<br/> Table 6 lists the proxy cache maintenance operation encodings, the meaning of the operation type code and the meaning of the array identifier, and how the maintenance set, maintenance way, maintenance word, and maintenance address fields are interpreted for the operation. (SBZ indicates &quot;should be zero.&quot;)</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><strong>Op Type Code</strong></p></td><td class="confluenceTd"><p><strong>Maintenance Operation and Array Identifier</strong></p></td><td class="confluenceTd"><p><strong>Addr</strong></p></td><td class="confluenceTd"><p><strong>Word</strong></p></td><td class="confluenceTd"><p><strong>Way</strong></p></td><td class="confluenceTd"><p><strong>Set</strong></p></td></tr><tr><td class="confluenceTd"><p>0x0</p></td><td class="confluenceTd"><p>Initialize All Entries <br class="atl-forced-newline"/> 0 – Tag Array</p></td><td class="confluenceTd"><p><strong><em>SBZ</em></strong></p></td><td class="confluenceTd"><p><strong><em>SBZ</em></strong></p></td><td class="confluenceTd"><p><strong><em>SBZ</em></strong></p></td><td class="confluenceTd"><p><strong><em>SBZ</em></strong></p></td></tr><tr><td class="confluenceTd"><p>0x1-0x3</p></td><td class="confluenceTd"><p><em>Reserved</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td></tr><tr><td class="confluenceTd"><p>0x4</p></td><td class="confluenceTd"><p>Flush All Entries <br class="atl-forced-newline"/> 0 – Tag Array</p></td><td class="confluenceTd"><p><strong><em>SBZ</em></strong></p></td><td class="confluenceTd"><p><strong><em>SBZ</em></strong></p></td><td class="confluenceTd"><p><strong><em>SBZ</em></strong></p></td><td class="confluenceTd"><p><strong><em>SBZ</em></strong></p></td></tr><tr><td class="confluenceTd"><p>0x5</p></td><td class="confluenceTd"><p>Flush Entry at Set and Way <br class="atl-forced-newline"/> 0 – Tag Array</p></td><td class="confluenceTd"><p><strong><em>SBZ</em></strong></p></td><td class="confluenceTd"><p><strong><em>SBZ</em></strong></p></td><td class="confluenceTd"><p><strong>Way</strong></p></td><td class="confluenceTd"><p><strong>Set</strong></p></td></tr><tr><td class="confluenceTd"><p>0x6</p></td><td class="confluenceTd"><p>Flush Entry at Address <br class="atl-forced-newline"/> 0 – Tag Array</p></td><td class="confluenceTd"><p><strong>Cache Coherence Window Offset</strong></p></td><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>0x7-0xB</p></td><td class="confluenceTd"><p><em>Reserved</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td></tr><tr><td class="confluenceTd"><p>0xC</p></td><td class="confluenceTd"><p>Debug Read Entry at Set, Way, and Word <br class="atl-forced-newline"/> 0 – Tag Array <br class="atl-forced-newline"/> 1 – Data Array</p></td><td class="confluenceTd"><p><strong><em>SBZ</em></strong></p></td><td class="confluenceTd"><p><strong>Word</strong></p></td><td class="confluenceTd"><p><strong>Way</strong></p></td><td class="confluenceTd"><p><strong>Set</strong></p></td></tr><tr><td class="confluenceTd"><p>0xD</p></td><td class="confluenceTd"><p><em>Reserved</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td></tr><tr><td class="confluenceTd"><p>0xE</p></td><td class="confluenceTd"><p>Debug Write Entry at Set, Way, and Word <br class="atl-forced-newline"/> 0 – Tag Array <br class="atl-forced-newline"/> 1 – Data Array</p></td><td class="confluenceTd"><p><strong><em>SBZ</em></strong></p></td><td class="confluenceTd"><p><strong>Word</strong></p></td><td class="confluenceTd"><p><strong>Way</strong></p></td><td class="confluenceTd"><p><strong>Set</strong></p></td></tr><tr><td class="confluenceTd"><p>0xF</p></td><td class="confluenceTd"><p><em>Reserved</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2132" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2132?src=confmacro" class="jira-issue-key">CONC-2132</a>
                            </span>
</em></p></td></tr></tbody></table></div><p><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427834065"><span class="confluence-anchor-link" id="_Ref427834065"></span></span><strong>Table 6: IO Cache (Proxy Cache) Maintenance Operations</strong><br/> An initialize all entries maintenance operation invalidates all the tag entries in the IO cache by issuing multiple individual IO cache tag write maintenance operations, while a flush all entries maintenance operation flushes all entries in the IO cache by issuing multiple individual flush entry at set and way maintenance operations. All other operations are single individual maintenance operations. While an individual maintenance operation is in progress, an AIU blocks any new accesses to the proxy cache until the operation completes its tag array access. <br/> While the maintenance operation active bit is set, any new writes to the maintenance control register, the maintenance location registers, and the maintenance data register are ignored. As a result, only one proxy cache maintenance operation can be performed at a time. Furthermore, the contents of the maintenance data register are UNDEFINED until the operation completes and the maintenance operation active bit is clear.<br/> Maintenance initialize operations do not detect, log, or signal errors. Maintenance flush operations may detect, log, and signal errors as described in Section 8.0. If the flush operates on an address, the operation behaves like an IO cache lookup and may affect or be affected by other entries; on the other hand, if the flush operates on an entry at a set and way, the operation only affects the entry at that set and way, and other entries in that set are ignored. In addition, at the completion of the flush operation, all flushed entries are guaranteed to be invalid. All maintenance operations are performed even if the Proxy Cache Lookup Enable bit is clear.

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2133" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2133?src=confmacro" class="jira-issue-key">CONC-2133</a>
                            </span>
 Software must not attempt any maintenance operation if the IO cache clock is disabled or the IO cache supply voltage is below an operational level.<br/> Debug read operations and debug write operations bypass the error detection and correction logic and access the IO cache arrays directly. As a result, these operations do not detect, log, or signal errors. Debug operations may be performed at any time, and performing a debug operation, by itself, <em>must not</em> cause functional issues, although a debug write operation may cause functional issues depending on the value written. However, from a software perspective, the data values read from an IO cache or written to an IO cache by a debug operation are UNDEFINED unless the IO cache is in the <em>offline</em> state. Debug operations are 32-bit atomic.</p><h3 id="ConcertoSystemArchitectureSpecification-_Ref427851671_Ref427851686_Toc447207705DirectorySegment(SnoopFilter)MaintenanceandDebug"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427851671"><span class="confluence-anchor-link" id="_Ref427851671"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427851686"><span class="confluence-anchor-link" id="_Ref427851686"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207705"><span class="confluence-anchor-link" id="_Toc447207705"></span></span>Directory Segment (Snoop Filter) Maintenance and Debug</h3><p>A DCE implements a set of snoop filter maintenance registers, which consists of a maintenance control register, a maintenance activity register, a pair of maintenance location registers, and a maintenance data register.<br/> The maintenance control register consists of a maintenance operation field, a snoop filter identifier field, and a security attribute bit (see below). On a write to the maintenance control register, the maintenance operation written to the maintenance operation field is performed on the snoop filter identified by the value written to the snoop filter identifier field.<br/> <strong><em>Note:</em></strong> The snoop filter identifier field and the security attribute bit values and register locations are consistent with the information reported in the error information register described in Section 8.7.<br/> <strong><em>Note:</em></strong> The security attribute may be configured to be up to three bits; however, in Concerto V1, the two most significant bits are RESERVED.<br/> The maintenance activity register consists of a maintenance operation active bit. When the maintenance control register is written, the maintenance operation active bit is set, and the maintenance operation active bit remains set until the maintenance operation is complete.<br/> The location or address on which the maintenance operation is performed is indicated by the pair of maintenance location registers, which includes a lower-addressed maintenance location register and a higher-addressed error location register. The lower register consists of a maintenance set field, a maintenance way field, and a maintenance word field, and the higher register consists of a maintenance address field. The type of maintenance operation determines which fields are used for the operation. Typically, the maintenance set field indicates the set for the operation, the error way field indicates the way for the operation, and the maintenance word indicates the word offset, in 32-bit granules, into the entry.<br/> For some operations, the maintenance location registers indicate a representation of an address. This representation is the cache coherence window offset shifted by the system cacheline offset. If the difference between the number of bits in the former and the number of bits in the latter is greater than 32, the higher-addressed maintenance location register is required to indicate the high-order address bits; otherwise, the higher-addressed error location register is not required. The cache coherence window offset can be derived by shifting the Concerto system address right by the system cacheline offset and by removing the cache coherence window prefix bits. In addition, for these errors, the security attribute is indicated in the security attribute bit of the maintenance control register.<br/> Table 7 lists the snoop filter maintenance operation encodings, the meaning of the operation type code and the meaning of the snoop filter identifier, and how the maintenance set, maintenance way, maintenance word, and maintenance address fields are interpreted for the operation. (SBZ indicates &quot;should be zero.&quot;)</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><strong>Op Type Code</strong></p></td><td class="confluenceTd"><p><strong>Maintenance Operation and Snoop Filter Identifier</strong></p></td><td class="confluenceTd"><p><strong>Addr</strong></p></td><td class="confluenceTd"><p><strong>Word</strong></p></td><td class="confluenceTd"><p><strong>Way</strong></p></td><td class="confluenceTd"><p><strong>Set</strong></p></td></tr><tr><td class="confluenceTd"><p>0x0</p></td><td class="confluenceTd"><p>Initialize All Entries <br class="atl-forced-newline"/> [4:0] – Snoop filter identifier</p></td><td class="confluenceTd"><p><strong><em>SBZ</em></strong></p></td><td class="confluenceTd"><p><strong><em>SBZ</em></strong></p></td><td class="confluenceTd"><p><strong><em>SBZ</em></strong></p></td><td class="confluenceTd"><p><strong><em>SBZ</em></strong></p></td></tr><tr><td class="confluenceTd"><p>0x1-0x3</p></td><td class="confluenceTd"><p><em>Reserved</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td></tr><tr><td class="confluenceTd"><p>0x4</p></td><td class="confluenceTd"><p>Recall All Entries <br class="atl-forced-newline"/> [4:0] – Snoop filter identifier</p></td><td class="confluenceTd"><p><strong><em>SBZ</em></strong></p></td><td class="confluenceTd"><p><strong><em>SBZ</em></strong></p></td><td class="confluenceTd"><p><strong><em>SBZ</em></strong></p></td><td class="confluenceTd"><p><strong><em>SBZ</em></strong></p></td></tr><tr><td class="confluenceTd"><p>0x5</p></td><td class="confluenceTd"><p>Recall Entry at Set and Way <br class="atl-forced-newline"/> [4:0] – Snoop filter identifier</p></td><td class="confluenceTd"><p><strong><em>SBZ</em></strong></p></td><td class="confluenceTd"><p><strong><em>SBZ</em></strong></p></td><td class="confluenceTd"><p><strong>Way</strong></p></td><td class="confluenceTd"><p><strong>Set</strong></p></td></tr><tr><td class="confluenceTd"><p>0x6</p></td><td class="confluenceTd"><p>Recall Entry at Address <br class="atl-forced-newline"/> [4:0] – Snoop filter identifier</p></td><td class="confluenceTd"><p><strong>Cache Coherence Window Offset</strong></p></td><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>0x7</p></td><td class="confluenceTd"><p><em>Reserved</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td></tr><tr><td class="confluenceTd"><p>0x8</p></td><td class="confluenceTd"><p>Recall All Victim Buffer Entries <br class="atl-forced-newline"/> [4:0] – Snoop filter identifier</p></td><td class="confluenceTd"><p><strong><em>SBZ</em></strong></p></td><td class="confluenceTd"><p><strong><em>SBZ</em></strong></p></td><td class="confluenceTd"><p><strong><em>SBZ</em></strong></p></td><td class="confluenceTd"><p><strong><em>SBZ</em></strong></p></td></tr><tr><td class="confluenceTd"><p>0x9-0xB</p></td><td class="confluenceTd"><p><em>Reserved</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td></tr><tr><td class="confluenceTd"><p>0xC</p></td><td class="confluenceTd"><p>Debug Read Entry at Set, Way, and Word <br class="atl-forced-newline"/> [4:0] – Snoop filter identifier</p></td><td class="confluenceTd"><p><strong><em>SBZ</em></strong></p></td><td class="confluenceTd"><p><strong>Word</strong></p></td><td class="confluenceTd"><p><strong>Way</strong></p></td><td class="confluenceTd"><p><strong>Set</strong></p></td></tr><tr><td class="confluenceTd"><p>0xD</p></td><td class="confluenceTd"><p><em>Reserved</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td></tr><tr><td class="confluenceTd"><p>0xE</p></td><td class="confluenceTd"><p>Debug Write Entry at Set, Way, and Word <br class="atl-forced-newline"/> [4:0] – Snoop filter identifier</p></td><td class="confluenceTd"><p><strong><em>SBZ</em></strong></p></td><td class="confluenceTd"><p><strong>Word</strong></p></td><td class="confluenceTd"><p><strong>Way</strong></p></td><td class="confluenceTd"><p><strong>Set</strong></p></td></tr><tr><td class="confluenceTd"><p>0xF</p></td><td class="confluenceTd"><p><em>Reserved</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A</em></p></td><td class="confluenceTd"><p><em>N/A

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2134" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2134?src=confmacro" class="jira-issue-key">CONC-2134</a>
                            </span>
</em></p></td></tr></tbody></table></div><p><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427855132"><span class="confluence-anchor-link" id="_Ref427855132"></span></span><strong>Table 7: Directory Segment (Snoop Filter) Maintenance Operations</strong><br/> An <em>initialize all entries</em> maintenance operation invalidates all the tag filter entries through a series of individual <em>debug write entry</em> operations to each set and way and invalidates the victim buffer entries, if present, by clearing the entry valid bits. A <em>recall all entries</em> maintenance operation recalls all tag filter entries through a series of individual <em>recall entry at set and way</em> operations on each set and way and recalls the victim buffer entries, if present, by performing a <em>recall all victim buffer entries</em> maintenance operation, which initiates a recall transaction for each valid entry in the victim buffer. Software may perform this latter operation independently. All other operations are single individual maintenance operations. While an individual maintenance operation is in progress, a DCE blocks any new accesses to the directory until the operation completes its directory access.<br/> Additionally, a <em>recall entry at address</em> maintenance operation <em>must</em> access both the tag filter and victim buffer, if present, and performs a recall transaction on a matching address in either structure.<br/> <strong><em>Note:</em></strong> Individual <em>recall entry at set and way</em> and <em>recall entry at address</em> operations <em>must</em> ensure that the designated entry is no longer present in either the tag filter or the victim buffer at the end of the operation.<br/> While the maintenance operation active bit is set, any new writes to the maintenance control register, the maintenance location registers, and the maintenance data register are ignored. As a result, only one directory segment maintenance operation can be performed at a time. Furthermore, the contents of the maintenance data register are UNDEFINED until the operation completes and the maintenance operation active bit is clear.<br/> Maintenance initialize operations do not detect, log, or signal errors. Maintenance recall operations may detect, log, or signal errors as described in Section 8.0. If the recall operates on an address, the operation behaves like a directory segment lookup and may affect or be affected by other entries; on the other hand, if the recall operates on an entry at a set and way, the operation only affects the entry at that set and way, and other entries in that set are ignored. In addition, at the completion of the recall operation, all recalled entries are guaranteed to be invalid. All maintenance operations are performed even if the Snoop Filter Enable bit is clear. Software must not attempt any maintenance operation if the directory segment clock is disabled or the directory segment supply voltage is below an operational level.<br/> Debug read operations and debug write operations bypass the error detection and correction logic and access the tag filter arrays directly. As a result, these operations do not detect, log, or signal errors. Debug operations may be performed at any time, and performing a debug operation, by itself, <em>must not</em> cause functional issues, although a debug write operation may cause functional issues depending on the value written. However, from a software perspective, the data values read from a snoop filter or written to a snoop filter by a debug operation are UNDEFINED unless the snoop filter is in the <em>offline</em> state. Debug operations are 32-bit atomic.

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2135" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2135?src=confmacro" class="jira-issue-key">CONC-2135</a>
                            </span>
</p><h2 id="ConcertoSystemArchitectureSpecification-_Ref417939414_Toc447207706TransactionTableDebug"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref417939414"><span class="confluence-anchor-link" id="_Ref417939414"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207706"><span class="confluence-anchor-link" id="_Toc447207706"></span></span>Transaction Table Debug</h2><p>Each unit implements a set of debug registers, which consists of a debug control register, a debug activity register, a debug location register, and a debug data register.<br/> The debug control register consists of a debug operation field. On a write to the debug control register, the debug operation written to the debug operation field is performed. At present, only debug read operations are supported, and a value of all zeros must be written into the debug operation field.<br/> The debug activity register consists of a debug operation active bit and a debug operation failure bit. When the debug control register is written, the debug operation active bit is set, and the debug operation active bit remains set until the debug operation is complete. In addition, when the debug control register is written, the debug operation failure bit is cleared, and once the debug operation is complete, the debug operation failure bit remains clear if the operation completed successfully or becomes set if the operation did <em>not</em> complete successfully.<br/> The location on which the debug operation is performed is indicated by the debug location register, which consists of a debug entry field, a debug structure field, and a debug word field. The debug entry field identifies an entry in the structure indicated by the debug structure field, and the debug word indicates the word offset, in 32-bit granules, in the entry. The assignment of state to debug entry, debug structure, and debug word values is <em>implementation-defined</em>.<br/> The debug data register contains the data read from the transaction table at the completion of the debug operation. If the debug operation was successful, as indicated by the debug operation failure bit, the contents of the debug data register are updated with the data read from the transaction table; if not, the debug data register remains unchanged. If the debug location register corresponds to a reserved structure, entry, or word, the contents of the debug data register are UNDEFINED.<br/> While the debug operation active bit is set, any new writes to the debug control register, the debug location register, and the debug data register are ignored. As a result, only one debug operation can be performed at a time. Furthermore, the contents of the debug data register are UNDEFINED until the operation completes and the debug operation active bit is clear.

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2136" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2136?src=confmacro" class="jira-issue-key">CONC-2136</a>
                            </span>
<br/> Debug operations may be performed at any time, and performing a debug operation, by itself, <em>must not</em> cause functional issues. However, the data values read from a transaction table are UNDEFINED unless the following conditions are true:</p><ul><li>No new messages will be presented on the slave request interfaces or on the master response interfaces, i.e. either the valid input signal or the ready output signal on each of these interfaces is deasserted and will not be asserted.</li><li>No new messages will be presented on the master request interfaces or on the slave response interfaces, i.e. either the valid output signal or the ready input signal on each of these interfaces is deasserted and will not be asserted.</li></ul><p><strong><em>Note:</em></strong> The first requirement implies that no new activity in the unit can be initiated by the rest of the system, and the second requirement implies that no new activity in the rest of the system can be initiated by the unit.<br/> <strong><em>Note:</em></strong> The above requirements apply only to the functional interfaces, i.e. SFI, AXI, or native agent interfaces, and do <em>not</em> apply to the CSR access interfaces, i.e. OCP-Lite.<br/> Debug operations are 32-bit atomic.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207707ImplementationNotes"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207707"><span class="confluence-anchor-link" id="_Toc447207707"></span></span>Implementation Notes</h3><p>The following notes apply to the implementation of the debug features:</p><ul><li>The debug features <em>must</em> be configurable based on a unit parameter, and a user may select to configure a unit without the debug features</li><li>No additional read ports should be added to the transaction tables to implement the debug features; in other words, an existing transaction table read mux should be used for debug operations. In the case where a collision occurs between any functional activity and a debug operation, the functional activity takes precedence. In this case, the debug operation failure bit is set, and the debug data register is unchanged.</li></ul><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207708TransactionTracing"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207708"><span class="confluence-anchor-link" id="_Toc447207708"></span></span>Transaction Tracing</h2><p><strong><em>FIXME:</em></strong> More details needed<br/> Generally speaking, Concerto relies on the FlexNoC trace capability. Some features that may be added to support protocol message tracing:</p><ul><li>An UpdVld message to trace Update Memory Valid protocol transactions</li><li>Control bits to enable UpdInv and UpdVld messages, even if unnecessary, so that all protocol transactions can be traced at the input to the DCE</li></ul><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207709ProgrammingErrors"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207709"><span class="confluence-anchor-link" id="_Toc447207709"></span></span>Programming Errors</h2><p><strong><em>FIXME:</em></strong> More details needed</p><ul><li>Certain transport interconnect errors</li><li>CMDreq message received by DCE when Agent Snoop Enable bit (or some other non-coherent only indication) is clear?</li></ul><h1 id="ConcertoSystemArchitectureSpecification-_Toc447207710PerformanceMonitoring"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207710"><span class="confluence-anchor-link" id="_Toc447207710"></span></span>Performance Monitoring</h1><p><strong><em>FIXME</em></strong></p><h1 id="ConcertoSystemArchitectureSpecification-_Toc447207711SoftwareModel"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207711"><span class="confluence-anchor-link" id="_Toc447207711"></span></span>Software Model</h1><p>This section describes the Concerto software model.</p><h2 id="ConcertoSystemArchitectureSpecification-_Ref441680215_Toc447207712Background"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref441680215"><span class="confluence-anchor-link" id="_Ref441680215"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207712"><span class="confluence-anchor-link" id="_Toc447207712"></span></span>Background</h2><p>As described in Section 2.0, each Concerto unit implements a simple OCP-Lite slave interface on the ConcertoServiceTI to provide read and write access to memory-mapped control and status registers (CSRs) within the unit. There are two supported access types:</p><ul><li>Reads to aligned 32-bit addresses</li><li>Writes to aligned 32-bit addresses</li></ul><p>All other types of accesses are UNDEFINED and result in slave errors.<br/> Each unit supports a maximum of one outstanding CSR access on its OCP-Lite slave interface. If a unit is processing a CSR access and a second arrives, the subsequent CSR access is blocked until the active access has completed.<br/> The ConcertoServiceTI exposes a 1MB memory region, which is divided into 256 4KB pages of 1024 32b registers each, in the global address space of the NonCoherentTI to which the service transport interconnect is attached. In this <strong><em>Concerto register region</em></strong>, each 4KB page is mapped to a unit or is UNDEFINED. In addition, the region includes one page that provides information about the coherence domain as a whole. An access to an UNDEFINED page results in a slave error.<br/> Software identifies a unit based on the <strong><em>register page</em></strong> <strong><em>number</em></strong>, or <strong><em>RegPageNum</em></strong>, within the Concerto register region. Using the definitions of <em>A</em>, <em>B</em>, <em>D</em>, and <em>M</em> from Section 2.1, the following shows how the register page numbers map onto to the Concerto units:</p><ul><li>0x00 to 0x5F: Agent AIUs (0x00 through <em>A</em>-1 legal, others UNDEFINED)</li><li>0x60 to 0x7F: Bridge AIUs (0x60 through 0x60+<em>B</em>-1 legal, others UNDEFINED)</li><li>0x80 to 0x9F: DCEs (0x80 through 0x80+<em>D</em>-1 legal, others UNDEFINED)</li><li>0xA0 to 0xBF: UNDEFINED</li><li>0xC0 to 0xDF: DMIs (0xC0 through 0xC0+<em>M</em>-1 legal, others UNDEFINED)</li><li>0xE0 to 0xFE: UNDEFINED</li><li>0xFF: Coherent Subsystem CSRs (mapped to DCE0)</li></ul><p>The register page numbers are grouped by the type of unit, i.e. Agent AIUs, Bridge AIUs, DCEs, and DMIs, and a <strong><em>register unit identifier</em></strong>, or <strong><em>RegUnitID</em></strong>, is used to identify a unit within each group. The RegUnitID is based on the UnitID and the number of units of each type and can be used to index into a register field to select a bit corresponding to the unit. The relationship between RegUnitID and UnitID is given by the following

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2032" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2032?src=confmacro" class="jira-issue-key">CONC-2032</a>
                            </span>
:</p><ul><li>Agent AIUs: RegUnitID = UnitID</li><li>Bridge AIUs: RegUnitID = UnitID - <em>A</em></li><li>DCEs: RegUnitID = UnitID - (<em>A</em> + <em>B</em>)</li><li>DMIs: RegUnitID = UnitID - (<em>A</em> + <em>B</em> + <em>D</em>)</li></ul><p>The difference between the register page number and register unit identifier is a constant based on the type of unit.<br/> Each register within a register page is identified with a <strong><em>register number</em></strong>, or <strong><em>RegNum</em></strong>, that indicates the given register within the page. The address offset of the register is given by multiplying the register number by 4, which is the number of bytes in each register.<br/> Bits within a register may be accessed by software in one of the following ways:</p><ul><li><strong><em>Read-only</em></strong> (<strong><em>RO</em></strong>) – A software read returns the value of the bit, while a software write is ignored.</li><li><strong><em>Read-write</em></strong> (<strong><em>RW</em></strong>) – A software read returns the value of the bit, while a software write updates the value of the bit.</li><li><strong><em>Read-write-one-to-clear</em></strong> (<strong><em>RW1C</em></strong>) – A software read returns the value of the bit, while a software write of zero is ignored and a software write of one clears the value of the bit.</li></ul><p>Bits within a register may also affect the hardware in one of the following ways:</p><ul><li><strong><em>Ignored</em></strong> (<strong><em>IG</em></strong>) – Hardware ignores the state of the bit.</li><li><strong><em>Read-only</em></strong> (<strong><em>RO</em></strong>) – Hardware behavior is modified by the state of the bit.</li><li><strong><em>Write-only</em></strong> (<strong><em>WO</em></strong>) – Hardware updates the state of the bit on an event.</li><li><strong><em>Read-write</em></strong> (<strong><em>RW</em></strong>) – Hardware behavior is modified by the state of the bit, and hardware updates the state of the bit on an event.</li></ul><p>Reserved bits in registers are indicated as RAZ/WI, or read-as-zero/write-ignored. In other words, reads return zeros for those bits, and writes to those bits are ignored.<br/> The remainder of this section describes the registers for the individual units.</p><h2 id="ConcertoSystemArchitectureSpecification-_Ref426062254_Toc447207713CoherentAgentInterfaceUnitRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref426062254"><span class="confluence-anchor-link" id="_Ref426062254"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207713"><span class="confluence-anchor-link" id="_Toc447207713"></span></span>Coherent Agent Interface Unit Registers</h2><p>Coherent agent interface unit (CAIU) registers are implemented by an Agent AIU and are located in register pages 0x00 through 0x5F.</p><h3 id="ConcertoSystemArchitectureSpecification-_Ref427750673_Ref427750674_Toc447207714CAIUTransactionRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427750673"><span class="confluence-anchor-link" id="_Ref427750673"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427750674"><span class="confluence-anchor-link" id="_Ref427750674"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207714"><span class="confluence-anchor-link" id="_Toc447207714"></span></span>CAIU Transaction Registers</h3><p>This section describes the CAIU transaction control and activity registers.<br/> <span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427684573"><span class="confluence-anchor-link" id="_Ref427684573"></span></span><strong><em>CAIU</em></strong> <strong><em>Transaction Control Register (CAIUTCR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x000<br/> <span style="text-decoration: underline;">Description</span><br/> The CAIUTCR controls whether agent transactions are enabled in a coherent agent interface unit. This register consists of the following bits and fields:</p><ul><li>Agent Transaction Enable – This bit enables agent transactions.</li><li>Agent Isolation Enable – This bit enables agent isolation mode.</li></ul><p>See Section 7.2.1 for more details.<br/> <span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427684628"><span class="confluence-anchor-link" id="_Ref427684628"></span></span><strong><em>CAIU Transaction Activity Register (CAIUTAR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x001<br/> <span style="text-decoration: underline;">Description</span><br/> The CAIUTAR reports whether certain protocol transactions are active in a coherent agent interface unit. This register consists of the following bits and fields:</p><ul><li>Transaction Active – This bit is set when the unit is performing any activity related to native agent transactions and is clear otherwise.</li><li>Snoop Transaction Active – This bit is set when the unit is performing any activity related to snoop messages and is clear otherwise.</li><li>Coherent Transaction Active – This bit is set when the unit is performing any activity related to coherent transactions and is clear otherwise.</li></ul><p>See Section 7.2.1 for more details.</p><h3 id="ConcertoSystemArchitectureSpecification-_Ref427750675_Ref427750681_Toc447207715CAIUProxyCacheTransactionRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427750675"><span class="confluence-anchor-link" id="_Ref427750675"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427750681"><span class="confluence-anchor-link" id="_Ref427750681"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207715"><span class="confluence-anchor-link" id="_Toc447207715"></span></span>CAIU Proxy Cache Transaction Registers</h3><p>This section describes the CAIU proxy cache transaction control and activity registers.<br/> <span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427658576"><span class="confluence-anchor-link" id="_Ref427658576"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427743551"><span class="confluence-anchor-link" id="_Ref427743551"></span></span><strong><em>CAIU</em></strong> <strong><em>Proxy Cache Transaction Control Register (CAIUPCTCR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x004<br/> <span style="text-decoration: underline;">Description</span><br/> The CAIUPCTCR controls the proxy cache transaction behavior in a coherent agent interface unit. This register consists of the following bits and fields:</p><ul><li>Proxy Cache Lookup Enable – This bit enables proxy cache lookups on native agent coherent transactions.</li><li>Proxy Cache Fill Enable – This bit enables proxy cache fills for native agent coherent transactions.</li><li>Allocate on Partial-Cacheline Read Miss – This bit enables allocation on partial-cacheline read accesses that miss in the proxy cache.</li><li>Allocate on Partial-Cacheline Write Miss – This bit enables allocation on partial-cacheline write accesses that miss in the proxy cache.</li><li>Allocate on Full-Cacheline Read Miss – This bit enables allocation on full-cacheline read accesses that miss in the proxy cache.</li><li>Allocate on Full-Cacheline Write Miss – This bit enables allocation on full-cacheline write accesses that miss in the proxy cache.</li></ul><p>See the <em>ACE-Lite AIU Architecture Specification</em> for more details.<br/> If the CAIU is configured <em>without</em> a proxy cache, all bits and fields in this register are RAZ/WI.<br/> <span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427743607"><span class="confluence-anchor-link" id="_Ref427743607"></span></span><strong><em>CAIU Proxy Cache Transaction Activity Register (CAIUPCTAR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x005<br/> <span style="text-decoration: underline;">Description</span><br/> The CAIUPCTAR reports proxy cache transaction activity in a coherent agent interface unit. This register consists of the following bits and fields:</p><ul><li>Proxy Cache Eviction Active – This bit is set when the unit is performing any proxy cache eviction activity and is clear otherwise.</li><li>Proxy Cache Fill Active – This bit is set when the unit is performing any proxy cache fill activity and is clear otherwise.</li></ul><p>See the <em>ACE-Lite AIU Architecture Specification</em> for more details.<br/> If the CAIU is configured <em>without</em> a proxy cache, all bits and fields in this register are RAZ/WI.</p><h3 id="ConcertoSystemArchitectureSpecification-_Ref427832977_Toc447207716CAIUProxyCacheMaintenanceRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427832977"><span class="confluence-anchor-link" id="_Ref427832977"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207716"><span class="confluence-anchor-link" id="_Toc447207716"></span></span>CAIU Proxy Cache Maintenance Registers</h3><p>This section describes the CAIU proxy cache maintenance control and status registers.<br/> <strong><em>CAIU Proxy Cache Maintenance Control Register (CAIUPCMCR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x020<br/> <span style="text-decoration: underline;">Description</span><br/> The CAIUPCMCR controls proxy cache maintenance operations in a coherent agent interface unit. This register consists of the following bits and fields:</p><ul><li>Proxy Cache Maintenance Operation – This field indicates the proxy cache maintenance operation performed.</li><li>Proxy Cache Array Identifier – This bit indicates the array on which the proxy cache maintenance operation is performed.</li><li>Proxy Cache Security Attribute – This bit indicates the security attribute of the address on which the proxy cache maintenance operation is performed. If the proxy cache maintenance operation does not operate on an address or if the system is not configured with the security attribute, the value of this bit should be zero.</li></ul><p>On a write to this register, the unit performs the proxy cache maintenance operation specified by the value written to the Proxy Cache Maintenance Operation field on the array specified by the value written to the Proxy Cache Array Identifier bit.<br/> See Section 9.1.1 for more details.<br/> If the CAIU is configured <em>without</em> a proxy cache, all bits and fields in this register are RAZ/WI.<br/> <strong><em>CAIU Proxy Cache</em></strong> <strong><em>Maintenance</em></strong> <strong><em>Activity Register (CAIUPCMAR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x021<br/> <span style="text-decoration: underline;">Description</span><br/> The CAIUPCMAR reports proxy cache maintenance operation activity in a coherent agent interface unit. This register consists of the following bits and fields:</p><ul><li>Proxy Cache Maintenance Operation Active – This bit is set when the unit is performing any proxy cache maintenance operation activity and is clear otherwise.</li></ul><p>Software may poll the Proxy Cache Maintenance Operation Active bit to determine when the maintenance operation has completed.<br/> See Section 9.1.1 for more details.<br/> If the CAIU is configured <em>without</em> a proxy cache, all bits and fields in this register are RAZ/WI.<br/> <strong><em>CAIU Proxy Cache Maintenance Location Registers 0-1 (CAIUPCMLR0-1)</em></strong><br/> <span style="text-decoration: underline;">Register Numbers</span><br/> 0x022-0x023<br/> <span style="text-decoration: underline;">Description</span><br/> CAIUPCMLR0-1 indicate the location in a proxy cache or the address on which the proxy cache maintenance operation is performed in a coherent agent interface unit. The CAIUPCMLR0 consists of the following bits and fields:</p><ul><li>Proxy Cache Maintenance Set – The field indicates the entry or the set on which the maintenance operation is performed.</li><li>Proxy Cache Maintenance Way – This field indicates the way on which the maintenance operation is performed.</li><li>Proxy Cache Maintenance Word – This field indicates the data word on which the maintenance operation is performed.</li></ul><p>If required, the CAIUPCMLR1 consists of the following bits and fields:</p><ul><li>Proxy Cache Maintenance Address – This field indicates the high-order address bits of the address on which the maintenance operation is performed.</li></ul><p>Otherwise, all bits in the CAIUPCMLR1 are reserved and are RAZ/WI.<br/> For certain maintenance operations, the CAIUPCMLR1 contains the high-order address bits, and the CAIUPCMLR0 contains the low-order address bits for the offset into cache coherence window.<br/> See Section 9.1.1 for more details.<br/> If the CAIU is configured <em>without</em> a proxy cache, all bits and fields in this register are RAZ/WI.<br/> <strong><em>CAIU Proxy Cache Maintenance Data Register (CAIUPCMDR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x024<br/> <span style="text-decoration: underline;">Description</span><br/> The CAIUPCMDR contains the data read from the proxy cache in response to a proxy cache maintenance read operation or the data to be written into the proxy cache on a proxy cache maintenance write operation in a coherent agent interface unit. This register consists of the following bits and fields:</p><ul><li>Proxy Cache Maintenance Data – This field contains the data resulting from a maintenance read operation or the data operand for a maintenance write operation.</li></ul><p>See <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166954/Concerto+System+Architecture+Specification">Section 9.1.1</a> for more details.<br/> If the CAIU is configured <em>without</em> a proxy cache, all bits and fields in this register are RAZ/WI.</p><h3 id="ConcertoSystemArchitectureSpecification-_Ref427750860_Toc447207717CAIUCorrectableErrorRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427750860"><span class="confluence-anchor-link" id="_Ref427750860"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207717"><span class="confluence-anchor-link" id="_Toc447207717"></span></span>CAIU Correctable Error Registers</h3><p>This section describes the CAIU correctable error control and status registers.<br/> <span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427743731"><span class="confluence-anchor-link" id="_Ref427743731"></span></span><strong><em>CAIU Correctable Error Control Register (CAIUCECR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x040<br/> <span style="text-decoration: underline;">Description</span><br/> The CAIUCECR controls the detection and signaling of correctable errors in a coherent agent interface unit. This register consists of the following bits and fields:</p><ul><li>Correctable Error Detection Enable – If this bit is set, the correctable error detection and logging logic is enabled; otherwise, the correctable error detection and logging logic is disabled.</li><li>Correctable Error Interrupt Enable – If this bit is set, the correctable error interrupt signal is asserted when the appropriate conditions are met; otherwise, the correctable error interrupt signal is not asserted.</li><li>Correctable Error Interrupt Threshold – This field determines the number of correctable errors that must be detected before the correctable error interrupt signal is asserted.</li></ul><p>See Section 8.7 for more details.<br/> If all resources and arrays in the CAIU are configured <em>without</em> error correction, all bits and fields in this register are RAZ/WI.<br/> <span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427743889"><span class="confluence-anchor-link" id="_Ref427743889"></span></span><strong><em>CAIU Correctable Error Status Register (CAIUCESR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x041<br/> <span style="text-decoration: underline;">Description</span><br/> The CAIUCESR logs information about correctable errors in a coherent agent interface unit. This register consists of the following bits and fields:</p><ul><li>Correctable Error Valid – If this bit is set, the CAIUCESR and CAIUCELR0-1 have logged information about a correctable error; otherwise, certain bits and fields in the CAIUCESR and CAIUCELR0-1 are UNDEFINED. Writing a one to the Correctable Error Valid bit clears the Correctable Error Valid bit.</li><li>Correctable Error Count Overflow – This bit indicates that the number of correctable errors detected by the unit overflowed the Correctable Error Count field.</li><li>Correctable Error Count – This field indicates the number of correctable errors detected by the unit. The field stops incrementing if the Correctable Error Count Overflow bit is set.</li><li>Correctable Error Type – This field indicates the logged error type if the Correctable Error Valid bit is set; otherwise, the field is UNDEFINED.</li><li>Correctable Error Information – This field indicates additional information about logged error if the Correctable Error Valid bit is set; otherwise, the field is UNDEFINED.</li></ul><p>See Section 8.7 for more details.<br/> <span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427743890"><span class="confluence-anchor-link" id="_Ref427743890"></span></span>If all resources and arrays in the CAIU are configured <em>without</em> error correction, all bits and fields in this register are RAZ/WI.<br/> <strong><em>CAIU Correctable Error Location Registers 0-1 (CAIUCELR0-1)</em></strong><br/> <span style="text-decoration: underline;">Register Numbers</span><br/> 0x042-0x043<br/> <span style="text-decoration: underline;">Description</span><br/> CAIUCELR0-1 log information about correctable errors in a coherent agent interface unit. The CAIUCELR0 consists of the following bits and fields:</p><ul><li>Correctable Error Entry (or Set) – If the Correctable Error Valid bit is set, this field indicates the entry or the set in which the logged error was detected; otherwise, the field is UNDEFINED.</li><li>Correctable Error Way – If the Correctable Error Valid bit is set, this field indicates the way in which the logged error was detected; otherwise, the field is UNDEFINED.</li><li>Correctable Error Word – If the Correctable Error Valid bit is set, this field indicates the data word in which the logged error was detected; otherwise, the field is UNDEFINED.</li></ul><p>If required, the CAIUCELR1 consists of the following bits and fields:</p><ul><li>Correctable Error Address – If the Correctable Error Valid bit is set, this field indicates the high-order address bits of the transaction that encountered the error; otherwise, the field is UNDEFINED.</li></ul><p>Otherwise, all bits in the CAIUCELR1 are reserved and are RAZ/WI.<br/> For certain errors, the CAIUCELR1 contains the high-order address bits, and the CAIUCELR0 contains the low-order address bits for the offset into cache coherence window.<br/> See Section 8.7 for more details.<br/> <span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427743907"><span class="confluence-anchor-link" id="_Ref427743907"></span></span>If all resources and arrays in the CAIU are configured <em>without</em> error correction, all bits and fields in this register are RAZ/WI.<br/> <strong><em>CAIU Correctable Error Status Alias Register (CAIUCESAR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x049<br/> <span style="text-decoration: underline;">Description</span><br/> The CAIUCESAR allows write access to the CAIUCESR in a coherent agent interface unit for diagnostic purposes. Both the CAIUCESR and CAIUCESAR provide access to the same state bits and differ only in the types of access each register provides.<br/> See Section 8.7 for more details.<br/> If all resources and arrays in the CAIU are configured <em>without</em> error correction, all bits and fields in this register are RAZ/WI.</p><h3 id="ConcertoSystemArchitectureSpecification-_Ref427750931_Toc447207718CAIUUncorrectableErrorRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427750931"><span class="confluence-anchor-link" id="_Ref427750931"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207718"><span class="confluence-anchor-link" id="_Toc447207718"></span></span>CAIU Uncorrectable Error Registers</h3><p>This section describes the CAIU uncorrectable error control and status registers.<br/> <span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427745126"><span class="confluence-anchor-link" id="_Ref427745126"></span></span><strong><em>CAIU Uncorrectable Error Control Register (CAIUUECR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x050<br/> <span style="text-decoration: underline;">Description</span><br/> The CAIUUECR controls the detection and signaling of uncorrectable errors in a coherent agent interface unit. This register consists of the following bits and fields:</p><ul><li>Uncorrectable Error Detection Enable – If this bit is set, the uncorrectable error detection and logging logic is enabled; otherwise, the uncorrectable error detection and logging logic is disabled.</li><li>Uncorrectable Error Interrupt Enable – If this bit is set, the uncorrectable error interrupt signal is asserted when the appropriate conditions are met; otherwise, the uncorrectable error interrupt signal is not asserted.</li><li>Uncorrectable Error Interrupt Threshold – This field determines the number of uncorrectable errors that must be detected before the uncorrectable error interrupt signal is asserted. This field is read-only and is set to zero.</li></ul><p>See Section 8.7 for more details.<br/> If all resources and arrays in the CAIU are configured <em>without</em> error detection, all bits and fields in this register are RAZ/WI.<br/> <strong><em>CAIU Uncorrectable Error Status Register (CAIUUESR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x051<br/> <span style="text-decoration: underline;">Description</span><br/> The CAIUUESR logs information about uncorrectable errors in a coherent agent interface unit. This register consists of the following bits and fields:</p><ul><li>Uncorrectable Error Valid – If this bit is set, the CAIUCESR and CAIUCELR0-1 have logged information about an uncorrectable error; otherwise, certain bits and fields in the CAIUCESR and CAIUCELR0-1 are UNDEFINED. Writing a one to the Uncorrectable Error Valid bit clears the Uncorrectable Error Valid bit.</li><li>Uncorrectable Error Count Overflow – This bit indicates that the number of uncorrectable errors detected by the unit overflowed the Uncorrectable Error Count field.</li><li>Uncorrectable Error Count – This field indicates the number of uncorrectable errors detected by the unit. The field stops incrementing if the Uncorrectable Error Count Overflow bit is set.</li><li>Uncorrectable Error Type – This field indicates the logged error type if the Uncorrectable Error Valid bit is set; otherwise, the field is UNDEFINED.</li><li>Uncorrectable Error Information – This field indicates additional information about logged error if the Uncorrectable Error Valid bit is set; otherwise, the field is UNDEFINED.</li></ul><p>See Section 8.7 for more details.<br/> If all resources and arrays in the CAIU are configured <em>without</em> error detection, all bits and fields in this register are RAZ/WI.<br/> <strong><em>CAIU Uncorrectable Error Location Registers 0-1 (CAIUUELR0-1)</em></strong><br/> <span style="text-decoration: underline;">Register Numbers</span><br/> 0x052-0x053<br/> <span style="text-decoration: underline;">Description</span><br/> CAIUUELR0-1 log information about uncorrectable errors in a coherent agent interface unit. The CAIUUELR0 consists of the following bits and fields:</p><ul><li>Uncorrectable Error Entry (or Set) – If the Uncorrectable Error Valid bit is set, this field indicates the entry or the set in which the logged error was detected; otherwise, the field is UNDEFINED.</li><li>Uncorrectable Error Way – If the Uncorrectable Error Valid bit is set, this field indicates the way in which the logged error was detected; otherwise, the field is UNDEFINED.</li><li>Uncorrectable Error Word – If the Uncorrectable Error Valid bit is set, this field indicates the data word in which the logged error was detected; otherwise, the field is UNDEFINED.</li></ul><p>If required, the CAIUUELR1 consists of the following bits and fields:</p><ul><li>Uncorrectable Error Address – If the Uncorrectable Error Valid bit is set, this field indicates the high-order address bits of the transaction that encountered the error; otherwise, the field is UNDEFINED.</li></ul><p>Otherwise, all bits in the CAIUUELR1 are reserved and are RAZ/WI.<br/> For certain errors, the CAIUUELR1 contains the high-order address bits, and the CAIUUELR0 contains the low-order address bits for the offset into cache coherence window.<br/> See Section 8.7 for more details.<br/> If all resources and arrays in the CAIU are configured <em>without</em> error detection, all bits and fields in this register are RAZ/WI.<br/> <strong><em>CAIU Uncorrectable Error Status Alias Register (CAIUUESAR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x059<br/> <span style="text-decoration: underline;">Description</span><br/> The CAIUUESAR allows write access to the CAIUUESR in a coherent agent interface unit for diagnostic purposes. Both the CAIUUESR and CAIUUESAR provide access to the same state bits and differ only the types of access each register provides.<br/> See Section 8.7 for more details.<br/> If all resources and arrays in the CAIU are configured <em>without</em> error detection, all bits and fields in this register are RAZ/WI.</p><h3 id="ConcertoSystemArchitectureSpecification-_Ref431980184_Toc447207719CAIUIdentificationRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref431980184"><span class="confluence-anchor-link" id="_Ref431980184"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207719"><span class="confluence-anchor-link" id="_Toc447207719"></span></span>CAIU Identification Registers</h3><p>This section describes the CAIU identification registers which provide information about the unit.<br/> <strong><em>CAIU Proxy Cache Identification Register (CAIUPCIDR)

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2138" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2138?src=confmacro" class="jira-issue-key">CONC-2138</a>
                            </span>
</em></strong><br/> <span style="text-decoration: underline;">Register Numbers</span><br/> 0x3FE<br/> <span style="text-decoration: underline;">Description</span><br/> The CAIUPCIDR reports the configuration of a proxy cache in a coherent agent interface unit. This register consists of the following bits and fields:</p><ul><li>Number of Proxy Cache Sets – This field indicates the number of sets in the proxy cache minus one <em>in this CAIU</em>. To determine the total number of sets in the proxy cache, this value must be multiplied by the number of CAIUs that implement the proxy cache. For an unimplemented proxy cache, the value of this field is zero.</li><li>Number of Proxy Cache Ways – This field indicates the number of ways (i.e. the associativity) in the proxy cache minus one. For an unimplemented proxy cache, the value of this field is zero.</li><li>Proxy Cache Type – The field indicates the type of proxy cache. The type of the proxy cache is given as follows (all other values are RESERVED):</li><li>000 – Unimplemented proxy cache</li><li>001 – Proxy cache with MSI cache model</li></ul><p>If this register reads as all zeros, the corresponding proxy cache is not implemented.<br/> <strong><em>CAIU Identification Register (CAIUIDR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x3FF<br/> <span style="text-decoration: underline;">Description</span><br/> The CAIUIDR identifies certain features and configuration information about a coherent agent interface unit. This register consists of the following bits and fields:

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2139" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2139?src=confmacro" class="jira-issue-key">CONC-2139</a>
                            </span>
</p><ul><li>Implementation Version – This field indicates the implementation version of the CAIU. A value of zero indicates the CAIU is <em>not</em> implemented, and all other values are RESERVED:</li><li>0x00 – Unimplemented CAIU</li><li>0x01 – Implemented CAIU</li><li>Coherent Agent Interface Identifier – This field indicates the coherent agent interface with which the CAIU is associated. If the CAIU is <em>not</em> implemented, this field is RAZ/WI.</li><li>Caching Agent – This bit indicates whether the coherent agent interface is represented as a caching agent in a snoop filter. If the CAIU is <em>not</em> implemented, this bit is RAZ/WI.</li><li>Type – The field indicates the type of CAIU. If the CAIU is <em>not</em> implemented, this field is RAZ/WI. The type of CAIU is given as follows (all other values are RESERVED):</li><li>0000 – ACE coherent agent interface with DVM support</li><li>0001 – ACE-Lite coherent agent interface with DVM support</li><li>0010 – ACE coherent agent interface without DVM support</li><li>0011 – ACE-Lite coherent agent interface without DVM support</li><li>Snoop Filter Identifier – This field indicates the snoop filter with which the coherent agent interface is associated. If the CAIU is <em>not</em> implemented, this field is RAZ/WI.</li><li>Proxy Cache – This bit indicates whether the CAIU implements a proxy cache. If the CAIU is <em>not</em> implemented, this bit is RAZ/WI.</li></ul><p>The UnitID for this CMIU may be calculated as follows:</p><ul><li>UnitID = RegPageNum</li></ul><p>Essentially, the UnitID equals the register page number.<br/> <strong><em>Note:</em></strong> Implementation Version captures various microarchitectural features and will be changed as features are added.</p><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207720Non-coherentBridgeUnitRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207720"><span class="confluence-anchor-link" id="_Toc447207720"></span></span>Non-coherent Bridge Unit Registers</h2><p>Non-coherent bridge unit registers are implemented by a Bridge AIU and are located in register pages 0x60 through 0x7F.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207721NCBUTransactionRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207721"><span class="confluence-anchor-link" id="_Toc447207721"></span></span>NCBU Transaction Registers</h3><p>This section describes the NCBU transaction control and activity registers.<br/> <strong><em>NCBU Transaction Control Register (NCBUTCR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x000<br/> <span style="text-decoration: underline;">Description</span><br/> The NCBUTCR behaves in the same manner as the CAIUTCR described in Section 11.2.1.<br/> <strong><em>NCBU Transaction Activity Register (NCBUTAR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x001<br/> <span style="text-decoration: underline;">Description</span><br/> The NCBUTAR behaves in the same manner as the CAIUTAR described in Section 11.2.1.</p><h3 id="ConcertoSystemArchitectureSpecification-_Ref427751612_Toc447207722NCBUProxyCacheTransactionRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427751612"><span class="confluence-anchor-link" id="_Ref427751612"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207722"><span class="confluence-anchor-link" id="_Toc447207722"></span></span>NCBU Proxy Cache Transaction Registers</h3><p>This section describes the NCBU proxy cache transaction control and activity registers.<br/> <span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427658589"><span class="confluence-anchor-link" id="_Ref427658589"></span></span><strong><em>NCBU Proxy Cache Transaction Control Register (NCBUPCTCR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x004<br/> <span style="text-decoration: underline;">Description</span><br/> The NCBUPCTCR behaves in the same manner as the CAIUPCTCR described in Section 11.2.2.<br/> <strong><em>NCBU Proxy Cache Transaction Activity Register (NCBUPCTAR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x005<br/> <span style="text-decoration: underline;">Description</span><br/> The NCBUPCTAR behaves in the same manner as the CAIUPCTAR described in Section 11.2.2.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207723NCBUProxyCacheMaintenanceRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207723"><span class="confluence-anchor-link" id="_Toc447207723"></span></span>NCBU Proxy Cache Maintenance Registers</h3><p>This section describes the NCBU proxy cache maintenance control and status registers.<br/> <strong><em>NCBU Proxy Cache Maintenance Control Register (NCBUPCMCR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x020<br/> <span style="text-decoration: underline;">Description</span><br/> The NCBUPCMCR behaves in the same manner as the CAIUPCMCR described in Section 11.2.3.<br/> <strong><em>NCBU Proxy Cache Maintenance Activity Register (NCBUPCMAR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x021<br/> <span style="text-decoration: underline;">Description</span><br/> The NCBUPCMAR behaves in the same manner as the CAIUPCMAR described in Section 11.2.3.<br/> <strong><em>NCBU Proxy Cache Maintenance Location Registers 0-1 (NCBUPCMLR0-1)</em></strong><br/> <span style="text-decoration: underline;">Register Numbers</span><br/> 0x022-0x023<br/> <span style="text-decoration: underline;">Description</span><br/> NCBUPCMLR0-1 behave in the same manner as CAIUPCMLR0-1 described in Section 11.2.3.<br/> <strong><em>NCBU Proxy Cache Maintenance Data Register (NCBUPCMDR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x024<br/> <span style="text-decoration: underline;">Description</span><br/> The NCBUPCMDR behaves in the same manner as the CAIUPCMDR described in Section 11.2.3.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207724NCBUCorrectableErrorRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207724"><span class="confluence-anchor-link" id="_Toc447207724"></span></span>NCBU Correctable Error Registers</h3><p>This section describes the NCBU correctable error control and status registers.<br/> <strong><em>NCBU Correctable Error Control Register (NCBUCECR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x040<br/> <span style="text-decoration: underline;">Description</span><br/> The NCBUCECR behaves in the same manner as the CAIUCECR described in Section 11.2.4.<br/> <strong><em>NCBU Correctable Error Status Register (NCBUCESR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x041<br/> <span style="text-decoration: underline;">Description</span><br/> The NCBUCESR behaves in the same manner as the CAIUCESR described in Section 11.2.4.<br/> <strong><em>NCBU Correctable Error Location Registers 0-1 (NCBUCELR0-1)</em></strong><br/> <span style="text-decoration: underline;">Register Numbers</span><br/> 0x042-0x43<br/> <span style="text-decoration: underline;">Description</span><br/> NCBUCELR0-1 behave in the same manner as CAIUCELR0-1 described in Section 11.2.4.<br/> <strong><em>NCBU Correctable Error Status Alias Register (NCBUCESAR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x049<br/> <span style="text-decoration: underline;">Description</span><br/> The NCBUCESAR behaves in the same manner as the CAIUCESAR described in Section 11.2.4.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207725NCBUUncorrectableErrorRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207725"><span class="confluence-anchor-link" id="_Toc447207725"></span></span>NCBU Uncorrectable Error Registers</h3><p>This section describes the NCBU uncorrectable error control and status registers.<br/> <strong><em>NCBU Uncorrectable Error Control Register (NCBUUECR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x050<br/> <span style="text-decoration: underline;">Description</span><br/> The NCBUUECR behaves in the same manner as the CAIUUECR described in Section 11.2.5.<br/> <strong><em>NCBU Uncorrectable Error Status Register (NCBUUESR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x051<br/> <span style="text-decoration: underline;">Description</span><br/> The NCBUUESR behaves in the same manner as the CAIUUESR described in Section 11.2.5.<br/> <strong><em>NCBU Uncorrectable Error Location Registers 0-1 (NCBUUELR0-1)</em></strong><br/> <span style="text-decoration: underline;">Register Numbers</span><br/> 0x052-0x053<br/> <span style="text-decoration: underline;">Description</span><br/> NCBUUELR0-1 behave in the same manner as CAIUUELR0-1 described in Section 11.2.5.<br/> <strong><em>NCBU Uncorrectable Error Status Alias Register (NCBUUESAR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x059<br/> <span style="text-decoration: underline;">Description</span><br/> The NCBUUESAR behaves in the same manner as the CAIUUESAR described in Section 11.2.5.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207726NCBUIdentificationRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207726"><span class="confluence-anchor-link" id="_Toc447207726"></span></span>NCBU Identification Registers</h3><p>This section describes the NCBU identification registers which provide information about the unit.<br/> <strong><em>NCBU Proxy Cache Identification Register (NCBUPCIDR)</em></strong><br/> <span style="text-decoration: underline;">Register Numbers</span><br/> 0x3FE<br/> <span style="text-decoration: underline;">Description</span><br/> The NCBUPCIDR behaves in the same manner as the CAIUPCIDR described in Section 11.2.6.<br/> <strong><em>NCBU Identification Register (NCBUIDR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x3FF<br/> <span style="text-decoration: underline;">Description</span><br/> The NCBUIDR identifies certain features and configuration information about a non-coherent bridge unit. This register consists of the following bits and fields:

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2140" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2140?src=confmacro" class="jira-issue-key">CONC-2140</a>
                            </span>
</p><ul><li>Implementation Version – This field indicates the implementation version of the NCBU. A value of zero indicates the NCBU is <em>not</em> implemented, and all other values are RESERVED:</li><li>0x00 – Unimplemented NCBU</li><li>0x01 – Implemented NCBU</li><li>Non-coherent Bridge Identifier – This field indicates the non-coherent bridge with which the NCBU is associated. If the NCBU is <em>not</em> implemented, this field is RAZ/WI.</li><li>Caching Agent – This bit indicates whether the non-coherent bridge is represented as a caching agent in a snoop filter. If the NCBU is <em>not</em> implemented, this bit is RAZ/WI.</li><li>Type – The field indicates the type of NCBU. If the NCBU is <em>not</em> implemented, this field is RAZ/WI. The type of NCBU is given as follows (all other values are RESERVED):</li><li>0011 – Non-coherent bridge</li><li>Snoop Filter Identifier – This field indicates the snoop filter with which the non-coherent bridge is associated. If the NCBU is <em>not</em> implemented, this field is RAZ/WI.</li><li>Proxy Cache – This bit indicates whether the NCBU implements a proxy cache. If the NCBU is <em>not</em> implemented, this bit is RAZ/WI.</li></ul><p>The UnitID for this NCBU may be calculated as follows:</p><ul><li>UnitID = (RegPageNum - 0x60) + <em>A</em></li></ul><p>In this relationship, <em>A</em> equals the number of CAIUs.</p><h2 id="ConcertoSystemArchitectureSpecification-_Ref426063331_Toc447207727DirectoryUnitRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref426063331"><span class="confluence-anchor-link" id="_Ref426063331"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207727"><span class="confluence-anchor-link" id="_Toc447207727"></span></span>Directory Unit Registers</h2><p>Directory unit registers (DIRU) are implemented by a DCE and are located in register pages 0x80 through 0x9F.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207728DIRUTransactionRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207728"><span class="confluence-anchor-link" id="_Toc447207728"></span></span>DIRU Transaction Registers</h3><p>This section describes the DIRU transaction control and activity registers.<br/> <strong><em>DIRU Transaction Control Register (DIRUTCR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x000<br/> <span style="text-decoration: underline;">Description</span><br/> All bits in the DIRUTCR are reserved and are RAZ/WI.<br/> <strong><em>DIRU Transaction Activity Register (DIRUTAR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x001<br/> <span style="text-decoration: underline;">Description</span><br/> The DIRUTAR reports whether certain protocol transactions are active in a directory unit. This register consists of the following bits and fields:</p><ul><li>Transaction Active – This bit is set when the unit is performing any activity related to transactions and is clear otherwise.</li></ul><p>See Section 7.2.2 for more details.</p><h3 id="ConcertoSystemArchitectureSpecification-_Ref427926123_Toc447207729DIRUSnoopFilterControlRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427926123"><span class="confluence-anchor-link" id="_Ref427926123"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207729"><span class="confluence-anchor-link" id="_Toc447207729"></span></span>DIRU Snoop Filter Control Registers</h3><p>This section describes the DIRU snoop filter enable register.<br/> <span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427622206"><span class="confluence-anchor-link" id="_Ref427622206"></span></span><strong><em>DIRU Snoop Filter Enable Register (DIRUSFER)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x004<br/> <span style="text-decoration: underline;">Description</span><br/> The DIRUSFER enables snoop filtering for a given snoop filter in a directory unit. This register consists of the following bits and fields:</p><ul><li>Snoop Filter Enable – This field consists of a bit per snoop filter. If a bit is set, snoop filtering is enabled for the corresponding snoop filter; otherwise, snoop filtering is disabled for that snoop filter. Bits that correspond to null filters or to snoop filters that are <em>not</em> implemented are RAZ/WI.</li></ul><p>See Section 7.2.2 for more details.<br/> <span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref427926131"><span class="confluence-anchor-link" id="_Ref427926131"></span></span><strong><em>V1.0 Erratum:</em></strong> Writes to bits that correspond to null filters are <em>not</em> ignored, and those bits will retain the last values written. Software should write zeros to those bits to ensure future compatibility.</p><h3 id="ConcertoSystemArchitectureSpecification-_Ref436646657_Ref436646670_Toc447207730DIRUCachingAgentSnoopRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref436646657"><span class="confluence-anchor-link" id="_Ref436646657"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref436646670"><span class="confluence-anchor-link" id="_Ref436646670"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207730"><span class="confluence-anchor-link" id="_Toc447207730"></span></span>DIRU Caching Agent Snoop Registers</h3><p>This section describes the DIRU caching agent snoop enable and snoop activity registers.<br/> <strong><em>DIRU Caching Agent Snoop Enable Register 0-3 (DIRUCASER0-3)</em></strong><br/> <span style="text-decoration: underline;">Register Numbers</span><br/> 0x010-0x013<br/> <span style="text-decoration: underline;">Description</span><br/> DIRUCASER0-3 enable snoop messages to the specified CAIU associated with a caching agent. This register consists of the following bits and fields:</p><ul><li>Caching Agent Snoop Enable – This field consists of a bit per CAIU or NCBU. If a bit is set, snoop messages are enabled for that CAIU or NCBU; otherwise, snoop messages are disabled. Bits that correspond to CAIUs and NCBUs that are <em>not</em> implemented are RAZ/WI.</li></ul><p>Each register contains the snoop enable bits for the following units:</p><ul><li>DIRUCASER0: CAIU 31 – CAIU 0</li><li>DIRUCASER1: CAIU 63 – CAIU 32</li><li>DIRUCASER2: CAIU 95 – CAIU 64</li><li>DIRUCASER3: NCBU 31 – NCBU 0</li></ul><p>See Section 7.2.2 for more details.<br/> <strong><em>DIRU Caching Agent Snoop Activity Register 0-3 (DIRUCASAR0-3)</em></strong><br/> <span style="text-decoration: underline;">Register Numbers</span><br/> 0x014-0x017<br/> <span style="text-decoration: underline;">Description</span><br/> DIRUCASAR0-3 report whether snoop messages are active to the specified CAIU associated with a caching agent. This register consists of the following bits and fields:</p><ul><li>Caching Agent Snoop Active – This field consists of a bit per CAIU or NCBU. If a bit is set, snoop messages are active for that CAIU or NCBU; otherwise, snoop messages are not active. Bits that correspond to CAIUs and NCBUs that are <em>not</em> implemented are RAZ/WI.</li></ul><p>Each register contains the snoop active bits for the following units:</p><ul><li>DIRUCASAR0: CAIU 31 – CAIU 0</li><li>DIRUCASAR1: CAIU 63 – CAIU 32</li><li>DIRUCASAR2: CAIU 95 – CAIU 64</li><li>DIRUCASAR3: NCBU 31 – NCBU 0</li></ul><p>See Section 7.2.2 for more details.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207731DIRUHintControlRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207731"><span class="confluence-anchor-link" id="_Toc447207731"></span></span>DIRU Hint Control Registers</h3><p>This section describes the DIRU hint enable register.<br/> <strong><em>DIRU Memory Region Hint Enable Register (DIRUMRHER)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x01C<br/> <span style="text-decoration: underline;">Description</span><br/> The DIRUMRHER enables hint messages to the specified CMIU associated with a coherent-capable memory region. This register consists of the following bits and fields:</p><ul><li>Memory Region Hint Enable – This field consists of a bit per CMIU. If a bit is set, hint messages are enabled for that CMIU; otherwise, hint messages are disabled. Bits that correspond to CMIUs that are <em>not</em> implemented or that are configured <em>without</em> hint resources are RAZ/WI.</li></ul><p>See the <em>DCE Unit Architecture Specification</em> for more details.<br/> <strong><em>V1.0 Erratum:</em></strong> Writes to bits that correspond to CMIUs configured <em>without</em> hint resources are <em>not</em> ignored, and those bits will retain the last values written. Software should write zeros to those bits to ensure future compatibility.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207732DIRUSnoopFilterMaintenanceRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207732"><span class="confluence-anchor-link" id="_Toc447207732"></span></span>DIRU Snoop Filter Maintenance Registers</h3><p>This section describes the DIRU snoop filter maintenance control and status registers.<br/> <strong><em>DIRU</em></strong> <strong><em>Snoop Filter Maintenance Control Register (DIRUSFMCR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x020<br/> <span style="text-decoration: underline;">Description</span><br/> The DIRUSFMCR controls snoop filter maintenance operations in a directory unit. This register consists of the following bits and fields:</p><ul><li>Snoop Filter Maintenance Operation – This field indicates the snoop filter maintenance operation performed.</li><li>Snoop Filter Identifier – This field indicates the snoop filter on which the snoop filter maintenance operation is performed.</li><li>Snoop Filter Security Attribute – This bit indicates the security attribute of the address on which the snoop filter maintenance operation is performed. If the snoop filter maintenance operation does not operate on an address or if the system is not configured with the security attribute, the value of this bit should be zero.</li></ul><p>On a write to this register, the unit performs the snoop filter maintenance operation specified by the value written to the Snoop Filter Maintenance Operation field on the snoop filter specified by the value written to the Snoop Filter Identifier bit.<br/> See Section 9.1.2 for more details.<br/> If the DIRU is configured with null filters <em>only</em>, all bits and fields in this register are RAZ/WI.<br/> <strong><em>DIRU</em></strong> <strong><em>Snoop Filter Maintenance Activity Register (DIRUSFMAR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x021<br/> <span style="text-decoration: underline;">Description</span><br/> The DIRUSFMAR reports snoop filter maintenance operation activity in a directory unit. This register consists of the following bits and fields:</p><ul><li>Snoop Filter Maintenance Operation Active – This bit is set when the unit is performing any snoop filter maintenance operation activity and is clear otherwise.</li></ul><p>Software may poll the Snoop Filter Maintenance Operation Active bit to determine when the maintenance operation has completed.<br/> See Section 9.1.2 for more details.<br/> If the DIRU is configured with null filters <em>only</em>, all bits and fields in this register are RAZ/WI.<br/> <strong><em>DIRU</em></strong> <strong><em>Snoop Filter Maintenance Location Registers 0-1 (DIRUSFMLR0-1)</em></strong><br/> <span style="text-decoration: underline;">Register Numbers</span><br/> 0x022-0x023<br/> <span style="text-decoration: underline;">Description</span><br/> DIRUSFMLR0-1 indicate the location in a snoop filter or the address on which the snoop filter maintenance operation is performed in a directory unit. The DIRUSFMLR0 consists of the following bits and fields:</p><ul><li>Snoop Filter Maintenance Set – The field indicates the set on which the maintenance operation is performed.</li><li>Snoop Filter Maintenance Way – This field indicates the way on which the maintenance operation is performed.</li><li>Snoop Filter Maintenance Word – This field indicates the data word on which the maintenance operation is performed.</li></ul><p>If required, the DIRUSFMLR1 consists of the following bits and fields:</p><ul><li>Snoop Filter Maintenance Address – This field indicates the high-order address bits of the address on which the maintenance operation is performed.</li></ul><p>Otherwise, all bits in the DIRUSFMLR1 are reserved and are RAZ/WI.<br/> For certain maintenance operations, the DIRUSFMLR1 contains the high-order address bits, and the DIRUSFMLR0 contains the low-order address bits for the offset into cache coherence window.<br/> See Section 9.1.2 for more details.<br/> If the DIRU is configured with null filters <em>only</em>, all bits and fields in this register are RAZ/WI.<br/> <strong><em>DIRU</em></strong> <strong><em>Snoop Filter Maintenance Data Register (DIRUSFMDR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x024<br/> <span style="text-decoration: underline;">Description</span><br/> The DIRUSFMDR contains the data read from the snoop filter in response to a snoop filter maintenance read operation or the data to be written into the snoop filter on a snoop filter maintenance write operation in a coherent agent interface unit. This register consists of the following bits and fields:</p><ul><li>Snoop Filter Maintenance Data – This field contains the data resulting from a maintenance read operation or the data operand for a maintenance write operation.</li></ul><p>See Section 9.1.2 for more details.<br/> If the DIRU is configured with null filters <em>only</em>, all bits and fields in this register are RAZ/WI.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207733DIRUCorrectableErrorRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207733"><span class="confluence-anchor-link" id="_Toc447207733"></span></span>DIRU Correctable Error Registers</h3><p>This section describes the DIRU correctable error control and status registers.<br/> <strong><em>DIRU Correctable Error Control Register (DIRUCECR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x040<br/> <span style="text-decoration: underline;">Description</span><br/> The DIRUCECR behaves in the same manner as the CAIUCECR described in Section 11.2.4.<br/> <strong><em>DIRU Correctable Error Status Register (DIRUCESR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x041<br/> <span style="text-decoration: underline;">Description</span><br/> The DIRUCESR behaves in the same manner as the CAIUCESR described in Section 11.2.4.<br/> <strong><em>DIRU Correctable Error Location Registers 0-1 (DIRUCELR0-1)</em></strong><br/> <span style="text-decoration: underline;">Register Numbers</span><br/> 0x042-0x43<br/> <span style="text-decoration: underline;">Description</span><br/> DIRUCELR0-1 behave in the same manner as CAIUCELR0-1 described in Section 11.2.4.<br/> <strong><em>DIRU Correctable Error Status Alias Register (DIRUCESAR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x049<br/> <span style="text-decoration: underline;">Description</span><br/> The DIRUCESAR behaves in the same manner as the CAIUCESAR described in Section 11.2.4.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207734DIRUUncorrectableErrorRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207734"><span class="confluence-anchor-link" id="_Toc447207734"></span></span>DIRU Uncorrectable Error Registers</h3><p>This section describes the DIRU uncorrectable error control and status registers.<br/> <strong><em>DIRU Uncorrectable Error Control Register (DIRUUECR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x050<br/> <span style="text-decoration: underline;">Description</span><br/> The DIRUUECR behaves in the same manner as the CAIUUECR described in Section 11.2.5.<br/> <strong><em>DIRU Uncorrectable Error Status Register (DIRUUESR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x051<br/> <span style="text-decoration: underline;">Description</span><br/> The DIRUUESR behaves in the same manner as the CAIUUESR described in Section 11.2.5.<br/> <strong><em>DIRU Uncorrectable Error Location Registers 0-1 (DIRUUELR0-1)</em></strong><br/> <span style="text-decoration: underline;">Register Numbers</span><br/> 0x052-0x053<br/> <span style="text-decoration: underline;">Description</span><br/> DIRUUELR0-1 behave in the same manner as CAIUUELR0-1 described in Section 11.2.5.<br/> <strong><em>DIRU Uncorrectable Error Status Alias Register (DIRUUESAR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x059<br/> <span style="text-decoration: underline;">Description</span><br/> The DIRUUESAR behaves in the same manner as the CAIUUESAR described in Section 11.2.5.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207735DIRUIdentificationRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207735"><span class="confluence-anchor-link" id="_Toc447207735"></span></span>DIRU Identification Registers</h3><p>This section describes the DIRU identification registers which provide information about the unit.<br/> <strong><em>DIRU Identification Register (DIRUIDR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x3FF<br/> <span style="text-decoration: underline;">Description</span><br/> The DIRUIDR identifies certain features and configuration information about a directory unit. This register consists of the following bits and fields:</p><ul><li>Implementation Version – This field indicates the implementation version of the DIRU. A value of zero indicates the DIRU is <em>not</em> implemented, and all other values are RESERVED:</li><li>0x00 – Unimplemented DIRU</li><li>0x01 – Implemented DIRU

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2141" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2141?src=confmacro" class="jira-issue-key">CONC-2141</a>
                            </span>
</li></ul><p>The UnitID for this DIRU may be calculated as follows:</p><ul><li>UnitID = (RegPageNum - 0x80) + <em>A</em> + <em>B</em></li></ul><p>In this relationship, <em>A</em> equals the number of CAIUs, and <em>B</em> equals the number of NCBUs.<br/> <span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref426063265"><span class="confluence-anchor-link" id="_Ref426063265"></span></span><strong><em>Note:</em></strong> Implementation Version captures various microarchitectural features and will be changed as features are added.</p><h2 id="ConcertoSystemArchitectureSpecification-_Ref441595936_Toc447207736CoherentMemoryInterfaceUnitRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref441595936"><span class="confluence-anchor-link" id="_Ref441595936"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207736"><span class="confluence-anchor-link" id="_Toc447207736"></span></span>Coherent Memory Interface Unit Registers</h2><p>Coherent memory interface unit (CMIU) registers are implemented by a DMI and are located in register pages 0xC0 through 0xDF.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207737CMIUTransactionRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207737"><span class="confluence-anchor-link" id="_Toc447207737"></span></span>CMIU Transaction Registers</h3><p>This section describes the CMIU transaction control and activity registers.<br/> <strong><em>CMIU Transaction Control Register (CMIUTCR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x000<br/> <span style="text-decoration: underline;">Description</span><br/> The CMIUTCR controls the protocol transaction behavior in a coherent memory interface unit. This register consists of the following bits and fields:</p><ul><li>Memory Hint Timeout Value – This field determines the number of CMIU cycles between timeout pulses to the memory hint buffer. The lifetime, in CMIU cycles, of a memory hint buffer entry is between one and two times the Memory Hint Timeout Value. If the CMIU is configured <em>without</em> hint resources, this field is RAZ/WI.</li></ul><p>See the <em>Concerto DMI Architecture Specification</em> for more details.<br/> <strong><em>CMIU Transaction Activity Register (CMIUTAR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x001<br/> <span style="text-decoration: underline;">Description</span><br/> The CMIUTAR reports whether certain protocol transactions are active in a coherent memory interface unit. This register consists of the following bits and fields:</p><ul><li>Transaction Active – This bit is set when the unit is performing any activity related to transactions and is clear otherwise.</li></ul><p>See Section 7.2.3 for more details.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207738CMIUCorrectableErrorRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207738"><span class="confluence-anchor-link" id="_Toc447207738"></span></span>CMIU Correctable Error Registers</h3><p>This section describes the CMIU correctable error control and status registers.<br/> <strong><em>CMIU Correctable Error Control Register (CMIUCECR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x040<br/> <span style="text-decoration: underline;">Description</span><br/> The CMIUCECR behaves in the same manner as the CAIUCECR described in Section 11.2.4.<br/> <strong><em>CMIU Correctable Error Status Register (CMIUCESR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x041<br/> <span style="text-decoration: underline;">Description</span><br/> The CMIUCESR behaves in the same manner as the CAIUCESR described in Section 11.2.4.<br/> <strong><em>CMIU Correctable Error Location Registers 0-1 (CMIUCELR0-1)</em></strong><br/> <span style="text-decoration: underline;">Register Numbers</span><br/> 0x042-0x43<br/> <span style="text-decoration: underline;">Description</span><br/> CMIUCELR0-1 behave in the same manner as CAIUCELR0-1 described in Section 11.2.4.<br/> <strong><em>CMIU Correctable Error Status Alias Register (CMIUCESAR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x049<br/> <span style="text-decoration: underline;">Description</span><br/> The CMIUCESAR behaves in the same manner as the CAIUCESAR described in Section 11.2.4.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207739CMIUUncorrectableErrorRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207739"><span class="confluence-anchor-link" id="_Toc447207739"></span></span>CMIU Uncorrectable Error Registers</h3><p>This section describes the CMIU uncorrectable error control and status registers.<br/> <strong><em>CMIU Uncorrectable Error Control Register (CMIUUECR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x050<br/> <span style="text-decoration: underline;">Description</span><br/> The CMIUUECR behaves in the same manner as the CAIUUECR described in Section 11.2.5.<br/> <strong><em>CMIU Uncorrectable Error Status Register (CMIUUESR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x051<br/> <span style="text-decoration: underline;">Description</span><br/> The CMIUUESR behaves in the same manner as the CAIUUESR described in Section 11.2.5.<br/> <strong><em>CMIU Uncorrectable Error Location Registers 0-1 (CMIUUELR0-1)</em></strong><br/> <span style="text-decoration: underline;">Register Numbers</span><br/> 0x052-0x053<br/> <span style="text-decoration: underline;">Description</span><br/> CMIUUELR0-1 behave in the same manner as CAIUUELR0-1 described in Section 11.2.5.<br/> <strong><em>CMIU Uncorrectable Error Status Alias Register (CMIUUESAR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x059<br/> <span style="text-decoration: underline;">Description</span><br/> The CMIUUESAR behaves in the same manner as the CAIUUESAR described in Section 11.2.5.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207740CMIUIdentificationRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207740"><span class="confluence-anchor-link" id="_Toc447207740"></span></span>CMIU Identification Registers</h3><p>This section describes the CMIU identification registers which provide information about the unit.<br/> <strong><em>CMIU Identification Register (CMIUIDR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x3FF<br/> <span style="text-decoration: underline;">Description</span><br/> The CMIUIDR identifies certain features and configuration information about a coherent memory interface unit. This register consists of the following bits and fields:</p><ul><li>Implementation Version – This field indicates the implementation version of the CMIU. A value of zero indicates the CMIU is <em>not</em> implemented, and all other values are RESERVED:</li><li>0x00 – Unimplemented CMIU</li><li>0x01 – Implemented CMIU</li><li>Coherent Memory Interface Identifier – This field indicates the coherent memory interface with which the CMIU is associated. If the CMIU is <em>not</em> implemented, this field is RAZ/WI.

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2142" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2142?src=confmacro" class="jira-issue-key">CONC-2142</a>
                            </span>
</li></ul><p>The UnitID for this CMIU may be calculated as follows:</p><ul><li>UnitID = (RegPageNum - 0xC0) + <em>A</em> + <em>B</em> + <em>D</em></li></ul><p>In this relationship, <em>A</em> equals the number of CAIUs, <em>B</em> equals the number of NCBUs, and <em>D</em> equals the number of DIRUs.<br/> <span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref426063343"><span class="confluence-anchor-link" id="_Ref426063343"></span></span><strong><em>Note:</em></strong> Implementation Version captures various microarchitectural features and will be changed as features are added.</p><h2 id="ConcertoSystemArchitectureSpecification-_Ref441595961_Toc447207741CoherentSubsystemRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref441595961"><span class="confluence-anchor-link" id="_Ref441595961"></span></span><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207741"><span class="confluence-anchor-link" id="_Toc447207741"></span></span>Coherent Subsystem Registers</h2><p>The coherent subsystem registers are implemented in DIRU 0 and are located in register page 0xFF.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207742CoherentSubsystemACEDVMTransactionRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207742"><span class="confluence-anchor-link" id="_Toc447207742"></span></span>Coherent Subsystem ACE DVM Transaction Registers</h3><p>This section describes the ACE DVM snoop enable and snoop activity registers.<br/> <strong><em>Coherent Subsystem ACE DVM Snoop Enable Register 0-3 (CSADSER0-3)</em></strong><br/> <span style="text-decoration: underline;">Register Numbers</span><br/> 0x010-0x013<br/> <span style="text-decoration: underline;">Description</span><br/> CSADSER0-3 enable DVM-related snoop messages to the specified agent. These registers consist of the following bits and fields:</p><ul><li>ACE DVM Snoop Enable – This field consists of a bit per CAIU. If a bit is set, DVM-related snoop messages are enabled for that CAIU; otherwise, DVM-related snoop messages are disabled. Bits that correspond to CAIUs that are not implemented or are configured not to receive DVM messages are RAZ/WI.</li></ul><p>Each register contains the DVM-related snoop enable bits for the following units:</p><ul><li>CSADSER0: CAIU 31 – CAIU 0</li><li>CSADSER1: CAIU 63 – CAIU 32</li><li>CSADSER2: CAIU 95 – CAIU 64</li><li>CSADSER3: NCBU 31 – NCBU 0</li></ul><p>See Section 7.2.2 for more details.<br/> If the coherent subsystem has been configured <em>without</em> support for ACE DVM transactions, all bits and fields in this register are RAZ/WI.<br/> <strong><em>Coherent Subsystem ACE DVM Snoop Activity Register 0-3 (CSADSAR0-3)</em></strong><br/> <span style="text-decoration: underline;">Register Numbers</span><br/> 0x014-0x017<br/> <span style="text-decoration: underline;">Description</span><br/> CSADSAR0-3 report whether DVM-related snoop messages are active to the specified agent. These registers consist of the following bits and fields:</p><ul><li>ACE DVM Snoop Active – This field consists of a bit per CAIU. If a bit is set, DVM-related snoop messages are active for that agent; otherwise, DVM-related snoop messages are not active. Bits that correspond to CAIUs that are not implemented or are configured not to receive DVM messages are RAZ/WI.</li></ul><p>Each register contains the DVM-related snoop active bits for the following units:</p><ul><li>CSADSAR0: CAIU 31 – CAIU 0</li><li>CSADSAR1: CAIU 63 – CAIU 32</li><li>CSADSAR2: CAIU 95 – CAIU 64</li><li>CSADSAR3: NCBU 31 – NCBU 0</li></ul><p>See Section 7.2.2 for more details.<br/> If the coherent subsystem has been configured <em>without</em> support for ACE DVM transactions, all bits and fields in this register are RAZ/WI.</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207743CoherentSubsystemErrorInterruptStatusRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207743"><span class="confluence-anchor-link" id="_Toc447207743"></span></span>Coherent Subsystem Error Interrupt Status Registers</h3><p>This section describes the correctable error and uncorrectable error interrupt status registers.<br/> <strong><em>Coherent Subsystem Correctable Error Interrupt Status Registers (CSCEISR0-7)</em></strong><br/> <span style="text-decoration: underline;">Register Numbers</span><br/> 0x040-0x047<br/> <span style="text-decoration: underline;">Description</span><br/> CSCEISR0-7 report whether a unit has asserted a correctable error interrupt. These registers consist of the following bits and fields:</p><ul><li>Error Interrupt Valid – This field consists of a bit per unit. If a bit is set, a correctable error interrupt has been asserted by the unit; otherwise, a correctable error interrupt has not been asserted. Bits that correspond to units that are <em>not</em> implemented are RAZ/WI.

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2143" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2143?src=confmacro" class="jira-issue-key">CONC-2143</a>
                            </span>
</li></ul><p>Each register contains the correctable error interrupt status bits for the following units:</p><ul><li>CSCEISR0: CAIU 31 – CAIU 0</li><li>CSCEISR1: CAIU 63 – CAIU 32</li><li>CSCEISR2: CAIU 95 – CAIU 64</li><li>CSCEISR3: NCBU 31 – NCBU 0</li><li>CSCEISR4: DIRU 31 – DIRU 0</li><li>CSCEISR5: Reserved</li><li>CSCEISR6: CMIU 95 – CMIU 64</li><li>CSCEISR7: Reserved</li></ul><p>See Section 8.7 for more details.<br/> If all resources and arrays in the coherent subsystem are configured <em>without</em> error correction, all bits and fields in this register are RAZ/WI.<br/> <strong><em>Coherent Subsystem Uncorrectable Error Interrupt Status Registers (CSUEISR0-7)</em></strong><br/> <span style="text-decoration: underline;">Register Numbers</span><br/> 0x050-0x057<br/> <span style="text-decoration: underline;">Description</span><br/> CSUEISR0-7 report whether a unit has asserted an uncorrectable error interrupt. These registers consist of the following bits and fields:</p><ul><li>Error Interrupt Valid – This field consists of a bit per unit. If a bit is set, an uncorrectable error interrupt has been asserted by the unit; otherwise, an uncorrectable error interrupt has not been asserted. Bits that correspond to units that are <em>not</em> implemented are RAZ/WI.</li></ul><p>Each register contains the uncorrectable error interrupt status bits for the following units:</p><ul><li>CSUEISR0: CAIU 31 – CAIU 0</li><li>CSUEISR1: CAIU 63 – CAIU 32</li><li>CSUEISR2: CAIU 95 – CAIU 64</li><li>CSUEISR3: NCBU 31 – NCBU 0</li><li>CSUEISR4: DIRU 31 – DIRU 0</li><li>CSUEISR5: Reserved</li><li>CSUEISR6: CMIU 95 – CMIU 64</li><li>CSUEISR7: Reserved</li></ul><p>See Section 8.7 for more details.<br/> If all resources and arrays in the coherent subsystem are configured <em>without</em> error detection, all bits and fields in this register are RAZ/WI.

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="CONC-2144" >
                <a href="https://arterisip.atlassian.net/browse/CONC-2144?src=confmacro" class="jira-issue-key">CONC-2144</a>
                            </span>
</p><h3 id="ConcertoSystemArchitectureSpecification-_Toc447207744CoherentSubsystemIdentificationRegisters"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207744"><span class="confluence-anchor-link" id="_Toc447207744"></span></span>Coherent Subsystem Identification Registers</h3><p>This section describes the identification registers for the coherent subsystem.<br/> <strong><em>Coherent Subsystem Snoop Filter Identification Registers (CSSFIDR0-31)</em></strong><br/> <span style="text-decoration: underline;">Register Numbers</span><br/> 0x3C0-0x3DF<br/> <span style="text-decoration: underline;">Description</span><br/> CSSFIDR0-31 report the configuration of the snoop filters in the coherent subsystem. These registers consist of the following bits and fields:</p><ul><li>Number of Snoop Filter Sets – This field indicates the number of sets in the snoop filter minus one <em>in each DIRU</em>. To determine the total number of sets in the snoop filter, this value must be multiplied by the number of DIRUs. For an unimplemented filter or a null filter, the value of this field is zero.</li><li>Number of Snoop Filter Ways – This field indicates the number of ways (i.e. the associativity) in the snoop filter minus one. For an unimplemented filter or a null filter, the value of this field is zero.</li><li>Snoop Filter Type – The field indicates the type of snoop filter. The type of the snoop filter is given as follows (all other values are RESERVED):</li><li>000 – Unimplemented filter</li><li>001 – Null filter</li><li>010 – Tag filter – presence vector</li><li>011 – Tag filter – owner pointer/sharer vector</li><li>110 – Tag filter with victim buffer – presence vector</li><li>111 – Tag filter with victim buffer – owner pointer/sharer vector</li></ul><p>If this register reads as all zeros, the corresponding snoop filter is not implemented.<br/> <strong><em>Coherent Subsystem Unit Identification Register (CSUIDR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x3FE<br/> <span style="text-decoration: underline;">Description</span><br/> The CSUIDR reports the number of units in the coherent subsystem. This register consists of the following bits and fields:</p><ul><li>Number of Coherent Agent Interface Units – This field identifies the number of CAIUs in the coherent subsystem. (<strong><em>Note:</em></strong> This value corresponds to the value <em>A</em> in Section 2.1)</li><li>Number of Non-coherent Bridge Units – This field identifies the number of NCBUs in the coherent subsystem. (<strong><em>Note:</em></strong> This value corresponds to the value <em>B</em> in Section 2.1)</li><li>Number of Directory Units – This field identifies the number of DIRUs in the coherent subsystem. (<strong><em>Note:</em></strong> This value corresponds to the value <em>D</em> in Section 2.1)</li><li>Number of Coherent Memory Interface Units – This field identifies the number of CMIUs in the coherent subsystem. (<strong><em>Note:</em></strong> This value corresponds to the value <em>M</em> in Section 2.1)</li></ul><p>Software may use the fields of this register to determine which register page numbers are defined and which are reserved.<br/> <strong><em>Coherent Subsystem</em></strong> <strong><em>Identification Register (CSIDR)</em></strong><br/> <span style="text-decoration: underline;">Register Number</span><br/> 0x3FF<br/> <span style="text-decoration: underline;">Description</span><br/> The CSIDR reports information about the coherent subsystem. This register consists of the following bits and fields:</p><ul><li>Release Version – This field identifies the release version (see Table 8).</li><li>Directory Cache Line Offset – This field indicates the width in bits of the directory cache line offset. The number of bits in the directory cache line offset equals the value of this field + 5, e.g. for a 6-bit offset the value of this field equals 1. The size in bytes of the directory cache line is equal to two to the power of the offset.</li><li>Number of Snoop Filters – This field identifies the number of snoop filters in the coherent subsystem. The value of this field equals the number of snoop filters minus one.</li></ul><p>Software may use the fields of this register to determine the number of defined snoop filter identification registers.<br/> Table 8 lists the encoding of the Release Version field.</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><strong>Release Version Code</strong></p></td><td class="confluenceTd"><p><strong>Release</strong></p></td></tr><tr><td class="confluenceTd"><p>0x00</p></td><td class="confluenceTd"><p><em>Reserved</em></p></td></tr><tr><td class="confluenceTd"><p>0x01</p></td><td class="confluenceTd"><p><strong>V1.0.0</strong></p></td></tr><tr><td class="confluenceTd"><p>0x02</p></td><td class="confluenceTd"><p><strong>V1.0.1</strong></p></td></tr><tr><td class="confluenceTd"><p>0x03</p></td><td class="confluenceTd"><p><strong>V1.5.0</strong></p></td></tr><tr><td class="confluenceTd"><p>0x04-0xFF</p></td><td class="confluenceTd"><p><em>Reserved</em></p></td></tr></tbody></table></div><p><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Ref441485458"><span class="confluence-anchor-link" id="_Ref441485458"></span></span><strong>Table 8: Release Version Codes</strong><br/> <strong><em>Note:</em></strong> Release Version captures the software release version of the Concerto IP and is incremented for each release.<br/> <strong>FIXME_FIXME_FIXME_FIXME_FIXME</strong></p><h1 id="ConcertoSystemArchitectureSpecification-_Toc447207745RandomStuff"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207745"><span class="confluence-anchor-link" id="_Toc447207745"></span></span>Random Stuff</h1><p> </p><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207746TopologyNotes"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207746"><span class="confluence-anchor-link" id="_Toc447207746"></span></span>Topology Notes</h2><p>Bridge interface dependencies:</p><ul><li><strong>AR (S)</strong> ⇒ <strong>CMDreq (M)</strong> {→ SNPreq (S) {⇒ DTWreq (M) ⇒ DTWrsp (M)}? → SNPrsp (S)}? {→ …}? → <strong>DTRreq/STRreq (S)</strong> {→ DTWreq (M) ⇒ DTWrsp (M)}? → <strong>R (S)</strong></li><li><strong>AW/W (S)</strong> ⇒ <strong>CMDreq (M)</strong> {→ SNPreq (S) {⇒ DTWreq (M) ⇒ DTWrsp (M)}? → SNPrsp (S)}? → <strong>STRreq (S)</strong> → <strong>DTWreq (M)</strong> ⇒ <strong>DTWrsp (M)</strong> → <strong>B (S)</strong></li></ul><p><br class="atl-forced-newline"/> DMI dependencies:</p><ul><li>HNTreq (S) ⇒ AR (M) ⇒ … ⇒ R (M)</li><li>MRDreq (S) ⇒ AR (M) ⇒ … ⇒ R (M) ⇒ DTRreq (M)</li><li>DTWreq (S) ⇒ AW/W (M) ⇒ … ⇒ B (M) ⇒ DTWrsp (S)</li></ul><p><br class="atl-forced-newline"/> AW/W must not depend on AR (e.g. FlexNoC) – outbound requests from AR master must not block outbound requests from AW/W master<br/> Blocking inbound requests to SFI slave must not block outbound requests from AXI AW/W master<br/> (Blocking inbound requests to SFI slave must not block outbound requests from SFI master) <br class="atl-forced-newline"/> <br class="atl-forced-newline"/> IDs:<br/> SFISlvID – Transport interconnect target address; sets global address<br/> UnitID – Protocol level logical identification; AIUID is the subset of AIUs; DAIUID is the subset of AIUs that are associated with caching agents (including IO caches)<br/> RegionID – Memory region logical identification<br/> SWID – Software level logical identification; locates each unit in the CSR map and in registers:</p><h2 id="ConcertoSystemArchitectureSpecification-_Toc447207747PowerManagementNotes"><span class="confluence-anchor-link" id="ConcertoSystemArchitectureSpecification-_Toc447207747"><span class="confluence-anchor-link" id="_Toc447207747"></span></span>Power Management Notes</h2><p><br class="atl-forced-newline"/> <br class="atl-forced-newline"/> Assumptions:</p><ul><li>An agent does not perform any native agent coherent transactions, e.g. a writeback, to service a snoop</li><li>An agent does not issue an update transaction (writeback) to a memory region to service a snoop</li></ul><p><br class="atl-forced-newline"/> Notes:</p><ul><li>At end of prerequisites, the AIU may still be processing a protocol transaction, e.g. the STRrsp message has not been issued, so PMSW must check AIU request activity.</li></ul><p><br class="atl-forced-newline"/> Native agent transaction completion implies the following:</p><ul><li>All snoops have completed</li><li>A blocking update transaction from a snooping AIU has completed</li><li>A DTW message from a snooping AIU due to a coherent clean transaction or a coherent write transaction has completed to memory (V1/V1+) or a DMI (V1+)</li><li>One DTR message has been received</li><li>A DTW message from the requesting AIU due to a coherent write transaction or an update transaction has completed to memory (V1) or a DMI (V1+)</li><li>A DTW message from the requesting AIU due to a coherent read transaction has completed to memory (V1) or a DMI (V1+)</li></ul><p>Protocol transaction completion implies the following:</p><ul><li>Native agent transaction completion</li><li>All DTR messages have been received</li></ul><p><br class="atl-forced-newline"/> Disable HNT messages when DMI is powered down<br/> Disable SNP messages when AIU is powered down; power OK signal from AIU? Activity signals from AIU?</p>