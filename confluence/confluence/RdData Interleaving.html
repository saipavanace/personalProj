<p /><style type='text/css'>/*<![CDATA[*/
div.rbtoc1759725300653 {padding: 0px;}
div.rbtoc1759725300653 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1759725300653 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class='toc-macro rbtoc1759725300653'>
<ul class='toc-indentation'>
<li><a href='#RdDataInterleaving-Overview'>Overview</a>
<ul class='toc-indentation'>
<li><a href='#RdDataInterleaving-Non-Interleavedreadresponsewithinacacheline'>Non-Interleaved read response within a cacheline</a></li>
<li><a href='#RdDataInterleaving-Non-InterleavedReadResponseonamulticachelinetransaction'>Non-Interleaved Read Response on a multicacheline transaction</a></li>
</ul>
</li>
<li><a href='#RdDataInterleaving-StimulusDescriptions'>Stimulus Descriptions</a></li>
<li><a href='#RdDataInterleaving-FunctionalCheck&amp;Coverage'>Functional Check &amp; Coverage</a></li>
<li><a href='#RdDataInterleaving-DirectedTestcase'>Directed Testcase</a></li>
<li><a href='#RdDataInterleaving-Configs/randomtestcase'>Configs/random testcase</a></li>
</ul>
</div><p /><h1 id="RdDataInterleaving-Overview">Overview</h1><h3 id="RdDataInterleaving-Non-Interleavedreadresponsewithinacacheline"><strong>Non-Interleaved read response within a cacheline</strong></h3><ul><li><p>When we send a multiple multibeat read transactions to the IOAIU, the responses for those transactions that are sent back should only interleave on the cacheline boundary and should never interleave within a cacheline. </p></li><li><p>This is a permanent fix made in the RTL</p></li><li><p><strong>Example when the address is cacheline aligned</strong>: </p><ul><li><p>Lets say in a configuration with wData = 128bits (16B), we send the following two transactions:</p><ul><li><p>txn1 : arid= ‘1', arlen=’4' (5 beats of data) and arsize= 4 (16B)</p></li><li><p>txn2 : arid= ‘2', arlen= '0’ (1 beat of data) and arsize=4 (16B)</p></li></ul></li><li><p>For the above transactions, if the IOAIU sends back a read response like so : </p><ul><li><p>beat1: rid= '1'</p></li><li><p>beat2: rid= '1'</p></li><li><p>beat3: rid= '1'</p></li><li><p>beat4: rid= '2'</p></li><li><p>beat5: rid= '1'</p></li><li><p>beat6: rid= '1'</p></li></ul></li><li><p>This will be a bug, since IOAIU sent 3 beats of data (which is not a cacheline worth of data) before interleaving the data of the second transaction. However, the following scenario will still be possible:</p><ul><li><p>beat1: rid= '1'</p></li><li><p>beat2: rid= '1'</p></li><li><p>beat3: rid= '1'</p></li><li><p>beat4: rid= '1'</p></li><li><p>beat5: rid= '2'</p></li><li><p>beat6: rid= '1'</p></li></ul></li><li><p>Because after sending the first 4 beats of data, we already transferred (16x4 = 64B of data) and hence we are not interleaving within the cacheline</p></li></ul></li></ul><p><strong>Example Read Transactions on Native Interface :</strong> </p><span class="confluence-embedded-file-wrapper image-left-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image image-left" width="340" src="https://arterisip.atlassian.net/wiki/download/attachments/437321729/image-20221010-191450.png?api=v2"></span><p><strong>Valid Response :</strong> </p><span class="confluence-embedded-file-wrapper image-left-wrapper"><img class="confluence-embedded-image image-left" src="https://arterisip.atlassian.net/wiki/download/attachments/437321729/image-20221010-191548.png?api=v2"></span><p><strong>Invalid Response :</strong></p><span class="confluence-embedded-file-wrapper image-left-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image image-left" width="340" src="https://arterisip.atlassian.net/wiki/download/attachments/437321729/image-20221010-191731.png?api=v2"></span><h3 id="RdDataInterleaving-Non-InterleavedReadResponseonamulticachelinetransaction"><strong>Non-Interleaved Read Response on a multicacheline transaction</strong></h3><ul><li><p>When we send a multiple read transactions to the IOAIU, where atleast one of them spans multiple cachelines, the responses for those transactions that are sent back can interleave in between the cachelines when “fnDisableRdInterleave“ parameter is set to “false“.</p></li><li><p>When this parameter is set to “true“, the interleaving is prohibited.</p></li><li><p>Along with the permanent fix made as described in section 1.1 (above), it basically means that when “fnDisableRdInterleave“ parameter is set to “true“, we should never see any kind of interleaving at all between the read responses.</p></li><li><p><strong>Example when the address is cacheline aligned</strong></p><ul><li><p>Lets say in a configuration with wData = 128bits (16B), we send the following two transactions:</p><ul><li><p>txn1 : arid= ‘1', arlen=’7' (8 beats of data) and arsize= 4 (16B)</p></li><li><p>txn2 : arid= ‘2', arlen= '0’ (1 beat of data) and arsize=4 (16B)</p></li></ul></li><li><p>For the above transactions, when “fnDisableRdInterleave“ is set to “true“, if the IOAIU sends back a read response like so :</p><ul><li><p>beat1: rid= '1'</p></li><li><p>beat2: rid= '1'</p></li><li><p>beat3: rid= '1'</p></li><li><p>beat4: rid= '1' → completed a cacheline</p></li><li><p>beat5: rid= '2'</p></li><li><p>beat6: rid= '1'</p></li><li><p>beat5: rid= '1'</p></li><li><p>beat6: rid= '1'</p></li><li><p>beat6: rid= '1' → completed the next cacheline</p></li></ul></li><li><p>This will be a bug, since there is a second transaction with rid=2 interleaved in between the 2 cachelines of the transaction with rid='1'</p></li><li><p>However, if the “fnDisableRdInterleave“ is set to “false“, the above transaction is legal</p></li><li><p>Because after sending the first 4 beats of data, we already transferred (16x4 = 64B of data) and hence we are not interleaving within the cacheline</p></li></ul></li></ul><p><strong>Example Read Transaction on Native Interface:</strong></p><span class="confluence-embedded-file-wrapper image-left-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image image-left" width="340" src="https://arterisip.atlassian.net/wiki/download/attachments/437321729/image-20221010-202512.png?api=v2"></span><p><strong>Example Response : </strong></p><span class="confluence-embedded-file-wrapper image-left-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image image-left" width="340" src="https://arterisip.atlassian.net/wiki/download/attachments/437321729/image-20221010-202438.png?api=v2"></span><p>The above response is legal if “fnDisableRdInterleave“ is set to “false“ else it is illegal.</p><p><strong>NOTE:</strong> The above examples assume that the transaction address is cacheline aligned. And when it is not aligned, we need lesser number of beats until we reach the cache lined boundary. </p><p>The total number of databeats to reach the cacheline boundary is given by this formula : </p><p>((SYS_nSysCacheline / (wData / 8)) -  ((araddr % 6) &gt;&gt; $clog2(wData / 8))) * (wData);</p><h1 id="RdDataInterleaving-StimulusDescriptions"><strong>Stimulus Descriptions </strong></h1><ul><li><p>There is no specific stimulus written to verify this feature.</p></li><li><p>The checks are always active and so any read issued on the axi interface should verify this feature</p></li><li><p>Note: Even though we don't have a directed testcase to hit this scenario, there is an action item <a class="external-link" href="https://arterisip.atlassian.net/browse/CONC-10653" rel="nofollow">CONC-10653</a> to see if this scenario can be targeted.</p></li></ul><h1 id="RdDataInterleaving-FunctionalCheck&amp;Coverage"><strong>Functional Check &amp; Coverage</strong></h1><div class="table-wrap"><table data-table-width="1800" data-layout="default" data-local-id="c4548bec-7cee-41d0-9eaa-2d4485f66405" class="confluenceTable"><colgroup><col style="width: 151.0px;"/><col style="width: 156.0px;"/><col style="width: 156.0px;"/><col style="width: 156.0px;"/><col style="width: 156.0px;"/><col style="width: 200.0px;"/><col style="width: 138.0px;"/><col style="width: 156.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p><strong>Scenario</strong></p></th><th class="confluenceTh"><p><strong>Hash-Tag</strong></p></th><th class="confluenceTh"><p><strong>Where Covered/Checked</strong></p></th><th class="confluenceTh"><p><strong>Reference Document</strong></p></th><th class="confluenceTh"><p><strong>Priority</strong></p></th><th class="confluenceTh"><p><strong>Implemented</strong></p></th><th class="confluenceTh"><p><strong>Status</strong></p></th><th class="confluenceTh"><p><strong>Remarks/Questions</strong></p></th></tr><tr><td class="confluenceTd"><p>Check that when &quot;fnDisableRdInterleave&quot; parameter is set to “true“, we never interleave read response beats in between multiple cachelines</p></td><td class="confluenceTd"><p>#Check.IOAIU.rd_interleave_disable</p></td><td class="confluenceTd"><p>ioaiu_scoreboard.svh</p></td><td class="confluenceTd"><p>IOAIU 3.4 Micro Arch Section 9.1</p></td><td class="confluenceTd"><p>High</p></td><td class="confluenceTd"><p>Done</p></td><td class="confluenceTd"><p>Pass</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>Check that we never interleave read data beats within the cacheline boundary</p></td><td class="confluenceTd"><p>#Check.IOAIU.cache_interleave</p></td><td class="confluenceTd"><p>ioaiu_scoreboard.svh</p></td><td class="confluenceTd"><p>IOAIU 3.4 Micro Arch Section 9.2</p></td><td class="confluenceTd"><p>High</p></td><td class="confluenceTd"><p>Done</p></td><td class="confluenceTd"><p>Pass</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>Cover Rd data beats interleaving between multiple cachelines</p></td><td class="confluenceTd"><p>#Cover.IOAIU.multiCacheline</p></td><td class="confluenceTd"><p>ioaiu_scoreboard.svh</p></td><td class="confluenceTd"><p>IOAIU 3.4 Micro Arch Section 9.2</p></td><td class="confluenceTd"><p>High</p></td><td class="confluenceTd"><p>Done</p></td><td class="confluenceTd"><p>Pass</p></td><td class="confluenceTd"><p /></td></tr></tbody></table></div><p /><h1 id="RdDataInterleaving-DirectedTestcase">Directed Testcase</h1><p>This is a check on the read response channel so any testcase which issues a read should exercise this logic and hence no directed testcase was created</p><h1 id="RdDataInterleaving-Configs/randomtestcase">Configs/random testcase</h1><p>For the permanent fix described in section 1.1, we are running on all the configurations</p><p>For the fix mentioned in section 1.2, we run it on config-axi4 (fnDisableRdInterleave=true and on testcase- bring_up_test or coh_noncoh_rd_wr</p>