<h1 id="DMITestplan-Ncore2.5-History">History</h1><h4 id="DMITestplan-Ncore2.5-Version0.7,11/22/2017.">Version 0.7, 11/22/2017.</h4><ul><li>Draft for v2.5</li></ul><h1 id="DMITestplan-Ncore2.5-ReviewHistory">Review History</h1><p>   <strong> </strong></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><strong>Review Date</strong></p></td><td class="confluenceTd"><p><strong>Attendees</strong></p></td></tr><tr><td class="confluenceTd">12/14/2017</td><td class="confluenceTd">Chirag Gandhi, Sanjay Deshpande, Mohammed Khaleeluddin, Travis Johnson, Satya Prakash</td></tr><tr><td class="confluenceTd"> </td><td class="confluenceTd"> </td></tr><tr><td class="confluenceTd"><p><strong><br/></strong></p></td><td class="confluenceTd"><p><strong><br/></strong></p></td></tr><tr><td class="confluenceTd"><p><strong><br/></strong></p></td><td class="confluenceTd"><p><strong><br/></strong></p></td></tr><tr><td class="confluenceTd"><p><strong> </strong></p></td><td class="confluenceTd"><p><strong> </strong></p></td></tr></tbody></table></div><p>   <strong> </strong></p><p><style type='text/css'>/*<![CDATA[*/
div.rbtoc1759724277707 {padding: 0px;}
div.rbtoc1759724277707 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1759724277707 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class='toc-macro rbtoc1759724277707'>
<ul class='toc-indentation'>
<li><a href='#DMITestplan-Ncore2.5-History'>History</a>
<ul class='toc-indentation'>
<li><a href='#DMITestplan-Ncore2.5-Version0.7,11/22/2017.'>Version 0.7, 11/22/2017.</a></li>
</ul>
</li>
<li><a href='#DMITestplan-Ncore2.5-ReviewHistory'>Review History</a></li>
<li><a href='#DMITestplan-Ncore2.5-1.Introduction'>1. Introduction</a>
<ul class='toc-indentation'>
<li><a href='#DMITestplan-Ncore2.5-1.1.References'>1.1. References</a></li>
<li><a href='#DMITestplan-Ncore2.5-1.2.Assumptions'>1.2. Assumptions</a></li>
</ul>
</li>
<li><a href='#DMITestplan-Ncore2.5-2.Testbenchdescription'>2. Testbench description</a>
<ul class='toc-indentation'>
<li><a href='#DMITestplan-Ncore2.5-2.1.TBdiagram'>2.1. TB diagram</a></li>
<li><a href='#DMITestplan-Ncore2.5-2.2.ListanddescriptionofTBcomponents'>2.2. List and description of TB components</a>
<ul class='toc-indentation'>
<li><a href='#DMITestplan-Ncore2.5-2.2.1.Monitors'>2.2.1. Monitors</a>
<ul class='toc-indentation'>
<li><a href='#DMITestplan-Ncore2.5-2.2.1.1.SFIMonitor(dv/common/lib_tb/sfi_monitor.svh)'>2.2.1.1. SFI Monitor (dv/common/lib_tb/sfi_monitor.svh)</a></li>
<li><a href='#DMITestplan-Ncore2.5-2.2.1.2.AXI4Monitor(dv/common/lib_tb/axi_monitor.svh)'>2.2.1.2. AXI4 Monitor (dv/common/lib_tb/axi_monitor.svh)</a></li>
</ul>
</li>
<li><a href='#DMITestplan-Ncore2.5-2.2.2.BFMs'>2.2.2. BFMs</a>
<ul class='toc-indentation'>
<li><a href='#DMITestplan-Ncore2.5-2.2.2.1.AXIBFM'>2.2.2.1. AXI BFM</a></li>
<li><a href='#DMITestplan-Ncore2.5-2.2.2.2.SystemBFM'>2.2.2.2. System BFM</a></li>
</ul>
</li>
</ul>
</li>
<li><a href='#DMITestplan-Ncore2.5-2.3.Checkers'>2.3. Checkers</a>
<ul class='toc-indentation'>
<li><a href='#DMITestplan-Ncore2.5-2.3.1DMIchecker'>2.3.1 DMI checker</a></li>
<li><a href='#DMITestplan-Ncore2.5-2.3.2CCPchecker'>2.3.2 CCP checker</a></li>
</ul>
</li>
<li><a href='#DMITestplan-Ncore2.5-2.4.Injectors'>2.4. Injectors</a></li>
</ul>
</li>
<li><a href='#DMITestplan-Ncore2.5-3.ConfigurationSpace'>3. Configuration Space</a>
<ul class='toc-indentation'>
<li><a href='#DMITestplan-Ncore2.5-3.1.ForConcertov2.5'>3.1. For Concerto v2.5</a></li>
<li><a href='#DMITestplan-Ncore2.5-3.2.DMIStaticConfigurations'>3.2. DMI Static Configurations</a>
<ul class='toc-indentation'>
<li><a href='#DMITestplan-Ncore2.5-3.2.1.NoCMC'>3.2.1. No CMC</a></li>
<li><a href='#DMITestplan-Ncore2.5-3.2.2.WithCMC'>3.2.2. With CMC</a></li>
<li><a href='#DMITestplan-Ncore2.5-3.2.3ExtendedVictimCache'>3.2.3 Extended Victim Cache</a></li>
</ul>
</li>
</ul>
</li>
<li><a href='#DMITestplan-Ncore2.5-'></a></li>
<li><a href='#DMITestplan-Ncore2.5-4.Features'>4. Features</a>
<ul class='toc-indentation'>
<li><a href='#DMITestplan-Ncore2.5-4.1.ArchitecturalFeatures'>4.1. Architectural Features</a>
<ul class='toc-indentation'>
<li><a href='#DMITestplan-Ncore2.5-4.1.1.MRDs(CMPSv0.18section7.3)'>4.1.1. MRDs (CMPSv0.18 section 7.3)</a>
<ul class='toc-indentation'>
<li><a href='#DMITestplan-Ncore2.5-4.1.1.1.MRDs(nonFlush)withCMC'>4.1.1.1. MRDs (non Flush) with CMC</a></li>
<li><a href='#DMITestplan-Ncore2.5-4.1.1.2.MRDFlushwithCMC'>4.1.1.2. MRDFlush with CMC</a></li>
<li><a href='#DMITestplan-Ncore2.5-4.1.1.3.MRDs(nonFlush)withoutCMC'>4.1.1.3. MRDs (non Flush) without CMC</a></li>
<li><a href='#DMITestplan-Ncore2.5-4.1.1.4.MRDFlushwithoutCMC'>4.1.1.4. MRDFlush without CMC</a></li>
</ul>
</li>
<li><a href='#DMITestplan-Ncore2.5-4.1.2.DTWs(CMPSv0.18section7.5)'>4.1.2. DTWs (CMPSv0.18 section 7.5)</a>
<ul class='toc-indentation'>
<li><a href='#DMITestplan-Ncore2.5-4.1.2.1.DTWswithCMC'>4.1.2.1. DTWs with CMC</a></li>
<li><a href='#DMITestplan-Ncore2.5-4.1.2.2.DTWswithoutCMC'>4.1.2.2. DTWs without CMC</a></li>
</ul>
</li>
<li><a href='#DMITestplan-Ncore2.5-4.1.3.HNTs(CMPSv0.18section7.2)'>4.1.3. HNTs (CMPSv0.18 section 7.2)</a>
<ul class='toc-indentation'>
<li><a href='#DMITestplan-Ncore2.5-4.1.3.1.HintswithCache'>4.1.3.1. Hints with Cache</a></li>
<li><a href='#DMITestplan-Ncore2.5-4.1.3.2.HintswithoutCache'>4.1.3.2. Hints without Cache</a></li>
</ul>
</li>
<li><a href='#DMITestplan-Ncore2.5-4.1.4.DTRs(CMPSv0.18section7.4)'>4.1.4. DTRs (CMPSv0.18 section 7.4)</a></li>
<li><a href='#DMITestplan-Ncore2.5-4.1.4.1.DTRswithCMC'>4.1.4.1. DTRs with CMC</a>
<ul class='toc-indentation'>
<li><a href='#DMITestplan-Ncore2.5-4.1.4.2.DTRsWithoutCMC'>4.1.4.2. DTRs Without CMC</a></li>
</ul>
</li>
<li><a href='#DMITestplan-Ncore2.5-4.1.5.Transport'>4.1.5. Transport</a></li>
<li><a href='#DMITestplan-Ncore2.5-4.1.6.InterfaceCoverpoints'>4.1.6. Interface Coverpoints</a></li>
<li><a href='#DMITestplan-Ncore2.5-4.1.8.Miscchecks'>4.1.8. Misc checks</a></li>
<li><a href='#DMITestplan-Ncore2.5-4.1.9.Portedfromv1.5Hashtags'>4.1.9. Ported from v1.5 Hashtags</a></li>
<li><a href='#DMITestplan-Ncore2.5-4.1.10.ExtendedVictimCache(CMPS0.18section7.3.1Table94)'>4.1.10. Extended Victim Cache (CMPS0.18 section7.3.1 Table94)</a></li>
</ul>
</li>
<li><a href='#DMITestplan-Ncore2.5-4.2.Micro-ArchitecturalFeatures'>4.2. Micro-Architectural Features</a>
<ul class='toc-indentation'>
<li><a href='#DMITestplan-Ncore2.5-4.2.1.General(uarchsection5.0)'>4.2.1. General (uarch section 5.0)</a></li>
<li><a href='#DMITestplan-Ncore2.5-4.2.4.MRDFlush(uarchsection5.0)'>4.2.4. MRD Flush (uarch section 5.0)</a></li>
<li><a href='#DMITestplan-Ncore2.5-4.2.5.DTW(uarchsection5.0)'>4.2.5. DTW (uarch section 5.0)</a></li>
<li><a href='#DMITestplan-Ncore2.5-4.2.6.DMIPipeControl(uarchsection5.1.6)'>4.2.6. DMI Pipe Control (uarch section 5.1.6)</a></li>
<li><a href='#DMITestplan-Ncore2.5-4.2.7.ExtendedVictimCache(uarch)'>4.2.7.Extended Victim Cache (uarch)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href='#DMITestplan-Ncore2.5-5.AdvancedCoverage(Crossofmulti-features,Timingsensitivescenariostohit,etc)'>5. Advanced Coverage (Cross of multi-features, Timing sensitive scenarios to hit, etc)</a></li>
<li><a href='#DMITestplan-Ncore2.5-6.Clock/Reset'>6. Clock/Reset</a>
<ul class='toc-indentation'>
<li><a href='#DMITestplan-Ncore2.5-6.1.Reset'>6.1. Reset</a></li>
<li><a href='#DMITestplan-Ncore2.5-6.2.Clock'>6.2. Clock</a></li>
</ul>
</li>
<li><a href='#DMITestplan-Ncore2.5-7.Performance(LatencyandBandwidth)'>7. Performance (Latency and Bandwidth)</a></li>
<li><a href='#DMITestplan-Ncore2.5-8.Errors'>8. Errors</a></li>
<li><a href='#DMITestplan-Ncore2.5-9.PowerManagement'>9. Power Management</a></li>
<li><a href='#DMITestplan-Ncore2.5-10.CSR'>10. CSR</a></li>
<li><a href='#DMITestplan-Ncore2.5-ActionItems'>Action Items</a></li>
</ul>
</div></p><p> </p><h1 id="DMITestplan-Ncore2.5-1.Introduction"><strong>1.   Introduction</strong></h1><p>This is a live document that keeps track of the DMI v2.0 tests, checks, and coverage. Note that the terms CCP and CMC are used interchangeably.</p><h2 id="DMITestplan-Ncore2.5-1.1.References">1.1.  References</h2><ol><li>CMPS RevB-v0.18</li><li>DMI Arch</li></ol><p> </p><h2 id="DMITestplan-Ncore2.5-1.2.Assumptions">1.2.  Assumptions</h2><h1 id="DMITestplan-Ncore2.5-2.Testbenchdescription"><strong style="font-size: 24.0px;">2.   Testbench description</strong></h1><h2 id="DMITestplan-Ncore2.5-2.1.TBdiagram"><strong>2.1. TB diagram</strong></h2><h2 id="DMITestplan-Ncore2.5-2.2.ListanddescriptionofTBcomponents"><strong>2.2.  List and description of TB components</strong></h2><p>This section describes the DMI unit-level (standalone) testbench components. The DMI will also be tested in the subsystem, full-system and carbon environments. In any environment, there will be one or more DMIs instantiated to be tested along with the real AIU(s) and DCE(s). The NOC will either be a pseudoNOC or the real FlexNOC.</p><p>The DMI testbench is a SystemVerilog UVM testbench. Its architecture diagram is shown below.</p><p>The Test component runs the Requester Sequences on the SFI Master Agent  to send MRD / HNT / DTW messages to the DUT. The Test component also runs the slave  Sequences on the SFI Slave Agent to responds to DTR messages from the DMI DUT.</p><p>The Scoreboard subscribes to the SFI Master and Slave Agents’ analysis ports as well as to the AXI Master Agent’s analysis ports, and uses the subscribed information to keep track of transaction completion and correctness and report any errors.</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16168777/image2017-6-21%2012:3:8.png?api=v2"></span></span></p><h3 id="DMITestplan-Ncore2.5-2.2.1.Monitors">2.2.1.  Monitors</h3><h4 id="DMITestplan-Ncore2.5-2.2.1.1.SFIMonitor(dv/common/lib_tb/sfi_monitor.svh)">2.2.1.1.   SFI Monitor (dv/common/lib_tb/sfi_monitor.svh)</h4><p>The SFI monitor looks at the SFI master and slave request and response interfaces between the DMI and the system BFM. The monitors are located under the {CONCERTO_TOP}/hw/dv/common/lib_tb area.</p><p>When collecting data, the SFI monitor collects all beats of data before sending a complete packet with all the data on the analysis port. With Cmc SFI monitor sent  per beat, because</p><p>RTL sent the address for lookup as soon as it receive first beat.</p><h4 id="DMITestplan-Ncore2.5-2.2.1.2.AXI4Monitor(dv/common/lib_tb/axi_monitor.svh)">2.2.1.2.   AXI4 Monitor (dv/common/lib_tb/axi_monitor.svh)</h4><p>The AXI4 monitor looks at the following AXI master channels between the DMI and the 3<sup>rd</sup> party AXI VIP:</p><ul><li>AXI Read Address Channel</li><li>AXI Read Data Channel</li><li>AXI Write Address Channel</li><li>AXI Write Data Channel</li><li>AXI Write Response Channel</li></ul><p>These channel are described by the ARM AMBA AXI4 spec.</p><p>On the data channels, the monitor will collect all beats of data before sending a complete packet with all the data.</p><p> </p><p><strong>2.2.1.3.  CCP Monitor (dv/common/lib_tb/ccp_monitor.svh) (with CMC )</strong></p><p> The CCP  monitor looks the following interface between DMI and CCP</p><ul><li>CCP ctrl interface</li><li>CCP wr data interface</li><li>CCP fill interface</li><li>CCP data rdrsp interface</li><li>CCP data evict interface</li><li>Maint op interface</li></ul><p>      </p><h3 id="DMITestplan-Ncore2.5-2.2.2.BFMs">2.2.2.  BFMs</h3><h4 id="DMITestplan-Ncore2.5-2.2.2.1.AXIBFM">2.2.2.1. AXI BFM</h4><p>The in-house ACE BFM will be configurable to act as an AXI BFM and will be used when the 3<sup>rd</sup> party VIP memory is not being used.</p><h4 id="DMITestplan-Ncore2.5-2.2.2.2.SystemBFM">2.2.2.2. System BFM</h4><p>The system is modeled by the dmi sequences located under {CONCERTO_TOP}/hw/dv/dmi/env/seq. The sequence keeps track of creation and reuse of IDs, and also decides based on command line inputs various parameters like number of commands in a test, type of packet to be sent next etc.</p><h2 id="DMITestplan-Ncore2.5-2.3.Checkers"><strong>2.3. Checkers</strong></h2><h3 id="DMITestplan-Ncore2.5-2.3.1DMIchecker">2.3.1 DMI checker</h3><p>The checker tracks all the transactions going into and coming out of the DMI and also checks the expected behavior of the DMI dynamically. </p><h3 id="DMITestplan-Ncore2.5-2.3.2CCPchecker">2.3.2 CCP checker</h3><p>The CCP checker tracks all the transactions at the DMI-CCP interface, it checks the expected state of cacheline and the data integrity.</p><p>It also checks replacement policy.</p><h2 id="DMITestplan-Ncore2.5-2.4.Injectors"><strong>2.4. Injectors</strong></h2><p>Double and single bit errors are injected using this logic.</p><h1 id="DMITestplan-Ncore2.5-3.ConfigurationSpace"><strong>3.   Configuration Space</strong></h1><h2 id="DMITestplan-Ncore2.5-3.1.ForConcertov2.5"><strong>3.1. For Concerto v2.5</strong></h2><p>Broadly, the configuration space is as follows:</p><p>1) DMI without cache</p><p>2) DMI with victim cache</p><p>3) DMI with hint cache</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p>Param</p></td><td class="confluenceTd"><p>Must Cover Values</p></td><td class="confluenceTd"><p>Nice to Cover</p></td></tr><tr><td class="confluenceTd"><p>wCacheLineOffset</p></td><td class="confluenceTd"><p>6</p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>wSecurityAttribute</p></td><td class="confluenceTd"><p>0,1</p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>wPriorityLevel</p></td><td class="confluenceTd"><p>0,3</p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>useResiliency</p></td><td class="confluenceTd"><p>0,1</p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>useHwDebug</p></td><td class="confluenceTd"><p>0,1</p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>useCmc</p></td><td class="confluenceTd"><p>0,1</p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>wxData</p></td><td class="confluenceTd"><p>64,128,256</p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>nMrdInFlight</p></td><td class="confluenceTd"><p>1,8,16</p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>nRttCtrlEntries</p></td><td class="confluenceTd"><p>1,32,64,96</p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>useRttDataEntries</p></td><td class="confluenceTd"><p>0,1</p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>fnErrDetectCorrect (Rtt Data)</p></td><td class="confluenceTd"><p>NONE,PARITY,SECDED</p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>useMemRspIntrlv</p></td><td class="confluenceTd"><p>0,1</p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>nWttCtrlEntries</p></td><td class="confluenceTd"><p>1,32,64,96</p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>nWttCtrlMemWr</p></td><td class="confluenceTd"><p>1,8,16,32</p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>nDtrInFlight</p></td><td class="confluenceTd"><p>1,8,16</p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>nHntSlaveIds</p></td><td class="confluenceTd"><p>0,4</p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>useAllocDtwData</p></td><td class="confluenceTd"><p>0,1</p></td><td class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" class="confluenceTd">useAllocMrdData</td><td colspan="1" class="confluenceTd">0,1</td><td colspan="1" class="confluenceTd"> </td></tr><tr><td class="confluenceTd"><p>nSets</p></td><td class="confluenceTd"><p>2,512,1024,2048</p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>nWays</p></td><td class="confluenceTd"><p>1,8,16</p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>nTagBank</p></td><td class="confluenceTd"><p>1,2</p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>nDataBank</p></td><td class="confluenceTd"><p>1,2,3,4</p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>fnReplPolType</p></td><td class="confluenceTd"><p>RANDOM, NRU</p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>useDinBuffer</p></td><td class="confluenceTd"><p>0,1</p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>useDoutBuffer</p></td><td class="confluenceTd"><p>0,1</p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>fnErrDetectCorrect(Tag)</p></td><td class="confluenceTd"><p>NONE,PARITY,SECDED</p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>fnErrDetectCorrect(Data)</p></td><td class="confluenceTd"><p>NONE,PARITY,SECDED</p></td><td class="confluenceTd"><p> </p></td></tr></tbody></table></div><h2 id="DMITestplan-Ncore2.5-3.2.DMIStaticConfigurations"><strong>3.2. DMI Static Configurations</strong></h2><h3 id="DMITestplan-Ncore2.5-3.2.1.NoCMC">3.2.1. No CMC</h3><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p>Parameter</p></td><td class="confluenceTd"><p>cfg1</p></td><td class="confluenceTd"><p>cfg2</p></td><td class="confluenceTd"><p>Cfg6</p></td></tr><tr><td class="confluenceTd"><p>wCacheLineOffset</p></td><td class="confluenceTd"><p>6</p></td><td class="confluenceTd"><p>6</p></td><td class="confluenceTd"><p>6</p></td></tr><tr><td class="confluenceTd"><p>wSecurityAttribute</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>0</p></td></tr><tr><td class="confluenceTd"><p>wPriorityLevel</p></td><td class="confluenceTd"><p>3</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>3</p></td></tr><tr><td class="confluenceTd"><p>useResiliency</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>1</p></td></tr><tr><td class="confluenceTd"><p>useHwDebug</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>1</p></td></tr><tr><td class="confluenceTd"><p>useCmc</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>0</p></td></tr><tr><td class="confluenceTd"><p>wxData</p></td><td class="confluenceTd"><p>256</p></td><td class="confluenceTd"><p>256</p></td><td class="confluenceTd"><p>64</p></td></tr><tr><td class="confluenceTd"><p>nMrdInFlight</p></td><td class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>7</p></td><td class="confluenceTd"><p>3</p></td></tr><tr><td class="confluenceTd"><p>nRttCtrlEntries</p></td><td class="confluenceTd"><p>96</p></td><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>1</p></td></tr><tr><td class="confluenceTd"><p>useRttDataEntries</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>1</p></td></tr><tr><td class="confluenceTd"><p>fnErrDetectCorrect (Rtt Data)</p></td><td class="confluenceTd"><p>SECDED128BITS</p></td><td class="confluenceTd"><p>NONE</p></td><td class="confluenceTd"><p>SECDED128</p></td></tr><tr><td class="confluenceTd"><p>useMemRspIntrlv</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>0</p></td></tr><tr><td class="confluenceTd"><p>nWttCtrlEntries</p></td><td class="confluenceTd"><p>96</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>96</p></td></tr><tr><td class="confluenceTd"><p>nWttCtrlMemWr</p></td><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>1</p></td></tr><tr><td class="confluenceTd"><p>nDtrInFlight</p></td><td class="confluenceTd"><p>16</p></td><td class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>4</p></td></tr></tbody></table></div><h3 id="DMITestplan-Ncore2.5-3.2.2.WithCMC">3.2.2. With CMC</h3><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p>Parameter</p></td><td class="confluenceTd"><p>cfg1</p></td><td class="confluenceTd"><p>cfg2</p></td><td class="confluenceTd"><p>cfg3</p></td><td class="confluenceTd"><p>cfg4</p></td><td class="confluenceTd"><p>cfg5</p></td><td class="confluenceTd"><p>Cfg6</p></td><td class="confluenceTd"><p>Cfg7</p></td><td class="confluenceTd"><p>Cfg8</p></td></tr><tr><td class="confluenceTd"><p>wCacheLineOffset</p></td><td class="confluenceTd">6</td><td class="confluenceTd">6</td><td class="confluenceTd">6</td><td class="confluenceTd">6</td><td class="confluenceTd">6</td><td class="confluenceTd">6</td><td class="confluenceTd">6</td><td class="confluenceTd">6</td></tr><tr><td class="confluenceTd"><p>wSecurityAttribute</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td></tr><tr><td class="confluenceTd"><p>wPriorityLevel</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>3</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>3</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>3</p></td><td class="confluenceTd"><p>3</p></td></tr><tr><td class="confluenceTd"><p>useResiliency</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>0</p></td></tr><tr><td class="confluenceTd"><p>useHwDebug</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td></tr><tr><td class="confluenceTd"><p>useCmc</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td></tr><tr><td class="confluenceTd"><p>wxData</p></td><td class="confluenceTd"><p>256</p></td><td class="confluenceTd"><p>64</p></td><td class="confluenceTd"><p>128</p></td><td class="confluenceTd"><p>128</p></td><td class="confluenceTd"><p>64</p></td><td class="confluenceTd"><p>128</p></td><td class="confluenceTd"><p>64</p></td><td class="confluenceTd"><p>64</p></td></tr><tr><td class="confluenceTd"><p>nMrdInFlight</p></td><td class="confluenceTd"><p>6</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>16</p></td><td class="confluenceTd"><p>15</p></td><td class="confluenceTd"><p>12</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>16</p></td><td class="confluenceTd"><p>16</p></td></tr><tr><td class="confluenceTd"><p>nRttCtrlEntries</p></td><td class="confluenceTd"><p>8</p></td><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>64</p></td><td class="confluenceTd"><p>96</p></td><td class="confluenceTd"><p>8</p></td><td class="confluenceTd"><p>16</p></td><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>4</p></td></tr><tr><td class="confluenceTd"><p>useRttDataEntries</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td></tr><tr><td class="confluenceTd"><p>fnErrDetectCorrect (Rtt Data)</p></td><td class="confluenceTd"><p>NONE</p></td><td class="confluenceTd"><p>SECDED128BITS</p></td><td class="confluenceTd"><p>SECDED64BITS</p></td><td class="confluenceTd"><p>SECDED128</p></td><td class="confluenceTd"><p>PARITY</p></td><td class="confluenceTd"><p>NONE</p></td><td class="confluenceTd"><p>PARITY8</p></td><td class="confluenceTd"><p>SECDED</p></td></tr><tr><td class="confluenceTd"><p>useMemRspIntrlv</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td></tr><tr><td class="confluenceTd"><p>nWttCtrlEntries</p></td><td class="confluenceTd"><p>16</p></td><td class="confluenceTd"><p>24</p></td><td class="confluenceTd"><p>8</p></td><td class="confluenceTd"><p>96</p></td><td class="confluenceTd"><p>16</p></td><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>24</p></td><td class="confluenceTd"><p>24</p></td></tr><tr><td class="confluenceTd"><p>nWttCtrlMemWr</p></td><td class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>3</p></td><td class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td></tr><tr><td class="confluenceTd"><p>nDtrInFlight</p></td><td class="confluenceTd"><p>12</p></td><td class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>16</p></td><td class="confluenceTd"><p>14</p></td><td class="confluenceTd"><p>3</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>2</p></td></tr><tr><td class="confluenceTd"><p>nHntSlaveIds</p></td><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>4</p></td></tr><tr><td class="confluenceTd"><p>useAllocDtwData</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td></tr><tr><td colspan="1" class="confluenceTd">useAllocMrdData</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">0</td></tr><tr><td class="confluenceTd"><p>nSets</p></td><td class="confluenceTd"><p>16</p></td><td class="confluenceTd"><p>32</p></td><td class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>32</p></td><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>64</p></td><td class="confluenceTd"><p>32</p></td><td class="confluenceTd"><p>32</p></td></tr><tr><td class="confluenceTd"><p>fnSetSelect</p></td><td class="confluenceTd"><p>GENERAL</p></td><td class="confluenceTd"><p>GENERAL</p></td><td class="confluenceTd"><p>GENERAL</p></td><td class="confluenceTd"><p>GENERAL</p></td><td class="confluenceTd"><p>GENERAL</p></td><td class="confluenceTd"><p>GENERAL</p></td><td class="confluenceTd"><p>GENERAL</p></td><td class="confluenceTd"><p>GENERAL</p></td></tr><tr><td class="confluenceTd"><p>nWays</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>8</p></td><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>4</p></td></tr><tr><td class="confluenceTd"><p>nTagBank</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>2</p></td></tr><tr><td class="confluenceTd"><p>nDataBank</p></td><td class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>2</p></td></tr><tr><td class="confluenceTd"><p>fnReplPolType</p></td><td class="confluenceTd"><p>NRU</p></td><td class="confluenceTd"><p>RANDOM</p></td><td class="confluenceTd"><p>NRU</p></td><td class="confluenceTd"><p>NRU</p></td><td class="confluenceTd"><p>NRU</p></td><td class="confluenceTd"><p>RANDOM</p></td><td class="confluenceTd"><p>RANDOM</p></td><td class="confluenceTd"><p>RANDOM</p></td></tr><tr><td class="confluenceTd"><p>useDinBuffer</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>0</p></td></tr><tr><td class="confluenceTd"><p>useDoutBuffer</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td></tr><tr><td class="confluenceTd"><p>fnErrDetectCorrect(Tag)</p></td><td class="confluenceTd"><p>SECDED</p></td><td class="confluenceTd"><p>PARITY</p></td><td class="confluenceTd"><p>SECDED</p></td><td class="confluenceTd"><p>SECDED64</p></td><td class="confluenceTd"><p>NONE</p></td><td class="confluenceTd"><p>NONE</p></td><td class="confluenceTd"><p>PARITY</p></td><td class="confluenceTd"><p>SECDED64</p></td></tr><tr><td class="confluenceTd"><p>fnErrDetectCorrect(Data)</p></td><td class="confluenceTd"><p>PARITY</p></td><td class="confluenceTd"><p>PARITY16</p></td><td class="confluenceTd"><p>NONE</p></td><td class="confluenceTd"><p>SECDED64</p></td><td class="confluenceTd"><p>SECDED64</p></td><td class="confluenceTd"><p>NONE</p></td><td class="confluenceTd"><p>PARITY16</p></td><td class="confluenceTd"><p>SECDED</p></td></tr></tbody></table></div><h3 id="DMITestplan-Ncore2.5-3.2.3ExtendedVictimCache"><strong>3.2.3 Extended Victim Cache</strong></h3><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p>Parameter</p></td><td class="confluenceTd"><p>cfg9</p></td><td class="confluenceTd"><p>cfg10</p></td><td colspan="1" class="confluenceTd"><p>Cfg11</p></td><td class="confluenceTd"><p>cfg12</p></td><td class="confluenceTd"><p>Cfg13</p></td></tr><tr><td class="confluenceTd"><p>wCacheLineOffset</p></td><td class="confluenceTd">6</td><td class="confluenceTd">6</td><td colspan="1" class="confluenceTd">6</td><td class="confluenceTd">6</td><td class="confluenceTd">6</td></tr><tr><td class="confluenceTd"><p>wSecurityAttribute</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>0</p></td><td colspan="1" class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>1</p></td></tr><tr><td class="confluenceTd"><p>wPriorityLevel</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>3</p></td><td colspan="1" class="confluenceTd"><p>3</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>3</p></td></tr><tr><td class="confluenceTd"><p>useResiliency</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>0</p></td><td colspan="1" class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>0</p></td></tr><tr><td class="confluenceTd"><p>useHwDebug</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>0</p></td><td colspan="1" class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td></tr><tr><td class="confluenceTd"><p>useCmc</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td><td colspan="1" class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td></tr><tr><td class="confluenceTd"><p>wxData</p></td><td class="confluenceTd"><p>256</p></td><td class="confluenceTd"><p>256</p></td><td colspan="1" class="confluenceTd"><p>64</p></td><td class="confluenceTd"><p>128</p></td><td class="confluenceTd"><p>64</p></td></tr><tr><td class="confluenceTd"><p>nMrdInFlight</p></td><td class="confluenceTd"><p>6</p></td><td class="confluenceTd"><p>1</p></td><td colspan="1" class="confluenceTd"><p>16</p></td><td class="confluenceTd"><p>16</p></td><td class="confluenceTd"><p>16</p></td></tr><tr><td class="confluenceTd"><p>nRttCtrlEntries</p></td><td class="confluenceTd"><p>8</p></td><td class="confluenceTd"><p>8</p></td><td colspan="1" class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>64</p></td><td class="confluenceTd"><p>4</p></td></tr><tr><td class="confluenceTd"><p>useRttDataEntries</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>0</p></td><td colspan="1" class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td></tr><tr><td class="confluenceTd"><p>fnErrDetectCorrect (Rtt Data)</p></td><td class="confluenceTd"><p>NONE</p></td><td class="confluenceTd"><p>NONE</p></td><td colspan="1" class="confluenceTd"><p>SECDED128BITS</p></td><td class="confluenceTd"><p>SECDED64BITS</p></td><td class="confluenceTd"><p>PARITY8</p></td></tr><tr><td class="confluenceTd"><p>useMemRspIntrlv</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>0</p></td><td colspan="1" class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td></tr><tr><td class="confluenceTd"><p>nWttCtrlEntries</p></td><td class="confluenceTd"><p>16</p></td><td class="confluenceTd"><p>1</p></td><td colspan="1" class="confluenceTd"><p>24</p></td><td class="confluenceTd"><p>8</p></td><td class="confluenceTd"><p>24</p></td></tr><tr><td class="confluenceTd"><p>nWttCtrlMemWr</p></td><td class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>1</p></td><td colspan="1" class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>1</p></td></tr><tr><td class="confluenceTd"><p>nDtrInFlight</p></td><td class="confluenceTd"><p>12</p></td><td class="confluenceTd"><p>12</p></td><td colspan="1" class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>16</p></td><td class="confluenceTd"><p>2</p></td></tr><tr><td class="confluenceTd"><p>nHntSlaveIds</p></td><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>0</p></td><td colspan="1" class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>4</p></td></tr><tr><td class="confluenceTd"><p>useAllocDtwData</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td><td colspan="1" class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td></tr><tr><td colspan="1" class="confluenceTd">useAllocMrdData</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">1</td></tr><tr><td class="confluenceTd"><p>nSets</p></td><td class="confluenceTd"><p>16</p></td><td class="confluenceTd"><p>16</p></td><td colspan="1" class="confluenceTd"><p>32</p></td><td class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>32</p></td></tr><tr><td class="confluenceTd"><p>fnSetSelect</p></td><td class="confluenceTd"><p>GENERAL</p></td><td class="confluenceTd"><p>GENERAL</p></td><td colspan="1" class="confluenceTd"><p>GENERAL</p></td><td class="confluenceTd"><p>GENERAL</p></td><td class="confluenceTd"><p>GENERAL</p></td></tr><tr><td class="confluenceTd"><p>nWays</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td><td colspan="1" class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>8</p></td><td class="confluenceTd"><p>4</p></td></tr><tr><td class="confluenceTd"><p>nTagBank</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td><td colspan="1" class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>2</p></td></tr><tr><td class="confluenceTd"><p>nDataBank</p></td><td class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>2</p></td><td colspan="1" class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>2</p></td></tr><tr><td class="confluenceTd"><p>fnReplPolType</p></td><td class="confluenceTd"><p>NRU</p></td><td class="confluenceTd"><p>RANDOM</p></td><td colspan="1" class="confluenceTd"><p>RANDOM</p></td><td class="confluenceTd"><p>NRU</p></td><td class="confluenceTd"><p>RANDOM</p></td></tr><tr><td class="confluenceTd"><p>useDinBuffer</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>0</p></td><td colspan="1" class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>0</p></td></tr><tr><td class="confluenceTd"><p>useDoutBuffer</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>1</p></td><td colspan="1" class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>1</p></td></tr><tr><td class="confluenceTd"><p>fnErrDetectCorrect(Tag)</p></td><td class="confluenceTd"><p>SECDED</p></td><td class="confluenceTd"><p>NONE</p></td><td colspan="1" class="confluenceTd"><p>PARITY</p></td><td class="confluenceTd"><p>SECDED</p></td><td class="confluenceTd"><p>PARITY</p></td></tr><tr><td colspan="1" class="confluenceTd"><p>fnErrDetectCorrect(Data)</p></td><td colspan="1" class="confluenceTd"><p>PARITY</p></td><td colspan="1" class="confluenceTd"><p>NONE</p></td><td colspan="1" class="confluenceTd"><p>PARITY16</p></td><td colspan="1" class="confluenceTd"><p>NONE</p></td><td colspan="1" class="confluenceTd"><p>PARITY16</p></td></tr></tbody></table></div><p><strong><br/></strong></p><h1 id="DMITestplan-Ncore2.5-"><strong><br/></strong></h1><h1 id="DMITestplan-Ncore2.5-4.Features"><strong>4.   Features</strong></h1><h2 id="DMITestplan-Ncore2.5-4.1.ArchitecturalFeatures"><strong>4.1.  Architectural Features</strong></h2><h3 id="DMITestplan-Ncore2.5-4.1.1.MRDs(CMPSv0.18section7.3)">4.1.1.  MRDs (CMPSv0.18 section 7.3)</h3><div class="table-wrap"><table class="confluenceTable"><thead><tr><td class="confluenceTd"><p><strong>Scenario</strong></p></td><td class="confluenceTd"><p><strong>Hash Tag</strong></p></td><td class="confluenceTd"><p><strong>Implemented?</strong></p></td></tr></thead><tbody><tr><td class="confluenceTd"><p>After receiving MRDreq , the DMI cannot  receive subsequent HNTreq or MRDreq to the same cacheline address until the MRDrsp message and DTRreq message have been issued for MRDreq</p><p>After receiving MRDreq, the DMI cannot  receive subsequent DTWreq to same cacheline address until the DTRreq message have been issued for MRdreq</p><p>Cover that this happens. The RTT entry has not sent MRD/HNTrsp and it sees a DTW to same address. Check that this DTW does not set its rdOutstanding incorrectly.</p></td><td class="confluenceTd"><p>#Check.DMI.v2.newDtwBeforeMrdRsp, #Check.DMI.v2.newHntBeforeHntRsp,</p><p>#Cov.DMI.v2.inComingDtwSendAxiWithoutMrdRsp</p><p> </p><p> </p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p><u>AR Channel:</u></p><p>Tests should cover all possible listed values of the following signals:</p><p>ARLEN[7:0]: System_cacheline_size / AWSIZE.</p><p>ARSIZE[2:0]: Matches configured SFI slave data bus width equal  wXData</p><p>ARBURST[1:0]: Equal to BurstType on SFI Slave IF. Always INCR</p><p>ARLOCK[0:0]: Normal</p><p>ARCACHE[3:0]: Equal to SFIPriv-AceCACHE on SFI slave bus.</p><p>ARPROT[2:0]: Equal to SFIPriv-AcePROT on SFI slave bus.</p><p>ARQOS[3:0]: Equal to SFIPriv-AceQOS on SFI slave bus.</p><p>ARREGION[3:0]: Equal to SFIPriv-AceREGION on SFI slave bus.</p><p>ARUSER[N:0]: Equal to SFIPriv-AceUSER on SFI slave bus. Pass through values on SFI interface</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.ARRandomize</p></td><td class="confluenceTd">DONE</td></tr><tr><td class="confluenceTd"><p><u>R Channel:</u></p><p>Tests should cover all possible listed values of the following signals:</p><p>RRESP[1:0]: Try all values</p><p>RUSER[N:0]: filed of  wr_req_sfiPriv if  wArUser is set</p><p>RDATA: Try interesting values -&gt; This is random</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.RRespLegalValues</p><p>#Check.DMI.v2.RDataMatchesFill</p><p>#Check.DMI.v2.RDataMatchesDtr</p><p>#Check.DMI.v2.CacheReadMatchesDtr</p></td><td class="confluenceTd">DONE</td></tr><tr><td class="confluenceTd"><p>Check that maxMrdsInFlight limit isn’t exceeded</p></td><td class="confluenceTd"><p>#Check.DMI.v2.maxMrdInFlightNotExceeded</p><p>#Cov.DMI.v2.nMrdInFlight</p></td><td class="confluenceTd">DONE</td></tr><tr><td class="confluenceTd"><p>Cover Dtr starts alongwith rdata. This is only true for non-interleaved case.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.DtrStartsAlongWithRData</p></td><td class="confluenceTd">DONE</td></tr><tr><td class="confluenceTd"><p>Test sequence of MRDs followed by DTWs and vice versa for all types of MRDs crossed with all types other MRDs / DTWs. Repeat for alternating transactions to same address (MRD-MRD, MRD-DTW) of all types. Don’t forget to include Flushes.</p></td><td class="confluenceTd"><p>#Test.DMI.v2.DirectedMrdDtw</p><p>#Test.DMI.v2.AlternateMrdDtw</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Test sequence of MRDs followed by HNTs and vice versa for all types of MRDs. Repeat for alternating transactions to same address. Don’t forget to include Flushes.</p></td><td class="confluenceTd"><p>#Test.DMI.v2.DirectedMrdHnt</p><p>#Test.DMI.v2.AlternateMrdHnt</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Cover req2 to most recently freed address. Cross with all transactions types for req1 and req2. This includes read, writes and hints.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.ReuseRecentlyUsed</p></td><td class="confluenceTd">DONE</td></tr></tbody></table></div><h4 id="DMITestplan-Ncore2.5-4.1.1.1.MRDs(nonFlush)withCMC">4.1.1.1.  MRDs (non Flush) with CMC</h4><div class="table-wrap"><table class="confluenceTable"><thead><tr><td class="confluenceTd"><p><strong>Scenario</strong></p></td><td class="confluenceTd"><p><strong>Hash Tag</strong></p></td><td class="confluenceTd"><p><strong>Implemented?</strong></p></td></tr></thead><tbody><tr><td class="confluenceTd"><p>Cover that incoming MRD has cache resource in dirty, invalid and clean states</p></td><td class="confluenceTd"><p> #Cov.DMI.v2.incomingMrdHitAllCacheStates</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Cover that incoming MRD hits existing MRD entry in various states. AR, R, data received but not written into cache.</p></td><td class="confluenceTd"><p> #Cov.DMI.v2.incomingMrdHitAllRttStates</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Cover MRD comes in on same cycle as cache fill is happening.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.MrdSameCycleAsFill</p><p>#Cov.DMI.v2.MrdCycleBeforeFill</p><p>#Cov.DMI.v2.MrdCycleAfterFill</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p><span class="legacy-color-text-red2">Cover crossing allocation attributes with CMC states. Add appropriate checks in scoreboard.</span></p></td><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p><span class="legacy-color-text-red2">Assert that MRDreq cannot match an RTT resource in speculative or read state and a CMC resource.</span></p></td><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p><span class="legacy-color-text-red2">Check that on MRD hit and resource is dirty, DMI performs eviction. Check that if resource is clean / invalid, there is no eviction.</span></p></td><td class="confluenceTd"><p>#Cov.DMI.v2.MrdEvictDtydata</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Cover that a 'remove' policy leads to eviction on MRD 'hit'.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.RemoveEvictMrdHit</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Cross above with all types of MRDs.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.EvictMrdHitTypes</p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>Cover/Test that an MRD causes backpressure even if RTT resources are available, but not WTT for the resulting evict.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.MRDBackPressureWTTRTTavail</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Cover that an MRDFlush gets backpressured due to lack of WTT resources.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.MRDBackPressureWTT</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p><span class="legacy-color-text-red2">Test that with RTTData, the DMI cannot backpressure on the R channel.</span></p></td><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>For 'remove' type, an MRD hit should cause an evict if dirty. This should also invalidate the entry. Check this if possible or punt to CCP folks. Cover that this scenario happens.</p></td><td class="confluenceTd"><p>#Check.DMI.CMC.EvictionOnDty</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Cover MRD to same address on cycle after DTR is sent.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.MRDSameAddrNextCycle</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Cover all MRD types causing all CCP transitions of cacheline. Combinations of SS-&gt;ES. Table 93 in section 7.3.1 of CMPS.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.MRDCausesCCPTransitions</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p><span class="legacy-color-text-red2">Add additional ordering checks based on time to ensure that ordering of MRD is maintained wrt. older HNTs and writes / evicts. (P2)</span></p></td><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><ol><li>Check that an MRD that is a CMC miss, and hits a WTT resource with write outstanding. <span class="legacy-color-text-red2">Add a coverpoint for this.</span></li><li>Memory read request will be sent after receiving the write response.</li></ol></td><td class="confluenceTd"><p>#Check.DMI.v2.MRDHitwithWTTwithWrOutstanding</p><p> </p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p><span class="legacy-color-text-red2">Check that an MRD that is a CMC hit, and hits a WTT resource is serviced ASAP without waiting for write response. Add coverpoint for this case.</span></p></td><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>Cover DTRreq going ahead of MRDrsp.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.MRDNonFlushDTRreqAheadOfMRDrsp</p></td><td class="confluenceTd"><p>DONE</p></td></tr></tbody></table></div><h4 id="DMITestplan-Ncore2.5-4.1.1.2.MRDFlushwithCMC">4.1.1.2.  MRDFlush with CMC</h4><div class="table-wrap"><table class="confluenceTable"><thead><tr><td class="confluenceTd"><p><strong>Scenario</strong></p></td><td class="confluenceTd"><p><strong>Hash Tag</strong></p></td><td class="confluenceTd"><p><strong>Implemented?</strong></p></td></tr></thead><tbody><tr><td class="confluenceTd"><p>Cover MRDFlush matches an existing MRD. Cover Flush hits an Hnt with rd outstanding.</p></td><td class="confluenceTd"><p> #Cov.DMI.v2.MRDFlushMatchesHNT</p><p>#Cov.DMI.v2.MRDFlushHitsHNTrdOutstanding</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p> Cover MRDFlush is a CMC miss. Add checks for this case.</p></td><td class="confluenceTd"><p> #Cov.DMI.v2.MRDFlushCMCMiss</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p> Flush is a hit, cover both visibility attributes. Cover the cache being in clean and dirty states for both the attributes. Add checks based on table 95 in CMPS.</p></td><td class="confluenceTd"><p> #Cov.DMI.v2.MRDFlushVisibilityAttributes</p><p>#Cov.DMI.v2.MRDFlushVisibilityXCleanDirty</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Check that for a Flush hitting an outstanding DTW (wrOutstanding), DTRRsp is not issued till Bresp is seen for this transaction. It is illegal to have another MRD / DTW to same address after, but you could have multiple writes outstanding to that address from earlier. Cover this scenario. Checks should check for all prior DTWs to be done, not just one.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.MultipleDTWsOutstandingtoMRDAddr</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Cover all SS-&gt;ES states for table 95 in CMPS.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.Table95States</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Add additional ordering checks based on time to ensure that ordering of MRD is maintained wrt. older HNTs and writes / evicts. (P2)</p></td><td class="confluenceTd"><p>#Check.DMI.v2.MRDFlushcollidewithHntWr</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Check if Flush matches RTT resource, waits for memory read response, discards data when received. Need coverpoint for this.</p></td><td class="confluenceTd"><p>#Check.DMI.v2.MRDFlushcollidewithHnt</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Check on DTR for Flush that both read and write outstanding are 0. This is mentioned above anyway, but this is more explicit.</p></td><td class="confluenceTd"><p>#Check.DMI.v2.DTRFlushRdandWrOutstandingZerro</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Cover DTRreq going ahead of MRDrsp.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.MRDFlushDTRreqAheadOfMRDrsp</p></td><td class="confluenceTd"><p>DONE</p></td></tr></tbody></table></div><h4 id="DMITestplan-Ncore2.5-4.1.1.3.MRDs(nonFlush)withoutCMC">4.1.1.3.  MRDs (non Flush) without CMC</h4><div class="table-wrap"><table class="confluenceTable"><thead><tr><td class="confluenceTd"><p><strong>Scenario</strong></p></td><td class="confluenceTd"><p><strong>Hash Tag</strong></p></td><td class="confluenceTd"><p><strong>Implemented?</strong></p></td></tr></thead><tbody><tr><td class="confluenceTd"><ol><li>With entry in WTT.  Cover that an incoming MRD hits an entry in the WTT_q with different states of WTT (for the same address). From review: This should be done probing RTL signals instead of looking at scb as below. Post review: After looking at RTL, the WTT is really simple, this would be seen better using the scoreboard queues.<br/>- no AW yet. <br/>- no W yet, but AW seen<br/>- both sent, but no Bresp<br/>- MRD can't come in till DtwResp is sent, but you can cross above post Dtwresp.<br/>- Multiple Wtt_q entries in scb with atleast 1 with wrOutstanding for each (this means that we cover RTL wtt wrOutstanding size 0-&gt;3.<br/>- Interesting cross is with same cycle bresp.<br/>- Cross every type of MRD with above coverpoints.</li></ol></td><td class="confluenceTd"><p> #Cov.DMI.v2.MRDHitsDifferentWttStates</p><p>#Cov.DMI.v2.CrossMRDHitsDifferentWttStates</p><p>#Cov.DMI.v2.MrdHitsMultipleDtwWithWrOutstanding</p><p>#Cov.DMI.v2.MrdSameCycleAsBResp</p><p>#Cov.DMI.v2.CrossMrdTypesWithWttStates</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>With entry in RTT</p><p>- MRDs cannot match in flight MRDs. Add TB assertion for this.</p></td><td class="confluenceTd"><p>#Check.DMI.v2.MrdNoMatchAnotherMrd</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>With hint outstanding</p><p>- hints are discarded</p></td><td class="confluenceTd"><p>#Check.DMI.v2.HintsDiscardedWithoutCache</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Cover DTR sent before MRDrsp for all MRD types</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.DtrBeforeMrdForAllTypes</p></td><td class="confluenceTd">DONE</td></tr></tbody></table></div><h4 id="DMITestplan-Ncore2.5-4.1.1.4.MRDFlushwithoutCMC">4.1.1.4.  MRDFlush without CMC</h4><div class="table-wrap"><table class="confluenceTable"><thead><tr><td class="confluenceTd"><p><strong>Scenario</strong></p></td><td class="confluenceTd"><p><strong>Hash Tag</strong></p></td><td class="confluenceTd"><p><strong>Implemented?</strong></p></td></tr></thead><tbody><tr><td class="confluenceTd"><ol><li><span>Cover MRDFlush matches an existing MRD. Cover Flush hits an MRD with both rd outstanding, and rd not outstanding. From review: This is not possible.</span></li><li>It can match an Hnt though.</li></ol></td><td class="confluenceTd"><p> #Check.DMI.v2.MRDFlushCannotMatchMrd.</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Check that for a Flush hitting an outstanding DTW (wrOutstanding), DTRRsp is not issued till Bresp is seen for this transaction. </p></td><td class="confluenceTd"><p> #Check.DMI.v2.FlushRspWaitsTillOutstandingBresp</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>It is illegal to have another <span>MRD</span> / DTW to same address after, but you could have multiple writes outstanding to that address from earlier. Cover this scenario (0-&gt;3). Checks should check for all prior DTWs to be done, not just one. </p></td><td class="confluenceTd"><p> #Cov.DMI.v2.MRDFlushHitsDifferentWttStates</p><p>#Cov.DMI.v2.FlushHitsOutstandingWrites0to3</p><p> #Check.DMI.v2.FlushRspWaitsTillAllOutstandingBresp</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Check on DTR for Flush that both read and write outstanding are 0. This is mentioned above anyway, but this is more explicit.</p></td><td class="confluenceTd"><p>#Check.DMI.v2.DtrHasNoRdOrWrOutstanding</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Cover DTRreq going ahead of MRDrsp.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.DTRbeforeMrdFlushRsp</p></td><td class="confluenceTd">DONE</td></tr></tbody></table></div><h3 id="DMITestplan-Ncore2.5-4.1.2.DTWs(CMPSv0.18section7.5)">4.1.2. DTWs (CMPSv0.18 section 7.5)</h3><div class="table-wrap"><table class="confluenceTable"><thead><tr><td class="confluenceTd"><p><strong>Scenario</strong></p></td><td class="confluenceTd"><p><strong>Hash Tag</strong></p></td><td class="confluenceTd"><p><strong>Implemented?</strong></p></td></tr></thead><tbody><tr><td class="confluenceTd"><p>For DTW all possible times for DTW to come in wrt older WTT entries, and add table. Probe rtl for these coverpoints. 11/4: Latest decision is to look at the dmi scoreboard since state machine does not capture enough state.</p></td><td class="confluenceTd"><p> #Cov.DMI.v2.newDtwHitsAllWttStates</p><p>#Cov.DMI.v2.newDtwHitsAllWrOutstanding</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Check DTWs should not come for a previous MRD, where the MRD still hasn't sent the DtrReq.</p></td><td class="confluenceTd"><p> #Check.DMI.v2.DtwHitsMrdWithoutDtr</p></td><td class="confluenceTd">DONE</td></tr><tr><td class="confluenceTd"><p>Cover DTW coming in for a previous HNT, where the RTT entry is in different states.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.DtwHitsHntAllStates</p><p>#Check.DMI.v2.IncomingDtwMarksHntStale</p></td><td class="confluenceTd">DONE</td></tr><tr><td class="confluenceTd"><p>Cover DTWrsp sent before and after AW/W/Bresp for all types of DTWs.</p></td><td class="confluenceTd"><p> #Cov.DMI.v2.DtwRspBeforeAfterDifferentAxi</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Cover outstanding write counter's all values from 0-3 (as of now). 11/04:</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.WttWrOutstandingcounter</p><p> </p></td><td class="confluenceTd">DONE</td></tr><tr><td class="confluenceTd"><p><u>AW Channel</u></p><p>Tests should cover all possible listed values of the following signals:</p><p>AWLEN[7:0]: System_cacheline_size / AWSIZE.</p><p>AWSIZE[2:0]: Matches configured SFI slave data bus width. equal to wXData</p><p>AWBURST[1:0]: Equal to BurstType on SFI Slave IF. INCR/ WRAP</p><p>AWLOCK[0:0]: 0 (Normal)</p><p>AWCACHE[3:0]: Equal to SFIPriv-AceCACHE on SFI slave bus.</p><p>AWPROT[2:0]: Equal to SFIPriv-AcePROT on SFI slave bus.</p><p>AWQOS[3:0]: Equal to SFIPriv-AceQOS on SFI slave bus.</p><p>AWREGION[3:0]: Equal to SFIPriv-AceREGION on SFI slave bus.</p><p>AWUSER[N:0]: Equal to SFIPriv-AceUSER on SFI slave bus. Pass through values from the SFI interface.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.AWChannelRandomize</p></td><td class="confluenceTd">DONE</td></tr><tr><td class="confluenceTd"><p><u>W Channel</u></p><p>Tests should cover all possible listed values of the following signals:</p><p>WSTRB[N:0]: Try all values</p><p>WUSER[N:0]: a filed of  wr_req_sfiPriv if  wAwUser is set</p><p>WDATA:  We randomize this.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.WChannelRandomize</p><p>#Check.DMI.v2.WriteDataWithCache</p><p>#Check.DMI.v2.WriteDataWithSFI</p><p>#Check.DMI.v2.CacheDataWithSFI</p></td><td class="confluenceTd">DONE</td></tr><tr><td class="confluenceTd"><p>Tests should cover all possible listed values of the following signals:</p><p>BRESP[1:0]: All values</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.LegalBrespValues</p></td><td class="confluenceTd">DONE</td></tr><tr><td class="confluenceTd"><p>Cover ordering amongst AW and W across write types.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.AWOrderingWithW</p></td><td class="confluenceTd">DONE</td></tr><tr><td class="confluenceTd"><p>Cover consecutive writes to same address.</p><p>Cross all types</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.BackToBackSameAddrWrites</p></td><td class="confluenceTd">DONE</td></tr><tr><td class="confluenceTd"><p>Cover all DtwResp sent, no AXI transactions seen</p><p>Cover no DtwResp sent, all AXI transactions done</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.AllDtwRespNoAxi</p><p>#Cov.DMI.v2.NoDtwRespAllAxi</p></td><td class="confluenceTd">DONE</td></tr><tr><td class="confluenceTd"><p>SFI channel backpressures only once Wtt is full, as long as wrOutstanding counter isn’t at max value.</p></td><td class="confluenceTd"><p>#Check.DMI.v2.NoSfiSlvBackpressureTillWttFull</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Test sequence of DTWs followed by HNTs and vice versa. Repeat for alternating DTW – HNTs to same address</p></td><td class="confluenceTd"><p>#Test.DMI.v2.DirectedDtwHnt</p><p>#Test.DMI.v2.AlternatingDtwHnt</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>11/07 review: Cover WrOutstanding counter to be maxed out, and we get a new Dtw. Add checks for this.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.CoverWrOutstandingMaxedNewDtw</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>11/07 review: WrOutstanding counter is configurable. Cover interesting values of this.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.CoverWrOutstandingValues</p></td><td class="confluenceTd"><p>DONE</p></td></tr></tbody></table></div><h4 id="DMITestplan-Ncore2.5-4.1.2.1.DTWswithCMC">4.1.2.1.  DTWs with CMC</h4><div class="table-wrap"><table class="confluenceTable"><thead><tr><td class="confluenceTd"><p><strong>Scenario</strong></p></td><td class="confluenceTd"><p><strong>Hash Tag</strong></p></td><td class="confluenceTd"><p><strong>Implemented?</strong></p></td></tr></thead><tbody><tr><td class="confluenceTd"><ol><li>Cover that incoming DTW has cache in dirty, invalid and clean states</li></ol></td><td class="confluenceTd"><p> #Cov.DMI.v2.DTWHitsAllCacheStates</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p> Cover that with AR/R channel backpressure, DTWs of all types still make progress. Same for backpressure due to not being able to sent DTRs. Applies to both request and response.</p></td><td class="confluenceTd"><p> #Cov.DMI.v2.DTWArRchannelbackpressure</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><ol><li>Cover Dtw hits a Wtt entry with entry being in different states.</li><li>- No Aw</li><li>- no w.</li><li>- an entry due to an evict vs. an entry due to a dtw.</li><li>- With multiple writes outstanding, can cross new dtw with different states for each of these outstanding writes.</li><li>- Cross the new Dtw having different visibility and allocation attributes, and result of a CMC lookup.</li></ol></td><td class="confluenceTd"><p>#Cov.DMI.v2.DTWCacheHitsWTTNoAw</p><p>#Cov.DMI.v2.DTWCacheHitsWTTNoW</p><p>#Cov.DMI.v2.DTWCacheHitsWTTFromEvictDTW</p><p>#Cov.DMI.v2.DTWCacheHitsWTTDtwAttrs</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Check that for a given address hitting another WTT entry, the same ID is reused for the AXI transaction. Check that for an address that is new, a new AWID is seen and not one in use.</p></td><td class="confluenceTd"><p>#Check.DMI.v2.AwIdReusedbysameAddr</p><p>#Check.DMI.v2.newAwIdusedbynewAddr</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Check that for a given address the write outstanding counter isn't exceeded. Assert that if the write outstanding counter is hit, the ready on the sfi slave req if is deasserted.</p></td><td class="confluenceTd"><p>#Check.DMI.v2.SFIslveReqdeassertwithMaxWroutstandingcnt</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Check DtwDataPlt as per Refer table 7 of  DMI Arch Doc.</p><p>Cove weird Wrap case</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.WeirdWrapDTWPtl</p><p>#Check.DMI.v2.DTWCacheDtwDataPtlVisible</p><p>#Check.DMI.v2.DTWCacheDtwDataPtlAlloc</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Check DtwDataDty   as per Refer table 7 of  DMI Arch Doc.</p></td><td class="confluenceTd"><p>#Check.DMI.v2.DTWCacheDtwDataDtyVisible</p><p>#Check.DMI.v2.DTWCacheCmcMissAllocateStates</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Check DtwDataCln   as per Refer table 7 of  DMI Arch Doc.</p></td><td class="confluenceTd"><p>#Check.DMI.v2.DTWCacheDtwDataClnVisible</p><p>#Check.DMI.v2.DTWCacheDtwDataClnAlloc</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>On every write response, oldest scoreboard entry needs to be deleted if the DtwRsp has been sent.</p></td><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><ol><li>Cover 0-nWrOutstanding entries each with BResp coming in</li><li>- before the DtwRsp</li><li>- after the DtwRsp</li></ol><p>Extending above case, cover a Dtw coming in with the previous Dtw in various states of AW, W and B being sent or not.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.DTW.ZeronWrOutstandingBresp</p><p> </p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Cover multiple AW,W being sent for an address, but no B response.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.DTWCacheAWWNoBresp</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Since there is no DTWData storage, system cannot have multiple entries to same address that have not sent AW or W. Add assert for this? Q: Can there be multiple entries (different addresses) that haven't sent AW/W?</p></td><td class="confluenceTd"><p>#Check.DMI.v2.MultileWrPendingwithoutWdata</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Ordering checks for every memory write to check that an AW/W doesn't have any write/read outstanding.</p></td><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>In addition to normal ordering checks, consider adding timing based checks to make sure ordering is maintained (P2).</p></td><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><ol><li>Check that a RTT resource in speculative state (i.e.servicing a hint) is marked stale and doesn't do a fill on the read response. Allocated way is de-allocated by writing on  CCP fill ctrl interface</li><li>- Check that the RTT resource is deallocated upon receipt of memory read response. Cover this. WrOutstanding is not set here.</li><li>- Unless it gets a MRD in the interim, in which case, it is reissued. Cover this. Check that this reissue does not happen until the Wr response is seen and wrOutstanding is not not set. In other words, if a stale entry is hit by a read, check if there is a wrOutstanding and mark it so.</li></ol></td><td class="confluenceTd"><p>#Cov.DMI.v2.DTWCacheRTTDeallocatedOnMRDrsp</p><p>#Check.DMI.v2.StaledHntdeallocated</p><p>#Check.DMI.v2.MrdHitwithstaledHnt</p><p> </p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Assert that if a DTW matches an MRD, it doesn't hit a CMC resource.</p></td><td class="confluenceTd"><p>#Check.DMI.v2.0.DTWcollidewithMRD</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Cover DTWreq message of different types causing two memory writes.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.DTWreqsCauseTwoMemoryWrites</p></td><td class="confluenceTd"><p>DONE</p></td></tr></tbody></table></div><h4 id="DMITestplan-Ncore2.5-4.1.2.2.DTWswithoutCMC">4.1.2.2.  DTWs without CMC</h4><div class="table-wrap"><table class="confluenceTable"><thead><tr><td class="confluenceTd"><p><strong>Scenario</strong></p></td><td class="confluenceTd"><p><strong>Hash Tag</strong></p></td><td class="confluenceTd"><p><strong>Implemented?</strong></p></td></tr></thead><tbody><tr><td class="confluenceTd"><p>With entry in WTT.</p><p>- no AW yet</p><p>- no W, but AW sent (consider while W is being sent if this is a separate state in the RTL)</p><p>-both sent, no BRESP</p><p>- on same cycle as BRESP</p><p>- Check that we can't see new DTW2 without DTWrsp1</p><p>- Multiple writes outstanding to same cacheline (0-&gt;3).</p><p>Most of this is covered in Section 4.1.2.1</p></td><td class="confluenceTd"><p> #Check.DMI.v2.NoDtw2WithoutDtwRsp1</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>With entry in RTT</p><p>- if entry is hint, mark hint stale. Flag error as this is not possible without cache</p><p>- if entry is mrd, error. This is illegal stimulus.</p></td><td class="confluenceTd"><p> #Check.DMI.v2.WithCacheMarkHintStaleOnDtw</p><p>#Check.DMI.v2.WithoutCacheDtwCannotMatchHint</p><p>#Check.DMI.v2.DtwCannotMatchMrd</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>With hint outstanding</p><p>- hints are discarded. Cover getting these back to back / without gap. Check this behavior.</p><p>- Cover that a DTW hits an hint that has not sent a HNTresp yet.</p></td><td class="confluenceTd"><p> #Cov.DMI.v2.DtwFollowsHint</p><p>#Cov.DMI.v2.HntFollowsDtw</p><p># Cov.DMI.v2.DtwFollowsHintNoGap</p><p>#Cov.DMI.v2.HntFollowsDtwNoGap</p><p>#Cov.DMI.v2.DtwHitsHintWithoutHntRsp</p></td><td class="confluenceTd"><p>DONE</p></td></tr></tbody></table></div><h3 id="DMITestplan-Ncore2.5-4.1.3.HNTs(CMPSv0.18section7.2)">4.1.3.  HNTs (CMPSv0.18 section 7.2)</h3><div class="table-wrap"><table class="confluenceTable"><thead><tr><td class="confluenceTd"><p><strong>Scenario</strong></p></td><td class="confluenceTd"><p><strong>Hash Tag</strong></p></td><td class="confluenceTd"><p><strong>Implemented?</strong></p></td></tr></thead><tbody><tr><td class="confluenceTd"><p> uArch section 5.0: Since the hint request FIFO is sized to be 4, check that 5th hint without response is dropped. This check should already exist from v1.6. This is sized to match parameter HntSlaveId.</p></td><td class="confluenceTd"><p>#Check.DMI.v2.MaxHntInFlightIs4</p><p>#Cov.DMI.v2.MaxHintInFlight (cover 1-4)</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Cover back to back hints to same address</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.BackToBackHintsSameAddr</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Cover different orders of AR,R and HntRsp. These apply only to the cache case.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.HntRspAxiOrdering</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Cover All responses sent, no AXI. Cover No responses sent all AXI done. Cross with all Fills done in the cache case.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.HntNoRspAllAxi</p><p>#Cov.DMI.v2.HntAllRspNoAxi</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Cache case: Assert that a HNT RTT entry cannot be freed although it is stale, till the data is received. We cover this when we cross DTW with all HNT RTT states.</p></td><td class="confluenceTd"><p>#Check.DMI.v2.FreeHntOnlyAfterData</p></td><td class="confluenceTd"><p>DONE</p></td></tr></tbody></table></div><h4 id="DMITestplan-Ncore2.5-4.1.3.1.HintswithCache">4.1.3.1. Hints with Cache</h4><div class="table-wrap"><table class="confluenceTable"><thead><tr><td class="confluenceTd"><p><strong>Scenario</strong></p></td><td class="confluenceTd"><p><strong>Hash Tag</strong></p></td><td class="confluenceTd"><p><strong>Implemented?</strong></p></td></tr></thead><tbody><tr><td class="confluenceTd"><ol><li>Cover: HNTreq does (not) cause eviction from CMC.</li></ol></td><td class="confluenceTd"><p>#Cov.DMI.v2.0.HntEvictedcacheline</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><ol><li> Cover: Hntreq causes hit in CMC.</li></ol></td><td class="confluenceTd"><p>#Cov.DMI.v2.0.HntreqHitcache</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><ol><li> Cover: HNTreq is discarded because RTT is full. HNTreq is discarded because WTT is full. Also cover case when both are full.</li></ol></td><td class="confluenceTd"><p>#Check.DMI.v2.0.HntdiscardedRTTfull</p><p>#Check.DMI.v2.0.HntdiscardedWTTfull</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Check that an HntReq cannot be present in both the Rtt and be a cache hit.</p></td><td class="confluenceTd"><p>#Check.DMI.v2.0.HntcantMatchinRTTandCaheHit</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Check that RdOutstanding Flag is set in RTT resouce when AR is sent. This applies to MRDs as well.</p></td><td class="confluenceTd"><p>#Check.DMI.v2.0.Rdoutstandingflgset</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Cover that hnt receives RData after it is stale i.e it has seen a DTW.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.0.HntStaledbeforeRData</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Cover HNT receives data on same cycle as incoming DTW matches HNT causing fill to be dropped.</p></td><td class="confluenceTd"><p>#Check.DMI.v2.0.HntRdatacollidewithDTW</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Check that every hint is processed after a hint req received earlier. Similarly it is processed in order with respect to any DTWreq or CMC eviction. Check can be done by comparing to existing RTT and WTT entries. This can also be checked by comparing that write outstanding flag is not set when AR is sent.</p></td><td class="confluenceTd"><p>#Check.DMI.v2.0.noWrOutStandingFlgARsentforHnt</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Check that another hint / mrd cannot be received for a hint that has not sent a response</p></td><td class="confluenceTd"><p>#Check.DMI.v2.0.NoHntMrdbeforeHntrsp</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Cover that a DTWreq is received for a hint that has not sent a response.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.0.DTWreqwithoutHntrsp</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Test that when RTT is backpressured, DTW req can still make progress.</p></td><td class="confluenceTd"><p>#Test.DMI.v2.0.RttbackPress</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Get hint when RTT is full (cross with only hints, only reads, and mix). Check that it is dropped.  </p></td><td class="confluenceTd"><p>#Cov.DMI.v2.HntReqRspWhenRttFul</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>De-assert sfi_mst_req_rdy forever. Send one HntReq and, once you see a AR read request, the DMI should be able to accept the read response (To prevent system deadlock, the DMI must be able to accept a memory read response for every memory read request that has been issued in response to an HNTreq message.)  (P2)</p></td><td class="confluenceTd"><p>(#Test.DMI.v2.RReadyNotZeroForeverBecauseOfSFIMstReqRdyEqualto0)</p></td><td class="confluenceTd"><p>DONE</p></td></tr></tbody></table></div><h4 id="DMITestplan-Ncore2.5-4.1.3.2.HintswithoutCache">4.1.3.2. Hints without Cache</h4><div class="table-wrap"><table class="confluenceTable"><thead><tr><td class="confluenceTd"><p><strong>Scenario</strong></p></td><td class="confluenceTd"><p><strong>Hash Tag</strong></p></td><td class="confluenceTd"><p><strong>Implemented?</strong></p></td></tr></thead><tbody><tr><td class="confluenceTd"><ol><li>Hints are discarded upon receipt. Only rsp is sent. Cross with entries in WTT states. Hint shoudn't allocate in RTT in the non-cache at all.</li></ol></td><td class="confluenceTd"><p> #Check.DMI.v2.NoCacheHntMatchWtt</p></td><td class="confluenceTd"><p>DONE</p></td></tr></tbody></table></div><h3 id="DMITestplan-Ncore2.5-4.1.4.DTRs(CMPSv0.18section7.4)">4.1.4. DTRs (CMPSv0.18 section 7.4)</h3><div class="table-wrap"><table class="confluenceTable"><thead><tr><td class="confluenceTd"><p><strong>Scenario</strong></p></td><td class="confluenceTd"><p><strong>Hash Tag</strong></p></td><td class="confluenceTd"><p><strong>Implemented?</strong></p></td></tr></thead><tbody><tr><td class="confluenceTd"><p> Cover that DTR system vis for a particular address is seen with more than one rtt queue entry matching this address. This is for scenario that MRDFlush hit an outstanding HNTreq.</p></td><td class="confluenceTd"><p> #Cov.DMI.DtrSysVisWithHintOutstanding</p><p>#Check.DMI.MrdFlushMarksHintStale</p></td><td class="confluenceTd"><p> DONE</p></td></tr></tbody></table></div><h3 id="DMITestplan-Ncore2.5-4.1.4.1.DTRswithCMC">4.1.4.1. DTRs with CMC</h3><div class="table-wrap"><table class="confluenceTable"><thead><tr><td class="confluenceTd"><p><strong>Scenario</strong></p></td><td class="confluenceTd"><p><strong>Hash Tag</strong></p></td><td class="confluenceTd"><p><strong>Implemented?</strong></p></td></tr></thead><tbody><tr><td class="confluenceTd"><ol><li> Table 96, section 7.4.1, cover all possible cases of mapping from MRD types to DTR. Make bins that are not allowed illegal. Cover different cache states as well.</li></ol></td><td class="confluenceTd"><p> #Cov.DMI.v2.DTRCacheTable96</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p> Cover that Dtr Sys Vis is seen for MRDFlush with CV and SV attributes crossed. Check that DTR Sys Vis is seen after the mem write response for SV and cacheline dirty. Cover this.</p></td><td class="confluenceTd"><p> #Cov.DMI.v2.DTRCacheDtrSysVisMRDFlush</p><p>#Cov.DMI.v2.DTRCacheMRDFlushSVDirty</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p> Check that for when the cacheline is clean/invalid, we don't expect any AXI transactions. Cover this, but this is already mentioned above. </p></td><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>Cover CV and all cache states, no AXI transaction needed here. Add checks for this.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.DTRCacheCVCacheStates</p></td><td class="confluenceTd"><p>DONE</p></td></tr></tbody></table></div><h4 id="DMITestplan-Ncore2.5-4.1.4.2.DTRsWithoutCMC">4.1.4.2.  DTRs Without CMC</h4><div class="table-wrap"><table class="confluenceTable"><thead><tr><td class="confluenceTd"><p><strong>Scenario</strong></p></td><td class="confluenceTd"><p><strong>Hash Tag</strong></p></td><td class="confluenceTd"><p><strong>Implemented?</strong></p></td></tr></thead><tbody><tr><td class="confluenceTd"><ol><li> Without the cache, table 96 cases fall into a smaller subset. Repeat coverage for these and marked not allowed cases illegal.</li></ol></td><td class="confluenceTd"><p>#Check.DMI.v2.NoCacheTable96</p><p>#Cover.DMI.v2.NoCacheTable96</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>From cache case above : “Cover that Dtr Sys Vis is seen for MRDFlush with CV and SV attributes crossed. Check that DTR Sys Vis is seen after the mem write response for SV and cacheline dirty. Cover this.”  Without the cache, there is never an AXI transaction for a flush - the DTR is always seen, add checks for this. 11/07: Add check for DTR that hits a WTT entry waits for bresp before it sends DTR sys vis. Cover MrdFlush hits a WTT in different states.</p></td><td class="confluenceTd"><p>#Check.DMI.v2.NoCacheNoAxiForFlush</p><p>#Check.DMI.v2.NoCacheCrossAttrWithFlush</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p> Cover DTRreq going out before MRDrsp for all types of Mrds.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.DTRreqBeforeMrdRsp</p></td><td class="confluenceTd"><p> DONE</p></td></tr></tbody></table></div><h3 id="DMITestplan-Ncore2.5-4.1.5.Transport">4.1.5. Transport</h3><div class="table-wrap"><table class="confluenceTable"><thead><tr><td class="confluenceTd"><p><strong>Scenario</strong></p></td><td class="confluenceTd"><p><strong>Hash Tag</strong></p></td><td class="confluenceTd"><p><strong>Implemented?</strong></p></td></tr></thead><tbody><tr><td class="confluenceTd"><p>Check that max DTR credits are not crossed. (i.e this is for transactions that are ready to send DTR but have not done so yet). Cover all values. Cover all DTRs in this pool being of one type only.</p></td><td class="confluenceTd"><p> #Check.DMI.v2.DtrMaxNotExceeded</p><p>#Cov.DMI.v2.DtrReadyButNotSent</p><p>#Cov.DMI.v2.AllDtrsInPoolSame</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Check that slvid matches the aiuId</p></td><td class="confluenceTd"><p> #Check.DMI.v2.DtrSlvIdMatchesAiuId</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Check that max dtr in flight is not crossed (requests that have not seen responses)</p></td><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Check that maxMrd messages allowed can be buffered without backpressure. Cover this. Cross with all MRDtypes.</p></td><td class="confluenceTd"><p>#Check.DMI.v2.MaxDtrCredits</p><p>#Cov.DMI.v2.DtrCreditsExhausted</p><p>.</p></td><td class="confluenceTd"><p>DONE</p></td></tr></tbody></table></div><h3 id="DMITestplan-Ncore2.5-4.1.6.InterfaceCoverpoints">4.1.6. Interface Coverpoints</h3><div class="table-wrap"><table class="confluenceTable"><thead><tr><td class="confluenceTd"><p><strong> Interface</strong></p></td><td class="confluenceTd"><p><strong>Scenario</strong></p></td><td class="confluenceTd"><p><strong>Hash Tag</strong></p></td><td class="confluenceTd"><p><strong>Implemented?</strong></p></td></tr></thead><tbody><tr><td class="confluenceTd"><p>sfi slave if (DTR)</p></td><td class="confluenceTd"><p>All different types of DTR seen.  These are encoded in SFI Priv.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.DtrAllTypes</p></td><td class="confluenceTd"><p> DONE</p></td></tr><tr><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p>cross different types of DTR with the allowed offset. Offset is also encoded in SFIPriv,</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.DtrOffsetsCrossed</p></td><td class="confluenceTd"><p> DONE</p></td></tr><tr><td class="confluenceTd"><p>sfi master if (MRD/DTW/HNT)</p></td><td class="confluenceTd"><p> all different types of MRD, DTW, HNT seen. These are encoded in SFI Priv</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.AllTransactionTypestypes</p><p> #Cov.DMI.v2.AlignLengthCrossWithAllDataTypes</p></td><td class="confluenceTd"><p> DONE</p></td></tr><tr><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p>cross all DTW types with alignments in cacheline</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.DtwAlignments</p></td><td class="confluenceTd"><p> DONE</p></td></tr><tr><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p>Cross all alignments on DTW with length of transaction. Look at incr_length coverpoint and extend this.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.DtwAlignments</p></td><td class="confluenceTd"><p> DONE</p></td></tr><tr><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p>AIU ID and AIU TransIDs are encoded in SFI Priv.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.AllAiuIdTransIdCovered</p></td><td class="confluenceTd"><p> DONE</p></td></tr><tr><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p>Cross existing address coverpoint with transaction types</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.CrossAddressWithAllTxnTypes</p></td><td class="confluenceTd"><p> DONE</p></td></tr><tr><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p>Extend all address coverpoints to cross with Security.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.CrossAddrWithSec</p></td><td class="confluenceTd"><p>DONE</p></td></tr></tbody></table></div><h3 id="DMITestplan-Ncore2.5-4.1.8.Miscchecks">4.1.8.  Misc checks</h3><div class="table-wrap"><table class="confluenceTable"><thead><tr><td class="confluenceTd"><p><strong>Scenario</strong></p></td><td class="confluenceTd"><p><strong>Hash Tag</strong></p></td><td class="confluenceTd"><p><strong>Implemented?</strong></p></td></tr></thead><tbody><tr><td class="confluenceTd"><p> Check that if CMC hit, no AR is sent</p></td><td class="confluenceTd"><p>#Check.DMI.v2.NoArwithCmcHit</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p> Check that on CMC miss, AR is sent if there is no hint pending.</p></td><td class="confluenceTd"><p>#Check.DMI.v2.ArSentNoHntInflight</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td></tr></tbody></table></div><h3 id="DMITestplan-Ncore2.5-4.1.9.Portedfromv1.5Hashtags">4.1.9. Ported from v1.5 Hashtags</h3><div class="table-wrap"><table class="confluenceTable"><thead><tr><td class="confluenceTd"><strong>Scenario</strong></td><td class="confluenceTd"><p><strong>Hash Tag</strong></p></td><td class="confluenceTd"><p><strong>Implemented?</strong></p></td></tr></thead><tbody><tr><td class="confluenceTd"><p>Cover each type of transaction having the same address as another, but with different security bit in both RTT and WTT.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.SameAddrDiffSecurity</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Add live checks for pressure similar to v1.6 by probing RTL signals.</p></td><td class="confluenceTd"><p>#Check.DMI.v2.Pressure</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Coverage to make sure that there are higher urgency requests which impact pressure calculation</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.HigherUrgencyOnReqThatContributeToPressure</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Add live transActv check ,EvictActv,FillActv,MaintActv</p></td><td class="confluenceTd"><p>#Check.DMI.v2.TransActvCheck</p><p>#Check.DMI.v2.EvictActvCheck</p><p>#Check.DMI.v2.FillActvCheck</p><p>#Check.DMI.v2.MaintActvCheck</p><p> </p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p> Cover RTT / WTT being full and no responses have been received from AXI mem.</p></td><td class="confluenceTd"><p> (#Check.DMI.v2.HntRspFields) (#Check.DMI.v2.DTRReqFields) (#Check.DMI.v2.DTWRspFields) (#Check.DMI.MRDRspFields)</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>We get nWtt unique addresses, wrOutstanding times each. As long as this is met, DMI does not backpressure on slave if. Directed test. High priority.</p></td><td class="confluenceTd"><p> #Check.DMI.v2.WTTFullAndNoNewDTWReqAccepted</p><p> </p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>HntReq should not get backpressured. Write a test which only sends HntReq and an assertion to check that the ready signal on sfi slave if is never de-asserted for this test. LP item.</p></td><td class="confluenceTd"><p>#Check.DMI.HNTReqIsNotBackPressured</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>AXI and SFI address widths should be the same</p></td><td class="confluenceTd"><p>#Check.DMI.v2.AXIAndSFIAddressWidthSame</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>JS TransId width checks #Check.DMI.v2.wTransIDFromSoftware This was added to tb_top for v1.6, maybe this is commented though.</p></td><td class="confluenceTd"><p>#Check.DMI.DtrReqSFIFields #Check.DMI.v2.wTransIDFromSoftware </p></td><td class="confluenceTd"><p>DONE</p></td></tr></tbody></table></div><h3 id="DMITestplan-Ncore2.5-4.1.10.ExtendedVictimCache(CMPS0.18section7.3.1Table94)">4.1.10. Extended Victim Cache (CMPS0.18 section7.3.1 Table94)</h3><div class="table-wrap"><table class="confluenceTable"><thead><tr><td class="confluenceTd"><p><strong>Scenario</strong></p></td><td class="confluenceTd"><p><strong>Hash Tag</strong></p></td><td class="confluenceTd"><p><strong>Implemented?</strong></p></td></tr></thead><tbody><tr><td class="confluenceTd"><p>Cover all MrdType hit/miss with alloc attribute 0/1,</p></td><td class="confluenceTd"><p>#Cover.DMI.v2.5.CrossMrdCacheStateAlloc</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Check only MrdRdCln and MrdRdVld will allocate on miss, MrdRdFlsh and MrdRdInv will behave same as remove policy</p></td><td class="confluenceTd"><p>#Check.DMI.v2.5.MrdRdCln&amp;MrdRdVldmiss,</p><p>#Check.DMI.v2.5.MrdRdFlsh&amp;MrdRdInvMiss,</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Check MrdRdCln with AL will retain cacheline on Hit CL/DR, no state change</p></td><td class="confluenceTd"><p>#Check.DMI.v2.5.MrdRdClnHit,</p><p> </p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd">Check MrdRdVld with AL will retain cacheline on hit CL, will remove cacheline if hit DR</td><td class="confluenceTd">#Check.DMI.v2.5.MrdRdVldHit</td><td class="confluenceTd">DONE</td></tr><tr><td class="confluenceTd">Check MrdRdFlsh will remove cacheline on hit , if cacheline DR it will do memory write</td><td class="confluenceTd">#Check.DMI.v2.5.MrdRdFlshHitDR</td><td class="confluenceTd">DONE</td></tr><tr><td colspan="1" class="confluenceTd">Check MrdRdFlsh will remove cacheline on hit and CL</td><td colspan="1" class="confluenceTd">#Check.DMI.v2.5.MrdRdFlshHitCL</td><td colspan="1" class="confluenceTd">DONE</td></tr><tr><td colspan="1" class="confluenceTd">Check MrdRdInv will remove cacheline on hit , no memory write</td><td colspan="1" class="confluenceTd">#Check.DMI.v2.5.MrdRdInvHit</td><td colspan="1" class="confluenceTd">DONE</td></tr></tbody></table></div><h2 id="DMITestplan-Ncore2.5-4.2.Micro-ArchitecturalFeatures">4.2. Micro-Architectural Features</h2><h3 id="DMITestplan-Ncore2.5-4.2.1.General(uarchsection5.0)">4.2.1. General (uarch section 5.0)</h3><div class="table-wrap"><table class="confluenceTable"><thead><tr><td class="confluenceTd"><p><strong>Scenario</strong></p></td><td class="confluenceTd"><p><strong>Hash Tag</strong></p></td><td class="confluenceTd"><p><strong>Implemented?</strong></p></td></tr></thead><tbody><tr><td class="confluenceTd"><ol><li>Consider probing P1 signals to get accurate timing info for RTT/WTT collision.</li></ol></td><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>Consider probing P2 signals to get cancel (by DMI) / replay (by CCP) info. Cover back to back replay case. Q: what is the max number of replays (consecutive) that can be of interest.</p></td><td class="confluenceTd"><p>#Check.DMI.v2.CancelReplayDropP2</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Test that replay stall is being asserted appropriately with correctable errors. Check that no transaction is dropped. Cover this happening with both reads and writes and for all replay sizes</p></td><td class="confluenceTd"><p>#Check.DMI.v2.NoTxnDroppedduetocorrectableError</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td><td class="confluenceTd"> </td></tr></tbody></table></div><h3 id="DMITestplan-Ncore2.5-4.2.4.MRDFlush(uarchsection5.0)">4.2.4.  MRD Flush (uarch section 5.0)</h3><div class="table-wrap"><table class="confluenceTable"><thead><tr><td class="confluenceTd"><p><strong>Scenario</strong></p></td><td class="confluenceTd"><p><strong>Hash Tag</strong></p></td><td class="confluenceTd"><p><strong>Implemented?</strong></p></td></tr></thead><tbody><tr><td class="confluenceTd"><p>Cache resource dirty</p><ol><li>check that Wtt entry is allocated in P2.</li><li>check that the DTR sys vis is issued only once the Bresp is seen for this write.</li></ol></td><td class="confluenceTd"><p>#Check.DMI.v2.MrdFlushDTRsysVisafterBresp</p></td><td class="confluenceTd"><p>DONE</p></td></tr></tbody></table></div><h3 id="DMITestplan-Ncore2.5-4.2.5.DTW(uarchsection5.0)">4.2.5.  DTW (uarch section 5.0)</h3><div class="table-wrap"><table class="confluenceTable"><thead><tr><td class="confluenceTd"><p><strong>Scenario</strong></p></td><td class="confluenceTd"><p><strong>Hash Tag</strong></p></td><td class="confluenceTd"><p><strong>Implemented?</strong></p></td></tr></thead><tbody><tr><td class="confluenceTd"><p>On DTW causing CCP update, check data being written in is the same as the one on DTW. </p></td><td class="confluenceTd"><p>#Check.DMI.v2.DTWToCCPWrdataIntegrity</p></td><td class="confluenceTd"><p>DONE</p></td></tr></tbody></table></div><h3 id="DMITestplan-Ncore2.5-4.2.6.DMIPipeControl(uarchsection5.1.6)">4.2.6.  DMI Pipe Control (uarch section 5.1.6)</h3><div class="table-wrap"><table class="confluenceTable"><thead><tr><td class="confluenceTd"><p><strong>Scenario</strong></p></td><td class="confluenceTd"><p><strong>Hash Tag</strong></p></td><td class="confluenceTd"><p><strong>Implemented?</strong></p></td></tr></thead><tbody><tr><td class="confluenceTd"><p>Cover Hnt hitting all three states of cache in P1. Cross with attributes.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.HntHitwiththreeStateofCache</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Cover all MRD types hitting all three states of cache in P1. Cross with attributes.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.MrdHitwiththreeStateofCache</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Cover all DTW types hitting all cache states in P1. Cross with attributes.</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.DtwhitwiththreeStateofCache</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Cross above with cancel being asserted in P2.</p></td><td class="confluenceTd"><p>#Cov.HntDtwMrdCancelinP2</p></td><td class="confluenceTd"><p>DONE</p></td></tr></tbody></table></div><h3 id="DMITestplan-Ncore2.5-4.2.7.ExtendedVictimCache(uarch)"> 4.2.7.Extended Victim Cache (uarch)</h3><div class="table-wrap"><table class="confluenceTable"><thead><tr><td class="confluenceTd"><p><strong>Scenario</strong></p></td><td class="confluenceTd"><p><strong>Hash Tag</strong></p></td><td class="confluenceTd"><p><strong>Implemented?</strong></p></td></tr></thead><tbody><tr><td class="confluenceTd"><div>Check MrdRdCln/MrdRdVld with msg Atrr: AL collide with staled Hnt, Dmi will use the way # of staled hnt.</div><div>it will do two txn on fill ctrl intf, first invalidate due to staled hnt then do fill for Mrd</div></td><td class="confluenceTd"><p>#Check.DMI.MrdALCollidewithStaledHnt,</p><p>#Cov.DMI.MrdALCollidewithStaledHnt,</p></td><td class="confluenceTd">DONE</td></tr><tr><td class="confluenceTd"><div>Check MrdRdCln/MrdRdVld with msg Atrr: AL not allocated in following condition, if it does not collide any</div><div>hnt in flight</div><div><ul><li><span>CCP indicates no allocate</span></li><li><span>The WTT is full or any of the WTT counters are at max</span></li><li><span>The Write Address Buffer is full (small buffer between CCP interface and AXI AW channel)</span></li></ul></div></td><td class="confluenceTd">#Check.DMI.MrdALNoAllocCondition</td><td class="confluenceTd">DONE</td></tr><tr><td class="confluenceTd"><p>Check Mrd collide with Hnt inflight ,hnt will be upgraded, alloc signal will not assert</p></td><td class="confluenceTd"><p>#Check.DMI.v2.5.MrdCollidewithHntinflightNoalloc</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>Check Mrd collide with Hnt inflight are not beat aligned , Mrd will again appear for lookup after fill</p></td><td class="confluenceTd"><p>#Check.DMI.v2.5.MrdCollidewithHntinflightNobeatallign</p></td><td class="confluenceTd"><p>DONE</p></td></tr></tbody></table></div><h1 id="DMITestplan-Ncore2.5-5.AdvancedCoverage(Crossofmulti-features,Timingsensitivescenariostohit,etc)"><strong>5.   Advanced Coverage (Cross of multi-features, Timing sensitive scenarios to hit, etc)</strong></h1><div class="table-wrap"><table class="confluenceTable"><thead><tr><td class="confluenceTd"><p><strong>Scenario</strong></p></td><td class="confluenceTd"><p><strong>Hash Tag</strong></p></td><td class="confluenceTd"><p><strong>Implemented?</strong></p></td></tr></thead><tbody><tr><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td></tr></tbody></table></div><h1 id="DMITestplan-Ncore2.5-6.Clock/Reset"><strong>6.   Clock/Reset</strong></h1><h2 id="DMITestplan-Ncore2.5-6.1.Reset">6.1.  Reset</h2><div class="table-wrap"><table class="confluenceTable"><thead><tr><td class="confluenceTd"><p><strong>Scenario</strong></p></td><td class="confluenceTd"><p><strong>Hash Tag</strong></p></td><td class="confluenceTd"><p><strong>Implemented?</strong></p></td></tr></thead><tbody><tr><td class="confluenceTd"><p> Check that when reset is asserted, all ready's/ valids are appropriately de-asserted </p></td><td class="confluenceTd"><p> #Check.DMI.v2.ResetReadyCheck</p></td><td class="confluenceTd"><p>DONE</p></td></tr></tbody></table></div><h2 id="DMITestplan-Ncore2.5-6.2.Clock">6.2. Clock</h2><h1 id="DMITestplan-Ncore2.5-7.Performance(LatencyandBandwidth)"><strong style="font-size: 24.0px;">7.    Performance (Latency and Bandwidth)</strong></h1><div class="table-wrap"><table class="confluenceTable"><thead><tr><td class="confluenceTd"><p align="center"><strong>Scenario</strong></p></td><td class="confluenceTd"><p align="center"><strong>Hash Tag</strong></p></td><td class="confluenceTd"><p align="center"><strong>Final performance number</strong></p></td><td class="confluenceTd"><p align="center"><strong>Implemented</strong></p></td></tr></thead><tbody><tr><td class="confluenceTd"><p>DTW throughput Msg type: DTW_DTATA_DTY, msg attri: AC,CV</p><p>wdata:64,   rtt:96 wtt:96</p><p>wdata:128: rtt:96 wtt:96</p><p>wdata:256:rtt:96 wtt:96</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.DtwDataDtyThroughput</p></td><td class="confluenceTd"><p> </p><p>8</p><p>4</p><p>2</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>DTW throughput Msg type: DTW_DTATA_DTY, msg attri: AC,CV</p><p>followed by MRD_RD_VLD</p><p>wdata:64,   rtt:96 wtt:96</p><p>wdata:128: rtt:96 wtt:96</p><p>wdata:256:rtt:96 wtt:96</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.MrdRdVldThroughput</p></td><td class="confluenceTd"><p> </p><p> </p><p>8</p><p>4</p><p>2</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p> </p></td></tr></tbody></table></div><p> </p><h1 id="DMITestplan-Ncore2.5-8.Errors"><strong>8.   Errors</strong></h1><p> </p><div class="table-wrap"><table class="confluenceTable"><thead><tr><td class="confluenceTd"><p align="center"><strong>Scenario</strong></p></td><td class="confluenceTd"><p align="center"><strong>Hash Tag</strong></p></td><td class="confluenceTd"><p align="center"><strong>Implemented?</strong></p></td></tr></thead><tbody><tr><td class="confluenceTd"><p>CorrectableError ( Rtt, Tag, Data)</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.CorrectableErrorRtt,  #Cov.DMI.v2.CorrectableErrorTag, #Cov.DMI.v2.CorrectableErrorData</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>UncorrectableError (Rtt, Tag, Data)</p></td><td class="confluenceTd"><p>#Cov.DMI.v2.CorrectableErrorRtt,  #Cov.DMI.v2.CorrectableErrorTag, #Cov.DMI.v2.CorrectableErrorData</p></td><td class="confluenceTd"><p>DONE</p></td></tr><tr><td class="confluenceTd"><p>TransportError</p></td><td class="confluenceTd"><p>#.Cov.DMI.v2.TransportError</p></td><td class="confluenceTd"><p>DONE</p></td></tr></tbody></table></div><h1 id="DMITestplan-Ncore2.5-9.PowerManagement"><strong>9.   Power Management</strong></h1><p> </p><div class="table-wrap"><table class="confluenceTable"><thead><tr><td class="confluenceTd"><p align="center"><strong>Scenario</strong></p></td><td class="confluenceTd"><p align="center"><strong>Hash Tag</strong></p></td><td class="confluenceTd"><p align="center"><strong>Implemented?</strong></p></td></tr></thead><tbody><tr><td class="confluenceTd"><p>TransActv</p></td><td class="confluenceTd"><p>#Check.DMI.v2.TransActvCheck</p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>EvictActv</p></td><td class="confluenceTd"><p>#Check.DMI.v2.EvictActvCheck</p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>FillActv</p></td><td class="confluenceTd"><p>#Check.DMI.v2.FillActvCheck</p></td><td class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" class="confluenceTd">CCP_IF_Disable</td><td colspan="1" class="confluenceTd">#Check.DMI.v2.CcpIFDisable</td><td colspan="1" class="confluenceTd"> </td></tr></tbody></table></div><h1 id="DMITestplan-Ncore2.5-10.CSR"><strong>10.  CSR </strong></h1><p> </p><div class="table-wrap"><table class="confluenceTable"><thead><tr><td class="confluenceTd"><p><strong>TestName</strong></p></td><td class="confluenceTd"><p><strong>Notes</strong></p></td></tr></thead><tbody><tr><td class="confluenceTd"><p>dmi_csr_all_reg_rd_reset_val_test</p></td><td class="confluenceTd"><p>Use ralgen to read all register values </p></td></tr><tr><td class="confluenceTd"><p>dmi_csr_bit_bash_test</p></td><td class="confluenceTd"><p>Use ralgen to perform a bit-bash test</p></td></tr><tr><td class="confluenceTd"><p>ralgen_cmiucecr_errDetEn_reg_test</p></td><td class="confluenceTd"><p>Test sets cecr en; waits for cesr.errvld to be set. Checks same through ESAR. Tests W1C behavior of ESR.</p></td></tr><tr><td class="confluenceTd"><p>ralgen_cmiucecr_errCntOvf_reg_test</p></td><td class="confluenceTd"><p>Setup test. En, inten, thd. Wait for errvld. Wait for ovf. Read ESAR.vld. Wr to check that it is set. Write 0 to ESAR.vld. Read the ESR and ESAR.vld bits. Should be 0. Also verify W1C attribute of ESR.ovf</p></td></tr><tr><td class="confluenceTd"><p>ralgen_cmiucecr_errInt_reg_test</p></td><td class="confluenceTd"><p>Test sets cecr.en, cecr.inten; thd to random value. It then waits for interrupt and tests cesr_errvld, type and count. It does the same for ESAR.  Disables cecr.en and inten. Writes to cesr.errvld and checks W1C behavior by checking vld. Check irq_c is deasserted.</p></td></tr><tr><td class="confluenceTd"><p>ralgen_cmiucecr_errThd_reg_test</p></td><td class="confluenceTd"><p>Test sets cecr.en, cecr.inten; thd to random value. Wait for ESR.errvld. Check errorcnt is at errthd. Read ESAR.errorcnt. This should match the ESR.errorcnt. Verify that resetting the CESR.ErrVld, CECR.errdeten, CECR.errthd fields does not change the ESR.errorcount.</p></td></tr><tr><td class="confluenceTd"><p>ralgen_cmiucecr_sw_write_reg_test</p></td><td class="confluenceTd"><p>Set the cecr.errthd, cecr.en. Write to ESAR.errvld field in a loop, while error injection is ongoing. After error injection, if ESR.errvld is set, reset it.</p></td></tr><tr><td class="confluenceTd"><p>ralgen_cmiucecr_noDetEn_reg_test</p></td><td class="confluenceTd"><p>CECR.errdeten is not set. Errors are injected. CESR.errvld is not set. CESR.errcnt is 0. CESAR.errcnt is 0. </p></td></tr><tr><td class="confluenceTd"><p>ralgen_cmiucecr_noIntEn_reg_test</p></td><td class="confluenceTd"><p>Set the CECR.errdeten and the CECR.errthd. Errors are injected. Check that the irq_c is not asserted. Check that the CESR.errvld is set.</p></td></tr><tr><td class="confluenceTd"><p>ralgen_cmiucesr_rstNoVld_reg_test</p></td><td class="confluenceTd"><p>Test writing to Vld bit when it is not set, does not affect errcnt (error injection to rtt mem)</p></td></tr><tr><td class="confluenceTd"><p>ralgen_cmiucesr_rstNoVld_CcpTag_reg_test</p></td><td class="confluenceTd"><p>Test writing to Vld bit when it is not set, does not affect errcnt (error injection to ccp tag mem)</p></td></tr><tr><td class="confluenceTd"><p>ralgen_cmiucesr_rstNoVld_CcpData_reg_test</p></td><td class="confluenceTd"><p>Test writing to Vld bit when it is not set, does not affect errcnt (error injection to ccp data mem)</p></td></tr><tr><td class="confluenceTd"><p>ralgen_cmiucelr_reg_test</p></td><td class="confluenceTd"><p>Test checks that the CELR0.errentry, CELR0.errway, CELR0.errword, CELR1.erraddr are updated with the error location.</p></td></tr><tr><td class="confluenceTd"><p>ralgen_cmiucelr_CcpTag_reg_test</p></td><td class="confluenceTd"><p>Test checks that the CELR0.errentry, CELR0.errway, CELR0.errword, CELR1.erraddr are updated with the error location.</p></td></tr><tr><td class="confluenceTd"><p>ralgen_cmiucelr_CcpData_reg_test</p></td><td class="confluenceTd"><p>Test checks that the CELR0.errentry, CELR0.errway, CELR0.errword, CELR1.erraddr are updated with the error location.</p></td></tr><tr><td class="confluenceTd"><p>ralgen_cmiuuecr_errDetEn_reg_test</p></td><td class="confluenceTd"><p>Test sets uecr en; waits for uesr.errvld to be set. Checks same through ESAR. Tests W1C behavior of ESR.</p></td></tr><tr><td class="confluenceTd"><p>ralgen_cmiuuecr_errCntOvf_reg_test</p></td><td class="confluenceTd"><p>Setup test. En, inten, thd. Wait for errvld. Wait for ovf. Read UESAR.vld. Wr to check that it is set. Write 0 to UESAR.vld. Read the UESR and UESAR.vld bits. Should be 0. Also verify W1C attribute of UESR.ovf</p></td></tr><tr><td class="confluenceTd"><p>ralgen_cmiuuecr_errInt_reg_test</p></td><td class="confluenceTd"><p>Test sets uecr.en, uecr.inten; thd to random value. It then waits for interrupt and tests uesr_errvld, type and count. It does the same for UESAR.  Disables uecr.en and inten. Writes to uesr.errvld and checks W1C behavior by checking vld. Check irq_uc is deasserted.</p></td></tr><tr><td class="confluenceTd"><p>ralgen_cmiuuecr_errThd_reg_test</p></td><td class="confluenceTd"><p>Test sets uecr.en, uecr.inten; thd to random value. Wait for UESR.errvld. Check errorcnt is at errthd. Read UESAR.errorcnt. This should match the UESR.errorcnt. Verify that resetting the UESR.ErrVld, UECR.errdeten, UECR.errthd fields does not change the UESR.errorcount.</p></td></tr><tr><td class="confluenceTd"><p>ralgen_cmiuuecr_sw_write_reg_test</p></td><td class="confluenceTd"><p>Set the uecr.errthd, uecr.en. Write to UESAR.errvld field in a loop, while error injection is ongoing. After error injection, if UESR.errvld is set, reset it.</p></td></tr><tr><td class="confluenceTd"><p>ralgen_cmiuuecr_noDetEn_reg_test</p></td><td class="confluenceTd"><p>UECR.errdeten is not set. Errors are injected. UESR.errvld is not set. UESR.errcnt is 0. UESAR.errcnt is 0. </p></td></tr><tr><td class="confluenceTd"><p>ralgen_cmiuuecr_noIntEn_reg_test</p></td><td class="confluenceTd"><p>Set the UECR.errdeten and the UECR.errthd. Errors are injected. Check that the irq_uc is not asserted. Check that the UESR.errvld is set.</p></td></tr><tr><td class="confluenceTd"><p>ralgen_cmiuuelr_reg_test</p></td><td class="confluenceTd"><p>Test writing to Vld bit when it is not set, does not affect errcnt (error injection to rtt mem)</p></td></tr><tr><td class="confluenceTd"><p>ralgen_cmiuuelr_CcpTag_reg_test</p></td><td class="confluenceTd"><p>Test writing to Vld bit when it is not set, does not affect errcnt (error injection to ccp tag mem)</p></td></tr><tr><td class="confluenceTd"><p>ralgen_cmiuuelr_CcpData_reg_test</p></td><td class="confluenceTd"><p>Test writing to Vld bit when it is not set, does not affect errcnt (error injection to ccp data mem)</p></td></tr><tr><td class="confluenceTd"><p>dmi_test with +single_bit_error_test</p><p> </p></td><td class="confluenceTd"><p>DMI random test with correctible errors injection to rtt_mem</p></td></tr><tr><td class="confluenceTd"><p>dmi_test with +ccp_single_bit_tag_error_test</p></td><td class="confluenceTd"><p>DMI random test with correctible errors injection to ccp_tag_mem</p></td></tr><tr><td class="confluenceTd"><p>dmi_test with +ccp_single_bit_data_error_test</p></td><td class="confluenceTd"><p>DMI random test with correctible errors injection to ccp_data_mem</p></td></tr></tbody></table></div><p> </p><h1 id="DMITestplan-Ncore2.5-ActionItems">Action Items</h1><ul class="inline-task-list" data-inline-tasks-content-id="16168777"><li data-inline-task-id="1"><span><a class="confluence-userlink user-mention" data-account-id="624b378ef407980070592335" href="https://arterisip.atlassian.net/wiki/people/624b378ef407980070592335?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">Satya Prakash (Deactivated)</a>: Add configuration (or change configuration) or wPriorityLevel = 0</span></li></ul>