<p><span class="legacy-color-text-blue3">This is a JS class that can be found in the following path and file:</span><br/><strong>hw-lib/js/sym_csr_lib.js</strong></p><h2 id="HW-SYMclassPktArrayQuery-BaseClass">Base Class</h2><p>None</p><h2 id="HW-SYMclassPktArrayQuery-Composition">Composition</h2><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156641/class+PkdStruct" data-linked-resource-id="16156641" data-linked-resource-version="3" data-linked-resource-type="page">class PkdStruct</a></p><h2 id="HW-SYMclassPktArrayQuery-Purpose">Purpose</h2><p>The class is meant for providing a way to parse and query for information from an ATP link packet definition in Symphony  ( described here: <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166670/HW-SYM+packetDesc" data-linked-resource-id="16166670" data-linked-resource-version="20" data-linked-resource-type="page">HW-SYM packetDesc</a> ). The class aims to optimize lookup of packet fields by cutting down parsing times of long packets. The class provides the following features:</p><ol><li>Methods to fetch fields, positions, widths by name,</li><li>Methods to fetch fields, positions by beat number,</li><li>Conversion to base packet array and params,</li><li>Pretty-print a packet-array ( beat-wise breakup with widths )</li><li>Packet-integrity checks</li></ol><p>In addition it provide some data-properties described in the next section. </p><h2 id="HW-SYMclassPktArrayQuery-Terminology">Terminology</h2><p>Following terms are defined in the context of this class</p><ol><li>Header fields: Any field in the packet with type value &quot;H&quot;.</li><li>Data fields: Any field in the packet with type value &quot;F&quot; or &quot;C&quot;.</li><li>Null fields: Any field in the packet with type value &quot;N&quot;</li><li>slice: An object with the following two keys: { <strong>start</strong>: zero or positive integer, <strong>end</strong>: zero or positive integer }. They can be used to determine at which bit a packet field begins and ends on an ATP bus signal.</li><li>position/Pos: An object with the following two keys: { <strong>beat</strong>: number of the beat at which a packet field exists, <strong>slice</strong>: described above }.</li><li>wholeField and subField: An H type field can be split across multiple fields, in which case each of the broken chunks is referred to as subFields and the collectively they are referred to as a wholeField. The subFields are referred to by names with a zero or positive integer suffixes (Ex: H_addr_0, H_len_1 }. The wholeFields are referred to by their whole names after dropping suffixes ( Ex: H_addr can refer to both H_addr_0 and H_addr_1 ). For F and C type fields, are integer suffixes are ignored. All methods accept only wholeField names or wholeNames as arguments. </li><li>NDP: Non-data-payload portion of the packet array.</li><li>DP: Data-payload portion of the packet array</li></ol><h2 id="HW-SYMclassPktArrayQuery-Properties">Properties</h2><p>An instance of the class will have the following data-properties, some of which are implemented as getters:</p><ol><li>numHdrBeats: This gives the number of header beats in the packet array. Minimum value is 1. For parallel and serial packet this will be 1.</li><li>pktStyle: This tells the packet style or header style of the packets and can take the following values: &quot;parallel&quot;, &quot;serial&quot;, &quot;fixed&quot;.</li><li>sumOfHWidths: This gives the sum of all Header or H type fields.</li><li>sumOfDWidths: This gives the sum of all Data or (F or C type) fields.</li><li>wholeSliceBus:  This gives  a slice ( refer above) of the entire ATP Bus assuming the lower index is zero.</li><li>wholeSliceNDP: This gives a single slice of the entire NDP portion in a header beat. Includes nulls with payload 0.</li><li>wholeSliceDP: This gives a single slice of the whole DP portion of the packet array in the first beat with payload ( payload 1 ). When there is no payload, this returns a null.</li></ol><h2 id="HW-SYMclassPktArrayQuery-Interface(Methods)">Interface (Methods)</h2><p>The class provides the following interface methods: </p><p><strong><em>constructor</em><em>(  wBus, pktArray, options )</em></strong></p><p>This is the constructor function used to initialize the instance of the class. It must be called with at least two arguments - wBus and pktArray. The third argument is optional.</p><ol><li>wBus: Type: A positive integer. This is the width of the link or width of the 'bus' signal on an ATP interface.</li><li>pktArray: Type: Array of objects. This is the packet-array  (not the pktDef itself ) expected to be computed by the getPacketArray( pktDef.params ) function.</li><li>options: Type: object. Following parameters/options are provided: createHashOfHFields ( to speed up H type field lookup ), protection (when false, returns references to the original packet array, else makes copies ).</li></ol><p>The constructor stored the NDP (payload 0) and DP fields (payload 1) of a packet separately. The former is stored as a 2D array internally or as an associative array (if createHashOfHFields = true), and the latter is stored as a 1D array. In addition, it remember where the last NDP field ends and if the packet is parallel.</p><p>For DP fields ( payload 1 ), all number suffixes in the names are dropped and only a single beat is stored to cut down lookup for data fields.</p><p><br/></p><p><em><strong>dWidth ( fieldName )</strong></em></p><p>Returns the width of a data field (F or C type field).</p><p><br/></p><p><em><strong>hWidth ( fieldName )</strong></em></p><p>Returns the width of a header wholeField (H type field). The fieldName is assumed to be a wholeField name ( i.e. no integer suffixes ). If a H type field is split into multiple sub-fields, then this returns the sum of widths of all the sub-fields.</p><p><br/></p><p><em><strong>nullWidth ( beat )</strong></em></p><p>Returns the sum of widths of any and all N type fields in a given beat.</p><p><br/></p><p><em><strong>dFieldPos ( fieldName )</strong></em></p><p>Returns a position object (refer terminology section) for a data-field (F or C type) in any beat with payload ( all data-fields have the same position in all beats ).</p><p><br/></p><p><em><strong>hFieldPos ( fieldName )</strong></em></p><p>Returns an array of position objects (refer terminology section) for a header-field (H type) in all beats with NDP fields.</p><p><br/></p><p><em><strong>dField ( fieldName )</strong></em></p><p>Returns a field object ( from the packet array ) whose name matches the parameter 'fieldName'.</p><p><br/></p><p><em><strong>hFields ( fieldName )</strong></em></p><p>Returns an array of field objects ( from the packet array as is ) whose names match the parameter 'fieldName' ( after dropping integer-suffixes).</p><p><br/></p><p><em><strong>dpFields ( beat )</strong></em></p><p>Returns an array for iterating over all data-field in a beat including NULL or N type fields. If not data-fields are present in that beat, then returns nothing.</p><p><br/></p><p><em><strong>ndpFields ( beat )</strong></em></p><p>Returns an array for iterating over all non-data-payload fields ( payload = 0 ) in a given beat. If not NDP fields are present in that beat, then returns nothing.</p><p><br/></p><p><em><strong>dpSlices ( beat )</strong></em></p><p>Same as dpFields except returns slice objects at each iteration instead of field objects.</p><p><br/></p><p><em><strong>ndpFields ( beat )</strong></em></p><p>Same as ndpFields except returns slice objects at each iteration instead of fields objects.</p><p><br/></p><p><em><strong>toBasePktArray ( )</strong></em></p><p>Returns an array same as the input pktArray such that all the H type sub-fields are merged into a single wholeField and only a single instance of each field (F, C, or H) is present. T</p><p><br/></p><p><em><strong>toBasePktParams ( )</strong></em></p><p>Returns an object (associate array) with base packet params and their values.</p><p><br/></p><p><em><strong>toString ( )</strong></em></p><p>Returns a pretty printed string of the input packet array with fields and their widths arranged in different rows ( that correspond to beats ). This overrides the default toString ( ) function of the PktArrayQuery instance and hence using the instance in any string context will return this string instead.</p><p><br/></p><h2 id="HW-SYMclassPktArrayQuery-Usageexamples">Usage examples</h2><p><span>Creating an instance of the PktArray class:</span></p><p><span>const interfaces        = libUtils.hierGetParam('interfaces', u.getParam);<br/></span><span>const pktDef            = interfaces.atpInterface.pktDef;<br/>const pktArray         = ( new obj.userLib[pktDef.packet] ).getPacketArray( pktDef.params );<br/>const myPkt             = new PktArrayQuery (inWidth, inPktArray);            // This creates the instance.<br/></span></p><p><br/></p><p>myPkt.hWidth( &quot;H_len&quot; ) // Returns the sum of widths of all H_len_* fields in the packet.<br/>myPkt.hFieldPos( &quot;H_addr&quot; )  // Returns an array such as [  { beat : 2, slice: { start: 3, end: 0 } ],  [  { beat : 3, slice: { start: 38, end: 11 } ], <br/><br/></p><p>const [ dpFields, dpSlices ]   = [ myPkt.dpFields( 1 ), myPkt.dpSlices( 1 ) ];  // Fetch payload fields from beat 1. Empty array if not payload fields found.<br/>const results             = [ ];</p><p>for ( let i = 0; i &lt; dpSlices; i++ ) {<br/>  const name   = dpFields[ i ];<br/>  const type     = dpFields[ i ].type;<br/>  <br/>  if ( type ! == &quot;N&quot;) {                             // Ignore fields of type &quot;N&quot; (NULL)<br/>    const slice     = dpSlices[ i ];<br/>    const value    = getVlogSliceExpression( interfaces.atpInterface.name+&quot;bus&quot;, slice );  // This is assumed to be a function that creates a string expression using the start and end indexes for the field mapped on to an ATP &quot;bus&quot;.<br/>    result.push( value );<br/>  }<br/>}</p><p><br/></p>