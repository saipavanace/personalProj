<h1 id="SystemEventandCoherencyWrapper-module_name"><strong>module_name</strong></h1><p>sys_evt_coh_concerto</p><p><br/></p><h2 id="SystemEventandCoherencyWrapper-References"><strong>References</strong></h2><p>See:</p><p>SysReq Messaging Protocol for SysCoReq/Event Transport on<a class="external-link" href="https://confluence.arteris.com/display/ENGR/Arch+Ncore+3.2+Docs" rel="nofollow"> Arch Ncore 3.2 Docs - Engineering - Confluence (arteris.com)</a></p><p><a class="external-link" href="https://confluence.arteris.com/display/ENGR/Outstanding+Issues+for+System+Event+and+Coherency+Messaging" rel="nofollow">Outstanding Issues for System Event and Coherency Messaging - Engineering - Confluence (arteris.com)</a></p><p><a class="external-link" href="https://confluence.arteris.com/display/ENGR/Delta+between+RTL+and+Architecture+Specification+for+System+Event+and+Coherency" rel="nofollow">Delta between RTL and Architecture Specification for System Event and Coherency - Engineering - Confluence (arteris.com)</a></p><h2 id="SystemEventandCoherencyWrapper-Parameters"><strong>Parameters</strong></h2><p>wEventTimeout : an integer value that is the width for the event timeout counter</p><p>wProtocolTimeout : an integer value that is the width for the protocol timeout counter</p><p>useSysEvtSender : a boolean value when true instantiates the sys_evt_sender module</p><p><span style="letter-spacing: 0.0px;">useSysEvtReceiver : a boolean value when true instantiates the sys_evt_receiver module</span></p><p>useSysCoh : a boolean value when true enables the System Coherency feature</p><p>useSysCohSender : valid when useSysCoh is true; a boolean value when true instantiates the sys_coh_sender module, else the sys_coh_receiver module. </p><p>useSysCoHwInterface: valid when useSysCoh and useSysCohSender is true; a boolean value when true indicates SysCo hardware interface is used.</p><p>wSnoopEnables : an integer value that specifies the width of the Snoop Enable register (i.e. the T / SnpCmd register in architecture spec), the value is the maximum NUnitId + 1. The bit position of the Snoop Enable register indicates the NUnitId of the agent to be snooped.</p><p>nSnoopAgents: an integer value that is the total number of snoop agents to be enabled.</p><p>nCoherencyAgents: an integer value that is the total number of coherency agents that include DCEs and DVE.</p><p>nEventAgentsForReceiver : an integer value that is the total number of messaging agents for the Sys.Event Receiver; this is used to set the depth for the input queue in the Sys.Event Receiver.</p><p>nEventAgentsForSender: an integer value that is the total number of messaging agents for the Sys.Event Sender.</p><p>wFUnitId : an integer value that indicates the width of the FUnitId field in the SYS message class.</p><p>wNUnitId : an integer value that indicates the width of the NUnitId. NOTE: NUnitId here can be CachingAgentId also, depending on how this module is used.</p><p>wMessageId : an integer value that indicates the width of the MessageId or RMessageId field in the SYS message class.</p><p>wSysReqOp : an integer value that indicates the width of the SysReq message field Op.</p><p>concParams : an object passed in from Maestro-generated JSON that contains parameters for all Concerto message types.</p><p>cmType : an object passed in from Maestro-generated JSON that contains the Concerto message type encodings.</p><p>sysReqTxInterface : an interface signal bundle object for the SysReq TX interface going to Concerto MUX.</p><p>sysRspRxInterface : an interface signal bundle object for the SysRsp RX interface coming from Concerto MUX.</p><p>sysReqRxInterface : an interface signal bundle object for the SysReq RX interface coming from Concerto MUX.</p><p>sysRspTxInterface : an interface signal bundle object for the SysRsp TX interface going to Concerto MUX.</p><pre class="page view"><br/></pre><h2 id="SystemEventandCoherencyWrapper-I/O"><strong>I/O</strong></h2><p>u.port('input', 'clk', 1);</p><p>u.port('input', 'reset_n', 1);</p><p><br/></p><p>u.port('input', 'csr_event_timeout_value' , wEventTimeout);</p><p>u.port('input', 'csr_protocol_timeout_value' , wProtocolTimeout);</p><p>    if (useSysEvtSender) {</p><p>u.port('input', 'csr_sys_evt_sender_enable', 1);</p><p>u.port('output', 'csr_sys_evt_sender_err_vld', 1);</p><p>        for (i=0; i &lt; nEventAgentsForSender; i++) {<br/>u.port('input', 'event'+i+'_f_unit_id', wFUnitId);<br/>        }</p><p>    }</p><p>    if (useSysEvtReceiver) {</p><p>u.port('input', 'csr_sys_evt_receiver_enable', 1);</p><p>u.port('output', 'csr_sys_evt_receiver_err_vld', 1);</p><p>    }</p><p>    if (useSysCoh) {</p><p>        if (useSysCohSender) {</p><p>u.port('input', 'csr_sys_coh_sender_activate', 1);<br/>u.port('output', 'csr_sys_coh_sender_connecting', 1);<br/>u.port('output', 'csr_sys_coh_sender_attached', 1);<br/>u.port('output', 'csr_sys_coh_sender_err_detected', 1);</p><p>            for (i=0; i &lt; nCoherencyAgents; i++) {<br/>u.port('input', 'coherency'+i+'_f_unit_id', wFUnitId);<br/>            }</p><p>        } else {</p><p>u.port('output', 'csr_snoop_enables', wSnoopEnables);</p><p>u.port('output', 'csr_sys_coh_receiver_err_vld', 1);</p><p>            for (i=0; i &lt; nSnoopAgents; i++) {<br/>u.port('input', 'aiu'+i+'_f_unit_id', wFUnitId);<br/>u.port('input', 'aiu'+i+'_n_unit_id', wNUnitId);<br/>            }</p><p>        }</p><p>    }</p><p>    if (useSysEvtSender) {</p><p>u.port('input', 'event_in_req', 1);</p><p>u.port('output', 'event_in_ack', 1);</p><p>u.port('input', 'event_in_targets', nEventAgentsForSender); //A list of targets for the Sys.Event message</p><p>    }</p><p>    if (useSysEvtReceiver) {</p><p>u.port('output', 'event_out_req', 1);<br/>u.port('input', 'event_out_ack', 1);</p><p>    }</p><p>    if (useSysCoh) {</p><p>        if (useSysCohSender) {</p><p>            if (useSysCoHwInterface) {<br/>u.port('input', 'sysco_req', 1);<br/>u.port('output', 'sysco_ack', 1);<br/>            }</p><p>        }</p><p>    }</p><p>    if (useSysCoh) {</p><p>        if (useSysCohSender) {</p><p>u.port('input', 'outstanding_coherent_count_zero', 1);</p><p>        } else {</p><p>u.port('input', 'outstanding_snoop_count_zero', nSnoopAgents); //one bit per Caching Agent</p><p>        }</p><p>    }</p><p>    if (useSysEvtSender || (useSysCoh &amp;&amp; useSysCohSender)) {</p><p>u.interface('sys_req_tx_', 'master', sysReqTxInterface);<br/>u.interface('sys_rsp_rx_', 'slave', sysRspRxInterface);</p><p>    }</p><p>    if (useSysEvtReceiver || (useSysCoh &amp;&amp; !useSysCohSender) {</p><p>u.interface('sys_req_rx_', 'slave', sysReqRxInterface);<br/>u.interface('sys_rsp_tx_', 'master', sysRspTxInterface);</p><p>    }</p><p><br/></p><h2 id="SystemEventandCoherencyWrapper-Descriptions"><strong>Descriptions</strong></h2><p>The System Event and Coherency module is a wrapper module to group the following basic RTL building blocks, subject to the legal combination restrictions.</p><ul><li>Sys.Event Sender - to translate an incoming EventIn signaling to an out-going Sys.Event message</li><li>Sys.Event Receiver - to translate an arriving Sys.Event message to an out-going EventOut signaling</li><li>Sys.Coh Sender - to translate an incoming SysCo signaling to an out-going Sys.Attach/Sys.Detach message</li><li>Sys.Coh Receiver - to translate an incoming Sys.Attach/Sys.Detach message to setting/clearing of a Snoop Enable bit for a target Snoop Agent.</li></ul><p>The handshake signaling on the two I/O pins (one for request, the other for acknowledge) is a 4-phase handshake protocol.</p><p>The handshake signaling can cross clock domain. In such cases, synchronizers are expected to be placed outside the wrapper module.</p><p>Events generated at a source within an agent will enter Ncore through the EventInputInterface and will be propagated to all agent interfaces (CAIU) in the system with an instantiated Event Receiver. The Event Receiver's EventOutputInterface will deliver events to the connected target (e.g. a processor cluster (DSU) or accelerator).</p><p><br/></p><p>For Ncore 3.2 NXP release, the legal combinations of the basic RTL building blocks is shown as below:</p><div class="table-wrap"><table class="relative-table wrapped confluenceTable" style="width: 78.1402%;"><colgroup><col style="width: 33.4933%;"/><col style="width: 66.4178%;"/></colgroup><tbody><tr><th class="confluenceTh">Concerto Unit</th><th class="confluenceTh">Legal Combinations</th></tr><tr><td class="confluenceTd">CHI-AIU (DVM capable)</td><td class="confluenceTd"><p>Sys.Coh Sender, Sys.Event Receiver </p></td></tr><tr><td class="confluenceTd">ACE-AIU (DVM capable)</td><td class="confluenceTd"><p>Sys.Coh Sender, Sys.Event Receiver </p></td></tr><tr><td class="confluenceTd">AXI-AIU with Proxy Cache (not DVM capable)</td><td class="confluenceTd"><p>Sys.Coh Sender, Sys.Event Receiver</p></td></tr><tr><td colspan="1" class="confluenceTd">AXI-AIU without Proxy Cache (not DVM capable)</td><td colspan="1" class="confluenceTd">none</td></tr><tr><td colspan="1" class="confluenceTd">ACELite-AIU (can be DVM capable)</td><td colspan="1" class="confluenceTd"><s>none</s> Sys.CohSender</td></tr><tr><td colspan="1" class="confluenceTd">ACELiteE-AIU (can be DVM capable)</td><td colspan="1" class="confluenceTd"><s>none</s> Sys.CohSender</td></tr><tr><td colspan="1" class="confluenceTd">DCE</td><td colspan="1" class="confluenceTd">Sys.Coh Receiver + Sys.Event Sender (ExMon event whenever ExclusiveStore passes and resets the monitor)</td></tr><tr><td colspan="1" class="confluenceTd">DVE</td><td colspan="1" class="confluenceTd">Sys.Coh Receiver</td></tr><tr><td colspan="1" class="confluenceTd">DMI</td><td colspan="1" class="confluenceTd">none</td></tr><tr><td colspan="1" class="confluenceTd">DII</td><td colspan="1" class="confluenceTd">none</td></tr></tbody></table></div><p>NOTE: CHI-AIU supports both I/O Pin driven SysCo, as well as CSR driven SysCo. The use case is either-or, not both. CSR driven SysCo for CHI-AIU is a fallback solution for SW.</p><p>NOTE: ACE-AIU and AXI-AIU with Proxy Cache are always CSR driven SysCo.</p><p><br/></p><p>The caching agents need to issue Sys.Coh (Attach/Detach) messages to DCE so that DCE can track their attached/detached states via the DCE Snoop Enable register.</p><p>DCE only send ExMon event (Sys.Event message) to Caching Agents that are in the attached states.</p><p>=&gt;Sys.Event messaging testing is tied to Sys.Coh messaging testing, unless SW writes to the DCE Snoop Enable register to all 1s.</p><p><br/></p><p>AIUs do not have Sys.Event Sender and therefore cannot send Sys.Event messages.</p><p><br/></p><p><strong>Maestro is expected to provide the following interface objects</strong>:</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Concerto Unit</th><th class="confluenceTh">Interface Objects required from Maestro generated JSON file</th></tr><tr><td class="confluenceTd"><p>CHI-AIU</p></td><td class="confluenceTd"><p>Sys.Coh Sender: interfaces.uSysDceIdInt, interfaces.uSysDveIdInt</p><p>Sys.Event Receiver: interface.uEvtOutInt</p></td></tr><tr><td colspan="1" class="confluenceTd">ACE-AIU</td><td colspan="1" class="confluenceTd"><p>Sys.Coh Sender: interfaces.uSysDceIdInt, interfaces.uSysDveIdInt</p><p><s>OPTIONAL:</s> Sys.Event Receiver: interface.uEvtOutInt</p></td></tr><tr><td class="confluenceTd">AXI-AIU with Proxy Cache</td><td class="confluenceTd"><p>Sys.Coh Sender: interfaces.uSysDceIdInt, interfaces.uSysDveIdInt</p><p>Sys.Event Receiver: <s>interface.uEvtOutInt</s> none</p></td></tr><tr><td colspan="1" class="confluenceTd">AXI-AIU without Proxy Cache</td><td colspan="1" class="confluenceTd">none</td></tr><tr><td colspan="1" class="confluenceTd">ACELite-AIU</td><td colspan="1" class="confluenceTd"><s>none</s> interfaces.uSysDveIdInt</td></tr><tr><td colspan="1" class="confluenceTd">ACELiteE-AIU</td><td colspan="1" class="confluenceTd"><s>none</s> interfaces.uSysDveIdInt</td></tr><tr><td colspan="1" class="confluenceTd">DCE</td><td colspan="1" class="confluenceTd"><p>Sys.Coh Receiver: interfaces.uSysCaIdInt, interfaces.uSysCaNodeIdInt</p><p>Sys.Event Sender: none (Exmon event is internally generated)</p></td></tr><tr><td colspan="1" class="confluenceTd">DVE</td><td colspan="1" class="confluenceTd">Sys.Coh Receiver: interfaces.uSysIdInt, interfaces.uSysNodeIdInt</td></tr><tr><td colspan="1" class="confluenceTd">DMI</td><td colspan="1" class="confluenceTd">none</td></tr><tr><td colspan="1" class="confluenceTd">DII</td><td colspan="1" class="confluenceTd">none</td></tr></tbody></table></div><p><br/></p><p>Error logging format and interrupt is undefined in the architecture spec.</p><p><br/></p><p>DVE Sys.Coh Receiver logs the FUnitId for the received SysReq message that has cmstatus arrival error or target not found error.</p><p>DCE Sys.Coh Receiver logs the FUnitId for the received SysReq message that has cmstatus arrival error or target not found error.</p><p>DCE Sys.Evt Sender logs the FUnitId for the received SysRsp message that has cmstatus arrival error, and logs the protocol timeout error.</p><p>AIU Sys.Evt Receiver logs the FUnitId for the received SysReq message that has cmstatus arrival error, and logs the event timeout error.</p><p><br/></p><p><br/></p><p><strong>The transaction flow for each of the basic building block is shown as below:</strong></p><p><br/></p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="https://arterisip.atlassian.net/wiki/download/attachments/16159947/EventSender.png?api=v2"></span></p><p><br/></p><p><strong>Sys.Event Sender transaction flow</strong></p><p>EventIn.Req -&gt; fork  </p><p>               broadcast SysReq.Event to specified targets</p><p>               collect SysRsp from specified targets</p><p>                       join</p><p>            -&gt; assert EventIn.Ack</p><p>            -&gt; wait for EventIn.Req deassertion</p><p>            -&gt; deassert EventIn.Ack</p><p><br/></p><p><span class="legacy-color-text-blue3">The Sys.Event Sender, when disabled through CSR, shall acknowledge event requests on the 2-wire interface.</span></p><p><br/></p><p>The table below shows the Sys.Event Sender's state machine:</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">current state</th><th class="confluenceTh">next state</th><th class="confluenceTh">trigger</th><th class="confluenceTh">action in current state</th></tr><tr><td class="confluenceTd">IDLE</td><td class="confluenceTd">SEND</td><td class="confluenceTd"><p>event_in_req &amp;&amp;</p><p>csr_sender_enable</p></td><td class="confluenceTd">-</td></tr><tr><td colspan="1" class="confluenceTd">IDLE</td><td colspan="1" class="confluenceTd">WAIT</td><td colspan="1" class="confluenceTd"><p>event_in_req &amp;&amp;</p><p>~csr_sender_enable</p></td><td colspan="1" class="confluenceTd">-</td></tr><tr><td colspan="1" class="confluenceTd">SEND</td><td colspan="1" class="confluenceTd">COLLECT</td><td colspan="1" class="confluenceTd">sending_last_request</td><td colspan="1" class="confluenceTd">issue SysReq.Event till last sent</td></tr><tr><td colspan="1" class="confluenceTd">COLLECT</td><td colspan="1" class="confluenceTd">PROTERR</td><td colspan="1" class="confluenceTd"><p>(all_responses_received &amp;&amp;</p><p>any_sys_rsp_error) ||</p><p>(~all_responses_received &amp;&amp;</p><p>protocol_timeout_error)</p></td><td colspan="1" class="confluenceTd">process SysRsp till last received</td></tr><tr><td colspan="1" class="confluenceTd">COLLECT</td><td colspan="1" class="confluenceTd">WAIT</td><td colspan="1" class="confluenceTd"><p>all_responses_received &amp;&amp;</p><p>~any_sys_rsp_error</p></td><td colspan="1" class="confluenceTd">process SysRsp till last received</td></tr><tr><td colspan="1" class="confluenceTd">PROTERR</td><td colspan="1" class="confluenceTd">WAIT</td><td colspan="1" class="confluenceTd">-</td><td colspan="1" class="confluenceTd">-</td></tr><tr><td colspan="1" class="confluenceTd">WAIT</td><td colspan="1" class="confluenceTd">DELAY</td><td colspan="1" class="confluenceTd"><p>~event_in_req</p></td><td colspan="1" class="confluenceTd">assert event_in_ack</td></tr><tr><td colspan="1" class="confluenceTd">WAIT</td><td colspan="1" class="confluenceTd">EVTERR</td><td colspan="1" class="confluenceTd"><p>event_timeout_error &amp;&amp;</p><p>event_in_req</p></td><td colspan="1" class="confluenceTd">assert event_in_ack</td></tr><tr><td colspan="1" class="confluenceTd">EVTERR</td><td colspan="1" class="confluenceTd">DELAY</td><td colspan="1" class="confluenceTd">-</td><td colspan="1" class="confluenceTd">-</td></tr><tr><td colspan="1" class="confluenceTd">DELAY</td><td colspan="1" class="confluenceTd">IDLE</td><td colspan="1" class="confluenceTd">-</td><td colspan="1" class="confluenceTd">deassert event_in_ack</td></tr></tbody></table></div><p><br/></p><p><strong>How the Sys.Event Sender generates the target_f_unit_id when sending a Sys.Event message</strong></p><p>The Sys.Event Sender has an array of target_f_unit_id (which are static tie off signals) as input ports.</p><p>The Sys.Event Sender uses a counter to iterate through the array of target_f_unit_id to generate the target_f_unit_id when broadcasting a Sys.Event message to targets.</p><p><br/></p><p>Notes taken from the architecture spec regarding Event Sender:</p><p>&quot;&quot;&quot;&quot;</p><p>After sending out all messages, the sender shall provide means to verify that all messages receive responses - as<br/>events will be handled one-at-a-time and no more than one message will be sent to each agent - counting the<br/>number of responses is sufficient.</p><p>An error is considered:<br/>-not all outbound transactions receive a response within the timeout period<br/>-one or more SysRsp return an error status - the status shall reflect accumulated error from all received<br/>responses (most severe error within CMSTATUS -- List to be defined)</p><p>&quot;&quot;&quot;&quot;</p><p><strong>NOTES:</strong><br/><strong><span class="legacy-color-text-blue3">The error logging/handling architecture spec, for system event, only defines protocol timeout error and event timeout error, and the error info is don't care. So the accumulation error status mentioned in the paragraph above is not needed for RTL implementation.</span></strong></p><p><br/></p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="https://arterisip.atlassian.net/wiki/download/attachments/16159947/image2021-6-28_17-3-52.png?api=v2"></span></p><p><br/></p><p><strong>Sys.Event Receiver transaction flow</strong></p><p>SysReq.Event -&gt; assert EventOut.Req</p><p>             -&gt; wait for EventOut.Ack assertion</p><p>             -&gt; deassert EventOut.Req</p><p>             -&gt; wait for EventOut.Ack deassertion</p><p>             -&gt; issue SysRsp as response</p><p><br/></p><p>The Sys.Event Receiver comprises an input queue (depth = one entry per messaging agent), a response generator, a scheduler, and a finite state machine (as event generator for EventOut handshake signaling). Note that the SysReq messages can arrive faster than the EventOut handshake signaling. In other words, source rate can be faster than the sink rate. The scheduler can aggregate multiple arriving messages within a certain time period, and to ensure every arriving SysReq message is responded with a SysRsp message. Every arriving message is tagged with EventGeneratorIdleOrDone (1 when the EventGenerator is idle or done upon the message arrival, else 0). The message at the top of the input queue is translated into Event generation only if its tag EventGeneratorIdleOrDone is 1.</p><p>The Sys.Event Receiver, when disabled through CSR, shall properly terminate all received SysReq.Event messages by responding with SysRsp.Ok.</p><p>The Sys.Event Receiver processes incoming SysReq messages in order and issues outgoing SysRsp messages in the same order as the SysReq arrival order.</p><p><br/></p><p>The table below shows the cm_status field in the SysRsp message:</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/></colgroup><tbody><tr><th class="confluenceTh"><p>SysRsp cm_status[7:0]</p></th><th class="confluenceTh">Comments</th></tr><tr><td class="confluenceTd"><p>01_000_000</p></td><td class="confluenceTd"><p>SysRsp.Error NoOperationPerformed for arrival error, or event timeout.</p></td></tr><tr><td class="confluenceTd">00_000_000</td><td class="confluenceTd">SysRsp.Ok NoOperationPerformed for receiver disabled.</td></tr><tr><td class="confluenceTd">00_000_001</td><td class="confluenceTd">SysRsp.Ok Busy for receiver busy.</td></tr><tr><td colspan="1" class="confluenceTd">00_000_011</td><td colspan="1" class="confluenceTd">SysRsp.Ok OperationPerformed for event completion.</td></tr></tbody></table></div><p><br/></p><p>The table below shows the Sys.Event Receiver's state machine:</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">current state</th><th class="confluenceTh">next state</th><th class="confluenceTh">trigger</th><th colspan="1" class="confluenceTh">action in current state</th></tr><tr><td class="confluenceTd">IDLE</td><td class="confluenceTd">SETEV</td><td class="confluenceTd"><p>sysreq_fifo__pop_valid &amp;&amp;</p><p>EventGeneratorIdleOrDone &amp;&amp;</p><p>csr_receiver_enable &amp;&amp;</p><p>~cmstatus_arrival_err</p></td><td colspan="1" class="confluenceTd">-</td></tr><tr><td class="confluenceTd">IDLE</td><td class="confluenceTd">DONE</td><td class="confluenceTd"><p>sysreq_fifo__pop_valid &amp;&amp;</p><p>(~EventGeneratorIdleOrDone ||</p><p>~csr_receveir_enable ||</p><p>cmstatus_arrival_err)</p></td><td colspan="1" class="confluenceTd">-</td></tr><tr><td class="confluenceTd">SETEV</td><td class="confluenceTd">WFA</td><td class="confluenceTd">-</td><td colspan="1" class="confluenceTd">Assert event_out_req</td></tr><tr><td colspan="1" class="confluenceTd">WFA</td><td colspan="1" class="confluenceTd">CLREV</td><td colspan="1" class="confluenceTd">event_out_ack || event_timeout</td><td colspan="1" class="confluenceTd">Waiting for ack assertion or timeout</td></tr><tr><td colspan="1" class="confluenceTd">CLREV</td><td colspan="1" class="confluenceTd">DONE</td><td colspan="1" class="confluenceTd">~event_out_ack || event_timeout</td><td colspan="1" class="confluenceTd"><p>Deassert event_out_req</p><p>Waiting for ack deassertion or timeout</p></td></tr><tr><td colspan="1" class="confluenceTd">DONE</td><td colspan="1" class="confluenceTd">IDLE</td><td colspan="1" class="confluenceTd"><p>EventGeneratorIdleOrDone &amp;&amp;</p><p>sysrsp_fifo__push_ready</p></td><td colspan="1" class="confluenceTd">Issue SysRsp by pushing to sysrsp_fifo and popping sysreq_fifo</td></tr></tbody></table></div><p><br/></p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="https://arterisip.atlassian.net/wiki/download/attachments/16159947/SysCohSender.png?api=v2"></span></p><p><br/></p><p><strong>Sys.Coh Sender transaction flow</strong></p><p>SysCo.Req asserts -&gt; fork  </p><p>               broadcast SysReq.Attach to specified targets</p><p>               collect SysRsp from specified targets</p><p>                             join</p><p>                  -&gt; assert SysCo.Ack</p><p>SysCo.Req deasserts -&gt; Wait for Coherent Transaction Counter == 0 </p><p>                    -&gt; fork  </p><p>               broadcast SysReq.Detach to specified targets</p><p>               collect SysRsp from specified targets</p><p>                       join</p><p>                    -&gt; deassert SysCo.Ack</p><p><br/></p><p>The table below shows the Sys.Coh Sender's state machine:</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">current state</th><th class="confluenceTh">next state</th><th class="confluenceTh">trigger</th><th class="confluenceTh">action in current state</th></tr><tr><td class="confluenceTd">IDLE</td><td class="confluenceTd">CONNECT</td><td class="confluenceTd">sysco_req</td><td class="confluenceTd">deasserts sysco_ack</td></tr><tr><td class="confluenceTd">CONNECT</td><td class="confluenceTd">ATTACH_ERR</td><td class="confluenceTd"><p>all_requests_sent &amp;&amp;</p><p>all_responses_received &amp;&amp;</p><p>(any_sys_rsp_error ||</p><p>protocol_timeout_error)</p></td><td class="confluenceTd"><p>issue SysReq.Attach till last sent</p><p>process SysRsp till last received</p></td></tr><tr><td class="confluenceTd">CONNECT</td><td class="confluenceTd">ATTACHED</td><td class="confluenceTd"><p>all_requests_sent &amp;&amp;</p><p>all_responses_received &amp;&amp;</p><p>~any_sys_rsp_error &amp;&amp;</p><p>~protocol_timeout_error &amp;&amp;</p><p>sysco_req</p></td><td class="confluenceTd"><p>asserts sysco_ack</p><p>issue SysReq.Attach till last sent</p><p>process SysRsp till last received</p></td></tr><tr><td colspan="1" class="confluenceTd">CONNECT</td><td colspan="1" class="confluenceTd">DISCONNECT</td><td colspan="1" class="confluenceTd"><p>all_requests_sent &amp;&amp;</p><p>all_responses_received &amp;&amp;</p><p>~any_sys_rsp_Error &amp;&amp;</p><p>~protocol_timeout_error &amp;&amp;</p><p>~sysco_req</p></td><td colspan="1" class="confluenceTd"><p>issue SysReq.Attach till last sent</p><p>process SysRsp till last received</p></td></tr><tr><td colspan="1" class="confluenceTd">ATTACHED</td><td colspan="1" class="confluenceTd">COHERENT_WAIT</td><td colspan="1" class="confluenceTd">~sysco_req</td><td colspan="1" class="confluenceTd">-</td></tr><tr><td colspan="1" class="confluenceTd">COHERENT_WAIT</td><td colspan="1" class="confluenceTd">DISCONNECT</td><td colspan="1" class="confluenceTd">outstanding_coherent_count_zero</td><td colspan="1" class="confluenceTd">-</td></tr><tr><td colspan="1" class="confluenceTd">DISCONNECT</td><td colspan="1" class="confluenceTd">DETACH_ERR</td><td colspan="1" class="confluenceTd"><p>all_requests_sent &amp;&amp;</p><p>all_responses_received &amp;&amp;</p><p>(any_sys_rsp_error ||</p><p>protocol_timeout_error)</p></td><td colspan="1" class="confluenceTd"><p>issue SysReq.Detach till last sent</p><p>process SysRsp till last received</p></td></tr><tr><td colspan="1" class="confluenceTd">DISCONNECT</td><td colspan="1" class="confluenceTd">IDLE</td><td colspan="1" class="confluenceTd"><p>all_requests_sent &amp;&amp;</p><p>all_responses_received &amp;&amp;</p><p>(~any_sys_rsp_error &amp;&amp;</p><p>~protocol_timeout_error)</p></td><td colspan="1" class="confluenceTd"><p>issue SysReq.Detach till last sent</p><p>process SysRsp till last received</p></td></tr><tr><td colspan="1" class="confluenceTd">DETACH_ERR</td><td colspan="1" class="confluenceTd">IDLE</td><td colspan="1" class="confluenceTd">-</td><td colspan="1" class="confluenceTd">-</td></tr></tbody></table></div><p><br/></p><p><strong>How the Sys.Coh Sender generates the target_f_unit_id when sending a Sys.Coh message</strong></p><p>The Sys.Coh Sender has an array of target_f_unit_id (which are static tie off signals) as input ports.</p><p>The Sys.Coh Sender uses a counter to iterate through the array of target_f_unit_id to generate the target_f_unit_id when broadcasting a Sys.Coh message to targets.</p><p><br/></p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="https://arterisip.atlassian.net/wiki/download/attachments/16159947/SysCohReceiver.png?api=v2"></span></p><p><br/></p><p><strong>Sys.Coh Receiver transaction flow</strong></p><p><br/></p><p>SysReq.Attach -&gt; enable SnpCmd to CAIU[x] (i.e. Snoop Enable register or T bit vector register )</p><p>              -&gt; issue SysRsp as response</p><p>SysReq.Detach -&gt; disable SnpCmd to CAIU[x]</p><p>              -&gt; Wait for Outstanding Snoop Count OSC[x] == 0</p><p>              -&gt; issue SysRsp as response</p><p><br/></p><p>The Sys.Coh Receiver comprises an input queue (depth = one entry per messaging agent), a response generator with a finite state machine. </p><p>The Sys.Coh Receiver, when disabled through CSR, shall properly terminate all received SysReq.Attach/Detach messages by responding with SysRsp.Ok.</p><p>The Sys.Coh Receiver processes incoming SysReq messages in order and issues outgoing SysRsp messages in the same order as the SysReq arrival order.</p><p><br/></p><p>On receipt of SysReq.Attach:<br/> * Map the SourceID of the arriving SysReq to the associated T[i] and set the bit.<br/> * Issue a SysRsp.Ok if the CMStatus of SysReq is OK.<br/> * Issue a SysRsp.Error if<br/> i. CMSatus of SysReq indicates an error<br/> ii. target does not exist within the T-vector<br/> iii. target is already set (NOTE: This is not implemented. The architecture spec says &quot;We should not see duplicate attempts to set/clear a bit, this would be considered a protocol violation&quot;. The reason it's not implemented because there's no harm in setting a bit twice. Note that SysCo can be CSR driven by Software.) <br/><br/>On receipt of SysReq.Detach:<br/> * Map the SourceID of the arriving SysReq to the associated T[i] and clear the bit<br/> * Issue a SysRsp.Ok if the CMStatus of SysReq is OK<br/> * Issue a SysRsp.Error if<br/>i. CMStatus of SysReq indicates an error<br/>ii. Target does not exist within the T-vector<br/>iii. Target is already clear (NOTE: This is not implemented. The architecture spec says &quot;We should not see duplicate attempts to set/clear a bit, this would be considered a protocol violation&quot;. The reason it's not implemented because there's no harm in clearing a bit twice. Note that SysCo can be CSR driven by Software) </p><p><br/></p><p>The table below shows the Sys.Coh Receiver's state machine:</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">current state</th><th class="confluenceTh">next state</th><th class="confluenceTh">trigger</th><th class="confluenceTh">action in current state</th></tr><tr><td class="confluenceTd">IDLE</td><td class="confluenceTd">SETSNP</td><td class="confluenceTd"><p>sysreq_fifo__pop_valid &amp;&amp;</p><p>~cmstatus_arrival_err &amp;&amp;</p><p>op_attach</p></td><td class="confluenceTd">-</td></tr><tr><td colspan="1" class="confluenceTd">IDLE</td><td colspan="1" class="confluenceTd">CLRSNP</td><td colspan="1" class="confluenceTd"><p>sysreq_fifo__pop_valid &amp;&amp;</p><p>~cmstatus_arrival_err &amp;&amp;</p><p>op_detach</p></td><td colspan="1" class="confluenceTd">-</td></tr><tr><td colspan="1" class="confluenceTd">IDLE</td><td colspan="1" class="confluenceTd">DONE</td><td colspan="1" class="confluenceTd"><p>sysreq_fifo__pop_valid &amp;&amp;</p><p>~cmstatus_arrival_err &amp;&amp;</p><p>~op_attach &amp;&amp;</p><p>~op_detach</p></td><td colspan="1" class="confluenceTd">-</td></tr><tr><td class="confluenceTd">SETSNP</td><td class="confluenceTd">DONE</td><td class="confluenceTd">-</td><td class="confluenceTd"><p>bit set in snoop_enables[i]</p></td></tr><tr><td class="confluenceTd">CLRSNP</td><td class="confluenceTd">WFOSC</td><td class="confluenceTd">-</td><td class="confluenceTd">bit cleared in snoop_enables[i]</td></tr><tr><td colspan="1" class="confluenceTd">WFOSC</td><td colspan="1" class="confluenceTd">DONE</td><td colspan="1" class="confluenceTd">outstanding_snoop_count_zero</td><td colspan="1" class="confluenceTd">-</td></tr><tr><td colspan="1" class="confluenceTd">DONE</td><td colspan="1" class="confluenceTd">IDLE</td><td colspan="1" class="confluenceTd">sysrsp_fifo__push_ready</td><td colspan="1" class="confluenceTd">issue SysRsp by pushing into sysrsp_fifo</td></tr></tbody></table></div><p><br/></p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/></colgroup><tbody><tr><th class="confluenceTh">SysRsp cm_status[7:0]</th><th class="confluenceTh">Comments</th></tr><tr><td class="confluenceTd">01_000_000</td><td class="confluenceTd">SysRsp.Error NoOperationPerformed for arrival error.</td></tr><tr><td class="confluenceTd">00_000_011</td><td class="confluenceTd">SysRsp.Ok OperationPerformed for protocol completion.</td></tr></tbody></table></div><p><br/></p><p><strong>How the Sys.Coh Receiver maps the initiator_f_unit_id in an arriving message to the bit position in the Snoop Enable (also called T or SnpCmd) register </strong></p><p>The Sys.Coh Receiver has an array of AIU's f_unit_id and n_unit_id (which are static tie off signals) as input ports.</p><p>The Sys.Coh Receiver first finds the matching index in the array of AIU's f_unit_id, and uses the matching index to select the AIU's n_unit_id, and uses the selected AIU's n_unit_id as the bit position of the Snoop Enable register.</p><p><br/></p><h2 id="SystemEventandCoherencyWrapper-CSRRegisters"><strong>CSR Registers</strong></h2><p>For Sys.Event Receiver:<br/>u.port('input', 'csr_event_timeout_value', wEventTimeout);<br/>u.port('input', 'csr_sys_evt_receiver_enable', 1);<br/>u.port('output', 'csr_sys_evt_receiver_err_vld', 1);</p><p><br/>For Sys.Event Sender:<br/>u.port('input', 'csr_event_timeout_value', wEventTimeout);<br/>u.port('input', 'csr_protocol_timeout_value', wProtocolTimeout);<br/>u.port('input', 'csr_sys_evt_sender_enable', 1);<br/>u.port('output', 'csr_sys_evt_sender_err_vld', 1);</p><p>For Sys.Coh Receiver:<br/>u.port('output', 'csr_sys_coh_receiver_err_vld', 1);<br/>u.port('output', 'snoop_enables', wSnoopEnables);</p><p>For Sys.Coh Sender:<br/>u.port('input', 'csr_protocol_timeout_value', wProtocolTimeout);<br/>u.port('input', 'csr_sys_coh_sender_activate', 1);<br/>u.port('output', 'csr_sys_coh_sender_connecting', 1);<br/>u.port('output', 'csr_sys_coh_sender_attached', 1);<br/>u.port('output', 'csr_sys_coh_sender_err_detected', 1);</p><p><br/></p><p>For CHI-AIU registers definition, see: hw-ncr/cpr/csr/chi_aiu.csr.cpr</p><p>For IOAIU registers definition, see: hw-ncr/cpr/csr/ioaiu.csr.cpr</p><p>For DCE registers definition, see: hw-ncr/cpr/csr/dce.csr.cpr</p><p>For DVE registers definition, see: hw-ncr/cpr/csr/dve.csr.cpr</p><p><br/></p><h3 id="SystemEventandCoherencyWrapper-SystemArchitecturespecchangesrelatedtoCSRregistersforEventhandlingandSysCo."><strong>System Architecture spec changes related to CSR registers for Event handling and SysCo.</strong></h3><p>xTCR and xTAR registers should be updated to support Event handling and SysCo.</p><p>Note that all Error related info will be moved to Ncore error registers</p><p>The two thresholds Event thereshold and the protocol threshold should use the same thresold as the general timeout threshold</p><p><br/></p><p>For CHI-AIU and IOAIU, their TCR (Transaction Control Register) and TAR (Transaction Activity Register) are updated with newly added bits.</p><p>For DCE, TCR is added (there was none before), and TAR doesn’t need to be updated because DCE is a SysCo receiver.</p><p>For DVE, no change because DVE does not have any Event sender nor receiver, and DVE is only a SysCo receiver.</p><p><br/></p><p>DCE:  DCEU<strong>TCR</strong> @ address offset=0x40</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/><col/></colgroup><tbody><tr><td class="confluenceTd"><p><strong>Bits</strong></p></td><td class="confluenceTd"><p><strong>Name</strong></p></td><td class="confluenceTd"><p><strong>Access </strong></p></td><td class="confluenceTd"><p><strong>Reset</strong></p></td><td class="confluenceTd"><p><strong>Description </strong></p></td></tr><tr><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>EventDisable</p></td><td class="confluenceTd"><p>R/W</p></td><td class="confluenceTd"><p>0x1</p></td><td class="confluenceTd"><p>Setting this disables Event handling (only applicable for blocks that have event handling else reserved)</p></td></tr></tbody></table></div><p>NOTE: I have to change the reset value of Event Disable to 0x1 to prevent DCE sending out ExMon events by default, which would cause our TB to flag a test failure.</p><p><br/></p><p>DCE:  DCEU<strong>TAR</strong> @ address offset=0x44</p><p>  no change.</p><p><br/></p><p><br/></p><p>CHI-AIU: CAIU<strong>TCR</strong> @ address offset=0x40</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/><col/></colgroup><tbody><tr><td class="confluenceTd"><p><strong>Bits</strong></p></td><td class="confluenceTd"><p><strong>Name</strong></p></td><td class="confluenceTd"><p><strong>Access </strong></p></td><td class="confluenceTd"><p><strong>Reset</strong></p></td><td class="confluenceTd"><p><strong>Description </strong></p></td></tr><tr><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>RDisable</p></td><td class="confluenceTd"><p>R/W</p></td><td class="confluenceTd"><p>0x0</p></td><td class="confluenceTd"><p>This controls whether a new request can be accepted inside the AIU  (only applicable to AIUs. for blocks that do not have this control mark it as reserved)</p></td></tr><tr><td class="confluenceTd"><p>1:3</p></td><td class="confluenceTd"><p>Reserved</p></td><td class="confluenceTd"><p>RO</p></td><td class="confluenceTd"><p>0x0</p></td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>EventDisable</p></td><td class="confluenceTd"><p>R/W</p></td><td class="confluenceTd"><p>0x0</p></td><td class="confluenceTd"><p>Setting this disables Event handling (only applicable for blocks that have event handling else reserved)</p></td></tr><tr><td class="confluenceTd"><p>7:5</p></td><td class="confluenceTd"><p>Reserved</p></td><td class="confluenceTd"><p>RO</p></td><td class="confluenceTd"><p>0x0</p></td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd"><p>8</p></td><td class="confluenceTd"><p>SysCoDisable  </p></td><td class="confluenceTd"><p>R/W</p></td><td class="confluenceTd"><p>0x0</p></td><td class="confluenceTd"><p>Setting this disables sysco (only applicable for blocks that have sysco else reserved)</p></td></tr><tr><td class="confluenceTd"><p>9</p></td><td class="confluenceTd"><p>SysCoAttach</p></td><td class="confluenceTd"><p>R/W</p></td><td class="confluenceTd"><p>0x0</p></td><td class="confluenceTd"><p>Writing 1 to this bit when the status register bit SysCoAttached is 0 starts an attach sequence. Writing 0 to this bit when the status register bit SysCoAttached is 1 starts a detach sequence. NOTE: This control is an OR with the SysCo HW interface signal &quot;sysco_req&quot;.</p></td></tr><tr><td class="confluenceTd"><p>31:10</p></td><td class="confluenceTd"><p>Reserved</p></td><td class="confluenceTd"><p><br/></p></td><td class="confluenceTd"><p><br/></p></td><td class="confluenceTd"><p><br/></p></td></tr></tbody></table></div><p><br/></p><p><br/></p><p>CHI-AIU:  CAIU<strong>TAR</strong> @ address offset=0x44</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/><col/></colgroup><tbody><tr><td class="confluenceTd"><p><strong>Bits</strong></p></td><td class="confluenceTd"><p><strong>Name</strong></p></td><td class="confluenceTd"><p><strong>Access </strong></p></td><td class="confluenceTd"><p><strong>Reset</strong></p></td><td class="confluenceTd"><p><strong>Description </strong></p></td></tr><tr><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>TransActv</p></td><td class="confluenceTd"><p>RO</p></td><td class="confluenceTd"><p>0x0</p></td><td class="confluenceTd"><p>This bit is set when AIU is performing any activity related to native agent transactions.</p></td></tr><tr><td class="confluenceTd"><p>1:3</p></td><td class="confluenceTd"><p>Reserved</p></td><td class="confluenceTd"><p>RO</p></td><td class="confluenceTd"><p>0x0</p></td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>SysCoConnecting</p></td><td class="confluenceTd"><p>RO</p></td><td class="confluenceTd"><p>0x0</p></td><td class="confluenceTd"><p>1 indicates that SysCo is in the process of connecting</p></td></tr><tr><td class="confluenceTd"><p>5</p></td><td class="confluenceTd"><p>SysCoAttached</p></td><td class="confluenceTd"><p>RO</p></td><td class="confluenceTd"><p>0x0</p></td><td class="confluenceTd"><p>1 indicates that SysCo is Attached; 0 indicates it is detached</p></td></tr><tr><td class="confluenceTd"><p>6</p></td><td class="confluenceTd"><p>SysCoError</p></td><td class="confluenceTd"><p>RO</p></td><td class="confluenceTd"><p>0x0</p></td><td class="confluenceTd"><p>1  Indicates Error was detected during previous or current SysCo event. This bit clears itself when the Sysco process triggers next time</p></td></tr><tr><td class="confluenceTd"><p>31:7</p></td><td class="confluenceTd"><p>Reserved</p></td><td class="confluenceTd"><p><br/></p></td><td class="confluenceTd"><p><br/></p></td><td class="confluenceTd"><p><br/></p></td></tr></tbody></table></div><p><br/></p><p><br/></p><p>IOAIU:   XAIUTCR @ address offset=0x40</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/><col/></colgroup><tbody><tr><td class="confluenceTd"><p><strong>Bits</strong></p></td><td class="confluenceTd"><p><strong>Name</strong></p></td><td class="confluenceTd"><p><strong>Access </strong></p></td><td class="confluenceTd"><p><strong>Reset</strong></p></td><td class="confluenceTd"><p><strong>Description </strong></p></td></tr><tr><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>Reserved</p></td><td class="confluenceTd"><p>RO</p></td><td class="confluenceTd"><p>0x0</p></td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd"><p>1:3</p></td><td class="confluenceTd"><p>Reserved</p></td><td class="confluenceTd"><p>RO</p></td><td class="confluenceTd"><p>0x0</p></td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>EventDisable</p></td><td class="confluenceTd"><p>R/W</p></td><td class="confluenceTd"><p>0x0</p></td><td class="confluenceTd"><p>Setting this disables Event handling (only applicable for blocks that have event handling else reserved)</p></td></tr><tr><td class="confluenceTd"><p>7:5</p></td><td class="confluenceTd"><p>Reserved</p></td><td class="confluenceTd"><p>RO</p></td><td class="confluenceTd"><p>0x0</p></td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd"><p>8</p></td><td class="confluenceTd"><p>SysCoDisable  </p></td><td class="confluenceTd"><p>R/W</p></td><td class="confluenceTd"><p>0x0</p></td><td class="confluenceTd"><p>Setting this disables sysco (only applicable for blocks that have sysco else reserved)</p></td></tr><tr><td class="confluenceTd"><p>9</p></td><td class="confluenceTd"><p>SysCoAttach</p></td><td class="confluenceTd"><p>R/W</p></td><td class="confluenceTd"><p>0x0</p></td><td class="confluenceTd"><p>Writing 1 to this bit when the status register bit SysCoAttached is 0 starts an attach sequence. Writing 0 to this bit when the status register bit SysCoAttached is 1 starts a detach sequence. NOTE: This control is an OR with the SysCo HW interface signal &quot;sysco_req&quot; if present.</p></td></tr><tr><td class="confluenceTd"><p>15:10</p></td><td class="confluenceTd"><p><br/></p></td><td class="confluenceTd"><p><br/></p></td><td class="confluenceTd"><p><br/></p></td><td class="confluenceTd"><p><br/></p></td></tr><tr><td class="confluenceTd"><p>17:16</p></td><td class="confluenceTd"><p>TransOrderModeRd</p></td><td class="confluenceTd"><p>R/W</p></td><td class="confluenceTd"><p>0x0</p></td><td class="confluenceTd"><p>Field is only applicable to IOAIU currently this is located at 1:0 and needs to move to this location</p></td></tr><tr><td class="confluenceTd"><p>19:18</p></td><td class="confluenceTd"><p>TransOrderModeWR</p></td><td class="confluenceTd"><p>R/W</p></td><td class="confluenceTd"><p>0x0</p></td><td class="confluenceTd"><p>Field is only applicable to IOAIU currently this is located at 1:0 and needs to move to this location</p></td></tr><tr><td class="confluenceTd"><p>31:20</p></td><td class="confluenceTd"><p>Reserved</p></td><td class="confluenceTd"><p><br/></p></td><td class="confluenceTd"><p><br/></p></td><td class="confluenceTd"><p><br/></p></td></tr></tbody></table></div><p><br/></p><p><br/></p><p>IOAIU  XAIUTAR @ address offset=0x44</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/><col/></colgroup><tbody><tr><td class="confluenceTd"><p><strong>Bits</strong></p></td><td class="confluenceTd"><p><strong>Name</strong></p></td><td class="confluenceTd"><p><strong>Access </strong></p></td><td class="confluenceTd"><p><strong>Reset</strong></p></td><td class="confluenceTd"><p><strong>Description </strong></p></td></tr><tr><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>TransActv</p></td><td class="confluenceTd"><p>RO</p></td><td class="confluenceTd"><p>0x0</p></td><td class="confluenceTd"><p>This bit is set when AIU is performing any activity related to native agent transactions.</p></td></tr><tr><td class="confluenceTd"><p>1:3</p></td><td class="confluenceTd"><p>Reserved</p></td><td class="confluenceTd"><p>RO</p></td><td class="confluenceTd"><p>0x0</p></td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>SysCoConnecting</p></td><td class="confluenceTd"><p>RO</p></td><td class="confluenceTd"><p>0x0</p></td><td class="confluenceTd"><p>1 indicates that SysCo is in the process of connecting</p></td></tr><tr><td class="confluenceTd"><p>5</p></td><td class="confluenceTd"><p>SysCoAttached</p></td><td class="confluenceTd"><p>RO</p></td><td class="confluenceTd"><p>0x0</p></td><td class="confluenceTd"><p>1 indicates that SysCo is Attached; 0 indicates it is detached</p></td></tr><tr><td class="confluenceTd"><p>6</p></td><td class="confluenceTd"><p>SysCoError</p></td><td class="confluenceTd"><p>RO</p></td><td class="confluenceTd"><p>0x0</p></td><td class="confluenceTd"><p>1  Indicates Error was detected during previous or current SysCo event. This bit clears itself when the Sysco process triggers next time</p></td></tr><tr><td class="confluenceTd"><p>31:7</p></td><td class="confluenceTd"><p>Reserved</p></td><td class="confluenceTd"><p><br/></p></td><td class="confluenceTd"><p><br/></p></td><td class="confluenceTd"><p><br/></p></td></tr></tbody></table></div><p><br/></p><p><br/></p><p><br/></p><p><strong>The existing DVE Snoop Enable register has the following definition (see DVE uarch spec):</strong></p><p>&quot;&quot;&quot;&quot;</p><p>DVE Snoop Enable Register is a combo register comprising four 32-bit registers:  DVEUSER0, DVEUSER1, DVEUSER2, DVEUSER3 to support a system that has up to 128 AIUs.</p><p>The width of the DVE Snoop Enable Register is nAius (the number of AIUs in the system). Bit 0 is for AIU0, Bit 1 for AIU1, etc. Whether an AIU is DVM capable or not can be found by writing and reading the corresponding bit in the DVE Snoop Enable Register. If writing a 1 to the bit but reading back 0 from the bit, then the AIU associated with the bit is not DVM capable, and software can find out the NUnitId (Node Unit ID) of that AIU which is the bit position.</p><p>In the write bit mask, the number of bits set to 1 is nDVMAgents. (NOTE: nDVMAgents is less than or equal to nAius).</p><p>DVE uses the values in the array of dvm_aiu_n_unit_id (Node Unit IDs from DVM capable AIUs; connected to DVE as input port) to generate the write bit mask.</p><p>&quot;&quot;&quot;&quot;</p><p>DVE generates a target enable bit vector of width=nDVMAgents, by matching the dvm_n_unit_id_array (array length is nDVMAgents) with the corresponding bits in the DVE Snoop Enable Register.</p><p>The target enable bit vector is fed to the DVE protocol manager for snoop control: if the bit for a target is set, then snoop can be sent to that target, otherwise no snoop can be sent to that target.</p><p><br/></p><p>NOTE:</p><p>The DVE CSR Snoop Enable register acts as a fallback when the SysCo is disabled in the system.</p><p>When SysCo is disabled in the system, then no AIU will issue SysReq.Attach to DVE, and the system software programs the DVE CSR Snoop Enable register to let DVE knows which AIUs are participating in the DVM coherency domain.</p><p><br/></p><p><strong>The newly created DCE Snoop Enable Register uses the DVM Snoop Enable Register definition but put it in the DCE context.</strong></p><p>&quot;&quot;&quot;&quot;</p><p>DCE Snoop Enable Register is a combo register comprising four 32-bit registers:  DCEUSER0, DCEUSER1, DCEUSER2, DCEUSER3 to support a system that has up to 128 AIUs.</p><p>The width of the DCE Snoop Enable Register is nAius (the number of AIUs in the system). Bit 0 is for AIU0, Bit 1 for AIU1, etc. Whether an AIU is DCE snoop capable or not can be found by writing and reading the corresponding bit in the DCE Snoop Enable Register. If writing a 1 to the bit but reading back 0 from the bit, then the AIU associated with the bit is not DCE snoop capable, and software can find out the NUnitId (Node Unit ID) of that AIU which is the bit position.</p><p>In the write bit mask, the number of bits set to 1 is nCachingAgents. (NOTE: nCachingAgents is less than or equal to nAius).</p><p>DCE uses the values in the array of ca_aiu_n_unit_id (Node Unit IDs from DCE snoop capable AIUs; connected to DCE as input port) to generate the write bit mask.</p><p>&quot;&quot;&quot;&quot;</p><p>DCE generates a target enable bit vector of width=nCachingAgents, by matching the ca_n_unit_id_array (array length is nCachingAgents) with the corresponding bits in the DCE Snoop Enable Register.</p><p>The target enable bit vector is fed to the DCE transaction manager for snoop control: if the bit for a target is set, then snoop can be sent to that target, otherwise no snoop can be sent to that target.</p><h2 id="SystemEventandCoherencyWrapper-IntegrationIssuesforDCE"><strong>Integration Issues for DCE</strong></h2><p>The ExMon events in DCE can happen at a rate faster than the Sys.Event Sender can process. So, DCE needs to accumulate multiple ExMon events into one event waiting to be fed to the Sys.Event Sender, while waiting for the ack from the Sys.Event Sender. An ack from the Sys.Event Sender indicates the req processing has finished.</p><p>The event_in_targets bit vector to the Sys.Event Sender is coming from the DCE Snoop Enable register.</p><p>DCE needs to implement CSR registers for:</p><p>csr_sys_evt_sender_enable (output from the DCE CSR module to the event sysco wrapper module)<br/>csr_sys_coh_receiver_err_vld (input to the DCE CSR module from the event sysco wrapper module)<br/>csr_protocol_timeout_value (output from the DCE CSR module to the event sysco wrapper module)<br/>csr_event_timeout_value (output from the DCE CSR module to the event sysco wrapper module)</p><p>snoop_enables (input to the DCE CSR module from the event sysco wrapper module)</p><p>csr_snoop_enables (output from the DCE CSR module to the DCE Transaction Manager; must be read/writeable by software).</p><p>DCE must update csr_snoop_enables with the snoop_enables from the Sys.Coh Receiver.</p><p>The &quot;outstanding_snoop_count_zero&quot; is a bit vector, one bit per caching agent. DCE drives the bit - for a caching agent - high only if the Snoop Credit counter in DCE Transaction Manager for that caching agent has reached its maximum value (i.e. all credits are available).</p><p><br/></p><h2 id="SystemEventandCoherencyWrapper-IntegrationIssuesforDVE"><strong>Integration Issues for DVE</strong></h2><p>DVE must update its existing Snoop Enable register with the Snoop Enable bits from the Sys.Coh Receiver when the Sys.Coh Receiver issues a SysRsp message.</p><p>DVE drives the &quot;outstanding_snoop_count_zero&quot; signal high only if the global Snoop Credit counter in DVE Protocol Manager has reached its maximum value (i.e. all credits are available).</p><p>DVE needs to implement CSR registers for:</p><p>csr_sys_coh_receiver_err_vld (input to the DVE CSR module from the event sysco wrapper module).<br/>snoop_enables (input to the DVE CSR module from the event sysco wrapper module).<br/>csr_snoop_enables (output from the DVE CSR module to the DVE Protocol Manager; must be read/writeable by software).</p><h2 id="SystemEventandCoherencyWrapper-IntegrationIssuesforAIU"><strong>Integration Issues for AIU</strong></h2><p>AIU must implement a register for software to program to indicate the offline/online state of the target AIUs that this AIU communicating with. If the bit for a target AIU indicates offline, then this AIU cannot send any SysReq message to that target AIU, because the target AIU is offline and hence won't respond with SysRsp message.</p><p>AIU needs to implement CSR registers for:</p><p>csr_protocol_timeout_value (output from the AIU CSR module to the event sysco wrapper module)<br/>csr_event_timeout_value (output from the AIU CSR module to the event sysco wrapper module)</p><p>csr_sys_evt_receiver_enable (output from the AIU CSR module to the event sysco wrapper module)<br/>csr_sys_coh_receiver_err_vld (input to the AIU CSR module from the event sysco wrapper module)</p><p>csr_sys_coh_sender_activate (output from the AIU CSR module; this is unused for CHI-AIU because CHI-AIU SysCo is always HW Interface driven)<br/>csr_sys_coh_sender_connecting (input to the AIU CSR module from the event sysco wrapper module)<br/>csr_sys_coh_sender_attached (input to the AIU CSR module from the event sysco wrapper module)<br/>csr_sys_coh_sender_err_detected (input to the AIU CSR module from the event sysco wrapper module)</p><p>AIU drives the &quot;outstanding_coherent_count_zero&quot; signal high only when the AIU OTT transaction table does not have any coherent transaction pending. A transaction in an OTT entry is considered coherent when its CMDreq.ch bit (the coherent attribute bit) is set, or if the CMDreq.cm_type indicates a DVM transaction.</p><p><br/></p><h2 id="SystemEventandCoherencyWrapper-IntegrationGuide"><strong>Integration Guide</strong></h2><p><br/></p><p>CHI-AIU is used as an example.</p><p>CHI-AIU has a Sys.Event Receiver (that receives SysReq and sends SysRsp), and a Sys.Coh Sender (that sends SysReq and receives SysRsp).</p><p>Therefore CHI-AIU Concerto MUX needs to provide SYS_REQ_RX and SYS_RSP_TX ports, as well as SYS_REQ_TX and SYS_RSP_RX ports.</p><p>CHI-AIU top-level needs to provide an EventIn req-ack two-pin interface for the Sys.Event Receiver.</p><p><strong><br/></strong>mkdir &lt;workdir&gt;<br/>cd &lt;workdir&gt;<br/>/engr/dev/tools/script/setup_concerto<br/>source SOURCEME ncore3.0.1<br/>cd $WORK_TOP<br/>$WORK_TOP/dv/scripts/refresh_rtl<br/>source SOURCEME_image</p><p><br/></p><p>NOTE: If you want to skip any of the editing of TACHL cpr files and TACHL rtl files as shown below, you can copy the files from <strong>/home/boon/sys_evt_coh_integration/</strong></p><p><br/></p><p><strong>vi $WORK_TOP/cpr/tachl/chi_aiu.tachl.cpr</strong></p><p><strong>Add these to TxParam object referenced by the ConcMuxMsgParamsParam object:</strong><br/>{<br/> &quot;parameterName&quot;: &quot;sysReq&quot;,<br/> &quot;type&quot;: &quot;object&quot;,<br/> &quot;reference&quot;: &quot;$TACHL_CPR_DIR/lib/reqRspParam.tachl.cpr#ReqParam&quot;,<br/> &quot;parameterType&quot;: &quot;architecture&quot;,<br/> &quot;formula&quot;: &quot;_self.enablePipe = 0;\n_self.pipeDepth = 2;\n_self.dpPresent = 0;\n_self.wNdpBits = system.concertocrequestmessagefields.wSYSNdp;\n_self.wDpBits = 0;\nreturn _self&quot;<br/> },<br/> {<br/> &quot;parameterName&quot;: &quot;sysRsp&quot;,<br/> &quot;type&quot;: &quot;object&quot;,<br/> &quot;reference&quot;: &quot;$TACHL_CPR_DIR/lib/reqRspParam.tachl.cpr#RspParam&quot;,<br/> &quot;parameterType&quot;: &quot;architecture&quot;,<br/> &quot;formula&quot;: &quot;_self.enablePipe = 1;\n_self.pipeDepth = 2;\n_self.dpPresent = 0;\n_self.wNdpBits = system.concertocresponsemessagefields.wSYSrspNdp;\n_self.wDpBits = 0;\nreturn _self&quot;<br/> },<br/><br/></p><p><strong>Add these to RxParam object referenced by the ConcMuxMsgParamsParam object:</strong></p><p>{<br/> &quot;parameterName&quot;: &quot;sysRsp&quot;,<br/> &quot;type&quot;: &quot;object&quot;,<br/> &quot;reference&quot;: &quot;$TACHL_CPR_DIR/lib/reqRspParam.tachl.cpr#RspParam&quot;,<br/> &quot;parameterType&quot;: &quot;architecture&quot;,<br/> &quot;formula&quot;: &quot;_self.enablePipe = 1;\n_self.pipeDepth = 2;\n_self.dpPresent = 0;\n_self.wNdpBits = system.concertocresponsemessagefields.wSYSrspNdp;\n_self.wDpBits = 0;\nreturn _self&quot;<br/> },<br/> {<br/> &quot;parameterName&quot;: &quot;sysReq&quot;,<br/> &quot;type&quot;: &quot;object&quot;,<br/> &quot;reference&quot;: &quot;$TACHL_CPR_DIR/lib/reqRspParam.tachl.cpr#ReqParam&quot;,<br/> &quot;parameterType&quot;: &quot;architecture&quot;,<br/> &quot;formula&quot;: &quot;_self.enablePipe = 0;\n_self.pipeDepth = 2;\n_self.dpPresent = 0;\n_self.wNdpBits = system.concertocrequestmessagefields.wSYSNdp;\n_self.wDpBits = 0;\nreturn _self&quot;<br/> },</p><p><br/></p><p><strong>Add this to InterfacesParam object:</strong></p><p>{<br/> &quot;parameterName&quot;: &quot;uEvtOutInt&quot;,<br/> &quot;type&quot;: &quot;object&quot;,<br/> &quot;formula&quot;: &quot;return unit.Interfaces.internal.uEvtOutInt&quot;,<br/> &quot;parameterType&quot;: &quot;architecture&quot;<br/> },</p><p><br/></p><p><br/><strong>vi $WORK_TOP/rtl/chi_aiu/src/aiu_top.tachl</strong></p><p><br/></p><p>Add this to the Interface Parameter generation section:</p><p>// CHI AIU Event Out interface params generation<br/>var interfaceFunc = new obj.userLib[interfaces.uEvtOutInt.interface];<br/>var evtOutInterface = interfaceFunc.getSignals(interfaces.uEvtOutInt.params);<br/>var evtOutInterfaceBundle = interfaceFunc.getSignalsBundle(interfaces.uEvtOutInt.params);<br/>var evtOutInterfaceName = <a class="external-link" href="http://interfaces.uEvtOutInt.name" rel="nofollow">interfaces.uEvtOutInt.name</a>;<br/>var evtOutInterfaceDirection = interfaces.uEvtOutInt.direction;</p><p><br/></p><p>var evtOutInterfaceBundleFiltered = {};<br/>evtOutInterfaceBundleFiltered = cloneDeep(evtOutInterfaceBundle);<br/>delete evtOutInterfaceBundleFiltered['in'];</p><p><br/></p><p>Add this to the internalFaultInterfaceBundle object.<br/> &quot;cmux_sys_rsp_rx_CE&quot; : 1,<br/> &quot;cmux_sys_req_rx_CE&quot; : 1,</p><p><br/></p><p>Add these to the Concerto MUX message structure creation section:</p><p>var SYS_REQ_TX = obj.userLib.concMsgGen(obj, 'sys_req_tx_', 'ConcMsgBodySYSReq', concParams.hdrParams, concParams.sysReqParams, concMuxTxMsgParams.sysReq, 'tx');<br/>var SYS_RSP_TX = obj.userLib.concMsgGen(obj, 'sys_rsp_tx_', 'ConcMsgBodySYSRsp', concParams.hdrParams, concParams.sysRspParams, concMuxTxMsgParams.sysRsp, 'tx');<br/><br/>var SYS_RSP_RX = obj.userLib.concMsgGen(obj, 'sys_rsp_rx_', 'ConcMsgBodySYSRsp', concParams.hdrParams, concParams.sysRspParams, concMuxRxMsgParams.sysRsp, 'rx');<br/>var SYS_REQ_RX = obj.userLib.concMsgGen(obj, 'sys_req_rx_', 'ConcMsgBodySYSReq', concParams.hdrParams, concParams.sysReqParams, concMuxRxMsgParams.sysReq, 'rx');</p><p><br/></p><p>Push the message structure to the CONC_TX_INTF array and CONC_RX_INT array.</p><p><br/>CONC_TX_INTF.push(CMD_REQ, STR_RSP, DTR_REQ_TX, DTR_RSP_TX, DTW_REQ, SNP_RSP, <strong>SYS_REQ_TX, SYS_RSP_TX</strong>);<br/>CONC_RX_INTF.push(CMD_RSP, STR_REQ, DTR_REQ_RX, DTR_RSP_RX, DTW_RSP, SNP_REQ, CMP_RSP, <strong>SYS_RSP_RX, SYS_REQ_RX</strong>);</p><p><br/></p><p>Add these to the CONC_INTF array.</p><p>CONC_INTF['SYSReqTxInterface'] = SYS_REQ_TX.signals;<br/>CONC_INTF['SYSRspTxInterface'] = SYS_RSP_TX.signals;<br/><br/>CONC_INTF['SYSRspRxInterface'] = SYS_RSP_RX.signals;<br/>CONC_INTF['SYSReqRxInterface'] = SYS_REQ_RX.signals;</p><p><br/></p><p>Declare the evtOutInterface for the I/O:</p><p>obj.lib.interface(evtOutInterfaceName, 'master' , evtOutInterface);</p><p><br/></p><p>Add this wire:</p><p>wire \=evtOutInterfaceName=\in_sync;</p><p><br/></p><p>And this wire in the useResiliency unitDuplication wire declaration section:</p><p>wire dup_unit__\=evtOutInterfaceName=\in_sync;</p><p><br/></p><p>Add the evtOutInterface to the UNIT_INTF array:</p><p> UNIT_INTF.push({<br/> modulePrefix: evtOutInterfaceName,<br/> localPrefix: evtOutInterfaceName,<br/> interface: evtOutInterfaceBundleFiltered,<br/> direction : &quot;master&quot;<br/> });</p><p><br/></p><p>Add the evtOutInterface and evtOutInterfaceName to the &quot;aiu_unit_params&quot; object:</p><p><br/> evtOutInterface: evtOutInterface,<br/> evtOutInterfaceName: evtOutInterfaceName,</p><p><br/></p><p>Add this to the aiu_unit_ports object for aiu_unit module instantiation:</p><p> aiu_unit_ports[evtOutInterfaceName+'in'] = evtOutInterfaceName+'in_sync';</p><p><br/></p><p>Add this to the dup_unit_ports object for the duplicated aiu_unit module instantiation for useResiliency unitDuplication:</p><p> dup_unit_ports[evtOutInterfaceName+'in'] = 'dup_unit__'+evtOutInterfaceName+'in_sync';</p><p><br/></p><p>Add this to the delayInterfaceBundle object for the duplicated aiu_unit module instantiation for useResiliency unitDuplication:</p><p> delayInterfaceBundle[evtOutInterfaceName+'in_sync'] = 1;</p><p><br/></p><p>Add this to the checker_delay_ports object for the checker_delay module instantiation for useResiliency unitDuplication:</p><p> checker_delay_ports['in_'+evtOutInterfaceName+'in_sync'] = 'delay__in_'+evtOutInterfaceName+'in_sync';<br/> checker_delay_ports['out_'+evtOutInterfaceName+'in_sync'] = 'delay__out_'+evtOutInterfaceName+'in_sync';</p><p><br/></p><p>Instantiate the synchronizer for the evtOutInterface's input signal:</p><p><br/></p><p>\=u.instance({<br/> instanceName: 'u_event_out_in_sync',<br/> moduleName: 'dffr_sync',<br/> params: {<br/> 'width' : 1,<br/> 'depth' : 2,<br/> },<br/> ports: {<br/> clk : clkInterfaceName+'clk',<br/> reset_n : clkInterfaceName+'reset_n',<br/> in_data : evtOutInterfaceName+'in',<br/> out_data : evtOutInterfaceName+'in_sync'<br/> }<br/>})=\</p><p><br/></p><p><strong>vi $WORK_TOP/rtl/chi_aiu/src/aiu_unit.tachl</strong></p><p><br/></p><p>Add these to the getParam section:</p><p>var wFPortId = u.getParam('wFPortId');<br/>var wNUnitId = u.getParam('wNUnitId');<br/>var wFUnitId = u.getParam('wFUnitId');<br/>var wMsgId = u.getParam('wMsgId');</p><p>var nCoherencyAgents = nDCEs + 1; //1 for DVE<br/>var nEventAgentsForReceiver = nDCEs;<br/>var wEventTimeout = 8;<br/>var wProtocolTimeout = 20;</p><p><br/>var evtOutInterface = u.getParam('evtOutInterface');<br/>var evtOutInterfaceName = u.getParam('evtOutInterfaceName');</p><p><br/></p><p>Declare the evtOutInterface:</p><p>obj.lib.interface(evtOutInterfaceName, 'master' , evtOutInterface);</p><p><br/></p><p>Declare the wire bundles in the section for Concerto MUX wire declaration:</p><p>\=bundleFunctions.wiresFromInterface('sys_req_tx_' , concertoInterfaces.SYSReqTxInterface,[],obj.lib.bundle )=\<br/>\=bundleFunctions.wiresFromInterface('sys_rsp_rx_' , concertoInterfaces.SYSRspRxInterface,[],obj.lib.bundle )=\<br/>\=bundleFunctions.wiresFromInterface('sys_req_rx_' , concertoInterfaces.SYSReqRxInterface,[],obj.lib.bundle )=\<br/>\=bundleFunctions.wiresFromInterface('sys_rsp_tx_' , concertoInterfaces.SYSRspTxInterface,[],obj.lib.bundle )=\</p><p><br/></p><p>Declare these wires for the sys_evt_coh_concerto module that's configured for CHI-AIU:<br/><br/>wire csr_sys_evt_receiver_enable = 1'b1; //FIXME this should be driven by chi_aiu_csr module<br/>wire csr_sys_evt_receiver_err_vld; //this should go to the chi_aiu_csr module<br/>wire csr_sys_coh_sender_activate = 1'b0; //FIXME this should be driven by chi_aiu_csr module; this is not used because CHI-AIU SysCo is HW interface driven.<br/>wire csr_sys_coh_sender_connecting; //this should go to the chi_aiu_csr module<br/>wire csr_sys_coh_sender_attached; //this should go to the chi_aiu_csr module<br/>wire csr_sys_coh_sender_err_detected; //this should go to the chi_aiu_csr module<br/>wire [\=wEventTimeout-1=\:0] csr_event_timeout_value = {\=wEventTimeout=\{1'b1}}; //FIXME this should be driven by chi_aiu_csr module<br/>wire [\=wProtocolTimeout-1=\:0] csr_protocol_timeout_value = {\=wProtocolTimeout{1'b1}}; //FIXME this should be driven by chi_aiu_csr module<br/>wire outstanding_coherent_count_zero = 1'b1; //FIXME this should be driven by CHI-AIU ott_top module.</p><p><br/></p><p><strong>Instantiate the sys_evt_coh_concerto module:</strong></p><p>wire my_sysco_req;<br/>wire my_sysco_ack;</p><p>\jsbegin<br/>var sys_evt_coh_concerto_params = {<br/>wFUnitId : wFUnitId,<br/>wFPortId : wFPortId,<br/>wNUnitId : wNUnitId,<br/>concParams : concParams,<br/>cmType : cm_type,<br/>sysReqTxInterface : concertoInterfaces.SYSReqTxInterface,<br/>sysRspRxInterface : concertoInterfaces.SYSRspRxInterface,<br/>sysReqRxInterface : concertoInterfaces.SYSReqRxInterface,<br/>sysRspTxInterface : concertoInterfaces.SYSRspTxInterface,</p><p>useSysEvtSender : 0,<br/>useSysEvtReceiver : 1,<br/>useSysCoh : 1,<br/>useSysCohSender : 1,<br/>useSysCoHwInterface : 1,<br/>nCoherencyAgents : nCoherencyAgents,<br/>nEventAgentsForReceiver : nEventAgentsForReceiver,<br/>wEventTimeout : wEventTimeout,<br/>wProtocolTimeout : wProtocolTimeout<br/>};</p><p>var instance_ports_for_sys_evt_coh_concerto = {<br/>clk : clkInterfaceName+'clk',<br/>reset_n : 'gated_reset_n',<br/>my_f_unit_id : unitIdInterfaceName+'my_f_unit_id',<br/>csr_event_timeout_value : 'csr_event_timeout_value',<br/>csr_protocol_timeout_value : 'csr_protocol_timeout_value',</p><p>csr_sys_evt_receiver_enable : 'csr_sys_evt_receiver_enable',<br/>csr_sys_evt_receiver_err_vld : 'csr_sys_evt_receiver_err_vld',<br/>event_out_req : evtOutInterfaceName+'out',<br/>event_out_ack : evtOutInterfaceName+'in',</p><p>csr_sys_coh_sender_activate : 'csr_sys_coh_sender_activate',<br/>csr_sys_coh_sender_connecting : 'csr_sys_coh_sender_connecting',<br/>csr_sys_coh_sender_attached : 'csr_sys_coh_sender_attached',<br/>csr_sys_coh_sender_err_detected : 'csr_sys_coh_sender_err_detected',<br/>sysco_req : 'my_sysco_req',<br/>sysco_ack : 'my_sysco_ack',<br/>outstanding_coherent_count_zero : 'outstanding_coherent_count_zero'<br/>};<br/>for (i=0; i &lt; nCoherencyAgents; i++) {<br/>if (i &lt; nDCEs) {<br/>instance_ports_for_sys_evt_coh_concerto['coherency'+i+'_f_unit_id'] = dceIdInterfaceName + 'f_unit_id' + '[' + (((i+1)*unit_id_width)-1) + ':' + (i*unit_id_width) + ']';<br/>} else {<br/>instance_ports_for_sys_evt_coh_concerto['coherency'+i+'_f_unit_id'] = dveIdInterfaceName + 'f_unit_id';<br/>}<br/>}<br/>\jsend<br/>\=obj.lib.instance({<br/>instanceName: 'u_sys_evt_coh_concerto',<br/>moduleName: 'sys_evt_coh_concerto',<br/>params: sys_evt_coh_concerto_params,<br/>ports: instance_ports_for_sys_evt_coh_concerto,<br/>interfaces: [<br/>{modulePrefix: 'sys_req_tx_', localPrefix: 'sys_req_tx_', interface: concertoInterfaces.SYSReqTxInterface},<br/>{modulePrefix: 'sys_rsp_rx_', localPrefix: 'sys_rsp_rx_', interface: concertoInterfaces.SYSRspRxInterface},<br/>{modulePrefix: 'sys_req_rx_', localPrefix: 'sys_req_rx_', interface: concertoInterfaces.SYSReqRxInterface},<br/>{modulePrefix: 'sys_rsp_tx_', localPrefix: 'sys_rsp_tx_', interface: concertoInterfaces.SYSRspTxInterface}<br/>]<br/>})=\</p><p>assign co_state_disabled = ~my_sysco_req &amp; ~my_sysco_ack;<br/>assign co_state_connect = my_sysco_req &amp; ~my_sysco_ack;<br/>assign co_state_enabled = my_sysco_req &amp; my_sysco_ack;<br/>assign co_state_disconnect = ~my_sysco_req &amp; my_sysco_ack;</p><p>assign my_sysco_req = \=chiInterfaceName=\pipe_sysco_req;</p><p>assign \=chiInterfaceName=\pipe_sysco_ack = my_sysco_ack;</p><p><br/></p><p><br/></p><p><strong><span class="legacy-color-text-blue3">$WORK_TOP/dv/scripts/refresh_rtl</span></strong><br/><strong><span class="legacy-color-text-blue3">source SOURCEME_image</span></strong></p><p><br/></p><p><strong>maestro-server -j /home/alobo/dev/maestro/tests/cases/test_tcl/test_ncore_connectivity/3NDN1DN/output/debug/top.level.clean.json -r sometmpdir</strong></p><p><br/></p><p><strong>/home/boon/tachl_debugc.sh chi_aiu aiu_top.tachl sometmpdir/output/debug/debug_json/caiu2_aiu_top.json</strong></p><p><br/></p><p><strong>vi chi_aiu_output/aiu_top.v</strong></p><p><strong>vi chi_aiu_output/aiu_unit_a.v</strong></p><p><br/></p><p><br/></p><pre class="page view"><br/></pre>