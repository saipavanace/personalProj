<h1 id="QChannelv3.0Testplan-TableofContentstrue">Table of Contents<style type='text/css'>/*<![CDATA[*/
div.rbtoc1759724714544 {padding: 0px;}
div.rbtoc1759724714544 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1759724714544 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class='toc-macro rbtoc1759724714544'>
<ul class='toc-indentation'>
<li><span class='TOCOutline'>1</span> <a href='#QChannelv3.0Testplan-TableofContentstrue'>Table of Contents</a></li>
<li><span class='TOCOutline'>2</span> <a href='#QChannelv3.0Testplan-History'>History</a>
<ul class='toc-indentation'>
<li><span class='TOCOutline'>2.1</span> <a href='#QChannelv3.0Testplan-Version'>Version</a></li>
</ul>
</li>
<li><span class='TOCOutline'>3</span> <a href='#QChannelv3.0Testplan-Reference'>Reference</a></li>
<li><span class='TOCOutline'>4</span> <a href='#QChannelv3.0Testplan-Introduction'>Introduction</a></li>
<li><span class='TOCOutline'>5</span> <a href='#QChannelv3.0Testplan-Testbenchdescription'>Testbench description</a>
<ul class='toc-indentation'>
<li><span class='TOCOutline'>5.1</span> <a href='#QChannelv3.0Testplan-Diagrams'>Diagrams</a></li>
<li><span class='TOCOutline'>5.2</span> <a href='#QChannelv3.0Testplan-SimplifiedTBdiagram'>Simplified TB diagram</a></li>
</ul>
</li>
<li><span class='TOCOutline'>6</span> <a href='#QChannelv3.0Testplan-ListanddescriptionofTBcomponents'>List and description of TB components</a>
<ul class='toc-indentation'>
<li><span class='TOCOutline'>6.1</span> <a href='#QChannelv3.0Testplan-BFMs'>BFMs</a></li>
<li><span class='TOCOutline'>6.2</span> <a href='#QChannelv3.0Testplan-Scoreboard'>Scoreboard</a></li>
<li><span class='TOCOutline'>6.3</span> <a href='#QChannelv3.0Testplan-Interface'>Interface</a></li>
</ul>
</li>
<li><span class='TOCOutline'>7</span> <a href='#QChannelv3.0Testplan-TestScenarios'>Test Scenarios</a></li>
<li><span class='TOCOutline'>8</span> <a href='#QChannelv3.0Testplan-AssertionsList'>Assertions List</a></li>
<li><span class='TOCOutline'>9</span> <a href='#QChannelv3.0Testplan-AssertionsCoverage'>Assertions Coverage</a></li>
<li><span class='TOCOutline'>10</span> <a href='#QChannelv3.0Testplan-TestplanReview&amp;Comments.'>Test plan Review &amp; Comments.</a></li>
</ul>
</div></h1><h1 id="QChannelv3.0Testplan-History">History</h1><h2 id="QChannelv3.0Testplan-Version">Version</h2><div class="table-wrap"><table class="wrapped confluenceTable"><tbody><tr><th class="confluenceTh">Version</th><th class="confluenceTh">Date</th><th class="confluenceTh">Comments</th><th class="confluenceTh">Reviewers</th></tr><tr><td class="confluenceTd">0.0.1</td><td class="confluenceTd"><div class="content-wrapper"><time datetime="2018-07-03" class="date-past">03 Jul 2018</time> </div></td><td class="confluenceTd">Initial</td><td class="confluenceTd"><div class="content-wrapper"><a class="confluence-userlink user-mention" data-account-id="624b36fdfd5e45007046ff24" href="https://arterisip.atlassian.net/wiki/people/624b36fdfd5e45007046ff24?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">Krunal Patel (Deactivated)</a></div></td></tr></tbody></table></div><p><br/></p><h1 id="QChannelv3.0Testplan-Reference">Reference</h1><ul><li>Q channel Spec<br/> <a class="external-link" href="https://developer.arm.com/docs/ihi0068/latest/amba-low-power-interface-specification" rel="nofollow">https://developer.arm.com/docs/ihi0068/latest/amba-low-power-interface-specification</a> </li><li class="WordSection1">Power management agent (PMA) specification and reference <br/><a class="external-link" href="https://confluence.arteris.com/display/ENGR/pma" rel="nofollow">https://confluence.arteris.com/display/ENGR/pma</a>  <br/><br/></li></ul><div class="WordSection1"><h1 id="QChannelv3.0Testplan-Introduction">Introduction</h1><p>Q-Channel Intended for use where simple run-stop quiescence semantics are suitable. Q-Channel is an evolution of the AXI low-power interface, and its naming reflects the fact that the purpose of the interface is the control of device quiescence.</p><p>The Q-Channel interface have the following characteristics:</p><ul><li> Controller-managed transitions between device states.</li><li> A device can: — Indicate that it must exit a lower-power state and enter a higher-functioning state. — Hint that it might accept a request to enter a lower-power state.</li><li> Optionally, a device can deny a state change request.</li><li> Clock domain crossing semantics are robust, to support asynchronous interfacing.</li></ul><p>Ncore 3.0 will implement Q channel support.<br/>Each Ncore block will have a PMA slave module with Q channel.</p><p>This will be a passive implementation, ncore block will not drive the deny signal. It will just indicate if the block is active by properly asserting the active signal on the Q channel, when there are no active transactions in the block, all SMI ports are inactive and if any available Native bus is inactive. The Accept signal on the Q channel is asserted when the block is not active and REQn is asserted.</p><h1 id="QChannelv3.0Testplan-Testbenchdescription">Testbench description</h1><h2 id="QChannelv3.0Testplan-Diagrams">Diagrams</h2><p>Each Ncore block will have a PMA slave module with Q channel.</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="700" src="https://arterisip.atlassian.net/wiki/download/attachments/16777417/final_1.JPG?api=v2"></span></p><h2 id="QChannelv3.0Testplan-SimplifiedTBdiagram">Simplified TB diagram</h2><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="700" src="https://arterisip.atlassian.net/wiki/download/attachments/16777417/Untitled%20Diagram%20(4).jpg?api=v2"></span></p><h1 id="QChannelv3.0Testplan-ListanddescriptionofTBcomponents">List and description of TB components</h1><h2 id="QChannelv3.0Testplan-BFMs"> BFMs</h2><ul><li><span class="confluence-anchor-link conf-macro output-inline">Driver will  drive QREQn signal when requested, In response to QREQn device will drive QACCEPTn </span>to accept the request.</li><li>If device is busy doing transactions, it will drive QACTIVE signal and if QACTIVE is asserted QREQ will not be accepted because device is busy.</li></ul><h2 id="QChannelv3.0Testplan-Scoreboard">Scoreboard</h2><p>            Scoreboard will check the Q channel conditions like, When device accept the QREQn by responding QACCEPTn </p><p>                      </p><h2 id="QChannelv3.0Testplan-Interface">Interface</h2><p>            Q channel Interface will have QACTIVEn, QREQn,  QDENY (*tied to 0)  and QACCEPT signals.</p><h1 id="QChannelv3.0Testplan-TestScenarios">Test Scenarios </h1><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/><col/><col/><col/></colgroup><tbody><tr><th colspan="1" style="text-align: center;" class="confluenceTh">Test Case</th><th style="text-align: center;" class="confluenceTh">Scenario/Intent</th><th style="text-align: center;" class="confluenceTh">Description</th><th style="text-align: center;" class="confluenceTh">Block</th><th colspan="1" style="text-align: center;" class="confluenceTh"><p>Status:</p><p>Pass/Fail</p></th><th colspan="1" style="text-align: center;" class="confluenceTh">Run Command</th><th colspan="1" style="text-align: center;" class="confluenceTh">Remark</th></tr><tr><td colspan="1" class="confluenceTd">dmi_qchannel_sanity_test</td><td class="confluenceTd"><p>Sanity Check : Sending any transactions and once all transaction completed, send QREQ and expect assertion of QACCEPTn.</p></td><td class="confluenceTd"><ul><li>Start Random DMI command sequence</li><li>Once All DMI command get completed, and Q channel ACTIVE signal goes low, Test sequence will<br/>assert QREQn and expect QACCEPTn from Q channel.</li></ul></td><td class="confluenceTd">DMI</td><td colspan="1" class="confluenceTd"> Pass</td><td colspan="1" class="confluenceTd">runsim -t <span>dmi_qchannel_sanity_test </span>-c hw_cfg_7 -e dmi -i 1 -w -v UVM_HIGH</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd"><span>dmi_qchannel_req_during_cmd_test</span></td><td class="confluenceTd">Sending QREQ when block is <span class="inline-comment-marker" data-ref="fd1bff21-db30-4d06-94cf-17205f649bb7">busy</span> doing transactions. : Send any random command and while command execution is going on, send QREQn and Slave should wait for command completion before accepting QREQn.</td><td class="confluenceTd"><ul><li>Start Random DMI command sequence</li><li>When DMI commands are running, and Q channel ACTIVE signal is still Hign, Test sequence will<br/>assert QREQn.</li><li>Q channel should will not respond with QACCEPTn or QDENY but it will wait for all command <br/>completion and de assertion of QACTIVE, then it will Respond with QACCEPT.</li></ul></td><td class="confluenceTd"> DMI</td><td colspan="1" class="confluenceTd"><span>Pass</span></td><td colspan="1" class="confluenceTd"><p><span>runsim -t <span>dmi_qchannel_req_during_cmd_test </span></span></p><p><span>-c hw_cfg_7 -e dmi -i 1 -w -v UVM_HIGH</span></p></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd"><span>dmi_qchannel_req_between_cmd_test</span></td><td class="confluenceTd">Send multiple commands and between two consecutive commands, when slave deassert the ACTIVE, Q channel bfm will assert QREQn and expect QACCEPTn assertion.</td><td class="confluenceTd"><ul><li>Start Random DMI command sequence with congi4 <span>which has &quot;usePMA&quot; support</span></li><li>Once All DMI command get completed, and Q channel ACTIVE signal goes low, Test sequence will<br/>assert QREQn. Q channel should respond with QACCEPTn.</li><li>Once QACCEPTn Received, de assert QREQn.</li><li>Start another Random DMI command sequence, and check if all command gets completed or not and see if DMI<br/>comes out of PMA or not.</li></ul></td><td class="confluenceTd"> DMI</td><td colspan="1" class="confluenceTd"><span>Pass</span></td><td colspan="1" class="confluenceTd"><span>runsim -t <span>dmi_qchannel_req_between_cmd_test </span></span><span>-c hw_cfg_7 -e dmi -i 1 -w -v UVM_HIGH</span></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd"><span>dmi_qchannel_multiple_req_test</span></td><td colspan="1" class="confluenceTd">Send multiple QREQn when block is not in ACTIVE state.</td><td colspan="1" class="confluenceTd"><ul><li style="text-align: left;">Start Random DMI command sequence</li><li style="text-align: left;">Once All DMI command get completed, and Q channel ACTIVE signal goes low, Test sequence will</li><li style="text-align: left;">assert multiple QREQn and expect QACCEPTn from Q channel everytime.</li></ul></td><td colspan="1" class="confluenceTd">DMI</td><td colspan="1" class="confluenceTd"><span>Pass</span></td><td colspan="1" class="confluenceTd"><span>runsim -t <span>dmi_qchannel_multiple_req_test </span></span><span>-c hw_cfg_7 -e dmi -i 1 -w -v UVM_HIGH</span></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd"><span>dmi_qchannel_reset_test</span></td><td colspan="1" class="confluenceTd">Assert Reset when slave has accepted QREQn and block is in Q-State.</td><td colspan="1" class="confluenceTd"><ul><li>Start Random DMI command sequence</li><li>Once All DMI command get completed, and Q channel ACTIVE signal goes low, Test sequence will<br/>assert QREQn and expect QACCEPTn from Q channel.</li><li>Once slave assert the QACCEPTn and enters in Q-State, assert block Reset.</li><li>When Reset deasserted, block should be able to come back to Active state.</li></ul></td><td colspan="1" class="confluenceTd"><span>DMI</span></td><td colspan="1" class="confluenceTd">Pass</td><td colspan="1" class="confluenceTd"><span>runsim -t <span>dmi_qchannel_reset_test</span></span><span>-c hw_cfg_7 -e dmi -i 1 -w -v UVM_HIGH</span></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd"><span>dii_qchannel_sanity_test</span></td><td colspan="1" class="confluenceTd"><span>Sanity Check : Sending any transactions and once all transaction completed, send QREQ and expect assertion of QACCEPTn.</span></td><td colspan="1" class="confluenceTd"><ul><li>Start Random DII command sequence</li><li>Once All DII command get completed, and Q channel ACTIVE signal goes low, Test sequence will<br/>assert QREQn and expect QACCEPTn from Q channel.</li></ul></td><td colspan="1" class="confluenceTd">DII</td><td colspan="1" class="confluenceTd"><span>Pass</span></td><td colspan="1" class="confluenceTd">runsim -e dii -c hw_cfg_7 -t <span>dii_qchannel_sanity_test </span>-i 1 -w -v UVM_DEBUG</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd"><span>dii_qchannel_req_during_cmd_test</span></td><td colspan="1" class="confluenceTd"><span>Sending QREQ when block is busy doing transactions. : Send any random command and while command execution is going on, send QREQn and Slave should wait for command completion before accepting QREQn.</span></td><td colspan="1" class="confluenceTd"><ul><li>Start Random DII command sequence</li><li>When DII commands are running, and Q channel ACTIVE signal is still Hign, Test sequence will<br/>assert QREQn.</li><li>Q channel should will not respond with QACCEPTn or QDENY but it will wait for all command <br/>completion and de assertion of QACTIVE, then it will Respond with QACCEPT.</li></ul></td><td colspan="1" class="confluenceTd"> DII</td><td colspan="1" class="confluenceTd"><span>Pass</span></td><td colspan="1" class="confluenceTd"><span>runsim -e dii -c hw_cfg_7 -t <span>dii_qchannel_req_during_cmd_test </span></span><span>-i 1 -w -v UVM_DEBUG</span></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd"><span>dii_qchannel_req_between_cmd_test</span></td><td class="confluenceTd"><span>Send multiple commands and between two consecutive commands, when slave deassert the ACTIVE, Q channel bfm will assert QREQn and expect QACCEPTn assertion.</span></td><td class="confluenceTd"><ul><li>Start Random DII command sequence with config1 which has &quot;usePMA&quot; support</li><li>Once All DII command get completed, and Q channel ACTIVE signal goes low, Test sequence will<br/>assert QREQn. Q channel should respond with QACCEPTn.</li><li>Once QACCEPTn Received, de assert QREQn.</li><li>Start another Random DII command sequence, and check if all command gets completed or not and see if DII<br/>comes out of PMA or not.</li></ul></td><td class="confluenceTd"> DII</td><td class="confluenceTd"><span>Pass</span></td><td class="confluenceTd"><p>runsim -e dii -c hw_cfg_7 -t dii_qchannel_req_between_cmd_test -i 1 -w -v UVM_DEBUG</p></td><td class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd"><span>dii_qchannel_multiple_req_test</span></td><td colspan="1" class="confluenceTd"><span>Send multiple QREQn when block is not in ACTIVE state.</span></td><td colspan="1" class="confluenceTd"><ul><li>Start Random DII command sequence</li><li>Once All DII command get completed, and Q channel ACTIVE signal goes low, Test sequence will</li><li>assert multiple QREQn and expect QACCEPTn from Q channel everytime.</li></ul></td><td colspan="1" class="confluenceTd">DII</td><td colspan="1" class="confluenceTd"><span>Pass</span></td><td colspan="1" class="confluenceTd"><span>runsim -e dii -c hw_cfg_7 -t <span>dii_qchannel_multiple_req_test </span>-i 1 -w -v UVM_DEBUG</span></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">dii_qchannel_reset_test</td><td colspan="1" class="confluenceTd">Assert Reset when slave has accepted QREQn and block is in Q-State.</td><td colspan="1" class="confluenceTd"><ul><li>Start Random DII command sequence</li><li>Once All DII command get completed, and Q channel ACTIVE signal goes low, Test sequence will<br/>assert QREQn and expect QACCEPTn from Q channel.</li><li>Once slave assert the QACCEPTn and enters in Q-State, assert block Reset.</li><li>When Reset deasserted, block should be able to come back to Active state.</li></ul></td><td colspan="1" class="confluenceTd">DII</td><td colspan="1" class="confluenceTd">Pass</td><td colspan="1" class="confluenceTd"><span>runsim -e dii -c hw_cfg_7 -t </span><span>dii_qchannel_reset_test </span><span>-i 1 -w -v UVM_DEBUG</span></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd"><span>chi_aiu_qchannel_sanity_test</span></td><td class="confluenceTd"><span>Sanity Check : Sending any transactions and once all transaction completed, send QREQ and expect assertion of QACCEPTn.</span></td><td class="confluenceTd"><ul><li>Start Random CHI_AIU command sequence</li><li>Once All CHI_AIU command get completed, and Q channel ACTIVE signal goes low, Test sequence will<br/>assert QREQn and expect QACCEPTn from Q channel.</li></ul></td><td class="confluenceTd">CHI_AIU</td><td class="confluenceTd">Pass</td><td class="confluenceTd"><span>runsim -e chi_aiu <span> -c </span><span>hw_cfg_7</span> -t <span>chi_aiu_qchannel_sanity_test </span></span><span>-i 1 -w</span></td><td class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd"><span>chi_aiu_<span>qchannel_req_during_cmd_test</span></span></td><td class="confluenceTd"><span>Sending QREQ when block is busy doing transactions. : Send any random command and while command execution is going on, send QREQn and Slave should wait for command completion before accepting QREQn.</span></td><td class="confluenceTd"><ul><li>Start Random CHI_AIU command sequence</li><li>When CHI_AIU commands are running, and Q channel ACTIVE signal is still Hign, Test sequence will<br/>assert QREQn.</li><li>Q channel should will not respond with QACCEPTn or QDENY but it will wait for all command <br/>completion and de assertion of QACTIVE, then it will Respond with QACCEPT.</li></ul></td><td class="confluenceTd"> CHI_AIU</td><td class="confluenceTd">Pass</td><td class="confluenceTd"><span>runsim -e chi_aiu <span> -c </span><span>hw_cfg_7</span> -t <span>chi_aiu_</span><span>qchannel_req_during_cmd_test </span></span><span>-i 1 -w</span></td><td class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd"><span>chi_aiu_</span><span>qchannel_req_between_cmd_test</span></td><td class="confluenceTd"><span>Send multiple commands and between two consecutive commands, when slave deassert the ACTIVE, Q channel bfm will assert QREQn and expect QACCEPTn assertion.</span></td><td class="confluenceTd"><ul><li>Start Random CHI_AIU command sequence with congi4 which has &quot;usePMA&quot; support</li><li>Once All CHI_AIU command get completed, and Q channel ACTIVE signal goes low, Test sequence will<br/>assert QREQn. Q channel should respond with QACCEPTn.</li><li>Once QACCEPTn Received, de assert QREQn.</li><li>Start another Random CHI_AIU command sequence, and check if all command gets completed or not and see if CHI_AIU<br/>comes out of PMA or not.</li></ul></td><td class="confluenceTd"> CHI_AIU</td><td class="confluenceTd">Pass</td><td class="confluenceTd">runsim -e chi_aiu <span> -c </span><span>hw_cfg_7</span> -t <span>chi_aiu_</span><span>qchannel_req_between_cmd_test </span>-i 1 -w</td><td class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd"><span>chi_aiu_qchannel_multiple_req</span><span>_test</span></td><td colspan="1" class="confluenceTd"><span>Send multiple QREQn when block is not in ACTIVE state.</span></td><td colspan="1" class="confluenceTd"><ul><li>Start Random CHI_AIU command sequence</li><li>Once All CHI_AIU command get completed, and Q channel ACTIVE signal goes low, Test sequence will</li><li>assert multiple QREQn and expect QACCEPTn from Q channel everytime.</li></ul></td><td colspan="1" class="confluenceTd"> CHI_AIU</td><td colspan="1" class="confluenceTd">Pass</td><td colspan="1" class="confluenceTd">runsim -e chi_aiu <span> -c </span><span>hw_cfg_7 </span>-t chi_aiu_qchannel_multiple_request_test -i 1 -w</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">chi_aiu_qchannel_reset_test</td><td colspan="1" class="confluenceTd">Assert Reset when slave has accepted QREQn and block is in Q-State.</td><td colspan="1" class="confluenceTd"><ul><li>Start Random CHI_AIU command sequence</li><li>Once All CHI_AIU command get completed, and Q channel ACTIVE signal goes low, Test sequence will<br/>assert QREQn and expect QACCEPTn from Q channel.</li><li>Once slave assert the QACCEPTn and enters in Q-State, assert block Reset.</li><li>When Reset deasserted, block should be able to come back to Active state.</li></ul></td><td colspan="1" class="confluenceTd"><span>CHI_AIU</span></td><td colspan="1" class="confluenceTd">Pass</td><td colspan="1" class="confluenceTd"><span>runsim -e chi_aiu <span> -c </span><span>hw_cfg_7 </span>-t chi_aiu_qchannel_reset_test -i 1 -w</span></td><td colspan="1" class="confluenceTd">CONC-6199</td></tr><tr><td colspan="1" class="confluenceTd">dve_qchannel_sanity_test</td><td colspan="1" class="confluenceTd"><span>Sanity Check : Sending any transactions and once all transaction completed, send QREQ and expect assertion of QACCEPTn.</span></td><td colspan="1" class="confluenceTd"><ul><li>Start Random DVE command sequence</li><li>Once All DVE command get completed, and Q channel ACTIVE signal goes low, Test sequence will<br/>assert QREQn and expect QACCEPTn from Q channel.</li></ul></td><td colspan="1" class="confluenceTd">DVE</td><td colspan="1" class="confluenceTd"><span>Pass</span></td><td colspan="1" class="confluenceTd">runsim -e dve -c hw_cfg_7 -t dve_qchannel_sanity_test -i 1 -w</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">dve_qchannel_req_during_cmd_test</td><td colspan="1" class="confluenceTd"><span>Sending QREQ when block is busy doing transactions. : Send any random command and while command execution is going on, send QREQn and Slave should wait for command completion before accepting QREQn.</span></td><td colspan="1" class="confluenceTd"><ul><li>Start Random DVE command sequence</li><li>When DVE commands are running, and Q channel ACTIVE signal is still Hign, Test sequence will<br/>assert QREQn.</li><li>Q channel should will not respond with QACCEPTn or QDENY but it will wait for all command <br/>completion and de assertion of QACTIVE, then it will Respond with QACCEPT.</li></ul></td><td colspan="1" class="confluenceTd">DVE</td><td colspan="1" class="confluenceTd"><span>Pass</span></td><td colspan="1" class="confluenceTd"><p><span>runsim -e dve -c hw_cfg_7 -t <span>dve_qchannel_req_during_cmd_test </span></span></p><p><span>-i 1 -w</span></p></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">dve_qchannel_req_between_cmd_test</td><td colspan="1" class="confluenceTd"><span>Send multiple commands and between two consecutive commands, when slave deassert the ACTIVE, Q channel bfm will assert QREQn and expect QACCEPTn assertion.</span></td><td colspan="1" class="confluenceTd"><ul><li>Start Random DVE command sequence with congi4 which has &quot;usePMA&quot; support</li><li>Once All DVE command get completed, and Q channel ACTIVE signal goes low, Test sequence will<br/>assert QREQn. Q channel should respond with QACCEPTn.</li><li>Once QACCEPTn Received, de assert QREQn.</li><li>Start another Random DVE command sequence, and check if all command gets completed or not and see if DVE<br/>comes out of PMA or not.</li></ul></td><td colspan="1" class="confluenceTd"> DVE</td><td colspan="1" class="confluenceTd"><span>Pass</span></td><td colspan="1" class="confluenceTd"><p><span>runsim -e dve -c hw_cfg_7 -t <span>dve_qchannel_req_between_cmd_test </span></span></p><p><span>-i 1 -w</span></p></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">dve_qchannel_multiple_req_test</td><td colspan="1" class="confluenceTd"><span>Send multiple QREQn when block is not in ACTIVE state.</span></td><td colspan="1" class="confluenceTd"><ul><li>Start Random DVE command sequence</li><li>Once All DVE command get completed, and Q channel ACTIVE signal goes low, Test sequence will</li><li>assert multiple QREQn and expect QACCEPTn from Q channel everytime.</li></ul></td><td colspan="1" class="confluenceTd"> DVE</td><td colspan="1" class="confluenceTd"><span>Pass</span></td><td colspan="1" class="confluenceTd"><p><span>runsim -e dve -c hw_cfg_7 -t <span>dve_qchannel_multiple_req_test </span></span></p><p><span>-i 1 -w</span></p></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">dve_qchannel_reset_test</td><td colspan="1" class="confluenceTd">Assert Reset when slave has accepted QREQn and block is in Q-State.</td><td colspan="1" class="confluenceTd"><ul><li>Start Random DVE command sequence</li><li>Once All <span>DVE </span>command get completed, and Q channel ACTIVE signal goes low, Test sequence will<br/>assert QREQn and expect QACCEPTn from Q channel.</li><li>Once slave assert the QACCEPTn and enters in Q-State, assert block Reset.</li><li>When Reset deasserted, block should be able to come back to Active state.</li></ul></td><td colspan="1" class="confluenceTd"><span>DVE</span></td><td colspan="1" class="confluenceTd">Pass</td><td colspan="1" class="confluenceTd"><p>runsim -e dve -c hw_cfg_7 -t dve_qchannel_reset_test</p><p> -i 1 -w</p></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">dce_qchannel_sanity_test</td><td colspan="1" class="confluenceTd"><span>Sanity Check : Sending any transactions and once all transaction completed, send QREQ and expect assertion of QACCEPTn.</span></td><td colspan="1" class="confluenceTd"><ul><li>Start Random DCE command sequence</li><li>Once All DCE command get completed, and Q channel ACTIVE signal goes low, Test sequence will<br/>assert QREQn and expect QACCEPTn from Q channel.</li></ul></td><td colspan="1" class="confluenceTd">DCE</td><td colspan="1" class="confluenceTd">Pass</td><td colspan="1" class="confluenceTd"><p>runsim -e dce -t <span>-c </span><span>hw_cfg_7 </span>dce_qchannel_sanity_test -i 1 -w</p></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">dce_qchannel_req_during_cmd_test</td><td colspan="1" class="confluenceTd"><span>Sending QREQ when block is busy doing transactions. : Send any random command and while command execution is going on, send QREQn and Slave should wait for command completion before accepting QREQn.</span></td><td colspan="1" class="confluenceTd"><ul><li>Start Random DCE command sequence</li><li>When DCE commands are running, and Q channel ACTIVE signal is still Hign, Test sequence will<br/>assert QREQn.</li><li>Q channel should will not respond with QACCEPTn or QDENY but it will wait for all command <br/>completion and de assertion of QACTIVE, then it will Respond with QACCEPT.</li></ul></td><td colspan="1" class="confluenceTd">DCE</td><td colspan="1" class="confluenceTd">Pass</td><td colspan="1" class="confluenceTd"><p><span>runsim -e dce -c hw_cfg_7 -t <span>dce_qchannel_req_during_cmd_test</span></span></p><p><span>-i 1 -w</span></p></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">dce_qchannel_req_between_cmd_test</td><td colspan="1" class="confluenceTd"><span>Send multiple commands and between two consecutive commands, when slave deassert the ACTIVE, Q channel bfm will assert QREQn and expect QACCEPTn assertion.</span></td><td colspan="1" class="confluenceTd"><ul><li>Start Random DCE command sequence with congi4 which has &quot;usePMA&quot; support</li><li>Once All DCE command get completed, and Q channel ACTIVE signal goes low, Test sequence will<br/>assert QREQn. Q channel should respond with QACCEPTn.</li><li>Once QACCEPTn Received, de assert QREQn.</li><li>Start another Random DCE command sequence, and check if all command gets completed or not and see if DCE<br/>comes out of PMA or not.</li></ul></td><td colspan="1" class="confluenceTd"> DCE</td><td colspan="1" class="confluenceTd">Pass</td><td colspan="1" class="confluenceTd"><p><span>runsim -e dce -c hw_cfg_7 -t <span>dce_qchannel_req_between_cmd_test</span></span></p><p><span>-i 1 -w</span></p></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">dce_qchannel_multiple_req_test</td><td colspan="1" class="confluenceTd"><span>Send multiple QREQn when block is not in ACTIVE state.</span></td><td colspan="1" class="confluenceTd"><ul><li>Start Random DCE command sequence</li><li>Once All DCE command get completed, and Q channel ACTIVE signal goes low, Test sequence will</li><li>assert multiple QREQn and expect QACCEPTn from Q channel everytime.</li></ul></td><td colspan="1" class="confluenceTd"> DCE</td><td colspan="1" class="confluenceTd">Pass</td><td colspan="1" class="confluenceTd"><p>runsim -e dce -c hw_cfg_7 -t dce_qchannel_multiple_request_test</p><p>-i 1 -w</p></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">dce_qchannel_reset_test</td><td colspan="1" class="confluenceTd">Assert Reset when slave has accepted QREQn and block is in Q-State.</td><td colspan="1" class="confluenceTd"><ul><li>Start Random DCE command sequence</li><li>Once there is some activity in DCE, test sequence will<br/>assert QREQn and expect QACCEPTn. DCE will only assert QACCEPTn if all activity in DCE is completed and QACTIVE goes low.</li><li>Once slave(DCE block) assert the QACCEPTn and enters in Q-State, assert block Reset.</li><li>When Reset deasserted, block should be able to come back to Active state, since DM does some memory initialization sequence automatically out of reset.</li></ul></td><td colspan="1" class="confluenceTd">DCE</td><td colspan="1" class="confluenceTd">Pass</td><td colspan="1" class="confluenceTd"><p>runsim -e dce -c hw_cfg_7 -t dce_qchannel_reset_test -i 1 -s 53961163 -w -v UVM_LOW</p></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">ioaiu_qchannel_sanity_test</td><td colspan="1" class="confluenceTd"><span>Sanity Check : Sending any transactions and once all transaction completed, send QREQ and expect assertion of QACCEPTn.</span></td><td colspan="1" class="confluenceTd"><ul><li>Start Random IOAIU command sequence</li><li>Once All IOAIU command get completed, and Q channel ACTIVE signal goes low, Test sequence will<br/>assert QREQn and expect QACCEPTn from Q channel.</li></ul></td><td colspan="1" class="confluenceTd">IOAIU</td><td colspan="1" class="confluenceTd"><span>Pass</span></td><td colspan="1" class="confluenceTd"><p><span>runsim -e ioaiu -c hw_cfg_7 <span>-i 1 -w</span></span></p><p>-t <span>ioaiu_qchannel_sanity_test</span></p><p><br/></p></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">ioaiu_qchannel_req_during_cmd_test</td><td colspan="1" class="confluenceTd"><span>Sending QREQ when block is busy doing transactions. : Send any random command and while command execution is going on, send QREQn and Slave should wait for command completion before accepting QREQn.</span></td><td colspan="1" class="confluenceTd"><ul><li>Start Random IOAIU command sequence</li><li>When IOAIU commands are running, and Q channel ACTIVE signal is still Hign, Test sequence will<br/>assert QREQn.</li><li>Q channel should will not respond with QACCEPTn or QDENY but it will wait for all command <br/>completion and de assertion of QACTIVE, then it will Respond with QACCEPT.</li></ul></td><td colspan="1" class="confluenceTd">IOAIU</td><td colspan="1" class="confluenceTd"><span>Pass</span></td><td colspan="1" class="confluenceTd"><p><span>runsim -e ioaiu -c hw_cfg_7 <span>-i 1 -w</span></span></p><p><span>-t <span>ioaiu_qchannel_req_during_cmd_test</span></span></p></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">ioaiu_qchannel_req_between_cmd_test</td><td colspan="1" class="confluenceTd"><span>Send multiple commands and between two consecutive commands, when slave deassert the ACTIVE, Q channel bfm will assert QREQn and expect QACCEPTn assertion.</span></td><td colspan="1" class="confluenceTd"><ul><li>Start Random IOAIU command sequence with congi4 which has &quot;usePMA&quot; support</li><li>Once All IOAIU command get completed, and Q channel ACTIVE signal goes low, Test sequence will<br/>assert QREQn. Q channel should respond with QACCEPTn.</li><li>Once QACCEPTn Received, de assert QREQn.</li><li>Start another Random IOAIU command sequence, and check if all command gets completed or not and see if IOAIU<br/>comes out of PMA or not.</li></ul></td><td colspan="1" class="confluenceTd"> IOAIU</td><td colspan="1" class="confluenceTd"><span>Pass</span></td><td colspan="1" class="confluenceTd"><p><span>runsim -e ioaiu -c hw_cfg_7 <span>-i 1 -w</span></span></p><p><span> -t i<span>oaiu_qchannel_req_between_cmd_test </span></span></p></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">Ioaiu_qchannel_multiple_req_test</td><td colspan="1" class="confluenceTd">Send multiple QREQn when block is not in ACTIVE state.</td><td colspan="1" class="confluenceTd"><ul><li>Start Random IOAIU command sequence</li><li>Once All IOAIU command get completed, and Q channel ACTIVE signal goes low, Test sequence will</li><li>assert multiple QREQn and expect QACCEPTn from Q channel everytime.</li></ul></td><td colspan="1" class="confluenceTd"> IOAIU</td><td colspan="1" class="confluenceTd">Pass</td><td colspan="1" class="confluenceTd"><p>runsim -e ioaiu -c hw_cfg_7 -t ioaiu_qchannel_multiple_request_test</p><p>-i 1 -w</p></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">ioaiu_qchannel_reset_test</td><td colspan="1" class="confluenceTd">Assert Reset when slave has accepted QREQn and block is in Q-State.</td><td colspan="1" class="confluenceTd"><ul><li>Start Random IOAIU command sequence</li><li>Once All <span>IOAIU</span> command get completed, and Q channel ACTIVE signal goes low, Test sequence will<br/>assert QREQn and expect QACCEPTn from Q channel.</li><li>Once slave assert the QACCEPTn and enters in Q-State, assert block Reset.</li><li>When Reset deasserted, block should be able to come back to Active state.</li></ul></td><td colspan="1" class="confluenceTd"><span>IOAIU</span></td><td colspan="1" class="confluenceTd">Pass</td><td colspan="1" class="confluenceTd"><p>runsim -e ioaiu -c hw_cfg_7 -i 1 -w</p><p>-t ioaiu_qchannel_reset_test</p></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">qchannel_sanity_test</td><td colspan="1" class="confluenceTd">Sanity Check : Sending any transactions and once all transaction completed, send QREQ and expect assertion of QACCEPTn.</td><td colspan="1" class="confluenceTd"><ul><li>Start Random FULL_SYS command sequence</li><li>Once All FULL_SYS command get completed, and Q channel ACTIVE signal goes low, Test sequence will<br/>assert QREQn and expect QACCEPTn from Q channel.</li></ul></td><td colspan="1" class="confluenceTd">FULL_SYS</td><td colspan="1" class="confluenceTd"><p>Pass</p><p><br/></p></td><td colspan="1" class="confluenceTd">runsim -e fsys -c hw_cfg_7 -t qchannel_sanity_test -i 1 -w</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">qchannel_req_during_cmd_test</td><td colspan="1" class="confluenceTd">Sending QREQ when block is busy doing transactions. : Send any random command and while command execution is going on, send QREQn and Slave should wait for command completion before accepting QREQn.</td><td colspan="1" class="confluenceTd"><ul><li>Start Random FULL_SYS command sequence</li><li>When FULL_SYS commands are running, and Q channel ACTIVE signal is still Hign, Test sequence will<br/>assert QREQn.</li><li>Q channel should will not respond with QACCEPTn or QDENY but it will wait for all command <br/>completion and de assertion of QACTIVE, then it will Respond with QACCEPT.</li></ul></td><td colspan="1" class="confluenceTd">FULL_SYS</td><td colspan="1" class="confluenceTd">Pass</td><td colspan="1" class="confluenceTd">runsim -e fsys -c hw_cfg_7 -t qchannel_req_during_cmd_test -i 1 -w</td><td colspan="1" class="confluenceTd"><br/></td></tr></tbody></table></div><p><strong><br/></strong></p><h1 id="QChannelv3.0Testplan-AssertionsList">Assertions List</h1><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Name</th><th class="confluenceTh">Description</th><th class="confluenceTh">Completion Status</th><th class="confluenceTh">Remarks</th></tr><tr><td colspan="1" class="confluenceTd">ASSERT_negREQn</td><td colspan="1" class="confluenceTd">QREQn can only be asserted (-&gt;0) when QACCEPTn is deasserted(1).</td><td colspan="1" class="confluenceTd"> <span>developed</span></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">ASSERT_negACCEPTn</td><td colspan="1" class="confluenceTd"><span><span>QACCEPTn </span>can only be asserted (1-&gt;0) when <span>QREQn </span>is asserted(0).</span></td><td colspan="1" class="confluenceTd"> <span>developed</span></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd"><span>ASSERT_posACCEPTn</span></td><td colspan="1" class="confluenceTd"><span>QACCEPTn </span><span>can only be deasserted (0-&gt;1) when QREQn is deasserted(1).</span></td><td colspan="1" class="confluenceTd"> <span>developed</span></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">ASSERT_Q_CHNL_X_CHECK</td><td colspan="1" class="confluenceTd">Checks  none of the Q-channel signals drives X.</td><td colspan="1" class="confluenceTd"><span> developed</span></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">ASSERT_REQn_ACCEPTn_NOT_ACTIVE</td><td colspan="1" class="confluenceTd"><span>When QACTIVE is low and QREQn asserted, then QACCEPTn should assert within 20 clks.</span></td><td colspan="1" class="confluenceTd"><span> developed</span></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">ASSERT_REQn_ACCEPTn_ACTIVE</td><td colspan="1" class="confluenceTd">When QACTIVE is high and QREQn asserted, then QACCEPTn should assert after QACTIVE goes low.</td><td colspan="1" class="confluenceTd"><span> developed</span></td><td colspan="1" class="confluenceTd"><br/></td></tr></tbody></table></div><p><br/></p><h1 id="QChannelv3.0Testplan-AssertionsCoverage">Assertions Coverage</h1><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Name</th><th class="confluenceTh">Description</th><th class="confluenceTh">Completion Status</th><th class="confluenceTh">Remarks</th></tr><tr><td class="confluenceTd">ASSERT_REQ_DURING_CMD_COV</td><td class="confluenceTd"><p>Property is covered when QREQn is asserted(-&gt;0) and at same time QACTIVE signal is high(1).</p></td><td class="confluenceTd"> developed</td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">ASSERT_REQ_BETWEEN_CMD_COV</td><td class="confluenceTd"><p><span>Property is covered when QREQn is asserted(-&gt;0) and at same time QACTIVE signal is low(0).</span></p></td><td class="confluenceTd"> developed</td><td class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">ASSERT_MULTIPLE_REQ_DURING_CMD_COV</td><td class="confluenceTd"><span>Property is covered when <span> QACTIVE signal is low(0) and QREQn is asserted(-&gt;0) atleast 2 times.</span></span></td><td class="confluenceTd"> developed</td><td class="confluenceTd"><br/></td></tr></tbody></table></div><h1 id="QChannelv3.0Testplan-TestplanReview&amp;Comments.">Test plan Review &amp; Comments.</h1><p>While getting coverage for dve, Boon Chuan found some coverage holdes for PMA. </p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="https://arterisip.atlassian.net/wiki/download/attachments/16777417/NCORE3-DVE-code-coverage-PMA-FSM.JPG?api=v2"></span></p></div><p>Here is the Eric Taylor's comment for missing coverage, Line no. 115,117,131.</p><p>For 131, it will always go straight to the ACTIVE state. Intheory this condition doesnt need to be there for this setup,</p><p>For 115,117 we never abort sleep.</p><div class="WordSection1"><p>          </p></div><div><strong><br/></strong></div>