<p><span class="legacy-color-text-blue3">This is a JS class that can be found in the following path and file:</span><br/><strong>hw-lib/js/lib_utils.js</strong></p><h2 id="classVlogPkdStruct-BaseClass">Base Class</h2><p><a class="external-link" href="https://confluence.arteris.com/display/ENGR/class+VlogSignal" rel="nofollow" style="text-decoration: none;">class VlogSignal</a></p><h2 id="classVlogPkdStruct-Composition">Composition</h2><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156641/class+PkdStruct" data-linked-resource-id="16156641" data-linked-resource-version="3" data-linked-resource-type="page">class PkdStruct</a></p><h2 id="classVlogPkdStruct-Description">Description</h2><p><span class="legacy-color-text-blue3">This class is used to represent a Verilog signal as a packed struct. Each member of a struct can be of a different size, has a name, and corresponds to a chunk of the whole signal. This can be useful in representing fields in a register or to access (by name) signals packed into a single write or read bus of a FIFO.</span></p><p><span class="legacy-color-text-blue3">A chunk is an instance of VlogNet returned when a slice operation is performed on the packed struct signal. Each chunk is generated dynamically during a method call that returns a chunk, instead of creating and storing them during the constructor call to save memory.</span></p><h2 id="classVlogPkdStruct-Interface(Methods)">Interface (Methods)</h2><p><span class="legacy-color-text-blue3">The class provides the following interface methods:</span></p><h4 id="classVlogPkdStruct-constructor(name,members,options)"><em>constructor ( name, members, options )</em></h4><p>Creates an instance of VlogPkdStruct. <em>name</em><span> </span>is the name of the signal that is to be broken into unequal sized-chunks. The <em>members</em> parameter is used to specify the members of the struct. Each member is an array and is expected to have the following structure:<br/>member    = [ <em>name</em>, <em>value</em>, <em>type </em>] where,</p><p><em>name</em>: member name, used to access members of a struct,<br/><em>value</em>: When type === &quot;width&quot;, value can be any object with 'width' property or a  positive integer that specifies the width of the member. When type === &quot;struct&quot;, the value must be an instance of PkdStruct. When type === &quot;array&quot;, the value must be an instance of PkdArray.<br/><em>type</em>: An optional string that can take one of three values: &quot;struct&quot;, &quot;array&quot;, &quot;width&quot;. Default if not specified is &quot;width&quot;.<br/><br/>The members parameter is an array of members<br/>members = [<br/>                     member0,<br/>                     member1,<br/>                     .<br/>                     .<br/>                     . <br/>                   ];<br/>The optional parameter <em>options</em> has the following fields: { endian: &quot;little&quot; or &quot;big&quot;, end: end offset for the VlogSignal }. Parameter <em>endian</em> specifies the endianness order in which the fields in the struct are packed. Default is &quot;little&quot;, i.e. zero-indexed fields occupy the least significant bits.</p><h4 id="classVlogPkdStruct-get(name)"><em>get ( name )</em></h4><p>Return type: VlogSignal. Returns the<span> </span>chunk of the signal that corresponds to the field with the specified name. Because there is no support for operator-overloading in JS, this acts as a substitute for indexing operator [ ]. </p><h4 id="classVlogPkdStruct-entries()"><em>entries ( )</em></h4><p>Return type: iterator. At each step the iterator fetches (value) an array of two elements: [ i, chunk ], where i is the index and chunk is the i<sup>th</sup><span> </span>chunk of the packet signal that is sliced. The return type is modeled after the built-in Array method entries().</p><h2 id="classVlogPkdStruct-DefaultIterator">Default Iterator</h2><p>Any instance of this class has a default iterator that fetches (value) each chunk of the signal starting from index 0 till the last index. In order to get an array from an iterator, one could use Array.from( ) or array destructuring instead.</p><h2 id="classVlogPkdStruct-Usage">Usage</h2><p>const busStruct             = [ { name: &quot;H_addr&quot;, width: 12 }, { name: &quot;H_msg_len&quot;, width: 4 } ];<br/>const FifoDataStruct     = [ { name: &quot;first&quot;, width: 1 }, { name: &quot;bus&quot;, value: busStruct, packType: &quot;struct&quot; }, { name: &quot;last&quot;, width: 1 } ];<br/>const fifoWdata            = VlogPkdStruct ( &quot;fifo_wdata&quot;, structInfo, { endian: &quot;big&quot; } );<br/>\=fifoWdata.get( &quot;bus&quot; ).get(&quot;H_addr&quot;)=\                                                       // Prints fifo_wdata [ 16 : 5 ]<br/>\=fifoWdata.get( &quot;bus&quot; ).get(&quot;H_msg_len&quot;)=\                                                 // Prints fifo_wdata [ 4 : 1 ]<br/>\=fifoWdata.get( &quot;bus&quot; )=\                                                                             // Prints fifo_wdata [ 4 : 1 ]<br/>\=fifoWdata.get(&quot;first&quot;)=\                                                                              // Prints fifo_wdata [ 17 ]</p><p><br/>const wDataChunks     = Array.from( fifoWdata );  // Returns an array corresponding to bit-vectors/nets [ register_bits[7:0], register_bits[15:8], register_bits[23:16], register_bits[31:24] ]<br/>OR<br/>const wDataChunks     = [ ...fifoWdata ];                // Returns an array corresponding to bit-vectors/nets [ register_bits[7:0], register_bits[15:8], register_bits[23:16], register_bits[31:24] ]<br/><br/>OR<br/>// Use iterator directly to parse with a for-of loop<br/>for ( const subField of fifoWdata ) {<br/>   // Perform operations or assign on each sub-field of the 16-bit &quot;fifo_wdata&quot; signal<br/>}</p><h2 id="classVlogPkdStruct-Conversiontoapackedsignal">Conversion to a packed signal</h2><p>If an unpacked signal already exists then it can be converted to a packed struct using the function vlogSignal2PkdStruct(<span> struct, endian, signal </span>) in order to break it into<span> several fields of possibly unequal width.</span></p>