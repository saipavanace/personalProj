<div><div class="pagetitle with-breadcrumbs"><h1 class="with-breadcrumbs" id="HW-CTFarb_wrr_rr1-module_name"><strong>module_name</strong></h1></div></div><p>arb_wrr_rr1</p><h1 id="HW-CTFarb_wrr_rr1-parameters"><strong>parameters</strong></h1><h2 style="margin-left: 30.0px;" id="HW-CTFarb_wrr_rr1-java_script:"><strong>java_script:</strong></h2><pre>{
	&quot;width&quot; : any positive integer</pre><pre class="page view">        &quot;weightWidths&quot; : [i,j,. . . k] // an array of positive integers where the number is equal to width. It represents the binary width needed to store the weight for that port.</pre><pre>}</pre><h2 style="margin-left: 30.0px;" id="HW-CTFarb_wrr_rr1-verilog:"><strong>verilog:</strong></h2><p style="margin-left: 30.0px;">none.</p><h1 id="HW-CTFarb_wrr_rr1-I/O"><strong>I/O</strong></h1><p>input [width-1:0] in_req;</p><p>input next;</p><p>input update_weights;</p><p>for( i = 0; i &lt; weightWidths.length; i++) {</p><p>  input [weightWidths[i]-1:0] weight_i;</p><p>}</p><p>output [width-1:0] out_gnt;</p><p>input [(∑weightWidths+width)-1:0] in_state;</p><p>output [(∑weightWidths+width)-1:0] out_state;</p><h1 id="HW-CTFarb_wrr_rr1-FunctionsUsed"><strong>Functions Used</strong></h1><p>N/A</p><h1 id="HW-CTFarb_wrr_rr1-ModulesUsed"><strong>Modules Used</strong></h1><p>arb_rr1</p><h1 id="HW-CTFarb_wrr_rr1-Description"><strong>Description</strong></h1><p>Weighted Round Robin Arbiter as shown in below figure.</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16157103/wrr_arb%20block%20diagram.svg?api=v2"></span></p><p>in_state and out_state are organized as:</p><p>  {</p><p>  for (i = 0; i &lt; width, i++) {</p><p>    weighCount_i,</p><p>    }</p><p>  stateOfArbiter}</p><p>next tells the code to update the state of the arbiter.</p><p>update_weights tells the counters to reload their weights regardless of the counts.</p><p>&quot;==0 next&quot; means the count will be 0 on the next cycle.</p>