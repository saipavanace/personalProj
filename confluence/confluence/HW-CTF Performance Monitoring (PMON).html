<h1 id="HW-CTFPerformanceMonitoring(PMON)-History"><strong>History</strong></h1><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Date</th><th colspan="1" class="confluenceTh">Comments</th><th class="confluenceTh">Editor</th></tr><tr><td class="confluenceTd"><div class="content-wrapper"><p><time datetime="2021-01-18" class="date-past">18 Jan 2021</time> </p></div></td><td colspan="1" class="confluenceTd"><ul><li>Initial PMON inside ATU</li></ul></td><td class="confluenceTd">Darshan Alagud</td></tr><tr><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td></tr></tbody></table></div><p class="auto-cursor-target"><strong>NOTE: FOR R1 THE PMON IS EMBEDDED INSIDE THE ATU INVISIBLE TO MAESTRO SOFTWARE.</strong></p><h1 id="HW-CTFPerformanceMonitoring(PMON)-Description"><strong>Description</strong></h1><p>This is the microarchitecture specification for PMON Stats block inside an ATU. The block provides all performance monitoring features that exist in Symphony R1. It can only be enabled inside an AXI-ATU initiator and AXI-ATU target.</p><p>The PMON Stats block provides capability to measure performance statistics such as bandwidth and latency measurements. The block provides timer/counter resources that can be run, started, or stopped by events coming in from outside the block, internal events, or by CPU-accessible registers. The block implements primarily two features in R1: bandwidth measurement and latency binning.</p><p><br/></p><h1 id="HW-CTFPerformanceMonitoring(PMON)-Interfaces"><strong>Interfaces</strong></h1><p><em>clkInterface</em>: A slave interface of type <a class="external-link" href="https://confluence.arteris.com/display/ENGR/InterfaceCLK" rel="nofollow">InterfaceCLK</a>.</p><p><em>cfgInterface</em>: A slave interface of type <a class="external-link" href="https://confluence.arteris.com/display/ENGR/InterfaceAPB" rel="nofollow">InterfaceAPB</a>. This provides the means to access registers inside the PMON Stats block.</p><p><em>evtInterfaces</em>: An array of slave interfaces of type <a class="external-link" href="https://confluence.arteris.com/display/ENGR/InterfaceEvt" rel="nofollow">InterfaceEvt</a>. This includes bandwidth-measurement events, context-allocation events, and context-deallocation events.</p><p><em>intInterface</em>: A master interface of type <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16160508/InterfaceINT" data-linked-resource-id="16160508" data-linked-resource-version="3" data-linked-resource-type="page">InterfaceINT</a>. This carries the measurement-done interrupt.</p><p><br/></p><h1 id="HW-CTFPerformanceMonitoring(PMON)-Parameters"><strong>Parameters</strong></h1><p>At the ATU level, a single parameter is exposed for Maestro software to control called the <em>pmonStatsEn</em>, which determines whether the block exists inside the ATU or not. The block parameters themselves ( described in <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16157285/OBSOLETE-DELETE+HW-CTF+pmon_stats" data-linked-resource-id="16157285" data-linked-resource-version="2" data-linked-resource-type="page">OBSOLETE-DELETE HW-CTF pmon_stats</a> ) are set inside the ATU for R1.</p><p>In addition, there are some feature-specific parameters that are also set inside the ATU. These are described below and will be referenced in the rest of the document:</p><p><em>nBins</em>: Number of bins or buckets for latency binning. Must be a positive power of 2. For R1 must be equal to 4.</p><p><em>resolution</em>: Number of bits allocated to a latency timer one of which exists per context entry. For R1 must be equal to 4.</p><p><em>nBwCountEvents</em>: Number of bandwidth count events to choose from.</p><p><em>enBinBounds</em>: Boolean. If true, this creates <em>nBins</em>-1 RW registers of width = <em>resolution. </em>These registers allow programmable bin boundaries. When false, bin boundaries are assumed to be equally distributed across the full-range of latencies.</p><p><em>nCtxtEntries</em>: Number of context-entries or latency timers. Derived parameter. It is equal to number of allocation events = number of deallocation events.</p><p><br/></p><h1 id="HW-CTFPerformanceMonitoring(PMON)-Features">Features</h1><p>The PMON Stats block in Symphony R1 provides two main features.</p><h2 id="HW-CTFPerformanceMonitoring(PMON)-BWMeasurement">BW Measurement</h2><p>This feature provides a means to measure various bandwidth related statistics (utilization and backpressure) on a certain interface. The measurement involves setting up the GLBL_TMR for the measurement duration after which the measurement-done interrupt is fired. During this interval the BW counter, counts the number of occurrences of a bandwidth count event (bw_count_x, x = 0, 1, 2, 3 ... <em>nBwCountEvents</em>-1).</p><p>The bw_count_x events are inputs to the PMON Stats block and are expected to be generated from valid and ready signals of different interfaces outside the PMON Stats block. Only one bandwidth count event can be chosen out of the nBWCountEvents at a time to increment the BW Counter. And it is selected by programming the EVT_SEL_bw_count register.</p><p><br/></p><p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image confluence-external-resource image-center" src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" data-image-src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" loading="lazy"></span></p><p style="text-align: center;">Bandwidth Measurement Block Diagram</p><p><br/></p><p>For R1, the 6 BW count events are generated as follows in the ATU initiator or target:</p><ol><li><em>bw_count_0</em>: valid &amp; ready on CTL_REQ channel. Measures utilization on CTL_REQ channel</li><li><em>bw_count_1</em>: valid &amp; ~ready on CTL_REQ channel. Measures backpressure on CTL_REQ channel. </li><li><em>bw_count_2</em>: valid &amp; ready on AXI_AW channel. Measures utilization on AXI_AW channel.</li><li><em>bw_count_3</em>: valid &amp; ~ready on AXI_AW channel. Measures backpressure on AXI_AW channel.</li><li><em>bw_count_4</em>: valid &amp; ready on AXI_AR channel. Measures utilization on AXI_AR channel.</li><li><em>bw_count_5</em>: valid &amp; ~ready on AXI_AR channel. Measures backpressure on AXI_AR channel.</li></ol><h2 id="HW-CTFPerformanceMonitoring(PMON)-LatencyBinning">Latency Binning</h2><p>This feature allows the user to measure the distribution of request-to-response latencies of transactions that pass through the ATU.</p><p><br/></p><p style="text-align: center;"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" data-image-src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" loading="lazy"></span></p><p style="text-align: center;">Binning Block Diagram</p><p><br/></p><h4 id="HW-CTFPerformanceMonitoring(PMON)-Free-runningcounter">Free-running counter</h4><p>The feature requires the setting up of a 32-bit free-running counter, called FREE_RUN. This involves setting the limit value (in the LIMIT register) to set the frequency of how often the timer expire event is fired. The expire event is then used to count the latency timers which effectively determines the unit of time that the latency timers measure. For example if the FREE_RUN counter fires once every 1000 clocks and latency-timer <em>resolution</em> = 2 bits, <em>nBins</em> = 4, then a value of two on the latency timer is roughly equal to 2*1000 = 2000 clocks with some margin of error.</p><h4 id="HW-CTFPerformanceMonitoring(PMON)-Associatedevents">Associated events</h4><p>The feature employs the following events to measure the time-interval between request sent and response arriving per transaction:</p><ol><li>Context allocation events (<em>alloc</em>): One such event is generated per entry in the context lookup block whenever that entry is allocated to an outgoing transaction.</li><li>Context deallocation events (<em>dealloc</em>): One such event is generated per entry in the context lookup block whenever that entry is deallocated indicating a response that was received for that transaction.</li><li>Expire event (<em>expire</em>): This is an internally generated event that is generated each time the free-running counter expires and wraps around. </li></ol><h4 id="HW-CTFPerformanceMonitoring(PMON)-LatencyTimers">Latency Timers</h4><p>One of these timers exists for every context-entry. These timers are not software-visible or CPU-accessible. The latency timers count the number of timer expire events generated by the free-running counter between the time when the allocate-event and deallocate event occurs for a given context entry. This effectively measures the time between allocation and deallocation of the associated context entry, albeit with a margin of error. The error margin can be reduced by increasing the resolution, but at the cost of increase in area.</p><h4 id="HW-CTFPerformanceMonitoring(PMON)-Binningcounters">Binning counters</h4><p>There will be <em>nBins</em> 32-bit binning counters, one for each bin or bucket. The value in each bin represents the frequency of transactions whose latencies lie within the range represented by the bin. The range of latencies determined by each bin can be calculated as follows:</p><p>For the i<sup>th</sup> bin, the range of latencies in number of clock cycles is given as :<br/>FREE_RUN_LIMIT * i * <em>levels</em> to FREE_RUN_LIMIT * (i+1) * <em>levels</em></p><p>where <em>levels</em> = 2<sup>resolution</sup> represents the number of levels that every latency timer can count.</p><p><br/></p><h4 id="HW-CTFPerformanceMonitoring(PMON)-PressureEventGeneration">Pressure Event Generation</h4><p>The PMON can also be used to generate a pressure event output that will be used by the CTL block of an ATU initiator to adjust QoS of incoming transactions. The pressure event is generated using some of the same resources used for latency binning - Free-running counter and Latency timers. When enabled, the pressure event will be generated whenever the latency timers count enough expire-events that would've caused them to increment the last bin (if bin counters were enabled).</p><p>The Pressure Event Generation feature is available only in the AXI-ATU initiators for R1.</p><p><br/></p><h1 id="HW-CTFPerformanceMonitoring(PMON)-GlobalTimer">Global Timer</h1><p>The global timer is a 64-bit timer that is organized into two separate 32-bit timers: GLBL_TMR_LO, that holds the lower 32-bits of the timer value, and GLBL_TMR_HI that holds the upper 32-bits of the timer value. The global timer and the associated 'done' interrupt together provide a means to set up intervals during which a measurement (Bandwidth utilization, binning) is to be done.</p><p>The measurement interval is set up by writing a 64-bit value into the GLBL_TMR_*_limit registers. It is enabled by writing the <em>glbl_timer_en</em> bit and starts running upon writing a 1 into the <em>start</em> bit in the GLBL_CTRL register. If the '<em>done</em>' interrupt is enabled, an interrupt is fired when the following condition is true: { GLBL_TMR_HI_val, GLBL_TMR_LO_val } == { GLBL_TMR_HI_limit, GLBL_TMR_LO_limit }. At this point the timer freezes or stops incrementing. It can be cleared or reset by writing a 1 into the <em>glbl_tmr_reset</em> bit in the GLBL_CTRL register.</p><p><br/></p><h1 id="HW-CTFPerformanceMonitoring(PMON)-Interrupts">Interrupts</h1><p>The block generates a single interrupt called the &quot;done&quot; interrupt to indicate when a measurement is done. This is generated when the GLBL_TIMER value hits a value equal to the value programmed in its <em>limit</em> registers. A typical measurement involves setting up the <em>limit</em> register to set the measurement duration. When the <em>done</em> interrupt occurs, all timers and counter values are expected to freeze their values (stop incrementing).</p><p>Note:</p><ol><li>The PMON Stats instantiates the <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16160510/interrupt" data-linked-resource-id="16160510" data-linked-resource-version="22" data-linked-resource-type="page">interrupt</a> accumulator block. The '<em>done</em>' interrupt is masked by default. In order to enable it, a 1 must be written into its mask bit in the INTMR register. Once the interrupt is set, it can be cleared by writing a 1 (W1C) into its interrupt bit in the INTVR register.</li><li>In order to see the interrupt come out of Symphony, all interrupt registers up to the top of the tree must be similarly enabled.</li></ol><p><br/></p><h1 id="HW-CTFPerformanceMonitoring(PMON)-ConfigurationspaceaddressmapforPMONSTATSsub-blocks">Configuration space address map for PMON STATS sub-blocks</h1><p><br/></p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Sub-block</th><th class="confluenceTh">Size (in bytes)</th><th class="confluenceTh">Base-address</th><th class="confluenceTh">Exists if</th></tr><tr><td class="confluenceTd">TOP</td><td class="confluenceTd">512 bytes</td><td class="confluenceTd">0x00</td><td class="confluenceTd">True (Always exists)</td></tr><tr><td class="confluenceTd">INTERRUPT</td><td class="confluenceTd">512 bytes</td><td class="confluenceTd">0x200</td><td class="confluenceTd">intInterface exists</td></tr></tbody></table></div><p><br/></p><h1 id="HW-CTFPerformanceMonitoring(PMON)-Registers">Registers</h1><p><br/></p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col style="width: 211.0px;"/><col style="width: 74.0px;"/><col style="width: 57.0px;"/><col style="width: 93.0px;"/><col style="width: 64.0px;"/><col style="width: 56.0px;"/><col style="width: 477.0px;"/><col style="width: 29.0px;"/></colgroup><tbody><tr><th class="confluenceTh">Register</th><th class="confluenceTh">Address</th><th class="confluenceTh">Field</th><th class="confluenceTh">Field width</th><th class="confluenceTh">Access</th><th class="confluenceTh">Reset</th><th class="confluenceTh">Description</th><th class="confluenceTh"><br/></th></tr><tr><td class="confluenceTd">GLBL_EN</td><td class="confluenceTd">0x0</td><td class="confluenceTd">glbl_tmr_en</td><td class="confluenceTd">1</td><td class="confluenceTd">RW</td><td class="confluenceTd">0</td><td class="confluenceTd">Enable global timer</td><td class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd">bw_en</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">RW</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">Enable BW counter</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd">lat_tmr_en</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">RW</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">Enable all latency timers</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd">bin_en</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">RW</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">Enable all bin counters</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd">free_run_en</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">RW</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">Enable FREE_RUN counter</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd">pressure_en</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">RW</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">Enable pressure event</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">GLBL_CTRL</td><td colspan="1" class="confluenceTd">0x4</td><td colspan="1" class="confluenceTd">start</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">WO</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">Start all enabled timers</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd">stop</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">WO</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">Stop all enabled timers</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd">glbl_tmr_reset</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">WO</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">Software reset global timer</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd">bw_reset</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">WO</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">Software reset BW counter</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd">lat_tmr_reset</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">WO</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">Software reset all latency timers</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd">bin_reset</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">WO</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">Software reset all BIN counters</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd">free_run_reset</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">WO</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">Software reset FREE_RUN counter</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">GLBL_TMR_LO_val</td><td class="confluenceTd">0x8</td><td class="confluenceTd">val</td><td class="confluenceTd">32</td><td class="confluenceTd">RO</td><td class="confluenceTd">0</td><td class="confluenceTd">Global timer LO value. Lower 32-bits.</td><td class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">GLBL_TMR_LO_limit</td><td colspan="1" class="confluenceTd">0xC</td><td colspan="1" class="confluenceTd">limit</td><td colspan="1" class="confluenceTd">32</td><td colspan="1" class="confluenceTd">RW</td><td colspan="1" class="confluenceTd">0xffff_ffff</td><td colspan="1" class="confluenceTd">Global timer LO limit. Lower 32-bits.</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">GLBL_TMR_HI_val</td><td colspan="1" class="confluenceTd">0x14</td><td colspan="1" class="confluenceTd">val</td><td colspan="1" class="confluenceTd">32</td><td colspan="1" class="confluenceTd">RO</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">Global timer HI value. Upper 32-bits.</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">GLBL_TMR_HI_limit</td><td colspan="1" class="confluenceTd">0x18</td><td colspan="1" class="confluenceTd">limit</td><td colspan="1" class="confluenceTd">32</td><td colspan="1" class="confluenceTd">RW</td><td colspan="1" class="confluenceTd">0xffff_ffff</td><td colspan="1" class="confluenceTd">Global timer HI limit. Upper 32-bits.</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">BW_TMR_LO_val</td><td colspan="1" class="confluenceTd">0x20</td><td colspan="1" class="confluenceTd">val</td><td colspan="1" class="confluenceTd">32</td><td colspan="1" class="confluenceTd">RO</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">Bandwidth count value. Lower 32-bits.</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">BW_TMR_HI_val</td><td colspan="1" class="confluenceTd">0x20</td><td colspan="1" class="confluenceTd">val</td><td colspan="1" class="confluenceTd">32</td><td colspan="1" class="confluenceTd">RO</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">Bandwidth count value. Upper 32 bits.</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">FREE_RUN_val</td><td colspan="1" class="confluenceTd">0x24</td><td colspan="1" class="confluenceTd">val</td><td colspan="1" class="confluenceTd">32</td><td colspan="1" class="confluenceTd">RO</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">Free-running counter value.</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">FREE_RUN_limit</td><td colspan="1" class="confluenceTd">0x28</td><td colspan="1" class="confluenceTd">limit</td><td colspan="1" class="confluenceTd">32</td><td colspan="1" class="confluenceTd">RW</td><td colspan="1" class="confluenceTd">0xffff_ffff</td><td colspan="1" class="confluenceTd">Free-running counter limit. If this is programmed with a value n, the expire events are generated once every n+1 clock cycles.</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">BIN_0_val</td><td colspan="1" class="confluenceTd">0x2C</td><td colspan="1" class="confluenceTd">val</td><td colspan="1" class="confluenceTd">32</td><td colspan="1" class="confluenceTd">RO</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">Bucket 0 or Bin 0 value</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">BIN_1_val</td><td colspan="1" class="confluenceTd">0x30</td><td colspan="1" class="confluenceTd">val</td><td colspan="1" class="confluenceTd">32</td><td colspan="1" class="confluenceTd">RO</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">Bucket 1 or Bin 1 value</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">BIN_2_val</td><td colspan="1" class="confluenceTd">0x34</td><td colspan="1" class="confluenceTd">val</td><td colspan="1" class="confluenceTd">32</td><td colspan="1" class="confluenceTd">RO</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">Bucket 2 or Bin 2 value</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">BIN_3_val</td><td colspan="1" class="confluenceTd">0x38</td><td colspan="1" class="confluenceTd">val</td><td colspan="1" class="confluenceTd">32</td><td colspan="1" class="confluenceTd">RO</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">Bucket 3 or Bin 3 value</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">EVT_SEL_bw_count</td><td colspan="1" class="confluenceTd">0x3C</td><td colspan="1" class="confluenceTd">sel</td><td colspan="1" class="confluenceTd">3</td><td colspan="1" class="confluenceTd">RW</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd"><p>Select bandwidth event:</p><p>0 - bw_count_0 event<br/>1 - bw_count_1 event<br/>2 - bw_count_2 event<br/>3 - bw_count_3 event<br/>4 - bw_count_4 event<br/>5 - bw_count_5 event<br/>6 - Reserved<br/>7 - Reserved<br/><br/></p></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">BIN_BOUND_0</td><td colspan="1" class="confluenceTd">0x40</td><td colspan="1" class="confluenceTd">val</td><td colspan="1" class="confluenceTd">4</td><td colspan="1" class="confluenceTd">RW</td><td colspan="1" class="confluenceTd">4</td><td colspan="1" class="confluenceTd">Bound 0 value</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">BIN_BOUND_1</td><td colspan="1" class="confluenceTd">0x44</td><td colspan="1" class="confluenceTd">val</td><td colspan="1" class="confluenceTd">4</td><td colspan="1" class="confluenceTd">RW</td><td colspan="1" class="confluenceTd">8</td><td colspan="1" class="confluenceTd">Bound 1 value</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">BIN_BOUND_2</td><td colspan="1" class="confluenceTd">0x48</td><td colspan="1" class="confluenceTd">val</td><td colspan="1" class="confluenceTd">4</td><td colspan="1" class="confluenceTd">RW</td><td colspan="1" class="confluenceTd">12</td><td colspan="1" class="confluenceTd">Bound 2 value</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">INTVR</td><td colspan="1" class="confluenceTd">0x200</td><td colspan="1" class="confluenceTd">valid</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">RW</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">Interrupt valid bit for the measurement <em>done</em> interrupt.</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd">INTMR</td><td colspan="1" class="confluenceTd">0x204</td><td colspan="1" class="confluenceTd">mask</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">RW</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">Interrupt mask bit for the measurement <em>done</em> interrupt. 0 - interrupt is masked. 1 - interrupt is enabled.</td><td colspan="1" class="confluenceTd"><br/></td></tr></tbody></table></div><h1 class="auto-cursor-target" id="HW-CTFPerformanceMonitoring(PMON)-Typicalsequenceandusage">Typical sequence and usage</h1><h2 id="HW-CTFPerformanceMonitoring(PMON)-GLBLTimersetup">GLBL Timer setup</h2><p class="auto-cursor-target">Any performance related measurement starts first with configuring the GLBL_TIMER registers and Interrupt registers. Below are the steps for doing so:</p><ol><li class="auto-cursor-target">Determine the number of clocks for the measurement interval. And program that value into GLBL_TMR_LO and GLBL_TMR_HI limit registers.</li><li class="auto-cursor-target">Program the INTMR register of the INTERRUPT block so as to unmask the done interrupt.</li></ol><h2 id="HW-CTFPerformanceMonitoring(PMON)-StepsforBWmeasurement">Steps for BW measurement</h2><p>For the first iteration</p><ol><li class="auto-cursor-target">Write ones to <em>glbl_timer_en</em> and <em>bw_en</em> bits in the GLBL_EN register.</li><li class="auto-cursor-target">Select the bandwidth event to count the BW counter, by programming into the SEL field in the EVT_SEL_bw_count.</li><li class="auto-cursor-target">Start the measurement by writing a 1 into the start-bit in the GLBL_CTRL register. This starts running both the BW* and GLBL* timers.</li><li class="auto-cursor-target">Wait until the done interrupt is fired.</li><li class="auto-cursor-target">When the <em>done</em> interrupt occurs, read the BW_LO_val and BW_HI_val registers.</li></ol><p>To run another iteration with the same measurement interval:</p><ol><li>Reset the BW registers by writing a 1 into the bw_reset software reset bit in the GLBL_CTRL register. This resets the BW counter.</li><li>Repeat steps 2 to 5 same as in the first iteration. Step 2 can be skipped if the measurement is to be repeated with the same BW count event.</li></ol><p>If required to change the measurement interval after an iteration, write ones into the glbl_tmr_reset and bw_reset bits in GLBL_CTRL register, follow steps for GLBL TIMER setup, and repeat steps 2 to 5 in the steps of the first iteration.</p><h2 id="HW-CTFPerformanceMonitoring(PMON)-StepsforLatencyBinning">Steps for Latency Binning</h2><p class="auto-cursor-target">For the first iteration</p><ol><li class="auto-cursor-target">Determine the required periodicity of expire events in number of clock cycles such that <em>levels*(3/4) * expire-event-period</em><em> = last_bin_min_delay,</em> where <em>last_bin_min_delay</em> is the smallest transaction delay that you want to count in the last bin, and <em>levels</em> = 2<sup>nBins</sup>. Program the FREE_RUN_limit register with the <em>expire-event-period</em>.</li><li class="auto-cursor-target">Write ones to the following enable bits in the GLBL_EN register - <em>glbl_tmr_en</em>, <em>lat_tmr_en</em>, <em>bin_en</em>, and <em>free_run_en</em>. </li><li>Start the measurement by writing a 1 into the start-bit in the GLBL_CTRL register. This starts running the GLBL_TMR timer, LAT_TMR timers, BIN counters, and the FREE_RUN counter.</li><li class="auto-cursor-target">Wait until the <em>done</em> interrupt is fired.</li><li class="auto-cursor-target">Read the BIN counts.</li></ol><p>To run another iteration with the same measurement interval:</p><ol><li>Reset FREE_RUN, LAT_TMR*, BIN counters/timers.</li><li>If you wish to distribute the bin counts differently in each bin, program the BIN_BOUND* registers to adjust the delay ranges for each bin. For example if too few transactions were counted in BIN 0, you could increase BIN_BOUND0 to capture more transactions.</li><li>Repeat steps 2 to 5 same as in the first iteration.</li></ol><h2 class="auto-cursor-target" id="HW-CTFPerformanceMonitoring(PMON)-StepsforPressureEventGeneration">Steps for Pressure Event Generation</h2><p>Skip the steps for GLBL_TMR setup for pressure event generation and continue with the steps below</p><ol><li>Determine the required periodicity of expire events in number of clock cycles such that <em>levels*(3/4) * expire-event-period</em><em> = last_bin_min_delay,</em> where <em>last_bin_min_delay</em> is the smallest transaction delay for which the pressure event must be activated, and <em>levels</em> = 2<sup>nBins</sup>. Program the FREE_RUN_limit register with the <em>expire-event-period</em>.</li><li class="auto-cursor-target">Write ones to the following enable bits in the GLBL_EN register - <em>lat_tmr_en</em>, and <em>free_run_en, </em>and <em>pressure_en.</em></li><li class="auto-cursor-target">Program the <em>start</em> bit in the GLBL_CTRL register. This will running the latency-timers whenever a transaction is outstanding in the context. And when any one of them exceeds the <em>last_bin_min_delay</em>, the pressure event is expected to be active.</li></ol><p class="auto-cursor-target">To turn off pressure event generation:</p><ol><li class="auto-cursor-target">To turn off the pressure-event generation temporarily, program the <em>stop</em> bit in the GLBL_CTRL register. This will stop all latency timers as well as the FREE_RUN counter.</li><li class="auto-cursor-target">Disable the pressure-event by writing a zero into the <em>pressure_en</em> bit, as well as the <em>lat_tmr_en</em> and <em>free_run_en</em> bits to stop the counters from running.</li><li class="auto-cursor-target">To turn off the pressure-event generation permanently, disable all enables in the GLBL_CTRL register. </li></ol><p class="auto-cursor-target">To continue with another iteration, skip step 3 above and follow the steps below:</p><ol><li class="auto-cursor-target">Program the <em>free_run_reset</em>, and <em>lat_tmr_reset</em> bits.</li><li class="auto-cursor-target">Follow steps 2-3 same as for the first iteration.</li></ol>