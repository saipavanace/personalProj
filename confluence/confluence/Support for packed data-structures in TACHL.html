<p>Even though an HDL language that is favored by a customer (typically Verilog) doesn't support high-level data-structures such as packed structs, designers using TACHL flow are not limited by the constructs and structures provided by the HDL language. This is because the TACHL flow allows representing designs with high level language structures (in JavaScript) that can then be used to generate Verilog code.</p><p>An example of a high-level feature that we use in TACHL that doesn't exist in Verilog is an Interface. The following is a proposal on how to support another such high-level feature called packed structures ( akin to System Verilog packed struct and packed arrays ) in JavaScript, and how to make use of them in TACHL. Representation of such structures in JavaScript is presented first followed by how library function or classes can read them to determine positions of fields on a bus.</p><p>There are two types of packed structures proposed here:</p><h2 id="Supportforpackeddata-structuresinTACHL-PackedStructrepresentation">Packed Struct representation</h2><p>A packed struct, when used to represent a bit vector, specifies a set of strings or field names to reference bit-slices of potentially <strong>unequal widths</strong> on that vector. A packed struct consists of several fields each with a certain width. All fields are assumed to be arranged contiguously or packed onto bus of bits. The order in which the fields are arranged and the endianness determine the start-end positions of the fields on the bus.</p><p>Such structures are useful to represent, to mention a few examples :</p><ol><li>Packet fields</li><li>Register fields</li><li>Concatenation of signals of different widths onto a FIFO bus</li><li>Opcodes in an instruction</li></ol><p><br/></p><p>A packed struct also needs to support composite structures i.e. struct of arrays and struct of structs. Taking all this into account, the following structure is proposed here to represent a packed struct in JS:</p><p>A packed struct will be represented as an array of fields:</p><p>[ <br/>  field_0,<br/>  field_1,<br/>  field_2,<br/>  .<br/>  .<br/>  .<br/>]<br/><br/>Each field above will be an object, represents a struct member, and will have the following properties:</p><p>{<br/>  <strong><em>name</em></strong>: A string with which to access members of the struct with.<br/>  <strong><em>width</em></strong>: A positive integer that specifies the size of the field in bits. Optional if packType is defined, in which case the width is expected to be computed from value.<br/>  <strong><em>value</em></strong>: Any number, string or object. If packType == &quot;struct&quot;, value must be a packed struct object. If packType == &quot;array&quot;, value must be a packed array object. Optional if packType is undefined or empty-string.<br/>  <strong><em>packType</em></strong>: A string that can take either one of the following values: &quot;struct&quot;, &quot;array&quot;. This tells how to interpret the 'value' and if it it to be expanded. Optional. When not defined, value is treated like any other object.<br/><strong><em>  endian</em></strong>: A string that can take either one of the following values: &quot;big&quot;, &quot;little&quot;. Defines the endianness of fields inside value when value is a packed structure. This is ignored if packType is undefined. Optional. Default values: endian = &quot;big if packType === &quot;struct&quot;, else &quot;little&quot;.<br/>}</p><p> Every field must have an associated width. The width property can however be omitted if the value is in turn a packed object, in which case the width will need to be computed by adding up sizes of each of the fields within the nested packed object. The names of properties <em>name</em> and <em>width</em> are intentionally chosen so that it aligns with most of the existing data-structures in Symphony and Ncore that can be represented as packed objects such as ATP packet definitions in Symphony, fields in a CSR register etc. This allows easy direct mapping of those objects to packed objects when they don't contain nested packed objects as values.</p><h2 id="Supportforpackeddata-structuresinTACHL-PackedArrayrepresentation">Packed Array representation</h2><p>A packed array, when used to represent a bit vector, specifies a range of indices (zero-indexed) to reference bit-slices of <strong>equal width</strong> on that vector. When each field in a packed object is known to be of the same width, we just need a single object rather than an array, to specify the packed structure. Each chunk or bit-slice that is referenced is a function of index and the endianness. This can be an alternative to regular arrays with one advantage over a regular Verilog array: Because a packed array represents a single-dimensional signal, it can appear on the LHS of an assignment.</p><p>A packed array also needs to support composite structures i.e. array or arrays and array of structs. Taking all this into account, the following structure is proposed here to represent a packed array in JS:</p><p>A packed array will be represented with a single object with the following properties:</p><p>{<br/>  <strong><em>width</em></strong>: A positive integer that represents the width of each chunk or value in the packed array. This is not the width of the array.<br/>  <strong><em>length</em></strong>: A positive integer that represents the number of chunks or values in the packed array.<br/>  <strong><em>value</em></strong>: Any number, string or object. If packType == &quot;struct&quot;, value must be a packed struct object. If packType == &quot;array&quot;, value must be a packed array object. Optional if packType is undefined or empty-string.<br/>  <strong><em>packType</em></strong>: A string that can take either one of the following values: &quot;struct&quot;, &quot;array&quot;. This tells how to interpret the 'value' and if it it to be expanded. Optional. When not defined, value is treated like any other object.<br/><strong><em>  endian</em></strong>: A string that can take either one of the following values: &quot;big&quot;, &quot;little&quot;. Defines the endianness of fields inside value when value is a packed structure. This is ignored if packType is undefined. Optional. Default values: endian = &quot;big if packType === &quot;struct&quot;, else &quot;little&quot;.<br/>}</p><p>Note that some of the parameters above apply to <em>value</em> or contents of the array such as 'width', packType, and endian, whereas length is a property of the array.</p><h2 id="Supportforpackeddata-structuresinTACHL-Librariesthatsupportreadingpackedstructures">Libraries that support reading packed structures</h2><p>Once we have the structures to represent packed structures, library functions or classes that read/parse above structures can be written in order to provide the following services:</p><ol><li>Determine positions of fields or sub-fields by their names.</li><li>Access values associated with and stored with each field.</li><li>Generate synthesizable RTL vector slice expressions or statements in a given HDL.</li></ol><p>3 involves 1 because we need to know the location of a field on a bus in order to generate a slice expression for the field on the bus. The position and size of a field or sub-field can be communicated between such libraries by using something like a Slice object (instance of <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16155846/class+Slice" data-linked-resource-id="16155846" data-linked-resource-version="7" data-linked-resource-type="page">class Slice</a>), which represents an abstraction for size and location of a field.</p><p>The input parameter for most of these functions will be the name of the field or struct member if no composite packed structures or nested fields are allowed. Otherwise, we will need a way of referencing nested fields in the packed structure discussed in the next section.</p><h3 id="Supportforpackeddata-structuresinTACHL-Hierarchicalreferencingofnestedfieldsorstructmembers">Hierarchical referencing of nested fields or struct members</h3><p>Some possible ways to design the interfaces for libraries to parse a packed struct include:</p><ol><li>Procedural or imperative approach: A function that has accepts three parameters: parsePkdStruct( struct, attr, namePath ), where attr can take values &quot;slice&quot; to return position of the accessed field or &quot;value&quot; to return the value associated with that field in the namePath. namePath is an array of field names to access fields hierarchically.</li><li>Object-Oriented approach: A parser class initialized with the struct with a get method that can optionally return another instance of the same class initialized with a nested struct.</li><li>Functional Programming approach: A parser function that returns closures for fields that include nested structs. The closure can then be called to access fields within a nested struct.</li></ol><p>For each member or field inside a packed structure that is accessed there are different types of attributes could be specified that the libraries need to support, such as:</p><ol><li>Position or Slice of the field</li><li>Value associated with the field</li><li>Truth value indicating if the field exists</li></ol><p>In addition, it is useful to provide access to fields in a struct serially in the order in which they are packed i.e. the libraries must implement an iterable.</p><h3 id="Supportforpackeddata-structuresinTACHL-Usingthelibraries">Using the libraries</h3><p>Once the above discussed library interfaces are available, they can be used to generate HDL expressions or statements. For example, an object-oriented approach would look like this:</p><p><span>// Define two packed structs such that the sub-Struct is nested within the topStruct<br/>subStruct = [ { name: &quot;mode&quot;, width: 3 }, { name: &quot;status&quot;, width: 4 }, { name: &quot;en&quot;, width: 1 } ];</span><br/><span>topStruct = [ { name: &quot;addr&quot;, width: 4 }, { name: &quot;sub&quot;, value: <strong>subStruct</strong>, packType: &quot;struct&quot; }, { name: &quot;id&quot;, width: 3 }, { name: &quot;test&quot;, width: 1 } ];  // This struct is composed of another struct, subStruct</span><br/><br/><span>top = new PkdStruct (topStruct, { endian: &quot;big&quot;, unpack: true });  // Set endianness, and option to return instances of same class initialized with nested structures (subStruct).<br/></span></p><p><span>top.get(&quot;addr&quot;)   // References the field in the top level struct only. Return the value field associated with the &quot;addr&quot; field, which is undefined in this case.<br/>top.get(&quot;sub&quot;).get(&quot;mode&quot;)   // Because the above returned another instance of the same class, it has a get method too.<br/></span>top.get(&quot;sub&quot;).get(&quot;mode&quot;).index(i)   // If mode was a packed array then we would need an index method to access fields within the packed array.</p><p><br/></p><p>Suppose we did</p><p>slice  = top.get(&quot;sub&quot;).slice(&quot;mode&quot;)  // This would return a Slice object (<a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16155846/class+Slice" data-linked-resource-id="16155846" data-linked-resource-version="7" data-linked-resource-type="page">class Slice</a>) for the sub-field &quot;mode&quot; inside field &quot;sub&quot;</p><p>Now we can use the slice information to generate a statement for example with the <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16157783/newTachl+Tachl+v4+and+higher" data-linked-resource-id="16157783" data-linked-resource-version="25" data-linked-resource-type="page">newTachl (Tachl v4 and higher)</a> like this:</p><p>m.extract( 16, &quot;mode&quot;, &quot;bus&quot;,   slice.start, slice.end ) // This would generate a statement: assign mode = bus[11 : 9];</p><p>Or </p><p>to generate the same statement using the <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16160940/Verilog+expression+generator" data-linked-resource-id="16160940" data-linked-resource-version="48" data-linked-resource-type="page">Verilog expression generator</a> library and <strong>old TACHL</strong>:</p><p>\jsbegin<br/>bus     = new VlogSignal( 16, &quot;bus&quot;);  // Creates a signal object with width 16 and name &quot;bus&quot; \jsend<br/>assign mode  = \=bus.sliceX( slice )=\;  // assign mode = bus[11:9];</p><p><br/></p><p><br/></p><p><br/></p>