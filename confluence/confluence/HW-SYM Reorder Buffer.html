<h1 id="HW-SYMReorderBuffer-History"><strong>History</strong></h1><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Date</th><th colspan="1" class="confluenceTh">Comments</th><th class="confluenceTh">Editor</th></tr><tr><td class="confluenceTd">12/3/2020</td><td colspan="1" class="confluenceTd"><ul><li>Initial R1 RoB w/ Memory</li></ul></td><td class="confluenceTd">Eric Taylor</td></tr><tr><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd"><br/></td></tr></tbody></table></div><h1 id="HW-SYMReorderBuffer-Outline"><strong>Outline</strong></h1><p><style type='text/css'>/*<![CDATA[*/
div.rbtoc1759723369318 {padding: 0px;}
div.rbtoc1759723369318 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1759723369318 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class='toc-macro rbtoc1759723369318'>
<ul class='toc-indentation'>
<li><a href='#HW-SYMReorderBuffer-History'>History</a></li>
<li><a href='#HW-SYMReorderBuffer-Outline'>Outline</a></li>
<li><a href='#HW-SYMReorderBuffer-Description'>Description</a></li>
<li><a href='#HW-SYMReorderBuffer-Interfaces'>Interfaces</a></li>
<li><a href='#HW-SYMReorderBuffer-ReferenceSpecification'>Reference Specification</a></li>
<li><a href='#HW-SYMReorderBuffer-Parameters'>Parameters</a></li>
<li><a href='#HW-SYMReorderBuffer-Ports'>Ports</a></li>
<li><a href='#HW-SYMReorderBuffer-TopLevel'>Top Level</a>
<ul class='toc-indentation'>
<li><a href='#HW-SYMReorderBuffer-Standalonenon-VCVersion'>Standalone non-VC Version</a></li>
<li><a href='#HW-SYMReorderBuffer-StandaloneVCVersion'>Standalone VC Version</a>
<ul class='toc-indentation'>
<li><a href='#HW-SYMReorderBuffer-NonEfficientStorage(SeparateContextforAllVC,CouldacceptVCresponsespercycle(howeverwontforR1))'>Non Efficient Storage (Separate Context for All VC, Could accept VC responses per cycle (however wont for R1))</a></li>
</ul>
</li>
</ul>
</li>
<li><a href='#HW-SYMReorderBuffer-UnitLevel'>Unit Level</a>
<ul class='toc-indentation'>
<li><a href='#HW-SYMReorderBuffer-RequestPath'>Request Path</a>
<ul class='toc-indentation'>
<li><a href='#HW-SYMReorderBuffer-ContextSelection'>Context Selection</a></li>
<li><a href='#HW-SYMReorderBuffer-RequestContext'>Request Context</a></li>
<li><a href='#HW-SYMReorderBuffer-RequestDependencySource'>Request Dependency Source</a></li>
</ul>
</li>
<li><a href='#HW-SYMReorderBuffer-ResponsePath'>Response Path</a>
<ul class='toc-indentation'>
<li><a href='#HW-SYMReorderBuffer-ResponseContextAllocation'>Response Context Allocation</a></li>
<li><a href='#HW-SYMReorderBuffer-ResponseDataBuffer'>Response Data Buffer</a>
<ul class='toc-indentation'>
<li><a href='#HW-SYMReorderBuffer-SinglePortSRAM(FixedLatency)'>Single Port SRAM (Fixed Latency)</a></li>
<li><a href='#HW-SYMReorderBuffer-Flops(0cyclelatency)'>Flops (0 cycle latency)</a></li>
</ul>
</li>
<li><a href='#HW-SYMReorderBuffer-ResponsePathBypass'>Response Path Bypass</a></li>
<li><a href='#HW-SYMReorderBuffer-DependencyClearingOperation'>Dependency Clearing Operation</a></li>
</ul>
</li>
<li><a href='#HW-SYMReorderBuffer-Timing'>Timing</a>
<ul class='toc-indentation'>
<li><a href='#HW-SYMReorderBuffer-Pipeing'>Pipeing</a></li>
<li><a href='#HW-SYMReorderBuffer-TimingOptimizationsandSignalNaming'>Timing Optimizations and Signal Naming</a></li>
</ul>
</li>
<li><a href='#HW-SYMReorderBuffer-OtherFeatures'>Other Features</a>
<ul class='toc-indentation'>
<li><a href='#HW-SYMReorderBuffer-ExternalPortDescriptions'>External Port Descriptions</a></li>
<li><a href='#HW-SYMReorderBuffer-ErrorChecking'>Error Checking</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div></p><p><br/></p><p><strong>NOTE: FOR R1 THE ROB IS EMBEDDED INSIDE THE ATU INVISABLE TO THE SOFTWARE.</strong></p><h1 id="HW-SYMReorderBuffer-Description"><strong>Description</strong></h1><p>This is the micro-architecture specification for the Reorder Buffer Bidirectional Adapter.</p><p>This bi-directional adapter has both request and response link going though it. It checks the requests for order dependencies and then stores responses in data buffer as required to satisfy the ordering requirement. The request ATP link can be of different size/format than the response ATP link but the base packet format is same for both. All responses coming into the reorder buffer must have their corresponding requests go through the requested link connected through it.</p><h1 id="HW-SYMReorderBuffer-Interfaces"><strong>Interfaces</strong></h1><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16164453/HW-SYM+InterfaceATP" data-linked-resource-id="16164453" data-linked-resource-version="12" data-linked-resource-type="page">HW-SYM InterfaceATP</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168667/InterfacePROT" data-linked-resource-id="16168667" data-linked-resource-version="16" data-linked-resource-type="page">InterfacePROT</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168917/HW-SYM+InterfaceSMI" data-linked-resource-id="16168917" data-linked-resource-version="9" data-linked-resource-type="page">HW-SYM InterfaceSMI</a></p><h1 id="HW-SYMReorderBuffer-ReferenceSpecification"><strong>Reference Specification</strong></h1><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166695/HW-SYM+Base+Packet+Parameters+Relationships" data-linked-resource-id="16166695" data-linked-resource-version="108" data-linked-resource-type="page">Base Packet Parameters &amp; Relationships<br /></a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16169110/Symphony+Architecture+Spec" data-linked-resource-id="16169110" data-linked-resource-version="18" data-linked-resource-type="page">Symphony Architecture Spec</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156349/HW-SYM+Common+Transaction+Layer+Microarchitecture+Specification" data-linked-resource-id="16156349" data-linked-resource-version="327" data-linked-resource-type="page">HW-SYM Common Transaction Layer Microarchitecture Specification</a></p><h1 id="HW-SYMReorderBuffer-Parameters"><strong>Parameters</strong></h1><p>{</p><p>   enRob : 0 or 1, // ENable the ROB Operation. Pass through if dissabled.</p><p>   maxBurst : 1 to inf, // The maximum transaction size in Bytes. Has to be multiple of bus width.</p><p>   pipeLevelRob : 0,1,2, // Indicates the pipe level in and out of the ROB. </p><p>   nOutstandingReq : 1 to inf, // Power of Two. Number of outstanding transactions.</p><p>   nDataEntries: 1 to inf, // Needs to be equal to the max beats per transaction times the max number of outstanding transactions.</p><p>   nReads: 1 to inf, // Number of reads that could be outstanding. Used to determine when to backpressure when there isnt enough space inside the read buffer.</p><p>   mstrArbLck :   &lt;true or false&gt; , // Indicates whether the arbiters will lock on a VC. </p><p>   vcLckStyleVld : &lt;true or false&gt; ,  // Indicates whether the arbiters will lock on valid.</p><p>   mstrLckStyleVld : &lt;true or false&gt; ,  // Indicates whether the arbiters will lock on valid.</p><p>   arbType : </p><p>          {</p><p>                master : &lt;&quot;arb_rr2&quot;,&quot;arb_wrr_rr1&quot;, ...&gt;</p><p>                vcs : [ &quot;string&quot;, &quot;string&quot; , ... ]  // Each String is an arb type</p><p>           } // The arbiter types of the master for VC selection</p><p>   masterArbRdyAware :  &lt;true or false&gt; ,  // Indicates whether the arbiters are ready aware</p><p>   weights: </p><p>         {</p><p>                master : &lt;1,2,3, ...&gt;</p><p>                vcs : [int, int, , ... ]  // Each String is an arb type</p><p>           } // The weights of the master for VC selection</p><p>   orderMode :  0 or 1, // 0 - Reorder all responces. 1 - Reorder per Common Layer</p><p>   orderRd :0 or 1, // 1 - Order Read Responce</p><p>   orderWr: 0 or 1, // 1 - Order Write Responce</p><p>   nSource: 1 to inf, // Number of sources feeding the ROB</p><p>   externalDepnd : 0 or 1, // 0 - Create dependencies inside ROB, 1 - take in dependencies from outside ROB</p><p>   externalPoison : 0 or 1, // 0 - Create dependencies inside ROB, 1 - take in dependencies from outside ROB</p><p>   externalReserve : 0 or 1, // 0 - Create dependencies inside ROB, 1 - take in dependencies from outside ROB</p><p>   MemoryGeneration: [</p><p>     {<br/>          &quot;rtlPrefixString&quot;: &quot;a_string&quot;, // deprecated, must match corresponding generic interface name. </p><p>          &quot;memoryType&quot; : &quot;a_string&quot;, // NONE or SYNOPSYS. Type of memory to be generated </p><p>          &quot;interfaceObjType: &quot;a_string&quot; // Used to match memory to genericInterface (rob0, rob1, ...),</p><p>          &quot;MemoLatency&quot; : integer, // latency of the connected memory. Defaults to 1 if memoryType is not NONE</p><p>       },</p><p><strong>   // Interface Parameters</strong></p><p>    &quot;interfaces&quot; :{</p><p>           &quot;clkInt&quot; : { &quot;name&quot; : &quot;a_string&quot;,  &quot;params&quot; : {}, &quot;direction&quot; : &quot;slave&quot;,  &quot;interface&quot; : &quot;<a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168894/InterfaceCLK" data-linked-resource-id="16168894" data-linked-resource-version="5" data-linked-resource-type="page">InterfaceCLK</a>&quot;},</p><p>           &quot;requestInterfacesIn&quot;  :  [{ &quot;name&quot; : &quot;a_string&quot;,  &quot;params&quot; : {}, &quot;direction&quot; : &quot;slave&quot;,  &quot;interface&quot; : &quot;<a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168894/InterfaceCLK" data-linked-resource-id="16168894" data-linked-resource-version="5" data-linked-resource-type="page">InterfaceA</a>TP or <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16164945/HW-SYM+InterfaceCTL" data-linked-resource-id="16164945" data-linked-resource-version="14" data-linked-resource-type="page">HW-SYM InterfaceCTL</a>&quot;, ...}, ... ],</p><p>           &quot;requestInterfacesOut&quot; :  [{ &quot;name&quot; : &quot;a_string&quot;,  &quot;params&quot; : {}, &quot;direction&quot; : &quot;slave&quot;,  &quot;interface&quot; : &quot;<a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168894/InterfaceCLK" data-linked-resource-id="16168894" data-linked-resource-version="5" data-linked-resource-type="page">InterfaceA</a>TP or <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16164945/HW-SYM+InterfaceCTL" data-linked-resource-id="16164945" data-linked-resource-version="14" data-linked-resource-type="page">HW-SYM InterfaceCTL</a>&quot;, ...},  ... ],</p><p>           &quot;responceInterfacesIn&quot;  : [{ &quot;name&quot; : &quot;a_string&quot;,  &quot;params&quot; : {}, &quot;direction&quot; : &quot;master&quot;,  &quot;interface&quot; : &quot;<a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168894/InterfaceCLK" data-linked-resource-id="16168894" data-linked-resource-version="5" data-linked-resource-type="page">InterfaceA</a>TP or <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16164945/HW-SYM+InterfaceCTL" data-linked-resource-id="16164945" data-linked-resource-version="14" data-linked-resource-type="page">HW-SYM InterfaceCTL</a>&quot;, ...}, ... ],</p><p>           &quot;responceInterfacesOut&quot; :  [{ &quot;name&quot; : &quot;a_string&quot;,  &quot;params&quot; : {}, &quot;direction&quot; : &quot;master&quot;,  &quot;interface&quot; : &quot;<a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168894/InterfaceCLK" data-linked-resource-id="16168894" data-linked-resource-version="5" data-linked-resource-type="page">InterfaceA</a>TP or <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16164945/HW-SYM+InterfaceCTL" data-linked-resource-id="16164945" data-linked-resource-version="14" data-linked-resource-type="page">HW-SYM InterfaceCTL</a>&quot;, ...},  ... ],        </p><p>           &quot;genericIoMem&quot; : [ </p><p>                {<br/>                    name: &quot;a_string&quot;, // The name of the memory module is derived from the name of the generic interface</p><p>                  params: {interface parameters}, </p><p>                  interfaceObjType: &quot;a_string&quot;, //matches the interfaceObjType in MemoryGeneration (rob0, rob1, ...)</p><p>                    direction: &quot;slave&quot;, </p><p>                  _SKIP_: boolean // true means interface is removed, false means interface is instanced</p><p>                  interface: &quot;InterfaceGeneric&quot;</p><p>                   }</p><p>           ]</p><p>    },</p><p>    &quot;stateProtectionStyle&quot; : &quot;&quot; or <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16169044/protectionStyle" data-linked-resource-id="16169044" data-linked-resource-version="15" data-linked-resource-type="page">protectionStyle</a></p><p>    &quot;registerProtectionStyle&quot; : &quot;&quot; or <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16169044/protectionStyle" data-linked-resource-id="16169044" data-linked-resource-version="15" data-linked-resource-type="page">protectionStyle</a></p><p>    &quot;memoryProtectionStyle&quot; : &quot;&quot; or <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16169044/protectionStyle" data-linked-resource-id="16169044" data-linked-resource-version="15" data-linked-resource-type="page">protectionStyle</a></p><p>}</p><h1 id="HW-SYMReorderBuffer-Ports"><strong>Ports</strong></h1><p>These ports will only be instantiated in a non standalone version of the ROB.</p><p>if (externalDepnd) {<br/>    u.port('input', <a class="external-link" href="http://requestInterfaceIn.name" rel="nofollow">requestInterfaceIn.name</a>+'ndp_dependency' , 1); <br/>    u.port('input', <a class="external-link" href="http://requestInterfaceIn.name" rel="nofollow">requestInterfaceIn.name</a>+'ndp_dependency_seqnum', requestInterfaceIn.signals['ndp_'].msg_seqnum); <br/>}</p><p>if (externalPoison) {<br/>    u.port('input', 'seqnum_poison' , 2*maxOut); <br/>}</p><p>if (externalReserve) {<br/>   u.port('input', <a class="external-link" href="http://requestInterfaceIn.name" rel="nofollow">requestInterfaceIn.name</a>+'ndp_reserveBeatBuffer' , 1);<br/>   u.port('output', <a class="external-link" href="http://requestInterfaceOut.name" rel="nofollow">requestInterfaceOut.name</a>+'ndp_reserveBeatBuffer' , 1); <br/>}</p><h1 id="HW-SYMReorderBuffer-TopLevel"><strong>Top Level </strong></h1><h2 id="HW-SYMReorderBuffer-Standalonenon-VCVersion">Standalone non-VC Version </h2><p><strong><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" data-image-src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" loading="lazy"></span></strong></p><h2 id="HW-SYMReorderBuffer-StandaloneVCVersion">Standalone VC Version</h2><h4 id="HW-SYMReorderBuffer-NonEfficientStorage(SeparateContextforAllVC,CouldacceptVCresponsespercycle(howeverwontforR1))"><strong>Non Efficient Storage (Separate Context for All VC, Could accept VC responses per cycle (however wont for R1))</strong></h4><p><br/>In the non-efficient ROB each VC will have a separate ROB unit since no two transactions in separate VCs will need to be ordered. This enables the ROB to accept responses from each VC at the same time.<br/>The unit-level ROB will get request information from a SMI VC demux. The request information will then go out and be selected through a SMI Arb.</p><p>The responses work similarly. Each response in interface will be driven from a SMI Demux . The response out will then drive a SMI Arb.</p><h1 id="HW-SYMReorderBuffer-UnitLevel"><strong>Unit Level </strong></h1><h2 id="HW-SYMReorderBuffer-RequestPath">Request Path</h2><ul><li>Red : Internal Dependency Determination</li><li>Green : External Dependency Determination</li><li>Ordering Vector : {Src Id, Ordering Id, Channel Id} based on Ordering Model</li></ul><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" data-image-src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" loading="lazy"></span></p><h3 id="HW-SYMReorderBuffer-ContextSelection">Context Selection</h3><p>A ROB will have nOutstandingReq entries. </p><p>The first nRead entries are reserved for only reads with a dependency. Each entry has a direct mapping to a location in the read data buffer that is the size of maxBurstSize. Reads with dependencies are allocated bottom to top. A read with a dependency will be backpressured if the first nRead entries are used.</p><p>All entries could be used for write transactions and reads without dependencies, however they are allocated top to bottom. Writes and reads without dependencies are backpressured when all entries are used. </p><p>An entry will be allocated for every transaction.</p><h3 id="HW-SYMReorderBuffer-RequestContext">Request Context</h3><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Request Context Entry</th><th class="confluenceTh">Description</th></tr><tr><td class="confluenceTd">valid</td><td class="confluenceTd"><p>On Context Allocation to 1 and is set to 0 when any of the following conditions occur:</p><ul><li>clear_from_poison - seqnum was indicated to be poisoned from the context</li><li>resp_valid_clear_write - clear from write txn</li><li>resp_valid_clear_read  - clear from read txn</li><li>resp_valid_clear_read_after_data - clear from read txn after data has already been sent</li></ul></td></tr><tr><td class="confluenceTd">read_count</td><td class="confluenceTd">On Context Allocation to 0, then as each beat is sent out it is increased.</td></tr><tr><td class="confluenceTd">beat_count</td><td class="confluenceTd">On Context Allocation to 0, then as each beat is read in it is increased.</td></tr><tr><td class="confluenceTd">depnd</td><td class="confluenceTd">On Context Allocation to dependency signal in. (Dependency determined from context) </td></tr><tr><td class="confluenceTd">depnd_entry</td><td class="confluenceTd">On Context Allocation to entry with trans_seqnum == dependency_seqnum</td></tr><tr><td colspan="1" class="confluenceTd">trans_seqnum</td><td colspan="1" class="confluenceTd">On Context Allocation to transactions sequence number.</td></tr><tr><td colspan="1" class="confluenceTd">ordering_vec</td><td colspan="1" class="confluenceTd">(Needed for Internal Dependency Determination) {Src Id, Ordering Id, Channel Id} based on Ordering Model</td></tr></tbody></table></div><h3 id="HW-SYMReorderBuffer-RequestDependencySource">Request Dependency Source</h3><p>Currently the context of the CTL layer indicates if and what dependency the transaction has based on sequence number. In the future this dependency can be determined internally inside the ROB. This is controlled by extenalDepnd. </p><h2 id="HW-SYMReorderBuffer-ResponsePath">Response Path</h2><p>High Level View of the Response Path</p><p><br/></p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" data-image-src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" loading="lazy"></span></p><h3 id="HW-SYMReorderBuffer-ResponseContextAllocation">Response Context Allocation</h3><p>A ROB will have nOutstandingReq response entries. No backpressure will be given as there is an entry for every outstanding transaction. </p><p>A response will know which response context entry to use based on a sequence number lookup. It will use the same entry as the request entry.</p><p>The context is split for the sake of easier reading and tachl.</p><p><br/></p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Request Context Entry</th><th class="confluenceTh">Description</th></tr><tr><td class="confluenceTd">response_dp_last_recieved</td><td class="confluenceTd"><p>Is set the cycle the NDP response comes in to last_dp_recieved otherwise it will be set whenever last_dp_reseived goes high</p><ul><li>last_dp_recieved goes high when the last beat of data comes in according to dp_last</li></ul></td></tr><tr><td class="confluenceTd">response_dp_sent</td><td class="confluenceTd">Is cleared when request entry is cleared. Is set when the data from the Read Data Buffer has been fully sent. </td></tr><tr><td class="confluenceTd">response_dp_sent_last</td><td class="confluenceTd">Is cleared when request entry is cleared. Is set when the last data beat of the transaction as a whole leaves the ROB.</td></tr><tr><td class="confluenceTd">response_sent</td><td class="confluenceTd">Is cleared when request entry is cleared. Is set when the NDP portion of the response has been sent. </td></tr><tr><td class="confluenceTd">response</td><td class="confluenceTd">Is set when the NDP of the transaction is recieved. This field stores all of the packet fields to be sent as an NDP at a later time. </td></tr><tr><td colspan="1" class="confluenceTd">resp_entry</td><td colspan="1" class="confluenceTd">UNUSED, NEEDS TO BE DELETED</td></tr><tr><td colspan="1" class="confluenceTd">resp_valid</td><td colspan="1" class="confluenceTd">Is set when an NDP response is seen and it has NOT bypassed the ROB.</td></tr><tr><td colspan="1" class="confluenceTd">dependency</td><td colspan="1" class="confluenceTd">Is set if the entry has a dependency on another entry. It is cleared when the entrie's dependency is cleared.</td></tr></tbody></table></div><h3 id="HW-SYMReorderBuffer-ResponseDataBuffer">Response Data Buffer</h3><p>Each context entry from 0 to nReads-1 has a specific entry inside the read data buffer. It holds (maxBurstSize/wDataBytes) beats of read data. This storage is used to store any read data that comes in for a transaction when it still has an outstanding dependency. </p><p>An entry's beat_count is how far inside its own buffer it needs to write data.</p><p>An entry's read_count is how far inside its own buffer it needs to read out data. </p><p>When reading out of the data buffer p_last may artificially need to be driven as multiple beats may have been combined inside the buffer. This is indicated by last_dp_beat which is driven from (beat_count - 1 == read_count).</p><p>When reading out of the data buffer last may artificially need to be driven if the ROB recorded it recieved last and that last beat of data exits the memory as indicated by last_dp_beat which is driven from (beat_count - 1 == read_count).</p><h4 id="HW-SYMReorderBuffer-SinglePortSRAM(FixedLatency)">Single Port SRAM (Fixed Latency)</h4><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" data-image-src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" loading="lazy"></span></p><h4 id="HW-SYMReorderBuffer-Flops(0cyclelatency)">Flops (0 cycle latency)</h4><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" data-image-src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" loading="lazy"></span></p><h3 id="HW-SYMReorderBuffer-ResponsePathBypass">Response Path Bypass</h3><p>A response ndp can bypass the Response Context if it does not depend on any other transaction as indicated by either the dependency or sent_dp field.</p><p>A response dp can bypass the Response Data Buffer if it is does not depend on any other transaction as indicated by either the dependency or sent_dp field. </p><h3 id="HW-SYMReorderBuffer-DependencyClearingOperation">Dependency Clearing Operation</h3><p>Once an entry's dependency is cleared it has first priority to be sent. This means once there is a valid waiting transaction that has no more dependencies the response path will be back pressured and the ndp/dp will be sent. All future responses to this entry will bypass the context and the read buffer. </p><h2 id="HW-SYMReorderBuffer-Timing">Timing </h2><h3 id="HW-SYMReorderBuffer-Pipeing"><span>Pipeing</span></h3><p><span>pipeLevelRob can indicate that pipes be put on the boundaries of the block. They will be put on each of the in and out interfaces.</span></p><h3 id="HW-SYMReorderBuffer-TimingOptimizationsandSignalNaming"><span>Timing Optimizations and Signal Naming</span></h3><p>To make timing optimizations many signals were moved a cycle back. This is indicated if the signal has &quot;early&quot; or &quot;early_in&quot; in its name. The registered version usually has &quot;early_reg&quot; or &quot;early_out&quot; in its name. </p><h2 id="HW-SYMReorderBuffer-OtherFeatures">Other Features</h2><h3 id="HW-SYMReorderBuffer-ExternalPortDescriptions">External Port Descriptions</h3><p>It is possible with the stand alone ROB for indipendent ports to come into and out of the ROB:</p><ul><li>dependency - Indicates there is a dependency for this transaction as signaled by the context </li><li>dependency_seqnum - Indicates what sequence number the transaction is dependent on</li><li>seqnum_poison - Indicates a sequence number is poisoned. If so the entry and all dependencies on that entry is cleared.</li><li>reserveBeatBuffer - A pass through signal for use inside the beatBuffer</li></ul><h3 id="HW-SYMReorderBuffer-ErrorChecking">Error Checking</h3><ul><li>Context timeout – This is an optional (parameterized) timeout check for context entries. The timeout logic walks through the context entries and takes snapshot of the active context entries. If after a configurable number of cycles, the context entry is not de-allocated or updated, it will result in a timeout interrupt being set.</li><li>ECC for data/header buffer – There can be optional (parametrized) ECC protection enabled for the data buffer and/or header buffer. The ECC check is done when data is read out and any ECC failure results in an interrupt being set and also error bit set in the corresponding packet.</li><li>Context lookup Error - Response received with no corresponding entry in the context buffer.</li></ul><p><br/></p>