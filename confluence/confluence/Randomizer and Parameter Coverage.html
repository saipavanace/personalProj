<style type='text/css'>/*<![CDATA[*/
div.rbtoc1759725303197 {padding: 0px;}
div.rbtoc1759725303197 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1759725303197 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class='toc-macro rbtoc1759725303197'>
<ul class='toc-indentation'>
<li><a href='#RandomizerandParameterCoverage-RandomizerandParameterCoverage'>Randomizer and Parameter Coverage</a>
<ul class='toc-indentation'>
<li><a href='#RandomizerandParameterCoverage-Goals'>Goals</a></li>
<li><a href='#RandomizerandParameterCoverage-Introduction'>Introduction</a></li>
<li><a href='#RandomizerandParameterCoverage-Directory'>Directory</a></li>
<li><a href='#RandomizerandParameterCoverage-Components'>Components</a>
<ul class='toc-indentation'>
<li><a href='#RandomizerandParameterCoverage-Confluence'>Confluence</a></li>
<li><a href='#RandomizerandParameterCoverage-parseConfluence.js'>parseConfluence.js</a></li>
<li><a href='#RandomizerandParameterCoverage-raw_params.json'>raw_params.json</a></li>
<li><a href='#RandomizerandParameterCoverage-params.json'>params.json</a></li>
<li><a href='#RandomizerandParameterCoverage-weights.json'>weights.json</a></li>
<li><a href='#RandomizerandParameterCoverage-updateConfluence.js'>updateConfluence.js</a></li>
<li><a href='#RandomizerandParameterCoverage-Randomizer'>Randomizer</a>
<ul class='toc-indentation'>
<li><a href='#RandomizerandParameterCoverage-buildSv.js'>buildSv.js</a></li>
<li><a href='#RandomizerandParameterCoverage-SystemVerilogModel'>System Verilog Model</a></li>
<li><a href='#RandomizerandParameterCoverage-constraints.js'>constraints.js</a></li>
<li><a href='#RandomizerandParameterCoverage-random_params.json'>random_params.json</a></li>
<li><a href='#RandomizerandParameterCoverage-generator.js'>generator.js</a></li>
<li><a href='#RandomizerandParameterCoverage-TCLconfig'>TCL config</a></li>
</ul>
</li>
<li><a href='#RandomizerandParameterCoverage-ParameterCoverage'>Parameter Coverage</a>
<ul class='toc-indentation'>
<li><a href='#RandomizerandParameterCoverage-dv.json'>dv.json</a></li>
<li><a href='#RandomizerandParameterCoverage-fetchCoverage.js'>fetchCoverage.js</a></li>
<li><a href='#RandomizerandParameterCoverage-generateReport.js'>generateReport.js</a></li>
<li><a href='#RandomizerandParameterCoverage-HTMLReport'>HTML Report</a></li>
</ul>
</li>
</ul>
</li>
<li><a href='#RandomizerandParameterCoverage-Runningtherandomizer'>Running the randomizer</a>
<ul class='toc-indentation'>
<li><a href='#RandomizerandParameterCoverage-runcommand'>run command</a></li>
<li><a href='#RandomizerandParameterCoverage--ciswitch'>-ci switch</a></li>
<li><a href='#RandomizerandParameterCoverage--rsswitch'>-rs switch</a></li>
</ul>
</li>
<li><a href='#RandomizerandParameterCoverage-ConfigCreation'>Config Creation</a></li>
<li><a href='#RandomizerandParameterCoverage-RunningParameterCoverage'>Running Parameter Coverage</a></li>
<li><a href='#RandomizerandParameterCoverage-Status'>Status</a></li>
<li><a href='#RandomizerandParameterCoverage-FutureImprovements'>Future Improvements</a></li>
</ul>
</li>
</ul>
</div><p /><h1 id="RandomizerandParameterCoverage-RandomizerandParameterCoverage">Randomizer and Parameter Coverage</h1><h2 id="RandomizerandParameterCoverage-Goals">Goals</h2><ul><li><p>To create a random configuration with legal combinations of all user settable parameters</p></li><li><p>To find issues with Maestro where it lets us create an invalid config</p></li><li><p>To find RTL and DV issues on unforeseen configurations </p></li><li><p>Measure the coverage of parameters across all configs generated randomly and manually</p></li></ul><h2 id="RandomizerandParameterCoverage-Introduction">Introduction</h2><p>This is a different version of randomizer from the existing randomizer, in that it is completely written in Javascript. However, the output of this randomizer is still TCL file which can be fed to Maestro (or buildTb script) to generate the RTL and DV files. The fact that this is written in javascript makes it easy for others to understand and modify the script later based on our requirements</p><span class="confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image image-center" alt="image-20250508-153708.png" width="1061" src="https://arterisip.atlassian.net/wiki/download/attachments/443416591/image-20250508-153708.png?api=v2"></span><p /><h2 id="RandomizerandParameterCoverage-Directory">Directory</h2><p>The randomizer is completely self contained with the $WORK_TOP/dv/scripts/randomizer directory</p><p>The parameter coverage related scripts are located at $WORK_TOP/dv/scripts/randomizer/params/coverage/scripts directory</p><h2 id="RandomizerandParameterCoverage-Components">Components</h2><h3 id="RandomizerandParameterCoverage-Confluence">Confluence</h3><ul><li><p>Confluence holds all the parameters that exist in Maestro including the user visible parameters, derived parameters and fixed parameters</p></li><li><p>The confluence should be the master copy of parameters which is maintained by the architecture team</p></li><li><p>Information of each parameter is defined in a static structure within the confluence page so that it gets easy to automatically parse it</p></li></ul><h3 id="RandomizerandParameterCoverage-parseConfluence.js">parseConfluence.js</h3><ul><li><p>This is a script that accesses the confluence via the confluence API and gathers all the parameters into a JSON structure</p></li><li><p>This acts as a bridge between the human readability of the confluence document and the machine readability of the JSON structure so that the process can be easily automated going forward</p></li><li><p><strong>Usage:</strong> node parseConfluence.js</p></li></ul><h3 id="RandomizerandParameterCoverage-raw_params.json">raw_params.json</h3><ul><li><p>This is the output of the parseConfluence javascript code</p></li><li><p>This captures all the parameters and various details about the parameters in the form of a JSON structure</p></li></ul><h3 id="RandomizerandParameterCoverage-params.json">params.json</h3><ul><li><p>The raw_params.json file generated above has more information than we need for creating a random config. For example, the descriptions of the parameter</p></li><li><p>Therefore, the parseConfluence.js code refines the raw_params.json a little bit more to create this params.json file</p></li><li><p>Basically params.json file is a light-weight form of raw_params.json which can be traversed faster and more efficiently by the randomization logic</p></li></ul><h3 id="RandomizerandParameterCoverage-weights.json">weights.json</h3><ul><li><p>This is used by the randomizer to adjust the weightage to assign a specific value to a parameter</p></li><li><p>This file is initially produced the the parseConfluence.js script where a “weight“ is associated with each and every parameter. Then this can be updated to control the weightage of various values of a parameter</p></li><li><p>Note that once the weight.json file is updated, even when the script is run again, the previous updates wont be erased. Instead the script just “updates“ the weights.json file to include any new parameters</p></li></ul><h3 id="RandomizerandParameterCoverage-updateConfluence.js">updateConfluence.js</h3><ul><li><p>This is a side script which is not part of the runsim flow, which helps us easily update the confluence page</p></li><li><p>The script takes in the raw_params.json file which can be edited manually by the user and updates the confluence page with the new information in the raw_params.json</p></li><li><p><strong>Usage:</strong> node updateConfluence.js</p></li></ul><h3 id="RandomizerandParameterCoverage-Randomizer">Randomizer</h3><h4 id="RandomizerandParameterCoverage-buildSv.js">buildSv.js</h4><ul><li><p>Since writing a constraint solver from scratch is not easy, the current version of randomizer leverages the sophisticated constraint solver that is already present within the VCS Simulator</p></li><li><p>However, in order to be able to use the simulator, we need to convert the parameter information into a system verilog model which can be simulated and randomized</p></li><li><p>The main inputs to this script is constraints.js, weights.json and the params.json file and the output would be random_params.json which contains all the parameters with their randomized values</p></li></ul><h4 id="RandomizerandParameterCoverage-SystemVerilogModel">System Verilog Model</h4><ul><li><p>We take the parameters described in the params.json file and construct a complete System Verilog Model for each parameter which represents the JSON file</p></li><li><p>The structure is inspired by the UVM register model structure, in which all registers are described as a SV model by reading the IPXACT format</p></li><li><p>This makes it easy to leverage various SV features pertaining to randomization like applying constraints, adding coverage bins, adding cross coverage between parameters, generating coverage, fetching coverage, reporting etc</p></li><li><p>This model is called the params_pkg.sv file. </p></li><li><p>Along with the params_pkg.sv file, we also construct the top level module to instantiate this model and randomize it which is then simulated using a VCS license</p></li></ul><h4 id="RandomizerandParameterCoverage-constraints.js">constraints.js</h4><ul><li><p>This is stand-alone JS file, which holds all the constraints between various parameters (Example, there has to be atleast 1 AIU with fnCsrAccess = 1)</p></li><li><p>These will be plugged into the SystemVerilog Model as a System Verilog constraint and will automatically applied while randomizing all the parameters</p></li><li><p>This will also be useful to document all the constraints at one place. One future TBD is to get these constraints from confluence and let the Arch team take control</p></li></ul><h4 id="RandomizerandParameterCoverage-random_params.json">random_params.json</h4><ul><li><p>Once the above model is constructed and simulated, we randomize every parameter within the valid values by applying the constraints.</p></li><li><p>After that we call a custom print function by which we traverse through all the parameters to print randomized values back into the JSON format</p></li><li><p>This is the final random_params.json file where each parameter holds a randomly generated value</p></li></ul><h4 id="RandomizerandParameterCoverage-generator.js">generator.js</h4><ul><li><p>After the random_params.json is generated, the generator.js script takes it and starts writing the TCL file in the format that Maestro understands and plugs in the random values for each parameter</p></li><li><p>The output of this will be the TCL config</p></li></ul><h4 id="RandomizerandParameterCoverage-TCLconfig">TCL config</h4><ul><li><p>This is the stand-alone TCL config that is generated by the randomizer which can readily be fed into Maestro</p></li><li><p>This config is inserted along with the other configs in our DV simulation flow so that we can use this random config instead of a static config everywhere in our flow</p></li></ul><h3 id="RandomizerandParameterCoverage-ParameterCoverage">Parameter Coverage</h3><h4 id="RandomizerandParameterCoverage-dv.json">dv.json</h4><ul><li><p>This will be the source of fetching the parameter values to calculate the coverage</p></li><li><p>This is the output from Maestro which is generated after running our random config through Maestro</p></li></ul><h4 id="RandomizerandParameterCoverage-fetchCoverage.js">fetchCoverage.js</h4><ul><li><p>This script simulates the SV model of parameters and dumps the functional coverage for it by populating the values for each parameter</p></li><li><p>It also parses the Coverage report generated by VCS to measure the coverage metrics</p></li></ul><h4 id="RandomizerandParameterCoverage-generateReport.js">generateReport.js</h4><ul><li><p>This is the reporting part of the parameter coverage.</p></li><li><p>This dumps the necessary HTML files</p></li></ul><h4 id="RandomizerandParameterCoverage-HTMLReport">HTML Report</h4><p>Here is the example HTML report for parameter coverage:</p><span class="confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image image-center" alt="image-20250508-160441.png" width="768" src="https://arterisip.atlassian.net/wiki/download/attachments/443416591/image-20250508-160441.png?api=v2"></span><p /><h2 id="RandomizerandParameterCoverage-Runningtherandomizer">Running the randomizer</h2><p>The randomizer code itself is embedded inside our runsim script</p><h3 id="RandomizerandParameterCoverage-runcommand">run command</h3><ul><li><p>This is an example run command: runsim -e fsys -c hw_randomizer_config -t aiu_random -i 1 -ci 2</p></li></ul><h3 id="RandomizerandParameterCoverage--ciswitch">-ci switch</h3><ul><li><p>The “ci“ switch specifies the total number of configs the randomizer needs to generate.</p></li><li><p>For example in the above run command, we are telling the randomizer to run the “aiu_random“ test on 2 random configurations.</p></li><li><p>Note that in the run command, the hw_randomizer_config is kind of a “keyword“ config which just lets runsim differentiate between every other config and a random config</p></li><li><p>So we need to stick to that name for now to ask runsim to run tests on a random configuration</p></li><li><p>However, we can continue to add the tests that we want to run on a random config to the “hw_randomizer_config“ along with other labels and plusargs like any other config</p></li></ul><h3 id="RandomizerandParameterCoverage--rsswitch">-rs switch</h3><ul><li><p>By default the randomizer gets a default seed value to generate the config</p></li><li><p>However, in case we want to reproduce an issue, it is possible to pass a integer value to runsim (and in turn, to the randomizer) to get the exact same config everytime. This is mainly useful for debugging</p></li><li><p>Note that even though we can make the randomizer generate exact same config, due to changes in Maestro, DV and RTL, it might be hard to generate the issue that we are looking to reproduce</p></li></ul><h2 id="RandomizerandParameterCoverage-ConfigCreation">Config Creation</h2><ul><li><p>The randomizer writes the output tcl (config) to this path: $MEASTRO_EXAMPLES/../base_configs/</p></li><li><p>The output file is called hw_randomizer_config_&lt;seed&gt; where seed is a unique number generated within the randomizer or the value passed to runsim using the “-rs” switch</p></li><li><p>NOTE: If we run a test on a random configuration or a regression with multiple configs, there will be a bunch of configurations generated in the above directory which <u>SHOULD NOT</u> be checked in and can be deleted when required</p></li></ul><h2 id="RandomizerandParameterCoverage-RunningParameterCoverage">Running Parameter Coverage</h2><ul><li><p>In the already existing runsim switch -exe, the MSB bit of the 12bit value controls the Parameter coverage</p></li><li><p>For example this is a runsim command to enable parameter coverage: runsim -e chi_subsys -c hw_cfg_42_e -t random_noncoherent -exe 877 </p></li><li><p>The MSB bit if -exe switch is '1' and hence parameter coverage will be enabled.</p></li><li><p>NOTE: Parameter coverage is enabled by default. So no need to specifically enable it. To check the coverage from a run or regression, we can find a HTML report under the debug/parameter_coverage path</p></li></ul><h2 id="RandomizerandParameterCoverage-Status">Status</h2><p>The current randomizer status is tracked in <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/613319015/Randomizer+Implementation+and+Regression+Status" data-linked-resource-id="613319015" data-linked-resource-version="6" data-linked-resource-type="page">this</a> page</p><h2 id="RandomizerandParameterCoverage-FutureImprovements">Future Improvements</h2><ul><li><p>See if there is a way to share a common library between the SW and DV team where we can put all our Maestro functions for easy sharing in the future so that we need not update the randomizer every time a function changes within the SW team internally</p></li><li><p>Get a complete list of all Maestro parameters to ensure we randomized everything</p></li></ul>