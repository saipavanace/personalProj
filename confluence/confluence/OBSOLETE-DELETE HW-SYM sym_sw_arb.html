<h1 id="OBSOLETE-DELETEHW-SYMsym_sw_arb-module_name"><strong>module_name</strong></h1><p>sym_sw_arb</p><h1 id="OBSOLETE-DELETEHW-SYMsym_sw_arb-parameters">parameters</h1><h2 id="OBSOLETE-DELETEHW-SYMsym_sw_arb-java_script:">java_script:</h2><pre>{
	&quot;numPort&quot; : any positive integer,</pre><pre>        &quot;numVc&quot; : any positive integer,</pre><pre>        &quot;numPri&quot; : any positive integer,</pre><pre>        &quot;mstrArbLck&quot; : boolean // true master arb locks, false master arb doesn't lock. Default false.</pre><pre>        &quot;vcLckStyleVld&quot; : boolean // Lock Style of VC arbiters. true locks on valid, false locks on ready. Default false.</pre><pre>        &quot;mstrLckStyleVld&quot; : boolean // Lock Style of master arbiter. true locks on valid, false locks on ready. Default false.</pre><pre>        &quot;arbType&quot; : {vc0ArbType: type, vc1ArbType: type . . . vc(num_vc-1)ArbType: type, masterArbType: type},</pre><pre>        &quot;portMap&quot; : {vc0PortMap: [i,j,k], vc1PortMap: [i,j,k] . . . vc(num_vc-1)PortMap: [i,j,k]} // i,j,k are list of ports that connect to that VC.</pre><pre>        &quot;masterArbRdyAware&quot; : &quot;yes&quot; | &quot;no&quot;, // When yes, the Master Arb uses the rdy AND vld to make a request. When no, just vld.</pre><pre>        &quot;weights&quot; : {vc0Weights: [wi,wj,wk], vc1Weights: [wi,wj,wk] . . . vc(num_vc-1)Weights: [i,j,k], masterWeights: [wl,wm,wn]}, //wi,wj,wk correspond to the ports for that VC.</pre><pre>        &quot;weightsProg&quot; &quot; &quot;yes&quot; | &quot;no&quot; // if the weights are programmable, the weights above represent registers widths, if not, represent hard value weights.</pre><pre>        &quot;protectionStyle&quot; : <a class="external-link" href="https://confluence.arteris.com/display/ENGR/protectionStyle" rel="nofollow">protectionStyle</a></pre><pre>}</pre><pre>type can be: arb_rr1, arb_rr2, arb_wrr_rr1, arb_wrr_rr2, arb_pri_rr1, arb_pri_rr2</pre><h2 id="OBSOLETE-DELETEHW-SYMsym_sw_arb-verilog:"><strong>verilog:</strong></h2><pre style="margin-left: 30.0px;">none.</pre><h1 id="OBSOLETE-DELETEHW-SYMsym_sw_arb-I/O"><strong>I/O</strong></h1><pre>u.port('input', 'clk', 1);<br/>u.port('input', 'reset_n', 1);<br/>for (i = 0; i &lt; numVc; i++) {<br/>  arb_type = arbType['vc'+i+'ArbType'];<br/>  arb_port_map = portMap['vc'+i+'PortMap'];<br/>  arb_num_pri = numPri;<br/>  arb_port_weights = weights['vc'+i+'Weights'];<br/>  arb_weights_prog = weightsProg;</pre><pre>  u.port('input', 'in_vc'+i+'_vld', numPort);<br/>  u.port('output', 'in_vc'+i+'_rdy', numPort);<br/>  u.port('output', 'out_vc'+i+'_vld', 1);<br/>  u.port('input', 'out_vc'+i+'_rdy', 1);<br/>  if (arb_port_map.length &gt; 1) {<br/>    u.port('output', 'vc'+i+'_data_sel', numPort);<br/>  }<br/>  if ((weightsProg === &quot;yes&quot;) &amp;&amp; (arb_type.substr(0,8) === 'arb_wrr_')) {<br/>    u.port('input', 'vc'+i+'_weights',arb_port_weights.reduce(arraySum));<br/>  }<br/>}<br/>for (i = 0; i &lt; numPort; i++) {<br/>  if ((arb_type.substr(0,8) === &quot;arb_pri_&quot;) ||<br/>    (arbType.masterArbType.substr(0,8) === &quot;arb_pri_&quot;) {<br/>    u.port('input', 'in_port'+i+'_pri', utilFunctions.log2ceil(numPri));<br/>  }<br/>}<br/>u.port('input', 'in_fst', numPort);<br/>u.port('input', 'in_lst', numPort);<br/>u.port('output', 'out_fst', 1);<br/>u.port('output', 'out_lst', 1);<br/>if ((weightsProg === &quot;yes&quot;) &amp;&amp; (arbType.masterArbType.substr(0,8) === &quot;arb_wrr_&quot;)) {<br/>  u.port('input', 'master_weights', weights.masterWeights.reduce(arraySum));<br/>}<br/>if (numVc &gt; 1) {<br/>  u.port('output', 'master_data_sel', numVc);<br/>}<br/>//<br/>// Not using creating *_err_index when reporting protection errors.<br/>//<br/>if (protectionStyle !== &quot;&quot;) {<br/>  if (protectionStyle.protection === &quot;parity&quot;) {<br/>    if (protectionStyle.reportErr === &quot;yes&quot;) {<br/>      u.port('output', 'par_err', 1);<br/>      if (protectionStyle.dupLite === &quot;yes&quot;) {<br/>        u.port('output', 'miscompare',1);<br/>      }<br/>    }<br/>    if (protectionStyle.forceErr === &quot;yes&quot;) {<br/>      u.port('input', 'force_par_err',1); <br/>      if (protectionStyle.dupLite === &quot;yes&quot;) {<br/>        u.port('input', 'force_miscompare',1);<br/>      }<br/>    }<br/>  }</pre><pre>  if (protectionStyle.protection === &quot;ecc&quot;) {<br/>    if (protectionStyle.reportErr === &quot;yes&quot;) {<br/>      u.port('output', 'sb_err', 1);<br/>      u.port('output', 'db_err', 1);<br/>      u.port('output', 'syndrome', utilFunctions.getEccWidth(protectionStyle.protWidth));<br/>      if (protectionStyle.dupLite === &quot;yes&quot;) {<br/>        u.port('output', 'miscompare',1);<br/>      }<br/>   }<br/>   if (protectionStyle.forceErr === &quot;yes&quot;) {<br/>     u.port('input', 'force_sb_err',1); <br/>     u.port('input', 'force_db_err',1); <br/>     if (protectionStyle.dupLite === &quot;yes&quot;) {<br/>       u.port('input', 'force_miscompare',1);<br/>     }<br/>   }<br/><span style="font-family: Arial , sans-serif;">  }<br/></span><span style="font-family: Arial , sans-serif;">}</span></pre><h1 id="OBSOLETE-DELETEHW-SYMsym_sw_arb-FunctionsUsed"><strong style="font-family: Arial , sans-serif;">Functions Used</strong></h1><p>hw_lib:getEccWidth(width) Returns to width of ECC bits based on width of data.</p><p>hw_lib:log2ceil(entry) Returns the width-1 of bits needed to store the binary version of entry.</p><h2 id="OBSOLETE-DELETEHW-SYMsym_sw_arb-LocalFunctions:">Local Functions:</h2><p>arraySumBitWidths(total,entry) Helper function used to sum an array.</p><p>stateWidth(type,width,numPri,weights,weightsProg) Helper function used to calculate the width of state_in and state_out for an arbiter.</p><p>getWeightBitWidths(weights) Takes in an array of numbers and returns an array of bit widths needed to implement a counter of that number.</p><p>getArbParams(type,width,numPri,weights,weightsProg) Helper function used to calculate parameters passed to an arbiter.</p><p>getArbPorts(type,width,numPri,weights,weightsProg,prefix,doesLock) Helper function used to calculate the pins and pin wires used by an arbiter.</p><h1 id="OBSOLETE-DELETEHW-SYMsym_sw_arb-ModulesUsed"><strong>Modules Used</strong></h1><p>arb_rr1</p><p>arb_rr2</p><p>arb_wrr_rr1</p><p>arb_wrr_rr2</p><p>arb_pri_rr1</p><p>arb_pri_rr2</p><p>arb_fifo</p><p>prot_reg</p><h1 id="OBSOLETE-DELETEHW-SYMsym_sw_arb-Description"><strong>Description</strong></h1><p>The below figure shows how arbType, portMap and weights interact:</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="500" src="https://arterisip.atlassian.net/wiki/download/attachments/16167479/IMG_2774.jpg?api=v2"></span></p><p>VC aware arbiter. Top love block diagram is shown below (doesn't show priority signaling which is equivalent to fst and lst.):</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16167479/syn_arbBlockDiagram.svg?api=v2"></span></p><p>Though data path is not a part of this block it will follow a similar path as either first or last signals. If there is only one VC, then the Master Arb goes away leaving only a single Arb &amp; Lock Logic block.</p><p>The below shows the block diagram for one of the Vcm Arb and Lock Logic Blocks (doesn't show priority signaling which is equivalent to fst and lst.)</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16167479/locking_arb.svg?api=v2"></span></p><p>The figure below show the block diagram for the Master Arbiter (doesn't show priority signaling which is equivalent to fst and lst, except priority never leaves as an output.)</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16167479/master_arb.svg?api=v2"></span></p><h2 id="OBSOLETE-DELETEHW-SYMsym_sw_arb-LockLogic:">Lock Logic:</h2><p>When an arbiter is locked, its state is not allowed to transition until it unlocks.</p><p>Locking Style: Below the description of locking assumes the style is *LckStyleVld = true. When *LckStyleVld = false, valid and ready must be asserted together for the associated port or VC to lock. Locking Style doesn't effect when an arbiter leaves lock. </p><p>VC arbiters: When the VC arbiters lock, they mask all requests except for the port the VC arbiter is locked on. Arbiter enters lock, when only first is asserted with a request (valid=1). Arbiter exits lock when last is asserted with a request and it's granted (ready = 1) for the port that arbiter is locked on.</p><p>Master arbiter: To enable master arbiter locking, set mstrArbLock = true. When the Master Arbiter locks, it masks off all requests except for the VC the arbiter is locked on when that VC is making a request, otherwise (during a bubble on the locked VC) it arbitrates between the other VCs not locked on making a request. Arbiter enters lock when a request (valid=1) is granted (ready = 1) and last is not asserted. First is not required to enter lock. Arbiter exits lock when last is asserted with a request and it's granted (ready = 1) for the VC the arbiter is locked on. The other change arbiter state transition. When mstrArbLock = false, the arbiter changes state every time a request is made, regardless of ready. When mstrArbLock = true, then the arbiter only changes state whenever there is a ready/valid pair with last asserted. </p><p><br/></p><p><br/></p>