<p><style type='text/css'>/*<![CDATA[*/
div.rbtoc1759724153402 {padding: 0px;}
div.rbtoc1759724153402 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1759724153402 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class='toc-macro rbtoc1759724153402'>
<ul class='toc-indentation'>
<li><a href='#Maestrologicsynthesisflow-Intro'>Intro</a></li>
<li><a href='#Maestrologicsynthesisflow-Customizingconstraintgeneration'>Customizing constraint generation</a></li>
</ul>
</div></p><p><ul class='childpages-macro'><li><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16170875/2019-11-06+Synthesis+meeting+notes" data-linked-resource-id="16170875" data-linked-resource-version="3" data-linked-resource-type="page">2019-11-06 Synthesis meeting notes</a></li><li><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16170862/Synthesis+To+Do" data-linked-resource-id="16170862" data-linked-resource-version="56" data-linked-resource-type="page">Synthesis To Do</a></li><li><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16171288/Timing+constraints+for+async+clock+adapters" data-linked-resource-id="16171288" data-linked-resource-version="3" data-linked-resource-type="page">Timing constraints for async clock adapters</a></li></ul></p><h2 id="Maestrologicsynthesisflow-Intro">Intro</h2><p>This page describes generation of Synopsys synthesis scripts and timing constraints from Maestro/Aria. The general page describing how to use Aria is <a class="external-link" href="https://confluence.arteris.com/display/ENGR/Aria" rel="nofollow">here</a></p><p>In a nutshell the whole functionality is packed under one Aria command - genDcSynScript, which derives necessary information from</p><ol><li>Genwrapper json generated by Maestro. <br/> Default: output/debug/<a class="external-link" href="http://top.level.rtl.gw" rel="nofollow">top.level.rtl.gw</a>.csr.json</li><li>Interface CPRs<br/> Default: $REPO_PATH/hw-*/cpr/interface </li><li>Tachl auxiliary files<br/> Default: output/rtl/design/*json</li></ol><p>Step 1: Run Maestro in order to have all these input files in place:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">module load dev/maestro_test
run_maestro -g -t your_maestro_flow.tcl</pre>
</div></div><p><br/>Step 2: create simple Aria js script to generate Synopsys synthesis scripts and constraints, for example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: js; gutter: false; theme: Confluence" data-theme="Confluence">// gen_dc_script.js
genDcSynScript({
  genScriptDir: &#39;top/dc_scripts&#39;,
  compileCommand: &#39;compile -map_effort medium -area_effort none -power_effort none -no_design_rule&#39;,
  keepInteractiveSession: true
});
exit();</pre>
</div></div><p> then run it with: <strong><code>aria -s gen_dc_script.js</code></strong></p><p>This specific example creates a flavor of dc_shell scripts which exercise low-effort synthesis flow with relaxed timing constraints -  useful for early experiments, when you just want to know if Maestro generated RTL can be mapped to gates at all... By default the top level module (always called gen_wrapper) is synthesized, but user can choose any other module in design hierarchy tree with topDesign option.</p><p> Files are generated in  genScriptDir directory. The most important ones are:<br/>  1.  <strong>dc.tcl</strong> - main script to be sourced in design compiler <br/><code> 2. <strong>&lt;design_name&gt;.sdc</strong></code> - timing constraints. At the moment we only take care of the clocks and IO delays. </p><p>Step 3: launch Synthesis run, for ex:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">/engr/dev/tools/synopsys/syn_vO-2018.06-SP3/syn/O-2018.06-SP3/bin/dc_shell-t -f top/dc_scripts/dc.tcl -output_log_file gen_wrapper.dc.log</pre>
</div></div><p>dc_shell results are dumped to outputs/ and reports/  subdirectories</p><p>Most of the parameters  of  genDcSynScript  have defaults and can be skipped. In a nutshell they can be divided into 3 categories:</p><ol><li>pointers to input and output files/dirs</li><li>params affecting Synthesis strategies and script sequence in general</li><li>params affecting generated constraints</li></ol><p>To see all available command parameters start interactive aria session and type<strong><code> genDcSynScript('help')</code></strong>. Here is the full list at this moment (it will grow!): </p><div class="code panel pdl" style="border-width: 1px;">
 <div class="codeHeader panelHeader pdl hide-border-bottom">
  <b class="code-title"></b><span class="collapse-source expand-control" style="display:none;"><span class="expand-control-icon icon">&nbsp;</span><span class="expand-control-text">Expand source</span></span><span class="collapse-spinner-wrapper"></span>
 </div>
 <div class="codeContent panelContent pdl hide-toolbar">
  <pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence; collapse: true" data-theme="Confluence">   topDesign
    Name of the design to be synthesized
    type: string
    default: gen_wrapper
  rtlJson
    RTL json file in genwrapper format exported from Maestro
    type: input_file
    default: ./output/debug/top.level.rtl.gw.csr.json
  rtlDir
    Directory with behavior verilog files generated by Maestro/tachl
    type: input_dir
    default: ./output/rtl/design
  rtlWrapperDir
    Directory with verilog files instantiating custom cells, such as memories.
         If the same verilog file is found in both rtlWrapperDir and rtlDir, the former takes precedence
    type: input_dir
  excludeVerilogModules
    List of verilog modules to be excluded from reading by the synthesis tool. Two ways to specify:
    a. String with module names separated by space, ex: 'sym_pipe_adapter_0 sym_pipe_adapter_3'
    b. JS expression returning a list of module names, ex:
     eval getObjs({type:'instance'}).filter(o=&gt;(o.module==='sym_pipe_adapter' &amp;&amp; o.params.depth &gt; 64)).map(o=&gt;o.verilogModule)
    type: string
  cprInterfaceDirs
    List of directories with CPR interface definitions
    type: input_dir
    default: /engr/dev/releases/utils/dep/m.ncore.stable/hw-lib/cpr/interface,/engr/dev/releases/utils/dep/m.ncore.stable/hw-ncr/cpr/interface,/engr/dev/releases/utils/dep/m.ncore.stable/hw-sym/cpr/interface
  techNode
    Target technology
    type: enum
    choices: [tsmc16,tsmc7]
    default: tsmc7
  hardMacroDbs
    List of db files containing compiled models of hard macros used in the design
    type: input_file
    default: 
  genScriptDir
    Create synthesis scripts and constraint file in this directory
    type: output_dir
    default: output/synthesis/synopsys/scripts
  checkOnly
    Don't run synthesis, but do a deeper check of input RTL
    type: boolean
    default: false
  keepInteractiveSession
    Don't quit dc_shell session when script is done executing. Useful for debug
    type: boolean
    default: false
  topoMode
    Run synthesis tool in topographical mode
    type: boolean
    default: false
  bottomUpSynthesis
    Characterize and compile major functional blocks first and then top level
    type: boolean
    default: false
  ungroupStartLevel
    Causes all hierarchical cells that are at the level specified by this option to be flattened
    type: number
    default: 2
  compileCommand
    dc_shell command for first (non-incremental) netlist compile.
    Hint: for low effort compile use: compile -map_effort medium -area_effort none -power_effort none -no_design_rule 
    type: string
    default: compile_ultra -no_boundary_optimization -gate_clock
  incrementalOpt
    Perform incremental optimizations after first compile
    type: boolean
    default: false
  clockScalingFactor
    Multiply all clock periods by this number to make timing convergence easy
    type: number
    default: 1
  maxTransition
    Maximal signal transition constraint,ns
    type: number
    default: 0.15
  outputLoad
    Capacitive load for all primary outputs, pf
    type: number
    default: 0.2
  clockUncertainty
    Clock uncertainty as a fraction of the cycle time of a clock
    type: number
    default: 0.1
  asyncAdapterWritePtrRegName
    String pattern indicating register cell of write pointer relative to async adapter cell hierarchy
    type: string
    default: U_wrap/u_gen_async_adapter_in/u_async_fifo_wt_ctl/u_ptr_reg/reg_out_dffre/q_reg[*]
  asyncAdapterReadPtrRegName
    String pattern indicating register cell of read pointer relative to async adapter cell hierarchy
    type: string
    default: U_wrap/u_gen_async_adapter_out/u_async_fifo_rd_ctl/u_ptr_reg/reg_out_dffre/q_reg[*]
  asyncAdapterDataRegName
    String pattern indicating data register cell relative to async adapter cell hierarchy
    type: string
    default: U_wrap/u_gen_async_adapter_in/u_async_fifo_reg_dp/u_pipereg_*/reg_out_dffre*/q*
  maxPaths
    Number of timing paths to report
    type: number
    default: 10


</pre>
 </div>
</div><p>Parameters can either be explicit or have a form of evaluated javascript expressions - in this case value string must start with eval keyword. For example, to exclude all pipe adapters deeper than 64 from synthesis:  </p><p>excludeVerilogModules: &quot;eval getObjs({type:'instance'}).filter(o=&gt;(o.module==='sym_pipe_adapter' &amp;&amp; o.params.depth &gt; 64)).map(o=&gt;o.params.verilogModule)&quot;</p><h2 id="Maestrologicsynthesisflow-Customizingconstraintgeneration">Customizing constraint generation</h2><p>With bottomUpSynthesis option set to false (default) Aria only generates constraints for the top level - this file is always called gen_wrapper.sdc. When set to true, constraints for all ATU and Ncore units are also generated. Transport networks are not constrained because they're synthesized with the top level.</p><p>Notice that verilog modules of Ncore units can have multiple instantiations. For ex in hw_config_07 there are 9 ncaiu* instances.  </p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: js; gutter: false; theme: Confluence" data-theme="Confluence">getObjs({type:&#39;instance&#39;}).filter(o=&gt;o.module===&#39;ioaiu_top&#39;).map(o=&gt;`inst:${o.name} module:${o.module} verilogModule:${o.verilogModule}`).join(&#39;\n&#39;)</pre>
</div></div><p>In genwrapper they're all instances of the same ioaiu_top module, but tachl uniquifies to 4 modules </p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">inst:ncaiu0 module:ioaiu_top verilogModule:ioaiu_top_a
inst:ncaiu1 module:ioaiu_top verilogModule:ioaiu_top_a
inst:ncaiu2 module:ioaiu_top verilogModule:ioaiu_top_b
inst:ncaiu3 module:ioaiu_top verilogModule:ioaiu_top_b
inst:ncaiu4 module:ioaiu_top verilogModule:ioaiu_top_b
inst:ncaiu5 module:ioaiu_top verilogModule:ioaiu_top_b
inst:ncaiu6 module:ioaiu_top verilogModule:ioaiu_top_b
inst:ncaiu7 module:ioaiu_top verilogModule:ioaiu_top_c
inst:ncaiu8 module:ioaiu_top verilogModule:ioaiu_top_d</pre>
</div></div><p>Subsequently only 4 correspondent constraint files are created : ioaiu_top_a.sdc  ioaiu_top_b.sdc  ioaiu_top_c.sdc  ioaiu_top_d.sdc. They will be sourced during synthesis of ioaiu_top* verilog modules</p><p>User can customize IO delays of top and block level with a callback function. For ex the code below aims to allocate 80% of cycle time to Ncore unit SMI interface signals and 60% to all other interfaces</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">function myInterfaceIoDelays(context) {
  // Walk through all interfaces of the instance except irq and pma
  for (let interf of context.getObjs({type:&#39;interface&#39;}).filter(i=&gt;![&#39;InterfaceIRQ&#39;,&#39;InterfacePQChannel&#39;].includes(i.model))) {
    
    // If we&#39;re constraining top level - give 50% to all inputs and outputs
    if (context.type === &#39;chip&#39;) {
      interf.inputDelay = interf.outputDelay = 0.5;
      continue;
    }
    // If it&#39;s unit level (Ncore units) SMI interfaces get 80% of the cycle time and all other interfaces get 60%
    if (interf.model === &#39;InterfaceSMI&#39;) {
      // SMI interface
      interf.inputDelay = interf.outputDelay = 0.2;
    } else {
      // Non-SMI interface
      interf.inputDelay = interf.outputDelay = 0.4;
    }
  } 
}

genDcSynScript({
  ...
  ioDelaysFunc: myInterfaceIoDelays,
  bottomUpSynthesis: true 
});</pre>
</div></div><p>These delays are saved as interface parameters in Aria design hierarchy. You can run tool in graphical mode to browse:  aria -s gen_syn_scripts.js -g</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="600" src="https://arterisip.atlassian.net/wiki/download/attachments/16167698/image2020-1-10%2014:6:11.png?api=v2"></span></p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="600" src="https://arterisip.atlassian.net/wiki/download/attachments/16167698/image2020-1-10%2014:7:15.png?api=v2"></span></p><p> </p><p>Subsequently in the generated constraint file you will see</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">create_clock -name clk1_6_clk1_6_domain_clk1_6_subdomain_clk -period 0.625 [get_ports clk1_6_clk1_6_domain_clk1_6_subdoma
in_clk]
set fastest_clock [get_clocks clk1_6_clk1_6_domain_clk1_6_subdomain_clk]


# Interface apb_ (InterfaceAPB, slave) input delay: 0.4, output delay: 0.4 of clock cycle
set_input_delay 0.25 -clock $fastest_clock [get_ports apb_paddr]
set_input_delay 0.25 -clock $fastest_clock [get_ports apb_psel]
...
# Interface smi_tx1_ (InterfaceSMI, master) input delay: 0.2, output delay: 0.2 of clock cycle
set_output_delay 0.125 -clock $fastest_clock [get_ports smi_tx1_ndp_targ_id]
set_output_delay 0.125 -clock $fastest_clock [get_ports smi_tx1_ndp_src_id]
...</pre>
</div></div><p> </p><p> </p>