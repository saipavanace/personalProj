<h1 id="OBSOLETE-DELETEHW-SYMATUCommonCharacteristics-Timingandpipestages">Timing and pipe stages</h1><p>Every ATU has four levels of pipelining that happens associated with the various interfaces:</p><ol><li>Native Interface</li><li>Common Interface</li><li>SMI Interface</li><li>ATP Interface</li></ol><p>The pipe depth for 1, 3 and 4 can only have one of three values: 0, 1 or 2. The Common interface can have deeper depth to deal with pipelining of context, but for this discussion we will treat all depths greater than 2 as 2.</p><h2 id="OBSOLETE-DELETEHW-SYMATUCommonCharacteristics-pipeForwardandpipeBackward">pipeForward and pipeBackward</h2><p>Every level of pipelining has two additional parameters associated with it, pipeForward (pF) and pipeBackward (pB).</p><p>pipeForward is associated with the valid going forward and if true means the valid is coming from a register from the output interface of the pipe. pipeForward being false means the valid is a function the valid from the input interface of the pipe stage and so the pipe stage can be bypassed if it is empty and ready on the output interface is true.</p><p>pipeBackward is associated with the ready going backwards and if true means the ready is coming from a register from the input interface of the pipe. pipeBackward being false means the ready to the input interface is a function of the ready from the output interface.</p><p>In the context of the rules being stated ATU initiators and ATU targets, the Native interfaces is considered to be the starting interface.</p><p>Rules:</p><ol><li>When depth = 0 it is not considered a pipe stage.</li><li>Any stage with depth = 2 is pF = pB = true.</li><li>Any stage with depth = 1 that is the first or not the last pipe stage in the ATU is pF = false, pB = true.</li><li>Any stage with depth = 1 that is the last pipe stage and not the first pipe stage in the ATU is pF = true, pB = false.</li></ol><p><br/></p><h3 id="OBSOLETE-DELETEHW-SYMATUCommonCharacteristics-ATUIAXI/APBPipes">ATUI AXI/APB Pipes</h3><p>// A depth of 1 is forced if ATP is lock-on-ready (retracting)<br/>var smiPipeLevelAtp = lckStyleVld || pipeLevelAtp ? pipeLevelAtp : 1;</p><p>var forcedAtpPipe     = lckStyleVld || pipeLevelAtp ? false : true;</p><p>*** If forcedAtpPipe is <strong>false</strong> then the ATP stage is not taken into consideration for above algorithm. </p><p>*** See above to determine if any stage is pipeForward or pipeBackward.</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh"><br/></th><th class="confluenceTh">Native Layer Pipe</th><th class="confluenceTh">Common Layer Pipe</th><th class="confluenceTh">PAM Pipe </th><th class="confluenceTh">Context Pipe Level</th><th colspan="1" class="confluenceTh">Queues</th><th class="confluenceTh">SMI Layer Pipe</th><th class="confluenceTh">ATP Layer Pipe</th></tr><tr><td class="confluenceTd">Request</td><td class="confluenceTd"><p>0 - Adds No Cycles</p><p>1 - if pF adds a cycle when not loaded</p><p>1 - if pB adds a cycle when loaded</p><p>2 - Adds 1 Cycle</p></td><td class="confluenceTd"><p>0 - Adds No Cycles</p><p>1 - if pF adds a cycle when not loaded</p><p>1 - if pB adds a cycle when loaded</p><p>2 - Adds 1 Cycle</p></td><td class="confluenceTd">Adds pamPipePam amount of Cycles</td><td class="confluenceTd">Adds 1 Cycle</td><td colspan="1" class="confluenceTd"><p>If queueDepth &gt; 0</p><p>Adds 1 cycle. </p></td><td class="confluenceTd"><p>0 - Adds No Cycles</p><p>1 - if pF adds a cycle when not loaded</p><p>1 - if pB adds a cycle when loaded</p><p>2 - Adds 1 Cycle</p></td><td class="confluenceTd"><p>0 - Adds No Cycles</p><p>1 - if pF adds a cycle when not loaded</p><p>1 - if pB adds a cycle when loaded</p><p>2 - Adds 1 Cycle</p></td></tr><tr><td class="confluenceTd">Response</td><td class="confluenceTd"><p>0 - Adds No Cycles</p><p>1 - if pF adds a cycle when not loaded</p><p>1 - if pB adds a cycle when loaded</p><p>2 - Adds 1 Cycle</p></td><td class="confluenceTd"><p>0 - Adds No Cycles</p><p>1 - if pF adds a cycle when not loaded</p><p>1 - if pB adds a cycle when loaded</p><p>2 - Adds 1 Cycle</p></td><td class="highlight-grey confluenceTd" title="Background colour : undefined" data-highlight-colour="grey"><br/></td><td class="confluenceTd">Adds pamPipeCtxt amount of Cycles</td><td colspan="1" class="confluenceTd"><p>if nVc &gt; 1</p><p>Adds 1 cycle. </p></td><td class="confluenceTd"><p>0 - Adds No Cycles</p><p>1 - if pF adds a cycle when not loaded</p><p>1 - if pB adds a cycle when loaded</p><p>2 - Adds 1 Cycle</p></td><td class="confluenceTd"><p>0 - Adds No Cycles</p><p>1 - if pF adds a cycle when not loaded</p><p>1 - if pB adds a cycle when loaded</p><p>2 - Adds 1 Cycle</p></td></tr></tbody></table></div><h3 id="OBSOLETE-DELETEHW-SYMATUCommonCharacteristics-ATUTAXI/APBPipes">ATUT AXI/APB Pipes</h3><p>// SMI ATP pipe depth calculation<br/>// A depth of 1 is forced if ATP is lock-on-ready (retracting)<br/>var smiPipeLevelAtp = smiPktmstrLckStyleVld || pipeLevelAtp ? pipeLevelAtp : 1;</p><p>var forcedAtpPipe = smiPktmstrLckStyleVld || pipeLevelAtp ? false : true;</p><p>*** If forcedAtpPipe is <strong>false</strong> then the ATP stage is not taken into consideration for above algorithm. </p><p><br/>// Ctl Req pipe depth calculation<br/>// A depth of 1 is forced if target splitting is present<br/>ctlPipeReq = (ctlPipeReq==0 &amp;&amp; splittingRequired) ? 1 : ctlPipeReq;</p><p>var forcedCtlPipeReq = (ctlPipeReq==0 &amp;&amp; splittingRequired) ? true : false;</p><p>*** If forcedCtlPipeReq is <strong>true</strong> then the ATP stage is not taken into consideration for above algorithm. </p><p><br/></p><p>*** See above to determine if any stage is pipeForward or pipeBackward</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh"><br/></th><th class="confluenceTh">Native Layer Pipe</th><th class="confluenceTh">Common Layer Pipe</th><th class="confluenceTh">Context Pipe Level</th><th colspan="1" class="confluenceTh">Queues</th><th class="confluenceTh">SMI Layer Pipe</th><th class="confluenceTh">ATP Layer Pipe</th></tr><tr><td class="confluenceTd">Request</td><td class="confluenceTd"><p>0 - Adds No Cycles</p><p>1 - if pF adds a cycle when not loaded</p><p>1 - if pB adds a cycle when loaded</p><p>2 - Adds 1 Cycle</p></td><td class="confluenceTd"><p>0 - Adds No Cycles</p><p>1 - if pF adds a cycle when not loaded</p><p>1 - if pB adds a cycle when loaded</p><p>2 - Adds 1 Cycle</p></td><td class="confluenceTd">Adds 1 Cycle</td><td colspan="1" class="confluenceTd"><p>If queueDepth &gt; 0</p><p>Adds 1 cycle. </p></td><td class="confluenceTd"><p>0 - Adds No Cycles</p><p>1 - if pF adds a cycle when not loaded</p><p>1 - if pB adds a cycle when loaded</p><p>2 - Adds 1 Cycle</p></td><td class="confluenceTd"><p>0 - Adds No Cycles</p><p>1 - if pF adds a cycle when not loaded</p><p>1 - if pB adds a cycle when loaded</p><p>2 - Adds 1 Cycle</p></td></tr><tr><td class="confluenceTd">Response</td><td class="confluenceTd"><p>0 - Adds No Cycles</p><p>1 - if pF adds a cycle when not loaded</p><p>1 - if pB adds a cycle when loaded</p><p>2 - Adds 1 Cycle</p></td><td class="confluenceTd"><p>0 - Adds No Cycles</p><p>1 - if pF adds a cycle when not loaded</p><p>1 - if pB adds a cycle when loaded</p><p>2 - Adds 1 Cycle</p></td><td class="confluenceTd">Adds pamPipeCtxt amount of Cycles</td><td class="highlight-grey confluenceTd" title="Background colour : undefined" colspan="1" data-highlight-colour="grey"><br/></td><td class="confluenceTd"><p>0 - Adds No Cycles</p><p>1 - if pF adds a cycle when not loaded</p><p>1 - if pB adds a cycle when loaded</p><p>2 - Adds 1 Cycle</p></td><td class="confluenceTd"><p>0 - Adds No Cycles</p><p>1 - if pF adds a cycle when not loaded</p><p>1 - if pB adds a cycle when loaded</p><p>2 - Adds 1 Cycle</p></td></tr></tbody></table></div><p><br/></p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="1600" src="https://arterisip.atlassian.net/wiki/download/attachments/16166911/image2020-11-20_15-2-23.png?api=v2"></span></p><h2 id="OBSOLETE-DELETEHW-SYMATUCommonCharacteristics-Multicast">Multicast</h2><p>Multicast introduces a latency of 5 cycles: 2 introduced by depacketizer, 1 introduced by multicast core logic, 2 introduced by packetizer.</p><h1 id="OBSOLETE-DELETEHW-SYMATUCommonCharacteristics-LockonValidvs.LockonReady"><br/>Lock on Valid vs. Lock on Ready</h1><p>A network can be configured to bet lock on ready vs. lock on valid. When a network is configured lock on ready, it is retracting. Most of the standard interfaces we interact with are non-retracting interfaces and so the ATUs will need know when they are connected to a lock on valid vs. lock on ready network. This means the addition of a parameter with a similar to:</p><pre>  &quot;lckStyleValid&quot; : true or false,</pre><p>When a network is lock on valid, the ATU doesn't need to do anything.</p><p>When a network is lock on ready, the ATU must automatically put in at least one buffer along the path to grab and hold the incoming transaction from ATP to keep the native interface from retracting. For this situation, the ATU can automatically put in buffer can be pF = pB = false.</p><h1 id="OBSOLETE-DELETEHW-SYMATUCommonCharacteristics-CommonLayerGeneration">Common Layer Generation</h1><p>All ATUs must have their Common Transaction Layer interfaces constructed from the library function : generateCTLInterface(atuParameters,userLib)</p><p>This function takes in the ATUs parameters plus the userLib object and returns the following object:</p><p>{</p><p>   ctlReqInterface : </p><p>      {<br/>           &quot;name&quot; : &quot;ctl_req_&quot;,<br/>           &quot;params&quot; : ctl_req_params,<br/>           &quot;direction&quot; : &quot;slave&quot;,<br/>           &quot;interface&quot; : &quot;InterfaceCTL&quot;<br/>       }, </p><p>   ctlRespInterface : </p><p>      {<br/>           &quot;name&quot; : &quot;ctl_req_&quot;,<br/>           &quot;params&quot; : ctl_resp_params,<br/>           &quot;direction&quot; : &quot;master&quot;,<br/>           &quot;interface&quot; : &quot;InterfaceCTL&quot;<br/>       }</p><p>}</p><p>Example use case (Note only parameters needed by its native layer function are added):</p><p>// Generate CTL Interface<br/>var atutParameters = {};<br/>atutParameters.interfaces = interfaces;<br/>atutParameters.nativeToCommon = nativeToCommon;<br/>atutParameters.commonToNative = commonToNative;<br/>atutParameters.readInterleaveSupported = readInterleaveSupported;</p><p>var generatedCtlInterface = utilFunctions.generateCTLInterface(atutParameters,utilFunctions);</p><p>axiLayerInterfaces[&quot;ctlReqInterface&quot;]   = generatedCtlInterface.ctlReqInterface;<br/>axiLayerInterfaces[&quot;ctlRespInterface&quot;] = generatedCtlInterface.ctlRespInterface;</p><p><br/></p>