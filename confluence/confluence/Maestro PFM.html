<h2 id="MaestroPFM-topIntroduction"><span class="confluence-anchor-link" id="MaestroPFM-top"><span class="confluence-anchor-link" id="top"></span></span>Introduction</h2><p>This document describes the initial finds of the Maestro second-generation Symphony Performance Model (pfm). The works remains in progress and the methodology presented remains an initial proof-of-concept.</p><p>Key features of the proposed performance model are:</p><ul><li>The simulation kernel is configured entirely at run time using a single JSON configuration file. This differs from prior models where a cumbersome and error prone pre-processing step is required to generate the source code for the simulation to then be compiled. The proposed approach can model Mesh, Omega, Clos, Butterfly and arbitrary topologies without recompilation.</li><li>The simulation kernel has no dependency on outside libraries; it is not SystemC nor TLM-based. By consequence of this, performance is very fast and source code debug is simplified.</li><li>Simulation semantics have been defined such that the main scheduler can model both synchronous and asynchronous (combinatorial) logic (as that found in a network of Flow-Through Switches.</li><li>The simulator can model delay through inter-switch channels. Channels can be modeled as simple delay pipes, stall pipes, or slip pipes based on end user requirements.</li><li>The model is targeted towards being cycle-accurate. Therefore, the model may be used either for the purpose of a performance model to enable design exploration, or for hardware validation.</li></ul><p>The performance model has been implemented using standard C++11 and is built CMake.</p><h2 id="MaestroPFM-Performance">Performance</h2><p>Performance has been a key concern from the outset. Simulation performance is very difficult to quantify as it is a strong function of topology and stimulus. As a baseline, using the 'basic.json' 4 initiator, 2 switch, 4 target topology, the simulator achieves ~200kPHITS/sec on a low-end Intel(R) Core(TM) i5-4200U CPU @ 1.60GHz with 8GB RAM.</p><h2 id="MaestroPFM-Methodology">Methodology</h2><p>The design of the performance model has been motivated by three principle concerns:</p><ul><li>Accuracy</li><li>Flexibility to model arbitrary topologies without recompilation</li><li>Performance</li></ul><h3 id="MaestroPFM-Accuracy">Accuracy</h3><p>The model aims to be model the behavior of a given NOC topology to cycle-level accuracy. It does this by modelling individual Phits on a cycle-by-cycle basis. Presently, there is little hardware/RTL against which to compare, and to date, the majority of verification has been carried out by inspection of post-simulation log files.</p><h3 id="MaestroPFM-ArbitraryTopology">Arbitrary Topology</h3><p>Simulation runs are described entirely using a JSON configuration file input. This configuration file describes all simulation parameters in addition to the topology to be simulated. An NOC topology is described as a set of edges and nodes. Each node represents a 'steppable' entity and describes things like switches, channel, initiators and targets. Each simulation entity derived from a common 'node' baseline that is used by the simulator to step and update state during simulation. Importantly, the means by which each node is stepped is standardized. The format of data communicated between nodes is standardized along with the semantics governing flow-control. By reading the configuration file, it is possible to construct and stitch together arbitrary nodes to form any arbitrary topology. By consequence of the common semantics of each node, it is possible to step update all node state in a standardized manner at reasonable levels of complexity. </p><h3 id="MaestroPFM-Performance.1">Performance</h3><p>High levels of performance is achieved by minimizing the amount of state that must be modified and/or copied on each cycle. State is communicated across nodes using a standardized Token data structure. A Token is a 64b integer consisting of bit fields to encoding important and commonly used state. A Token roughly corresponds to a PHIT in hardware. All secondary state associated with the Token is maintained in a secondary table that is static throughout the duration of the simulation to avoid copying. The use of Tokens enables the occupancy of each state in the model to be efficiently queried using fast logical operations. In addition, the Token has been specifically sized to fit within a single CPU register allowing for it to be copied trivially through Nodes as the Phit progresses through the model.</p><h2 id="MaestroPFM-ConfigurationFormat">Configuration Format</h2><p>The configuration file controls all aspects of the simulation.</p><p>The configuration file consists of three main sections:</p><ul><li>Globals<ul><li>Maintains the set of parameters that control the overall behavior of the model (the number of cycles to simulate, what to call generated trace files, etc...). </li></ul></li><li>Edges<ul><li>The 'edge' field maintains an array of ordered pairs denoting all edges in the topology. The 0th entry denotes the source port, the 1st entry denotes the destination port. The order in which edges are defined is irrelevant however the ordering of ports within each tuple is important. </li></ul></li><li>Vertices<ul><li>The 'vertices' field maintains an array of JSON objects that denote each node in the topology. Each node is defined by a globally unique integer ID which is used for the purpose of elaboration and routing (a name field is also present, however this exists simply for the purpose of tracing and log file generation).</li></ul></li></ul><p>NOTE: This definition of the configuration file is incomplete and very rough. It is presented only until a canonical definition for the Symphony data model arrives. This format <em><strong>should not</strong> </em>be used for the purpose of development outside of this work.</p><p>An example configuration (corresponding to the 1i_to_4t topology) is presented below (incomplete):</p><pre>{<br/> &quot;dotfile&quot; : &quot;graph.dot&quot;,<br/> &quot;cfgfile&quot; : &quot;cfgdump.json&quot;,<br/> &quot;cycles&quot; : 100000,<br/> &quot;edges&quot; : [<br/>   [&quot;i0&quot;, &quot;sw0.0&quot;],<br/>   [&quot;sw0.0&quot;, &quot;sw1.0&quot;],<br/>   [&quot;sw0.1&quot;, &quot;sw2.0&quot;],<br/>   [&quot;sw1.0&quot;, &quot;t0&quot;],<br/>   [&quot;sw1.1&quot;, &quot;t1&quot;],<br/>   [&quot;sw2.0&quot;, &quot;t2&quot;],<br/>   [&quot;sw2.1&quot;, &quot;t3&quot;]<br/> ],<br/> &quot;vertices&quot; : [<br/>   { &quot;type&quot; : &quot;traffic_generator&quot;,<br/>     &quot;name&quot; : &quot;i0&quot;,<br/>     &quot;subtype&quot; : &quot;trace&quot;,<br/>     &quot;id&quot; : 0,<br/>     &quot;trace&quot; : true,<br/>     &quot;opts&quot;: {<br/>       &quot;filename&quot; : &quot;1i_to_4t.bin&quot;,<br/>       &quot;rsp_id&quot; : 7<br/>     }<br/> },<br/> { &quot;type&quot; : &quot;switch&quot;,<br/>   &quot;name&quot; : &quot;sw0&quot;,<br/>   &quot;subtype&quot; : &quot;ft&quot;,<br/>   &quot;id&quot; : 1,<br/>   &quot;m&quot; : 1,<br/>   &quot;n&quot; : 2,<br/>   &quot;opts&quot; : {<br/>   &quot;egress_arbs&quot; : [<br/>      {<br/>        &quot;type&quot; : &quot;round_robin&quot;,<br/>        &quot;m&quot; : 1<br/>      },<br/>      {<br/>        &quot;type&quot; : &quot;round_robin&quot;,<br/>        &quot;m&quot; : 1<br/>      }<br/>    ],<br/>    &quot;routes&quot; : [<br/>      [ 4, 5 ],<br/>      [ 6, 7 ]<br/>    ]<br/>  }<br/> },<br/> ...<br/> { &quot;type&quot; : &quot;traffic_sink&quot;,<br/>   &quot;name&quot; : &quot;t3&quot;,<br/>   &quot;subtype&quot; : &quot;simple&quot;,<br/>   &quot;trace&quot; : true,<br/>   &quot;id&quot; : 7<br/> }<br/> ]<br/>}</pre><h2 id="MaestroPFM-ExistingNodeModels">Existing Node Models</h2><p>The following node models exist:</p><h3 id="MaestroPFM-Switches">Switches</h3><h4 id="MaestroPFM-Discussion">Discussion</h4><p>TBD</p><h4 id="MaestroPFM-RoutingandConfiguration">Routing and Configuration</h4><p>All Switch node styles may have an arbitrary number of ingress and egress ports. The arbitration and allocation policies are configurable (although at present only static round robin and separable-allocation policies are implemented). Routing across switches is performed statically and cannot be changed post-elaboration. Each Switch configuration maintains a &quot;ID list&quot; for each egress port. Such &quot;ID list&quot; denotes the set of nodes (identified by node ID) to which a Flit should be allocated. The same node ID may be present at multiple egress ports although this is presently untested.</p><p>Care must be taken to ensure that the Switch routing style is appropriately configured. Head of line block will occur on an ingress port in cases where a Flit cannot be routed to an appropriate egress port. In the future, debug code to detect this condition may be added (with some additional overhead) however at present the input configuration and stimulus is required to be well-formed. </p><h4 id="MaestroPFM-Flow-ThroughSwitch(&quot;ft&quot;)">Flow-Through Switch (&quot;ft&quot;)</h4><p>The Flow-Through &quot;ft&quot; switch models the standard flow-through switch architecture. Input ports are switched to output port combinatorially. Presently, Flits are allocated to egress ports using a standard round-robin arbiter. Egress ports remain allocated for the entire duration of a Flit and are not reallocated at the Phit-level.</p><h4 id="MaestroPFM-BufferedFlow-ThroughSwitch(&quot;buffered_ft&quot;)">Buffered Flow-Through Switch (&quot;buffered_ft&quot;)</h4><p>The Buffered-Flow Through switch style is a variation of the standard FT approach where each ingress port has its own dedicated queue. Consequently, the minimum latency through the switch is now equal to or greater than one cycle. Individual queue depths may be set during configuration however are bounded and finite. When individual ingress switches become full, upstream nodes are appropriately back pressured.</p><h4 id="MaestroPFM-VC-EnabledFlow-ThroughSwitch(&quot;vc_ft&quot;)">VC-Enabled Flow-Through Switch (&quot;vc_ft&quot;)</h4><p>The VC-Enabled Flow Through Switch node style extends the standard buffered_ft node such that each ingress port has multiple VC queues. The vc_ft style obeys the &quot;input-first&quot; separable allocation whereby a round robin arbiter is present at each ingress port to select between VC, and each egress port allocated based upon the winners of the first round. Allocation is fully combinatorial, therefore the minimum latency through the switch is equal to that of an individual VC queue; one cycle. As before, egress ports are allocated at a Flit granularity and interleaving at the Phit-level does not occur.</p><h3 id="MaestroPFM-Channel">Channel</h3><h4 id="MaestroPFM-Discussion.1">Discussion</h4><p>&quot;Channels&quot; are the basic interconnect node sthat model delay between entities. They are optional and are not required for the purpose of connecting two switches back-to-back.</p><h4 id="MaestroPFM-Configuration">Configuration</h4><p>Channels are configured entirely on the length of the pipe. Stall semantics of pipes cannot be configured and are instead intrinsic to the node type configured.</p><h4 id="MaestroPFM-DelayPipe">Delay Pipe</h4><p>The Delay Pipe Node models the interconnect latency between nodes in a topology. For a given delay pipe node, Tokens entering the node are guaranteed to exit the node after some fixed cycle delay. As tokens cannot be stalled within the channel, higher level  logic between producing and consuming node must be used to mediate flow-control. In the case of an error, where a Token is lost at the egress port, the simulation will immediately terminate.</p><h4 id="MaestroPFM-StallPipe">Stall Pipe</h4><p>The Stall Pipe Node models a standard pipeline channel with fully combinatorial stall path upstream from consumer to producer. Minimum latency through the pipe is equal to the number of stages. Back pressure is asserted based upon occupancy of each stage of the pipeline. The stall path is broken by invalid pipeline stages.</p><h4 id="MaestroPFM-SlipPipe">Slip Pipe</h4><p>The Slip Pipe Node models a slip/double-buffer pipeline style. The minimum latency from producer to consumer nodes is at least the number of stages of the pipeline. Behavior of the node differs from the Stall Pipe as each stage is double-buffered. </p><h4 id="MaestroPFM-QueuePipe">Queue Pipe</h4><p>The Queue Pipe Node models a fictitious (unrealizable) First-In First-Out Queue data structure. It is presented for completeness. The queue model has finite capacity and shall back pressure the producer node when full. Latency through the queue is at least one-cycle.</p><h3 id="MaestroPFM-Initiators">Initiators</h3><h4 id="MaestroPFM-Randomized">Randomized</h4><h4 id="MaestroPFM-TraceDriven">Trace Driven</h4><h4 id="MaestroPFM-Targets">Targets</h4><p><br/></p><h2 id="MaestroPFM-TraceFormat">Trace Format</h2><p>A rudimentary trace format has been implemented to control traffic generation. Each line in the trace file denotes an individual transaction is emitted (subject to flow control) by an initiator. Each line is prefixed by a either an absolute or relative cycle time (denoted by '@' or '+') to denote the cycle at which the transaction may be emitted. This cycle time denotes the lower bound on the cycle at which data may be emitted. Transactions may indeed be emitted after the desired cycle subject to downstream flow control. Each transaction consists of a number of comma separated key/value pairs. At present, only two pairs have been implemented, PHITS, denoting the number of PHITS to emit, and TGT_ID denoting the Node ID of the destination.</p><h3 id="MaestroPFM-ExampleTrace">Example Trace</h3><p>@1:PHITS=1,TGT_ID=4<br/>+1:PHITS=1,TGT_ID=4<br/>+1:PHITS=1,TGT_ID=4<br/>+1:PHITS=1,TGT_ID=4<br/>+1:PHITS=1,TGT_ID=4<br/>+1:PHITS=1,TGT_ID=4<br/>+1:PHITS=1,TGT_ID=4<br/>+1:PHITS=1,TGT_ID=4</p><p><br/></p><p><br/></p><h3 id="MaestroPFM-Compiler/DecompilerUtilities">Compiler/Decompiler Utilities</h3><p>Text formats are human readable however they are not ideally suited for fast simulation. Text traces must be converted to a corresponding optimized binary format using the 'tcom' (trace compiler) utility before they can be used in the simulator. The corresponding 'tdcom' (trace de-compiler) utility is present to convert the binary format back to the text format.</p><h2 id="MaestroPFM-Methodology.1">Methodology</h2><h2 id="MaestroPFM-ExampleTopologies">Example Topologies</h2><p>NOTE: Each Topology is generated using the &quot;dot&quot; graphing language. Graphs are generated by traversing the internally generated graph in simulation memory. An unfortunate consequence of this is that 'dot' has little understanding how to best render such topologies. The performance figures however remain unchanged.  Suggestions are welcome.</p><h3 id="MaestroPFM-1i_to_4t.json">1i_to_4t.json</h3><p>Configuration modelling a simple 1 initiator 4 target topology using Flow-Through switches. Test configuration to model the behavior of back-to-back switches, associated flow control, and routing across switches.</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="https://arterisip.atlassian.net/wiki/download/attachments/16170209/1i_to_4t.svg.png?api=v2"></span></p><h3 id="MaestroPFM-2i_to_2t.json">2i_to_2t.json</h3><p>Configuration modelling simple 2 initiator, 2 target topology using a single Flow-Through switch. Test configuration to demonstrate the absence of contention/serialization when initiator nodes are addressing independent egress nodes.</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16170209/2i_to_2t.png?api=v2"></span></p><h3 id="MaestroPFM-4i_to_1t.json">4i_to_1t.json</h3><p>Configuration modelling simple 4 initiator to 1 target topology. Test configuration to demonstrate arbitration across ingress ports across multiple Flow-Through switches.</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="https://arterisip.atlassian.net/wiki/download/attachments/16170209/4i_to_1t.png?api=v2"></span></p><h3 id="MaestroPFM-basic.json">basic.json</h3><p>Canonical configuration modelling request and response networks for a 4 initiator and 4 target arbitrary topology. Configuration implements various Channel nodes as a proof of concept and has ATUI CMD and RESP nodes to model ATU behavior (although these are simply pass through at the moment and do impact behavior).</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="https://arterisip.atlassian.net/wiki/download/attachments/16170209/basic.png?api=v2"></span></p><h3 id="MaestroPFM-bf2ary3fly.json">bf2ary3fly.json</h3><p>A configuration modelling a 2-ary, 3-fly Butterfly topology using Flow-Through switches.</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16170209/bf2ary3fly.png?api=v2"></span></p><h3 id="MaestroPFM-channel_delaypipe.json">channel_delaypipe.json</h3><p>Test configuration modelling delay/latency behavior of Delay Pipe Channel.</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16170209/channel_delaypipe.png?api=v2"></span></p><h3 id="MaestroPFM-channel_queue.json">channel_queue.json</h3><p>Test configuration modelling delay/latency behavior of Queue Channel.</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16170209/channel_queue.png?api=v2"></span></p><h3 id="MaestroPFM-channel_slippipe.json">channel_slippipe.json</h3><p>Test configuration modelling delay/latency behavior of Slip Pipe Channel.</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16170209/channel_slippipe.png?api=v2"></span></p><h3 id="MaestroPFM-channel_stallpipe.json">channel_stallpipe.json</h3><p>Test configuration modelling delay/latency behavior of Stall Pipe Channel.</p><h3 id="MaestroPFM-clos_m3n3r4.json">clos_m3n3r4.json</h3><p>A configuration modelling a standard CLOS(3, 3, 4) topology using Flow-Through switches.</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16170209/clos_m3n3r4.png?api=v2"></span></p><h3 id="MaestroPFM-mesh4.json">mesh4.json</h3><p>A configuration modelling a 2x2 mesh using buffered Flow-Through switches. Each switch has one initiator and one target. Traffic is routed along shortest path for adjacent nodes, clockwise for nodes 0 and 3, counter-clockwise for nodes 1 and 2.</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16170209/mesh4.png?api=v2"></span></p><h3 id="MaestroPFM-omega_8x8_2x2.json">omega_8x8_2x2.json</h3><p>A configuration modelling a 8x8 Omega network using 2x2 Flow-Through switches.</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16170209/omega_8x8_2x2.png?api=v2"></span></p><h2 id="MaestroPFM-Usage:">Usage:</h2><p>PFM can be found at: <a href="ssh://stash.arteris.com:7999/maes/pfm.git" rel="nofollow">ssh://stash.arteris.com:7999/maes/pfm.git</a></p><p>PFM requires g++ &gt;= 3.9, CMake &gt;= 3.7 and Conan.</p><p>PFM can be built as following:</p><pre>  &gt; git clone <a href="ssh://stash.arteris.com:7999/maes/pfm.git" rel="nofollow">ssh://stash.arteris.com:7999/maes/pfm.git</a> </pre><pre>  &gt; pushd pfm</pre><pre>  &gt; mkdir build</pre><pre>  &gt; pushd build</pre><pre>  &gt; conan install ..</pre><pre>  &gt; cmake ..</pre><pre>  &gt; make -j</pre><p>A simulation of the 'basic' configuration can be initiated using:</p><pre>  &gt; make basic</pre><p>A complete regression of all configuration can be initiated using</p><pre>  &gt; make run_all</pre><pre><br/></pre><p>In this example, the mesh4 configuration is used. This topology consists of 4 initiators and 4 targets connected using 4 buffered FT switches in a 2x2 mesh configuration. Initiators are denoted by the suffix 'i', targets by 't', switches by 'sw' and sinks by 's'. All traffic originates from initiator i0 and is sent to t0. Notably, i0 and t0 belong to the same Switch and therefore no inter-Switch routing is necessary. Individual Phits are emitted by i0 at 1 cycle intervals and return after 4 cycles of latency.</p><p><br/></p><p>This example can be run from &quot;cfgs/mesh4&quot; in the build directory using the command: make mesh4</p><p>(Note: tracing is optional here and may be enabled/disabled on a node-by-node basis).</p><p><br/></p><pre>2017-08-22 15:27:34,932 INFO [default] Debug build enabled<br/>Schedule = [ i0 t0 i2 t2 i3 t3 i1 t1 sw1 sw3 sw2 sw0 s0 s1 s2 s3]<br/>[1]{i0}:Emit PHIT: {&quot;dst_id&quot;:4,&quot;id&quot;:127,&quot;valid&quot;:true,&quot;vc&quot;:0} <br/>[2]{sw0}:Arbitration successful in= 0 out= 1 <br/>[2]{i0}:Emit PHIT: {&quot;dst_id&quot;:4,&quot;id&quot;:126,&quot;valid&quot;:true,&quot;vc&quot;:0} <br/>[3]{sw0}:Arbitration successful in= 0 out= 1 <br/>[3]{i0}:Emit PHIT: {&quot;dst_id&quot;:4,&quot;id&quot;:125,&quot;valid&quot;:true,&quot;vc&quot;:0} <br/>[3]{t0}:Consumed Phit: {&quot;dst_id&quot;:4,&quot;id&quot;:127,&quot;valid&quot;:true,&quot;vc&quot;:0} <br/>[3]{t0}:Emitted Phit: {&quot;dst_id&quot;:12,&quot;id&quot;:127,&quot;valid&quot;:true,&quot;vc&quot;:0} <br/>[4]{sw0}:Arbitration successful in= 1 out= 0 <br/>[4]{sw0}:Arbitration successful in= 0 out= 1 <br/>[4]{i0}:Emit PHIT: {&quot;dst_id&quot;:4,&quot;id&quot;:124,&quot;valid&quot;:true,&quot;vc&quot;:0} <br/>[4]{t0}:Consumed Phit: {&quot;dst_id&quot;:4,&quot;id&quot;:126,&quot;valid&quot;:true,&quot;vc&quot;:0} <br/>[4]{t0}:Emitted Phit: {&quot;dst_id&quot;:12,&quot;id&quot;:126,&quot;valid&quot;:true,&quot;vc&quot;:0} <br/>[5]{sw0}:Arbitration successful in= 1 out= 0 <br/>[5]{sw0}:Arbitration successful in= 0 out= 1 <br/>[5]{i0}:Emit PHIT: {&quot;dst_id&quot;:4,&quot;id&quot;:123,&quot;valid&quot;:true,&quot;vc&quot;:0} <br/>[5]{t0}:Consumed Phit: {&quot;dst_id&quot;:4,&quot;id&quot;:125,&quot;valid&quot;:true,&quot;vc&quot;:0} <br/>[5]{t0}:Emitted Phit: {&quot;dst_id&quot;:12,&quot;id&quot;:125,&quot;valid&quot;:true,&quot;vc&quot;:0} <br/>[5]{s0}:Consume PHIT: {&quot;dst_id&quot;:12,&quot;id&quot;:127,&quot;valid&quot;:true,&quot;vc&quot;:0} <br/>[6]{sw0}:Arbitration successful in= 1 out= 0 <br/>[6]{sw0}:Arbitration successful in= 0 out= 1 <br/>[6]{i0}:Emit PHIT: {&quot;dst_id&quot;:4,&quot;id&quot;:127,&quot;valid&quot;:true,&quot;vc&quot;:0} <br/>[6]{t0}:Consumed Phit: {&quot;dst_id&quot;:4,&quot;id&quot;:124,&quot;valid&quot;:true,&quot;vc&quot;:0} <br/>[6]{t0}:Emitted Phit: {&quot;dst_id&quot;:12,&quot;id&quot;:124,&quot;valid&quot;:true,&quot;vc&quot;:0} <br/>[6]{s0}:Consume PHIT: {&quot;dst_id&quot;:12,&quot;id&quot;:126,&quot;valid&quot;:true,&quot;vc&quot;:0} <br/>[7]{sw0}:Arbitration successful in= 1 out= 0 <br/>[7]{sw0}:Arbitration successful in= 0 out= 1 <br/>[7]{i0}:Emit PHIT: {&quot;dst_id&quot;:4,&quot;id&quot;:126,&quot;valid&quot;:true,&quot;vc&quot;:0} <br/>[7]{t0}:Consumed Phit: {&quot;dst_id&quot;:4,&quot;id&quot;:123,&quot;valid&quot;:true,&quot;vc&quot;:0} <br/>[7]{t0}:Emitted Phit: {&quot;dst_id&quot;:12,&quot;id&quot;:123,&quot;valid&quot;:true,&quot;vc&quot;:0} <br/>[7]{s0}:Consume PHIT: {&quot;dst_id&quot;:12,&quot;id&quot;:125,&quot;valid&quot;:true,&quot;vc&quot;:0} <br/>[8]{sw0}:Arbitration successful in= 1 out= 0 <br/>[8]{sw0}:Arbitration successful in= 0 out= 1 <br/>[8]{i0}:Emit PHIT: {&quot;dst_id&quot;:4,&quot;id&quot;:125,&quot;valid&quot;:true,&quot;vc&quot;:0} <br/>[8]{t0}:Consumed Phit: {&quot;dst_id&quot;:4,&quot;id&quot;:127,&quot;valid&quot;:true,&quot;vc&quot;:0} <br/>[8]{t0}:Emitted Phit: {&quot;dst_id&quot;:12,&quot;id&quot;:127,&quot;valid&quot;:true,&quot;vc&quot;:0} <br/>[8]{s0}:Consume PHIT: {&quot;dst_id&quot;:12,&quot;id&quot;:124,&quot;valid&quot;:true,&quot;vc&quot;:0} <br/>[9]{sw0}:Arbitration successful in= 1 out= 0 <br/>[9]{sw0}:Arbitration successful in= 0 out= 1 <br/>[9]{i0}:Emit PHIT: {&quot;dst_id&quot;:4,&quot;id&quot;:124,&quot;valid&quot;:true,&quot;vc&quot;:0} <br/>[9]{t0}:Consumed Phit: {&quot;dst_id&quot;:4,&quot;id&quot;:126,&quot;valid&quot;:true,&quot;vc&quot;:0} <br/>[9]{t0}:Emitted Phit: {&quot;dst_id&quot;:12,&quot;id&quot;:126,&quot;valid&quot;:true,&quot;vc&quot;:0} <br/>[9]{s0}:Consume PHIT: {&quot;dst_id&quot;:12,&quot;id&quot;:123,&quot;valid&quot;:true,&quot;vc&quot;:0} <br/>[10]{sw0}:Arbitration successful in= 1 out= 0</pre><pre>...</pre><pre>[12]{s0}:Consume PHIT: {&quot;dst_id&quot;:12,&quot;id&quot;:125,&quot;valid&quot;:true,&quot;vc&quot;:0} <br/>[13]{s0}:Consume PHIT: {&quot;dst_id&quot;:12,&quot;id&quot;:124,&quot;valid&quot;:true,&quot;vc&quot;:0} <br/>sw1 EOS Report:<br/>sw1: Ingress Queue = 0(8)<br/>sw1: Ingress Queue = 0(8)<br/>sw1: Ingress Queue = 0(8)<br/>sw1: Ingress Queue = 0(8)<br/>sw3 EOS Report:<br/>sw3: Ingress Queue = 0(8)<br/>sw3: Ingress Queue = 0(8)<br/>sw3: Ingress Queue = 0(8)<br/>sw3: Ingress Queue = 0(8)<br/>sw2 EOS Report:<br/>sw2: Ingress Queue = 0(8)<br/>sw2: Ingress Queue = 0(8)<br/>sw2: Ingress Queue = 0(8)<br/>sw2: Ingress Queue = 0(8)<br/>sw0 EOS Report:<br/>sw0: Ingress Queue = 0(8)<br/>sw0: Ingress Queue = 0(8)<br/>sw0: Ingress Queue = 0(8)<br/>sw0: Ingress Queue = 0(8)<br/>All FLIT/PHITS idle at end of simulation. <br/>Report latencies:<br/>0 0<br/>1 0<br/>2 0<br/>3 0<br/>4 9<br/>Phit count=9</pre><h2 id="MaestroPFM-FrequentlyAskedQuestions(FAQ)">Frequently Asked Questions (FAQ)</h2><h3 id="MaestroPFM-Howaccurateisthismodel?">How accurate is this model?</h3><p>With the absence of an RTL golden reference model, it is very hard to tell. For simple topologies and for simplistic stimulus, validation has been done by manual inspection of the resultant trace files. Beyond that, has complexity increases it becomes very difficult to know for certain. Initial results are promising.</p><h3 id="MaestroPFM-Tellmeabouttheconfigurationfileformat?">Tell me about the configuration file format?</h3><p>Symphony will eventually have its own project description format (most likely in JSON). To date, this remains to be defined by the architects. The current configuration file format represents an initial stake in the ground of what one would expect the final project format to look like.</p><p><br/></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16170209/Maestro+PFM#MaestroPFM-top">Back to top</a> </p><p><br/></p>