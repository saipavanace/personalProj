<h1 id="PerformanceCounter(includingBW,Latency,andMultiported)-8.0Perfcounter"><strong>8.0 Perf counter</strong></h1><style type='text/css'>/*<![CDATA[*/
div.rbtoc1759724821745 {padding: 0px;}
div.rbtoc1759724821745 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1759724821745 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class='toc-macro rbtoc1759724821745'>
<ul class='toc-indentation'>
<li><a href='#PerformanceCounter(includingBW,Latency,andMultiported)-8.0Perfcounter'>8.0 Perf counter</a>
<ul class='toc-indentation'>
<li><a href='#PerformanceCounter(includingBW,Latency,andMultiported)-8.1PMONuArchitecture'>8.1 PMON uArchitecture</a></li>
<li><a href='#PerformanceCounter(includingBW,Latency,andMultiported)-8.2Latencycounter'>8.2 Latency counter</a>
<ul class='toc-indentation'>
<li><a href='#PerformanceCounter(includingBW,Latency,andMultiported)-8.2.1Latencycounterdesign'>8.2.1 Latency counter design</a></li>
<li><a href='#PerformanceCounter(includingBW,Latency,andMultiported)-8.2.2Latencycounterverificationstrategy'>8.2.2 Latency counter verification strategy</a></li>
</ul>
</li>
<li><a href='#PerformanceCounter(includingBW,Latency,andMultiported)-8.3Bandwidthcountersdesign'>8.3 Bandwidth counters design</a>
<ul class='toc-indentation'>
<li><a href='#PerformanceCounter(includingBW,Latency,andMultiported)-8.3.1Bandwidthcountersdesign'>8.3.1 Bandwidth counters design</a></li>
</ul>
</li>
<li><a href='#PerformanceCounter(includingBW,Latency,andMultiported)-8.4PerfcountertestPlan'>8.4 Perf counter testPlan</a>
<ul class='toc-indentation'>
<li><a href='#PerformanceCounter(includingBW,Latency,andMultiported)-8.4.1PerfcounterStimulus'>8.4.1 Perf counter Stimulus</a></li>
<li><a href='#PerformanceCounter(includingBW,Latency,andMultiported)-Stimulus'>Stimulus</a></li>
<li><a href='#PerformanceCounter(includingBW,Latency,andMultiported)-8.4.2Perfcounterchecking'>8.4.2 Perf counter checking</a></li>
<li><a href='#PerformanceCounter(includingBW,Latency,andMultiported)-FunctionalChecks'>Functional Checks</a></li>
<li><a href='#PerformanceCounter(includingBW,Latency,andMultiported)-8.4.3Perfcounterfunctionalcoverage:'>8.4.3 Perf counter functional coverage :</a></li>
<li><a href='#PerformanceCounter(includingBW,Latency,andMultiported)-Functionalcoverage:'>Functional coverage :</a></li>
<li><a href='#PerformanceCounter(includingBW,Latency,andMultiported)-8.4.4Perfcounterdocuments:'>8.4.4 Perf counter documents :</a></li>
<li><a href='#PerformanceCounter(includingBW,Latency,andMultiported)-PerfcounterReferences'>Perf counter References</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div><p>For 3.4, the IOAIU strategy is to reuse all the 3.2 testing, and add testing with both bringup tests and random tests for the following new 3.4 features:</p><p style="margin-left: 30.0px;">latency</p><p style="margin-left: 30.0px;">bandwidth events</p><p style="margin-left: 30.0px;">multiported IOAIU</p><p>The checking is done by the PMON verification library that was integrated in 3.4, both for the latency code and bandwidth code.</p><p>After integrating the PMON verification library, there will be a bringup test and a random test added for both latency counters and bandwidth counters and filtering.</p><p>These new tests will be run on each AIU type of single core IOAIU config: ace, ace_lite, ace_lite_e, axi, and axi_proxy, as well as multi-ported configs.</p><h2 id="PerformanceCounter(includingBW,Latency,andMultiported)-8.1PMONuArchitecture"><strong>8.1 PMON uArchitecture</strong></h2><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" src="https://arterisip.atlassian.net/wiki/download/attachments/60555703/image2022-5-3_11-48-48.png%3Fversion=1&amp;modificationDate=1661292266791&amp;cacheVersion=1&amp;api=v2?api=v2"></span><h2 id="PerformanceCounter(includingBW,Latency,andMultiported)-8.2Latencycounter"><strong>8.2 Latency counter</strong></h2><h3 id="PerformanceCounter(includingBW,Latency,andMultiported)-8.2.1Latencycounterdesign"><strong>8.2.1 Latency counter design</strong></h3><p>Ncore provides latency counters IOAIU for either reads or writes. Latency is reported back as a binned histogram. The latency reported at IOAIUAIUs is from Ncore system perspective, the complete lifetime of the transaction within Ncore.</p><p>When transaction is ready to be issued on the Native interface, it is allocated to the latency counter table.</p><p>The ID represents the transaction table (OTT/WTT/RTT) ID and counter is a 9-bit counter. The counter is started as soon as the entry is allocated. If all entries within the latency counter table are taken, then any new qualified transaction just does not participate in the latency histogram.</p><p>The counter increments every 2, 4, 8 or 16 clock cycle based on CSR configuration. If the counter hits its max value, then it stays saturated until deallocation and the saturated value is used for latency histogram binning.</p><p>The latency counter table is deallocated at approximately the same time corresponding response is received from the native interface. The deallocated entry counter value is then subtracted by the configured 8-bit offset, if the offset corrected value is negative then it is saturated downwards to zero. The quantizer takes the offset corrected value and increment appropriate histogram bin.</p><p /><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" src="https://arterisip.atlassian.net/wiki/download/attachments/60555703/image2022-4-26_14-43-56.png%3Fversion=2&amp;modificationDate=1661292488044&amp;cacheVersion=1&amp;api=v2?api=v2"></span><h3 id="PerformanceCounter(includingBW,Latency,andMultiported)-8.2.2Latencycounterverificationstrategy"><strong>8.2.2 Latency counter verification strategy</strong></h3><p>The latency table verification strategy consists of spying on the &quot;alloc_id&quot;, &quot;dealoc_id&quot;, &quot;alloc&quot; and &quot;dealloc&quot; signals with a latency spy interface.<br/>These signals will be the inputs of the latency counter scoreboard.</p><p /><p>Latency scoreboard predicts and generates the different histogram bins<br/>After that, Those bins will be sent to the Pmon scoreboard which will increment the appropriate bin and map each counting value to the correct register.<br/>The 8 registers are checked at the Pmon scoreboard level.</p><p /><p>In order to improve the quality of our verification and to be able to precisely identify and determine the location of any bugs, the latency table verification would be on two levels:</p><p>1 - The verification of the generation of the bins to detect a possible bug at the level of the latency counter table or offset logic  : we will spy the bins signals of design at the output of the quantizer and will be compared with the bins generated by latency counter scoreboard at the level of this scoreboard.<br/>2- Verification of the bins counting and mapping of values to the different registers at Pmon scoreboard level.</p><p /><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" src="https://arterisip.atlassian.net/wiki/download/attachments/60555703/image2022-4-29_17-33-43.png%3Fversion=1&amp;modificationDate=1661292579206&amp;cacheVersion=1&amp;api=v2?api=v2"></span><h2 id="PerformanceCounter(includingBW,Latency,andMultiported)-8.3Bandwidthcountersdesign"><strong>8.3 Bandwidth counters design</strong></h2><h3 id="PerformanceCounter(includingBW,Latency,andMultiported)-8.3.1Bandwidthcountersdesign"><strong>8.3.1 Bandwidth counters design</strong></h3><p /><p>Ncore provides IOAIU Bandwidth counters. These counters count in 64Byte data accuracy and at divided by 16 accuracies of the clock frequency.</p><p>BW counting can be filtered based on FunitID or user bits, this can be configured in CSRs xBCNTFR and xBCNTMR.</p><p>In IOAIU, the following can be counted: </p><ul><li><p>Read data bandwidth, this refers to data being read from IOAIU : CmdReq RD event</p></li></ul><ul><li><p>Write data bandwidth, this refers to data being written into IOAIU : CmdReq WR event</p></li></ul><ul><li><p>Snoop bandwidth, this refers to data being written into IOAIU : SnpRsp event</p></li></ul><p>The counter reports : </p><ul><li><p>xCNTSR: number of divide by 16 clock cycles</p></li><li><p>xCNTVR: number of 64Bytes of data.</p></li></ul><p>The above information can be used to calculate the effective BW. The counter must be disabled before reading them to get correct BW.<br/>Note that this will be approximate BW as all transactions that were counted may necessarily not be 64 bytes transactions and the time accuracy is divided by 16.</p><h2 id="PerformanceCounter(includingBW,Latency,andMultiported)-8.4PerfcountertestPlan"><strong>8.4 Perf counter testPlan</strong></h2><h3 id="PerformanceCounter(includingBW,Latency,andMultiported)-8.4.1PerfcounterStimulus"><strong>8.4.1 Perf counter Stimulus</strong></h3><h3 id="PerformanceCounter(includingBW,Latency,andMultiported)-Stimulus">Stimulus</h3><div class="table-wrap"><table data-layout="default" data-local-id="b34596c1-6cf8-4797-9e82-151afd6b3532" class="confluenceTable"><colgroup><col style="width: 85.0px;"/><col style="width: 85.0px;"/><col style="width: 85.0px;"/><col style="width: 85.0px;"/><col style="width: 85.0px;"/><col style="width: 85.0px;"/><col style="width: 85.0px;"/><col style="width: 85.0px;"/></colgroup><tbody><tr><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Scenario</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Hashtag</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Where</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Done</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Status</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Priority</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Ref Doc</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Comments</p></th></tr><tr><td class="confluenceTd"><p>Configuration sequence should set counter control filed to 32-bit counter mode and ssr count filed to 32-bit counter mode </p></td><td class="confluenceTd"><p>#Stimulus.IOAIU.Pmon.v3.4.XCNT32BIT</p></td><td rowspan="9" class="confluenceTd"><p /><p /><p /><p /><p /><p /><p><a class="external-link" href="http://perf_cnt_unit_cfg_seq.sv/" rel="nofollow">perf_cnt_unit_cfg_seq.sv</a></p><p><a class="external-link" href="http://perf_cnt_units.sv/" rel="nofollow">perf_cnt_units.sv</a></p></td><td class="confluenceTd"><p>N</p></td><td class="confluenceTd"><p>NA</p></td><td class="confluenceTd"><p>1</p></td><td rowspan="11" class="confluenceTd"><p>Ncore Concerto Perf Counter Specification<br/></p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>Configuration sequence should set xMCNTCR local count enable field to 1 to enable and 0 to disable all counter for one unit</p></td><td class="confluenceTd"><p>#Stimulus.IOAIU.Pmon.v3.4.LocalEnableDisable</p></td><td class="confluenceTd"><p>N</p></td><td class="confluenceTd"><p>NA</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>Configuration sequence should set xMCNTCR local count clear field to clear all counter</p></td><td class="confluenceTd"><p>#Stimulus.IOAIU.Pmon.v3.4.LocalClear</p></td><td class="confluenceTd"><p>N</p></td><td class="confluenceTd"><p>NA</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>1- Configuration sequence should set xCNTCR<br/>2 - Counters must be disabled before reading BW counter values<br/>3- Filter should be disabled on this testcase</p></td><td class="confluenceTd"><p>#<a class="external-link" href="http://Stimulus.Pmon.v3.4.Bw" rel="nofollow">Stimulus.Pmon.v3.4.Bw</a></p></td><td class="confluenceTd"><p>N</p></td><td class="confluenceTd"><p>NA</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>1- Configuration sequence should set xCNTCR<br/>2 - Counters must be disabled before reading BW counter values</p><p>3- Enabling BW filter and  configure xBCNTFR and xBCNTMR</p><p>4 - Fix xBCNTFR.filter_value to fixed Funit ID</p></td><td class="confluenceTd"><p>#Stimulus.IOAIU.Pmon.v3.4.BwFilterFixed</p></td><td class="confluenceTd"><p>N</p></td><td class="confluenceTd"><p>NA</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>1- Configuration sequence should set xCNTCR<br/>2 - Counters must be disabled before reading BW counter values</p><p>3- Enabling BW filter and  configure xBCNTFR and xBCNTMR</p><p>4- Configure xBCNTFR.filter_select to set filter Bw counting on Funit, else filter on userBits randomly</p><p>5 - generate xBCNTFR.filter_value with random Funit ID (or userbits) from IOAIU Funit (userbits) possible ranges </p></td><td class="confluenceTd"><p>#Stimulus.IOAIU.Pmon.v3.4.BwFilterRand</p></td><td class="confluenceTd"><p>N</p></td><td class="confluenceTd"><p>NA</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p><strong>Same as Scenario as Bw filter but we should configure event first as CmdReqWR event </strong></p></td><td class="confluenceTd"><p /></td><td class="confluenceTd"><p>N</p></td><td class="confluenceTd"><p>NA</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p><strong>Same as Scenario as Bw filter but we should configure event first as CmdReqRD event </strong></p></td><td class="confluenceTd"><p /></td><td class="confluenceTd"><p>N</p></td><td class="confluenceTd"><p>NA</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p><strong>Same as Scenario as Bw filter but we should configure event first as SnpRsp event, can only filter on Funit ID, cannot filter on userid</strong></p></td><td class="confluenceTd"><p /></td><td class="confluenceTd"><p>N</p></td><td class="confluenceTd"><p>NA</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>1- configure Counter control xCNTCR</p><ul><li><p>Counter control to 3b100 i.e., bit bin counter</p></li><li><p>SSR count to 3b100 i.e., 32 bit bin counter</p></li><li><p>Count first event is don’t care in this case</p></li><li><p>Count Second event is don’t care in this case</p></li></ul><p>2 - configure xLCNTCR with fixed values from ranges</p><ul><li><p>Latency pre scale = fixed value</p></li><li><p>Read/Write latency = fixed value</p></li><li><p>Latency bin offset = 0</p></li><li><p>Latency count enable = 1</p></li></ul><p /></td><td class="confluenceTd"><p>#Stimulus.IOAIU.Pmon.v3.4.LatencyFixed</p></td><td class="confluenceTd"><p><a class="external-link" href="http://perf_cnt_unit_cfg_seq.sv/" rel="nofollow">perf_cnt_unit_cfg_seq.sv</a></p><p><a class="external-link" href="http://perf_cnt_units.sv/" rel="nofollow">perf_cnt_units.sv</a></p></td><td class="confluenceTd"><p>N</p></td><td class="confluenceTd"><p>NA</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>Maybe adding specific sequence for Latency registers configuration</p></td></tr><tr><td class="confluenceTd"><p>1 - Generate random event first and event second<br/>2-  Generate random values from ranges to configure xLCNTCR fields</p></td><td class="confluenceTd"><p>#Stimulus.IOAIU.Pmon.v3.4.LatencyRand</p></td><td class="confluenceTd"><p><a class="external-link" href="http://perf_cnt_unit_cfg_seq.sv/" rel="nofollow">perf_cnt_unit_cfg_seq.sv</a></p><p><a class="external-link" href="http://perf_cnt_units.sv/" rel="nofollow">perf_cnt_units.sv</a></p></td><td class="confluenceTd"><p>N</p></td><td class="confluenceTd"><p>NA</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>Maybe adding specific sequence for Latency registers configuration</p></td></tr></tbody></table></div><h3 id="PerformanceCounter(includingBW,Latency,andMultiported)-8.4.2Perfcounterchecking"><strong>8.4.2 Perf counter checking</strong></h3><h3 id="PerformanceCounter(includingBW,Latency,andMultiported)-FunctionalChecks">Functional Checks</h3><div class="table-wrap"><table data-layout="default" data-local-id="79f62e09-c256-4e34-bd22-5735f8a5d551" class="confluenceTable"><colgroup><col style="width: 85.0px;"/><col style="width: 85.0px;"/><col style="width: 85.0px;"/><col style="width: 85.0px;"/><col style="width: 85.0px;"/><col style="width: 85.0px;"/><col style="width: 85.0px;"/><col style="width: 85.0px;"/></colgroup><tbody><tr><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Checks</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Hashtag</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Where</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Done</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Status</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Priority</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Ref Doc</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Comments</p></th></tr><tr><td class="confluenceTd"><p>Check that that XCNTVR have the correct value of event first event performance counting and XCNTSR have the correct value of second event performance counting</p></td><td class="confluenceTd"><p>#Check.IOAIU.Pmon.v3.4.XCNT32BIT</p></td><td rowspan="8" class="confluenceTd"><p /><p /><p /><p>perf_counters_scoreboard.svh</p><p /></td><td class="confluenceTd"><p>N</p></td><td class="confluenceTd"><p>NA</p></td><td class="confluenceTd"><p>1</p></td><td rowspan="9" class="confluenceTd"><p>Ncore Concerto Perf Counter Specification</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>Check that all perf mon counters registers are enabled or disabled</p></td><td class="confluenceTd"><p>#Check.IOAIU.Pmon.v3.4.LocalEnableDisable</p></td><td class="confluenceTd"><p>N</p></td><td class="confluenceTd"><p>NA</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>Check that all perf mon counters registers are cleared </p></td><td class="confluenceTd"><p>#Check.IOAIU.Pmon.v3.4.LocalClear</p></td><td class="confluenceTd"><p>N</p></td><td class="confluenceTd"><p>NA</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>Check that Bw counter functionality by validation of DtwReq event in IOAIU unit : Check xCNTSR and xCNTVR values</p></td><td class="confluenceTd"><p>#<a class="external-link" href="http://Check.Pmon.v3.4.Bw" rel="nofollow">Check.Pmon.v3.4.Bw</a></p></td><td class="confluenceTd"><p>N</p></td><td class="confluenceTd"><p>NA</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>Bw filter by enabling bw filter and validation of DtwReq event in IOAIU unit : Check xCNTSR and xCNTVR values</p></td><td class="confluenceTd"><p>#Check.IOAIU.Pmon.v3.4.BwFilter</p></td><td class="confluenceTd"><p>N</p></td><td class="confluenceTd"><p>NA</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p><strong>CmdReqWR event counting</strong></p></td><td class="confluenceTd"><p>#Check.IOAIU.Pmon.v3.4.CmdReqWr</p></td><td class="confluenceTd"><p>N</p></td><td class="confluenceTd"><p>NA</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p><strong>CmdReqRD event counting</strong></p></td><td class="confluenceTd"><p>#Check.IOAIU.Pmon.v3.4.CmdReqRd</p></td><td class="confluenceTd"><p>N</p></td><td class="confluenceTd"><p>NA</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p><strong>SnpRsp event counting</strong></p></td><td class="confluenceTd"><p>#Check.IOAIU.Pmon.v3.4.SnpRsp </p></td><td class="confluenceTd"><p /></td><td class="confluenceTd"><p /></td><td class="confluenceTd"><p /></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>Latency counter feature :</p><p>1- Check bins at quantizer level and before Pmon counting using a spies signals</p><p>2- Check latency counting by checking 4 consecutive counter registers xCNTVR0 to xCNTVR3 and xCNTSR0 to xCNTSR3</p></td><td class="confluenceTd"><p /><p>#Check.IOAIU.Pmon.v3.4.LatencyBins</p><p>#Check.IOAIU.Pmon.v3.4.LatencyCounter</p></td><td class="confluenceTd"><p>perf_counters_scoreboard.svh</p><p>New file : latency_counters_scoreboard.svh</p></td><td class="confluenceTd"><p>N</p></td><td class="confluenceTd"><p>NA</p></td><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p /></td></tr></tbody></table></div><h3 id="PerformanceCounter(includingBW,Latency,andMultiported)-8.4.3Perfcounterfunctionalcoverage:"><strong>8.4.3 Perf counter functional coverage :</strong></h3><h3 id="PerformanceCounter(includingBW,Latency,andMultiported)-Functionalcoverage:">Functional coverage :</h3><p>Pmon functional coverage is already implemented and completed for Ncore 3.2 features.</p><p>Below new points related to new features to be covered</p><div class="table-wrap"><table data-layout="default" data-local-id="b4e4f907-6452-4dc4-afe6-db73fd0eaec2" class="confluenceTable"><colgroup><col style="width: 113.33px;"/><col style="width: 113.33px;"/><col style="width: 113.33px;"/><col style="width: 113.33px;"/><col style="width: 113.33px;"/><col style="width: 113.33px;"/></colgroup><tbody><tr><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Scenario</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Hash-Tag</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Where Covered</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Done</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Status</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Comments</p></th></tr><tr><td class="confluenceTd"><p>Cover 32-bit counter mode for xCNTVR : Counter control=3'b100</p></td><td class="confluenceTd"><p>#Cover.IOAIU.Pmon.v3.4.CONTROL.32BIT</p></td><td rowspan="8" class="confluenceTd"><p /><p /><p /><p /><p /><p>perf_cnt_unit_defines.svh</p></td><td class="confluenceTd"><p>N</p></td><td class="confluenceTd"><p>NA</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>Cover 32-bit counter mode for xCNTSR : SSR count =3'b100</p></td><td class="confluenceTd"><p>#Cover.IOAIU.Pmon.v3.4.SSR.32BIT</p></td><td class="confluenceTd"><p>N</p></td><td class="confluenceTd"><p>NA</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>Cover filter type selection : - filter select = 0 to select Funit ID filtering </p><ul><li><p>filter select = 1 to select user Bits filtering</p></li></ul><p /></td><td class="confluenceTd"><p>#Cover.IOAIU.Pmon.v3.4.FilterSelect</p></td><td class="confluenceTd"><p>N</p></td><td class="confluenceTd"><p>NA</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p><strong>Cover CmdReq WR event : xCNTCR.event first = 17</strong></p></td><td class="confluenceTd"><p>#Cover.IOAIU.Pmon.v3.4.CmdReqWR</p></td><td class="confluenceTd"><p>N</p></td><td class="confluenceTd"><p>NA</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p><strong>Cover CmdReq RD event : : xCNTCR.event first = 18</strong></p></td><td class="confluenceTd"><p>#Cover.IOAIU.Pmon.v3.4.CmdReqRD</p></td><td class="confluenceTd"><p>N</p></td><td class="confluenceTd"><p>NA</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p><strong>Cover SnpRsp event : : xCNTCR.event first = 19</strong></p></td><td class="confluenceTd"><p>#Cover.IOAIU.Pmon.v3.4.SnpReq </p></td><td class="confluenceTd"><p /></td><td class="confluenceTd"><p /></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>Cover Different latency pre scale values : </p><p>2b00 – count every 2 cycles<br/>2b01 – count every 4 cycles<br/>2b10 – count every 8 cycles<br/>2b11 – count every 16 cycles</p></td><td class="confluenceTd"><p>#Cover.IOAIU.Pmon.v3.4.LatencyScale</p></td><td class="confluenceTd"><p>N</p></td><td class="confluenceTd"><p>NA</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>Cover Latency type : write, read</p></td><td class="confluenceTd"><p>#Cover.IOAIU.Pmon.v3.4.LatencyType</p></td><td class="confluenceTd"><p>N</p></td><td class="confluenceTd"><p>NA</p></td><td class="confluenceTd"><p /></td></tr></tbody></table></div><h3 id="PerformanceCounter(includingBW,Latency,andMultiported)-8.4.4Perfcounterdocuments:"><strong>8.4.4 Perf counter documents :</strong></h3><h3 id="PerformanceCounter(includingBW,Latency,andMultiported)-PerfcounterReferences">Perf counter References</h3><p>Ncore 3.4 Perf Counter Arch Spec : <a class="external-link" href="https://confluence.arteris.com/display/ENGR/Arch+Ncore+3.4+Docs?preview=/30510577/41386910/Ncore%20Concerto%20Perf%20Counter%20Specification.pdf" rel="nofollow">https://confluence.arteris.com/display/ENGR/Arch+Ncore+3.4+Docs?preview=/30510577/41386910/Ncore%20Concerto%20Perf%20Counter%20Specification.pdf</a></p><p>Ncore 3.4 Perf Counter Micro-Architecture Spec : <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16170605/Ncore+3.4_Performance+Monitor+Micro-Architecture+Specification" data-linked-resource-id="16170605" data-linked-resource-version="8" data-linked-resource-type="page">Ncore 3.4 Performance Monitor Micro-Architecture Specification</a></p><p>Ncore 3.4 Perf Counter verification library integration instructions: <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/39354499/Pmon+verification+library+integration+for+Ncore3.4" data-linked-resource-id="39354499" data-linked-resource-version="16" data-linked-resource-type="page">Pmon verification library integration for Ncore3.4</a></p><p>Ncore 3.4 DII Testplan with Perf Counter information: <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16170841/Ncore+3.4+DII+Testplan" data-linked-resource-id="16170841" data-linked-resource-version="115" data-linked-resource-type="page">Ncore 3.4 DII Testplan:</a></p><p>Ncore 3.2 Perfmon Arch questions: <a class="createlink" href="/wiki/pages/createpage.action?spaceKey=ENGR&amp;title=Perfmon%20Arch%20questions&amp;linkCreation=true&amp;fromPageId=60555703">/wiki/spaces/ENGR/pages/16166456</a></p><p>Ncore 3.0 Perf Counter Micro-Architecture Review video: <a class="external-link" data-card-appearance="inline" href="https://arteris-my.sharepoint.com/personal/ronak_salamat_arteris_com/_layouts/15/onedrive.aspx?id=%2Fpersonal%2Fronak%5Fsalamat%5Farteris%5Fcom%2FDocuments%2FRecordings%2FPerformance%20Counter%20uArch%20review%2D20210608%5F140238%2DMeeting%20Recording%2Emp4&amp;parent=%2Fpersonal%2Fronak%5Fsalamat%5Farteris%5Fcom%2FDocuments%2FRecordings" rel="nofollow">https://arteris-my.sharepoint.com/personal/ronak_salamat_arteris_com/_layouts/15/onedrive.aspx?id=%2Fpersonal%2Fronak%5Fsalamat%5Farteris%5Fcom%2FDocuments%2FRecordings%2FPerformance%20Counter%20uArch%20review%2D20210608%5F140238%2DMeeting%20Recording%2Emp4&amp;parent=%2Fpersonal%2Fronak%5Fsalamat%5Farteris%5Fcom%2FDocuments%2FRecordings</a> </p><p /><p>Ncore 3.4 Testplan review for PMON blocks and FSYS: <a class="external-link" href="https://arteris-my.sharepoint.com/:v:/p/bill_chandler/ET9YqL5UUMtNrjKd3BDGHYUBUi4PFc585ZdUwMK1Cdzk7Q" rel="nofollow">https://arteris-my.sharepoint.com/:v:/p/bill_chandler/ET9YqL5UUMtNrjKd3BDGHYUBUi4PFc585ZdUwMK1Cdzk7Q</a></p>