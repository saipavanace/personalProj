<h2 id="OBSOLETE-DELETEHW-CTFpmon_stats-module_name:">module_name<strong>:</strong></h2><p>pmon_stats</p><h2 id="OBSOLETE-DELETEHW-CTFpmon_stats-JavaScriptparameters:">JavaScript parameters:</h2><p><strong><em>nodeId</em> </strong>: a non-negative integer.</p><p><strong><em>tmrEvtMap</em></strong>: An array of objects. Each array element object defines a timer/counter. The object must have the following fields:<br/>{<br/>   <em>name</em> : &quot;a_string&quot;,<br/>   <em>width</em> : a positive integer. Width of the timer,<br/>   <em>start</em> : &quot;a_string&quot; that matches an event-name (See below). Optional if skipped, this will be tied to a one,<br/>   <em>stop</em> : &quot;a_string&quot; that matches an event-name (See below). Optional if skipped, this will be tied to a zero,<br/>   <em>reset</em> : &quot;a_string&quot; that matches an event-name (See below). Optional if skipped, this will be tied to a zero,<br/>   <em>count</em> : &quot;a_string&quot; that matches an event-name (See below). Optional. If skipped, this will be tied to a one,<br/>   <em>tmrEvt</em> : &quot;a_string&quot; that matches an event-name (See below). Optional. If skipped, timer won't have this output generated.<br/>},</p><p><strong><em>evtDefines</em></strong>: An array of objects. The structure of such an object is described below: <br/>{<br/><em>name</em> : A string that specifies the name of the internal event. This needs to match the name of the event when used in <em>iEvtMap</em> or <em>oEvtMap</em> data-structures.<br/><em>width</em> : A positive integer that specifies the width of the event.<br/><em>interrupt</em> : A Boolean true or false. True means this event should trigger interrupt.<br/><em>outEvt </em>: A string that matches the name of one of the event names on the <em>evtInterfaces</em>. If not defined or empty-string, this event will remain internal to the block and doesn't go out as an output of the probe block.<br/><em>description</em>: A string describing the event. This is passed to interrupt block if marked interrupt.<br/><em>conditions</em> : An array of strings each of which is expected to be a syntactically correct Verilog expression. The names of signals should match either one of the following:</p><ol><li>Names of events described in the <em>evtDefines</em> data-structure</li><li>User-defined register field described in the <em>regFieldDefines</em> data-structure</li><li>Register fields in Timer registers Val and Limit. Name of the signal is described as <em>RegisterName</em>_<em>FieldName_</em>out, where<em><em> RegisterName = 'TimerName</em>_</em>val' or '<em>TimerName</em>_limit', and <em>FieldName</em> = 'val' or 'limit'.</li><li>Verilog constant literal</li></ol><p>}</p><p><strong><em>regFieldDefines</em></strong>: An array of objects each of which describes a user-defined register field. The structure of such an object is defined below:<br/>{<br/><em>  name</em> : A string that specifies the name of the internal event. This needs to match the name of the signal as used in the Verilog expressions in the <em>conditions</em> array in <em>evtDefines</em>.<br/>  <em>width</em> : A positive integer that specifies the width of the field.<br/>  <em>access</em> : A string that can take one of the following values - &quot;RW&quot;, &quot;RO&quot;.<br/><em>  description</em>: A string describing the register field.<br/>}</p><p><strong><em>protectionStyle</em></strong>: <a class="external-link" href="https://confluence.arteris.com/display/ENGR/protectionStyle" rel="nofollow">protectionStyle</a></p><p>An <strong>event-name</strong> string must match either</p><ol><li>An event name defined in <em>evtDefines </em>data-structure. or </li><li>An input event name i.e. name (property of that event)+&quot;_val&quot;</li></ol><p>If a timer event (<em>tmrEvt</em>) of a timer is to be used as an input event to another timer, then it must be defined in the evtDefines and then connected to the <em>tmrEvt</em> output of the driving timer.</p><p><br/></p><p><strong>Interfaces:</strong></p><p><em>clkInterface</em>: A slave interface of type <a class="external-link" href="https://confluence.arteris.com/display/ENGR/InterfaceCLK" rel="nofollow">InterfaceCLK</a>.</p><p><em>cfgInterface</em>: A slave interface of type <a class="external-link" href="https://confluence.arteris.com/display/ENGR/InterfaceAPB" rel="nofollow">InterfaceAPB</a>. This interface is used to program the probe registers.</p><p><em>evtInterfaces</em>: An array of slave interfaces of type <a class="external-link" href="https://confluence.arteris.com/display/ENGR/InterfaceEvt" rel="nofollow">InterfaceEvt</a>.</p><p><em>protInterface</em>: (Optional interface. Not in Presto 1.0). A master interface of type <a class="external-link" href="https://confluence.arteris.com/display/ENGR/InterfacePROT" rel="nofollow">InterfacePROT</a>.</p><p><em>intInterface</em>: A master interface of type <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16160508/InterfaceINT" data-linked-resource-id="16160508" data-linked-resource-version="3" data-linked-resource-type="page">InterfaceINT</a>.</p><p><em>ctiInterface</em>: (Optional interface for future use. Not in Presto 1.0). A slave interface of type InterfaceCTI.</p><h2 id="OBSOLETE-DELETEHW-CTFpmon_stats-ModulesUsed">Modules Used</h2><div><strong><strong><a class="external-link" href="https://confluence.arteris.com/display/ENGR/sym_apb_csr" rel="nofollow">sym_apb_csr</a></strong></strong></div><div><strong><strong><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16157267/OBSOLETE-DELETE+HW-CTF+pmon_tmr" data-linked-resource-id="16157267" data-linked-resource-version="2" data-linked-resource-type="page">OBSOLETE-DELETE HW-CTF pmon_tmr</a></strong></strong></div><div><strong><strong><br/></strong></strong></div><div><h2 id="OBSOLETE-DELETEHW-CTFpmon_stats-BlockDescription">Block Description</h2><p>The link probe or the pmon_probe block listens to packets on an ATP link. It can be configured to read specific fields in packets which can then be used</p><p><span class="confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image image-center" height="400" src="https://arterisip.atlassian.net/wiki/download/attachments/16157285/image2019-12-5%2015:29:43.png?api=v2"></span></p><p><br/></p><p>The PMON stats consists of the following sub-blocks:</p><ol><li>Timers. This block contains a set of PMON Timers. Each of these timers has:<ol><li>A <em>cfgTmrInterface</em> which are bits coming from and going to the APB CSR Block for software control.</li><li>An <em>evtTmrInterface</em> which includes:</li></ol></li></ol><p>                                                               i.      Input events to the timer – start, stop, count, reset</p><p>                                                             ii.      An Output event from the timer - tmr</p><ol><li>APB CSR: This implements a set of configuration registers to configure each of the timers in the <em>tmrEvtMap</em>, and a set of select values to choose from, from a pool of input and internal events as described in the <em>tmrEvtMap</em> data-structure. The CSR structure for this block is generated, based on <em>tmrEvtMap</em>, dynamically during TACHL run.</li><li>Input Events Mapping: This consists of a set of muxes and wire-mappings of input events, <em>iEvt</em>[X], and internal events, <em>tEvt</em>[X], to <em>evtTmrInterface </em>interfaces of all the Timers. The wire-mappings are done based on the <em>iEvtMap</em> object in the <em>tmrEvtMap</em>.</li><li>Output Events Mapping: This is just a set of wire-mapping of all timer outputs (‘<em>tmr</em>’) to output events, <em>oEvt</em>[X], and internal events, <em>tEvt</em>[X]. The wire-mappings are done based on the <em>oEvtMap</em> object in the <em>tmrEvtMap</em>.</li></ol><h2 id="OBSOLETE-DELETEHW-CTFpmon_stats-RegisterDescriptions">Register Descriptions</h2><p>The number of registers the probe block will have depends on the parameters <em>tmrEvtMap</em>, <em>evtDefines</em>, and <em>regFieldDefines</em>. The exact number of registers generated can be calculated this way:</p><p>Number of timer registers = <em>tmrEvtMap</em>.length * 4.<br/>Number of select registers = 1 if (ceil(log2(<em>evtDefines</em>[ i ].conditions.length)) &gt; 0) else 0, for i from 0 to number of events in evtDefines-1<br/>Number of user-defined registers = <em>regFieldDefines</em>.length;<br/>Number of global registers = 2.</p><p>Total Number of registers = global registers + user-defined registers + select registers + timer registers.</p><h4 id="OBSOLETE-DELETEHW-CTFpmon_stats-1.1.1PMON_STATS_SEL_eventName">1.1.1      PMON_STATS_SEL_<em>eventName</em></h4><p>An instance of this register exists for each event in the <em>evtDefines</em> structure, as long as the number of entries in the <em>conditions</em> array for that event is greater than 1.</p><div class="table-wrap"><table class="wrapped confluenceTable"><tbody><tr><td class="confluenceTd"><p>Field</p></td><td class="confluenceTd"><p>Bits</p></td><td class="confluenceTd"><p>RW</p></td><td class="confluenceTd"><p>Parameterized</p></td><td class="confluenceTd"><p>Description</p></td></tr><tr><td class="confluenceTd"><p>sel</p></td><td class="confluenceTd"><p>Log<sub>2</sub>(No. of conditions to select from to generate the conditional event)</p><p align="center"><br/></p></td><td class="confluenceTd"><p>RW</p></td><td class="confluenceTd"><p>Yes</p></td><td class="confluenceTd"><p>Select value to select condition for event N</p></td></tr></tbody></table></div><p><br/></p><h4 id="OBSOLETE-DELETEHW-CTFpmon_stats-1.1.2PMON_STATS_USER_N(N=0,1,2,…)">1.1.2      PMON_STATS_USER_<em>N</em> (N = 0,1, 2, …)</h4><p>These registers are generated to hold register-fields defined in the <em>regFieldDefines</em> data-structure. Currently a separate register is generated for each register field in the <em>regFieldDefines</em> data-structure. However, this might change in future to optimize utilization of an address space.</p><p><br/></p><div class="table-wrap"><table class="wrapped confluenceTable"><tbody><tr><td class="confluenceTd"><p>Field</p></td><td class="confluenceTd"><p>Bits</p></td><td class="confluenceTd"><p>RW</p></td><td class="confluenceTd"><p>Parameterized</p></td><td class="confluenceTd"><p>Description</p></td></tr><tr><td class="confluenceTd"><p align="center">Matches the name of field in <em>regFieldDefines</em></p></td><td class="confluenceTd"><p>Matches the width of field in <em>regFieldDefines</em></p></td><td class="confluenceTd"><p>RW</p></td><td class="confluenceTd"><p>Yes</p></td><td class="confluenceTd"><p>Used to generate conditional events according to user-specified conditions</p></td></tr></tbody></table></div><p><br/></p><h4 id="OBSOLETE-DELETEHW-CTFpmon_stats-1.1.3TimerName_val">1.1.3      <em>TimerName</em>_val</h4><p>This register holds the current timer or counter value.</p><p><br/></p><div class="table-wrap"><table class="wrapped confluenceTable"><tbody><tr><td class="confluenceTd"><p>Field</p></td><td class="confluenceTd"><p>Bits</p></td><td class="confluenceTd"><p>SW access</p></td><td class="confluenceTd"><p>Parameterized</p></td><td class="confluenceTd"><p>Description</p></td></tr><tr><td class="confluenceTd"><p>Val</p></td><td class="confluenceTd"><p>W = ‘<em>width</em>’ in <em>tmrEvtMap</em></p></td><td class="confluenceTd"><p>RO</p></td><td class="confluenceTd"><p>No</p></td><td class="confluenceTd"><p>Current timer value</p></td></tr></tbody></table></div><p><br/></p><h4 id="OBSOLETE-DELETEHW-CTFpmon_stats-1.1.4TimerName_limit">1.1.4      <em>TimerName</em>_limit</h4><p>This register holds the limit or threshold value used to generate the timer output event.</p><p><br/></p><div class="table-wrap"><table class="wrapped confluenceTable"><tbody><tr><td class="confluenceTd"><p>Field</p></td><td class="confluenceTd"><p>Bits</p></td><td class="confluenceTd"><p>SW access</p></td><td class="confluenceTd"><p>Parameterized</p></td><td class="confluenceTd"><p>Description</p></td></tr><tr><td class="confluenceTd"><p>limit</p></td><td class="confluenceTd"><p>W = ‘<em>width</em>’ in <em>tmrEvtMap</em></p></td><td class="confluenceTd"><p>RW</p></td><td class="confluenceTd"><p>No</p></td><td class="confluenceTd"><p>Limit value for comparison with timer value to generate timer output event.</p></td></tr></tbody></table></div><p><br/></p><h4 id="OBSOLETE-DELETEHW-CTFpmon_stats-1.1.5TimerName_ctrl">1.1.5      <em>TimerName</em>_ctrl</h4><p>This register provides software control to start, stop, and reset timer N.</p><p><br/></p><div class="table-wrap"><table class="wrapped confluenceTable"><tbody><tr><td class="confluenceTd"><p>Field</p></td><td class="confluenceTd"><p>Bits</p></td><td class="confluenceTd"><p>RW</p></td><td class="confluenceTd"><p>Parameterized</p></td><td class="confluenceTd"><p>Description</p></td></tr><tr><td class="confluenceTd"><p>start</p></td><td class="confluenceTd"><p align="center">0-0</p></td><td class="confluenceTd"><p>RW</p></td><td class="confluenceTd"><p>No</p></td><td class="confluenceTd"><p>Software Start bit for starting timer N. Auto-clears after a cycle.</p></td></tr><tr><td class="confluenceTd"><p>stop</p></td><td class="confluenceTd"><p align="center">4-4</p></td><td class="confluenceTd"><p>RW</p></td><td class="confluenceTd"><p>No</p></td><td class="confluenceTd"><p>Software Stop bit for stopping timer N. Auto-clears after a cycle.</p></td></tr><tr><td class="confluenceTd"><p>reset</p></td><td class="confluenceTd"><p align="center">8-8</p></td><td class="confluenceTd"><p>RW</p></td><td class="confluenceTd"><p>No</p></td><td class="confluenceTd"><p>Software Reset bit for resetting timer N. Auto-clears after a cycle.</p></td></tr></tbody></table></div><p><br/></p><h4 id="OBSOLETE-DELETEHW-CTFpmon_stats-1.1.6TimerName_en_mode">1.1.6      <em>TimerName</em>_en_mode</h4><p>Timer N Enable and Mode Select register. This register has bits to enable timer and to configure the timer in various modes.</p><p><br/></p><div class="table-wrap"><table class="wrapped confluenceTable"><tbody><tr><td class="confluenceTd"><p>Field</p></td><td class="confluenceTd"><p>Bits</p></td><td class="confluenceTd"><p>SW access</p></td><td class="confluenceTd"><p>Parameterized</p></td><td class="confluenceTd"><p>Description</p></td></tr><tr><td class="confluenceTd"><p>en</p></td><td class="confluenceTd"><p align="center">0-0</p></td><td class="confluenceTd"><p>RW</p></td><td class="confluenceTd"><p>No</p></td><td class="confluenceTd"><p>Enable Timer N.</p></td></tr><tr><td class="confluenceTd"><p>ct</p></td><td class="confluenceTd"><p align="center">4-4</p></td><td class="confluenceTd"><p>RW</p></td><td class="confluenceTd"><p>No</p></td><td class="confluenceTd"><p>Set Counter or Timer Mode. 0 – Counter mode, 1 – Timer mode.</p></td></tr><tr><td class="confluenceTd"><p>inc_mode</p></td><td class="confluenceTd"><p align="center">9-8</p></td><td class="confluenceTd"><p>RW</p></td><td class="confluenceTd"><p>No</p></td><td class="confluenceTd"><p>Set increment mode. Determines how timer increments after reaching limit value:</p><p>0 – Wrap mode. Timer resets to 0.</p><p>1 – Freeze mode. Timer freezes at limit value and doesn’t increment value afterward.</p><p>2 – Run Mode. Timer continues to increment after reaching limit value.</p></td></tr></tbody></table></div></div>