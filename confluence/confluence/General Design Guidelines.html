<p>These are general suggestions and things to keep in mind when starting to make TACHL blocks. </p><h2 id="GeneralDesignGuidelines-Documentation">Documentation</h2><div class="table-wrap"><table data-layout="wide" data-local-id="cf051390-3c16-4a53-98d8-1fb62a74d6dc" class="confluenceTable"><colgroup><col style="width: 101.0px;"/><col style="width: 859.0px;"/></colgroup><tbody><tr><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Number</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Guideline</p></th></tr><tr><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>All software visible blocks must have a confluence page. This should include:</p><ul><li><p>IO Naming and Behavior</p></li><li><p>Top level parameter description.</p></li><li><p>Hierarchy and Partitioning of Blocks.</p></li><li><p>Internal interfaces and timing.</p></li><li><p>State Machines</p></li></ul></td></tr><tr><td class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>All other blocks should at least have a confluence page explaining parameters and IO behavior. </p></td></tr><tr><td class="confluenceTd"><p>3</p></td><td class="confluenceTd"><p>Either comment or self-name all parameters and internal signals.</p></td></tr><tr><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>All library elements should have a confluence explaining parameters and function.</p></td></tr><tr><td class="confluenceTd"><p>5</p></td><td class="confluenceTd"><p>Put all comments with implementation detail inside the JS world.</p></td></tr><tr><td class="confluenceTd"><p>6</p></td><td class="confluenceTd"><p>Design should be well commented describing top level behavior and motivations. </p></td></tr><tr><td class="confluenceTd"><p>7</p></td><td class="confluenceTd"><p>All RTL files must include the Arteris legal header.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">///////////////////////////////////////////////////////////////////////////
// Arteris Inc. 2022. All rights reserved
///////////////////////////////////////////////////////////////////////////</pre>
</div></div></td></tr></tbody></table></div><p /><h2 id="GeneralDesignGuidelines-Structural">Structural</h2><div class="table-wrap"><table data-layout="wide" data-local-id="bf8e1faf-cb3c-4b7e-af63-728c5b58ab6e" class="confluenceTable"><colgroup><col style="width: 101.0px;"/><col style="width: 859.0px;"/></colgroup><tbody><tr><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Number</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Guideline</p></th></tr><tr><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>If two blocks have a common feature ( feature with same name ) try and encapsulate it inside a HW/JS library element.</p></td></tr><tr><td class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>File sizes should be kept at a reasonable length. &lt;1000 lines</p></td></tr><tr><td class="confluenceTd"><p>3</p></td><td class="confluenceTd"><p>Avoid deeply nested if statements and mixed JS/Verilog nested if statements.</p></td></tr><tr><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>Keep in mind when making transaction tables / large context blocks that having each context entry reference a common module can help with coverage.</p></td></tr><tr><td class="confluenceTd"><p>5</p></td><td class="confluenceTd"><p>Put repetitive Verilog expressions inside JS functions. (Macros)</p></td></tr><tr><td class="confluenceTd"><p>6</p></td><td class="confluenceTd"><p>The tachl filename needs to match the module name.</p></td></tr><tr><td class="confluenceTd"><p>7</p></td><td class="confluenceTd"><p>Filenames should be all lowercase &lt;unit&gt;<em>&lt;subunit&gt;</em>&lt;subunit&gt;.tachl E.g., ioaiu_control_ace_snoopresponse.tachl<br/>Filename should, if convenient, to make tracking easier, reflect the design hierarchy.<br/>Common files should preferably be in the library.</p></td></tr><tr><td class="confluenceTd"><p>8</p></td><td class="confluenceTd"><p>It is not allowed to share design modules across units outside of the library.</p></td></tr><tr><td class="confluenceTd"><p>8</p></td><td class="confluenceTd"><p>Use library elements when possible. Especially arbiters, dffre, pipestages, logic trees, lookup pipes</p></td></tr><tr><td class="confluenceTd"><p>9</p></td><td class="confluenceTd"><p>First level of hierarchy should be unit name ex. “ioaiu”. The next level which is duplicated should be unit name and underscore unit ex. “ioaiu_unit”</p><p>All other blocks for that unit should be in its own tachl file and be titled unit_”name”. ex. “ioaiu_control”</p></td></tr></tbody></table></div><h2 id="GeneralDesignGuidelines-HardwareCoding">Hardware Coding </h2><div class="table-wrap"><table data-layout="wide" data-local-id="e9f5a202-17c5-41d9-b0f5-239758fdd06d" class="confluenceTable"><colgroup><col style="width: 101.0px;"/><col style="width: 859.0px;"/></colgroup><tbody><tr><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Number</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Guideline</p></th></tr><tr><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>The design must be coded in TACHL/verilog-2005</p></td></tr><tr><td class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>RTL should be synthesizable, and thus only use synthesizable verilog constructs.<br/>RTL naming cannot conflict with verilog reserved names...</p></td></tr><tr><td class="confluenceTd"><p>3</p></td><td class="confluenceTd"><p>Design should be built with readability, timing/layout and ease of debug in mind. Scalability in terms of ease of change, and upgradability should also be considered.</p></td></tr><tr><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>ET: I think we should keep JS Variables as CamelFoot as that is how they are defined in CPR. Then in hardware we could use underscores to make the HW/SW world look differant, </p><p>Signal naming should be CamelFoot<br/>Signals should be named meaningfully and not overly long.<br/>E.g.,<br/>DataBufferAddr<br/>DataBufferReadData<br/>NxtAddr</p></td></tr><tr><td class="confluenceTd"><p>5</p></td><td class="confluenceTd"><p><del>Instancenames should be the modulename with the unit name removed.</del><br/><del>E.g.,</del><br/><del>ioaiu_stt stt(...)</del><br/><del>ioaiu_control control(...)</del><br/><del>ioaiu_control_ace_snoopresponse ace_snoopresponse(...)</del></p><p>Copy of the structural requirement above.</p></td></tr><tr><td class="confluenceTd"><p>6</p></td><td class="confluenceTd"><p>Signals generated within a unit and propagated outside the unit should be prefixed with the unit (instance) name. This should only be used for larger blocks.<br/>E.g., output wire sttMessage</p></td></tr><tr><td class="confluenceTd"><p>7</p></td><td class="confluenceTd"><p>Pipelined signals should follow a clear suffixing numbering scheme.<br/>E.g., data_p0, data_p1, etc.</p></td></tr><tr><td class="confluenceTd"><p>8</p></td><td class="confluenceTd"><p>ET: The word “Active” I think is up for interpretation. Im not sure how enforceable / useful this rule is. For example if I have a signal not_working and its 1 does that mean its active high. Or having the signal “active” and using it to check if some thing is not active is that active low? I know you can make an argument over semantics but I dont see much use in this rule. </p><p>Active low signals should be avoided if possible and suffixed with _n if used.</p></td></tr><tr><td class="confluenceTd"><p>9</p></td><td class="confluenceTd"><p>Clocks below the top module should be named clk. A prefix or suffix can be added for different power/clock domains.</p></td></tr><tr><td class="confluenceTd"><p>10</p></td><td class="confluenceTd"><p>Resets below the top module should be named reset_n (active low). A prefix or suffix can be added for different power/clock domains.</p></td></tr><tr><td class="confluenceTd"><p>7</p></td><td class="confluenceTd"><p>ET: I think we should specify verilog parameter here. JS parameters are in CamelCase inside CPR and there isn't a reason to rename them for the sake of renaming, </p><p>Parameter naming should be UPPERCASE, E.g., DATABUSWIDTH<br/>Parameter names should not be abbreviated but spelled out so it's clear what the usage is. E.g., SNOOPBUFFERENTRIES, DATABUFFERENTRIES, CACHEDATABUSWIDTH, etc.<br/>TLAs are not be allowed for parameters.</p></td></tr><tr><td class="confluenceTd"><p>8</p></td><td class="confluenceTd"><p>Always use the dffre function.  &quot;always @ (posedge clk)&quot; block are not allowed outside flop library cells.</p></td></tr><tr><td class="confluenceTd"><p>9</p></td><td class="confluenceTd"><p><del>Consider using ao_mux instead of reverse case statement. </del></p><p>ET: Why did you cross this out. ao_mux can allow for future pipeline ability of lookups and in designs we did see timing improvements when ao_muxs are used as the tool doesnt need to imply the parallel nature of the case statement. Its just a tip to let people know this block exists and in many cases its better to just use this block.</p></td></tr><tr><td class="confluenceTd"><p>10</p></td><td class="confluenceTd"><p>No casex allowed in design.</p><p>All case statements should use casez.</p><p>All casez statement must include a default.</p><p>Illegal states must have an assertion.</p></td></tr><tr><td class="confluenceTd"><p>11</p></td><td class="confluenceTd"><p>Always use the JS functions to declare ports, interfaces and local wires instead of declaring them in Verilog.</p></td></tr><tr><td class="confluenceTd"><p>12</p></td><td class="confluenceTd"><p>Avoid the use of Verilog parameters and use JS parameters as much as possible. The use of Verilog parameters is allowed but should limited to when it makes sense and to lower levels of the block. The use of JS parameters is useful for coverage, while Verilog parameters are useful for code density in generate statements.</p><p>Try to avoid too much mixing of parameters at any level of the design. You can always move a JS parameter to a Verilog parameter but not the other was around.</p></td></tr><tr><td class="confluenceTd"><p>10</p></td><td class="confluenceTd"><p>While JS parameters will be used in general, the generated RTL should have a hook to the JS parameters so it's possible to determine the parameters settings in the waveforms for the generated RTL.<br/>In particular for configuration parameters.</p></td></tr><tr><td class="confluenceTd"><p>11 </p></td><td class="confluenceTd"><p>Follow the asserting guide here: <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16167534/RTL+Assertion+Methodology" data-linked-resource-id="16167534" data-linked-resource-version="4" data-linked-resource-type="page">RTL Assertion Methodology</a> </p></td></tr><tr><td class="confluenceTd"><p>12</p></td><td class="confluenceTd"><p>Software visible blocks must only use the &quot;interfaces&quot; object at the top level. No declaration of single ports.</p></td></tr><tr><td class="confluenceTd"><p>13</p></td><td class="confluenceTd"><p>Minimize individual ports on blocks that are not library elements and use interfaces (old-style or new-style) instead. This avoids having to pass width (of port) params separately.</p></td></tr><tr><td class="confluenceTd"><p>14</p></td><td class="confluenceTd"><p>Guideline for creating CSR interfaces  <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16160703/Auto+generation+of+CSR+register+ports+and+interfaces" data-linked-resource-id="16160703" data-linked-resource-version="14" data-linked-resource-type="page">Auto generation of CSR register ports and interfaces</a></p></td></tr><tr><td class="confluenceTd"><p>15</p></td><td class="confluenceTd"><p>Keep in mind when index-math in part-selects ( Ex: signalName[ \=(i+1)*width-1=\ : \=i*width=\ ] ) becomes cluttery. </p><ol><li><p>Cannot use Verilog arrays (customer requirements).</p></li><li><p>If you need to divide up a long bit-vector uniformly, use JS libraries that return arrays: split( ) function or functions that allow packed-array representation.</p></li><li><p>If you need to divide up a long bit-vector non-uniformly, use Verilog destructuring ( Ex: assign { a, b, c } = packed_signal; ). Or functions that allow packed-struct representation.</p></li><li><p>At a module boundary: Avoid packing several inputs of same width into a single input bit vector. Use interface arrays instead.</p></li><li><p>Make JS variables defining the msb and lsb to spread out code complexity. </p></li><li><p>Make new signals when repetitively using the same index-math. </p></li></ol></td></tr><tr><td class="confluenceTd"><p>16</p></td><td class="confluenceTd"><p>Reduce if-else branch clutter for operations on signals of variable widths such as bit-indexing, part-selects, zero-padding etc.</p></td></tr><tr><td class="confluenceTd"><p>17</p></td><td class="confluenceTd"><p>We need a good guideline on when and how to avoid name-collisions. ( Libraries are available for this: regNameNoHit(), createUniqueNameFactory())</p><p>Never have empty interface names. Can cause signal naming collisions. </p></td></tr><tr><td class="confluenceTd"><p>18</p></td><td class="confluenceTd"><p>Increase separation between JS and Verilog sections of code in TACHL code such that it leads to more opportunities for modularizing, and refactoring JS section of code.</p><p>For example create global JS variables in one place (at the top of the file) verses doing it inline spread through the code. </p></td></tr><tr><td class="confluenceTd"><p>19</p></td><td class="confluenceTd"><p>Try and use the following abbreviations:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">          address      -- addr
           index        -- idx
           valid        -- vld
           select       -- sel
           byte enable  -- be
           bit enable   -- biten
           next         -- nxt
           destination  -- dst
           source       -- src
           control      -- ctrl
           operation    -- op
           decode       -- dec
           opcode       -- opc
           enable       -- en
           disable      -- disen
           write        -- wr
           write enable -- wren
           read         -- rd
           read enable  -- rden
           allocate     -- alloc
           deallocate   -- dealloc
           complete     -- comp
           update       -- upd     </pre>
</div></div></td></tr><tr><td class="confluenceTd"><p>20</p></td><td class="confluenceTd"><p>No Verilog Macros are allowed in the design. Use JS functions instead.</p></td></tr><tr><td class="confluenceTd"><p>21</p></td><td class="confluenceTd"><p>Avoid dead code. Use JS parameters to enable/disable code. </p></td></tr><tr><td class="confluenceTd"><p>22</p></td><td class="confluenceTd"><p>State machines should be coded in always @(*) blocks using a casez statement</p></td></tr></tbody></table></div><p /><h2 id="GeneralDesignGuidelines-SoftwareCoding">Software Coding</h2><div class="table-wrap"><table data-layout="wide" data-local-id="94020bf3-9d11-4fbb-8ac2-f38e05a4c1c3" class="confluenceTable"><colgroup><col style="width: 104.0px;"/><col style="width: 856.0px;"/></colgroup><tbody><tr><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Number</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Guideline</p></th></tr><tr><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>All parameters of a software visible block must have default values set.</p></td></tr><tr><td class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>Follow SRP (Single-responsibility principle). This implies or leads to :<br/></p><ol><li><p>Breaking up large functions ( &gt; 50 lines) into smaller functions.</p></li><li><p>Small number of parameters ( &lt; 4 ) passed to a function.</p></li><li><p>Smaller loops.</p></li></ol></td></tr><tr><td class="confluenceTd"><p>3</p></td><td class="confluenceTd"><p>Name all your constants. No magic numbers allowed.</p></td></tr><tr><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>Generally use high-level language features and JS built-in functions to improve code intent and reliability, except in following cases:</p><ol><li><p>If they lead to problems because of TACHL running in a host environment. (Need clarity on what kind of functions cause problems because of this)</p></li><li><p>If they employ less familiar design patterns and paradigms ( functional ). If you must use this, please include comments.</p></li></ol></td></tr><tr><td class="confluenceTd"><p>5</p></td><td class="confluenceTd"><p>Only make copies of those objects that you wish to modify and only at the level you wish to modify. This avoids deep copies. Shallow copies and reference copies are sufficient in almost every case.</p></td></tr><tr><td class="confluenceTd"><p>6</p></td><td class="confluenceTd"><p>Favor forEach over C-style for-loops when parsing arrays nested inside objects, and when using nested loops.</p></td></tr><tr><td class="confluenceTd"><p>7</p></td><td class="confluenceTd"><p>If required to implement encapsulation or object-oriented code, use factory function approach. Avoid using ES6 classes, constructor functions, prototypes, and using 'this' keyword.</p></td></tr><tr><td class="confluenceTd"><p>8</p></td><td class="confluenceTd"><p>When using built-in functions that accept callbacks ( such as findIndex(), find(), sort(), filter() ) except forEach( ), avoid in-place (inside function call) anonymous functions with multiple lines or statements. Define such functions separately as regular non-anonymous functions and pass them to functions that accept callbacks.</p></td></tr><tr><td class="confluenceTd"><p>9</p></td><td class="confluenceTd"><p>Defining anonymous functions using 'function' keyword or big-arrow operator ( =&gt; ) ?</p></td></tr><tr><td class="confluenceTd"><p>10</p></td><td class="confluenceTd"><p>Variable declarations:</p><ol><li><p>Minimize overall number of variable declarations in global space. You could hide them inside functions, objects, and block-scoped declarations.</p></li><li><p>Use 'const' when declaring variables, except when you need to reassign that variable. Use 'let' when you need to reassign a variable, except when you want that variable visible outside a block.</p></li><li><p>If you need a variable to be visible outside the current block, only then use 'var'.</p></li></ol></td></tr></tbody></table></div><h2 id="GeneralDesignGuidelines-Indentation">Indentation</h2><div class="table-wrap"><table data-layout="wide" data-local-id="b7681b06-c925-4cc7-9498-660152cd4855" class="confluenceTable"><colgroup><col style="width: 109.0px;"/><col style="width: 851.0px;"/></colgroup><tbody><tr><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Number</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Guideline</p></th></tr><tr><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>Spacing:<br/></p><ol><li><p>Leave a blank line above a statement block such as an if-block or a for-block.</p></li><li><p>Leave two lines blank above a function definition.</p></li><li><p>Either 2 or 4 spaces from the left for lines within a block</p></li></ol></td></tr><tr><td class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>Avoid \js. Use \jsbegin, \jsend instead.</p></td></tr><tr><td class="confluenceTd"><p>3</p></td><td class="confluenceTd"><p>The code should be indented for blocks.<br/>e.g.,<br/>if (block) begin:BLOCK<br/>  ..<br/>end<br/>else begin<br/>  ..<br/>end</p><p>begin end blocks should named<br/>e.g.,  <br/>begin: BLOCK<br/>end // BLOCK</p><p>generate endgenerate statements should be on separate lines.<br/>e.g.,</p><p>generate<br/>  if (SOMETHING) begin:bloc<br/>  ..<br/>  end // SOMETHING<br/>  else begin<br/>  end // !SOMETHING<br/>endgenerate</p></td></tr></tbody></table></div>