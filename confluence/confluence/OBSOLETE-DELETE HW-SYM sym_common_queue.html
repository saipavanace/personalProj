<p><strong>module_name:</strong></p><p><span>sym_common_queue</span></p><h1 id="OBSOLETE-DELETEHW-SYMsym_common_queue-Features"><strong>Features</strong></h1><ul><li>Can map nChIn Flows to nQueue queues to nVC vcs.</li><li>Implements the queuing functionality of the Common Layer.</li><li>TODO: Data Channel Optional for Queues</li></ul><p><br/></p><div class="page view"><div class="wiki-content"><h1 id="OBSOLETE-DELETEHW-SYMsym_common_queue-I/O"><strong>I/O</strong></h1><p>var topSmiOutParams = Object.assign({},smiParams);<br/>topSmiOutParams.nSmiVC = nVc;<br/>topSmiOutParams.nSmiDPvc = nVc;</p><p>var interfaceFunc = new obj.userLib[&quot;InterfaceSMI&quot;];<br/>var requestInterfaceOut = interfaceFunc.getSignalsBundle(topSmiOutParams)['ndp_'];<br/>var dataInterfaceOut = interfaceFunc.getSignalsBundle(topSmiOutParams)['dp_'];</p><p>var requestInterfaceIn = interfaceFunc.getSignalsBundle(topSmiInParams)['ndp_'];<br/>var dataInterfaceIn = interfaceFunc.getSignalsBundle(topSmiInParams)['dp_'];</p><p>if(externalDepnd) {<br/>   requestInterfaceOut.dependency = 1;<br/>   requestInterfaceIn.dependency = 1;</p><p>   requestInterfaceOut.dependency_seqnum = requestInterfaceIn.msg_seqnum;<br/>   requestInterfaceIn.dependency_seqnum = requestInterfaceIn.msg_seqnum;<br/>}</p></div><p>u.interface('a_', 'slave', clkInterface, []);</p><p>if(nQueue &gt; 1) {<br/>u.port('input', 'in_queue' , log2ceil(nQueue)); <br/>}</p><div class="wiki-content"><p>u.interface('req_in_', 'slave' , requestInterfaceIn, []);<br/>u.interface('req_out_', 'master', requestInterfaceOut, []);<br/>u.interface('data_out_', 'master', dataInterfaceOut, []);<br/>u.interface('data_in_', 'slave', dataInterfaceIn, []);</p><p>if(rateLmtEn) {<br/>   for(let i = 0; i &lt; nQueue; i++) {<br/>      u.port('output', 'queue_'+i+'_len' , requestInterfaceIn.msg_len); <br/>   }<br/>   u.port('output', 'queue_selected' , nQueue); <br/>   u.port('input', 'queue_block' , nQueue); <br/>   u.port('input', 'queue_demote' , nQueue);<br/>}</p><h2 id="OBSOLETE-DELETEHW-SYMsym_common_queue-Parameters"><strong>Parameters</strong></h2><p>{</p><p>   bypass : int , // 0 - Impliment Queue Functionality, 1 - Just a single channel pass through.</p><p>   nChIn : int , // Number of Channels coming in. This number needs to match the width of the valid on the incoming data and request interfaces.</p><p>   nQueue : int , // The number of queues that a transaction can be mapped to.</p><p>   nVc : int , // The number of VCs that a queue could be mapped to.</p><p>   arbType : string , // The type of arbitration that will be used to select between Queues and VCs</p><p>   queue2Out : array,  // The mapping of which VC each queue maps to</p><p>   numPri : int , // The number of prioritites</p><p>   maxSdu : int, // The largest size of a transaction in bytes. </p><p>   queueDepth : int,  // The depth of all the request queues. </p><p>   externalDepnd : bool, // Indicates if two signals need to be added to the request path. (depnd, depnd_seqnum). Specifically used to get dependencies from the Context to the Reorder Buffer. (Should Abstract and make Generic)</p><p>   rateLmtEn  :bool, // Indicates if a rate limiter is instantiated to regulate the queues</p><p>   queuePriMap : array, // Array of priorities to be assigned to each queue</p><p>   queueSecPriMap : array, // Array of secondary priorities to be assigned to each queue. To be used if the rate limiter demotes the queue.</p><p>   queueVldOnPacket : boolean, // Indicates if a queue has to have a full packet before presenting valid to the sym_sw_arb</p><p>   smiParams : object, // Parameters of the SMI interface going in and out</p><p>   arbWeights : object, // Weights to be used by the sym_smi_arb</p><p>   mstrArbLck : bool, // mstrArbLck to be used by sym_smi_arb</p><p>   vcLckStyleVld : bool, // vcLckStyleVld to be used by sym_smi_arb</p><p>   mstrLckStyleVld : bool, // mstrLckStyleVld to be used by sym_smi_arb</p><p>   masterArbRdyAware : bool, // masterArbRdyAware to be used by sym_smi_arb</p><p>   clkInterface : object, // The incoming Clock Interface</p><p>}</p><h1 id="OBSOLETE-DELETEHW-SYMsym_common_queue-ModulesUsed"><strong>Modules Used</strong></h1><p>sym_pipe_adapter</p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16164560/OBSOLETE-DELETE+HW-SYM+sym_smi_arb" data-linked-resource-id="16164560" data-linked-resource-version="9" data-linked-resource-type="page">OBSOLETE-DELETE HW-SYM sym_smi_arb</a></p><p>sym_routing_arb </p><p><strong style="font-size: 24.0px;">Description</strong></p><h2 id="OBSOLETE-DELETEHW-SYMsym_common_queue-Summary">Summary</h2></div></div><p>The sym_common queue is a library block used by the CTL layer to convert a SMI interface with a specific amount of VCs to another SMI interface with a different number of VCs going through an arbitrary number of queues.</p><p>These queues  can store transactions and their corresponding data. Each queue can be regulated by an external rate limiter in addition to an external credit manager in the future. </p><h2 id="OBSOLETE-DELETEHW-SYMsym_common_queue-Assertions">Assertions</h2><p>For Each Channel</p><p>ASSERT_COMMONQ_IN_\=i=\_HIT : Hit the channel coming in.</p><p>For Each Queue:</p><p>ASSERT_COMMONQ_QUEUE_\=queue=\_HIT : Hit the specific queue.</p><p>For Each VC</p><p>ASSERT_COMMONQ_OUT_\=o=\_HIT : Hit a specific VC out</p><h2 id="OBSOLETE-DELETEHW-SYMsym_common_queue-Mapping">Mapping</h2><p>The sym_common_queue has the ability to take in nCh channels in, map then to nQueues, and then arbitrate between nQueues to drive nVcs using the <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16164560/OBSOLETE-DELETE+HW-SYM+sym_smi_arb" data-linked-resource-id="16164560" data-linked-resource-version="9" data-linked-resource-type="page">OBSOLETE-DELETE HW-SYM sym_smi_arb</a></p><p>The incoming transaction will have an assigned queue according to the queue signal coming in.  The queue will then map to a VC through the vcMap parameter. </p><h2 id="OBSOLETE-DELETEHW-SYMsym_common_queue-BlockDiagramandFunction">Block Diagram and Function</h2><h3 id="OBSOLETE-DELETEHW-SYMsym_common_queue-NDP/DPFlow">NDP/DP Flow</h3><p>The ndp of a transaction simply maps to a queue.</p><p>When the ndp comes in on a specific channel that channel captures the queue it was mapped to. This will be used by the dp of than channel to route to a queue. </p><p>This means for each channel the dp will be held until the queue is available from its respective ndp syncing the two buses.</p><p>The queues themselves act like a single channel SMI input to the sym_smi_arb that map to a multiple channel SMI output</p><p>See <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16164560/OBSOLETE-DELETE+HW-SYM+sym_smi_arb" data-linked-resource-id="16164560" data-linked-resource-version="9" data-linked-resource-type="page">OBSOLETE-DELETE HW-SYM sym_smi_arb</a> for more detail about how the queues map to the outgoing VCs.</p><h3 id="OBSOLETE-DELETEHW-SYMsym_common_queue-PipeDepth">Pipe Depth </h3><p>All the sym_pipe_adapters are set to queueDepth.</p><h3 id="OBSOLETE-DELETEHW-SYMsym_common_queue-QueueValidonPacket">Queue Valid on Packet</h3><p>If queueVldOnPacket is true that means a queue has to contain a full packet before valid is presented to the sym_sw_arb. The depth must be able to hold a maxPduSz packet to prevent the possibility of deadlock. This will be ignored if there is only a single queue in the sym_common_queue block. </p><h3 id="OBSOLETE-DELETEHW-SYMsym_common_queue-Priority(OptionalFunctionality)">Priority (Optional Functionality)</h3><p>Inside the sym_common_queue the priority field will be mapped according to queuePriMap and queueSecPriMap. This is done as a transaction is leaving the queue and entering the sym_smi_arb.</p><p>If these parameters are not defined and/or empty the incoming priority will flow through the block.</p><h3 id="OBSOLETE-DELETEHW-SYMsym_common_queue-BlockingandFeedback(OptionalFunctionality)">Blocking and Feedback (Optional Functionality)</h3><p>The sym_common_queue is able to take in external control from a rate limiter and credit manager to block specific queues from sending transactions. All blocking is done on the output of the queues.</p><p>In addition the common queue provides feedback to the rate limiter and credit manager about what transaction was selected from arbitration for each queue.</p><h3 id="OBSOLETE-DELETEHW-SYMsym_common_queue-BlockDiagram">Block Diagram</h3><div class="page view"><div class="wiki-content"><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="900" src="https://arterisip.atlassian.net/wiki/download/attachments/16161182/sym_common_queue_pic.PNG?api=v2"></span></p><h3 id="OBSOLETE-DELETEHW-SYMsym_common_queue-ImplementationandSizeNote">Implementation and Size Note</h3><p>It is assumed that most of the depth and buffering should be done inside the network and not inside this block this why the pipes do not have memories. </p></div><p><br/></p></div>