<p>Machine learning will be on interconnect component instances.  We expect to have a dataset large enough for ML.</p><p>Target will be to pre-characterize 2-3 libraries and extrapolate to other libraries / process nodes.</p><p>Scripts will be for Physical Synthesis and possibly PnR.  </p><p>Characterization</p><ul style="list-style-type: square;"><li>Will have a parameter randomizer at the very start of the flow to generate a big design space</li><li>Will the process have synthesis flags?  Possibly yes.  Not all settings will have impact but others will like enabling clock gating.<ul style="list-style-type: square;"><li>Feedback on what synthesis flags needed will be valuable?</li></ul></li><li>Questions on how to characterize Ncore units and dealing with memory placement.</li><li>Need more dialogue on Ncore unit characterization (Benny, Khaleel)</li><li>Need an overall strategy for dealing with memories.</li><li>Need IO constraints on the blocks</li><li>Will bundle to compress timing information</li><li>ML will extract data from the databases to give us actionable models</li><li>Can also use learning on which parameters to use and which matter</li><li>Divided in 3 sets: Learning data, test data and validation data</li></ul><p>Demo</p><ul><li>Clock domains will be either derived or in future user can draw the bounding box</li><li>Discussion on simultaneously optimizing placement and timing</li><li>Grid search identifies where they can place if the center of gravity is not placeable</li><li>Does not yet optimize for congestion</li><li>Plan to do simulated annealing or similar flow to address any remaining violations or overlap.  Or could accept some overlap because they are soft cores.</li><li>Timing calculated using Manhatten distances routing around blockages.</li><li>Algorithm chooses shortest.  At the moment we do not consider congestion.  Does not consider layers of metal.</li><li>Uses mm/nS can traverse.  Might be useful to have multiple measures for each metal layer.</li><li>Might have option to show violations as how we have calculated them.</li><li>Using sequential pipeline addition.  Congestion and having to figure out to go amongst multiple options will be the challenge.</li><li>This is a single fanout problem.  But switches can be combinational so we do have the problem there.  Recursively determines worst-case combinatorial path from source to destination and removes this from the budget.</li><li>It would be good to characterize the algorithm as components grow.  We should build some complex benchmarks and characterize - especially with congestion.</li><li>Algorithm is deterministic.  Will support ECO mode.  Could be that we only allow changes in a particular channel.  Need to determine the set of scenarios to expose this capability in the GUI and the algorithm.</li><li>Can we add latency constraints?</li><li>We would like a latency report?  We have one.  Can we overlay on a grid to display why latency is what it is?</li><li>Big chip example - valuable to add more constraints/blockages in the middle.</li><li>Eric to discuss with Federico if there is any way to provide information from NXP design to run it through our flow.</li></ul><p> </p>