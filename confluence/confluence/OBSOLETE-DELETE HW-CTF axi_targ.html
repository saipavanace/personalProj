<p><style>[data-colorid=llspb5sy8z]{color:#333333} html[data-color-mode=dark] [data-colorid=llspb5sy8z]{color:#cccccc}[data-colorid=f034cb3or8]{color:#333333} html[data-color-mode=dark] [data-colorid=f034cb3or8]{color:#cccccc}</style><br /></p><h2 id="OBSOLETE-DELETEHW-CTFaxi_targ-Modulename:">Module name<strong style="font-size: 14.0px;">:</strong></h2><p><span>axi_targ</span></p><h2 id="OBSOLETE-DELETEHW-CTFaxi_targ-JavaScriptparameters:">JavaScript parameters<strong style="font-size: 14.0px;">:</strong></h2><p>&quot;axiRdEn&quot;:&nbsp;&nbsp;int, 1 - Enable AXI read data and read address channel. 0 - disable read data and read address channels.<br />&quot;axiWrEn&quot;:&nbsp; int,&nbsp;1 - Enable AXI write data and write address channel. 0 - disable write data and write address channels.<br />&quot;axiPipeR&quot;: int, //&nbsp;Depth of the pipe in the read-response channel datapath.<br />&quot;axiPipeB&quot;: int,&nbsp; //&nbsp;&nbsp;Depth of the pipe in the write-response channel datapath.<br />&quot;axiPipeW&quot;: int, //&nbsp;Depth of the pipe in the write-data channel datapath.<br />&quot;axiPipeAW&quot;: int, //&nbsp;&nbsp;Depth of the pipe in the write-address channel datapath.<br />&quot;axiPipeAR&quot;: int,&nbsp; //&nbsp;Depth of the pipe in the read-address channel datapath.&nbsp;&nbsp;</p><h2 id="OBSOLETE-DELETEHW-CTFaxi_targ-Interfaces:">Interfaces<strong style="font-size: 14.0px;font-weight: bold;">:</strong></h2><p>clkInterface:&nbsp;A slave interface of type&nbsp;<a class="external-link" href="https://confluence.arteris.com/display/ENGR/InterfaceCLK" rel="nofollow">InterfaceCLK</a></p><p>ctlInterface : A slave interface of type&nbsp;<a class="external-link" href="https://confluence.arteris.com/display/ENGR/InterfaceCTL" rel="nofollow">InterfaceCTL</a></p><p>axiInterface: A master interface of type InterfaceAXI</p><h2 id="OBSOLETE-DELETEHW-CTFaxi_targ-ModulesUsed">Modules Used</h2><p>ctl_axi_req</p><p>ctl_axi_req_dp</p><p>axi_ctl_resp</p><p>axi_ctl_resp_dp</p><p><a class="external-link" href="https://confluence.arteris.com/display/ENGR/sym_common_splitter" rel="nofollow">sym_common_splitter</a></p><h2 id="OBSOLETE-DELETEHW-CTFaxi_targ-BlockDiagram">Block Diagram</h2><p><br /></p><p><strong><strong><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image confluence-external-resource image-center" src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" data-image-src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" loading="lazy" /></span></strong></strong></p><p style="text-align: center;"><strong><strong>axi_targ (Top)</strong></strong></p><p style="text-align: center;"><br /></p><h2 id="OBSOLETE-DELETEHW-CTFaxi_targ-Description">Description</h2><p>This component implements the AXI Native Layer in the target ATUs (<a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16157082/OBSOLETE-DELETE+HW-CTF+atut_axi" data-linked-resource-id="16157082" data-linked-resource-version="2" data-linked-resource-type="page">OBSOLETE-DELETE HW-CTF atut_axi</a>). It translates requests on the CTL interface to requests on the AXI AW and AR channels. It also translates the responses from the AXI read and write response channels to CTL response sub-interface.</p><p>The internal AXI_REQ interface is same as an AXI_AW or AXI_AR channel, except it has an additional signal '<em>type</em>' that indicates whether the request is a read-request or a write-request. The <em>type</em> signal is used to generate&nbsp;<em>valid</em> signals on AW and AR channels of the master AXI interface.&nbsp;</p><p>The internal CMD_R (Read-command) interface is used to carry enough information required to create a read-response command on CTL RESP in the axi_ctl_resp block.</p><p>The axi_targ block may receive transactions of greater length than that supported by the native axi protocol (axlen &gt; 15 for fixed/wrap, or axlen &gt; 255 for incr). When true, the native layer splits the transaction into multiple transactions of the allowable length.</p><p>Below are details of the different sub-blocks used in axi_targ:</p><h3 id="OBSOLETE-DELETEHW-CTFaxi_targ-ctl_axi_req">ctl_axi_req</h3><p>This sub-block converts read, write requests on CTL REQ channel to requests on AXI_REQ interface. The block uses the <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16157025/HW-CTF+class+CTL2AXI" data-linked-resource-id="16157025" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF class CTL2AXI</a>&nbsp;JS library and tables to do the mapping between the CTL and AXI signals, except for the length signal. The length field in CTL REQ is in bytes and hence needs to be converted to beats as per AXI protocol.</p><p>The pseudocode to create burst length is as follows:</p><pre>const maxStartOffset = axiBSize===1 ? &quot;ctl_req_addr[0]&quot; : &quot;ctl_req_split_addr[&quot;+(axiBSize-1)+&quot;:0]&quot;;<br />const maxEndOffset = axiBSize===1 ? &quot;num_bytes[0]&quot; : &quot;num_bytes[&quot;+(axiBSize-1)+&quot;:0]&quot;;<br />const zeros = wCtlLen===axiBSize ? &quot;&quot; : (wCtlLen-axiBSize)+&quot;'h0&quot;;<br />assign mask_shift = \=ctlWidth('txn_hdr_burstSize')+&quot;'h&quot;+axiBSize=\ - ctl_req_split_txn_hdr_burstSize;<br />assign offset_mask = ~\=axiBSize+&quot;'h0&quot;=\ &gt;&gt; mask_shift;<br />assign start_addr_offset = \=maxStartOffset=\ &amp; offset_mask;<br />assign end_addr_offset = \=maxEndOffset=\ &amp; offset_mask;<br />assign start_addr_unaligned = |start_addr_offset;<br />assign end_addr_unaligned = |end_addr_offset;<br />assign num_bytes = ctl_req_split_len + {\=zeros+&quot;,&quot;=\start_addr_offset} + \=wCtlLen+1=\'d1;<br />assign num_beats = (num_bytes &gt;&gt; ctl_req_split_txn_hdr_burstSize) + {\=wCtlLen+&quot;'h0&quot;=\,end_addr_unaligned};<br />assign num_beats_dec = num_beats - 1'b1;<br />assign ax_len = num_beats_dec[\=wAxiLen-1=\:0];</pre><p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image confluence-external-resource image-center" src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" data-image-src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" loading="lazy" /></span></p><p style="text-align: center;"><strong style="text-align: center;"><strong>ctl_axi_req<br /><br /></strong></strong></p><h4 style="text-align: left;" id="OBSOLETE-DELETEHW-CTFaxi_targ-splitter"><strong style="text-align: center;"><strong>splitter</strong></strong></h4><p>The logic is required if the native axi target layer is to be sent axi transactions greater than 16 beats for fixed/wrap or 256 beats for incr. (The current use case is transactions at an axi initiator where the number of bytes in a single beat of a wide transaction would be converted to greater than 16/256 beats on a narrower axi target. For example, a single beat of a 2048 bit initiator has contains more bytes (256) than 256 beats of a 32-bit wide target bus (1024).)</p><p style="text-align: center;"><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image confluence-external-resource image-center" src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" data-image-src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" loading="lazy" /></span><strong>ctl_axi_req_splitter</strong></p><p style="text-align: left;">The response is first passed through the <a class="external-link" href="https://confluence.arteris.com/display/ENGR/sym_common_splitter" rel="nofollow">ctl_init_req_split</a> macro, also used by the initiator ctl block. This block splits a single transaction into multiple transactions if required. The output sequentially transmits each new sub-transactions using a ctl interface with some sideband signals. The sideband signals are:</p><ol><li style="text-align: left;">split_required - is this transaction part of a split?</li><li style="text-align: left;">split_last - is this transaction the last part of a split?</li><li style="text-align: left;">dp beat count - how many data beats are associated with this transaction if this is a write?</li></ol><h5 id="OBSOLETE-DELETEHW-CTFaxi_targ-reads">reads</h5><p>If the transaction is a read, then an entry is pushed onto the read rlast queue with the ordering id, and an indicator whether this read was a non-final read of a split transaction. All reads, plit or not, are pushed onto the queue. The age queue structure has the following features:</p><ol><li>the age of a read is tracked because there can be multiple outstanding reads with the same ordering id</li><li>an entry can be popped from the queue out of order because read return data is not guaranteed to be in order</li></ol><p>An entry is popped from the queue upon receiving a query from the axi_ctl_resp_dp block that matches the oldest entry of that tag (ordering id). The 'non-final-read' indicator is returned to the axi_ctl_resp_dp block so it can be used to squash the r_last assertion.</p><h5 id="OBSOLETE-DELETEHW-CTFaxi_targ-writes">writes</h5><p>If the transaction is a write, then an entry is pushed onto the write bresp queue with the ordering id and an indicator whether this write was a non-final write of a split transaction. All writes, split or not, are pushed onto the queue. The age queue structure has the following features:</p><ol><li>the age of a write is tracked because there can be multiple outstanding writes with the same ordering id</li><li>an entry can be popped from the queue out of order because bresp is not guaranteed to be in order</li></ol><p>An entry is popped from the queue upon receiving a query from the axi_ctl_resp block that matches the oldest entry of that tag (ordering id). The 'non-final-write' indicator is returned to the axi_ctl_resp block so it can be used to squash the bresp assertion.</p><p>If the transaction is a write, then an entry is also pushed onto the write wdata fifo with the expected number of beats of write data expected for that write. This fifo does not need to track age because write data is not interleaved and guaranteed to be in order.</p><p>An entry is popped from the fifo upon receiving a query from the ctl_axi_req_dp block. The number of beats is sent back to the ctl_axi_req_dp block and is used there to help track which beat of a write data tenure needs to have a w_last asserted.</p><h3 style="text-align: left;" id="OBSOLETE-DELETEHW-CTFaxi_targ-ctl_axi_req_dp">ctl_axi_req_dp</h3><p>This sub-block converts request data on CTL REQ DP channel to write-data on AXI W channel.</p><p>When the splitter is not required, there is no logic here and mostly through-connections.</p><p>If the splitter is present, this block may receive a long stream of outbound write data that has been split. When a new write is received, this block:</p><ol><li>queries the splitter context block to determine the new length beat_count of the incoming stream.</li><li>saves the beat_count, monitors the data tenure in progress,</li><li>then inserts a w_last when beat_count beats have been received</li><li>return to step 1</li></ol><p>The dp remains unaware of how many times the original transaction has been split. After it has inserted w_last, it just performs a new query on for the next w_valid. Therefore, multiple queries are performed for the original write data stream.</p><h3 id="OBSOLETE-DELETEHW-CTFaxi_targ-axi_ctl_resp">axi_ctl_resp</h3><p>This sub-block selects between write and read-responses on AXI W channel and CMD_R interface respectively to drive the CTL_RESP (NDP) channel. The information on the CMD_R interface ( generated by the axi_ctl_resp_dp sub-block) is used to create the read-response command on the CTL RESP.</p><p>If the splitter is present, this block may receive bresp responses that need to be dropped so that only one bresp response is returned for the original write. When a new b_valid is received, this block:</p><ol><li>queries the splitter context block using the bresp id to determine if this bresp should be dropped.</li><li>drops the bresp response if instructed by the context block</li></ol><p>The axi_ctl_resp remains unaware of how many times the original transaction has been split. Multiple queries are performed for the original write data stream.</p><p><span data-colorid="f034cb3or8" style="text-decoration: none;">The block employs a simple 2-state round-robin arbiter which keeps track of the last response type (read or write). When both read and write responses are valid on AXI, read wins if the last response type granted was a write, otherwise write wins.</span></p><p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image confluence-external-resource image-center" src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" data-image-src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" loading="lazy" /></span></p><p style="text-align: center;"><span data-colorid="llspb5sy8z" style="text-decoration: none;"><strong>axi_ctl_resp</strong></span></p><h3 id="OBSOLETE-DELETEHW-CTFaxi_targ-axi_ctl_resp_dp">axi_ctl_resp_dp</h3><p>If the splitter is present, this block may receive r_last assertions that need to be dropped so that only one r_last response is returned for the original read. When a new r_last is received, this block:</p><ol><li>queries the splitter context block using the read response id to determine if this r_last should be dropped.</li><li>drops the r_last response if instructed by the context block</li></ol><p>The axi_ctl_resp_dp remains unaware of how many times the original transaction has been split. Multiple queries are performed for the original read data stream.</p><p>This sub-block generates read-response command on the CMD_R (which in turn is used to generate CTL RESP read-commands in axi_ctl_resp block) as well as read-response data on the CTL RESP DP channel, from the AXI R channel.</p><p>The CTL interface protocol has the following requirements that need to be met:</p><ol><li>In addition to the per-beat response and data on the CTL_RESP_DP channel, each response must have an associated command on the CTL_RESP (NDP) channel.</li><li>If read-interleaving is enabled, and the response ID on AXI R channel changes before r_last is asserted:<ol><li>The dp_dummy signal must be asserted to signal the end of current stream of response data-beats.</li><li>A command must be sent on CTL_RESP (NDP) channel for the new stream of response data-beats with the new ID.</li></ol></li></ol><p>A state-machine is implemented to meet the above requirements for CTL protocol. It controls the assertion of&nbsp;<em>valid</em> signals on the CMD (CMD_R) and DATA (CTL_RESP_DP) channels, and ready on the AXI R channel. The state-machine remembers which channels (CMD, DATA) were busy or ready when a read-response beat arrived and if an ID change or <em>r_last</em>&nbsp;occurred for the previous response-beat.</p><p>The ID change is detected by comparing the saved ID with the current ID on a valid response-beat on AXI R channel. If different it is used to drive the dummy signal. The saved ID is stored or updated every time a command is sent / acknowledged on the CMD_R channel.</p><p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image confluence-external-resource image-center" src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" data-image-src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" loading="lazy" /></span></p><p style="text-align: center;"><strong style="text-align: center;"><strong>axi_ctl_resp_dp</strong></strong></p><p style="text-align: left;"><strong style="text-align: center;"><strong><br /></strong></strong></p><p style="text-align: left;"><strong>State machine description</strong></p><p>The individual states are described below:</p><p><strong>CMD_DATA_NOT_SENT</strong>: This is the initial / reset state in which the state-machine awaits a read-response from the AXI R channel. It can also mean that either an&nbsp;<em>r_last</em> on the AXI R occurred or an ID change was detected for the last response data-beat. There are four possibilities when a response beat arrives in this state:</p><ol><li>Both CMD and DATA channels are busy (readies low). Then the state-machine remains in this state.</li><li>Both CMD and DATA channels are ready. Then both CMD and the current response data-beat is sent to CTL. The SM moves to DATA_NOT_SENT state unless it was a single-beat response i.e.&nbsp;if<em> r_last</em> was also asserted.</li><li>CMD channel is ready, but DATA channel is busy. Only CMD is sent, AXI <em>r_ready</em> is not granted, and the SM moves to DATA_NOT_SENT state.</li><li>DATA channel is ready, but CMD channel is busy. Only DATA is sent, AXI&nbsp;<em>r_ready</em> is not granted, and the SM moves to CMD_NOT_SENT state.</li></ol><p><strong>CMD_NOT_SENT</strong>: The SM in this state means that only the first data-beat of the response was sent but not the associated command. The SM waits in this state until CMD channel is ready. When ready, the command is sent and moves to either DATA_NOT_SENT or CMD_DATA_NOT_SENT depending on whether the last response-beat was already sent in the CMD_DATA_NOT_SENT state.</p><p><strong>DATA_NOT_SENT</strong>: The SM in this state means that not all data for a response were sent. Hence the SM waits in this state until it sends the last response-beat ( indicated by&nbsp;<em>r_last&nbsp;</em>) or until there was an ID-change (&nbsp;<em>new_r_id </em> is high ). A dummy is signaled when there is an ID change detected in this state.</p><p>Transitioning to the CMD_NOT_SENT state means that when the CMD channel is busy, there is no need to wait to send the first data-beat or in other words to assert <em>ctl_resp_dp_valid,</em>&nbsp;when in CMD_DATA_NOT_SENT state. This removes valid-on-ready dependency (&nbsp;<em>ctl_resp_dp_valid&nbsp;</em>on&nbsp;<em>cmd_r_ready&nbsp;</em>) which in turn avoids the possibility of a feedback loop or logic loop.</p><p><br /></p><p><strong style="text-align: center;"><strong><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image confluence-external-resource image-center" src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" data-image-src="https://confluence.arteris.com/plugins/servlet/confluence/placeholder/unknown-attachment?locale=en_US&amp;version=2" loading="lazy" /></span></strong></strong></p><p><br /></p><p style="text-align: center;"><strong>State Machine diagram for axi_ctl_resp_dp (All state-transitions are qualified by axi_r_valid)</strong></p><p><br /></p><p><br /></p><p><strong style="text-align: center;"><strong><br /></strong></strong></p><p><strong><strong><br /></strong></strong></p><p><br /></p><p><br /></p>