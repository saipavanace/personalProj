<div class="wiki-content"><h2 id="UndocommandforRemoveObject-RemoveObjectandCreateObjectoperations">Remove Object and Create Object operations</h2><p><strong>Remove Object</strong> operation will remove target object and all of it's sub-objects recursively, as well as trigger all side effects caused by removal.</p><p><strong>Execute operation</strong>: Remove Object operation.</p><p><strong>Undo operation</strong>: Restore Object operation.</p><p><strong>Redo operation</strong>: repeat the Remove Object operation</p><p><strong>Data</strong>:</p><p>State - execute / redo, undo - reflects the state of the undo command. After execute(), redo() calls or after an object construction (assuming the command records an action equivalent to execute()) the object will be in execute / redo state. After executing undo(), the object will be in undo state.</p><p>The state changes the meaning of other held data.</p><p>Pointer to the moved object / copy of the object for the execute / redo state. Pointer to AdmOwner object for the undo state.</p><p>The Remove Object undo command in execute / redo state holds ownership of the removed objects. If the undo history clear() is requested and the command in being destroyed it should dispose held resources.</p><p>Â </p><p><strong>Create Object</strong> operation creates a new sub-object.</p><p><strong>Execute operation</strong>: Create Object<sup>[1]</sup> operation.</p><p><strong>Undo operation</strong>: Remove Object.</p><p><strong>Redo operation</strong>: Restore Object<sup>[2]</sup>.</p><p><strong>Data</strong>: Create Object: parent object, type and name of child object, User Parent if applicable. Remove/Restore Object: Same data used for Remove Object undo command operation.</p><p><a class="external-link" href="https://portal.softeq.com/pages/createpage.action?spaceKey=ARTERIS&amp;title=1&amp;linkCreation=true&amp;fromPageId=122225755" rel="nofollow">1</a> This command could be simplified to creating, removing, re-creating the object, but this might break pointer consistency for future undo operations on the stack, if they use pointer.</p><p><a class="external-link" href="https://portal.softeq.com/pages/createpage.action?spaceKey=ARTERIS&amp;title=2&amp;linkCreation=true&amp;fromPageId=122225755" rel="nofollow">2</a> The Create Object command is complementary to Remove Object command except for the <em>execute</em> part.</p><h2 id="UndocommandforRemoveObject-TemporaryStorageforremovedobjects">Temporary Storage for removed objects</h2><p>Regardless of implementation chosen removed object would require a separate storage location to hold removed objects. It could be implemented as an ObjectArray in current ParameterFacet placed alongside the root object. This way it would share the same ParameterFacetID and necessary type information as objects in the NDL model under root and won't interfere with serialization / de-serialization. The stored objects might require an additional intermediate node to store metadata for deleted objects or to isolate them within unique namespaces.</p><h2 id="UndocommandforRemoveObject-Renamingandnamespaceseparation">Renaming and namespace separation</h2><p>The temporary storage could be implemented as an ObjectArray holding an intermediary objects, which are a subclass of AdmOwner. The name of the object could be randomized and uniquified. The object itself will hold a removed object and act as it's parent. This way all of the stored removed objects would have a unique name prefix.</p><h2 id="UndocommandforRemoveObject-RemoveObjectimplementation">Remove Object implementation</h2><p>Undo command for Remove Object operation could be implemented in 2 ways:</p><ol><li>Deep copy + remove</li><li>Move</li></ol><h3 id="UndocommandforRemoveObject-Deepcopy+remove">Deep copy + remove</h3><ol><li>Make a deep copy of the object to a location in a temporary store for removed objects.</li><li>Remove the object from NDL and DAL model.</li></ol><p>The undo command would store the location of the object's copy.</p><p>The act of copying and removing the old object would invalidate pointers to it. Currently all other undo commands use pointers to AdmOwner and would have to be rewritten to search for the object by it's path instead.</p><h3 id="UndocommandforRemoveObject-Move">Move</h3><ol><li>Detach an object from it's current parent.</li><li>Move it to a new destination in temporary storage.<br/>2.1 Move NDL object representation and execute all side effects as if the object was removed<br/>2.2 Move DAL object representation.</li></ol><p>The undo command would store the new location of moved object in temporary store.</p><p>The detach operation should have the same side-effects as existing removeObject() operation and could share/inherit part of the existing code. The detach operation could use an interface parallel to removeObject() - detachObject(). The implementation could be split into the public API and the implementation API. The implementation part should have a method to remove and destroy an existing object and a method to move the object. The public part could select to use either of implementation methods depending.</p></div>