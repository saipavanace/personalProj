<h1 id="NcoreTask_SchedulerforDirectedtesting-Requirement">Requirement</h1><p>Ncore DV environements of different blocks are highly randomized and cerating directed tests is very hard. </p><p>A common solution must be created for all DV environments including IP and FSYS levels.</p><p>the idea is to be able to  execute/control different parts of a global test like test sequence, register configuration, wait time…</p><p /><h1 id="NcoreTask_SchedulerforDirectedtesting-Description">Description</h1><p>In order to control the execution of any part of the code and not only test/uvm sequences, the task scheduler is created for this purpose. It’s a singleton that coud be insatantiated in the DV environment. By this way all components of the Testbench will be able to register their tasks into it. The first implementation is including following routines but it could be enhanced in the future based on different requirements:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">  //class Interface 
  extern static function task_scheduler get_instance();

  //add an event to the main task array
  extern function void task_schedule (string task_idx);//, integer timer_wait = 0);

  //wait for tigger of task start of execution
  extern task task_wait_start_exec(string task_idx);  

  //tigger end of execution of the task
  extern function void task_trig_end_exec(string task_idx);

  //create a dependancy between different tasks
  extern function void task_add_dependancy(string task_idx, string task_dep_list[]);

  //run task: create process for waiting and trigging events according to inter-dependancy array
  extern task run ();

  //printing tasks array
  extern function void print_scheduled_tasks();</pre>
</div></div><p /><h1 id="NcoreTask_SchedulerforDirectedtesting-IntegrationanduseinTB">Integration and use in TB</h1><ul><li><p>the task scheduler is under dv/common/lib_tb/task_scheduler_pkg.sv</p></li><li><p>IP owners should follow these steps to let using task_scheduler in IP and FSYS env:</p><ul><li><p>Implement <code>add_scheduler_txn</code> function. This function will be called by the uvm_test to create a task to be executed (user need) and to register this task in the scheduler. In the below example, the function argument could be any type especially an uvm_object that will let the creation of the needed task with needed attributes. Note that it’s mandatory to call <code>task_scheduler_i.task_schedule(task_name);</code> to register the task in the task_scheduler and return the task id wich is a string.</p></li></ul></li></ul><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">function string chi_aiu_vseq::add_scheduler_txn( &lt;arguments&gt;);
      string task_name;
        ......
        .......

    task_scheduler_i.task_schedule(task_name);
    return task_name;
endfunction: add_scheduler_txn</pre>
</div></div><ul><li><p /><ul><li><p>use of <code>task_wait_start_exec</code> to wait for trigging the task execution and <code>task_trig_end_exec</code> to trig the end of the task execution like following:</p></li></ul></li></ul><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">        task_scheduler_i.task_wait_start_exec(task_name);
        #(10ns) `uvm_info($psprintf(&quot;chi_aiu_vseq_req_seq_q[%0d]&quot;, ID), $sformatf(&quot;[task_scheduler] Executing taskid= %0s&quot;, task_name), UVM_NONE)
        //put this in post_hook with if scheduler is on
        task_scheduler_i.task_trig_end_exec(task_name);</pre>
</div></div><ul><li><p>IP/FSYS user must implement following in testcase:</p><ul><li><p>instatntiate the scheduler</p></li></ul></li></ul><p><code>task_scheduler_i = task_scheduler::get_instance();</code></p><ul><li><p /><ul><li><p>call <code>add_scheduler_txn</code> as needed</p></li><li><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">task_schedul_list_req_&lt;%=idx%&gt;[0] = m_chi&lt;%=idx%&gt;_vseq.add_scheduler_txn(&quot;req_seq_q&quot;);
task_schedul_list_req_&lt;%=idx%&gt;[1] = m_chi&lt;%=idx%&gt;_vseq.add_scheduler_txn(&quot;req_seq_q&quot;);</pre>
</div></div><p /></li><li><p>create dependancies between tasks</p></li><li><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">    task_scheduler_i.task_add_dependancy(task_schedul_list_dat_0[0], &#39;{task_schedul_list_req_0[0],task_schedul_list_req_0[1]});
    task_scheduler_i.task_add_dependancy(task_schedul_list_rsp_0[1], &#39;{task_schedul_list_dat_1[1]});
    task_scheduler_i.task_add_dependancy(task_schedul_list_dat_1[0], &#39;{task_schedul_list_req_0[2]});</pre>
</div></div><p /></li><li><p>execute the run task to let scheduled tasks to be executed in the defined way.</p></li><li><p><code>task_scheduler_i.run();</code></p></li></ul></li></ul><p style="margin-left: 90.0px;"></p>