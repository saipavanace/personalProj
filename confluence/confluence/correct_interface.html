<div class="wiki-content"><style>[data-colorid=gxhw1vujxv]{color:#707070} html[data-color-mode=dark] [data-colorid=gxhw1vujxv]{color:#8f8f8f}</style><h1 id="correct_interface-SWVisible:"><strong>SW Visible:</strong></h1><p>no</p><h1 id="correct_interface-Parameters:"><strong>Parameters:</strong></h1><h2 id="correct_interface-Javascript:"><strong>Javascript:</strong></h2><pre>{</pre><pre>  &quot;direction&quot; : &quot;forward&quot; or &quot;backward&quot; // &quot;forward&quot; means protection is being generated for outputs. &quot;backyards&quot; for inputs.</pre><pre>  &quot;inInterface&quot; : {&quot;name&quot; : &quot;a_name&quot;, &quot;signals&quot; : {interface def}},</pre><pre>  &quot;outInterface&quot; : {&quot;name&quot; : &quot;a_name&quot;, &quot;signals&quot; : {interface def}},</pre><pre>  &quot;addCorPath&quot; : true or false, // When true, outInterface is always uncorrected and outInterfaceCor is always corrected but a cycle later.</pre><pre>  &quot;outInterfaceCor&quot; : {&quot;name&quot; : &quot;a_name&quot;, &quot;signals&quot; : {interface def}}, // Conditional interface, exists based on addCorPath.</pre><pre>  &quot;clkInterface&quot; : {&quot;name&quot; : &quot;a_name&quot;, &quot;signals&quot; : {interface def}},</pre><pre>  &quot;protectionInterface&quot; : {&quot;name&quot; : &quot;a_name&quot;, &quot;signals&quot; : {interface def}},</pre><pre>  &quot;protectionScheme&quot; : {<a class="external-link" href="https://confluence.arteris.com/display/ENGR/protectionScheme" rel="nofollow">protectionScheme Object</a>}</pre><pre>}</pre><h2 id="correct_interface-Verilog:"><strong>Verilog:</strong></h2><p>N/A</p><h1 id="correct_interface-I/O:"><strong>I/O:</strong></h1><pre>u.interface(<a class="external-link" href="http://ininterface.name/" rel="nofollow">inInterface.name</a>,'slave',inInterface.signals);</pre><pre>u.interface(<a class="external-link" href="http://outinterface.name/" rel="nofollow">outInterface.name</a>,'master',outInterface.signals);&nbsp;</pre><pre>if (addCorePath) {</pre><pre>  u.interface(outInterfaceCor.name,'master',outInterfaceCor.signals);</pre><pre>  u.interface(clkInterface.name,&quot;slave&quot;,clkInterface.signals};</pre><pre>}</pre><pre>u.interface(protection<a class="external-link" href="http://outinterface.name/" rel="nofollow">Interface.name</a>,'master',outInterface.signals);<span style="font-family: Arial , sans-serif;">&nbsp;</span></pre><h1 id="correct_interface-FunctionsUsed:"><strong>Functions Used:</strong></h1><p>getEccWidth</p><p>regNameIfNoHit</p><p>compareInterfaces</p><p>getUniqName</p><p>wiresFromInterface</p><p>assignByBundle</p><h1 id="correct_interface-ModulesUsed:"><strong>Modules Used:</strong></h1><p>logic_tree</p><p>ecc_dec</p><p>ecc_cor</p><p>prot_mux</p><h1 id="correct_interface-Description:"><strong>Description:</strong></h1><p>&nbsp;</p><p>When the mode is forward, the block takes the protection scheme and uses it on the inputs of the inInterface and generates error signals which is outputted on the protectionInterface. <span class="inline-comment-marker" data-ref="a0efe951-cb07-4023-adb1-6575f9e5df0b">The outInterface need not have a prot signal in</span>, but if it does, the prot signal is passed on unmodified to it from the inInterface. The inInterface must and it's width must match the width needed by the protectionScheme. If the protectionStyle allows it, signals in the inInterface associated with that style will be corrected and forwarded to the outInterface. If prot exists in outInterface, it will also be corrected if possible. The inInterface must contain a valid signal to qualify errors on the protectionInterface.</p><p>When the mode is backward, the block takes the protections scheme and applies it on the inputs of the outInterface and generates error signals which is an outputted on the protectinInterface. The inInterface need not have a prot_b signal in, but if it does the prot_b signal is passed unmodified to it from the outInterface. The outInterface must and its width must match the width needed by the protectionScheme.&nbsp;If the protectionStyle allows it, signals in the outInterface associated with that style will be corrected and forwarded to the inInterface. If prot_b exists in inInterface, it will also be corrected if possible.</p><p>The protectionInterfaces is an array, because multiple protectionStyles can be applied in a direction, so each style needs a protectionInterface to report to. For ecc styles, index is never used, but syndrome is optional.</p><p>The above description applies when addCorePath = false. When addCorePath = true a second output interface, outInterfaceCor, is added that always presents the corrected data, while outInterface will always present uncorrected data. The two readies from the two outInterfaces will be ORed together and used internally for state transitions. The valid on outInterfaceCor starts out always being held low. When a correctable error is detected, valid on the outInterface will be forced low starting on the next cycle and until there is a gap, either caused by a bubble on the input side or the lack of a ready on the output side. Valid on outInterfaceCor will be allowed to go high on the cycle following a correctable error and will be forced low when there is a gap.</p><p>Internally there will be a state bit controlling which mode the block is in: Corrected Mode or UnCorrected Mode. The mode transitions from UnCorrected Mode to Corrected Mode on the cycle after a correctable error, and from Corrected Mode to Uncorrected Mode a cycle after a gap.</p></div><div><div><a class="external-link" href="https://confluence.arteris.com/" rel="nofollow"><span data-colorid="gxhw1vujxv" class="aui-icon aui-icon-small aui-iconfont-like">&nbsp;</span></a></div></div>