<p><style>[data-colorid=x0qf825hc7]{color:#091e42} html[data-color-mode=dark] [data-colorid=x0qf825hc7]{color:#bdd2f6}</style><br /></p><h1 id="QoSArbiter-module_name"><strong>module_name</strong></h1><p>com_arb_qos_age</p><h1 id="QoSArbiter-parameters"><strong>parameters</strong></h1><h2 id="QoSArbiter-java_script:"><strong>java_script:</strong></h2><pre>{<br />        &quot;assertOn&quot;: assertion, boolean
	&quot;nPorts&quot; : number of requestor ports, a positive integer<br />        &quot;nEntries&quot; : number of entries in the age buffer, a positive integer<br />        &quot;nPrio&quot; : number of priority levels, a positive integer<br />        &quot;wPrio&quot; : the width of the priority, a positive integer</pre><pre><span>}<br /><br /></span></pre><p>u.paramDefault('assertOn', 'int', 0);</p><p>u.paramDefault('usePipe',&nbsp; 'int', 0); //When 1 pipeline is enabled, and the pipeOption specifies the pipeline options.</p><p>u.paramDefault('pipeOption', 'int', 0); //When 0, pipeline point is at the internal find first result signal &ldquo;pop_vec&rdquo;. &nbsp;When 1, pipeline point is the input &ldquo;req_vec&rdquo;.</p><p>u.paramDefault('useOnehotIndex', 'int', 0);&nbsp;//When 1, pop_index and grant_index has a width of nPorts, otherwise wPorts.</p><p><br /></p><p>let assertOn = u.getParam('assertOn');</p><p>let usePipe&nbsp; = u.getParam('usePipe');</p><p>let pipeOption = u.getParam('pipeOption');</p><p>let useOnehotIndex = u.getParam('useOnehotIndex');</p><p><br /></p><p>var nPorts&nbsp;&nbsp; = u.getParam('nPorts');</p><p>let wPorts&nbsp;&nbsp; = u.getParam('wPorts');</p><p>var nPrio&nbsp;&nbsp;&nbsp; = u.getParam('nPrio');</p><p>var wPrio&nbsp;&nbsp;&nbsp; = u.getParam('wPrio');</p><p>let nEntries = u.getParam('nEntries');</p><p><br /></p><pre><span><br /></span></pre><h2 id="QoSArbiter-verilog:"><strong>verilog:</strong></h2><p>none.</p><h1 id="QoSArbiter-I/O"><strong>I/O</strong></h1><pre>u.port('input', 'clk', 1);<br />u.port('input', 'reset_n', 1);<br /><br />// age buffer push interface<br />u.port('input', 'push_en', 1);         //or reduce of push_index<br />u.port('input', 'push_index', nPorts); //onehot0, 1 bit per port<br /><br />// age buffer pop interface<br />u.port('input', 'pop_en', 1);<br />u.port('input', 'pop_index', useOnehotIndex ? nPorts : wPorts);<br /><br />// arbiter request interface<br />for (var i = 0; i &lt; nPorts; i++) {<br />  u.port('input', 'req'+i+'_prio', wPrio); //input request priority for each port<br />}<br />u.port('input', 'req_vec', nPorts); // input requests; multihot0 bit vector<br /><br />// arbiter grant interface<br />u.port('input', 'grant_ack', 1);<br />u.port('output', 'grant', 1); //Functionally grant = or reduce of grant_vec<br />u.port('output', 'grant_vec', nPorts); // output grant; onehot0 bit vector<br />u.port('output', 'grant_index', useOnehotIndex ? nPorts : wPorts); //output grant index<br /><br />// status interface<br />u.port('output', 'valid_vec', nEntries);<br />u.port('output', 'empty', 1);<br />u.port('output', 'full', 1);</pre><pre><br /></pre><h1 id="QoSArbiter-Description"><strong>Description</strong></h1><p>QoS Arbiter that picks the highest priority oldest request in the request arrival order.</p><p>If usePipe=0, then the grant is given in the same cycle as the request.</p><p>If usePipe=1, then the grant is given in the next cycle following the request.</p><p>The request arrival order is recorded in an age buffer via the push interface. The entry in the age buffer is retired via the pop interface.</p><p>The priority is in the descending order. A priority of 0 is the highest priority. Each request comes with a priority.</p><p>When a grant is given for a request, the index of the request in the age buffer is also provided.</p><p>The external logic can register the grant index and uses it to drive the pop index when popping the age buffer.</p><p><br /></p><p>The QoS Arbiter comprises two modules connected in series.</p><p><br /></p><p>The first module is the priority request selector.</p><p>nPorts=4, nPrio=3</p><pre>                       +----------+<br />  req_vec[0]----------&gt;|          |<br />  req_vec[1]----------&gt;|          |                                +---+<br />  req_vec[2]----------&gt;| decoder  |---&gt;in_req_0[3:0]--------------&gt;| M |<br />  req_vec[3]----------&gt;|          |---&gt;in_req_1[3:0]--------------&gt;| U |------&gt; in_req_prio[3:0]<br />  req0_priority[1:0]--&gt;|          |---&gt;in_req_2[3:0]--------------&gt;| X |<br />  req1_priority[1:0]--&gt;|          |                                +---+<br />  req2_priority[1:0]--&gt;|          |                                  |<br />  req3_priority[1:0]--&gt;|          |                                  |<br />                       +----------+                                  | <br />                                                       +------+      | <br />                            OR_REDUCE(in_req_0[3:0])--&gt;|      |      | <br />                            OR_REDUCE(in_req_1[3:0])--&gt;| arb  |------+ <br />                            OR_REDUCE(in_req_2[3:0])--&gt;| spri | in_req_prio_sel[2:0]<br />                                                       |      |<br />                                                       +------+</pre><p><br /></p><p>The second module is the age-order arbiter.</p><p>nEntries=4,&nbsp;<span data-colorid="x0qf825hc7">nPorts=4, nPrio=3</span></p><pre><br />                                    +------------------------------+      <br />in_req_prio[3:0]-------------------&gt;|lookup   Age Vector find_first|-----&gt; grant_vec[3:0]<br />                                    +---------------^--------------+       grant_index[1:0]<br />                                                    |<br />                                    +---------------+--------------+ <br />                                    |         Age Buffer           |<br />                                    |                              |<br />push_en----------------------------&gt;| push                     pop |&lt;----- pop<br />                  +-------------+   |                              |&lt;----- pop_index[1:0]<br />push_index[3:0]--&gt;|index_encoder|--&gt;| index[1:0]                   |<br />                  +-------------+   +------------------------------+<br /><br />The age buffer is implemented as a shift register, shifting from index=0 to index=nEntries-1.<br />The youngest entry is on the left.<br />The oldest entry is on the right.<br />Any valid entry in the age buffer can be popped, and the age buffer will collapse/compress after the pop.<br /><br /></pre>