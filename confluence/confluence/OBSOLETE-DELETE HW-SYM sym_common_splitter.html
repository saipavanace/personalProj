<p><strong>module_name:</strong></p><p><span>sym_common_splitter (Currently a stand alone module here ../rtl/ctl_init/src/ctl_init_req_split.tachl)</span></p><h1 id="OBSOLETE-DELETEHW-SYMsym_common_splitter-Features"><strong>Features</strong></h1><p><br/></p><div class="page view"><h1 id="OBSOLETE-DELETEHW-SYMsym_common_splitter-I/O"><strong>I/O</strong></h1><p><strong>// Clock Interface<br/></strong></p><p>u.interface('' , 'slave', clkInterface);</p><p><strong>// Interface containing characteristics of an incoming transaction. Originally in the Init this comes from the PAM.</strong></p><p>u.interface('lookup_' , 'slave', lookupInterface, ['addr','user']);</p><p><strong>// CTL Interface that txns are being split on. Same interface in and out.</strong></p><p>u.interface('in_' , 'slave', ctlReqInterface);</p><p>u.interface('out_', 'master', ctlReqInterface);</p><p><strong>// Interface containing split data to be used by context.</strong></p><p>u.interface('out_', 'master', splitLookupInterface);</p><p><strong>// Interface to Write Data Path indicating the amount of write beats needed for the next split txn.</strong></p><p>u.interface('dp_trans_fifo_', 'master', dpTransFifoInterface);</p><h2 id="OBSOLETE-DELETEHW-SYMsym_common_splitter-Parameters"><strong>Parameters</strong></h2><p>{</p><div class="wiki-content">    narrowSupported : bool, // Indicates if narrows are supported coming into the splitting block<br/>    wData : int,  // Width of the Data where the splitting block operates</div><div class="wiki-content">    wRoute : int, // Width of the Route Field<br/>    wTargId : int, // Width of the target ID field<br/>    supportWrap : bool, // Indicates if wraps are supported coming into the splitting block</div><div class="wiki-content">    maxPduSize : int, // The largest transaction in bytes that can be accepted by the splitting block</div><p><strong>   // Splitting Parameters</strong></p><div class="wiki-content">    have_splitting  : bool, // indicates if splitting is needed</div><div class="wiki-content">    wMaxBurst : int, // indicates the width of the largest splitting size possible.</div><p><strong>   // Striping Parameters</strong></p><div class="page view">    have_striping     : bool, // Indicates if striping is needed</div><div class="page view">    wAddrStrpGrp   : int,   // Used for the mod3 striping function</div><div class="page view">    nStrpTarg     :  [int, int, ... ],  // Number of striping targes to each striping group<br/>    strpFunc : [int, int, ... ], // Strpe function of each tripe group</div><div class="page view">    strpFuncHash : [object, object, ... ], // ARray of address bits to use for the triping function<br/>    strpSz : [int, int, ... ], // The size of each of the striping regions<br/>    strpMap : [int, int, ... ], // How the address is mapped going out of the striping block for striped transactions<br/>    strpGrpTables :  [object, object, ... ], // Tables of targets for each striping group.</div><p>}</p><h1 id="OBSOLETE-DELETEHW-SYMsym_common_splitter-ModulesUsed"><strong>Modules Used</strong></h1><p><br/></p><p><strong style="font-size: 24.0px;">Description</strong></p><p>This document describes the splitting TACHL used inside the common layer. Currently this is a stand alone block, however could be turned into a library block as it could be used to split at the target.</p><h2 id="OBSOLETE-DELETEHW-SYMsym_common_splitter-TopLevelInterfaceandParameterDefinitions">Top Level Interface and Parameter Definitions</h2></div><h3 id="OBSOLETE-DELETEHW-SYMsym_common_splitter-ConfigurationConditions(DefinedInsideBlock)"><strong style="letter-spacing: -0.006em;">Configuration Conditions (Defined Inside Block) </strong></h3><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Condition</th><th class="confluenceTh">Simplified Condition (Left out checks for parameter existence)</th></tr><tr><td colspan="1" class="confluenceTd">haveStripeLookup</td><td colspan="1" class="confluenceTd">nStrpTarg.length</td></tr><tr><td class="confluenceTd">haveSplitWrap</td><td class="confluenceTd">(lookupInterface.split_wrap != 0)</td></tr><tr><td class="confluenceTd">haveSplitFixed</td><td class="confluenceTd">(lookupInterface.split_fixed != 0 &amp; lookupInterface.split_fixed != undefined)</td></tr><tr><td class="confluenceTd">haveSplitNarrow</td><td class="confluenceTd">(lookupInterface.split_narrow != 0 &amp; lookupInterface.split_narrow != undefined)</td></tr><tr><td class="confluenceTd">haveMaxBurst</td><td class="confluenceTd">(lookupInterface.max_burst != 0)</td></tr><tr><td colspan="1" class="confluenceTd">subBeatNarrowWrap</td><td colspan="1" class="confluenceTd">narrowSupported &amp; supportWrap &amp; (haveSplitWrap | haveSplitNarrow)</td></tr></tbody></table></div><h3 id="OBSOLETE-DELETEHW-SYMsym_common_splitter-ConfigurationConditions(DefinedOutsideBlockinCTLUseCase)"><strong>Configuration Conditions (Defined Outside Block in CTL Use Case) </strong></h3><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Condition</th><th class="confluenceTh">Simplified Condition (Left out checks for parameter existence)</th></tr><tr><td colspan="1" class="confluenceTd">narrowSplit</td><td colspan="1" class="confluenceTd">Target that doesn't support narrows. </td></tr><tr><td class="confluenceTd">wide_to_narrow_f2i</td><td class="confluenceTd">supportFixed &amp;&amp; (Target with Smaller Width)</td></tr><tr><td class="confluenceTd">have_striping</td><td class="confluenceTd">nonZeroStripe</td></tr><tr><td class="confluenceTd">have_splitting</td><td class="confluenceTd">enSplitting &amp; (nonZeroMaxBurst | nonZeroBoundary | wide_to_narrow_f2i  | narrowSplit | nonZeroSplitWrap)</td></tr><tr><td class="confluenceTd">pamTargSplitWrapCol</td><td class="confluenceTd"><p>Split Wrap Column Exists and has non 0 value. </p></td></tr></tbody></table></div><div class="page view"><h3 id="OBSOLETE-DELETEHW-SYMsym_common_splitter-Interfaces"><strong>Interfaces</strong></h3><h3 id="OBSOLETE-DELETEHW-SYMsym_common_splitter-lookupInterface-Interfacecontainingcharacteristicsofanincomingtransaction."><strong>lookupInterface - <strong>Interface containing characteristics of an incoming transaction. <br/></strong></strong></h3><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Signal Name</th><th class="confluenceTh">Used by Splitting Logic</th><th class="confluenceTh">Condition</th><th class="confluenceTh">Description</th></tr><tr><td class="confluenceTd">mod_addr</td><td class="confluenceTd">yes</td><td class="confluenceTd">Always</td><td class="confluenceTd">The original address that goes into the splitting block</td></tr><tr><td class="confluenceTd">targ_id</td><td class="confluenceTd">yes</td><td class="confluenceTd">Always</td><td class="confluenceTd">The original targ_id that goes into the splitting block</td></tr><tr><td class="confluenceTd">route</td><td class="confluenceTd">yes</td><td class="confluenceTd">Always</td><td class="confluenceTd">The original route that goes into the splitting block</td></tr><tr><td class="confluenceTd">bytesToBoundaryMask</td><td class="confluenceTd">yes</td><td class="confluenceTd">Always</td><td class="confluenceTd">A mask that is created depending on the boundary size. The bytesToBoundary is calculated by (mask &amp; ~addr) + 1</td></tr><tr><td class="confluenceTd">split_fixed</td><td class="confluenceTd">yes</td><td class="confluenceTd">wide_to_narrow_f2i</td><td class="confluenceTd">Indication that the fixed needs to be split into INCRs</td></tr><tr><td class="confluenceTd">split_narrow</td><td class="confluenceTd">yes</td><td class="confluenceTd">narrowSplit</td><td class="confluenceTd">Indication if the target supports narrow transactions.</td></tr><tr><td class="confluenceTd">split_narrow_width</td><td class="confluenceTd">yes</td><td class="confluenceTd">narrowSplit</td><td class="confluenceTd">The width of said target. </td></tr><tr><td class="confluenceTd">striped</td><td class="confluenceTd">yes</td><td class="confluenceTd">have_striping</td><td class="confluenceTd">Indication if the transaction is to a striping group.</td></tr><tr><td class="confluenceTd">stripe_group</td><td class="confluenceTd">yes</td><td class="confluenceTd">have_striping</td><td class="confluenceTd">Which stripe group the transaction matched to.</td></tr><tr><td class="confluenceTd">max_burst</td><td class="confluenceTd">yes</td><td class="confluenceTd">pamTargMaxBurstCol &amp; nonZeroMaxBurst</td><td class="confluenceTd">The max size in bytes that transaction can be.</td></tr><tr><td class="confluenceTd">bytes_to_max</td><td class="confluenceTd">yes</td><td class="confluenceTd">pamTargMaxBurstCol &amp; nonZeroMaxBurst</td><td class="confluenceTd">~~~ TO DELETE ~~~</td></tr><tr><td class="confluenceTd">split_wrap</td><td class="confluenceTd">yes</td><td class="confluenceTd">have_splitting &amp; pamTargSplitWrapCol</td><td class="confluenceTd">Indication that the wrap needs to be split into INCRs</td></tr><tr><td class="confluenceTd">interleaved</td><td class="confluenceTd">no</td><td class="confluenceTd">Long and out of Scope</td><td class="confluenceTd">OOS (Out of Scope)</td></tr><tr><td colspan="1" class="confluenceTd">decode_error</td><td colspan="1" class="confluenceTd">no</td><td colspan="1" class="confluenceTd">enDecodeError</td><td colspan="1" class="confluenceTd">OOS</td></tr><tr><td colspan="1" class="confluenceTd">rw</td><td colspan="1" class="confluenceTd">no</td><td colspan="1" class="confluenceTd">pamRW.length != 0</td><td colspan="1" class="confluenceTd">OOS</td></tr><tr><td colspan="1" class="confluenceTd">toThinInterleaved</td><td colspan="1" class="confluenceTd">no</td><td colspan="1" class="confluenceTd">reserveBeatBuffer</td><td colspan="1" class="confluenceTd">OOS</td></tr><tr><td colspan="1" class="confluenceTd">domain_err</td><td colspan="1" class="confluenceTd">no</td><td colspan="1" class="confluenceTd">have_domain_error</td><td colspan="1" class="confluenceTd">OOS</td></tr><tr><td colspan="1" class="confluenceTd">lookup_err</td><td colspan="1" class="confluenceTd">no</td><td colspan="1" class="confluenceTd">Always</td><td colspan="1" class="confluenceTd">OOS</td></tr></tbody></table></div><p><strong>splitLookupInterface - <strong>Interface containing split data to be used by context.</strong></strong></p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Signal Name</th><th colspan="1" class="confluenceTh">Driven By Splitting Logic</th><th class="confluenceTh">Condition</th><th colspan="1" class="confluenceTh">Description</th></tr><tr><td class="confluenceTd">orig_fixed</td><td colspan="1" class="confluenceTd">yes</td><td class="confluenceTd">have_splitting || have_striping</td><td colspan="1" class="confluenceTd">Indicates if the original transaction was a fixed transaction.</td></tr><tr><td class="confluenceTd">split_req</td><td colspan="1" class="confluenceTd">yes</td><td class="confluenceTd">have_splitting || have_striping</td><td colspan="1" class="confluenceTd">Indicates if the transaction was split.</td></tr><tr><td class="confluenceTd">last</td><td colspan="1" class="confluenceTd">yes</td><td class="confluenceTd">have_splitting || have_striping</td><td colspan="1" class="confluenceTd">Indicates if the transaction was the last transaction in a series of split transactions. </td></tr><tr><td class="confluenceTd">first</td><td colspan="1" class="confluenceTd">yes</td><td class="confluenceTd">have_splitting || have_striping</td><td colspan="1" class="confluenceTd">Indicates if the transaction was the first transaction in a series of split transactions. </td></tr><tr><td class="confluenceTd">split_wrap_offset</td><td colspan="1" class="confluenceTd">yes</td><td class="confluenceTd">have_splitting || have_striping</td><td colspan="1" class="confluenceTd">Is driven to the difference between the in address and out address on the first transaction, otherwise its 0. (Used to drive ingle beat wrap context info)</td></tr><tr><td colspan="1" class="confluenceTd">domain_error</td><td colspan="1" class="confluenceTd">no</td><td colspan="1" class="confluenceTd">haveDomainError</td><td colspan="1" class="confluenceTd">OOS (Out of Scope)</td></tr><tr><td class="confluenceTd">rw</td><td colspan="1" class="confluenceTd">no</td><td class="confluenceTd">pamRW.length != 0</td><td colspan="1" class="confluenceTd">OOS </td></tr><tr><td class="confluenceTd">decode_error</td><td colspan="1" class="confluenceTd">no</td><td class="confluenceTd">enDecodeError</td><td colspan="1" class="confluenceTd">OOS</td></tr><tr><td class="confluenceTd">toThinInterleaved</td><td colspan="1" class="confluenceTd">no</td><td class="confluenceTd">reserveBeatBuffer</td><td colspan="1" class="confluenceTd">OOS</td></tr><tr><td class="confluenceTd">multicast_label</td><td colspan="1" class="confluenceTd">no</td><td class="confluenceTd">wMulticastLabel</td><td colspan="1" class="confluenceTd">OOS</td></tr><tr><td class="confluenceTd">multicast_mask</td><td colspan="1" class="confluenceTd">no</td><td class="confluenceTd">wMulticastMask</td><td colspan="1" class="confluenceTd">OOS</td></tr></tbody></table></div><p><strong>dpTransFifoInterface - <strong>Interface to Write Data Path indicating the amount of write beats needed for the next split txn.</strong></strong></p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Signal Name</th><th class="confluenceTh">Driven By Splitting Logic</th><th colspan="1" class="confluenceTh">Condition</th><th colspan="1" class="confluenceTh">Description</th></tr><tr><td class="confluenceTd">valid</td><td class="confluenceTd">yes</td><td colspan="1" class="confluenceTd">have_splitting || have_striping</td><td colspan="1" class="confluenceTd">Typical Valid</td></tr><tr><td class="confluenceTd">ready</td><td class="confluenceTd">yes</td><td colspan="1" class="confluenceTd">have_splitting || have_striping</td><td colspan="1" class="confluenceTd">Typical Read</td></tr><tr><td class="confluenceTd">splitFixed</td><td class="confluenceTd">yes</td><td colspan="1" class="confluenceTd">have_splitting || have_striping</td><td colspan="1" class="confluenceTd">Indicates if the transaction was a fixed that was split. (In which case the beat accumulation is ignored)</td></tr><tr><td class="confluenceTd">len</td><td class="confluenceTd">yes</td><td colspan="1" class="confluenceTd">have_splitting || have_striping</td><td colspan="1" class="confluenceTd">Indicates the length of the transaction in <span class="inline-comment-marker" data-ref="8c4ed773-5bfc-4df6-85bd-c1ef3462c8d7">bytes</span>, </td></tr></tbody></table></div><p><strong><span class="inline-comment-marker" data-ref="72ce8e41-f3b3-45f3-a198-33cf84b882f0">ctlReqInterface</span> - Interface that carries the request through the block. All signals are pass through with the exception of </strong></p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Signal Name</th><th class="confluenceTh">Description</th></tr><tr><td class="confluenceTd">addr</td><td class="confluenceTd"><p>Address of Transaction</p></td></tr><tr><td class="confluenceTd">len</td><td class="confluenceTd">Length of Transaction</td></tr><tr><td class="confluenceTd">burstType</td><td class="confluenceTd">Burst Type of Transaction</td></tr><tr><td colspan="1" class="confluenceTd">targ_id</td><td colspan="1" class="confluenceTd">Target Id of Transaction</td></tr><tr><td colspan="1" class="confluenceTd">route</td><td colspan="1" class="confluenceTd">Route of Transaction</td></tr></tbody></table></div><h2 id="OBSOLETE-DELETEHW-SYMsym_common_splitter-GeneralDesignIdeaoftheSplittingBlock">General Design Idea of the Splitting Block</h2></div><p>The general logic of the splitting block is to find the closest point that the transaction needs to split on. For example this could be a:</p><ul style="list-style-type: square;"><li>Wrap Boundary</li><li>Max Burst Size Boundary</li><li>Striping Boundary</li><li>Data Width Boundary for Single Beat Transactions</li></ul><p>A transaction could need to take into consideration all of these, however it needs to find the closest one and act on that one to satisfy all requirements.</p><p>Once this boundary is found the length needs to be modified to account for the split. This length will modify the original length and address both of which will be used the next cycle.</p><p>The same evaluation will take place the next cycle.</p><p>So its possible to have something along the lines of:</p><ul style="list-style-type: square;"><li>Max Burst Boundary → Max Burst Boundary → Striping Boundary → Wrap Boundary (In theory there would need to be more Max Burst splits for this to be possible but just to illistrate)</li></ul><p>The side signals are then modified based on the reason and mechanics of the split. This really is just burstType and burstSize.</p><p>The splitting block in parallel also detects what striping region the transaction is in and calculates a modified target id and route depending on an indicated striping function. The actual splitting uses the mechanic above.</p><p><br/></p><div class="page view"><h2 id="OBSOLETE-DELETEHW-SYMsym_common_splitter-TopLevelMicroarchitecture">Top Level Microarchitecture</h2><h3 id="OBSOLETE-DELETEHW-SYMsym_common_splitter-SplittingTopLevelFlowDiagram">Splitting Top Level Flow <span class="inline-comment-marker" data-ref="d68a8849-0717-4d8e-8b83-7c28f1b6d53f">Diagram</span></h3><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="2000" src="https://arterisip.atlassian.net/wiki/download/attachments/16156909/image2021-1-6_17-43-34.png?api=v2"></span></p><h3 id="OBSOLETE-DELETEHW-SYMsym_common_splitter-StripingTopLevelFlowDiagram">Striping Top Level Flow <span class="inline-comment-marker" data-ref="e70a7a44-687a-494c-be5a-db9a865a832a">Diagram</span></h3><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="2000" src="https://arterisip.atlassian.net/wiki/download/attachments/16156909/image2021-1-6_18-6-34.png?api=v2"></span></p><p>For lower level details I suggest looking at the TACHL or generated code. </p><h3 id="OBSOLETE-DELETEHW-SYMsym_common_splitter-SummaryofModifiedSignals">Summary of Modified Signals</h3><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Modifiable SIgnals</th><th class="confluenceTh">Decsription</th></tr><tr><td class="confluenceTd">addr</td><td class="confluenceTd"><p>(Single Beat Wrap Split)                     ?  Lower Wrap Boundary :</p><p>(Initial Request)                                  ?  Original Address :</p><p>(Address + len == Upper Boundary) ?  Lower Wrap Boundary :</p><p>                                                               Precious Address + Previous Length;</p></td></tr><tr><td class="confluenceTd">len</td><td class="confluenceTd">Bytes to the First Found Boundary</td></tr><tr><td class="confluenceTd">burstType</td><td class="confluenceTd">(Split Wrap || Split Fixed) ? INCR : Original Burst Size</td></tr><tr><td colspan="1" class="confluenceTd">targ_id</td><td colspan="1" class="confluenceTd">(Striped) ? Stripe Group Target ID Lookup : Original Target ID</td></tr><tr><td colspan="1" class="confluenceTd">route</td><td colspan="1" class="confluenceTd">(Striped) ? Stripe Group Route Lookup : Original Route</td></tr></tbody></table></div><h2 id="OBSOLETE-DELETEHW-SYMsym_common_splitter-SplittingWRAPStallCycle">Splitting WRAP Stall Cycle</h2><p>If a wrap needs to split there will be a cycle stall where information is first calculated and stored into a register. This is to satisfy timing requirements. This in theory this could b<span style="letter-spacing: 0.0px;">e optional o</span><span style="letter-spacing: 0.0px;">r not be a stall but a pipeline. </span>However both of those will need to be future enhancements. </p><p>Note: If the forward path is not ready this first cycle that can count as the stall cycle. </p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/></colgroup><tbody><tr><th colspan="1" class="confluenceTh">Cycle 0</th><th class="confluenceTh">Calculated Value (Cycle 1)</th><th class="confluenceTh">Description</th></tr><tr><td rowspan="11" class="confluenceTd">STALL</td><td class="confluenceTd">upper_path</td><td class="confluenceTd">Use bytes to upper boundary.</td></tr><tr><td class="confluenceTd">lower_path</td><td class="confluenceTd">Use bytes to original address.</td></tr><tr><td class="confluenceTd">bytes_to_upper_boundary_from_register</td><td class="confluenceTd">Bytes to the upper wrap boundary from reg_out_addr</td></tr><tr><td class="confluenceTd">bytes_to_upper_boundary_from_input</td><td class="confluenceTd">Bytes to the upper wrap boundary from in_addr</td></tr><tr><td class="confluenceTd">post_origAddr</td><td class="confluenceTd">Original Address</td></tr><tr><td class="confluenceTd">split_sub_beat_wrap</td><td class="confluenceTd">Transaction is smaller than a beat and the Wrap needs to be converted to an INCR.</td></tr><tr><td colspan="1" class="confluenceTd">cancel_split_wrap</td><td colspan="1" class="confluenceTd">The WRAP can be converted to single INCR so no split needed.</td></tr><tr><td colspan="1" class="confluenceTd">lower_boundary</td><td colspan="1" class="confluenceTd">The lower boundary of the Wrap txn.</td></tr><tr><td colspan="1" class="confluenceTd">upper_boundary</td><td colspan="1" class="confluenceTd">The upper boundary of the Wrap txn.</td></tr><tr><td colspan="1" class="confluenceTd">splitWrap</td><td colspan="1" class="confluenceTd">Indicates the wrap needs to be split.</td></tr><tr><td colspan="1" class="confluenceTd">stall_cycle</td><td colspan="1" class="confluenceTd">Used for the stall mechanic</td></tr></tbody></table></div></div><p><br/></p><div class="page view"><p><strong><br/></strong></p></div>