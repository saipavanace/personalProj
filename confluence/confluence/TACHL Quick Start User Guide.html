<div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Version</th><th class="confluenceTh">Description</th><th class="confluenceTh">Modifier</th></tr><tr><td class="confluenceTd">0.1</td><td class="confluenceTd">Some initial info about TACHL and how to run it</td><td class="confluenceTd">Eric Taylor</td></tr></tbody></table></div><p class="auto-cursor-target"><style type='text/css'>/*<![CDATA[*/
div.rbtoc1759723896047 {padding: 0px;}
div.rbtoc1759723896047 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1759723896047 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class='toc-macro rbtoc1759723896047'>
<ul class='toc-indentation'>
<li><a href='#TACHLQuickStartUserGuide-PurposeofthisGuide'>Purpose of this Guide</a></li>
<li><a href='#TACHLQuickStartUserGuide-WhatisTACHL?'>What is TACHL?</a>
<ul class='toc-indentation'>
<li><a href='#TACHLQuickStartUserGuide-HowtorunTACHL'>How to run TACHL</a>
<ul class='toc-indentation'>
<li><a href='#TACHLQuickStartUserGuide-TopLevelJSONParameters'>Top Level JSON Parameters</a></li>
<li><a href='#TACHLQuickStartUserGuide-TopLevelTACHLFile'>Top Level TACHL File</a></li>
<li><a href='#TACHLQuickStartUserGuide-TACHLLibraries'>TACHL Libraries</a></li>
<li><a href='#TACHLQuickStartUserGuide-JavaScriptLibraries'>JavaScript Libraries</a></li>
<li><a href='#TACHLQuickStartUserGuide-CPRLibraries'>CPR Libraries</a></li>
</ul>
</li>
</ul>
</li>
<li><a href='#TACHLQuickStartUserGuide-StructureofaTypicalTACHLFile'>Structure of a Typical TACHL File</a>
<ul class='toc-indentation'>
<li><a href='#TACHLQuickStartUserGuide-HeaderandLibraryImports'>Header and Library Imports</a></li>
<li><a href='#TACHLQuickStartUserGuide-DefaultParameters'>Default Parameters</a></li>
<li><a href='#TACHLQuickStartUserGuide-ImportParameters'>Import Parameters</a></li>
<li><a href='#TACHLQuickStartUserGuide-DefineInterfaces'>Define Interfaces</a></li>
<li><a href='#TACHLQuickStartUserGuide-Misc.Calculations'>Misc. Calculations</a></li>
<li><a href='#TACHLQuickStartUserGuide-ModuleDefinitionandStartofVerilog'>Module Definition and Start of Verilog</a></li>
<li><a href='#TACHLQuickStartUserGuide-DefineWiresfromObjects'>Define Wires from Objects</a></li>
<li><a href='#TACHLQuickStartUserGuide-CreateaFlop'>Create a Flop</a></li>
<li><a href='#TACHLQuickStartUserGuide-CreateInstances'>Create Instances</a></li>
<li><a href='#TACHLQuickStartUserGuide-endmodule'>endmodule</a></li>
</ul>
</li>
<li><a href='#TACHLQuickStartUserGuide-ExampleofaTypicalTACHLFile'>Example of a Typical TACHL File</a></li>
<li><a href='#TACHLQuickStartUserGuide-gen_wrapper'>gen_wrapper</a></li>
</ul>
</div></p><h1 class="auto-cursor-target" id="TACHLQuickStartUserGuide-PurposeofthisGuide">Purpose of this Guide</h1><p>To give enough general info to get up to speed with TACHL quickly:</p><ul style="list-style-type: square;"><li>Explain what TACH is.</li><li>How to run TACHL</li><li>Structure of a typical TACHL file.</li><li>How to pass in parameters.</li><li>How to make ports.</li><li>How to instantiate a block.</li></ul><p>This is not a methodology guide. Just a quick go to guide for TACHL basics. This doesnt go over new TACHL. Rather whats currently used in NCore.</p><h1 id="TACHLQuickStartUserGuide-WhatisTACHL?">What is TACHL?</h1><p>TACHL is a templated language that allows designers to use JavaScript alongside Verilog to create Verilog files. A TACHL file will have a mix of JavaScript and Verilog/System Verilog, and once TACHL is ran the output will be all Verilog files to define the top level block.</p><h2 id="TACHLQuickStartUserGuide-HowtorunTACHL">How to run TACHL</h2><p><br/></p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: js; gutter: false; theme: Confluence" data-theme="Confluence">&gt; /engr/dev/releases/tachl/versions/tachl-latest/bin/tachl-dbg.js -p &lt;Top Level JSON&gt; -t &lt;Top Level TACHL&gt; -l &lt;TACHL Library Folders&gt; -j &lt;JavaScript Library Folders&gt; -z &lt;CPR Library Folders&gt; -o &lt;Output Directory&gt;</pre>
</div></div><h3 id="TACHLQuickStartUserGuide-TopLevelJSONParameters">Top Level JSON Parameters</h3><p>Each TACHL file will have a set of top level JavaScript parameters passed in which is able to define a specific configuration of that TACHL block. These parameters are passed in through a JSON object. An example JSON object is below:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: js; gutter: false; theme: Confluence" data-theme="Confluence">{
    &quot;strRtlNamePrefix&quot;: &quot;DII&quot;,
    &quot;wAddr&quot;: 48,
    &quot;wData&quot;: 128,
    &quot;wLargestEndpoint&quot;: 22,
    &quot;wCacheLineOffset&quot;: 6,
    &quot;enableDoublePortBuffer&quot;: 0,
    ...
}</pre>
</div></div><p>These parameters can be passed further into instantiated TACHL blocks. </p><h3 id="TACHLQuickStartUserGuide-TopLevelTACHLFile">Top Level TACHL File</h3><p>The top level TACHL file is the TACHL block the top level parameters will feed.</p><h3 id="TACHLQuickStartUserGuide-TACHLLibraries">TACHL Libraries</h3><p>Each TACHL file can instantiate sub blocks. These subblocks must be in the same directory the TACHL command is being run, or in one of the folders listed after the -l flag.</p><h3 id="TACHLQuickStartUserGuide-JavaScriptLibraries">JavaScript Libraries</h3><p>Since TACHL is a mix of JavaScript and Verilog we have the ability to use JavaScript functions to perform operations. Any function used has to be contained in one of the folders listed after -j and the library has to be instanciated at the top of the TACHL file. </p><h3 id="TACHLQuickStartUserGuide-CPRLibraries">CPR Libraries</h3><p>CPR files give definitions of how certain JavaScript objects are created. For example interfaces have CPR files. These CPR files define how an Interface Object can be created from specific parameters. The CPR files themselves are temples on how to create objects. Some examples of CPR files needed for NCORE are:</p><ul style="list-style-type: square;"><li>Interface CPRs </li><li>Concerto Message CPRs</li></ul><h1 id="TACHLQuickStartUserGuide-StructureofaTypicalTACHLFile">Structure of a Typical TACHL File</h1><p>The best way to think about a TACHL file is that it is a normal Verilog file. If you copy and paste a Verilog file into a TACHL file it will work. What TACHL does is the ability to do inline JavaScript. For example:</p><p><br/></p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: js; gutter: false; theme: Confluence" data-theme="Confluence">wire signal_a;
wire signal_b;

\jsbegin
for ( let i = 0; i &lt; nRegisters; i++) {
\jsend

reg register_\=i=\;

\js }

</pre>
</div></div><p>Here we can see three examples of how the JS world is integrated into TACHL.</p><ol><li>JavaScript can be started with a \jsbegin and a \jsend. In-between is all JavaScript. Here we create a for loop to create multiple lines of Verilog which is in between.</li><li>You can print JavaScript variables using \=&lt;variable&gt;=\. For example here &quot;i&quot; will be replaced with a number.</li><li>Finally a single line can be made into JavaScript simply with the \js tag.</li></ol><h3 id="TACHLQuickStartUserGuide-HeaderandLibraryImports">Header and Library Imports</h3><p><br/></p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: js; gutter: false; theme: Confluence" data-theme="Confluence">// Copyright (C) 2018 Arteris, Inc.
// All rights reserved.
//=============================================================================
\jsbegin
// This module defines dii top level.
//
//=============================================================================

var u                    = obj.lib;
var memFunctions         = obj.userLib;
var bundleFunctions      = obj.userLib.bundleFunctions;
var utilFunctions        = obj.userLib;
var cloneDeep            = utilFunctions.deepCopy;
var log2ceil             = function(n) { return Math.ceil(Math.log(n)/Math.LN2); };</pre>
</div></div><p>Here we can see the top level header for the file. Then we see a \jsbegin which allows us to do all of the JavaScript work that is needed before the Verilog starts being made. In this part we instantiate all functions and libraries which will be used later in the TACHL file..</p><h3 id="TACHLQuickStartUserGuide-DefaultParameters">Default Parameters</h3><p><br/></p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: js; gutter: false; theme: Confluence" data-theme="Confluence">u.paramDefault(&#39;fnErrDetectCorrect&#39;,&#39;string&#39;,&quot;NONE&quot;);
u.paramDefault(&#39;fnNativeInterface&#39;,&#39;string&#39;,&quot;AXI4&quot;);
u.paramDefault(&#39;useExternalMemory&#39;,&#39;int&#39;,0);
u.paramDefault(&#39;usePma&#39;,&#39;boolean&#39;,true);
u.paramDefault(&#39;PmaInfo&#39;, &#39;object&#39;, {&quot;wActive&quot; : 1, &quot;fnPmaInterfaceType&quot;:&quot;Q&quot;});

</pre>
</div></div><p>Next we define all parameters that can ever be passed into this TACHL block and give them all default values. These are the values that JavaScript variable will be if it is not passed in from the top level. All of these variable can be used later on inside the TACHL file in JavaScript world. </p><h3 id="TACHLQuickStartUserGuide-ImportParameters">Import Parameters</h3><p><br/></p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: js; gutter: false; theme: Confluence" data-theme="Confluence">var smiTxPortParams       = obj.lib.getParam(&#39;smiPortParams&#39;, &#39;tx&#39;);
var smiRxPortParams       = obj.lib.getParam(&#39;smiPortParams&#39;, &#39;rx&#39;);
var concParams            = obj.lib.getParam(&#39;concParams&#39;);
var concMuxTxMsgParams    = obj.lib.getParam(&#39;concMuxMsgParams&#39;, &#39;tx&#39;);
var concMuxRxMsgParams    = obj.lib.getParam(&#39;concMuxMsgParams&#39;, &#39;rx&#39;);
var interfaces            = obj.lib.getParam(&#39;interfaces&#39;);</pre>
</div></div><p>Next we need to import all of the parameters that would be used using the getParam function. These functions are what actually grabs the parameter instead of just giving it a default value. Another important note is that most top level blocks will specifically have an &quot;interfaces&quot; parameter. This parameter defines all the top level interfaces which will be connected into this block. We will see in the next section how its used. </p><h3 id="TACHLQuickStartUserGuide-DefineInterfaces">Define Interfaces</h3><p><br/></p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: js; gutter: false; theme: Confluence" data-theme="Confluence">// AXI interface params generation
var interfaceFunc        = new obj.userLib[interfaces.axiInt.interface];
var axiInterface         = interfaceFunc.getSignals(interfaces.axiInt.params);
var axiInterfaceBundle   = interfaceFunc.getSignalsBundle(interfaces.axiInt.params);
var axiInterfaceName     = interfaces.axiInt.name;

obj.lib.interface(axiInterfaceName, &#39;master&#39;, axiInterfaceBundle);</pre>
</div></div><p>- or -</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: js; gutter: false; theme: Confluence" data-theme="Confluence">u.port(&#39;input&#39;, &#39;my_f_unit_id&#39; , wFUnitId);
u.port(&#39;input&#39;, &#39;my_n_unit_id&#39; , wNUnitId)
u.port(&#39;input&#39;, &#39;my_csr_rpn&#39;   , wRpn);
u.port(&#39;input&#39;, &#39;my_csr_nrri&#39;  , wNrri);
u.port(&#39;output&#39;,&#39;c&#39;            , 1);
u.port(&#39;output&#39;,&#39;uc&#39;           , 1);</pre>
</div></div><p>- or -</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: js; gutter: false; theme: Confluence" data-theme="Confluence">u.nInterfaces(interfaces);</pre>
</div></div><p>There are multiple ways to define interfaces into the block. This essentially generates the port list for the top level block.</p><ul style="list-style-type: square;"><li>This first method generates a &quot;signal bundle&quot; object and then generates the ports using obj.lib.interface. A signal bundle is just a JavaScript object of all the signals and their width. For example :<ul style="list-style-type: square;"><li>{ &quot;signal_a&quot; : 5, &quot;signal_b&quot; : 1 }</li></ul></li><li>This second method can directly make ports for the TACHL block.</li><li>This last method can be used for all &quot;Software Visible&quot; blocks. These blocks need to take in all of thier interfaces through that interface parameter we talked about before. This function can automatically do the first method for all interfaces defined in that interface object. </li></ul><h3 id="TACHLQuickStartUserGuide-Misc.Calculations">Misc. Calculations</h3><p><br/></p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: js; gutter: false; theme: Confluence" data-theme="Confluence">var read_req_width     = wMpf1 + axi_id_width + wAddr + wSize + wQos + arprot_width + aruser_width + 1 + 1 + 1 + 1 + wOrder + arlock_width + 1 + 1 + wTOF;
var write_resp_width   = bresp_width + axi_id_width;
var str_req_width      = tt_id_width + wFUnitId + wMsgId + 1 + wQos + wQl + wPriority + 1;</pre>
</div></div><p>Personally I also create all global JavaScript variables at the top. These are JavaScript variables which arent passed into the block but rather calculated from the variables passed in.</p><h3 id="TACHLQuickStartUserGuide-ModuleDefinitionandStartofVerilog">Module Definition and Start of Verilog</h3><p><br/></p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: js; gutter: false; theme: Confluence" data-theme="Confluence">\jsend

module \=u.getModuleName()=\ (\=u.getPorts(&#39;\n    &#39;)=\);

//=============================================================================
// Internal Wires
//=============================================================================

    wire [1:0]                        bresp;
    wire [\=wAddr-1=\:0]              bresp_addr;</pre>
</div></div><p>Here we use \jsend to close out the upper JavaScript portion of the TACHL file and create the module definition. Here we get the name and ports of the module from the &quot;u&quot; library. Then we see we start the Verilog portion with wire definitions. </p><h3 id="TACHLQuickStartUserGuide-DefineWiresfromObjects">Define Wires from <span class="inline-comment-marker" data-ref="3d6ca32c-64a8-42a5-8284-6e35f2fa22f6">Objects</span></h3><p><br/></p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: js; gutter: false; theme: Confluence" data-theme="Confluence">\=m.bundleFunctions.wiresFromInterface(&#39;axi_mst_pipe_&#39;, AXI_Interface, [], u.bundle)=\</pre>
</div></div><p>If we have signal bundles we can automatically generate wires for all the signals in that bundle using a bundle function. </p><h3 id="TACHLQuickStartUserGuide-CreateaFlop">Create a Flop</h3><p><br/></p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: js; gutter: false; theme: Confluence" data-theme="Confluence">\=u.dffre(  wFUnitId
          , &#39;r_my_f_unit_id&#39;
          , &#39;my_f_unit_id&#39;
          , wFUnitId+&#39;\&#39;b0&#39;
          , &quot;1&#39;b1&quot;
          , &#39;to_clk_gate_clk&#39;
          , &#39;to_clk_gate_reset_n&#39;)=\</pre>
</div></div><p>In TACHL we use the dffre function to create flops. The arguments are </p><ul style="list-style-type: square;"><li>The width of the flop. (Integer)</li><li>Name of the output wire. (String)</li><li>Name of the input wire. (String)</li><li>Reset Value (String)</li><li>Enable Signal (String)</li><li>Clock Name (String)</li><li>Reset Name (String)</li></ul><h3 id="TACHLQuickStartUserGuide-CreateInstances">Create Instances</h3><p>There are many ways you can approach instancing a block. This is just one and is more of an example of all the arguments into obj.lib.instance</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: js; gutter: false; theme: Confluence" data-theme="Confluence">// First we go into JavaScript mode to create all of the objects used to define the interfaces into the block.
\jsbegin

// We are going to check if this block needs to be created
if (usePma ) {
//-----------------------------------------------------------------------------
// CSR Interfaces

// The interfaces argument of the instance function takes in an array. Here we declare our array which will contain multiple interface objects. 
var pma_interfaces = [];
var dii_num = 0;

// Create the clock interface object.
pma_interfaces[dii_num] =     {
                                modulePrefix  : &#39;&#39;, // The prefix of the signal used in the instanced module
                                localPrefix   : &#39;to_clk_gate_&#39; , // The prefix of the signal used in the block instancing the module
                                interface     :  clkInterfaceNoTest // The signal bundle 
                              };

dii_num++;

// Create a Q Interface
pma_interfaces[dii_num] =     {
                                 modulePrefix  :  qInterfaceName,
                                 localPrefix   :  qInterfaceName,
                                 interface     :  qInterface
                              };

dii_num++;

// Next we have to pass into the PMA that &quot;interfaces&quot; object we talked about earlier. This is how the PMA knows what ports to make. It looks repetitive from before but the main difference is.
// - Above defines the port connects in the top block.
// - This defines the port definitions inside the instanced block
var interfaces   =  {};
interfaces[&quot;clkInt&quot;]  =       {
                                 &quot;name&quot;      : &quot;&quot;, // The prefix of the signals
                                 &quot;params&quot;    : {}, // If the interface object has any parameters they go here
                                 &quot;direction&quot; : &quot;slave&quot;, // The direction of the interface
                                 &quot;interface&quot; : &quot;InterfaceCLK&quot; // The interface object name. ( Defined in a CPR file)
                              };

interfaces[&quot;masterInt&quot;] =     {
                                 &quot;name&quot;      : qInterfaceName,
                                 &quot;params&quot;    : {
                                                  &quot;wActive&quot;     : PmaInfo.wActive,
                                                  &quot;channelType&quot; : PmaInfo.fnPmaInterfaceType
                                               },
                                 &quot;direction&quot; : &quot;slave&quot;,
                                 &quot;interface&quot; : &quot;InterfacePQChannel&quot;
                              };

interfaces[&quot;pmaControlInt&quot;] = {
                                 &quot;name&quot;      : &quot;pma_ctl_&quot;,
                                 &quot;params&quot;    : {},
                                 &quot;direction&quot; : &quot;master&quot;,
                                 &quot;interface&quot; : &quot;InterfacePMAControl&quot;
                              };
// Now we go back to Verilog world.
\jsend

\js // Break Feedthrough Path

wire goto_sleep;
wire asleep;

// Now we create the instance.
\=obj.lib.instance ({
                instanceName: &#39;dii_pma&#39;, // The name of the instance
                moduleName: &#39;pma_slave&#39;, // The name of the module being instanciated
                params : { // The parameters being passed into the module being instanced  &quot;modules parameter name&quot; : &quot;JavaScript Variable Name&quot;
                             syncReq              : false,
                             channel              : &quot;Q&quot;,
                             interfaces           : interfaces
                         },
                ports:   { // We can also define individual port connections to be made manually. 
                             &quot;pma_ctl_asleep&quot;     : &#39;asleep&#39;,
                             &quot;pma_ctl_goto_sleep&quot; : &#39;goto_sleep&#39;,
                             &quot;pma_ctl_busy&quot;       : &#39;busy&#39;,
                             &quot;pma_ctl_abort&quot;      : &#39;1\&#39;b0&#39;
                         },
                verilogParams : {},
                interfaces : pma_interfaces // These define port connections through that interface array we created earlier.
        })=\
\js }</pre>
</div></div><h3 id="TACHLQuickStartUserGuide-endmodule">endmodule</h3><p><br/></p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: js; gutter: false; theme: Confluence" data-theme="Confluence">endmodule</pre>
</div></div><p>A module is closed normally like any other Verilog file. </p><h1 id="TACHLQuickStartUserGuide-ExampleofaTypicalTACHLFile">Example of a Typical TACHL File</h1><p>This is a barrel shifter as seen in hw-lib.</p><p><br/></p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: js; gutter: false; theme: Confluence" data-theme="Confluence">//=============================================================================
// Copyright (C) 2021 Arteris, Inc.
// All rights reserved.
//=============================================================================
\jsbegin
//
// A block that does a barrel shift
//
//=============================================================================

var u = obj.lib;
var utilFunctions = obj.userLib;

u.paramDefault(&#39;width&#39;, &#39;int&#39;, 512);
u.paramDefault(&#39;minShiftSize&#39;, &#39;int&#39;, 8);

var width = u.getParam(&#39;width&#39;);
var minShiftSize = u.getParam(&#39;minShiftSize&#39;);

var num_groups = Math.ceil(width/minShiftSize);
var ptr_width = utilFunctions.log2ceil(num_groups);
var int_width = (2 ** ptr_width) * minShiftSize;
var int_num_groups = Math.ceil(int_width/minShiftSize);

u.port(&#39;input&#39;, &#39;shift&#39;, ptr_width);
u.port(&#39;input&#39;, &#39;din&#39;, width);
u.port(&#39;output&#39;,&#39;dout&#39;, width);

\jsend
module \= u.getModuleName()=\ (\=u.getPorts(&#39;\n &#39;)=\);

wire [\=int_width-1=\:0] int_din;
wire [\=int_width-1=\:0] int_dout;\jsbegin
if (int_width === width) {\jsend
    assign int_din = din;
    assign dout = int_dout;\jsbegin
} else {\jsend
    assign int_din = {\=int_width-width=\&#39;b0,din};
    assign dout = int_dout[\=width-1=\:0];\jsbegin
}

//
// Put down the muxes, starting with most significant
//

var not_done = true;
var stage_size = int_width/2;
var ptr_index = ptr_width-1

while (not_done) {\jsend
    //
    // shift bit \=ptr_index=\
    //
    wire [\=int_width-1=\:0] mux_out_\=ptr_index=\;\jsbegin
    for (var i = 0; i &lt; (int_width/stage_size); i++) {
        if (i === 0) {
            if (stage_size === int_width/2) {\jsend
   assign mux_out_\=ptr_index=\[\=stage_size-1=\:0] = shift[\=ptr_index=\] ? int_din[\=int_width-1=\:\=int_width/2=\] : int_din[\=(int_width/2)-1=\:0];\jsbegin
            } else {\jsend
   assign mux_out_\=ptr_index=\[\=stage_size-1=\:0] = shift[\=ptr_index=\] ? mux_out_\=ptr_index+1=\[\=int_width-1=\:\=int_width-stage_size=\] : mux_out_\=ptr_index+1=\[\=stage_size-1=\:0];\jsbegin
            }
        } else {
            if (stage_size === int_width/2) {\jsend
  assign mux_out_\=ptr_index=\[\=((i+1)*stage_size)-1=\:\=i*stage_size=\] = shift[\=ptr_index=\] ? int_din[\=(int_width/2)-1=\:0] : int_din[\=int_width-1=\:\=int_width/2=\];\jsbegin
            } else {\jsend
  assign mux_out_\=ptr_index=\[\=((i+1)*stage_size)-1=\:\=i*stage_size=\] = shift[\=ptr_index=\] ? mux_out_\=ptr_index+1=\[\=(i*stage_size)-1=\:\=(i-1)*stage_size=\] : mux_out_\=ptr_index+1=\[\=((i+1)*stage_size)-1=\:\=i*stage_size=\];\jsbegin
            }
      }
    }
    stage_size = stage_size/2;
    ptr_index--;
    if (ptr_index &lt; 0) not_done = false;
}
//
// Connect up int_dout
//
\jsend
//
// Hook up to dout
//
assign int_dout = mux_out_0;
endmodule
</pre>
</div></div><h1 id="TACHLQuickStartUserGuide-gen_wrapper">gen_wrapper</h1><p>The top level block to full system design will always be a gen_wrapper. A gen_wrapper has no specific logic in it, however is constructed so arbitrary blocks, connections, and ports can be made by software at the top level. At the end of the software flow Maestro is able to make a JSON file which can instantiate a gen_wrapper.</p><p>You can read more about gen_wrapper here <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168521/gen_wrapper" data-linked-resource-id="16168521" data-linked-resource-version="20" data-linked-resource-type="page">gen_wrapper</a></p><p><br/></p>