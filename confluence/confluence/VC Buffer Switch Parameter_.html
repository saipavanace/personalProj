<div class="table-wrap"><style>[data-colorid=vuxgmn06pr]{color:#333333} html[data-color-mode=dark] [data-colorid=vuxgmn06pr]{color:#cccccc}[data-colorid=utiry11cl4]{color:#333333} html[data-color-mode=dark] [data-colorid=utiry11cl4]{color:#cccccc}[data-colorid=dq3ba8bf5i]{color:#333333} html[data-color-mode=dark] [data-colorid=dq3ba8bf5i]{color:#cccccc}[data-colorid=xv1nhcjdv4]{color:#333333} html[data-color-mode=dark] [data-colorid=xv1nhcjdv4]{color:#cccccc}[data-colorid=gjhl79j51l]{color:#333333} html[data-color-mode=dark] [data-colorid=gjhl79j51l]{color:#cccccc}[data-colorid=qq6pm500wu]{color:#333333} html[data-color-mode=dark] [data-colorid=qq6pm500wu]{color:#cccccc}[data-colorid=nncqfh3fsa]{color:#333333} html[data-color-mode=dark] [data-colorid=nncqfh3fsa]{color:#cccccc}[data-colorid=r4wggx5bgi]{color:#333333} html[data-color-mode=dark] [data-colorid=r4wggx5bgi]{color:#cccccc}</style><table class="confluenceTable"><tbody><tr><th class="confluenceTh">&nbsp;</th><th class="confluenceTh">Parameter</th><th class="confluenceTh">Syntax</th><th class="confluenceTh">Comments</th></tr><tr><td class="confluenceTd">1</td><td class="confluenceTd">Buffer Layer 0 (Per VC input buffer)</td><td class="confluenceTd">bufLayer0</td><td class="confluenceTd">bufLayer0:{depth:1 or greater, pipeForward:boolean, simplePipe:boolean, circular:boolean}</td></tr><tr><td class="confluenceTd">2</td><td class="confluenceTd">Buffer Layer 1 (Per VC/Per Input/Per output VC buffer)</td><td class="confluenceTd">bufLayer1</td><td class="confluenceTd"><span data-colorid="xv1nhcjdv4" style="text-decoration: none;">bufLayer1:{depth:1 or greater, pipeForward:boolean, simplePipe:boolean, circular:boolean} </span></td></tr><tr><td colspan="1" class="confluenceTd">3</td><td colspan="1" class="confluenceTd">Buffer Layer 2 (Per VC output buffer)</td><td colspan="1" class="confluenceTd">bufLayer2</td><td colspan="1" class="confluenceTd"><span data-colorid="dq3ba8bf5i" style="text-decoration: none;">bufLayer2:{depth:1 or greater, pipeForward:boolean, simplePipe:boolean, circular:boolean} </span></td></tr><tr><td colspan="1" class="confluenceTd">4</td><td colspan="1" class="confluenceTd"><p style="margin-left: 0.0px;text-align: left;">1) Arbitration only arbitrates on an input that has a ready asserted</p><p style="margin-left: 0.0px;text-align: left;">2) Soft Locking</p><p style="margin-left: 0.0px;text-align: left;">3) Master arbitration lock style</p></td><td colspan="1" class="confluenceTd"><p style="margin-left: 0.0px;text-align: left;">1) arbRdyAware</p><p style="margin-left: 0.0px;text-align: left;">2) mstrArbLck</p><p style="margin-left: 0.0px;text-align: left;">3) mstLckStypleVld</p></td><td colspan="1" class="confluenceTd"><p style="margin-left: 0.0px;text-align: left;">1) &quot;yes&quot;, &quot;no&quot;</p><p style="margin-left: 0.0px;text-align: left;">2) &quot;true&quot;, &quot;false&quot;</p><p style="margin-left: 0.0px;text-align: left;">3) &quot;ture&quot;, or &quot;false&quot;</p></td></tr><tr><td colspan="1" class="confluenceTd">5</td><td colspan="1" class="confluenceTd">Are the weights programmable</td><td colspan="1" class="confluenceTd">weightsProg</td><td colspan="1" class="confluenceTd">Boolean</td></tr><tr><td colspan="1" class="confluenceTd">6</td><td colspan="1" class="confluenceTd">Number of Priorities</td><td colspan="1" class="confluenceTd">numPri</td><td colspan="1" class="confluenceTd">Integer</td></tr><tr><td colspan="1" class="confluenceTd">7</td><td colspan="1" class="confluenceTd">Route fields (which fields are to used to determine the egress port)</td><td colspan="1" class="confluenceTd">routeFields</td><td colspan="1" class="confluenceTd"><pre style="margin-left: 0.0px;">[{rf:[&quot;a_string&quot;,&quot;&quot;,&quot;&quot;]}, // array depth variable {rf:[]},{rf:[]}], // array depth = numIngress&nbsp;
<strong style="text-decoration: none;text-align: left;">Discussion</strong><span data-colorid="r4wggx5bgi" style="text-decoration: none;">: Two dimensional array. Entry 0 in top array correlates to inInterfaces[0] and so on. </span></pre><pre style="margin-left: 0.0px;"><span data-colorid="nncqfh3fsa" style="text-decoration: none;">Strings in sub array describes which fields in the header will be used to determine route. </span></pre><pre style="margin-left: 0.0px;"><span data-colorid="vuxgmn06pr" style="text-decoration: none;">Multiple strings indicate multiple fields that are concatenated together to determine the bits used</span></pre><pre style="margin-left: 0.0px;"><span data-colorid="utiry11cl4" style="text-decoration: none;">to route a packet to an egress port. A check will be done to verify that the number </span></pre><pre style="margin-left: 0.0px;"><span data-colorid="gjhl79j51l" style="text-decoration: none;">of egress ports can be encoded in the width of the fields provided.</span>
</pre></td></tr><tr><td colspan="1" class="confluenceTd">8</td><td colspan="1" class="confluenceTd">route shift (determines the bit shift on the route field in this switch)</td><td colspan="1" class="confluenceTd">routeShift</td><td colspan="1" class="confluenceTd">routeShift:<span data-colorid="qq6pm500wu" style="text-decoration: none;">[non negative integer, , ,] array depth = numIngress</span></td></tr><tr><td colspan="1" class="confluenceTd">9</td><td colspan="1" class="confluenceTd"><p>VC Shift map defines how input VCs are mapped to output VCs. e.g. Input0, VC0 can be mapped out egress VC2 on all egress ports</p><p>&nbsp;</p></td><td colspan="1" class="confluenceTd">vcShiftMap</td><td colspan="1" class="confluenceTd"><p>vcShiftMap: null or</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">[{vcs:[
        {mapFunc{ shiftFields: ['string','string'], // Header fields to concatenate to create shift bit pattern.
                                                    // Can be null of empty, but shiftTable can only have one entry.
                      shiftTable: [{vc: 0 or pos int, // VC to map to
                                   shiftPat: 'string'}, // Pattern to map to indicated VC. 
                                           {},{}] // max array depth = numVc},
                   {},{}]}, // array depth = numVc
             {},{}], // array depth = numIngress</pre>
</div></div></td></tr><tr><td colspan="1" class="confluenceTd">10</td><td colspan="1" class="confluenceTd">Route Map</td><td colspan="1" class="confluenceTd">routeMap</td><td colspan="1" class="confluenceTd"><p style="margin-left: 0.0px;text-align: left;">routeMap: [{rm:[{bitPat: &quot;a_string&quot;,egressPort: int},{},{}]},{},{}]</p><p style="margin-left: 0.0px;text-align: left;"><strong>Discussion</strong>: Two dimensional array. Entry 0 in top array correlates to inInterfaces[0] and so on.</p><p style="margin-left: 0.0px;text-align: left;">The subarrays is an array of bit patterns that map the bits defined in routeFields to an egress port.</p><p style="margin-left: 0.0px;text-align: left;">Example: Use field H_route[3] to define routing for a 2x2 switch on all ingress ports.</p><p style="margin-left: 0.0px;text-align: left;">routeFields:[{rf:[&quot;H_route[3]&quot;]},{rf:[&quot;H_route[3]&quot;]}],</p><p style="margin-left: 0.0px;text-align: left;">routeMap:[{rm:[</p><p style="margin-left: 0.0px;text-align: left;">{bitPat:&quot;1'b0&quot;,out: 0},</p><p style="margin-left: 0.0px;text-align: left;">{bitPat:&quot;1'b1&quot;,out: 1}],</p><p style="margin-left: 0.0px;text-align: left;">{bitPat:&quot;1'b0&quot;,out: 0},</p><p style="margin-left: 0.0px;text-align: left;">{bitPat:&quot;1'b1&quot;,out: 1}]}],</p></td></tr><tr><td colspan="1" class="confluenceTd">11</td><td colspan="1" class="confluenceTd">Egress Arbitration Type</td><td colspan="1" class="confluenceTd">arbType</td><td colspan="1" class="confluenceTd"><pre style="margin-left: 0.0px;">arbType: {egress: ['string',,], // array depth = numEgress&nbsp;</pre><pre style="margin-left: 0.0px;">          vcs: [{vc: ['string',,]} // array depth = numEgress</pre><pre style="margin-left: 0.0px;">          ,{},{}] // array depth = numVc&nbsp;</pre></td></tr><tr><td colspan="1" class="confluenceTd">12</td><td colspan="1" class="confluenceTd">Weights if arb type WRR/RR</td><td colspan="1" class="confluenceTd">weights</td><td colspan="1" class="confluenceTd"><pre style="margin-left: 0.0px;">weights: {egress: [{w: [1,1,1]}, // array depth = numVc</pre><pre style="margin-left: 0.0px;">                   {},{}], // array depth = numEgress&nbsp;</pre><pre style="margin-left: 0.0px;">          vcs: [{vc: [{w: [1,1,1]}, // array depth = number of ingress ports to switch vc0 if no port pruning in portMap</pre><pre style="margin-left: 0.0px;">                         {},{}]}, // array depth = numEgress</pre><pre style="margin-left: 0.0px;">               {},{}] // array depth = numVc</pre></td></tr><tr><td colspan="1" class="confluenceTd">13</td><td colspan="1" class="confluenceTd">VC mapping that is which VC is connected to which VC on the</td><td colspan="1" class="confluenceTd">vcMap</td><td colspan="1" class="confluenceTd">vcMap:<pre style="margin-left: 0.0px;">{</pre><pre style="margin-left: 0.0px;">  ingress: [{vm:[non negative integer,,]}, // array depth min = 1, array depth max = numVc</pre><pre style="margin-left: 0.0px;">  {vm:[]},{vm:[]}], // array depth = numIngress</pre><pre style="margin-left: 0.0px;">  egress: []}, // some format as ingress, array depth = numEgress&nbsp;</pre></td></tr><tr><td colspan="1" class="confluenceTd">14</td><td colspan="1" class="confluenceTd">Input Port mapping (which egress port is connect what ingress ports)</td><td colspan="1" class="confluenceTd">portMap</td><td colspan="1" class="confluenceTd">portMap:<pre style="margin-left: 0.0px;">[</pre><pre style="margin-left: 0.0px;">    {ports: [non negative integer,,]}, // array depth min = 1, array depth max = numIngress&nbsp;</pre><pre style="margin-left: 0.0px;">    {},{}],  // array depth = numEgress, Maps which ingress inputs go to which egress ports. <br />               (This filtering is done on the egress ports of the vc switches)</pre></td></tr></tbody></table></div><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p>