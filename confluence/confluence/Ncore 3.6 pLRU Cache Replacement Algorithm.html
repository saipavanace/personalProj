<p>The external link that was used for implementing the Ncore 3.6 pLRU Cache Replacement Algorithm is provided below for reference. This confluence page copies the majority of content for Ncore traceability. </p><p><a class="external-link" data-card-appearance="inline" href="https://en.wikipedia.org/wiki/Pseudo-LRU" rel="nofollow">https://en.wikipedia.org/wiki/Pseudo-LRU</a> </p><p><em><strong>NOTE</strong></em>: Ncore HW Implemented the feature around the Jan 2023 timeframe. There have been no functional or implementation updates to the external Wikipedia page since then as of todayâ€™s date <time datetime="2024-09-06" class="date-past">06 Sep 2024</time> . The two updates below made after Jan 2023 are minor formatting or syntax corrections and did not change any details of the algorithm. </p><span class="confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image image-center" width="760" src="https://arterisip.atlassian.net/wiki/download/attachments/851214441/Screenshot%202024-09-06%20at%2010.07.43%E2%80%AFAM.png?api=v2"></span><h1 id="Ncore3.6pLRUCacheReplacementAlgorithm-Psuedo-LRU">Psuedo-LRU</h1><p><strong>Pseudo-LRU</strong> or <strong>PLRU</strong> is a family of <a class="external-link" href="https://en.wikipedia.org/wiki/Cache_algorithms" rel="nofollow">cache algorithms</a> which improve on the performance of the <a class="external-link" href="https://en.wikipedia.org/wiki/Cache_algorithms#LRU" rel="nofollow">Least Recently Used</a> (LRU) algorithm by replacing values using approximate measures of age rather than maintaining the exact age of every value in the cache.</p><p>PLRU usually refers to two cache replacement algorithms: tree-PLRU and bit-PLRU.</p><h1 id="Ncore3.6pLRUCacheReplacementAlgorithm-Tree-PLRU">Tree-PLRU</h1><p>Tree-PLRU is an efficient <a class="external-link" href="https://en.wikipedia.org/wiki/Algorithm" rel="nofollow">algorithm</a> to select an item that most likely has not been accessed very recently, given a set of items and a sequence of access events to the items.</p><p>This technique is used in the <a class="external-link" href="https://en.wikipedia.org/wiki/CPU_cache" rel="nofollow">CPU cache</a> of the <a class="external-link" href="https://en.wikipedia.org/wiki/Intel_486" rel="nofollow">Intel 486</a> and in many processors in the <a class="external-link" href="https://en.wikipedia.org/wiki/PowerPC" rel="nofollow">PowerPC</a> family, such as <a class="external-link" href="https://en.wikipedia.org/wiki/Freescale" rel="nofollow">Freescale's</a> <a class="external-link" href="https://en.wikipedia.org/wiki/PowerPC_G4" rel="nofollow">PowerPC G4</a> used by <a class="external-link" href="https://en.wikipedia.org/wiki/Apple_Computer" rel="nofollow">Apple Computer</a>.</p><p>The algorithm works as follows: consider a <a class="external-link" href="https://en.wikipedia.org/wiki/Binary_search_tree" rel="nofollow">binary search tree</a> for the items in question. Each node of the tree has a one-bit flag denoting &quot;go left to insert a pseudo-LRU element&quot; or &quot;go right to insert a pseudo-LRU element&quot;. To find a pseudo-LRU element, traverse the tree according to the values of the flags. To update the tree with an access to an item N, traverse the tree to find N and, during the traversal, set the node flags to denote the direction that is opposite to the direction taken.</p><p /><span class="confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image image-center" alt="Plruexample.png" width="552" src="https://arterisip.atlassian.net/wiki/download/attachments/851214441/Plruexample.png?api=v2"></span><p>This algorithm can be sub-optimal since it is an approximation. For example, in the above diagram with A, C, B, D cache lines, if the access pattern was: C, B, D, A, on an eviction, B would be chosen instead of C. This is because both A and C are in the same half and accessing A directs the algorithm to the other half that does not contain cache line C.</p><h1 id="Ncore3.6pLRUCacheReplacementAlgorithm-Bit-PLRU">Bit-PLRU</h1><p>Bit-PLRU stores one status bit for each cache line. These bits are called MRU-bits. Every access to a line sets its MRU-bit to 1, indicating that the line was recently used. Whenever the last remaining 0 bit of a set's status bits is set to 1, all other bits are reset to 0. At cache misses, the leftmost line whose MRU-bit is 0 is replaced.<a class="external-link" href="https://en.wikipedia.org/wiki/Pseudo-LRU#cite_note-1" rel="nofollow"><sup>[1]</sup></a></p>