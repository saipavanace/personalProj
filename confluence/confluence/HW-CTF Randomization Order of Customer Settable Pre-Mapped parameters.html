<p>The numbering on the sections indicate the order that parameters must be randomized. If a parameter is not listed it is considered a derived parameter.</p><h1 id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-1.0NetworkLevelRandomization">1.0 Network Level Randomization</h1><h2 style="margin-left: 30.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-1.1NetworkFirstSet">1.1 Network First Set</h2><p style="margin-left: 60.0px;">enBufWrite: true/false<br/>lckStyleValid: true/false<br/>vcForDdLck: true/false;<br/>vcForQoS: true/false;<br/>numPri: 1,2,3,4,5,6,7,8<br/>maxPktSize: (bytes) 64,128, 256, 512,1024,2048,4096<br/>protectionStyle = {protection: 'none', scrub: false, useCorrected: false, protWidth: 0}</p><h2 style="margin-left: 30.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-1.2NetworkSecondSet">1.2 Network Second Set</h2><p style="margin-left: 60.0px;">mstrArbLck: true/false - if nVc &gt; 1, mstrArbLck = true else true/false<br/>nVc: 1,2,4 - if vcForDdLck &amp;&amp; vcForQoS nVc = 4 else if (!vcForDdLck &amp;&amp; vcForQoS) || (vcForDdLck &amp;&amp; !vcForQoS) nVc = 2 else nVc = 1</p><p style="margin-left: 60.0px;">The number of VCs you set is going to be a function of how you want to use them. If you want to do QoS with VCs, nVc = 2. If you want to use VCs for deadlock avoidance, nVc = 2. If you want to do both, nVc = 4. If you want to do neither, nVc = 1.</p><h2 style="margin-left: 30.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-1.3NetworkThirdSet">1.3 Network Third Set</h2><p style="margin-left: 60.0px;">mstrArbRdyAware: true/false - if mstrArbLck == true, mstrArbRdyAware = true else true/false </p><h1 id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-2.0ATUTLevelRandomization">2.0 ATUT Level Randomization</h1><h2 style="margin-left: 30.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-2.1ATUTFirstSet">2.1 ATUT First Set</h2><p style="margin-left: 60.0px;">ATUT Type: APB/AXI</p><h2 style="margin-left: 30.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-2.2ATUTType=AXI">2.2 ATUT Type = AXI</h2><h3 style="margin-left: 60.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-2.2.1ATUTType=AXISecondSet">2.2.1 ATUT Type = AXI Second Set</h3><p style="margin-left: 90.0px;">Interface:</p><p style="margin-left: 120.0px;">wAddr = 12,15,16,17,31,32,33,63,64<br/>wArUser = wAwUser = wBUser = 0 to 200<br/>wArId = wAwId = wWId = 0,1,2,3,4,5,7,8,9,15,16,17,31,32<br/>wData = 8,16,32,64,128,256,512,1024,2048<br/>wLock = 1,2<br/>wProt = 0,3<br/>wQos = 0,4<br/>wRegion = 0,4<br/>nativeType = axi3,axi4<br/>eAr = 0,1<br/>eAw = 0,1</p><p style="margin-left: 90.0px;">Block:</p><p style="margin-left: 120.0px;">stateProtectionStyle = network.protectionStyle<br/>protectionStyle = network.protectionStyle<br/>registerProtectionStyle = network.protectionStyle<br/>memoryProtectionStyle = network.protectionStyle<br/>maxOutWr = 0,1,2,4,8,16,32,64,128,256,512<br/>maxOutRd = 0,1,2,4,8,16,32,64,128,256,512<br/>maxOutTotal = 0,1,2,4,8,16,32,64,128,256,512<br/>assertOn = true/false<br/>enBufWrite = network.enBufWrite<br/>incrSupported = true<br/>fixedSupported = true/false<br/>wrapSupported = true/false<br/>narrowSupport = true/false<br/>widthAdaptionSupported = true/false<br/>readInterleaveSupported = true/false<br/>atomicsSupported = false<br/>exclusivesSupported = true/false<br/>mstrArbLock = network.mstrArbLock<br/>lckStyleVld = network.lckStyleVld<br/>smiPktnumPri = network.numPri<br/>smiPktmstrArbLck = network.mstrArbLock<br/>smiPktweightsProg = false<br/>smiPktarbType = network.arbType<br/>smiPktweights= network.weights<br/>smiDpknumPri = network.numPri<br/>smiDpktmstrArbLck = network.mstrArbLock<br/>smiDpkweightsProg = false<br/>smiDpkarbType = network.arbType<br/>smiDpkweights= network.weights<br/>qosMapMode = 0<br/>enPathLookup = false<br/>pipeLevelExclMon = 0,1,2<br/>pipeLevelLut =0,1,2<br/>pipeLevelAtp = 0,1,2<br/>pipeLevelSmi = 0,1,2<br/>axiPipeR= 0,1,2<br/>axiPipeAr = 0,1,2<br/>axiPipeAw=0,1,2<br/>axiPipeW= 0,1,2<br/>axiPipeB= 0,1,2<br/>ctlPipeReq= 0,1,2<br/>ctlPipeResp= 0,1,2<br/>nodeId = 0 to Math.pow(2,wSrcId) where nodeId is unique from every block<br/>timeoutErrChk = true/false<br/>timeoutErrCount = 0 to inf<br/>timeoutUseExternalValues = true/false<br/>numPri = network.numPri<br/>ctlArbType = network.arbType<br/>ctlArbWeights =network.weights<br/>rateLmtEn = true/false<br/>rateLmtUseExternalValues = true/false<br/>rateLmtRefCntGlobal  = 1 to 65536, power of two<br/>refreshAmtGlobal  = 1 to 65536, power of two<br/>rateLmtBktGlobal = 1 to 65536, power of two<br/>rateLmtRefCntQueue_p = array of ( 1 to 65536 power of two , ...) where length = network.nVc<br/>rateLmtRefCntQueue_s =  array of ( 1 to 65536 power of two , ...) where length = network.nVc<br/>refreshAmtQueue_p =  array of ( 1 to 65536 power of two , ...) where length = network.nVc<br/>refreshAmtQueue_s =  array of ( 1 to 65536 power of two , ...) where length = network.nVc<br/>rateLmtBktQueue_p =  array of ( 1 to 65536 power of two , ...) where length = network.nVc<br/>rateLmtBktQueue_s =  array of ( 1 to 65536 power of two , ...) where length = network.nVc<br/>wRateLmtRefCntGlobal = array of (1 to 16 , ...) where length = network.nVc <br/>wRefreshAmtGlobal = array of ( 1 to 16 , ...) where length = network.nVc <br/>wRateLmtBktGlobal  = array of ( 0 to 16 , ...) where length = network.nVc <br/>wRateLmtRefCntQueue = array of (1 to 16 , ...) where length = network.nVc <br/>wRefreshAmtQueue = array of ( 1 to 16 , ...) where length = network.nVc <br/>wRateLmtBktQueue = array of ( 0 to 16 , ...) where length = network.nVc <br/>crdMngrEn = false<br/>wCrdMngrReqCnt = 0<br/>wCrdMngrDataCnt = 0 <br/>crdDataUnit = 1<br/>wCrdMngrType = 0<br/>pathLut = Array of ( Target ID to route, ... )  (Defined in Topology)<br/>wDataMax = 8,16,32,64,128,256,512,1024<br/>wDataMin = 8,16,32,64,128,256,512,1024<br/>mapBaseAddr = Target Base Address string (Defined in Topology)<br/>mapBaseMask = Target Base Mask string  (Defined in Topology)<br/>nativeToCommon = Array of (Objects containing definition which can define common layer signals from native interface, ..) (Defined in network)<br/>commonToNative = Array of (Objects containing definition which can define native layer signals from common interface, ..) (Defined in network)</p><h3 style="margin-left: 60.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-2.2.2ATUTTYPE=AXIThirdSet">2.2.2 ATUT TYPE = AXI Third Set</h3><p style="margin-left: 90.0px;">Interface:</p><p style="margin-left: 120.0px;">wWUser = wRUser = (0,1,2,3,4,5,7,8,9,15,16,17,31,32,33,63,64,65,127,128,129)*wData/8 and must be less than 200<br/>wLen = 4,8 - if nativeType = axi3, wLen = 4, else wLen = 4,8<br/>wSize = 3,4 - if nativeType = axi3, wSize = 3, else wSize = 3,4</p><p style="margin-left: 90.0px;">Block:</p><p style="margin-left: 120.0px;">nativeType = interface.nativeType<br/>wrEn = interface.eAw<br/>rdEn = interface.eAr<br/>nExclEntries = 0 to 64 - if !exclusivesSupported, then nExclEntries = 0, else nExclEntries = 1 to 64<br/>smiPktarbRdyAware = true/false - if smiPktmstrArbLck || network.mstrArbRdyAware then smiPktarbRdyAware = true else smiPktarbRdyAware = true/false<br/>smiDpktarbRdyAware = true/false - if smiDpktmstrArbLck || network.mstrArbRdyAware then smiDpktarbRdyAware = true else smiDpktarbRdyAware = true/false<br/>ctlPipeCtxt = 0...log2ceil(maxOutTotal)<br/>maxPduSz = 4,8,16,32,64,128,256,512,1024,2048,4096 where maxPduSz &gt;= wData/8 <br/>idCompMask = Array of ( true or false, ... )  where length == wArId. The number of true entries needs to equal the width of ordering ID in the packet.<br/>queueMap = Array of ( Verilog Strings,  ... ) of length network.nVc<br/>vcMap = Array of ( 0..nVc-1 , 0..nVc-1, 0..nVc-1 ... ) of length network.nVc</p><h3 style="margin-left: 60.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-2.2.3ATUTTYPE=AXIFourthSet">2.2.3 ATUT TYPE = AXI Fourth Set</h3><p style="margin-left: 90.0px;">Interface:</p><p style="margin-left: 90.0px;">Block:</p><p style="margin-left: 120.0px;">queueDepth = 0...(maxPduSz/wData) </p><h2 style="margin-left: 30.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-2.3ATUTType=APB">2.3 ATUT Type = APB</h2><h3 style="margin-left: 60.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-2.2.1ATUTType=APBSecondSet">2.2.1 ATUT Type = APB Second Set</h3><p style="margin-left: 90.0px;">Interface:</p><p style="margin-left: 120.0px;">wAddr = 12,15,16,17,31,32,33,63,64<br/>wData = 8,16,32,64<br/>wProt = 0,3<br/>wPsel = 1, 9<br/>wStrb = 0, 1, 2, 4, 8<br/>wPSlverr = 0, 1</p><p style="margin-left: 90.0px;">Block:</p><p style="margin-left: 120.0px;">stateProtectionStyle = network.protectionStyle<br/>registerProtectionStyle = network.protectionStyle<br/>memoryProtectionStyle = network.protectionStyle<br/>maxOutWr = 1<br/>maxOutRd = 1<br/>maxOutTotal = 1<br/>assertOn = true/false<br/>wrEn = true<br/>rdEn = true<br/>enBufWrite = network.enBufWrite<br/>incrSupported = true<br/>fixedSupported = false<br/>wrapSupported = false<br/>narrowSupport = false<br/>widthAdaptionSupported = true/false<br/>readInterleaveSupported = false<br/>atomicsSupported = false<br/>exclusivesSupported = true/false<br/>mstrArbLock = network.mstrArbLock<br/>lckStyleVld = network.lckStyleVld<br/>smiPktnumPri = network.numPri<br/>smiPktmstrArbLck = network.mstrArbLock<br/>smiPktweightsProg = false<br/>smiPktarbType = network.arbType<br/>smiPktweights= network.weights<br/>smiDpknumPri = network.numPri<br/>smiDpktmstrArbLck = network.mstrArbLock<br/>smiDpkweightsProg = false<br/>smiDpkarbType = network.arbType<br/>smiDpkweights= network.weights<br/>qosMapMode = 0<br/>enPathLookup = false<br/>pipeLevelApb = 0,1,2<br/>pipeLevelExclMon = 0,1,2<br/>pipeLevelLut =0,1,2<br/>pipeLevelAtp = 0,1,2<br/>pipeLevelSmi = 0,1,2<br/>ctlPipeReq= 0,1,2<br/>ctlPipeResp= 0,1,2<br/>nodeId = 0 to Math.pow(2,wSrcId) where nodeId is unique from every block<br/>timeoutErrChk = true/false<br/>timeoutErrCount = 0 to inf<br/>timeoutUseExternalValues = true/false<br/>numPri = network.numPri<br/>ctlArbType = network.arbType<br/>ctlArbWeights =network.weights<br/>rateLmtEn = true/false<br/>rateLmtUseExternalValues = true/false<br/>rateLmtRefCntGlobal  = 1 to 65536, power of two<br/>refreshAmtGlobal  = 1 to 65536, power of two<br/>rateLmtBktGlobal = 1 to 65536, power of two<br/>rateLmtRefCntQueue_p = array of ( 1 to 65536 power of two , ...) where length = network.nVc<br/>rateLmtRefCntQueue_s =  array of ( 1 to 65536 power of two , ...) where length = network.nVc<br/>refreshAmtQueue_p =  array of ( 1 to 65536 power of two , ...) where length = network.nVc<br/>refreshAmtQueue_s =  array of ( 1 to 65536 power of two , ...) where length = network.nVc<br/>rateLmtBktQueue_p =  array of ( 1 to 65536 power of two , ...) where length = network.nVc<br/>rateLmtBktQueue_s =  array of ( 1 to 65536 power of two , ...) where length = network.nVc<br/>wRateLmtRefCntGlobal = array of (1 to 16 , ...) where length = network.nVc <br/>wRefreshAmtGlobal = array of ( 1 to 16 , ...) where length = network.nVc <br/>wRateLmtBktGlobal  = array of ( 0 to 16 , ...) where length = network.nVc <br/>wRateLmtRefCntQueue = array of (1 to 16 , ...) where length = network.nVc <br/>wRefreshAmtQueue = array of ( 1 to 16 , ...) where length = network.nVc <br/>wRateLmtBktQueue = array of ( 0 to 16 , ...) where length = network.nVc <br/>crdMngrEn = false<br/>wCrdMngrReqCnt = 0<br/>wCrdMngrDataCnt = 0 <br/>crdDataUnit = 1<br/>wCrdMngrType = 0<br/>pathLut = Array of ( Target ID to route, ... )  (Defined in Topology)<br/>wDataMax = 8,16,32,64,128,256,512,1024,2048<br/>wDataMin = 8,16,32,64,128,256,512,1024,2048<br/>mapBaseAddr = Target Base Address string (Defined in Topology)<br/>mapBaseMask = Target Base Mask string  (Defined in Topology)<br/>wApbSlvDec = 0 to 3 - if (ATU includes multiple APB interfaces) then log2ceil(# of APB targets attached to ATU target) else 0. (Defined in Topology)<br/>apbSlvLut = Object of (Addr to Chip Select lookup table) - if (ATU includes multiple APB interfaces) then &lt;defined&gt; else &lt;undefined&gt;. (Defined in Topology) </p><h3 style="margin-left: 60.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-2.2.2ATUTTYPE=APBThirdSet">2.2.2 ATUT TYPE = APB Third Set</h3><p style="margin-left: 90.0px;">Interface:</p><p style="margin-left: 90.0px;">Block:</p><p style="margin-left: 120.0px;">nExclEntries = 0 to 64 - if !exclusivesSupported, then nExclEntries = 0, else nExclEntries = 1 to 64<br/>smiPktarbRdyAware = true/false - if smiPktmstrArbLck || network.mstrArbRdyAware then smiPktarbRdyAware = true else smiPktarbRdyAware = true/false<br/>smiDpktarbRdyAware = true/false - if smiDpktmstrArbLck || network.mstrArbRdyAware then smiDpktarbRdyAware = true else smiDpktarbRdyAware = true/false<br/>ctlPipeCtxt = 0...log2ceil(maxOutTotal)<br/>maxPduSz = 4,8,16,32,64,128,256,512,1024,2048,4096 where maxPduSz &gt;= wData/8 <br/>idCompMask = Array of ( true or false, ... )  where length == wArId of system. The number of true entries needs to equal the width of ordering ID in the packet.<br/>queueMap = Array of ( Verilog Strings,  ... ) of length network.nVc<br/>vcMap = Array of ( 0..nVc-1 , 0..nVc-1, 0..nVc-1 ... ) of length network.nVc</p><h3 style="margin-left: 60.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-2.2.3ATUTTYPE=APBFourthSet">2.2.3 ATUT TYPE = APB Fourth Set</h3><p style="margin-left: 90.0px;">Interface:</p><p style="margin-left: 90.0px;">Block:</p><p style="margin-left: 120.0px;">queueDepth = 0...(maxPduSz/wData) </p><h1 id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-3.0SAMRandomization">3.0 SAM Randomization</h1><h2 style="margin-left: 30.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-3.1Settheaddresswidthoftheconfigspace">3.1 Set the address width of the config space</h2><p style="margin-left: 60.0px;">Unfortunately, the address range on the config space is an interactive process because it's topology dependent but you can't specify a topology until after you specified a SAM. However, you can help the process by always putting the config space last in the SAM.</p><p style="margin-left: 60.0px;">In the case of the 4x4 random script, we can put an upper limit on how big the config space could be because we know the topologies ahead of time:</p><p style="margin-left: 60.0px;">Interrupts Accumulators (one per clock domain): 5<br/>Firewalls on every link in request (assume mesh topology): 15<br/>ATUTs: 4<br/>ATUIs: 4<br/>PMON Link Monitors: 8<br/>PMON Stats Blocks: 4<br/>Multicast Blocks: 2</p><p style="margin-left: 60.0px;">Max Number of Configurable Blocks: 62</p><p style="margin-left: 60.0px;">Address range needed for 62 blocks is 62 x 4 K rounded up to next power of 2: 256 K or 18 bits of address.</p><h2 style="margin-left: 30.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-3.1UsingtheaddresswidthsfromtheATUTs,createaSAM">3.1 Using the address widths from the ATUTs, create a SAM</h2><p style="margin-left: 60.0px;">Minimum: Stack the ATUTs in order and always put the config space last<br/>Maximum: Stack the ATUTs in a random order, but always put the config space last</p><p style="margin-left: 60.0px;">Rule: The starting offset address for an ATUT must be aligned with it's address range.</p><p style="margin-left: 60.0px;">Extra Credit: The address width of a target can be wider than the range of the target. For example, the target could be 32 bits wide, but the range of the target is from 0100 0000 - 01FF FFFF. In this case, the width of the target in the SAM is 25 bits, and you would program the mapBaseAddr to 0100 0000 and the mapBaseMask to FF00 0000. Therefore, for any target with greater than 12 bits of address, you can randomly reduce it's range within its address range and put the reduced range in the SAM.</p><p><br/></p><h1 id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-4.0ATUIRandomization">4.0 ATUI Randomization</h1><h2 style="margin-left: 30.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-2.1ATUIFirstSet">2.1 ATUI First Set</h2><p style="margin-left: 60.0px;">ATUI Type: APB/AXI</p><h2 style="margin-left: 30.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-2.2ATUIType=AXI">2.2 ATUI Type = AXI</h2><h3 style="margin-left: 60.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-2.2.1ATUIType=AXISecondSet">2.2.1 ATUI Type = AXI Second Set</h3><p style="margin-left: 90.0px;">Interface:</p><p style="margin-left: 120.0px;">wAddr = 12,15,16,17,31,32,33,63,64<br/>wArUser = wAwUser = wBUser = 0 to 200<br/>wArId = wAwId = wWId = 0,1,2,3,4,5,7,8,9,15,16,17,31,32<br/>wData = 8,16,32,64,128,256,512,1024,2048<br/>wLock = 1,2<br/>wProt = 0,3<br/>wQos = 0,4<br/>wRegion = 0,4<br/>nativeType = axi3,axi4<br/>eAr = 0,1<br/>eAw = 0,1</p><p style="margin-left: 90.0px;">Block:</p><p style="margin-left: 120.0px;">protectionStyle = network.protectionStyle<br/>maxOutWr = 0,1,2,4,8,16,32,64,128,256,512<br/>maxOutRd = 0,1,2,4,8,16,32,64,128,256,512<br/>maxOutTotal = 0,1,2,4,8,16,32,64,128,256,512<br/>enSplitting = true<br/>enReordering = true/false<br/>enDecodeError = true/false<br/>enBufWrite = network.enBufWrite<br/>incrSupported = true<br/>fixedSupported = true/false<br/>wrapSupported = true/false<br/>narrowSupport = true/false<br/>readInterleaveSupported = true/false<br/>atomicsSupported = false<br/>mstrArbLock = network.mstrArbLock<br/>lckStyleVld = network.lckStyleVld<br/>smiPktmstrArbLck = network.mstrArbLock<br/>smiPktnumPri = network.numPri<br/>smiPktweightsProg = false<br/>smiPktarbType = network.arbType<br/>smiPktweights= network.weights<br/>smiDpknumPri = network.numPri<br/>smiDpkweightsProg = false<br/>smiDpkarbType = network.arbType<br/>smiDpkweights= network.weights<br/>qosMapMode = 0<br/>enPathLookup = false<br/>pipeLevel = 0,1,2<br/>pipeLevelRob = 0,1,2<br/>pipeLevelLut =0,1,2<br/>pipeLevelAtp = 0,1,2<br/>axiPipeR= 0,1,2<br/>axiPipeAr = 0,1,2<br/>axiPipeAw=0,1,2<br/>axiPipeW= 0,1,2<br/>axiPipeB= 0,1,2<br/>ctlPipeReq= 0,1,2<br/>ctlPipeResp= 0,1,2<br/>nodeId = 0 to Math.pow(2,wSrcId) where nodeId is unique from every block<br/>modeUserBits = &quot;&quot;<br/>timeoutErrChk = true/false<br/>timeoutErrCount = 0 to inf<br/>timeoutUseExternalValues = true/false<br/>numPri = network.numPri<br/>ctlArbType = network.arbType<br/>ctlArbWeights =network.weights</p><p style="margin-left: 120.0px;">pamTid = Array of ( nodeId of Target, ... )  (Defined in Topology)<br/>pamRoute= Array of ( route to Target, ... )  (Defined in Topology)<br/>pamBaseAddr = Array of ( Base Address of Target Region , ... )  (Defined in Topology)<br/>pamBaseMask = Array of (Based on Size of Target Region , ... )  (Defined in Topology)<br/>pamMapBase = 0,1,2</p><p style="margin-left: 120.0px;">rateLmtEn = true/false<br/>rateLmtUseExternalValues = true/false<br/>rateLmtRefCntGlobal  = 1 to 65536, power of two<br/>refreshAmtGlobal  = 1 to 65536, power of two<br/>rateLmtBktGlobal = 1 to 65536, power of two<br/>rateLmtRefCntQueue_p = array of ( 1 to 65536 power of two , ...) where length = network.nVc<br/>rateLmtRefCntQueue_s =  array of ( 1 to 65536 power of two , ...) where length = network.nVc<br/>refreshAmtQueue_p =  array of ( 1 to 65536 power of two , ...) where length = network.nVc<br/>refreshAmtQueue_s =  array of ( 1 to 65536 power of two , ...) where length = network.nVc<br/>rateLmtBktQueue_p =  array of ( 1 to 65536 power of two , ...) where length = network.nVc<br/>rateLmtBktQueue_s =  array of ( 1 to 65536 power of two , ...) where length = network.nVc<br/>wRateLmtRefCntGlobal = array of (1 to 16 , ...) where length = network.nVc <br/>wRefreshAmtGlobal = array of ( 1 to 16 , ...) where length = network.nVc <br/>wRateLmtBktGlobal  = array of ( 0 to 16 , ...) where length = network.nVc <br/>wRateLmtRefCntQueue = array of (1 to 16 , ...) where length = network.nVc <br/>wRefreshAmtQueue = array of ( 1 to 16 , ...) where length = network.nVc <br/>wRateLmtBktQueue = array of ( 0 to 16 , ...) where length = network.nVc </p><p style="margin-left: 120.0px;">queuePriMap =  Array of ( 0..network.numPri,  ... ) of length network.nVc<br/>queueSecPriMap = Array of ( 0..network.numPri,  ... ) of length network.nVc</p><h3 style="margin-left: 60.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-2.2.2ATUITYPE=AXIThirdSet">2.2.2 ATUI TYPE = AXI Third Set</h3><p style="margin-left: 90.0px;">Interface:</p><p style="margin-left: 120.0px;">wWUser = wRUser = (0,1,2,3,4,5,7,8,9,15,16,17,31,32,33,63,64,65,127,128,129)*wData/8 and must be less than 200<br/>wLen = 4,8 - if nativeType = axi3, wLen = 4, else wLen = 4,8<br/>wSize = 3,4 - if nativeType = axi3, wSize = 3, else wSize = 3,4</p><p style="margin-left: 90.0px;">Block:</p><p style="margin-left: 120.0px;">nativeType = interface.nativeType<br/>wrEn = interface.eAw<br/>rdEn = interface.eAr<br/>smiPktarbRdyAware = true/false - if smiPktmstrArbLck || network.mstrArbRdyAware then smiPktarbRdyAware = true else smiPktarbRdyAware = true/false<br/>smiDpktarbRdyAware = true/false - if smiDpktmstrArbLck || network.mstrArbRdyAware then smiDpktarbRdyAware = true else smiDpktarbRdyAware = true/false<br/>pipeLevelPam = 0 ... log2ceil(pamBaseAddr.length)<br/>ctlPipeCtxt = 0...log2ceil(maxOutTotal)<br/>maxPduSz = 4,8,16,32,64,128,256,512,1024,2048,4096 where maxPduSz &gt;= wData/8 </p><p style="margin-left: 120.0px;">pamTargWidth = array of ( (ATUT[pamTid[entry]].wData/8) , ...)  If entry is striping/multicast take the minimum width from all of targets in region.<br/>pamTargNarrow = array of ( ATUT[pamTid[entry]].narrowSupported , ...)  If entry is striping/multicast use false if any target in region is false.<br/>pamTargSplitWrap = array of ( ~ATUT[pamTid[entry]].wrapSupported , ...)  If entry is striping/multicast use true if any target doesnt support wraps.<br/>pamTargReadInterleave = array of ( ATUT[pamTid[entry]].readInterleaveSupported, ...)  If entry is striping/multicast use true if any target is true<br/>pamTargFixedSupported = array of ( ATUT[pamTid[entry]].fixedSupported, ...)  If entry is striping/multicast use false if any target doesnt support fixed.<br/>pamTargIncrSupported = array of (true, true, ... )<br/>pamTargBoundary =  array of (0, 0, ... )</p><p style="margin-left: 120.0px;">idCompMask = Array of ( true or false, ... )  where length == wArId. The number of true entries needs to equal the width of ordering ID in the packet.</p><p style="margin-left: 120.0px;">pamMulti = Array of ( symphonyBlocks[pamTid[entry]]  is a Multicast Block, ... )      <br/>pamMultiUser = Array of ( true or false, ... )      <br/>pamMultiLabelUserBits = String with format &quot;[a:b]&quot; where a = log2ceil(nMulticastLabels) to wArUser-1 and b = 0 to wArUser-log2ceil(nMulticastLabels), a-b &gt;= log2ceil(nMulticastLabels)<br/>pamMode = (interfaces.modeInterface._SKIP_) ? Array of ( 0, ... ) :  Array of ( 0 to 2, ... ) <br/>pamRW = Array of ( a , ... )     where a = (ATUT[pamTid[entry]].rdEn &amp;&amp; ATUT[pamTid[entry]].wrEN) ? 0 : (ATUT[pamTid[entry]].rdEn) ? 1 : 2. If entry is striping/multicast region a is the maximum a from all targets in striping/multicast region</p><p style="margin-left: 120.0px;">pamStrp = Array of ( true/false , ... )      <br/>pamStrpGrp =  Array of ( 0 .. strpGrbTables.length-1  , ... ) </p><p style="margin-left: 120.0px;">pamTargMaxBurst = Array of ( a, ... ) where a = Min(ATUT[pamTid[entry]].maxPduSz, network.maxPduSz).  If entry is striping/multicast take the minimum a from all of targets in region.</p><p style="margin-left: 120.0px;">nStrpTarg = array of ( 2 or 4 or 8 , ...) where length = nStrpGroups<br/>strpFunc = array of ( 0,1 , ...) where length = nStrpGroups<br/>strpFuncHash = array of ( hashArray, ...) where length = nStrpGroups<br/>strpWStrpBits = array of ( 0, ..) where length = nStrpGroups<br/>strpSz = array of (power of two from (wData/8) to Math.pow(2,wAddr), ..), where length == nStrpTarg TODO: Needs better constraints<br/>strpMap = array of ( 0 or 1 or 2 , ..) where length = nStrpGroups<br/>strpGrpTables =  array of ( strpGrpTable Object, ... ) where length = nStrpGroups</p><h3 style="margin-left: 60.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-2.2.2ATUITYPE=AXIFourthSet">2.2.2 ATUI TYPE = AXI Fourth Set</h3><p style="margin-left: 90.0px;">Interface:</p><p style="margin-left: 120.0px;"><br/></p><p style="margin-left: 90.0px;">Block:</p><p style="margin-left: 120.0px;">pamMultiLabel = Array of ( pamMulti[entry] ? 1 to nMulticastLabels : 0, ... )      <br/>pamMultiMaskUserBits =  String with format &quot;[c:d]&quot; where c = log2ceil(maxMulticastTargets) to wArUser-1 and d = 0 to wArUser-log2ceil(maxMulticastTargets),c-d &gt;= log2ceil(maxMulticastTargets) , and c:d does not cross a:b in pamMultiLabelUserBits </p><p style="margin-left: 120.0px;">queueMap = Array of ( Verilog Strings,  ... ) of length network.nVc<br/>queueDepth = 0...(maxPduSz/wData) <br/>vcMap = Array of ( 0..nVc-1 , 0..nVc-1, 0..nVc-1 ... ) of length network.nVc</p><h2 style="margin-left: 30.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-2.3ATUIType=APB">2.3 ATUI Type = APB</h2><h3 style="margin-left: 60.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-2.2.1ATUIType=APBSecondSet">2.2.1 ATUI Type = APB Second Set</h3><p style="margin-left: 90.0px;">Interface:</p><p style="margin-left: 90.0px;">       wPsel = 1 to 9<br/>       wAddr = 12,15,16,17,31,32,33,63,64  <br/>       wData = 8,16,32,64 <br/>       wProt = 0,3<br/>       wStrb = 0,1,2,4,8<br/>       wPSlverrr = 0,1</p><p style="margin-left: 90.0px;">Block:</p><p style="margin-left: 120.0px;">protectionStyle = network.protectionStyle<br/>maxOutWr = 1<br/>maxOutRd = 1<br/>maxOutTotal = 1<br/>enSplitting = true<br/>enReordering = false<br/>enDecodeError = true/false<br/>enBufWrite = network.enBufWrite<br/>incrSupported = true<br/>fixedSupported = false<br/>wrapSupported = false<br/>narrowSupport = false<br/>readInterleaveSupported = false<br/>atomicsSupported = false<br/>mstrArbLock = network.mstrArbLock<br/>lckStyleVld = network.lckStyleVld<br/>smiPktmstrArbLck = network.mstrArbLock<br/>smiPktnumPri = network.numPri<br/>smiPktweightsProg = false<br/>smiPktarbType = network.arbType<br/>smiPktweights= network.weights<br/>smiDpknumPri = network.numPri<br/>smiDpkweightsProg = false<br/>smiDpkarbType = network.arbType<br/>smiDpkweights= network.weights<br/>qosMapMode = 0<br/>enPathLookup = false<br/>pipeLevel = 0,1,2<br/>pipeLevelRob = 0,1,2<br/>pipeLevelLut =0,1,2<br/>pipeLevelAtp = 0,1,2<br/>axiPipeR= 0,1,2<br/>axiPipeAr = 0,1,2<br/>axiPipeAw=0,1,2<br/>axiPipeW= 0,1,2<br/>axiPipeB= 0,1,2<br/>ctlPipeReq= 0,1,2<br/>ctlPipeResp= 0,1,2<br/>nodeId = 0 to Math.pow(2,wSrcId) where nodeId is unique from every block<br/>modeUserBits = &quot;&quot;<br/>timeoutErrChk = true/false<br/>timeoutErrCount = 0 to inf<br/>timeoutUseExternalValues = true/false<br/>numPri = network.numPri<br/>ctlArbType = network.arbType<br/>ctlArbWeights =network.weights</p><p style="margin-left: 120.0px;">pamTid = Array of ( nodeId of Target, ... )  (Defined in Topology)<br/>pamRoute= Array of ( route to Target, ... )  (Defined in Topology)<br/>pamBaseAddr = Array of ( Base Address of Target Region , ... )  (Defined in Topology)<br/>pamBaseMask = Array of (Based on Size of Target Region , ... )  (Defined in Topology)<br/>pamMapBase = 0,1,2</p><p style="margin-left: 120.0px;">rateLmtEn = true/false<br/>rateLmtUseExternalValues = true/false<br/>rateLmtRefCntGlobal  = 1 to 65536, power of two<br/>refreshAmtGlobal  = 1 to 65536, power of two<br/>rateLmtBktGlobal = 1 to 65536, power of two<br/>rateLmtRefCntQueue_p = array of ( 1 to 65536 power of two , ...) where length = network.nVc<br/>rateLmtRefCntQueue_s =  array of ( 1 to 65536 power of two , ...) where length = network.nVc<br/>refreshAmtQueue_p =  array of ( 1 to 65536 power of two , ...) where length = network.nVc<br/>refreshAmtQueue_s =  array of ( 1 to 65536 power of two , ...) where length = network.nVc<br/>rateLmtBktQueue_p =  array of ( 1 to 65536 power of two , ...) where length = network.nVc<br/>rateLmtBktQueue_s =  array of ( 1 to 65536 power of two , ...) where length = network.nVc<br/>wRateLmtRefCntGlobal = array of (1 to 16 , ...) where length = network.nVc <br/>wRefreshAmtGlobal = array of ( 1 to 16 , ...) where length = network.nVc <br/>wRateLmtBktGlobal  = array of ( 0 to 16 , ...) where length = network.nVc <br/>wRateLmtRefCntQueue = array of (1 to 16 , ...) where length = network.nVc <br/>wRefreshAmtQueue = array of ( 1 to 16 , ...) where length = network.nVc <br/>wRateLmtBktQueue = array of ( 0 to 16 , ...) where length = network.nVc </p><p style="margin-left: 120.0px;">queuePriMap =  Array of ( 0..network.numPri,  ... ) of length network.nVc<br/>queueSecPriMap = Array of ( 0..network.numPri,  ... ) of length network.nVc</p><h3 style="margin-left: 60.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-2.2.2ATUITYPE=APBThirdSet">2.2.2 ATUI TYPE = APB Third Set</h3><p style="margin-left: 90.0px;">Interface:</p><p style="margin-left: 120.0px;"><br/></p><p style="margin-left: 90.0px;">Block:</p><p style="margin-left: 120.0px;">nativeType = interface.nativeType<br/>wrEn = interface.eAw<br/>rdEn = interface.eAr<br/>smiPktarbRdyAware = true/false - if smiPktmstrArbLck || network.mstrArbRdyAware then smiPktarbRdyAware = true else smiPktarbRdyAware = true/false<br/>smiDpktarbRdyAware = true/false - if smiDpktmstrArbLck || network.mstrArbRdyAware then smiDpktarbRdyAware = true else smiDpktarbRdyAware = true/false<br/>pipeLevelPam = 0 ... log2ceil(pamBaseAddr.length)<br/>ctlPipeCtxt = 0...log2ceil(maxOutTotal)<br/>maxPduSz = wData/8 </p><p style="margin-left: 120.0px;">pamTargWidth = array of ( (ATUT[pamTid[entry]].wData/8) , ...)  If entry is striping/multicast take the minimum width from all of targets in region.<br/>pamTargNarrow = array of ( ATUT[pamTid[entry]].narrowSupported , ...)  If entry is striping/multicast use false if any target in region is false.<br/>pamTargSplitWrap = array of ( ~ATUT[pamTid[entry]].wrapSupported , ...)  If entry is striping/multicast use true if any target doesnt support wraps.<br/>pamTargReadInterleave = array of ( ATUT[pamTid[entry]].readInterleaveSupported, ...)  If entry is striping/multicast use true if any target is true<br/>pamTargFixedSupported = array of ( ATUT[pamTid[entry]].fixedSupported, ...)  If entry is striping/multicast use false if any target doesnt support fixed.<br/>pamTargIncrSupported = array of (true, true, ... )<br/>pamTargBoundary =  array of (0, 0, ... )</p><p style="margin-left: 120.0px;">idCompMask = Array of ( true or false, ... )  where length == wArId. The number of true entries needs to equal the width of ordering ID in the packet.</p><p style="margin-left: 120.0px;">pamMulti = Array of ( symphonyBlocks[pamTid[entry]]  is a Multicast Block, ... )      <br/>pamMultiUser = Array of ( true or false, ... )      <br/>pamMultiLabelUserBits = String with format &quot;[a:b]&quot; where a = log2ceil(nMulticastLabels) to wArUser-1 and b = 0 to wArUser-log2ceil(nMulticastLabels), a-b &gt;= log2ceil(nMulticastLabels)<br/>pamMode = (interfaces.modeInterface._SKIP_) ? Array of ( 0, ... ) :  Array of ( 0 to 2, ... ) <br/>pamRW = Array of ( a , ... )     where a = (ATUT[pamTid[entry]].rdEn &amp;&amp; ATUT[pamTid[entry]].wrEN) ? 0 : (ATUT[pamTid[entry]].rdEn) ? 1 : 2. If entry is striping/multicast region a is the maximum a from all targets in striping/multicast region</p><p style="margin-left: 120.0px;">pamStrp = Array of ( true/false , ... )      <br/>pamStrpGrp =  Array of ( 0 .. strpGrbTables.length-1  , ... ) </p><p style="margin-left: 120.0px;">pamTargMaxBurst = Array of ( a, ... ) where a = Min(ATUT[pamTid[entry]].maxPduSz, network.maxPduSz).  If entry is striping/multicast take the minimum a from all of targets in region.</p><p style="margin-left: 120.0px;">nStrpTarg = array of ( 2 or 4 or 8 , ...) where length = nStrpGroups<br/>strpFunc = array of ( 0,1 , ...) where length = nStrpGroups<br/>strpFuncHash = array of ( hashArray, ...) where length = nStrpGroups<br/>strpWStrpBits = array of ( 0, ..) where length = nStrpGroups<br/>strpSz = array of (power of two from (wData/8) to Math.pow(2,wAddr), ..), where length == nStrpTarg TODO: Needs better constraints<br/>strpMap = array of ( 0 or 1 or 2 , ..) where length = nStrpGroups<br/>strpGrpTables =  array of ( strpGrpTable Object, ... ) where length = nStrpGroups</p><h3 style="margin-left: 60.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-2.2.2ATUITYPE=APBFourthSet">2.2.2 ATUI TYPE = APB Fourth Set</h3><p style="margin-left: 90.0px;">Interface:</p><p style="margin-left: 120.0px;"><br/></p><p style="margin-left: 90.0px;">Block:</p><p style="margin-left: 120.0px;">pamMultiLabel = Array of ( pamMulti[entry] ? 1 to nMulticastLabels : 0, ... )      <br/>pamMultiMaskUserBits =  String with format &quot;[c:d]&quot; where c = log2ceil(maxMulticastTargets) to wArUser-1 and d = 0 to wArUser-log2ceil(maxMulticastTargets),c-d &gt;= log2ceil(maxMulticastTargets) , and c:d does not cross a:b in pamMultiLabelUserBits </p><p style="margin-left: 120.0px;">queueMap = Array of ( Verilog Strings,  ... ) of length network.nVc<br/>queueDepth = 0...(maxPduSz/wData) <br/>vcMap = Array of ( 0..nVc-1 , 0..nVc-1, 0..nVc-1 ... ) of length network.nVc</p><h2 style="margin-left: 30.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-2.4ATUIAddPMON">2.4 ATUI Add PMON</h2><p style="margin-left: 60.0px;">Randomly add a PMON set to an ATUI</p><h3 style="margin-left: 60.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-2.4.1PMONBlocksFirstSet">2.4.1 PMON Blocks First Set</h3><p>                        Stats block:<br/>                            tmrEvtMap            = Array of timer definitions including what events control the timers.<br/>                            evtDefines             = Define the events that drive the timer.<br/>                            regFieldDefines     = Define register fields that are used to generate events.</p><p>                        Probe block:<br/>                            fieldArray              = Array of packet fields that are to be monitored.<br/>                            evtDefines             = Define the events that are to be generated.<br/>                            regFieldDefines     = Define register fields that are used to generate events.<br/>                            </p><p>                         Interface:<br/>                            Set the length of evtInterfaces and names of each to match the number of events generated by probe and received by Stats.<br/>                            Set intInterface on probe and/or Stats depending on whether or not there are any events are marked as interrupts in evtDefines.</p><p style="margin-left: 60.0px;"><br/></p><h3 style="margin-left: 60.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-2.4.2PMONBlocksSecondSet">2.4.2 PMON Blocks Second Set</h3><p>                    <br/>                            </p><p style="margin-left: 60.0px;"><br/></p><h1 id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-5.0TopologyRandomization">5.0 Topology Randomization</h1><h2 style="margin-left: 30.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-5.1SelectTopologyStyle">5.1 Select Topology Style</h2><p style="margin-left: 60.0px;">Topology Style = mesh, ring, irregular</p><p style="margin-left: 60.0px;">Mesh, ring and irregular topologies with loops can only be picked if network.mstrArbLck = true.</p><h2 style="margin-left: 30.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-5.2EvaluateTopologyforloops">5.2 Evaluate Topology for loops</h2><p style="margin-left: 60.0px;">If topology has loops set network.networkHasCycles = true, else false;</p><h2 style="margin-left: 30.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-5.3SelectSwitchStyleandaddnetworklevelparameterstoswitches">5.3 Select Switch Style and add network level parameters to switches</h2><p style="margin-left: 60.0px;">Switch Style = buffered/flowThru - If (network.nVc &gt; 1 || network.networkHasCycles || network.mstrArbLck || netWork.mstrArbrdyAware) Switch Style = buffered, else buffered/flowThru</p><p style="margin-left: 60.0px;">for (I in all switches) {<br/>  I.mstrArbLck = network.mstrArbLck<br/>  I.vcLckStyleVld = network.lckStyleVld<br/>  I.mstrLckStyleVld = network.lckStyleVld<br/>  if (switch type == flowThru) {<br/>    for (J in all I.outputs) {<br/>      I.mstrArbRdyAware[J] = network.mstrArbRdyAware<br/>    }<br/>  }<br/>}</p><h2 style="margin-left: 30.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-5.4RandomaddpipesandFIFOstolinksandaddnetworklevelparameterstopipesandFIFOs">5.4 Random add pipes and FIFOs to links and add network level parameters to pipes and FIFOs</h2><p style="margin-left: 60.0px;">pipe &amp; fifo Style = normal/VC - If (network.nVc &gt; 1) pipe &amp; fifo Style = VC, else pipe &amp; fifo Style = normal</p><p style="margin-left: 60.0px;">for (I in all pipes &amp; fifos) {<br/>  I.lckStyleVld = network.lckStyleVld<br/>  if (network.nVc &gt; 1) {<br/>    I.mstrArbLck = network.mstrArbLck<br/>    I.mstrArbRdyAware = network.mastArbRdyAware<br/>    }<br/>  }<br/>}</p><h2 style="margin-left: 30.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-5.6Addmulticastblocks(true/false)">5.6 Add multicast blocks (true/false)</h2><p style="margin-left: 60.0px;">Topology must equal mesh to add predetermine multicast blocks for now.</p><h3 style="margin-left: 60.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-5.6.1MulticastFirstSet">5.6.1 Multicast First Set</h3><p style="margin-left: 90.0px;">is nVc &gt; 1?</p><h4 style="margin-left: 90.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-5.5.1.1nVc==1,sym_multicastSecondSet">5.5.1.1 nVc == 1, sym_multicast Second Set</h4><p style="margin-left: 120.0px;">protectionStyle = network.protectionStyle<br/>numLabels = 1<br/>noRegs = false<br/>enBufWrite = network.enBufWrite<br/>createCSR = true<br/>numOutStanding = 1,2,4,8,16,32,64,128,256,512 - numOutstanding &lt;= to the maximum atui.block.maxOutWr that can talk to multicast tree<br/>pktSize = 1,2,4,8,16,32,64,128,256,512,1024 - if (network.networkHasCycles || multicastTreesShareResources) pktSize = min(max(atui.block.maxPduSz/interface.atp.wData that can talk to multicast tree),network.maxPktSize/interface.atp.wData,max(atut.block.maxPduSz/interface.atp.wData) that are in multicast tree) else pktSize = 1,2,4,8,16,32,64,128,256,512,1024 <br/><br/></p><h4 style="margin-left: 90.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-5.5.1.2nVc&gt;1,sym_vc_multicastSecondSet">5.5.1.2 nVc &gt; 1, sym_vc_multicast Second Set</h4><p style="margin-left: 120.0px;">protectionStyle = network.protectionStyle<br/>numLabels = 1<br/>noRegs = false<br/>enBufWrite = network.enBufWrite<br/>createCSR = true<br/>numOutStanding = 1,2,4,8,16,32,64,128,256,512 - numOutstanding &lt;= to the maximum atui.block.maxOutWr that can talk to multicast tree<br/>pktSize = 1,2,4,8,16,32,64,128,256,512,1024 - if (network.networkHasCycles || multicastTreesShareResources) pktSize = min(max(atui.block.maxPduSz/interface.atp.wData that can talk to multicast tree),network.maxPktSize/interface.atp.wData,max(atut.block.maxPduSz/interface.atp.wData) that are in multicast tree) else pktSize = 1,2,4,8,16,32,64,128,256,512,1024<br/>mstrArbLock = network.mstrArbLock<br/>lckStyleValid = network.lckStyleValid<br/>masterArbRdyAware = network.masterArbRdyAware</p><h2 style="margin-left: 30.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-5.6RandomlyaddfirewallstorequestnetworkATPlinks">5.6 Randomly add firewalls to request network ATP links</h2><h2 style="margin-left: 30.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-5.7Randomlyassignpacketstyles,clocksandATPwidthstoallblocks">5.7 Randomly assign packet styles, clocks and ATP widths to all blocks</h2><p style="margin-left: 60.0px;">Limit the number of clock domains to 5.</p><p style="margin-left: 60.0px;">If generating a random UPF bench, blocks have preassigned clock domains and power domains, topology must be mesh, but ATP widths can be random.</p><h2 style="margin-left: 30.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-5.8AutoadapterATPlinksandaddnetworklevelsettingstoadapters">5.8 Auto adapter ATP links and add network level settings to adapters</h2><p style="margin-left: 60.0px;">adapter Style = normal/VC - If (network.nVc &gt; 1) adapter Style = VC, else adapter Style = normal</p><p style="margin-left: 60.0px;">for (I in all adapters except pipes and FIFOs) {<br/>  if (network.nVc &gt; 1) {<br/>    I.lckStyleVld = network.lckStyleVld<br/>    I.mstrArbLck = network.mstrArbLck<br/>    I.mstrArbRdyAware = network.mastArbRdyAware<br/>    }<br/>  }<br/>}</p><h2 style="margin-left: 30.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-5.9Settopologydependentnetworkparameters">5.9 Set topology dependent network parameters</h2><p style="margin-left: 60.0px;">network.networkHasDwConverters = true/false<br/>network.networkHasFirewalls = true/false<br/>network.networkHasCycles = true/false</p><h1 id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-6.0Cleanup">6.0 Cleanup</h1><h2 style="margin-left: 30.0px;" id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-6.1ATUIcleanup">6.1 ATUI clean up</h2><p style="margin-left: 60.0px;">wDataMax = 0<br/>wDataMin = 2048<br/>for (I in all ATUs) {<br/>  if I.interface.wData &gt; wDataMax then wDataMax = I.interface.wData<br/>  if I.interface.wData &lt; wDataMin then wDataMin = I.interface.wData<br/>}<br/>for (I in all ATUs) {<br/>  I.block.wDataMax = wDataMax<br/>  I.block.wDataMin = wDataMin<br/>  I.block.widthAdaptherSupported = network.networkHasDwConverters<br/>}</p><p style="margin-left: 60.0px;"><strong>Beat Buffer Entries</strong></p><p style="margin-left: 60.0px;">for (I in all ATUs) {</p><p style="margin-left: 60.0px;">   narrowInterleavedTarget = false;</p><p style="margin-left: 60.0px;">   for (nodeId in I.pamTid) {<br/>      if(ATUT[nodeId].wData &lt; I.wData &amp;&amp; ATUT[nodeId].readInterleaveSupported){</p><p style="margin-left: 60.0px;">        narrowInterleavedTarget = true;</p><p style="margin-left: 60.0px;">      }<br/>   }</p><p style="margin-left: 60.0px;">   beatBufferEntries = (narrowInterleavedTarget) ? 1 to I.maxOutRd : 0;</p><p style="margin-left: 60.0px;">}</p><p style="margin-left: 60.0px;"><br/></p><p style="margin-left: 60.0px;"><br/></p><h1 id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-7.0UseMaestrotoRandomizedPreMapParameters">7.0 Use Maestro to Randomized Pre Map Parameters</h1><p>If the above is done correctly and the constraints are properly in Maestro, this should work.</p><h1 id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-8.0Mapdesign">8.0 Map design</h1><h1 id="HW-CTFRandomizationOrderofCustomerSettablePre-Mappedparameters-9.0UseMaestrotoRandomizedPostMapParameters">9.0 Use Maestro to Randomized Post Map Parameters</h1><p>If the above is done correctly and the constraints are properly in Maestro, this should work.</p><p><br/></p><p><br/></p>