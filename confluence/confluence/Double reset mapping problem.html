<h1 id="Doubleresetmappingproblem-Summary">Summary</h1><p>Current undoable mapped object deletion doesn't support multiple resets.</p><p>We create only one temporary array for object ids removed from certain &quot;mappedObjects&quot; object array.</p><p>We can use it only once to change original object path names in underlying HierString→ObjectID storage. On the second attempt, the old object's names remain in storage which causes conflicts.</p><h1 id="Doubleresetmappingproblem-Resetmappingclasseschain">Reset mapping classes chain</h1><p>The whole chain of classes participating in mapping reset is illustrated in the picture</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16165045/ResetMappingClassChain.png?api=v2"></span></p><h1 id="Doubleresetmappingproblem-DALobjectsstorageorganization">DAL objects storage organization</h1><p>In DAL <code>ParameterFacetImpl</code> class delegates object storage manipulations (allocate, find, remove) to <code>ParameterFacetImpl::store_</code>  attribute of type <code>TypedKeyValueStore</code></p><p>Objects storage (TypedKeyValueStore class) consists of two parts:</p><ul><li>Memory storage for objects</li><li>HierString → ObjectID table for fast searching by name</li></ul><p>When we add objects to the storage we allocate a new place in memory and create a corresponding record in the table to be able to find objects quickly by their path (HierString).</p><p>Overview diagram is on the picture:</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16165045/DAL_storage_organization.png?api=v2"></span></p><h1 id="Doubleresetmappingproblem-UndoableDALobjectsdeletion">Undoable DAL objects deletion</h1><p>This topic is partially covered in the <a class="external-link" href="https://confluence.arteris.com/display/ENGR/Undo+command+for+Remove+Object" rel="nofollow">article</a>.</p><p>We are using the &quot;move approach&quot; which consists of two parts:</p><ul><li>Replace object IDs</li><li>Rename objects in HierString → ObjectID storage</li></ul><p>IDs replacement means the<u> creation of an additional object</u> array in undo storage and r<u>eplacing here object IDs</u> from the source array.</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16165045/IDsReplacement.png?api=v2"></span></p><p>Renaming objects means <u>updating the HierString → ID storage</u> by making removed objects be found by paths related to a temporary object array.</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16165045/HierStringToIdTableUpdate.png?api=v2"></span></p><h1 id="Doubleresetmappingproblem-DalObjectsStorageclassoverview">DalObjectsStorage class overview</h1><p>This class is responsible for temporary arrays for keeping removed objects' IDs management.</p><p>The objects of this class (we have one inside AdmUndoStorage) have to be mapped to the proper object array in undo storage.</p><p>When we store objects in this storage this class creates (or searches for already created one) temporary objects array and moves objects to be removed in this array.</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16165045/DalObjectsStorageClassIllustration.png?api=v2"></span></p><h2 id="Doubleresetmappingproblem-Aproblemwhenwetrytostoreanobjectofthesamesourcearraytwice">A problem when we try to store an object of the same source array twice</h2><p>Moving objects requires two steps:</p><ul><li>Replace ID from parent array to temporary array</li><li>Rename object in HierString → ID storage</li></ul><p><u>One temporary array provides one unique name</u> to properly make the second step.</p><p>During the second attempt, renaming won't be successful and the <u>old object name would be kept in storage</u> confusing upcoming operations.</p><h1 id="Doubleresetmappingproblem-Possiblesolutions">Possible solutions</h1><h2 id="Doubleresetmappingproblem-Forcefullycleantemporaryarraywithpreviousmappingresults">Forcefully clean temporary array with previous mapping results</h2><p>The idea is to clean temporaries that was created during the previous reset.</p><p>It solves the problem with mapping crashes but may corrupt undo stack because it will contain commands that would have problems with undo.</p><h2 id="Doubleresetmappingproblem-Keepstackofresetmappings">Keep stack of reset mappings</h2><p>Instead of keeping only one temporary array for removed mapped objects we may keep stack of such arrays.</p><p>Every time we reset mapping for certain &quot;mappedObjects&quot; array we add new temporary.</p><p>When we try to undo we take a temporary on the top of stack, replace items back and remove item from stack.</p><p>Further redo should place new temporary again so we no problems with redo are expected.</p><p>This solution allows to undo multiple mapping resets but may cost some memory in run-time to keep all data</p><p><br/></p>