<p><style type='text/css'>/*<![CDATA[*/
div.rbtoc1759724496889 {padding: 0px;}
div.rbtoc1759724496889 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1759724496889 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class='toc-macro rbtoc1759724496889'>
<ul class='toc-indentation'>
<li><a href='#NCBUWithCCPTestPlan-1Introduction'>1 Introduction</a></li>
<li><a href='#NCBUWithCCPTestPlan-2Testbenchdescription'>2 Testbench description</a>
<ul class='toc-indentation'>
<li><a href='#NCBUWithCCPTestPlan-2.1TBdiagram'>2.1 TB diagram</a></li>
<li><a href='#NCBUWithCCPTestPlan-2.2ListanddescriptionofTBcomponents'>2.2 List and description of TB components</a>
<ul class='toc-indentation'>
<li><a href='#NCBUWithCCPTestPlan-2.2.1Monitors'>2.2.1 Monitors</a>
<ul class='toc-indentation'>
<li><a href='#NCBUWithCCPTestPlan-2.2.1.1AXI4Monitor'>2.2.1.1 AXI4 Monitor</a></li>
<li><a href='#NCBUWithCCPTestPlan-2.2.1.2SFIMonitor'>2.2.1.2 SFI Monitor</a></li>
</ul>
</li>
<li><a href='#NCBUWithCCPTestPlan-2.2.2BFMs'>2.2.2 BFMs</a>
<ul class='toc-indentation'>
<li><a href='#NCBUWithCCPTestPlan-2.2.2.1SystemBFM'>2.2.2.1 System BFM</a></li>
</ul>
</li>
<li><a href='#NCBUWithCCPTestPlan-2.2.3NCBUScoreboard'>2.2.3 NCBU Scoreboard</a></li>
<li><a href='#NCBUWithCCPTestPlan-2.2.4SystemVerilogAssertions'>2.2.4 System Verilog Assertions</a></li>
<li><a href='#NCBUWithCCPTestPlan-2.2.5EndofSimChecker'>2.2.5 End of Sim Checker</a></li>
<li><a href='#NCBUWithCCPTestPlan-2.2.6Injectors'>2.2.6 Injectors</a></li>
</ul>
</li>
</ul>
</li>
<li><a href='#NCBUWithCCPTestPlan-3ConfigurationSpace'>3 Configuration Space</a>
<ul class='toc-indentation'>
<li><a href='#NCBUWithCCPTestPlan-3.1NCBUMainParameters'>3.1 NCBU Main Parameters</a></li>
<li><a href='#NCBUWithCCPTestPlan-3.2NCBUStaticConfigurationAPFusedforConcertov2.0'>3.2 NCBU Static Configuration APF used for Concerto v2.0</a></li>
</ul>
</li>
<li><a href='#NCBUWithCCPTestPlan-4Features'>4 Features</a>
<ul class='toc-indentation'>
<li><a href='#NCBUWithCCPTestPlan-4.1MainFeatures'>4.1 Main Features</a></li>
</ul>
</li>
<li><a href='#NCBUWithCCPTestPlan-5Errors'>5 Errors</a>
<ul class='toc-indentation'>
<li><a href='#NCBUWithCCPTestPlan-5.1Single-biterror'>5.1 Single-bit error</a></li>
<li><a href='#NCBUWithCCPTestPlan-5.2Double-biterror'>5.2 Double-bit error</a></li>
<li><a href='#NCBUWithCCPTestPlan-5.3Protocolerror'>5.3 Protocol error</a></li>
</ul>
</li>
<li><a href='#NCBUWithCCPTestPlan-6ErrorLogging'>6 Error Logging</a></li>
<li><a href='#NCBUWithCCPTestPlan-7PowerManagement'>7 Power Management</a></li>
<li><a href='#NCBUWithCCPTestPlan-8CSR&amp;MntOps'>8 CSR &amp; MntOps</a></li>
<li><a href='#NCBUWithCCPTestPlan-9.AdvancedCoverage(Crossofmulti-features,Timingsensitivescenariostohit,etc)'>9. Advanced Coverage (Cross of multi-features, Timing sensitive scenarios to hit, etc)</a></li>
<li><a href='#NCBUWithCCPTestPlan-10Performance(LatencyandBandwidth)'>10 Performance (Latency and Bandwidth)</a></li>
<li><a href='#NCBUWithCCPTestPlan-11.Regressionscriptcommand'>11. Regression script command</a></li>
<li><a href='#NCBUWithCCPTestPlan-12.CodeCoverageMeetingMinutesandFeedbacknotes.'>12. Code Coverage Meeting Minutes and Feedback notes.</a></li>
<li><a href='#NCBUWithCCPTestPlan-ActionItems'>Action Items</a></li>
</ul>
</div></p><h2 id="NCBUWithCCPTestPlan-1Introduction">1 Introduction</h2><p>The document provides a detailed testplan for verifying NCBU with CCP block.  </p><p>For NCBU the input port will be configured as an AXI4 port by tying off AxSNOOP, AxBAR and AxDOMAIN signals. AxDOMAIN should be tied to 1 to generate ReadOnce. </p><p>Here is the list of features that NCBU supports and need to be verified.</p><ul><li>NCBU supports read once, write-unique and write-line-unique transactions.</li><li>Multi-line transaction i.e AxLen can be 0-255 for INCR and 1,3,7,15 for WRAP.  </li><li>Support for accepting multiple transaction with same AxId.  </li><li>Support for chaining of same address to enable processing different read/write transactions with the same order that it was received. </li><li>Cache module i.e CCP supports MSI-IX and MEI cache model. </li><li>Burst type INCR and WRAP. </li></ul><p>NCBU doesn't support following features. </p><ul><li>DVM </li><li>Barrier Support </li><li>Fixed burst-type is not supported. </li></ul><h2 id="NCBUWithCCPTestPlan-2Testbenchdescription">2 Testbench description</h2><h3 id="NCBUWithCCPTestPlan-2.1TBdiagram">2.1 TB diagram</h3><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16170532/image2017-6-13%2013:31:49.png?api=v2"></span></p><h3 id="NCBUWithCCPTestPlan-2.2ListanddescriptionofTBcomponents">2.2 List and description of TB components</h3><h4 id="NCBUWithCCPTestPlan-2.2.1Monitors">2.2.1     Monitors</h4><h5 id="NCBUWithCCPTestPlan-2.2.1.1AXI4Monitor">2.2.1.1  AXI4 Monitor</h5><p>This monitor looks at the following interfaces between the AXI4 BFM (or one of the AXI4 VIPs) and the NCBU DUT:</p><ul><li>AXI4 Read Address Channel</li><li>AXI4 Write Address Channel</li><li>AXI4 Read Data Channel</li><li>AXI4 Write Data Channel</li><li>AXI4 Write Response Channel</li></ul><p>On the data channels, the monitor will collect all beats of data before sending a complete packet with all the data.</p><h5 id="NCBUWithCCPTestPlan-2.2.1.2SFIMonitor">2.2.1.2  SFI Monitor </h5><p>The SFI monitor looks at the SFI master and slave request and response interfaces between the NCBU and the system BFM.</p><h4 id="NCBUWithCCPTestPlan-2.2.2BFMs">2.2.2     BFMs</h4><p>NCBU will be using the in-house ACE BFM configured in AXI4 mode for generating the traffic from the agent.</p><h5 id="NCBUWithCCPTestPlan-2.2.2.1SystemBFM">2.2.2.1  System BFM </h5><p>The system BFM will act as the rest of the system to the NCBU DUT. It will process requests sent by the NCBU and will send snoops to the NCBU for addresses previously requested, currently in process or random addresses.</p><p>Improvements were made to system BFM to send snoops by using the addresses from the cache model in the NCBU checker. Also system BFM architecture was updated to support individual Request/Response driver and sequencer channel. This was done to solve the issue of bubble in the processing of Master and Slave request/response transactions. </p><h4 id="NCBUWithCCPTestPlan-2.2.3NCBUScoreboard">2.2.3     NCBU Scoreboard</h4><p>The NCBU scoreboard monitors all the external signals coming in and out of the NCBU DUT. It is fed all of this information by the AXI4 monitor (which monitors signals between the AXI4 BFM and the NCBU), the SFI monitor (which monitors signals between the System BFM and the NCBU) and the CCP monitor (which monitors signals between the CCP and NCBU).</p><p>The NCBU scoreboard performs interface level checks between the AXI4 and the SFI side. Here are the checks it performs:</p><ul><li>Check to make sure that address are always processed in order.  Any transaction that has address collision is put to sleep. The algorithm used for checking this is as follows. If any of the below condition are not met then the transaction is put to sleep. <ul><li>For No-Allocate Txn<ul><li>Tag pipeline is seen</li><li>STRReq is received. </li><li>DTRReq is received. </li><li>If DTWReq is required then DTWRsp is received. </li></ul></li><li>For Allocate Txn<ul><li>Tag pipeline is seen</li><li>Fill Ctrl is seen on CCP interface</li><li>Fill Done is received on the CCP interface</li></ul></li><li>Evict <ul><li>Tag pipeline is seen</li><li>Updated Response is received. </li><li>DTWResp is received. </li></ul></li><li>Read-hit/Write-hit<ul><li>Tag pipeline is seen</li><li>If a read-hit is seen on the Tag pipeline but the CCP data is not yet received. </li><li>If a write-hit is seen on the Tag pipeline but data is not seen on CCP write port. </li></ul></li></ul></li><li>Check for CCP busy and stale vector. CCP RTL uses busy vector to determine whether this way is protected or not. NCBU checker checks the busy vector by collecting all the txn with following parameters pending <ul><li> For Allocate txn or Write-Hit Upgrade txn<ul><li>FillCtrl is not seen on CCP interface or</li><li>Fill Done is not seen on CCP interface </li></ul></li></ul></li><li>NCBU checker implements a cache model to track each cacheline that is committed to CCP. Using this cache model NCBU checker can predict the read-hit, snoop-hit and evict data.  Using the cache model NCBU checker can also track the correct output for MntOp transactions. </li><li>NCBU checker also checks for each Fill to CCP the state committed to CCP is correct as per the cache model with which NCBU is configured with. </li><li>NCBU checker has a check to verify delayed snoop response. Snoop response should be delayed for a snoop request that hits a pending evict. </li><li>NCBU checker also checks that the Fill Data committed by NCBU to CCP is correct. It predicts this by merging the agent data with the DTR data that it received from the SFI bus. </li><li><p>NCBU can now support multiple transaction with same AxID. NCBU should not block any request for the AxID as long as there is space in the OTT. However as per the AXI spec the response for AxID with same value should always be ordered.  NCBU checker ensures that the transaction with same AxID are always returned in the order received by NCBU AXI port. </p></li><li>Check all AXI fields in the follow up AXI transactions (AXI Read Data channel fields are compared to AXI Read Address channel fields to make sure they match)<ul><li>Check to make sure that SFI fields on outgoing SFI messages match SFI fields received on incoming SFI messages. For example, an outgoing DTR request that follows an incoming SNP request should have the same SFIPriv AceUser field.</li><li>Check to make sure that SFI fields on outgoing SFI messages match AXI fields received on incoming AXI transactions. For example, an outgoing DTW message should have the same data as an incoming AXI data on the write data channel.</li><li>Making sure that SFI transaction IDs for SFI outgoing request packets match the transaction ID requirements (Trans ID prefix) as laid out by the Concerto NCBU architectural spec.</li><li>Making sure that SFI transaction IDs for SFI outgoing requests are unique and do not match any SFI requests for which SFI responses have not been received.</li><li>Check to make sure that outgoing SFI requests (and incoming SFI requests) have the correct SFIPriv message type. The only SFI requests that are outgoing are CMDreq, DTWreq and DTRreq (only for snoops). The only SFI requests that are incoming are SNPreq, DTRreq and STRreq.</li><li>Check to make sure that the exact number of SFI DTR request messages are received (based on CMD request type and/or STR request ST field).</li><li>Check to make sure that, if multiple DTR request messages are received, the data in them is exactly the same.</li><li>Check DMI and DCE unit IDs on Concerto message requests going to those units based on the address.</li><li>Check SFI snoop response correctly reflects the snoop response.</li><li>Check SFI NonPriv fields based on tables 21-28 in the Concerto NCBU architectural spec.</li><li>Check to make sure that the STRReq and STRRsp messages are legal based on the CmdReq message.</li><li>Checks for error conditions.</li><li>Calculation of DCE/DMI unit ID based on address.</li><li>Handling partial writes/multiple cache lines (including different data bus widths between AXI and SFI as well as different cache line sizes between AXI and SFI).</li></ul></li></ul><h4 id="NCBUWithCCPTestPlan-2.2.4SystemVerilogAssertions">2.2.4     System Verilog Assertions</h4><p>This section will include the following sets of assertions that will be added to the testbench:</p><ul><li>3<sup>rd</sup> party VIP assertions for AXI4</li><li>Assertions available on arm’s website to check ACE/AXI4 behavior: These assertions are standalone that will be alive in simulations in which the ACE in house BFM will be used.</li><li>Interface (external as well as between two internal blocks in the NCBU) assertion checks that would make more sense to be written as assertions rather than checks as part of the NCBU scoreboard or micro-architectural checker.</li><li>Use Oski assertion for CCP. [ Currently this is not enabled. ]</li></ul><h4 id="NCBUWithCCPTestPlan-2.2.5EndofSimChecker">2.2.5     End of Sim Checker</h4><ul><li>Check to make sure all transactions have completed from ACE BFM and System BFM perspective.</li><li>Check to make sure all credits have been returned at the end of simulation and credit counters are back to reset values.</li><li>Check to make sure all NCBU internal queues/FIFO's (OTT Ctrl, OTT Data, OTT Strb, and possible others) have no pending transactions or they are empty.</li><li>Check to make sure all NCBU Address and AXI Linked-List are back to “idle”.</li></ul><h4 id="NCBUWithCCPTestPlan-2.2.6Injectors">2.2.6     Injectors</h4><h2 id="NCBUWithCCPTestPlan-3ConfigurationSpace">3 Configuration Space</h2><h3 id="NCBUWithCCPTestPlan-3.1NCBUMainParameters">3.1 NCBU Main Parameters </h3><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th class="confluenceTh">Parameter</th><th class="confluenceTh">Must cover values (v2.0)</th></tr><tr><td class="confluenceTd">wCachelineOffset</td><td class="confluenceTd">6</td></tr><tr><td class="confluenceTd">NCBU Native interface</td><td class="confluenceTd">ACE-LITE</td></tr><tr><td class="confluenceTd">nMemRegions</td><td class="confluenceTd">1..8</td></tr><tr><td class="confluenceTd">szAgentCacheline</td><td class="confluenceTd">64B</td></tr><tr><td class="confluenceTd">wAxID</td><td class="confluenceTd">4, 5, 6, 12</td></tr><tr><td class="confluenceTd">wAxAddr</td><td class="confluenceTd">32, 36, 40, 44, 48</td></tr><tr><td class="confluenceTd">wXData</td><td class="confluenceTd">64, 128, 256</td></tr><tr><td class="confluenceTd">isBridgeInterface (only ACE-Lite)</td><td class="confluenceTd">TRUE</td></tr><tr><td class="confluenceTd">useIOCache (only ACE-Lite)</td><td class="confluenceTd">True, False</td></tr><tr><td class="confluenceTd">fnCacheState</td><td class="confluenceTd">MSI-IX, MEI</td></tr><tr><td class="confluenceTd">nOttCtrlEntries</td><td class="confluenceTd">2, 33, 96, 128</td></tr><tr><td class="confluenceTd">nOttDataEntries</td><td class="confluenceTd">2, nOttCtrlEntries</td></tr><tr><td class="confluenceTd">nOttStrbEntries</td><td class="confluenceTd">2, nOttCtrlEntries</td></tr><tr><td class="confluenceTd">nCmdInFlight</td><td class="confluenceTd">1, 3, 4, 16</td></tr><tr><td class="confluenceTd">nDtrInFlight</td><td class="confluenceTd">1, 3, 4, 16</td></tr><tr><td class="confluenceTd">nDtrSlaveIds</td><td class="confluenceTd">1, 3, 4, 16</td></tr><tr><td class="confluenceTd">fnErrorType</td><td class="confluenceTd">SECDED, SECDED64,PARITY</td></tr></tbody></table></div><h3 id="NCBUWithCCPTestPlan-3.2NCBUStaticConfigurationAPFusedforConcertov2.0">3.2 NCBU Static Configuration APF used for Concerto v2.0</h3><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th class="confluenceTh">Parameter</th><th class="confluenceTh">Cfg 3 (With CCP)</th><th class="confluenceTh">Cfg 4 (With CCP)</th><th class="confluenceTh">Cfg 5 (With CCP)</th><th class="confluenceTh">Cfg 6 (With CCP)</th></tr><tr><td class="confluenceTd">wCachelineOffset</td><td class="confluenceTd">6</td><td class="confluenceTd">6</td><td class="confluenceTd">6</td><td class="confluenceTd">6</td></tr><tr><td colspan="1" class="confluenceTd">wSecurityAttr</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">1</td></tr><tr><td class="confluenceTd">nMemRegions</td><td class="confluenceTd">3</td><td class="confluenceTd">1</td><td class="confluenceTd">8</td><td class="confluenceTd">2</td></tr><tr><td class="confluenceTd">nAius</td><td class="confluenceTd">1</td><td class="confluenceTd">1</td><td class="confluenceTd">1</td><td class="confluenceTd">1</td></tr><tr><td class="confluenceTd">wAxID</td><td class="confluenceTd">12</td><td class="confluenceTd">5</td><td class="confluenceTd">4</td><td class="confluenceTd">12</td></tr><tr><td class="confluenceTd">wAxAddr</td><td class="confluenceTd">48</td><td class="confluenceTd">36</td><td class="confluenceTd">32</td><td class="confluenceTd">40</td></tr><tr><td class="confluenceTd">wXData</td><td class="confluenceTd">128</td><td class="confluenceTd">256</td><td class="confluenceTd">64</td><td class="confluenceTd">128</td></tr><tr><td class="confluenceTd">wAwUser</td><td class="confluenceTd">8</td><td class="confluenceTd">0</td><td class="confluenceTd">12</td><td class="confluenceTd">1</td></tr><tr><td class="confluenceTd">wWUser</td><td class="confluenceTd">0</td><td class="confluenceTd">0</td><td class="confluenceTd">0</td><td class="confluenceTd">0</td></tr><tr><td class="confluenceTd">wBUser</td><td class="confluenceTd">0</td><td class="confluenceTd">0</td><td class="confluenceTd">0</td><td class="confluenceTd">0</td></tr><tr><td class="confluenceTd">wArUser</td><td class="confluenceTd">8</td><td class="confluenceTd">0</td><td class="confluenceTd">12</td><td class="confluenceTd">1</td></tr><tr><td class="confluenceTd">wRUser</td><td class="confluenceTd">0</td><td class="confluenceTd">0</td><td class="confluenceTd">0</td><td class="confluenceTd">0</td></tr><tr><td class="confluenceTd">useAceQosPort</td><td class="confluenceTd">TRUE</td><td class="confluenceTd">FALSE</td><td class="confluenceTd">TRUE</td><td class="confluenceTd">FALSE</td></tr><tr><td class="confluenceTd">useIOCache</td><td class="confluenceTd">TRUE</td><td class="confluenceTd">TRUE</td><td class="confluenceTd">TRUE</td><td class="confluenceTd">TRUE</td></tr><tr><td class="confluenceTd">nSets</td><td class="confluenceTd">16</td><td class="confluenceTd">4096</td><td class="confluenceTd">4</td><td class="confluenceTd">32</td></tr><tr><td class="confluenceTd">nWays</td><td class="confluenceTd">8</td><td class="confluenceTd">1</td><td class="confluenceTd">16</td><td class="confluenceTd">4</td></tr><tr><td class="confluenceTd">fnCacheType</td><td class="confluenceTd">MSI-IX</td><td class="confluenceTd">MSI-IX</td><td class="confluenceTd">MSI-IX</td><td class="confluenceTd">MEI</td></tr><tr><td class="confluenceTd">Replacement Policy</td><td class="confluenceTd">Random</td><td class="confluenceTd">NRU</td><td class="confluenceTd">Random</td><td class="confluenceTd">NRU</td></tr><tr><td class="confluenceTd">nTagBanks</td><td class="confluenceTd">2</td><td class="confluenceTd">1</td><td class="confluenceTd">1</td><td class="confluenceTd">1</td></tr><tr><td class="confluenceTd">nDataBanks</td><td class="confluenceTd">4</td><td class="confluenceTd">1</td><td class="confluenceTd">2</td><td class="confluenceTd">1</td></tr><tr><td class="confluenceTd">nOttCtrlEntries</td><td class="confluenceTd">128</td><td class="confluenceTd">33</td><td class="confluenceTd">4</td><td class="confluenceTd">96</td></tr><tr><td class="confluenceTd">nOttDataEntries</td><td class="confluenceTd">128</td><td class="confluenceTd">33</td><td class="confluenceTd">4</td><td class="confluenceTd">96</td></tr><tr><td class="confluenceTd">nOttStrbEntries</td><td class="confluenceTd">128</td><td class="confluenceTd">33</td><td class="confluenceTd">4</td><td class="confluenceTd">96</td></tr><tr><td class="confluenceTd">OttDataErrorInfo</td><td class="confluenceTd">SECDED</td><td class="confluenceTd">PARITY</td><td class="confluenceTd">SECDED64</td><td class="confluenceTd">SECDED</td></tr><tr><td class="confluenceTd">TagDataErrInfo</td><td class="confluenceTd">SECDED</td><td class="confluenceTd">PARITY16B</td><td class="confluenceTd">SECDED64</td><td class="confluenceTd">SECDED</td></tr><tr><td class="confluenceTd">DataBankErrInfo</td><td class="confluenceTd">SECDED</td><td class="confluenceTd">PARITY</td><td class="confluenceTd">SECDED64</td><td class="confluenceTd">SECDED</td></tr><tr><td class="confluenceTd">nCmdInFlight</td><td class="confluenceTd">4</td><td class="confluenceTd">16</td><td class="confluenceTd">1</td><td class="confluenceTd">16</td></tr><tr><td class="confluenceTd">nDtrInFlight</td><td class="confluenceTd">4</td><td class="confluenceTd">16</td><td class="confluenceTd">1</td><td class="confluenceTd">16</td></tr><tr><td class="confluenceTd">nDtrSlaveIds</td><td class="confluenceTd">4</td><td class="confluenceTd">16</td><td class="confluenceTd">1</td><td class="confluenceTd">16</td></tr><tr><td class="confluenceTd">wMasterData</td><td class="confluenceTd">128</td><td class="confluenceTd">256</td><td class="confluenceTd">64</td><td class="confluenceTd">128</td></tr><tr><td class="confluenceTd">wSlaveData</td><td class="confluenceTd">128</td><td class="confluenceTd">256</td><td class="confluenceTd">64</td><td class="confluenceTd">128</td></tr><tr><td class="confluenceTd">nDce</td><td class="confluenceTd">4</td><td class="confluenceTd">1</td><td class="confluenceTd">4</td><td class="confluenceTd">1</td></tr><tr><td class="confluenceTd">nDmi</td><td class="confluenceTd">3</td><td class="confluenceTd">1</td><td class="confluenceTd">8</td><td class="confluenceTd">2</td></tr><tr><td colspan="1" class="confluenceTd">Resiliency</td><td colspan="1" class="confluenceTd">FALSE</td><td colspan="1" class="confluenceTd">TRUE</td><td colspan="1" class="confluenceTd">FALSE</td><td colspan="1" class="confluenceTd">FALSE</td></tr><tr><td colspan="1" class="confluenceTd">Checker Unit Delay</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">4</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">0</td></tr></tbody></table></div><p> </p><h2 id="NCBUWithCCPTestPlan-4Features">4 Features</h2><h3 id="NCBUWithCCPTestPlan-4.1MainFeatures">4.1 Main Features</h3><p>To verify mainline features of NCBU testbench generates random read/write traffic using the AXI port. The address generation is a key component for verifying the mainline cache features in NCBU. For Read/Write transaction NCBU testbench is configured to generate address with following knobs.  </p><ul><li>First 25 txn with hit percentage      (0,0)</li><li>After 100 txn with hit percentage   (20,40)</li><li>After 500 txn with hit percentage   (50,50)</li><li>After 1000 txn with hit percentage (70,90)</li><li>After 1500 txn with hit percentage (20,40)</li><li>After 1700 txn with hit percentage (70,90)</li></ul><p>For snoops NCBU testbench uses the help of NCBU checker cache model to generate snoops to address that are already present in the NCBU cache. For each test the snoop hit rate is configured in the range (50,100). </p><p>The following tests are used to verify NCBU mainline features. Each test generates random traffic i.e Random read/write/snoop with 2000 Reads, 2000 Write and 2000 Snoop along with above knobs for address generation.  </p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th class="confluenceTh">Scenario</th><th class="confluenceTh">Hash Tag</th><th colspan="1" class="confluenceTh">Status</th></tr><tr><td class="confluenceTd"><p>Configures NCBU in no-allocate mode and runs random read/write/snoop traffic. </p></td><td class="confluenceTd"><p>#Test.NCB.NoAlloc</p></td><td colspan="1" class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>No Error </p></td><td class="confluenceTd"><p>#Test.NCB.NoError</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Single-bit Error </p></td><td class="confluenceTd"><p>#Test.NCB.RandRdWrWithSingleBitError</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Only Reads, No AxId Collision</p></td><td class="confluenceTd"><p>#Test.NCB.ReadNoAxId</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Only Read, No Multi-line i.e Only Read Partial</p></td><td class="confluenceTd"><p>#Test.NCB.ReadNoMultiLineOnlyPartial</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Only Write, No Multi-line i.e Only Write Partial</p></td><td class="confluenceTd"><p>#Test.NCB.WriteNoMultiLineOnlyPartial</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Only Write/Read No Multi-line i.e Only Partial</p></td><td class="confluenceTd"><p>#Test.NCB.RdWrNoMultiLineOnlyPartial</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Only Write, No AxId Collision</p></td><td class="confluenceTd"><p>#Test.NCB.WriteNoAxId</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Only Write </p></td><td class="confluenceTd"><p>#Test.NCB.OnlyWritesAlltypes</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Directed test to set index to fixed values for a read txn and run random traffic resulting in lots of eviction. </p></td><td class="confluenceTd"><p>#Test.NCB.ReadEvicts</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Directed test to set index to fixed values and run random traffic resulting in lots of eviction. </p></td><td class="confluenceTd"><p>#Test.NCB.WriteEvicts</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Single-bit Error, No BFM Delays</p></td><td class="confluenceTd"><p>#Test.NCB.NoBFMDelays</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Init memory with random values, Single-bit Error</p></td><td class="confluenceTd"><p>#Test.NCB.InitMemWithRandData</p></td><td class="confluenceTd"><p>Implemented</p></td></tr></tbody></table></div><h2 id="NCBUWithCCPTestPlan-5Errors">5 Errors</h2><h3 id="NCBUWithCCPTestPlan-5.1Single-biterror">5.1     Single-bit error</h3><p>Inject random single-bit errors for all my regression test. For OTT/Tag/Data banks configured with SECDED single-bit error should be corrected whereas for PARITY single-bit error will become as double-bit error.</p><p>NCBU checker has a cache model that is used to ensure that corrected data returned by CCP is as expected. </p><h3 id="NCBUWithCCPTestPlan-5.2Double-biterror">5.2     Double-bit error</h3><p>There are 3 types of Double-bit errors that apply to NCBU. </p><ol><li>NCBU Tag Double-bit Errors</li><li>NCBU Double-bit Data Errors</li><li>NCBU OTT Double-bit Data Errors</li></ol><p> </p><p>As per the Architecture spec for double-bit error the expected behavior is as follows:</p><p><em>For a native agent read response, the NCBU marks each data beat in the native agent read response with a data corruption error if that data beat contains a corrupted byte. For a native agent write request, the NCBU indicates a data corruption error in the native agent write response. For a DTWreq message, the NCBU de-asserts the byte-enable for each corrupted byte in the data transfer.</em></p><h3 id="NCBUWithCCPTestPlan-5.3Protocolerror">5.3     Protocol error</h3><ul><li>Inject all type of Protocol errors i.e CMDrsp, STRreq, UpdReq, DTRreq and DTWrsp errors. All of this transaction can receive transport errors. </li><li>NCBU can receive following types of transport errors<ul><li>Transport Security Error</li><li>Transport Power Management Error</li><li>Transport Timeout Error</li><li>For transport error NCBU will terminate the protocol transaction and provide response to agent with all data beats marked as error.</li><li>NCBU can receive following type of propagated errors<ul><li>Address Corruption error on STRreq</li><li>Transport Error on STRreq</li><li>For propagated errors NCBU will complete the protocol transaction and mark each beat on the agent response with transport error.<br/><br/></li></ul></li></ul></li></ul><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th class="confluenceTh"><p><strong>Scenario</strong></p></th><th class="confluenceTh"><p><strong>Hash Tag</strong></p></th><th class="confluenceTh"><p><strong>Implemented?</strong></p></th></tr><tr><td class="confluenceTd"><p>Randomly inject double-bit error on Tag memory</p></td><td class="confluenceTd"><p>#Test.NCB.CCPTagDbError</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Randomly inject double-bit error on data memory</p></td><td class="confluenceTd"><p>#Test.NCB.CCPDataDbError</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Randomly inject double-bit error on Ott Data memory  </p></td><td class="confluenceTd"><p>#Test.NCB.OttDataError</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Random protocol error on DTRReq  </p></td><td class="confluenceTd"><p>#Test.NCB.DtrReqError</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Random protocol error of Addr type on STRReq  </p></td><td class="confluenceTd"><p>#Test.NCB.StrReqAddrError</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Random protocol error of Data type on STRReq</p></td><td class="confluenceTd"><p>#Test.NCB.StrReqDataError</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Random CmdRsp Transport Security Error</p></td><td class="confluenceTd"><p>#Test.NCB.CmdRspTrsptSecError</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Random CmdRsp Transport disconnect Error</p></td><td class="confluenceTd"><p>#Test.NCB.CmdRspTrspDisError</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Random DtwRsp Data Error</p></td><td class="confluenceTd"><p>#Test.NCB.DtwRspDataError</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Random UpdDtwRsp Transport Security Error</p></td><td class="confluenceTd"><p>#Test.NCB.UpdDtwRspTrsptSecError</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Random UpdDtwRsp Transport Disconnect Error</p></td><td class="confluenceTd"><p>#Test.NCB.UpdDtwRspTrsptDisError</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td colspan="1" class="confluenceTd"><p>Random UpdDtwRsp Transport Timeout Error</p></td><td colspan="1" class="confluenceTd"><p>#Test.NCB.UpdDtwRspTrsptTimError</p></td><td colspan="1" class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>ACE Coh-Window Err</p></td><td class="confluenceTd"><p>#Test.NCB.WinowError</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Random all types of Errors</p></td><td class="confluenceTd"><p>#Test.NCB.RandAllErrors</p></td><td class="confluenceTd"><p>Implemented</p></td></tr></tbody></table></div><p> </p><p> </p><h2 id="NCBUWithCCPTestPlan-6ErrorLogging">6  Error Logging </h2><p>Hash tags to check error count, error valid, error overflow at end of sim should all be 0 if no errors are enabled in the test.</p><p>1.1       Error Detect Enable</p><p>1.     When error detect enable is set, all errors should be detected, corrected and logged. </p><p>2.     When error detect enable is not set and no error are injected, tests should work as is and pass.</p><p>3.     When error detect enable is not set and errors are injected, ensure that they are not detected, corrected or logged.</p><p>1.2       Error Interrupt Enable</p><p>Ensure that both correctable and uncorrectable interrupts are triggered when ErrIntEn is set and the appropriate error injection happens.</p><p>Ensure that neither the correctable nor the uncorrectable interrupt are triggered when ErrIntEn is disabled and error injection happen</p><p>1.3       Error Logging for correctable Errors</p><p>For NCBU, set up the error control registers to have a threshold of 1. Send two transactions and get the address of the second transaction from the above injector (or the test itself, since its directed). Check the logging registers (ESR, ELR0 and ELR1) to make sure the value logged is correct. After this, inject an additional error and confirm that the only the ErrOvf bit has now been set and no other changes have happened to the logging</p><p>1.4       Error Logging for uncorrectable Errors</p><p>For NCBU, set up the error control registers to have a threshold of 1. Send two transactions and get the address of the second transaction from the above injector (or the test itself, since its directed). Check the logging registers (ESR, ELR0 and ELR1) to make sure the value logged is correct. After this, inject an additional error and confirm that only the ErrOvf bit has now been set and no other changes have happened to the logging</p><p>1.5       Error Valid and Error Overflow bit reset</p><p>Check that the error valid and the error overflow bits are reset by writing 1 to the error valid and error overflow bits respectively after they have both been set. This should also clear the error count. If one of the above bits are not set, a write will not clear the bit, and more important, will not clear the error count</p><p>1.6       Error Status Alias Register</p><p>Confirm that writing to the alias register will affect the error status register</p><p> </p><p>1.7       Multiple Error of same type in same cycle</p><p>In NCBU, check that when multiple errors of the same type are injected (using the injector above), for uncorrectable both ErrVld and ErrOvf bits are set, for correctable, if err_count &lt; errthd then only ErrOvf will be set, if err_count = errthd, both ErrVld and ErrOvf bits  are seen.</p><p>1.8       Software writing in the same cycle as error detected</p><p>When this happens, the result should be that the error was first detected and then the software updated the state of the register</p><p> </p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th class="confluenceTh"><p><strong>Scenario</strong></p></th><th class="confluenceTh"><p><strong>Hash Tag</strong></p></th><th class="confluenceTh"><p><strong>Implemented?</strong></p></th></tr><tr><td colspan="1" class="confluenceTd"><p>Inject Single-bit tag error and read the register for error logging and ensure interrupt is generated.</p></td><td colspan="1" class="confluenceTd"><p>#Test.NCB.SingleBitErrCsrLogging</p></td><td colspan="1" class="confluenceTd"><p>Implemented</p></td></tr><tr><td colspan="1" class="confluenceTd"><p>Inject Error on StrReq and ensure the Error is logged in the CSR.</p></td><td colspan="1" class="confluenceTd"><p>#Test.NCB.StrReqErrorLogging</p></td><td colspan="1" class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Inject Error on DtrReq and ensure the Error is logged in the CSR.</p></td><td class="confluenceTd"><p>#Test.NCB.DtrReqErrorLogging</p></td><td class="confluenceTd"><p>Implemented</p></td></tr></tbody></table></div><h2 id="NCBUWithCCPTestPlan-7PowerManagement">7  Power Management</h2><p>NCBU has directed test to randomly perform IO cache online and offline sequence that are used for the power management purpose. In addition NCBU checker implements checks for TransActv bit to ensure that any activity in NCBU is correctly tracked and reported. </p><h2 id="NCBUWithCCPTestPlan-8CSR&amp;MntOps">8  CSR &amp; MntOps</h2><p>Ensure that all register can be read with reset values i.e use ralgen to verify read/write of all the NCBU registers.</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th class="confluenceTh"><p><strong>Scenario</strong></p></th><th class="confluenceTh"><p><strong>Hash Tag</strong></p></th><th class="confluenceTh"><p><strong>Implemented?</strong></p></th></tr><tr><td class="confluenceTd"><p>This test is used to verify TT debug features. It runs random traffic after few cycles it halts the traffic and reads the TT entries to ensure that we can use TT debug features for debugging purpose. </p></td><td class="confluenceTd"><p>#Test.NCB.TTdebug</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Performs IO cache online sequence at the start of the test and offline sequence at the end of the test.</p></td><td class="confluenceTd"><p>#Test.NCB.DirectedOnlineOffline</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Randomly perform online/offline sequence while the traffic is running. </p></td><td class="confluenceTd"><p>#Test.NCB.RandOnlineOffline</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Randomly toggle Allocation signal to ensure NCBU can handle changes in Allocation policy while traffic is running. </p></td><td class="confluenceTd"><p>#Test.NCB.RandAllocBits</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Verifies flush by index MntOp feature. </p></td><td class="confluenceTd"><p>#Test.NCB.MntOpFlushByIndex</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Verifies flush by addr feature. </p></td><td class="confluenceTd"><p>#Test.NCB.MntOpFlushByAddr</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Randomly performs MntOp Init all to flush the entire cache while the traffic is running. </p></td><td class="confluenceTd"><p>#Test.NCB.RandAllMntOp</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Disable Lookup and ensure NCBU treats all txn as no-allocate. </p></td><td class="confluenceTd"><p>#Test.NCB.DisLookupEnable</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Disable Fill Enable register  with single_bit_error injected</p></td><td class="confluenceTd"><p>#Test.NCB.DisFillEnable</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Disable Fill Enable register with double-bit-tag error injected</p></td><td class="confluenceTd"><p>#Test.NCB.DisFillEnableWithDbTagError</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Disable Fill Enable register with double-bit-data error injected.</p></td><td class="confluenceTd"><p>#Test.NCB.DisFillEnableWithDbDataError</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Writes Random Values to Tag Ram using MntOp Debug write and reads them back using MntOp Debug read. </p></td><td class="confluenceTd"><p>#Test.NCB.MntOpDbgTagRdWr</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Writes Random values to Data Ram using MntOp Debug write and reads them backing using MntOp Debug read. </p></td><td class="confluenceTd"><p>#Test.NCB.MntOpDbgDataRdWr</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Use Ralgen to read all register values</p></td><td class="confluenceTd"><p>#Test.NCB.RalgenAllRead</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Use Ralgen to perform a bit-bash test</p></td><td class="confluenceTd"><p>#Test.NCB.RalgenBitBash</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p> </p></td><td class="confluenceTd"> </td><td class="confluenceTd"> </td></tr><tr><td class="confluenceTd"><p>This test is used to verify MntOp with errors injected on MntOps. Injects a single-bit tag error and ensure CCP corrects the data while reading it out.</p></td><td class="confluenceTd"><p>#Test.NCB.MntOpWithSingleBitError</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td class="confluenceTd"><p>Inject Double-bit tag error on MntOps and ensure error is logged.</p></td><td class="confluenceTd"><p>#Test.NCB.MntOpDbError</p></td><td class="confluenceTd"><p>Implemented</p></td></tr><tr><td colspan="1" class="confluenceTd">Randomly configure the Dynamic OTT registers and ensure the OTT allocation is controlled by the limit register.</td><td colspan="1" class="confluenceTd">#Test.NCB.OttDynamic</td><td colspan="1" class="confluenceTd">Implemented</td></tr></tbody></table></div><p> </p><h2 id="NCBUWithCCPTestPlan-9.AdvancedCoverage(Crossofmulti-features,Timingsensitivescenariostohit,etc)">9. Advanced Coverage (Cross of multi-features, Timing sensitive scenarios to hit, etc)</h2><p>Latest NCBU coverage properties for v2.0</p><p> </p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th class="confluenceTh"><p align="center">Feature</p></th><th class="confluenceTh"><p align="center">Description</p></th><th class="confluenceTh"><p align="center">Coverage/Checking</p></th></tr><tr><td class="confluenceTd"><p>Back to Back Transactions coverage requested by design</p></td><td class="confluenceTd"><p>Muffadal, </p><p>Can we add coverage for Write Hits Back-to-Back test (and also Read Hits Back-to-Back test) to ensure all these legal combinations are covered?</p><p>Hit with No Dependency</p><p>Hit with AxID Dependency</p><p>Miss with No Dependency</p><p>Miss with AxID Dependency</p><p>With Address Dependency</p><p>Thanks,</p><p>-Boon</p></td><td class="confluenceTd"> </td></tr><tr><td colspan="1" class="confluenceTd">Coverage properties feedback from boon</td><td colspan="1" class="confluenceTd"><p>1.crdfifo_full</p><p>2.rdrsp_fifo_full</p><p>3.ott_fifo_full</p><p>4. dtrfifo_full</p><p>5.prm.dat.wr_storage_busy</p><p>6.b2bRdHits -  B2B_RD_MISS_AXID_DEP   coverage is 0. Why.</p><p>7.read hit back-to-back multiple times in a row.</p><p>8.write hit back-to-back multiple times in a row</p></td><td colspan="1" class="confluenceTd"> </td></tr></tbody></table></div><h2 id="NCBUWithCCPTestPlan-10Performance(LatencyandBandwidth)"><br/>10 Performance (Latency and Bandwidth)</h2><p>NCBU has a list of dedicated tests to measure performance. Here is the list of test that we run and the associated numbers </p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th class="confluenceTh"><p><strong>Test</strong></p></th><th class="confluenceTh"><p><strong>Bus Width</strong></p></th><th class="confluenceTh"><p><strong>V1.6 BW Numbers GBytes/Sec</strong></p></th><th class="confluenceTh"><p><strong>V2.0 BW Numbers</strong></p><p><strong>GBytes/Sec</strong></p></th></tr><tr><td class="confluenceTd"><p>Only Read txns</p></td><td class="confluenceTd"><p>128-bits</p></td><td class="confluenceTd"><p>16</p></td><td class="confluenceTd"><p>16</p></td></tr><tr><td class="confluenceTd"><p>Only Write txns</p></td><td class="confluenceTd"><p>128-bits</p></td><td class="confluenceTd"><p>8.004130</p></td><td class="confluenceTd"><p>8.00</p></td></tr><tr><td class="confluenceTd"><p>Read/Write txns</p></td><td class="confluenceTd"><p>128-bits</p></td><td class="confluenceTd"><p>17.4</p></td><td class="confluenceTd"><p>19.24</p></td></tr><tr><td class="confluenceTd"><p>25%Write &amp; 75% Read</p></td><td class="confluenceTd"><p>128-bits</p></td><td class="confluenceTd"><p>19.27</p></td><td class="confluenceTd"><p>19.20</p></td></tr><tr><td class="confluenceTd"><p>25%Write &amp; 75% Read</p><p>[80 % Read-hit, 50 % Write-Hit]</p></td><td class="confluenceTd"><p>128-bits</p></td><td class="confluenceTd"><p> </p></td><td class="confluenceTd"><p>18.06</p></td></tr></tbody></table></div><p><br/>Latency numbers for different Read Miss and Write Miss arc so we can use this for future reference.  </p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th class="confluenceTh"><p><strong> </strong></p></th><th class="confluenceTh"><p><strong>Description</strong></p></th><th class="confluenceTh"><p><strong> </strong></p><p><strong>V2.0</strong></p><p><strong>config_128, wxData=128, </strong></p><p><strong>ottctrl=128,</strong></p><p><strong>ottdata=128 ,</strong></p><p><strong>AxId = 12,         </strong></p></th></tr><tr><td rowspan="4" class="confluenceTd"><p>Latency  Read Miss Allocate</p></td><td class="confluenceTd"><p>AXI Rd Req-&gt;CmdReq</p></td><td class="confluenceTd"><p align="center">2</p></td></tr><tr><td class="confluenceTd"><p>STRReq + DTRReq -&gt; AXI Rd Resp</p></td><td class="confluenceTd"><p align="center">12</p></td></tr><tr><td class="confluenceTd"><p>Fill Done -&gt;STRRsp</p></td><td class="confluenceTd"><p align="center">3</p></td></tr><tr><td class="confluenceTd"><p>STRReq + DTRReq -&gt; Fill Data</p></td><td class="confluenceTd"><p align="center">11</p></td></tr><tr><td rowspan="4" class="confluenceTd"><p>Latency Write Miss Allocate</p></td><td class="confluenceTd"><p>AXI Wr Req -&gt; CmdReq</p></td><td class="confluenceTd"><p align="center">4</p></td></tr><tr><td class="confluenceTd"><p>STRReq + DTR -&gt; Fill Data</p></td><td class="confluenceTd"><p align="center">4</p></td></tr><tr><td class="confluenceTd"><p>Fill Ctrl + Fill Data + Fill Done -&gt; STR Rsp</p></td><td class="confluenceTd"><p align="center">1</p></td></tr><tr><td class="confluenceTd"><p>Fill Ctrl + Fill Data + Fill Done -&gt; Bresp</p></td><td class="confluenceTd"><p align="center">3</p></td></tr></tbody></table></div><h2 id="NCBUWithCCPTestPlan-11.Regressionscriptcommand"><span style="font-size: 20.0px;"><br/>11. Regression script command</span></h2><p>node /home/muffadal/work/hw/dv/scripts/gen_my_regr.js -e cbi -t regr -r -m <a class="external-link" href="mailto:muffadal@arteris.com" rel="nofollow">muffadal@arteris.com</a> -s NCBU</p><p> </p><p>The script will generate two files “reglist.sh” [This is the regression testlist ] and “regr_cmd.sh” [This is the command that you can use to run the testlist]</p><p> </p><h2 id="NCBUWithCCPTestPlan-12.CodeCoverageMeetingMinutesandFeedbacknotes.">12. Code Coverage Meeting Minutes and Feedback notes. </h2><p>Team,</p><p>I discussed with Boon regarding read-hit no dependency not being hit by stimulus. Basically for Config5 we only have 4 OTT entries and since NCBU needs minimum 4 OTT entries to process any transaction that means that we will see very few collision.  Due to this reason we will never see read-hit with dependency being covered for this config since we can process maximum 1 coherent agent transaction at a time. </p><p>Also due to very few collision AXID linked-list code will also have many holes hence bringing down the coverage. </p><p>I am thinking of increasing the OTT size for this config since the stimulus generated by this config is not very interesting. Let me know what you guys think.   </p><p>Thanks,</p><p>Muffadal</p><p> </p><p><strong>From:</strong> Boon Chuan <br/> <strong>Sent:</strong> Friday, May 05, 2017 6:16 PM<br/> <strong>To:</strong> Chirag Gandhi &lt;<a class="external-link" href="mailto:chirag.gandhi@arteris.com" rel="nofollow">chirag.gandhi@arteris.com</a>&gt;; Muffadal Lakadawala &lt;<a class="external-link" href="mailto:muffadal.lakadawala@arteris.com" rel="nofollow">muffadal.lakadawala@arteris.com</a>&gt;; Parimal Gaikwad &lt;<a class="external-link" href="mailto:parimal.gaikwad@arteris.com" rel="nofollow">parimal.gaikwad@arteris.com</a>&gt;<br/> <strong>Cc:</strong> Mohammed Khaleeluddin &lt;<a class="external-link" href="mailto:mohammed.khaleeluddin@arteris.com" rel="nofollow">mohammed.khaleeluddin@arteris.com</a>&gt;<br/> <strong>Subject:</strong> RE: NCBU code coverage closure</p><p> </p><p>Chirag,</p><p> </p><p>The NCB protocol manager dut.unit.prm  has a condition coverage of 81.99% for the config5_with_ccp configuration.</p><p>The reason is the configuration only has 4 OTT entries and the logic reserves 3 of them, therefore only 1 coherent agent request can be outstanding, therefore a significant amount of logic and resources are not reasonably utilized. For example, CTT1, CTT2, CTT3, CmdSelFIFO, RdRspIssueFIFO, wup_fifo, OttRdRspBuffer, *IssueFifo, crdfifo, CtrlFLM, DataFLM.  Excluding these holes, the condition coverage for the NCB protocol manager can be bumped up to 90% or more.</p><p> </p><p>NOTE: Because of only 1 coherent agent request can be outstanding in the configuration, the FIFOs in the Pipe Controller are not reasonably utilized also. Same applies to the RACK FIFO and WACK FIFO in the ACE module.</p><p>NOTE: I noticed all 4 OTT entries are utilized, because one of them is used by coherent agent request, the rest by flush/eviction.</p><p> </p><p>Stimulus can be improved in this area:</p><p>-Read Hit With Dependency.  Basically CCP to OTT data path is not exercised.</p><p>-Read Hit With No Dependency with CCP Poison.</p><p>-CSR Error Detect Enable. Basically it’s always enabled by TB</p><p>-CSR Error Logging / Register testing</p><p>-TTDebug</p><p>-Delayed Snoop Response (snoop address matching eviction addresses in UTT)</p><p> </p><p>-Boon</p><p> </p><p> </p><p><strong>From:</strong> Chirag Gandhi <br/> <strong>Sent:</strong> Thursday, May 04, 2017 10:43 PM<br/> <strong>To:</strong> Boon Chuan &lt;<a class="external-link" href="mailto:boon.chuan@arteris.com" rel="nofollow">boon.chuan@arteris.com</a>&gt;; Muffadal Lakadawala &lt;<a class="external-link" href="mailto:muffadal.lakadawala@arteris.com" rel="nofollow">muffadal.lakadawala@arteris.com</a>&gt;; Parimal Gaikwad &lt;<a class="external-link" href="mailto:parimal.gaikwad@arteris.com" rel="nofollow">parimal.gaikwad@arteris.com</a>&gt;<br/> <strong>Cc:</strong> Mohammed Khaleeluddin &lt;<a class="external-link" href="mailto:mohammed.khaleeluddin@arteris.com" rel="nofollow">mohammed.khaleeluddin@arteris.com</a>&gt;<br/> <strong>Subject:</strong> NCBU code coverage closure</p><p> </p><p>Folks,</p><p> </p><p>I am attaching a table with NCBU code coverage numbers for all configs. I was not able to close NCBU config 5 with CCP (able to get to 90% condition coverage). This config had only 4 OTT entries and there were lots of holes because of the reservation. There were some CCP holes as well. If Boon and Parimal can have a look at this config and see if there is anything we can exclude, that would be really nice. However, if you think there are no stimulus holes and the low numbers are expected, please let me know and I can take that to Exec staff as a reason/waiver for this one config. All exclusion files are saved in ~chirag/coverage_exclusions.</p><p> </p><p>To pull up code coverage for config 5 with my exclusions, please use command below:</p><p> </p><p>dve -cov -dir /scratch3/muffadal/coverage_database_to_keep/v2.0_cov/regr_2017_4_26_19_5_49/debug/cbi/config5_with_ccp/exe/simv.vdb /scratch3/muffadal/coverage_database_to_keep/v2.0_cov/regr_2017_4_26_19_5_49/debug/cbi/config5_with_ccp/run/*/simv.vdb -elfile /home/chirag/coverage_exclusions/ncbccp_config5_v2.0.el</p><p> </p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p align="center">NCB</p></td><td class="confluenceTd"><p align="center"> </p></td><td class="confluenceTd"><p align="center"> </p></td><td class="confluenceTd"><p align="center"> </p></td></tr><tr><td class="confluenceTd"><p align="center"> </p></td><td class="confluenceTd"><p align="center">NCB0</p></td><td class="confluenceTd"><p align="center">99.00%</p></td><td class="confluenceTd"><p align="center">96.00%</p></td></tr><tr><td class="confluenceTd"><p align="center"> </p></td><td class="confluenceTd"><p align="center">NCB1</p></td><td class="confluenceTd"><p align="center">99.00%</p></td><td class="confluenceTd"><p align="center">95.00%</p></td></tr><tr><td class="confluenceTd"><p align="center"> </p></td><td class="confluenceTd"><p align="center">NCB2</p></td><td class="confluenceTd"><p align="center">99.00%</p></td><td class="confluenceTd"><p align="center">96.00%</p></td></tr><tr><td class="confluenceTd"><p align="center"> </p></td><td class="confluenceTd"><p align="center">NCBCCP3</p></td><td class="confluenceTd"><p align="center">98.00%</p></td><td class="confluenceTd"><p align="center">95.00%</p></td></tr><tr><td class="confluenceTd"><p align="center"> </p></td><td class="confluenceTd"><p align="center">NCBCCP4</p></td><td class="confluenceTd"><p align="center">98.00%</p></td><td class="confluenceTd"><p align="center">95.00%</p></td></tr><tr><td class="confluenceTd"><p align="center"> </p></td><td class="confluenceTd"><p align="center">NCBCCP5</p></td><td class="confluenceTd"><p align="center">98.00%</p></td><td class="confluenceTd"><p align="center">90.00%</p></td></tr><tr><td class="confluenceTd"><p align="center"> </p></td><td class="confluenceTd"><p align="center">NCBCCP6</p></td><td class="confluenceTd"><p align="center">99.00%</p></td><td class="confluenceTd"><p align="center">96.00%</p></td></tr></tbody></table></div><p> </p><p>Thanks</p><p>- Chirag</p><p> </p><p> </p><p>OTT module</p><ol><li>SEND_ACE_DAT_ERR not covered [Owner:Boon] i.e ace_rack</li><ol><li>This is a dead code.  RdRspIssueFifo multiport FIFO port ERR is not used because the OTT entry state machine never enter this state because the legacy multiline dbit logic is removed.</li></ol><li>Wait_RD_CONVERT_DBIT not covered [Owner : Boon ]</li><li>Ctt_deallocate for window_error/ccp uce error is dead code. Since we don’t allocate in CTT for this cases.   [Owner: Boon]</li><li>Check if TTdebug is part of the regression [Owner : Muffadal ]</li><li>For write_miss_allocate we will never see DTW handback so the equation related to this will never be covered.  [Owner : Boon]</li><li>DTR bypass code should be removed for CCP conifg because this code is not used. [Owner : Boon ]</li><li>We don’t see more than 1 OTT entry being assigned for evict. Need to investigate if TB is generating enough evict stimulus.  [ Owner : Muffadal ]</li><li>For write miss allocate since we don’t do DTW.  In the v1.6 design AIU used to perform DTW but with new design this will never happen so code related to this should be removed.  [Owner : Muffadal]</li></ol><p>  </p><p><strong>From:</strong> Muffadal Lakadawala <br/> <strong>Sent:</strong> Tuesday, April 18, 2017 6:01 PM<br/> <strong>To:</strong> Saad Zahid &lt;<a class="external-link" href="mailto:saad.zahid@arteris.com" rel="nofollow">saad.zahid@arteris.com</a>&gt;; Boon Chuan &lt;<a class="external-link" href="mailto:boon.chuan@arteris.com" rel="nofollow">boon.chuan@arteris.com</a>&gt;; Chirag Gandhi &lt;<a class="external-link" href="mailto:chirag.gandhi@arteris.com" rel="nofollow">chirag.gandhi@arteris.com</a>&gt;<br/> <strong>Cc:</strong> Mohammed Khaleeluddin &lt;<a class="external-link" href="mailto:mohammed.khaleeluddin@arteris.com" rel="nofollow">mohammed.khaleeluddin@arteris.com</a>&gt;; Parimal Gaikwad &lt;<a class="external-link" href="mailto:parimal.gaikwad@arteris.com" rel="nofollow">parimal.gaikwad@arteris.com</a>&gt;<br/> <strong>Subject:</strong> RE: NCB Code Coverage Report...</p><p>Address Link-List:</p><ol><li>Out of the total 128-bit UTT entries we are not able to hit the top UTT entries.</li><li>Certain OTT entries i.e the top 4 are never used.</li><li>Last 14<sup>th</sup> and 16<sup>th</sup> OTT is not allocated for evictions.</li><li>Stimulus for OTT holding evict address begin deallocated at the same cycle when a address lookup result in an address collision for that UTT.</li><li>((entry102_got_collision0 &amp; ( ~ ( | ({(entry_collision0_vlds &amp; entry_dealloc_multihot)}) ) )) | (entry102_got_collision1 &amp; ( ~ ( | ({(entry_collision1_vlds &amp; entry_dealloc_multihot)}) ) ))) è This equation suggest that we have only one eviction active at any give point in time. Need to investigate why we don’t have multiple evict pending.</li><li>TB need to ensure that we see more than 8 eviction at a time.</li><li>Eviction port Collison is causing the coverage to go down for the address linked-list.</li></ol><p>AXID Link-List</p><ol><li>For read-hit not woken up by its dependee.  (entry128_depend &amp; ( | ({(entry128_dependee_id_vec &amp; entry_dealloc_multihot)}) ))</li><li>For this module because we use total nOttCtrlEntries * 2 so all the upper half of AxID which are used only for read-hit are never exercised.</li><li>So exclude all bins that start from 128+8 to 256 and the last 4 reserved entries i.e 123 to 127</li></ol><p>Thanks,</p><p>Muffadal</p><p> </p><p><strong>From:</strong> Muffadal Lakadawala </p><p><strong>Sent:</strong> Monday, April 17, 2017 3:12 PM<br/> <strong>To:</strong> Saad Zahid &lt;<a class="external-link" href="mailto:saad.zahid@arteris.com" rel="nofollow">saad.zahid@arteris.com</a>&gt;; Boon Chuan &lt;<a class="external-link" href="mailto:boon.chuan@arteris.com" rel="nofollow">boon.chuan@arteris.com</a>&gt;; Chirag Gandhi &lt;<a class="external-link" href="mailto:chirag.gandhi@arteris.com" rel="nofollow">chirag.gandhi@arteris.com</a>&gt;<br/> <strong>Cc:</strong> Mohammed Khaleeluddin &lt;<a class="external-link" href="mailto:mohammed.khaleeluddin@arteris.com" rel="nofollow">mohammed.khaleeluddin@arteris.com</a>&gt;<br/> <strong>Subject:</strong> RE: NCB Code Coverage Report...</p><p> </p><p>Hi Team,</p><p>We reviewed CCP module in NCBU today.  Attaching the meeting minutes.</p><ol><li>Test with ErrDetEn set to 0 not part of this run.  <strong>[Owner : Muffadal ]</strong></li><li>MntOp with datapipe read not part of the regression.  <strong>[Owner : Muffadal ]</strong></li><li>MntOp datapipe should cover all memory locations and all word combinations.  <strong>[Owner : Muffadal ]</strong></li><li>State_data_in bit [38:33] are not toggled [Tagpipe.v file line 247] [<strong>Owner : Parimal]</strong></li></ol><p>Thanks,</p><p>Muffadal</p><p> </p><p><strong>From:</strong> Muffadal Lakadawala <br/> <strong>Sent:</strong> Wednesday, April 12, 2017 4:30 PM<br/> <strong>To:</strong> Saad Zahid &lt;<a class="external-link" href="mailto:saad.zahid@arteris.com" rel="nofollow">saad.zahid@arteris.com</a>&gt;; Boon Chuan &lt;<a class="external-link" href="mailto:boon.chuan@arteris.com" rel="nofollow">boon.chuan@arteris.com</a>&gt;; Chirag Gandhi &lt;<a class="external-link" href="mailto:chirag.gandhi@arteris.com" rel="nofollow">chirag.gandhi@arteris.com</a>&gt;<br/> <strong>Cc:</strong> Mohammed Khaleeluddin &lt;<a class="external-link" href="mailto:mohammed.khaleeluddin@arteris.com" rel="nofollow">mohammed.khaleeluddin@arteris.com</a>&gt;<br/> <strong>Subject:</strong> RE: NCB Code Coverage Report...</p><p> </p><p>Attaching meeting minutes for 04/12/2017</p><ol><li>Reviewing STT module based</li><ol><li>Module for Line Coverage is 100 %</li><li>Snp_rsp is not generated since tag uncorrectable testcase. [Owner : Muffadal ]</li><li>Dtw_resp error not generated by TB which is causing the hole.  [ Owner : Muffadal ]</li><li>Ensure all kinds errors are injected on snoop that should improve the coverage numbers.</li><li>AgentSnpCrFiFo.v write ptr never increments. [Check with Mike ] [Owner : Muffadal ]</li><li>AgentSnpDataFiFo never goes Full. Looks like we are not even exercising all the entries.   [Owner : Boon ]</li><li>AgentSnpDataFifo push_ready=0 and push_valid=1 is never covered. [Owner : Boon ]</li></ol><li>Ncbioc module</li><ol><li>Debug read/write are not part of regression.</li><li>Flush index/way and flush address should be part of the regression. Double check.  [Owner: Muffadal]</li><li>(Sel_mntop &amp; mntop_flush) line:154 in ncbioc_mnt_ctrl.v is not covered. [Owner : Boon ]</li><li>Utt_full not covered. Because we need a big cache with very small OTT count to hit this case. Suggestion is to use offline sequence to generate this scenario. [Owner : Muffadal ]</li><li>MntOp init in middle of simulation not exercised.   [Owner Muffadal]</li></ol></ol><p>Let me know if I missed anything.</p><p>Thanks,</p><p>Muffadal</p><p> </p><h2 id="NCBUWithCCPTestPlan-ActionItems">Action Items</h2><ul class="inline-task-list" data-inline-tasks-content-id="16170532"><li data-inline-task-id="1"><span>Add hash tags to all tests and coverage properties</span></li><li data-inline-task-id="2"><span>Add OCP port to diagram</span></li><li data-inline-task-id="3"><span>Add a reference section which gives links to all specs that this test plan refers to</span></li><li data-inline-task-id="4"><span>Add a configuration where you have NONE error type</span></li><li data-inline-task-id="5">useResiliency = 1 config?</li><li data-inline-task-id="6">MaintActive check</li><li data-inline-task-id="7">Back to back single bit error injection - functional coverage point - or run a 100% error injection test.</li><li data-inline-task-id="8"><span> </span></li></ul>
<p> </p>