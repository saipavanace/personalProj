<h1 id="HW-CTFSymphonyBlockCommonCharacteristics-LogicLoops">Logic Loops</h1><p>1) Valid can never be a function of ready.</p><p style="margin-left: 30.0px;">The way to solve this when you want to do it is to use state based on the previous value of ready. The most common occurrence of this is when you have split busses that really originate from a single bus. You don't want to assert valid forward unless you have two readies. The way to solve this is to store the state of what happened last cycle so if the two busses diverge you can properly filter the readies and valids.</p><p>2) Ready can be a function of valid, but avoid if possible. </p><h1 id="HW-CTFSymphonyBlockCommonCharacteristics-Interrupts">Interrupts</h1><p>1) Software visible Symphony blocks will only output one interrupt.</p><p>2) If a block has multiple interrupts internally, it must accumulate them using the standard interrupt.tachl block in the standard library. </p><p>3) If a block can dynamically have an interrupt, from software's point of view the block will always have an interrupt. If the parameters to the block are such that there is not interrupt, then the interrupt shall be internally tied to 0.</p><h1 id="HW-CTFSymphonyBlockCommonCharacteristics-CSRGeneration">CSR Generation</h1><p>1) Symphony blocks will generate their CSRs and write them out.</p><p>2) Symphony blocks instanced by software will only write out one CSR file per instance block.</p><p>3) If a block can dynamically have configuration registers, from software's point of view, the block will always have configuration registers. When the block doesn't have CSR registers the block will write out a CSR file that describes no registers but works will the backend tooling and tie off the config interface into the block such that it doesn't deadlock the interface if a transaction erroneously comes to it, SLVERR and SREADY tied high.</p><p>4) A block that has a configuration port needs to have an ID parameter. The value of the ID parameters must appear in the CSR in the &quot;csrDescription&quot; field for each register in the format described under section &quot;Block ID description&quot; below.</p><p>5) A read only register with the a default value of &quot;id&quot; should be put in the last addressable word in the address space of a block.</p><p>6) For the interrupt block, an additional parameter, &quot;<em>InterruptMap</em>&quot; of type 'string' shall be passed to its generate CSR function. This will be appended to the &quot;csrDescription&quot; field of interrupt status registers (INTVR or any register with interrupt status bits) of that block in the CSR and the translated IPXACT. In order for DV to be able to parse this string to infer how the interrupts are mapped to the register bits properly, it needs to follow the format listed in the section &quot;Interrupt Bit Description&quot;.</p><h3 id="HW-CTFSymphonyBlockCommonCharacteristics-BlockIDDescription">Block ID Description</h3><p>This is a string that will exist in the &quot;<em>csrDescripton</em>&quot; field of every register in the CSR, in order to identify to which block the register belongs. The string must include &quot;BlockID: &quot; followed by</p><ol><li>A non-negative integer that matches the ID of the software visible block with which the register is associated with. Ex: 5</li><li>A hierarchical number separated by dots (.). And the leftmost number must match the ID of the software visible block. Ex: 6.1.2 - Here 6 is the software visible block ID in which the register exists. The remaining numbers can be used to identify different interrupt hierarchy levels and sub-blocks withing that block.</li></ol><p>Examples of &quot;<em>csrDescription</em>&quot; fields:<br/>&quot;Timer control register for BlockID: 9&quot;.<br/>&quot;BlockID: 5.4, Probe select register for event addr_hit&quot;<br/>&quot;BlockID: 18&quot;</p><h3 id="HW-CTFSymphonyBlockCommonCharacteristics-InterruptBitDescription(InterruptMap)">Interrupt Bit Description (<em>InterruptMap</em>)</h3><p>The <em>InterruptMap</em> string is expected to be included in &quot;<em>csrDescription</em>&quot; ( <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16154965/csr" data-linked-resource-id="16154965" data-linked-resource-version="35" data-linked-resource-type="page">csr</a> ) of every register with interrupt status bits. The format of the <em>InterruptMap</em> string is described in this section. To be able to parse, the string must be surrounded by identifier strings -&quot;InterruptMap%&quot; and &quot;%InterruptMap&quot;. Between the two identifiers, the following two fields are expected:</p><ol><li><strong>Level</strong>: Must be either one of the values - &quot;TOP&quot; (when the register is at the top of a interrupt tree), &quot;SUB&quot; (for all other levels in the interrupt tree). This value must be surrounded by strings &quot;Level%&quot; and &quot;%Level&quot;.</li><li><strong>BitMap</strong>: This consists of a series of fields and their values separated by comma ( , ), surrounded by &quot;BitMap%&quot; and &quot;%BitMap&quot;, and with a colon( : ) separating the field and value. The following fields are expected:<ol><li>statusBit: A non-negative integer. A bit offset of the bit in the register that is an interrupt status bit.</li><li>maskBit: A non-negative integer. A bit offset of the bit in the maskRegister that is the associated maskBit.</li><li>maskRegister: A string. Name of the register that has the maskBit above. The mask bit can be in the same register or a different register.</li><li>tree: A string that can only take the following two values: &quot;ERROR&quot;, &quot;INFO&quot;. Default &quot;ERROR&quot;. Indicates the type of interrupt tree the interrupt belongs to.</li><li>srcBlockID: (Optional). A hierarchical BlockID (see Block ID Description in previous section). This must exist if the status bit is being driven by interrupts from another interrupt status register.</li></ol></li></ol><p>There can and typically exist multiple instances of the BitMap string. Sometimes a status bit can have multiple interrupt sources in which case, multiple BitMaps exist for the same statusBit, each source can come from a different hierarchy.</p><p>Examples of &quot;<em>csrDescription</em>&quot; fields:<br/>&quot;<strong>BlockID</strong>: 7, Interrupt Valid Register. <strong>InterruptMap</strong>% <strong>Level</strong>% SUB %<strong>Level</strong>, <strong>BitMap</strong>% statusBit: 0, maskRegister: INTMR, maskBit: 0, tree: ERROR %<strong>BitMap</strong>, <strong>BitMap</strong>% statusBit: 1, maskRegister: INTMR, maskBit: 1, tree: INFO %<strong>BitMap</strong> %<strong>InterruptMap</strong>&quot;<br/>&quot;<strong>BlockID</strong>: 13, Interrupt Valid Register. <strong>InterruptMap</strong>% <strong>Level</strong>% TOP %<strong>Level</strong>, <strong>BitMap</strong>% statusBit: 0, srcBlockID: 0, maskRegister: INTMR, maskBit: 0, tree: INFO %<strong>BitMap</strong>, <strong>BitMap</strong>% statusBit: 1, srcBlockID: 1, maskRegister: INTMR, maskBit: 1, INFO %<strong>BitMap</strong> %<strong>InterruptMap</strong>&quot;</p><h4 id="HW-CTFSymphonyBlockCommonCharacteristics-GeneratingtheInterruptMapstring">Generating the <em>InterruptMap</em> string</h4><p>For blocks that instantiate the <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16160510/interrupt" data-linked-resource-id="16160510" data-linked-resource-version="22" data-linked-resource-type="page">interrupt</a> block, the <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16157062/HW-CTF+generateInterruptCSR" data-linked-resource-id="16157062" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF generateInterruptCSR()</a> function computes the <em>InterruptMap</em> string inside with no srcBlockIDs by default (last/leaf-level assumed). If the interrupt status registers are not the last-level interrupt status bits in the interrupt hierarchy, then the optional parameter srcBlockIDMap is required to be passed to the <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16157062/HW-CTF+generateInterruptCSR" data-linked-resource-id="16157062" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF generateInterruptCSR()</a> function. All other Symphony design blocks must call this function <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16157058/HW-CTF+genInterruptMap" data-linked-resource-id="16157058" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF genInterruptMap()</a> to compute the <em>InterruptMap</em> string.</p><h4 id="HW-CTFSymphonyBlockCommonCharacteristics-ParsingtheInterruptMapstring">Parsing the <em>InterruptMap</em> string</h4><p>Refer <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156456/HW-CTF+Generating+Interrupt+Status+Bit+Trees+from+IP-XACT+register+descriptions" data-linked-resource-id="16156456" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF Generating Interrupt Status Bit Trees from IP-XACT register descriptions</a></p><h1 id="HW-CTFSymphonyBlockCommonCharacteristics-RTLCodingImplications">RTL Coding Implications</h1><p>Software visible blocks that can be instanced inside other blocks that can generate CSR files will need two things:</p><ol><li>A CSR function that is defined in sym_lib_utils.js that generates the CSR object to be written. The function must be used by the block to generate its CSR.</li><li>An input variable named createCSR of type boolean (can be a 0/1 int in TACHL code) that defaults to true in the CPR description.</li></ol><p>Blocks that instance other software visible blocks that have CSRs must do the following:</p><ol><li>Pass createCSR = false to instanced block.</li><li>Call the blocks CSR function with the parameters and merge that CSR object the with the blocks CSR object before writing it out.</li></ol><h1 id="HW-CTFSymphonyBlockCommonCharacteristics-Booleans">Booleans</h1><p>Boolean parameters can be coded as either an int or a boolean, but software will always see them as type boolean. This mean if you code a boolean as int, when you use it as a logical operator you must do the following:</p><p style="margin-left: 30.0px;">if (variable) {}</p><p>not:</p><p style="margin-left: 30.0px;">if (variable === 1) {}</p><p>or any other option where you are comparing the variable to a value.</p><h1 id="HW-CTFSymphonyBlockCommonCharacteristics-LockonValidvs.LockonReady">Lock on Valid vs. Lock on Ready</h1><p>A network can be configured to bet lock on ready vs. lock on valid. When a network is configured lock on ready, it is retracting. This means the addition of a parameter with a similar to:</p><pre>  &quot;lckStyleValid&quot; : true or false,</pre><p>When a network is lock on valid, blocks do not need to do anything.</p><p>When a network is lock on ready, any block that takes in an ATP interface and splits it between two or more sinks will need to put down a buffer on the ATP interface with depth = 1, pF = pB = false. This is to lock the ATP interface and prevent it from retracting. It is not allowed to look at the readies of the two or more sinks and use that to filter the forward going valids to the sinks because that is making valid a function of ready which we don't allow.</p><h1 id="HW-CTFSymphonyBlockCommonCharacteristics-VCversionsofblocks">VC versions of blocks</h1><p>When there are two software visible versions of a block, non-VC version vs. VC version, with the exception of the async adapter and clock/power domain adapter, the following minimum set of parameters are added:</p><pre>  &quot;numPri&quot; : positive number 1 or greater.</pre><pre>  &quot;mstrArbLck&quot; : true or false,</pre><pre>  &quot;lckStyleValid&quot; : true or false,</pre><pre>  &quot;arbType&quot; : &quot;string&quot;,  // Any arbType allowed by sym_switch.</pre><pre>  &quot;arbRdyAware&quot; : true or false, </pre><pre>  &quot;weights&quot; : [wl,wm,wn], // if arbType arb_wrr_*, what are the weights.</pre><h1 id="HW-CTFSymphonyBlockCommonCharacteristics-ASYNCblocks">ASYNC blocks</h1><p>For blocks that span clock domains, three rules need to be followed:</p><p>1) There need to be two sub blocks where all the registers in each sub block is only clocked by one clock.</p><p>2) The interfaces that go between the two sub blocks must have the same interface name for module and local on the instances of the sub block. </p><p>3) The sub blocks must use new interface style for all of its ports.</p><h1 id="HW-CTFSymphonyBlockCommonCharacteristics-TACHLexclusiontags">TACHL exclusion tags</h1><p>No tag if the code is never used (Error messages)</p><p>&quot;symphony&quot; for code that is not ever used in Symphony use case (Ncore specific code)</p><p>&quot;symphonyR1&quot; for code that is not used in the Symphony R1 release (aka Presto 1.0)</p><p>&quot;symphonyQA&quot; for code that is not used in the Symphony QA release to AEs</p><p><br/></p><h1 id="HW-CTFSymphonyBlockCommonCharacteristics-Asserts">Asserts</h1><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156450/HW-CTF+Symphony+Asserts" data-linked-resource-id="16156450" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF Symphony Asserts</a></p>