<h2 id="memory_sleep-Descriptions">Descriptions</h2><p>Memory Sleep Controller for multiple memories.</p><p>There is a state machine per memory.</p><p>The state machine monitors the input &quot;active_i&quot; from the external logic to determine if it needs to put the memory bank into sleep, or out from sleep.</p><p>The state machine asserts LS_o (the level sensitive Light Sleep pin) to memory to put the memory in Light Sleep, and to indicate that the state machine is in LS state.</p><p>The state machine asserts DS_o (the level sensitive Deep Sleep pin) to memory to put the memory in Deep Sleep, and to indicate that the state machine is in DS state.</p><p>The state machine asserts SD_o (the level sensitive Shut Down pin) to memory to put the memory in Shut Down, and to indicate that the state machine is in SD state.</p><p>The state machine monitors ROP_i (the level sensitive Ready For Operation pin) from the memory to sense the memory wake up from Deep Sleep or from Shut Down. </p><p>The state machine's initial state is NORMAL state.</p><p>In NORMAL state, if &quot;active_i&quot; is low for &quot;ls_timer_max_i&quot; &gt; 0 consecutive cycles, then the state machine transitions to LS state; else if &quot;active_i&quot; is low for &quot;ds_timer_max_i&quot; &gt; 0 consecutive cycles, then the<br/>state machine transitions to DS state; else if &quot;active_i&quot; is low for &quot;sd_timer_max_i&quot; &gt; 0 consecutive cycles, then the state machine transitions to SD state.</p><p>In LS state, if &quot;active_i&quot; is high, then the state machine transitions to LS_EXIT state; else if &quot;active_i&quot; is low for &quot;ds_timer_max_i&quot; &gt; 0 consecutive cycles, then the state machine transitions to DS state; else if &quot;active_i&quot; is low for &quot;sd_timer_max_i&quot; &gt; 0 consecutive cycles, then the state machine transitions to SD state.</p><p>In LS_EXIT state, the state machine waits for &quot;nLsExitTime&quot; &gt;=0 cycles and transitions to NORMAL state.</p><p>In DS state, if &quot;active_i&quot; is high, then the state machine transitions to DS_EXIT state; else if &quot;active_i&quot; is low for &quot;sd_timer_max_i&quot; &gt; 0 consecutive cycles, then the state machine transitions to SD state.</p><p>In DS_EXIT state, the state machine waits for &quot;ROP_i&quot; assertion to return to NORMAL state.</p><p>In SD state, if &quot;active_i&quot; is high, then the state machine transitions to SD_EXIT state.</p><p>In SD_EXIT state, the state machine waits for &quot;ROP_i&quot; assertion to return to NORMAL state.</p><p>In any state, if &quot;force_sd_i&quot; is high, then the state machine enters SD state and the timer resets to zero; else if &quot;force_ds_i&quot; is high, then the state machine enters DS state and the timer resets to zero.</p><p>NOTE:</p><p>The wake up of memories from Deep Sleep and Shut Down are managed by chaining them together in series.<br/>The wake up requests for Deep Sleep and Shut Down (sensed through the active_i[nMems-1:0] inputs) are picked one by one through a find first logic.</p><h2 id="memory_sleep-jsParameters">js Parameters</h2><p> </p><div class="table-wrap"><table class="confluenceTable"><thead><tr><th class="confluenceTh"><div class="tablesorter-header-inner">Parameter</div></th><th class="confluenceTh"><div class="tablesorter-header-inner">Type</div></th><th class="confluenceTh"><div class="tablesorter-header-inner">Range of values</div></th><th class="confluenceTh"><div class="tablesorter-header-inner">Default</div></th><th colspan="1" class="confluenceTh"><div class="tablesorter-header-inner"><p>Description</p></div></th></tr></thead><tbody><tr><td colspan="1" class="confluenceTd">nMems</td><td colspan="1" class="confluenceTd">int</td><td colspan="1" class="confluenceTd"> </td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">Number of memories</td></tr><tr><td colspan="1" class="confluenceTd">wLsTmr</td><td colspan="1" class="confluenceTd">int</td><td colspan="1" class="confluenceTd"> </td><td colspan="1" class="confluenceTd">4</td><td colspan="1" class="confluenceTd">The width of the Light Sleep timer. If this value is zero, then the Light Sleep interface and logic is not instantiated.</td></tr><tr><td colspan="1" class="confluenceTd">wDsTmr</td><td colspan="1" class="confluenceTd">int</td><td colspan="1" class="confluenceTd"> </td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">The width of the Deep Sleep timer. If this value is zero, then the Deep Sleep interface and logic is not instantiated.</td></tr><tr><td colspan="1" class="confluenceTd">wSdTmr</td><td colspan="1" class="confluenceTd">int</td><td colspan="1" class="confluenceTd"> </td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">The width of the Shut Down timer. If this value is zero, then the Shut Down interface and logic is not instantiated.</td></tr><tr><td colspan="1" class="confluenceTd">nLsExitTime</td><td colspan="1" class="confluenceTd">int</td><td colspan="1" class="confluenceTd"><span>0..(2^wLsTmr)-1</span></td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd"><p>Number of cycles to wait in LS_EXIT state to satisfy the timing requirement</p><pre>Tflsc (Light Sleep LS fall setup time before CLK rises)</pre></td></tr></tbody></table></div><h2 id="memory_sleep-VerilogParameters"><br/>Verilog Parameters </h2><p> </p><div class="table-wrap"><table class="confluenceTable"><thead><tr><th class="confluenceTh"><div class="tablesorter-header-inner">Parameter</div></th><th class="confluenceTh"><div class="tablesorter-header-inner">Type</div></th><th class="confluenceTh"><div class="tablesorter-header-inner">Range of values</div></th><th class="confluenceTh"><div class="tablesorter-header-inner">Default</div></th><th colspan="1" class="confluenceTh"><div class="tablesorter-header-inner"><p>Description</p></div></th></tr></thead><tbody><tr><td class="confluenceTd"> </td><td class="confluenceTd"> </td><td class="confluenceTd"> </td><td class="confluenceTd"> </td><td colspan="1" class="confluenceTd"> </td></tr></tbody></table></div><h2 id="memory_sleep-IOPorts"><br/>IO Ports</h2><p> </p><div class="table-wrap"><table class="confluenceTable"><thead><tr><th style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner">Port</div></th><th style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner">Direction</div></th><th style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner">Width</div></th><th colspan="1" style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner"><p>Description</p></div></th></tr></thead><tbody><tr><td class="confluenceTd">clk</td><td class="confluenceTd">Input</td><td class="confluenceTd">1</td><td colspan="1" class="confluenceTd">Clock. The memories are also running off this clock.</td></tr><tr><td colspan="1" class="confluenceTd">reset_n</td><td colspan="1" class="confluenceTd">Input</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">Reset, active low, async</td></tr><tr><td colspan="1" class="confluenceTd">active_i</td><td colspan="1" class="confluenceTd">Input</td><td colspan="1" class="confluenceTd">nMems</td><td colspan="1" class="confluenceTd">Per memory. 1 indicates that there's an active operation to the memory.</td></tr><tr><td colspan="1" class="confluenceTd">ready_for_operation_o</td><td colspan="1" class="confluenceTd">Output</td><td colspan="1" class="confluenceTd">nMems</td><td colspan="1" class="confluenceTd">Per memory. To a CSR register. 1 indicates the memory is ready for operation.</td></tr></tbody></table></div><p> </p><p>if (wLsTmr &gt; 0) {</p><div class="table-wrap"><table class="confluenceTable"><thead><tr><th style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner">Port</div></th><th style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner">Direction</div></th><th style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner">Width</div></th><th colspan="1" style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner"><p>Description</p></div></th></tr></thead><tbody><tr><td colspan="1" class="confluenceTd">in_light_sleep_o</td><td colspan="1" class="confluenceTd">Output</td><td colspan="1" class="confluenceTd">nMems</td><td colspan="1" class="confluenceTd">Per memory. To a CSR register. 1 indicates the memory is in Light Sleep.</td></tr><tr><td colspan="1" class="confluenceTd">LS_o</td><td colspan="1" class="confluenceTd">Output</td><td colspan="1" class="confluenceTd">nMems</td><td colspan="1" class="confluenceTd">Per memory. The Light Sleep pin (level sensitive) to memory.</td></tr></tbody></table></div><p>    for (var i = 0; i &lt; u.getParam('nMems'); i++) {</p><div class="table-wrap"><table class="confluenceTable"><thead><tr><th style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner">Port</div></th><th style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner">Direction</div></th><th style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner">Width</div></th><th colspan="1" style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner"><p>Description</p></div></th></tr></thead><tbody><tr><td colspan="1" class="confluenceTd">ls&lt;i&gt;_timer_max_i</td><td colspan="1" class="confluenceTd">Input</td><td colspan="1" class="confluenceTd">wLsTmr</td><td colspan="1" class="confluenceTd">Timer max value for counting the idle cycles for entry into Light Sleep</td></tr></tbody></table></div><p>    }</p><p>}</p><p> </p><p>if ((wDsTmr &gt; 0) || (wSdTmr &gt; 0)) {</p><div class="table-wrap"><table class="confluenceTable"><thead><tr><th style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner">Port</div></th><th style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner">Direction</div></th><th style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner">Width</div></th><th colspan="1" style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner"><p>Description</p></div></th></tr></thead><tbody><tr><td colspan="1" class="confluenceTd">ROP_i</td><td colspan="1" class="confluenceTd">Input</td><td colspan="1" class="confluenceTd">nMems</td><td colspan="1" class="confluenceTd">Per memory. The Ready For Operation pin (level sensitive) for Wake Up from memory for Deep Sleep and Shut Down only.</td></tr></tbody></table></div><p>}</p><p> </p><p>if (wDsTmr &gt; 0) {</p><div class="table-wrap"><table class="confluenceTable"><thead><tr><th style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner">Port</div></th><th style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner">Direction</div></th><th style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner">Width</div></th><th colspan="1" style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner"><p>Description</p></div></th></tr></thead><tbody><tr><td colspan="1" class="confluenceTd">force_ds_i</td><td colspan="1" class="confluenceTd">Input</td><td colspan="1" class="confluenceTd">nMems</td><td colspan="1" class="confluenceTd">Per memory. From a CSR register. Force the memory into Deep Sleep.</td></tr><tr><td colspan="1" class="confluenceTd">in_deep_sleep_o</td><td colspan="1" class="confluenceTd">Output</td><td colspan="1" class="confluenceTd">nMems</td><td colspan="1" class="confluenceTd">Per memory. To a CSR register. 1 indicates the memory is in Deep Sleep.</td></tr><tr><td colspan="1" class="confluenceTd">DS_o</td><td colspan="1" class="confluenceTd">Output</td><td colspan="1" class="confluenceTd">nMems</td><td colspan="1" class="confluenceTd">Per memory. The Deep Sleep pin (level sensitive) to memory.</td></tr></tbody></table></div><p>    for (var i = 0; i &lt; u.getParam('nMems'); i++) {</p><div class="table-wrap"><table class="confluenceTable"><thead><tr><th style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner">Port</div></th><th style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner">Direction</div></th><th style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner">Width</div></th><th colspan="1" style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner"><p>Description</p></div></th></tr></thead><tbody><tr><td colspan="1" class="confluenceTd">ds&lt;i&gt;_timer_max_i</td><td colspan="1" class="confluenceTd">Input</td><td colspan="1" class="confluenceTd">wDsTmr</td><td colspan="1" class="confluenceTd">Timer max value for counting the idle cycles for entry into Deep Sleep</td></tr></tbody></table></div><p>    }</p><p>}</p><p> </p><p>if (wSdTmr &gt; 0) {</p><div class="table-wrap"><table class="confluenceTable"><thead><tr><th style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner">Port</div></th><th style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner">Direction</div></th><th style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner">Width</div></th><th colspan="1" style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner"><p>Description</p></div></th></tr></thead><tbody><tr><td colspan="1" class="confluenceTd">force_sd_i</td><td colspan="1" class="confluenceTd">Input</td><td colspan="1" class="confluenceTd">nMems</td><td colspan="1" class="confluenceTd">Per memory. From a CSR register. Force the memory into Shut Down.</td></tr><tr><td colspan="1" class="confluenceTd">in_shutdown_o</td><td colspan="1" class="confluenceTd">Output</td><td colspan="1" class="confluenceTd">nMems</td><td colspan="1" class="confluenceTd">Per memory. To a CSR register. 1 indicates the memory is in Shut Down.</td></tr><tr><td colspan="1" class="confluenceTd">SD_o</td><td colspan="1" class="confluenceTd">Output</td><td colspan="1" class="confluenceTd">nMems</td><td colspan="1" class="confluenceTd">Per memory. The Shut Down pin (level sensitive) to memory.</td></tr></tbody></table></div><p>    for (var i = 0; i &lt; u.getParam('nMems'); i++) {</p><div class="table-wrap"><table class="confluenceTable"><thead><tr><th style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner">Port</div></th><th style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner">Direction</div></th><th style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner">Width</div></th><th colspan="1" style="text-align: center;" class="confluenceTh"><div class="tablesorter-header-inner"><p>Description</p></div></th></tr></thead><tbody><tr><td colspan="1" class="confluenceTd">sd&lt;i&gt;_timer_max_i</td><td colspan="1" class="confluenceTd">Input</td><td colspan="1" class="confluenceTd">wSdTmr</td><td colspan="1" class="confluenceTd">Timer max value for counting the idle cycles for entry into Shut Down</td></tr></tbody></table></div><p>    }</p><p>}</p><div><p> </p></div><pre>Datasheet: </pre><pre>/engr/dev/tools/synopsys/memory/TSMC16nm/install_dir/ts16nxq41p11sadcl02msa04/edoc1279_ts16nxq41p11sadcl02ms.pdf</pre><pre>===============================================================================================</pre><pre>From Datasheet<br/>===============================================================================================<br/>LS (Light Sleep) - Provides leakage reduction with fine-grained power gating and source biasing.<br/>DS (Deep Sleep) - When the DS pin is asserted, integrated periphery power gating with data retention<br/> available and the memory outputs are held low.<br/>SD (Shut Down) - When the SD pin is asserted, there is a complete shutdown (both the periphery and<br/> array are power gated), with no data retention, and the memory outputs are held low.</pre><pre>A wake-up (Ready for Operation = ROP) pin is also provided in the Deep Sleep and Shut Down modes<br/>to manage and control the in-rush peak current of the SoC. It enables memories to be chained together<br/>in this mode and allows them to be woken up serially.</pre><pre>Memory Input Pin<br/>----------------<br/>Signal Enabled         Description<br/>LS     ls_enabled=TRUE Light Sleep Input. <br/>                       When the memory is disabled and the pin is active, <br/>                       then the memory goes into low leakage mode. <br/>                       There is no change in the output state.<br/>DS     pg_enabled=TRUE Deep Sleep Input. <br/>                       This pin shuts down power to periphery and maintain memory contents. <br/>                       The outputs of the memory are pulled low.<br/>SD     pg_enabled=TRUE Shut Down Input. <br/>                       This pin shuts down power to periphery and memory core, no memory data retention.</pre><pre>Memory Output Pin<br/>-----------------<br/>Signal Enabled        Description<br/>ROP    pg_enable=TRUE ROP is Ready for Operation pin. <br/>                      This pin should be high for any valid memory operation.</pre><pre>Power Mode Truth Table<br/>----------------------<br/>Mode        ME   LS    DS    SD    ROP   Q<br/>----------------------------------------------<br/>Normal      0/1  0     0     0     ROP-1 Q-1<br/>----------------------------------------------<br/>Light Sleep 0/1  1     0     0     ROP-1 Q-1<br/>----------------------------------------------<br/>Deep Sleep  X    X     0-&gt;1  0     0     0<br/>            X    X     1-&gt;0  0     1     Qr<br/>----------------------------------------------<br/>Shutdown    X    X     1/0   0-&gt;1  0     0<br/>            X    X     1/0   1-&gt;0  1     Qr<br/>----------------------------------------------</pre><p> </p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="https://arterisip.atlassian.net/wiki/download/attachments/16167493/MemorySleepPowerDownModeTiming.JPG?api=v2"></span></p><pre> </pre><pre>NOTE:</pre><pre>An alternative solution to avoid memory access during wake-up is to set the ME pin to inactive<br/>state for at least &quot;Tflsc/Tfdsc/Tfsdc&quot; time interval after the &quot;LS/DS/SD&quot; falling edge.</pre><pre>Timing Parameters (number below is for ffgnp_ccbt_0p88v_n40c snopsys/memory/TSMC16nm, 16Kx32CM16SW1BK8CD1)<br/>-------------------------------------------------------------------------------------<br/>Trlsc (Light Sleep LS rise setup time before CLK rises)   = 0.022 ns min<br/>Trdsc (Deep Sleep  DS rise setup time before CLK rises)   = 0.078 ns min<br/>Trsdc (Shut Down   SD rise setup time before CLK rises)   = 0.078 ns min<br/>Tflsc (Light Sleep LS fall setup time before CLK rises)   = 0.217 ns min <br/>Tfdsc (Deep Sleep  DS fall setup time before CLK rises)   = 9.650 ns min <br/>Tfsdc (Shut Down   SD fall setup time before CLK rises)   = 9.650 ns min<br/>Tlsx  (Light Sleep LS hold time ater CLK rises)           = 0.086 ns min<br/>Tcdsx (Deep Sleep  DS hold time ater CLK rises)           = 0.556 ns min<br/>Tcsdx (Shut Down   SD hold time ater CLK rises)           = 0.556 ns min<br/>Tlsi  (Light Sleep LS active to memory low-leakage state) = 0.422 ns max<br/>Tdsi  (Deep Sleep  LS active to memory low-leakage state) = 0.682 ns max<br/>Tsdi  (Shut Down   SD active to memory low-leakage state) = 0.682 ns max<br/>Tdsrropf (DS rise to ROP falling delay)                   = 0.175 ns max<br/>Tdsfropr (DS fall to ROP rising delay)                    = 9.650 ns max<br/>Tsdrropf (SD rise to ROP falling delay)                   = 0.175 ns max<br/>Tsdfropr (SD fall to ROP rising delay)                    = 9.650 ns max</pre>