<p> This is a document to capture current thinking on the development methodology for maestro. It remains a work in progress and reads are encouraged to make their own contributions.</p><h2 id="Methodology-Language">Language</h2><p>Maestro shall be written in pure C++/STL. We may consider ancillary scripting languages such as TCL and QtQuick where applicable, however these shall be limited to their particular domain.</p><p>C++ is a dynamic language, therefore we are confronted with the need to standardized around a particular version of the C++ standard. The choices are as follows:</p><h3 id="Methodology-C++03">C++03</h3><p>C++03 is the most well established C++ standard and has found wide adoption. It is perhaps the most well known standard in the team.</p><h3 id="Methodology-C++11">C++11</h3><p>C++11 is a recent addition to the core C++. C++11 introduces many new concepts previously unavailable in C++03 from which Maestro may directly benefit. These include, but are not limited to: rvalue semantics, lambda, an enhance standard library, type inference (auto), smart pointers. C++11 is common in recent C++ project however  many legacy tools remain written in pure C++03.</p><p>C++11 presents a significant overhaul of the C++ language and introduces many features from which we could directly benefit. It is now very well established in the industry and tool support is excellent.</p><h3 id="Methodology-C++14">C++14</h3><p>C++14 is a minor tweak to the existing C++11 standard. It is an incremental upgrade to C++11 and largely contains features and tweaks that arrived too late for the C++11 standardization process (make_unique).</p><p>Although fairly recent, C++14 presents a minor modification compared with C++11. Consequently, C++14 presents little risk compared to C++11.</p><h3 id="Methodology-C++17">C++17</h3><p>C++17 is the most recent version of the C++ standard. It introduces some additional features (scoped namespaces, template inference, destructing binds) that although useful, present limited advantage to those features found already in C++11/14. C++17 is an emerging standard therefore tool support remains limited and there is perhaps little awareness in the team how such additional features could be leveraged in Maestro.</p><p> </p><h3 id="Methodology-Conclusion">Conclusion</h3><p>The choice of language largely depends upon the choice of platform. Presently, it is hard to justify C++17 as the standard of choice. It is too bleeding edge and there are real questions over tool support. C++11 has been widely adopted in the industry and is presently used in a large number of projects. C++14 is simply an incremental improvement over C++11 and changes very little of substance other than to rationalize some of the features introduced by C++11.</p><h2 id="Methodology-GUI">GUI</h2><p>The choice of GUI toolkit is clearly an important choice. A large body of existing EDA tools appear to use either custom frameworks, or use QT. QT appears to be the standard GUI library for C++ applications and has seen wide adoption in the industry. QT provides a sub-language called QtQuick which is a JSON/HTML-like language to describe layout and appearance. It uses a Javascript-like language to script behavior as desired. </p><p>QT has a number of key advantages: it is well known in the industry, it is already used in EDA tools (allowing us to maintain a consistent look-and-feel with competitor products), it has many of the details &quot;already worked out&quot;, we have support available if needed. QT provides a number of cross-platform libraries that may be used within the core Maestro libraries. Although useful, we would prefer that QT and related technologies remain limited to the GUI front-end as expertise in the team is heavily weighted on the C++/STL side and relatively light on the QT side.</p><p>QT is not free software. It can be used free of charge for projects that are open source, it must however be licensed if to be used in a commercial, closed-source project. Upon initial investigation, it appears that licensing for the technology begins at around $300/month, but it is not understood how this changes as a function of seats.</p><h2 id="Methodology-Platform">Platform</h2><p>We should target platforms common with those targeted by large EDA vendors. Unfortunately, such platforms are typically some generations behind the leading edge (at times many years behind). Presently, we consider RHEL as our core target platform, however our developers use either CentOS (which is itself a variant of RHEL) and Ubuntu. We should consider the impact our chosen platform has on our ability to leverage C++ constructs and ancillary tools. </p><p>The choice of platform to be targeted is a key design design that should be made before any development is carried out.</p><h2 id="Methodology-IDE">IDE</h2><p>We do not mandate a common IDE across the project. Each individual is familiar with an IDE/Text editor with which they are most comfortable. To enforce use of a secondary editor would only present an impedance mismatch between the developer and the keyboard. The individual is therefore free to use their text editor of choice provided that in doing so they are able to obey to coding style guidelines defined herein.</p><h2 id="Methodology-CodingConventions">Coding Conventions</h2><p>MK has recommended the &quot;High Integrity C++ Coding Standard 4.0&quot; as a prospective coding standard. There exist other coding standards, Google and LLVM, that have seen widespread adoption. It is desirable to leverage existing tools such as clang-tidy and clang-format to mechanically enforce coding standards across the team. Such tools exist for the Google and LLVM coding standards, however no tool exists for High Integrity. This remains TBD. </p><p> </p><p>We should enforce coding layout conventions. All code within the project should retain a command look and feel. We have available a tool called clang-format that can automatically reformat C++ based upon the projects style guidelines. This remains TBD.</p><h3 id="Methodology-Whitespace">Whitespace</h3><p>All code should be free of whitespace violations (superfluous whitespace at the end of a line). Files should be terminated using an additional blank line at the EOF (as standard). Spaces should be used over Tabs. </p><h2 id="Methodology-Ancillarylibraries">Ancillary libraries</h2><h3 id="Methodology-Boost">Boost</h3><p>Boost is a standard library used in many C++ projects. It is very common in the industry and the libraries therein are commonly precursors to those found in new generations of the C++ standard. The Boost library itself, although free, is licensed under terms that allow for it to be used in commercial products with no concern. In fact, it is already commonly used with many industry-leading applications written in C++.</p><p>Boost maintains many sub-libraries. Although very well-established and tested, they are fairly complex to use and could potentially pose problems for packaging and deployment. Before adding a particular Boost library as a dependency, we should consider the impact that this has on our code base.</p><h3 id="Methodology-STL">STL</h3><p>The Standard Template Library is the standard C++ library. Preference should be made to leverage existing data-structures and algorithms already implemented in the STL instead of reinventing the wheel. We should limit our use of the C standard library and remain consistent with modern C++ methodologies.</p><h3 id="Methodology-QT">QT</h3><p>QT shall be used to generate Maestro's GUI. Although QT provides a number of libraries that may be used for core functionality in Maestro, we shall specifically limits its use to the front end GUI.</p><h2 id="Methodology-Build">Build</h2><p>Maestro shall be built using CMake. CMake presents a number of significant advantages over standard Makefiles. CMake projects operate at a higher level of abstraction than standard Makefiles and therefore more important data about file relationships and dependencies. CMake can generate Makefiles as an output that can then be used for the purpose of build. CMake offers the secondary advantage that it can generate a compile_commands.json file. This file can be used by free tools to perform auto-completion and/or project navigation.</p><h2 id="Methodology-Packaging/Deployment">Packaging/Deployment</h2><p>We require a packaging and deployment strategy for Maestro. Specifically, we need a fool proof and automated means by which Maestro can be packaged to be deployed to a customer.</p><p>Presently, there are two options:</p><h3 id="Methodology-CPack">CPack</h3><p>CPack is a package distributed alongside CMake. It leverages the existing CMake build scripts to generate an installation executable or archive. It appears to be fully automated and the path of least effort as our existing builds are carried out using CMake. </p><h3 id="Methodology-QT.1">QT</h3><p>Qt has its own deployment technology. It is closely integrated with Qt and may be useful for deploying dependencies along with our code. As the front-end is written in QT, this too may offer a solution.</p><p> </p><h2 id="Methodology-Test">Test</h2><p>Test is a first-level requirement of our project. All code should have related Unit Tests. There are two proposed Unit Test libraries:</p><h3 id="Methodology-GTest/Mock">GTest/Mock</h3><p>Google Test/Mock is the standard C++ unit test framework from Google. It appears to have widespread adoption in the industry and is supported and used by Google.</p><h3 id="Methodology-Catch">Catch</h3><p>Catch is a C++ unit library that appears to have gained traction over GTest. On superficial analysis, it appears to be very similar in structure to GTest and it is unclear how one could benefit from its use. Although it is an open source project, it does not appear to have a large organization behind it and therefore support is unknown. This, however, remains true of GTest too.</p><h3 id="Methodology-CTest">CTest</h3><p>CTest is a tool distributed alongside CMake. It is not a unit test library. Instead, it is simply a driver that invokes all tests within a CMake project. It consolidates reports and automatically checks PASS/FAIL status. It is fully integrated with GTest.</p><h3 id="Methodology-GUI.1">GUI</h3><p>Automated test of the Maestro GUI should be carried out. One would assume that there exists a methodology and test framework in QT however this has not yet been explored. At present, there exists little expertise in the team on how to do this, however it remains a priority. This would like become a key objective of the individual tasked with GUI development. </p><h2 id="Methodology-CodeReview">Code Review</h2><p>There is much to be gained by regular code reviews. Code reviews allow developers to gain an insight into the work of other individuals. They allow useful feedback across the team that can be use as a means by which bad design decision can be caught early in the design process. A secondary benefit of code reviews is that they enhance communication across the team and enable individuals to gain an insight on the coding style of their colleagues. </p><h2 id="Methodology-TBD/Actions">TBD/Actions</h2><ul><li><a class="createlink" href="/wiki/pages/createpage.action?spaceKey=ENGR&amp;title=MK%2FJB&amp;linkCreation=true&amp;fromPageId=16171295">MK/JB</a> (Urgent) Decide upon supported/targeted platforms. This directly impacts the C++ standard, the tools and the version of QT we can use.</li></ul><p> </p><p> </p>