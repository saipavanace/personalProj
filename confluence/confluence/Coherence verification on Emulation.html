<p>Below tests are also available as a C program to be run on the SoC emulation build with A78 ARM DSU+Ncore3+Transactor Memory model. Alternatively, some of these sequences will not be developed in system verilog and instead just be tested in C program. </p><p><br/></p><h1 id="CoherenceverificationonEmulation-1.Coherencytest">1. Coherency test</h1><h2 id="CoherenceverificationonEmulation-1.1.Simplecoherencytest">1.1. Simple coherency test</h2><h2 id="CoherenceverificationonEmulation--FalseSharingverificationonVeloce">- False Sharing verification on Veloce</h2><p><strong>Principle</strong></p><p>This is the most classic test for coherent memory systems. In this test, all threads load and store to the same set of cachelines, but they never share a single bytes in them.</p><p>     1.a) C Program with ARM DSU+NCORE3:</p><p>In the present C program implementation of the false sharing test, thread number <code>N</code> only accesses byte number <code>N</code> of each cacheline. In a coherent system, when threads only access distinct memory locations, they must only read back the latest value they wrote at each address, even if they are effectively sharing cachelines.</p><p>One bug that would expose a different behavior would be to have a same cacheline in unique state in two different caches at the same time in the system. If data is stored to these two cachelines, one of these will get overriden by the other at some point and a thread will not be able to read back the latest data it wrote.</p><p>     1.b) System Verilog sequence with Veloce CHI transactors + Ncore 3 Transactor env: </p><p style="margin-left: 60.0px;">CHI 0 will do ReadUnique and modify its own designated bytes (WritePtl) in its own cache and update State IX(by using cache API).</p><p style="margin-left: 60.0px;">CHI 1 will do ReadUnique, a snoop will come to CHI0, CHI0 will send Modified data to NCore, Ncore will assume ownership and shift modified data to CH1, DRAM will not update.</p><p style="margin-left: 60.0px;">CHI 1 will modify its own designated bytes(WritePtl) in its own cache and update state UD (using cache API).  </p><p>We have 2 ways to implement data integrity check for this sequence:</p><p style="margin-left: 60.0px;">Maintain separate SB with each transactor keeping track of odd and even TXNID or address. Compare the Rd_Unique on CHI_0 with write on CHI_1 and Rd_unique on CHI_1 with write on CHI_0.</p><p style="margin-left: 60.0px;">Implement common SB approach, which compares all Rd_unique with preceding write.</p><h2 id="CoherenceverificationonEmulation--Producer-ConsumerbasedConsistencyverificationonVeloce:">- Producer-Consumer based Consistency verification on Veloce:</h2><h4 id="CoherenceverificationonEmulation-Principle"><strong>Principle</strong></h4><p>This program tests memory consistency and more specifically the release-acquire semantics. It uses two shared buffers (<code>A</code> and <code>B</code>) and N threads. The first thread is called the producer and the others are the consumers. Initially, the producer will randomly set buffer <code>A</code> while the consumers wait. Then, the consumers will read buffer <code>A</code> and check that they effectively read the values that the producer wrote. During that time, the producer sets buffer <code>B</code>. Once both the producer and the consumers are done, they switch buffer and repeat the same operation.</p><p>If the memory system is not consistent, the consumers might read a stale value despite having synchronized with the producer. In other words, the release-acquire semantics enforced by the synchronization might be violated by a non consistent system.</p><p>        2.a) For the consumers to be able to check that the values they read are indeed the values the producer wrote, the producer and the consumers use identically seeded instances of a same pseudo-random number generator. It enables the consumers to rebuild the sequence of values written by the producer without relying on the shared memory system which is being tested and might be faulty.</p><p>        2.b) Below is a sequence which does a very basic version of the producer-consumer sequence in one direction. This approach is very limited in the scenarios it is generate. Further enhancements to this update will follow once we have False sharing sequences enabled. </p><p style="margin-left: 60.0px;">CHI 0 will do WriteUnique and modify cache and memory with data every transaction.</p><p style="margin-left: 60.0px;">CHI 0 will do the ReadUnique to take ownership of the cache line and perform data integrity check.</p><p style="margin-left: 60.0px;">CHI 1 will do ReadOnce to get the data from CHI 0 cache and again perform data integrity check. </p><h2 id="CoherenceverificationonEmulation-1.2CoherencytestwiththelargechunkofthedataonLinuxenvironment">1.2 Coherency test with the large chunk of the data on Linux environment</h2><h2 id="CoherenceverificationonEmulation--MatrixmultiplicationusingOpenMPlibrary">- Matrix multiplication using OpenMP library</h2><p><br/></p><ul style="list-style-type: square;"><li>Matrix multiplication combined with atomic transaction</li></ul><p><br/></p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="https://arterisip.atlassian.net/wiki/download/attachments/16163781/image2022-6-2_9-43-53.png?api=v2"></span></p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="https://arterisip.atlassian.net/wiki/download/attachments/16163781/image2022-6-2_9-44-43.png?api=v2"></span></p><p><br/></p><ul style="list-style-type: square;"><li>Matrix multiplication with seperate calculation for each row</li></ul><p><br/></p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="https://arterisip.atlassian.net/wiki/download/attachments/16163781/image2022-6-2_13-40-57.png?api=v2"></span></p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="https://arterisip.atlassian.net/wiki/download/attachments/16163781/image2022-6-2_13-43-13.png?api=v2"></span></p><h2 id="CoherenceverificationonEmulation-1.3Coherncytestunderheavytrafficenvironment">1.3 Coherncy test under heavy traffic environment</h2><p><br/></p><h1 id="CoherenceverificationonEmulation-2.DVMtest">2. DVM test</h1><p>DVM transactions support the maintenance of a virtual memory system and are used to pass operations that cannot be conveyed using the normal coherency transactions. Support for Distributed Virtual Memory transactions is a design-time option for a component. Components must either fully participate in the distributed virtual memory scheme or they must never participate. Components that are participating must be capable of receiving any distributed virtual memory transaction and responding appropriately.</p><p>A DVM scheme has the following transaction types:</p><p>DVM Operation<br/>These transactions convey particular operations, such as a Translation Lookaside Buffer (TLB) invalidation request. A component can issue concurrent DVM Operations. DVM Operation is:</p><ul style="list-style-type: square;"><li>TLB invalidate</li><li>Branch Predictor Invalidate</li><li>Instruction Cache Invalidate</li><li>Synchronization</li></ul><p>DVM Sync<br/>This is a synchronization transaction that a component issues to check that all previous DVM Operations that it has issued have completed.</p><p>DVM Complete<br/>This transaction is issued in response to a DVM Sync transaction. It is issued by a component that has received a number of DVM Operations followed by a DVM Sync. The DVM Complete indicates that all the required operations and any associated transactions have completed.</p><h2 id="CoherenceverificationonEmulation-2.1SimpleDVMtest">2.1 Simple DVM test</h2><p><br/></p><h2 id="CoherenceverificationonEmulation-2.2DVMtestunderheavytrafficenvironment">2.2 DVM test under heavy traffic  environment</h2><p><br/></p><h1 id="CoherenceverificationonEmulation-3.Atomictest">3. Atomic test </h1><p>For SV based directed testbench, here is the testplan for atomic tests: </p><ol><li>Single Atomic transaction bring up</li><li>Multiple Atomic transaction (single kind) bring up</li><li>Different types of multiple atomic transactions bring up.</li><li>Single type of Stash transactions bring up</li><li>Different types of multiple Stash transaction bring up.</li><li><span class="legacy-color-text-blue3">Combination test case bring up </span><ol style="text-align: left;"><li>All types of reads, dataless(except stash ops) and writes enabled.</li><li>Address collisions between transactions enabled - this could change and might just do different address per transactions depending on RTL readiness.</li><li>Snoop, atomic and stash enabled in that order.</li></ol></li></ol>