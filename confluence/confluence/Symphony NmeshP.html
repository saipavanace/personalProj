<p>This area can be used to create an NxM mesh with P external ports per node.</p><h1 id="SymphonyNmeshP-Createanarea">Create an area</h1><pre>mkdir {fill_in_directory_name_here}<br/>cd {directory_name}<br/>/engr/dev/tools/script/setup_sym -d master<br/>source SOURCEME.tcsh <br/>(for bash: source SOURCEME.bash)</pre><h1 id="SymphonyNmeshP-CDtoNmesharea">CD to Nmesh area</h1><p>cd $WORK_TOP/tb/top/NmeshP</p><h1 id="SymphonyNmeshP-CreateanJSONfilethat&#39;sconfiguredforthenetworkyouaretryingtocreate.">Create an JSON file that's configured for the network you are trying to create.</h1><p>An example exist in the directory called BasePketParamsExpl.json</p><p>The route must be 30 to support X-Y-X or Y-X-Y routing.</p><p>The width of H_pri must be 3.</p><p>The width of steer in SMI must be 0. The width of H_steer must be 0.</p><p>The IDs are hardcoded to width of 10.</p><h1 id="SymphonyNmeshP-Runcreate_Nmesh.shscripttogenerateyournetwork">Run create_Nmesh.sh script to generate your network</h1><p>The script includes usage:</p><pre>./create_Nmesh.sh<br/>ERROR: ./create_Nmesh.sh Not enough arguments<br/>USAGE: ./create_Nmesh.sh $1 $2 $3 $4 $5 $6 $7<br/>  $1 = JSON file to base backet parameters<br/>  $2 = target data width<br/>  $3 = packet type (parallel, serial or fixed)<br/>  $4 = number of external ports per node<br/>  $5 = arbType for all switch arbs<br/>  $6 = name to give mesh<br/>  $7 = Value for lock on Valid in switch<br/>  $8 = X dimension of mesh<br/>  $9 = Y dimension of mesh<br/><br/>Base packet parameters JSON file format:<br/>{ &quot;params&quot; {base packet parameters}}</pre><pre> ./create_Nmesh.sh BasePketParamsExpl.json 128 parallel 1 arb_pri_rr1 req false 4 4<br/>max_beats: 4<br/>header_width: 231<br/>max_header_field_width: 30<br/>data_beat_multiplier: 8<br/>data_beat_width: 153<br/>min_data_beat_width_F: 19<br/>min_data_beat_width_C: 1<br/>min_data_width: 16<br/>number_data_beats: 4<br/>null bits to total bits: 0.451171875<br/>data bits to beat bits: 0.3984375</pre><pre><span style="font-family: Arial , sans-serif;">The above command creates a top level JSON file named req_meshATP_Nmesh.json that uses xy routing, where &quot;req&quot; is the name passed in for $6. All the sub files are uniquified with the $6 string, including the packet cpr, which is put in the cpr directory.<br/><br/>[jcodd@pomerol NmeshP]$ ./create_Nmesh_yx.sh BasePketParamsExpl.json 128 parallel 1 arb_pri_rr1 resp false 4 4<br/>max_beats: 4<br/>header_width: 231<br/>max_header_field_width: 30<br/>data_beat_multiplier: 8<br/>data_beat_width: 153<br/>min_data_beat_width_F: 19<br/>min_data_beat_width_C: 1<br/>min_data_width: 16<br/>number_data_beats: 4<br/>null bits to total bits: 0.451171875<br/>data bits to beat bits: 0.3984375<br/><br/><span>The above command creates a top level JSON file named resp_meshATP_Nmesh.json that uses yx routing, where &quot;resp&quot; is the name passed in for $6. All the sub files are uniquified with the $6 string, including the packet cpr, which is put in the cpr directory.</span><br/></span></pre><h1 id="SymphonyNmeshP-Runthefollowingcommandtogeneratetheverilogtorun">Run the following command to generate the verilog to run </h1><p>./run_NmeshP req_meshATP_Nmesh.json gen_wrapper.tachl Nmesh</p><h1 id="SymphonyNmeshP-Runsomeperformancetests">Run some performance tests</h1><p><br/></p><p>There some precanned test benches to run some performance tests. They require running the two ./create_Nmesh.sh and ./create_Nmesh_yx.sh commands above to work.</p><p>./run_NmeshP dut.json dut_smi.tachl dut_smi</p><p>Creates a test bench that can run performance tests on a single fabric SMI to SMI that uses xy routing</p><p>./run_NmeshP dut_yx.json dut_smi.tachl dut_smi_yx</p><p>Creates a test bench that can run performance tests on a single fabric SMI to SMI that uses yx routing</p><p>./run_NmeshP dut.json dut_smi_rr.tachl dut_smi_rr</p><p>Creates a test bench that can run performance test on a request fabric that uses xy routing to a response fabric that use xy routing.</p><p>./run_NmeshP dut_rr_yx.json dut_smi_rr_yx.tachl dut_smi_rr_yx</p><p>Creates a test bench that can run performance test on a request fabric that uses xy routing to a response fabric that use yx routing.</p><p><br/></p>