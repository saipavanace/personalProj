<p><a href="/wiki/spaces/ENGR/pages/16157783/newTachl+Tachl+v4+and+higher?preview=%2F16157783%2F16325044%2FnewTachl+Presentation.pptx"><span style="background: url('/wiki/s/-672721829/6452/d621ad2a33e27b90ca05c475b216bfab745e08a2/1000.0.0-d621ad2a33e2/_/download/resources/com.atlassian.confluence.plugins.confluence-view-file-macro:view-file-macro-resources/images/placeholder-medium-presentation.png'); width: 333px; height: 95px; display: inline-block; padding-top: 155px; margin: 2px; border: 1px solid #ddd; text-align: center; vertical-align: text-bottom; text-decoration: none; font-size: 12px; color: #000;">newTachl Presentation.pp…</span></a></p><p><br/></p><p>Up to date with Tachl v4.1.1</p><p><br/></p><p><style type='text/css'>/*<![CDATA[*/
div.rbtoc1759723486587 {padding: 0px;}
div.rbtoc1759723486587 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1759723486587 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class='toc-macro rbtoc1759723486587'>
<ul class='toc-indentation'>
<li><a href='#newTachl(Tachlv4andhigher)-newTachlLanguagePresentation'>newTachl Language Presentation</a>
<ul class='toc-indentation'>
<li><a href='#newTachl(Tachlv4andhigher)-WhatisanewTachlunit?'>What is a newTachl unit?</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-Parametersdefinitionsandunitvariableassignments'>Parameters definitions and unit variable assignments</a>
<ul class='toc-indentation'>
<li><a href='#newTachl(Tachlv4andhigher)-Parameterdefinition'>Parameter definition</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-Getandcheckparametervalues'>Get and check parameter values</a>
<ul class='toc-indentation'>
<li><a href='#newTachl(Tachlv4andhigher)-Getallparameters'>Get all parameters</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-Getoneparameter'>Get one parameter</a></li>
</ul>
</li>
</ul>
</li>
<li><a href='#newTachl(Tachlv4andhigher)-Interfacefunction'>Interface function</a>
<ul class='toc-indentation'>
<li><a href='#newTachl(Tachlv4andhigher)-Simpleinterfacedeclaration'>Simple interface declaration</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-Inputsandoutputsdeclaration'>Inputs and outputs declaration</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-Multipleinterfacesdeclaration'>Multiple interfaces declaration</a></li>
</ul>
</li>
<li><a href='#newTachl(Tachlv4andhigher)-Architecturefunction'>Architecture function</a>
<ul class='toc-indentation'>
<li><a href='#newTachl(Tachlv4andhigher)-DeclarativenewTachlfunctions'>Declarative newTachl functions</a>
<ul class='toc-indentation'>
<li><a href='#newTachl(Tachlv4andhigher)-Wiredeclaration'>Wire declaration</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-Regdeclaration'>Reg declaration</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-Constantdeclaration'>Constant declaration</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-Enumdeclaration'>Enum declaration</a></li>
</ul>
</li>
<li><a href='#newTachl(Tachlv4andhigher)-Constantusage'>Constant usage</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-BasiccombinatorialnewTachlfunctions'>Basic combinatorial newTachl functions</a>
<ul class='toc-indentation'>
<li><a href='#newTachl(Tachlv4andhigher)-SimpleVerilogassignstatement'>Simple Verilog assign statement</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-Busoperation(busOR,busANDandbusXOR)'>Bus operation (bus OR, bus AND and bus XOR)</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-Inlinemux'>Inline mux</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-Netextension(with0)'>Net extension (with 0)</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-Signednetextension(withMSBbit)(sinceTachlv4.0.7)'>Signed net extension (with MSB bit) (since Tachl v4.0.7)</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-Netextraction'>Net extraction</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-Netresize'>Net resize</a></li>
</ul>
</li>
<li><a href='#newTachl(Tachlv4andhigher)-SequentialnewTachlfunctions'>Sequential newTachl functions</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-AdvancedcombinatorialnewTachlfunctions'>Advanced combinatorial newTachl functions</a>
<ul class='toc-indentation'>
<li><a href='#newTachl(Tachlv4andhigher)-Concatenation'>Concatenation</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-Split'>Split</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-Replicate'>Replicate</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-Reverse(sinceTachlv4.0.7)'>Reverse (since Tachl v4.0.7)</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-Or,And,XorandAddoflistofnets'>Or, And, Xor and Add of list of nets</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-Subofnets(SinceTachlv4.0.21)'>Sub of nets (Since Tachl v4.0.21)</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-Invofnet(SinceTachlv4.0.21)'>Inv of net (Since Tachl v4.0.21)</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-Comparisonofnets(SinceTachlv4.0.21)'>Comparison of nets (Since Tachl v4.0.21)</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-Casestatement(mux)'>Case statement (mux)</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-DecodedCasestatement(scanMux)(SinceTachlv4.0.26)'>Decoded Case statement (scanMux) (Since Tachl v4.0.26)</a></li>
</ul>
</li>
<li><a href='#newTachl(Tachlv4andhigher)-EvolvedcombinatorialnewTachlfunctions'>Evolved combinatorial newTachl functions</a>
<ul class='toc-indentation'>
<li><a href='#newTachl(Tachlv4andhigher)-Encodefunction'>Encode function</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-Decodefunction'>Decode function</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-ScanLsb/ScanMsbfunctions'>ScanLsb/ScanMsb functions</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-PopCountfunction(SinceTachlv4.0.21)'>PopCount function (Since Tachl v4.0.21)</a></li>
</ul>
</li>
<li><a href='#newTachl(Tachlv4andhigher)-SpecialnewTachlfunctions'>Special newTachl functions</a>
<ul class='toc-indentation'>
<li><a href='#newTachl(Tachlv4andhigher)-SimpleInstantiation'>Simple Instantiation</a>
<ul class='toc-indentation'>
<li><a href='#newTachl(Tachlv4andhigher)-InstantiatefororiginalTachlmodule'>Instantiate for original Tachl module</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-InstantiatefornewTachlmodule'>Instantiate for newTachl module</a></li>
</ul>
</li>
<li><a href='#newTachl(Tachlv4andhigher)-Multipleinstantiation'>Multiple instantiation</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-FiniteStateMachine'>Finite State Machine</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-NativeVerilogCode'>Native Verilog Code</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-HeaderComment(SinceTachlv4.0.15)'>Header Comment (Since Tachl v4.0.15)</a></li>
<li><a href='#newTachl(Tachlv4andhigher)-DesignComment(SinceTachlv4.0.15)'>Design Comment (Since Tachl v4.0.15)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div></p><h1 id="newTachl(Tachlv4andhigher)-newTachlLanguagePresentation">newTachl Language Presentation</h1><h2 id="newTachl(Tachlv4andhigher)-WhatisanewTachlunit?">What is a newTachl unit? </h2><div><ul><li>A newTachl unit is a JS function with only one argument (called “m” but can be any other letter)</li></ul></div><blockquote><pre>function unit(m) {<br/>    Parameters definitions and unit variables assignments<br/>    Interface function<br/>    Architecture function<br/>    function return statement<br/>}<br/>module.exports = unit</pre></blockquote><p><br/></p><div><ul><li>Inside the unit, all newTachl function calls must be prefixed with “m.” to reference the newTachl library.</li></ul><div><ul><li>A newTachl unit JS function must have 4 parts:<ul><li>The parameter part directly in the unit function. Unit variables can be declared in here too if you need to share them between the interface and the architecture to avoid duplication.</li><li>An interface function myInterface (WARNING : interface is a JS reserved word) where ports and interfaces of the unit will be declared.</li><li>An architecture function architecture where the architecture description of the unit is written.</li></ul></li><li>A newTachl unit JS function must return its internal function as a JS object:</li></ul><blockquote><pre>return { interface: myInterface, architecture: architecture }</pre></blockquote><ul><li>A newTachl file must export this JS unit function with this JS line:</li></ul><blockquote><pre>module.exports = unit;</pre></blockquote><ul><li>Like Tachl, newTachl manipulates strings and these strings are Verilog equations and net names.</li></ul><h2 id="newTachl(Tachlv4andhigher)-Parametersdefinitionsandunitvariableassignments">Parameters definitions and unit variable assignments</h2><h3 id="newTachl(Tachlv4andhigher)-Parameterdefinition">Parameter definition</h3><blockquote><pre>m.defineParam(<br/>   param_name,                      // Parameter name<br/>   param_type,                      // Parameter type (’int’, ’bit’, ’array’, ’boolean’, ’string’ or ’object’)<br/>   default_value,<br/>   min_value_or_legal_values_list,  // for ’int’ and ’array’ for min_value, legal_values_list for ’int’ only<br/>   max_value                        // for ’int’ and ’array’<br/> );</pre></blockquote><div class="O1"><ul><li>Parameter definition is not mandatory but highly recommended.</li></ul></div><div class="O1"><ul><li>Today, either ALL parameters must be defined or NONE of them. Partial parameters declaration is not working yet.</li></ul><h3 id="newTachl(Tachlv4andhigher)-Getandcheckparametervalues">Get and check parameter values</h3><p>These functions are use to get parameters from the parameter structure. These functions do all the possible parameter checks.</p><div><ul><li>If a module instantiates this unit with a wrong parameter name or type, you get an error</li></ul></div><div><ul><li>If a module instantiates this unit without passing some parameters values, default values are used in place of the missing ones. If there is no default value for a missing one, an error is raised.</li></ul></div></div><h4 id="newTachl(Tachlv4andhigher)-Getallparameters">Get all parameters</h4><blockquote><pre>m.getParams()</pre></blockquote><p>This function returns the entire parameter structure of the unit.</p><blockquote><pre class="O1">var p = m.getParams();<br/>var param0 = p.param0;</pre></blockquote><p class="O1">Or</p><blockquote><pre class="O1">var { param0 } = m.getParams();     // works only if there is only one parameter called ’param0’</pre></blockquote><h4 id="newTachl(Tachlv4andhigher)-Getoneparameter">Get one parameter</h4><blockquote><pre>m.getParam( param_name )</pre></blockquote><p>This function returns the parameter param_name from the parameter structure.</p><blockquote><pre>var param0 = m.getParam('param0_name');</pre></blockquote><h2 id="newTachl(Tachlv4andhigher)-Interfacefunction">Interface function</h2><blockquote><pre>function myInterface() {<br/>   m.interface(module_prefix, direction, interface_bundle, exclude_list);<br/>   m.input(width, input_port_name);<br/>   m.output(width, output_port_name);<br/> }</pre></blockquote><div><ul><li>The myInterface JS function has no argument and can use the variables declared in the unit function.</li></ul><h3 id="newTachl(Tachlv4andhigher)-Simpleinterfacedeclaration">Simple interface declaration</h3><blockquote><pre>m.interface(prefix, direction, interfaceSpec, excludeList)</pre></blockquote><p>The m.interface function has the same semantic as the original Tachl interface function:</p></div><div class="O1"><ul><li>1st argument is the module prefix</li><li>2nd argument is the direction -&gt; ’master’ or ’slave’</li><li>3rd argument is the interface bundle</li><li>4th argument is the exclude list from the interface bundle</li></ul><h3 id="newTachl(Tachlv4andhigher)-Inputsandoutputsdeclaration">Inputs and outputs declaration</h3><blockquote><pre>m.input(width, name)<br/>m.output(width, name)</pre></blockquote><p>m.input and m.output functions are for input and output declarations</p></div><div class="O1"><ul><li>1st argument is the width of the port</li><li>2nd argument is the name of the port</li></ul><h3 id="newTachl(Tachlv4andhigher)-Multipleinterfacesdeclaration">Multiple interfaces declaration</h3><blockquote><pre>m.nInterfaces(interfaceObj)</pre></blockquote><p>m.nInterfaces function has the same semantic as the original Tachl nInterfaces function</p><h2 id="newTachl(Tachlv4andhigher)-Architecturefunction">Architecture function</h2><ul><li>The architecture JS function has no argument and can use variables declared in the unit function.</li></ul><div class="O0"><ul><li>A lot of JS functions can be used here like m.reg, m.assign, m.mux2, m.field…</li></ul></div></div><div class="O0"><div><ul><li>The large majority of the newTachl functions follow this format:</li></ul></div><blockquote><pre class="O1">m.functionName(width, name, …args);</pre></blockquote><div class="O1"><ul><li style="list-style-type: none;background-image: none;"><ul><li>Where:</li></ul></li></ul></div><div class="O2"><ul><li style="list-style-type: none;background-image: none;"><ul><li style="list-style-type: none;background-image: none;"><ul><li>width is the size of the output net. Must be an integer.</li></ul></li></ul></li></ul></div><div class="O2"><ul><li style="list-style-type: none;background-image: none;"><ul><li style="list-style-type: none;background-image: none;"><ul><li>name is the output net name. Must be a string or JS null. Empty string or JS null for an unnamed net builds an auto-generated net named n_numericalValue.</li></ul></li></ul></li></ul></div><div class="O2"><ul><li style="list-style-type: none;background-image: none;"><ul><li style="list-style-type: none;background-image: none;"><ul><li>…args are the other arguments specific to the function.</li></ul></li></ul></li></ul></div><div class="O2"><ul><li style="list-style-type: none;background-image: none;"><ul><li>The return value of those functions is the output net name string.</li></ul></li></ul></div><div><ul><li>newTachl, like Tachl, manipulates strings. For equations, these strings are Verilog strings.</li></ul><div><ul><li>It is possible to call the functions recursively without limitation</li></ul></div><blockquote><pre>m.assign(1, ’foo’, `${m.assign(1, null, ’bar0 &amp; bar1’)} | ${m.assign(1, null, ’bar2 &amp; bar3’)}`);</pre></blockquote><div><ul><li>This line is equivalent to:</li></ul></div><blockquote><pre class="O1">var tmp0 = m.assign(1, null, ’bar0 &amp; bar1’); // return ’n_1’ into var tmp0|<br/>var tmp1 = m.assign(1, null, ’bar2 &amp; bar3’); // return ’n_2’ into var tmp1|<br/>m.assign(1, ’foo’, `${tmp0} | ${tmp1}`);</pre></blockquote><div><ul><li>And equivalent Verilog Code is (bar0, bar1, bar2 and bar3 are already declared nets):</li></ul></div><blockquote><pre class="O1">wire n_1;<br/>wire n_2;<br/>wire foo;<br/>assign n_1 = bar0 &amp; bar1;<br/>assign n_2 = bar2 &amp; bar3;<br/>assign foo = n_1 | n_2;</pre></blockquote><div class="O1"><div><ul><li>In the previous example, the equations are neither evaluated nor understood by newTachl, and no check is done on the width of the input nets (bar0, bar1, bar2 and bar3).</li></ul></div><div><ul><li>newTachl checks widths every time it is possible</li></ul></div><blockquote><pre class="O1">m.assign(10, ’foo’, ’bar[12:3]’);</pre></blockquote><div class="O2"><ul><li style="list-style-type: none;background-image: none;"><ul><li>newTachl  checks that the bits extraction is 10 bits here.</li></ul></li></ul></div><blockquote><pre class="O1">m.mux2(12, ’foo’, ’sel[2]’, ’bar1’, ’bar2 &amp; bar3’);</pre></blockquote><div class="O2"><ul><li style="list-style-type: none;background-image: none;"><ul><li>newTachl verifies that sel[2] is 1 bit as the selector of mux2.</li></ul></li></ul></div><div class="O2"><ul><li style="list-style-type: none;background-image: none;"><ul><li>newTachl verifies bar1's width  too because it's a net.</li></ul></li></ul></div><div class="O2"><ul><li style="list-style-type: none;background-image: none;"><ul><li>bar2 &amp; bar3 cannot be checked because it's an equation.</li></ul></li></ul><h3 id="newTachl(Tachlv4andhigher)-DeclarativenewTachlfunctions">Declarative newTachl functions</h3><h4 id="newTachl(Tachlv4andhigher)-Wiredeclaration">Wire declaration</h4><blockquote><pre>m.addWire(width, name);</pre></blockquote></div></div></div></div><div><p>Useful when a net is assigned bit by bit</p><blockquote><pre class="O2">m.addWire(10, ’foo’);<br/>m.assign(1, ’foo[0]’  , ’bar0’);<br/>m.assign(9, ’foo[9:1]’, ’bar1’);</pre></blockquote><div class="O1">Useful when a net is connected to an output port of an instance (instantiation of a Tachl module, not needed for newTachl module instantiation)</div><h4 id="newTachl(Tachlv4andhigher)-Regdeclaration">Reg declaration</h4><blockquote><pre>m.addReg(width,name);</pre></blockquote><p>Useful only when a registered net is assigned bit by bit</p><blockquote><pre class="O2">m.addReg(10, ’foo’);<br/>m.reg(1, ’foo[0]’  , ’bar0’);<br/>m.reg(9, ’foo[9:1]’, ’bar1’);</pre></blockquote><h4 class="O2" id="newTachl(Tachlv4andhigher)-Constantdeclaration">Constant declaration</h4><blockquote><pre class="O2">m.addConst(size, name, value &lt;, base&gt;);</pre></blockquote><p class="O2">Useful to declare a named constant value</p><div class="O2"><div class="O3"><ul><li>value is an integer value. It is a JS number, so syntax like 0x… , 0b… is allowed too.</li></ul></div><div class="O3"><ul><li>base is optional and is 2 by default. Allowed values are 2 (binary), 8 (octal), 10 (decimal) or 16 (hexadecimal). It is needed for the Verilog output.</li></ul></div><blockquote><pre class="O3">m.addConst(12, ’foo’, 123, 16);</pre></blockquote><p class="O3">or</p><blockquote><pre class="O3">m.addConst(12, ’foo’, 0x7b, 16); </pre></blockquote><p>gives this Verilog output</p><blockquote><pre class="O3">localparam foo = 12’h7b;</pre></blockquote><h4 class="O3" id="newTachl(Tachlv4andhigher)-Enumdeclaration">Enum declaration</h4><blockquote><pre class="O3">m.addEnum(enum_name, enum_list &lt;, encoding&gt;);</pre></blockquote><p class="O3">Useful to declare enumerated values (for State Machines for instance)</p><div class="O2"><ul><li>enum_list is defined by a list like [’enum_0’ ,..., ’enum_N’]<br/>or an object like { value_0 : ’enum_0’ ,..., value_N : ’enum_N’ }</li></ul></div><div class="O2"><ul><li>encoding is the encoding type. Default value is ’binary’, allowed values are ’binary’, ’one_hot’ or ’gray’.</li></ul><p>addEnum function return the width of the enumerated value (new in Tachl version 4.0.4).<br/>In the following example:</p><blockquote><pre>var wMyEnum = m.addEnum('MyEnum', {3 : 'FOO' , 7 : 'BAR' });</pre></blockquote><p>wMyEnum is equal to 3 because 3 bits are necessary to encode value 7 of enum 'BAR'.</p><h3 id="newTachl(Tachlv4andhigher)-Constantusage">Constant usage</h3><blockquote><pre>m.field(width, value &lt;, base&gt;);</pre></blockquote><p>Useful when constants are needed inside equations</p><div class="O2"><ul><li>value is an integer value</li><li>base is optional and is 2 by default. Allowed values are 2 (binary), 8 (octal), 10 (decimal) or 16 (hexadecimal). base value is used only if the no constant (width,value) was already defined.</li></ul></div><blockquote><pre class="O2">m.assign(12, ’foo’, `foo_prev + ${m.field(12, 123, 10)}`);</pre></blockquote><div class="O2">gives this Verilog output</div><blockquote><pre class="O2">localparam CONST_12H7B = 12’d123;<br/>wire [11:0] foo;<br/>assign foo = foo_prev + CONST_12H7B;</pre></blockquote></div></div><h3 class="O2" id="newTachl(Tachlv4andhigher)-BasiccombinatorialnewTachlfunctions">Basic combinatorial newTachl functions</h3><h4 id="newTachl(Tachlv4andhigher)-SimpleVerilogassignstatement">Simple Verilog assign statement</h4><blockquote><pre class="O1">m.assign(width, name, net_or_equation);</pre></blockquote><div class="O1">gives this Verilog output</div><blockquote><pre class="O2">wire [width-1:0] name;<br/>assign name = net_or_equation;</pre></blockquote><h4 id="newTachl(Tachlv4andhigher)-Busoperation(busOR,busANDandbusXOR)">Bus operation (bus OR, bus AND and bus XOR)</h4><blockquote><pre class="O1">m.busOr(1, name, net_or_equation);<br/>m.busAnd(1, name, net_or_equation);<br/>m.busXor(1, name, net_or_equation);</pre></blockquote><div class="O1"><div class="O1">gives this Verilog output</div></div><blockquote><pre class="O2">wire name;<br/>assign name = |{ net_or_equation };   // busOr</pre></blockquote><p>or</p><blockquote><pre class="O2">wire name;<br/>assign name = &amp;{ net_or_equation };   // busAnd</pre></blockquote><p>or</p><blockquote><pre class="O2">wire name;<br/>assign name = ^{ net_or_equation };   // busXor</pre></blockquote><div class="O1"><ul><li>Bus operation output is always 1 bit wide</li></ul></div><h4 id="newTachl(Tachlv4andhigher)-Inlinemux">Inline mux</h4><blockquote><pre class="O1">m.mux2(width, name, selector, if_0_net_or_equation, if_1_net_or_equation);</pre></blockquote><div class="O1"><div class="O1">gives this Verilog output</div></div><blockquote><pre class="O2">wire [width-1:0] name;<br/>assign name = selector ? if_1_net_or_equation : if_0_net_or_equation;</pre></blockquote><div class="O2"><ul><li>selector must be a 1 bit wide net</li></ul></div><h4 class="O2" id="newTachl(Tachlv4andhigher)-Netextension(with0)">Net extension (with 0)</h4><div class="O2"><blockquote><pre class="O1">m.extend(width, name, net);</pre></blockquote><div class="O1">gives this Verilog output</div><blockquote><pre class="O2">wire [width-1:0] name;<br/>assign name = { (width-net_width)’b0 , net };</pre></blockquote><div class="O2"><ul><li>net must be known and its width (net_width) and must be &lt;= width</li></ul><h4 class="O2" id="newTachl(Tachlv4andhigher)-Signednetextension(withMSBbit)(sinceTachlv4.0.7)">Signed net extension (with MSB bit) (since Tachl v4.0.7)</h4><blockquote><pre class="O1">m.signExtend(width, name, net);</pre></blockquote><p>gives this Verilog output</p><blockquote><pre class="O2">wire [width-1:0] name;<br/>assign name = { {width-net_width{net[net_width-1]}} , net };</pre></blockquote><ul><li>net must be known and its width (net_width) and must be &lt;= width</li></ul></div><h4 id="newTachl(Tachlv4andhigher)-Netextraction">Net extraction</h4><blockquote><pre class="O1">m.extract(width, name, net, msb1 &lt;, lsb&gt;);            // lsb is optional</pre></blockquote><div class="O1">gives this Verilog output</div><blockquote><pre class="O2">wire [width-1:0] name;<br/>assign name = net[msb1];       // if lsb is not set</pre></blockquote><p>or</p><blockquote><pre class="O2">wire [width-1:0] name;<br/>assign name = net[msb1:lsb];   // if lsb is set</pre></blockquote><div class="O2"><ul><li>net must be known, and its width must be &gt; msb1</li></ul></div><h4 id="newTachl(Tachlv4andhigher)-Netresize">Net resize</h4><blockquote><pre class="O1">m.resize(width, name, net);</pre></blockquote><div class="O1">gives this Verilog output</div><blockquote><pre class="O3">wire [width-1:0] name;<br/>assign name = { (width-net_width)’b0 , net };    // if net_width&lt;width</pre></blockquote><div class="O3">or</div><blockquote><pre class="O3">wire [width-1:0] name;<br/>assign name = net;                               // if net_width==width</pre></blockquote><div class="O3">or</div><blockquote><pre class="O3">wire [width-1:0] name;<br/>assign name = net[width-1:0];                    // if net_width&gt;width</pre></blockquote><h3 class="O3" id="newTachl(Tachlv4andhigher)-SequentialnewTachlfunctions">Sequential newTachl functions</h3><div>Equivalent of dff Tachl function (default reset value is 0 and default enable is 1)</div><blockquote><pre class="O1">m.reg(width, name, equation &lt;, clock, reset&gt;)<br/>m.dff(width, name, equation &lt;, clock, reset&gt;)                               // since Tachl v4.0.7</pre></blockquote><div>Equivalent of dffr Tachl function (default enable is 1)</div><blockquote><pre class="O1">m.regReset(width, name, equation, reset_value &lt;, clock, reset&gt;)<br/>m.dffr(width, name, equation, reset_value &lt;, clock, reset&gt;)                 // since Tachl v4.0.7</pre></blockquote><div>Equivalent of dffe Tachl function (default reset value is 0)</div><blockquote><pre class="O1">m.regEn(width, name, equation, enable &lt;, clock, reset&gt;)<br/>m.dffe(width, name, equation, enable &lt;, clock, reset&gt;)                      // since Tachl v4.0.7</pre></blockquote><div>Equivalent of dffre Tachl function</div><blockquote><pre class="O1">m.regResetEn(width, name, equation, reset_value, enable &lt;, clock, reset&gt;)<br/>m.dffre(width, name, equation, reset_value, enable &lt;, clock, reset&gt;)        // since Tachl v4.0.7</pre></blockquote><div>For those functions, clock and reset are optional.</div></div></div></div></div><div><br/></div><div>Register with Set and Reset command (Since Tachl v4.0.15)</div><blockquote><pre>m.regSR(width, name, regSRObject&lt;, clock, reset&gt;)<br/><br/>where regSRObject is:<br/>{<br/>  set      : setSignalName,                                                   // Size is width<br/>  reset    : resetSignalName,                                                 // Size is width<br/>  prio     : priority                                                         // Should be 'SET' or 'RST'<br/>&lt; enable   : enableNet &gt;                                                      // Optional, size is 1 bit<br/>&lt; resetVal : reset_value &gt;                                                    // Optional, since Tachl v4.0.25<br/>}<br/><br/>equivalent to:<br/>if prio == 'RST'<br/>  m.regReset(width, name, '~resetSignalName &amp; ( setSignalName | name )')<br/>if prio == 'SET<br/>  m.regReset(width, name, 'setSignalName | ( ~resetSignalName &amp; name )')</pre></blockquote><div><br/></div><div><br/></div><div><div class="O2"><h3 id="newTachl(Tachlv4andhigher)-AdvancedcombinatorialnewTachlfunctions">Advanced combinatorial newTachl functions</h3><h4 id="newTachl(Tachlv4andhigher)-Concatenation">Concatenation</h4><div class="O3"><blockquote><pre class="O1">m.cat(width, name, cat_list)</pre></blockquote><ul><li class="O2">cat_list is a list of nets or equations to be concatenated. MSB first.</li><li class="O2">cat_list could be[ net0, net1 , … ] if netX widths are already known.</li><li class="O2">cat_list could be[ [ net0 , width_of_net0 ] , [ equ1 , width_of_equ1 ] , …].</li><li class="O2">cat_list could be a mix of both like[ net0 , [ equ1 , width_of_equ1 ] , …].</li></ul><p class="O2">gives this Verilog output</p><blockquote><pre class="O8">wire [width-1:0] name;<br/>assign name[width-1:width-width_of_net0]                             = net0;<br/>assign name[width-width_of_net0-1:width-width_of_net0-width_of_equ1] = equ1;<br/>...</pre></blockquote><h4 id="newTachl(Tachlv4andhigher)-Split">Split</h4><blockquote><pre class="O1">m.split(width, split_list, net);</pre></blockquote><ul><li class="O2">split_list is a list of nets, destinations of the split. MSB first.</li><li class="O2">split_list could be[ net0, net1 , … ] if netX widths are already known (output ports or with m.addWire()).</li><li class="O2">split_list could be[ [ net0 , width_of_net0 ] , [ net1 , width_of_net1 ] , …].</li><li class="O2">split_list could be a mix of both like[ net0 , [ net1 , width_of_net1 ] , …].</li></ul><p class="O2">gives this Verilog output</p><blockquote><pre class="O2">wire [width_of_net1-1:0] net1;    // net0 is already declared in this example<br/>assign net0 = net[width-1:width-width_of_net0];<br/>assign net1 = net[width-width_of_net0-1:width-width_of_net0-width_of_net1];<br/>...</pre></blockquote><h4 id="newTachl(Tachlv4andhigher)-Replicate">Replicate</h4><blockquote><pre class="O1">m.repl(width, name, net);</pre></blockquote><ul><li class="O2">Replicate net of width net_width to match width.</li><li class="O2">width must be a multiple of net_width (width%net_width==0)</li></ul><div class="O2">gives this Verilog output</div><blockquote><pre class="O2">wire [width-1:0] name;<br/>assign name = { (width/net_with) { net }};</pre></blockquote><h4 id="newTachl(Tachlv4andhigher)-Reverse(sinceTachlv4.0.7)">Reverse (since Tachl v4.0.7)</h4><blockquote><pre>m.reverse(width, name, net);</pre></blockquote><ul><li>Reverse net</li><li>width of nets net and name should be the same (width bits wide)</li></ul><h4 id="newTachl(Tachlv4andhigher)-Or,And,XorandAddoflistofnets">Or, And, Xor and Add of list of nets</h4><blockquote><pre class="O1">m.or(width, name, net_list);<br/>m.and(width, name, net_list);<br/>m.xor(width, name, net_list);<br/>m.add(width, name, net_list);</pre></blockquote><ul><li class="O2">All net in net_list must have the same width</li><li class="O2">net_list is a simple list like [ ’net0’, ’net1’, … , ’netN’ ]</li></ul><p>or this syntax (Since Tachl v4.0.21)</p><blockquote><pre class="O1">m.or(width, name, net0, net1, ... , netN);<br/>m.and(width, name, net0, net1, ... , netN);<br/>m.xor(width, name, net0, net1, ... , netN);<br/>m.add(width, name, net0, net1, ... , netN);</pre></blockquote><div class="O2">gives this Verilog output</div><blockquote><pre class="O2">wire [width-1:0] name;<br/>assign name = net0 | net1 | … | netN;    // or</pre></blockquote><p>or</p><blockquote><pre class="O2">wire [width-1:0] name;<br/>assign name = net0 &amp; net1 &amp; … &amp; netN;    // and</pre></blockquote><p>or</p><blockquote><pre class="O2">wire [width-1:0] name;<br/>assign name = net0 ^ net1 ^ … ^ netN;    // xor</pre></blockquote><p>or</p><blockquote><pre class="O2">wire [width-1:0] name;<br/>assign name = net0 + net1 + … + netN;    // add</pre></blockquote><h4 class="O2" id="newTachl(Tachlv4andhigher)-Subofnets(SinceTachlv4.0.21)">Sub of nets (Since Tachl v4.0.21)</h4><blockquote><pre>m.sub(width, name, net0, net1);</pre></blockquote><ul><li>net0 and net1 must have the same width</li></ul><p>gives this Verilog output</p><blockquote><pre class="O2">wire [width-1:0] name;<br/>assign name = net0 - net1;</pre></blockquote><h4 class="O2" id="newTachl(Tachlv4andhigher)-Invofnet(SinceTachlv4.0.21)">Inv of net (Since Tachl v4.0.21)</h4><blockquote><pre>m.inv(width, name, net);</pre></blockquote><ul><li>net must be width wide</li></ul><p>gives this Verilog output</p><blockquote><pre class="O2">wire [width-1:0] name;<br/>assign name = ~net;</pre></blockquote><h4 class="O2" id="newTachl(Tachlv4andhigher)-Comparisonofnets(SinceTachlv4.0.21)">Comparison of nets (Since Tachl v4.0.21)</h4><blockquote><pre>m.eq(1, name, net0, net1);<br/>m.ne(1, name, net0, net1);<br/>m.ge(1, name, net0, net1);<br/>m.gt(1, name, net0, net1);<br/>m.le(1, name, net0, net1);<br/>m.lt(1, name, net0, net1);</pre></blockquote><ul><li>net0 and net1 must have the same width</li><li>output name is always 1 bit wide</li></ul><p>gives this Verilog output</p><blockquote><pre class="O2">wire [width-1:0] name;<br/>assign name = net0 == net1;    // eq : equal</pre></blockquote><p>or</p><blockquote><pre class="O2">wire [width-1:0] name;<br/>assign name = net0 != net1;    // ne : not equal</pre></blockquote><p>or</p><blockquote><pre class="O2">wire [width-1:0] name;<br/>assign name = net0 &gt;= net1;    // ge : greater or equal</pre></blockquote><p>or</p><blockquote><pre class="O2">wire [width-1:0] name;<br/>assign name = net0 &gt; net1;    // gt : greater than</pre></blockquote><p>or</p><blockquote><pre class="O2">wire [width-1:0] name;<br/>assign name = net0 &lt;= net1;    // le : less or equal</pre></blockquote><p>or</p><blockquote><pre class="O2">wire [width-1:0] name;<br/>assign name = net0 &lt; net1;    // lt : less than</pre></blockquote><h4 class="O2" id="newTachl(Tachlv4andhigher)-Casestatement(mux)">Case statement (mux)</h4><div class="O2"><blockquote><pre class="O1">m.mux(width, name, selector, entry_list);</pre></blockquote><div class="O2"><ul><li>entry_list is a simple list like<br/>[ ’net_if_sel_is_0’, ’net_if_sel_if_1’, … , ’net_if_sel_is_N’ ]<br/>or an object like<br/>{ 0: ’net_if_sel_is_0’ , … , N: ’net_if_sel_is_N’ , null: ’net_for_other_cases’ }</li></ul></div><div class="O2"><ul><li>selector width must be wide enough to cover all the entry_list values.</li></ul></div><div class="O2"><ul><li>All net in entry_list must have the same width.</li></ul></div><div class="O2"><div class="O2">gives this Verilog output</div></div><blockquote><pre class="O2">reg [width-1:0] name;<br/> always @(*)<br/> begin<br/>   case (selector)<br/>     0: name = net_if_sel_is_0;<br/>     …<br/>     N: name = net_if_sel_is_N;<br/>     default: name = net_for_other_cases;<br/>   endcase<br/> end</pre></blockquote><h4 class="O2" id="newTachl(Tachlv4andhigher)-DecodedCasestatement(scanMux)(SinceTachlv4.0.26)">Decoded Case statement (scanMux) (Since Tachl v4.0.26)</h4><blockquote><pre class="O1">m.scanMux(width, name, entry_list);</pre></blockquote><ul><li>entry_list is an object like<br/>{ sel_net_0: ’net_if_sel_net_0’ , … , set_net_N: ’net_if_sel_net_N’ , null: ’net_for_other_cases’ }</li><li>all selector width must be 1 bit wide.</li><li>All net in entry_list must have the same width.</li></ul>gives this Verilog output<blockquote><pre class="O2">reg [width-1:0] name;<br/> always @(*)<br/> begin<br/>   case (1'b1)<br/>     sel_net_0: name = net_if_sel_net_0;<br/>     …<br/>     set_net_N: name = net_if_set_net_N;<br/>     default: name = net_for_other_cases;<br/>   endcase<br/> end</pre></blockquote><h3 id="newTachl(Tachlv4andhigher)-EvolvedcombinatorialnewTachlfunctions">Evolved combinatorial newTachl functions</h3><h4 id="newTachl(Tachlv4andhigher)-Encodefunction">Encode function</h4><blockquote><pre>m.encode(width, name, net &lt;, found&gt;);</pre></blockquote><div class="O1"><ul><li>Useful to get the index of the 1 in a one hot encoded net</li><li>net must be defined and its width must be equal to log2(net_width).</li><li>net must be one hot else the output net name is not relevant.</li><li>found output is the bus OR of input net and is optionnal</li></ul></div><h4 id="newTachl(Tachlv4andhigher)-Decodefunction">Decode function</h4><blockquote><pre>m.decode(width, name, net);</pre></blockquote><div class="O1"><ul><li>Useful to get a bus where the bit at index net is set to 1.</li><li>Equivalent to 1&lt;&lt;net.</li><li>net must be defined.</li><li>Output net name could be larger or smaller than the 2net_width, this function automatically resizes the output net name to width.</li></ul><h4 id="newTachl(Tachlv4andhigher)-ScanLsb/ScanMsbfunctions">ScanLsb/ScanMsb functions</h4><blockquote><pre>m.scanLsb(width, name, net &lt;, enable, found&gt;);<br/>m.scanMsb(width, name, net &lt;, enable, found&gt;);</pre></blockquote><ul><li>Useful to get a one hot net where the 1 is the first one found from LSB or MSB</li><li>net must be defined and its width must be equal to width</li><li>enable input is optionnal. Considered as 1 if undefined</li><li>found output is the bus OR of input net and is optionnal</li></ul><h4 id="newTachl(Tachlv4andhigher)-PopCountfunction(SinceTachlv4.0.21)">PopCount function (Since Tachl v4.0.21)</h4><blockquote><pre>m.popCount(width, name, net);</pre></blockquote><ul><li>Useful to get the number of bits set to 1 in net.</li><li>net must be defined.</li><li>Output net name width must be log2(width_of_net + 1).</li></ul><h3 id="newTachl(Tachlv4andhigher)-SpecialnewTachlfunctions">Special newTachl functions</h3><h4 id="newTachl(Tachlv4andhigher)-SimpleInstantiation">Simple Instantiation</h4><div>One common function to instantiate both Tachl module and newTachl module</div><h5 class="O1" id="newTachl(Tachlv4andhigher)-InstantiatefororiginalTachlmodule">Instantiate for original Tachl module</h5><blockquote><pre class="O2">m.instantiate({ instance_object });</pre></blockquote><div class="O2"><ul><li>Same function as Tachl instance function</li><li>instance_object has the same structure as the Tachl one.</li></ul></div><h5 class="O1" id="newTachl(Tachlv4andhigher)-InstantiatefornewTachlmodule">Instantiate for newTachl module</h5><blockquote><pre class="O2">m.instantiate({ instance_object });</pre></blockquote><ul><li class="O2">Improved instantiation function which adds checking on ports and parameters</li><li class="O2">Add auto-declaration of nets connected to output ports</li><li class="O2">instance_object has the same structures as the Tachl one except it doesn’t support verilogParams entry and the direction field in the interface is not necessary (the direction is auto-discovered on the sub-module).</li></ul><h4 class="O2" id="newTachl(Tachlv4andhigher)-Multipleinstantiation">Multiple instantiation</h4><blockquote><pre class="O2">m.nInstance(instanceObj);</pre></blockquote><p class="O2">m.nInstance function has the same semantic as the original Tachl nInstance function</p><h4 class="O2" id="newTachl(Tachlv4andhigher)-FiniteStateMachine">Finite State Machine</h4><p class="O2">A function to simplify write of a State Machine</p><blockquote><pre class="O1">m.fsm({<br/>   enum_name   : ’enum_state_name’,   // name of the enumerate type<br/>   state       : ’state_name’,<br/>   next_state  : ’next_state_name’,<br/>   enable      : ’enable_name’,       // optional, default is 1<br/>   encoding    : ’encoding_name’,     // optional, default is ’binary’. Same encoding as m.addEnum<br/>   transitions : {<br/>     ’STATE0’ : {<br/>       ’STATE1’ : condition_from_STATE0_to_STATE1_net_or_equation,<br/>       ’STATE2’ : condition_from_STATE0_to_STATE2_net_or_equation,<br/>       ’STATE0’ : null<br/>     },<br/>     ’STATE1’ : ’STATE2’,             // unconditional transition<br/>     ’STATE2’ : {<br/>       ’STATE0’ : condition_from_STATE2_to_STATE1_net_or_equation,<br/>       ’STATE2’ : null<br/>     }<br/>   },<br/>   reset_state : ’reset_state_name’   // optional, must be in transitions. Default is the 1st state.<br/> };</pre></blockquote><p>Like the addEnum function, fsm function return the width of the enumerated value (new in Tachl version 4.0.4).</p><h4 class="O1" id="newTachl(Tachlv4andhigher)-NativeVerilogCode">Native Verilog Code</h4><div>Because it could be useful to directly add Verilog/System-Verilog code in the output file, an “AsIs” function is implemented.</div><div><ul><li>No check is done on what it is written inside.</li></ul></div><div><ul><li>Essentially used to implement SVA (System-Verilog Assertions).</li></ul></div><blockquote><pre>m.asIs(condition, verilog_string_lst);</pre></blockquote><ul><li class="O1">condition is a JS Boolean</li><li class="O1">verilog_string_lst is, as the name said, a list of Verilog/System-Verilog strings to dump inside the output file if condition is true. Each list string is printed in a new line</li></ul><h4 id="newTachl(Tachlv4andhigher)-HeaderComment(SinceTachlv4.0.15)">Header Comment (Since Tachl v4.0.15)</h4><p>Because it could be useful to add a header comment on the top of the exported verilog file, a &quot;header&quot; function is implemented</p><blockquote><pre>m.header(comment_string_lst);</pre></blockquote><ul><li class="O1">This function should be placed before the interface function.</li><li class="O1">Only one header function called is allowed per file</li><li class="O1">comment_string_lst is, as the name said, a list of comments strings to dump inside the output file. Each element is prepend with the Verilog comment symbol (&quot;//&quot; and printed in a new line</li></ul><h4 id="newTachl(Tachlv4andhigher)-DesignComment(SinceTachlv4.0.15)">Design Comment (Since Tachl v4.0.15)</h4><p>Because it could be useful to add some comments in the exported verilog file, a &quot;comment&quot; function is implemented</p><blockquote><pre>m.comment(comment_string_lst);</pre></blockquote><ul><li class="O1">comment_string_lst is, as the name said, a list of comment strings to dump inside the output file. Each element is prepend with the Verilog comment symbol (&quot;//&quot; and printed in a new line</li></ul><p><br/></p></div></div></div></div></div>