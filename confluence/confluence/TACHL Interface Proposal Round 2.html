<ol><li>Interfaces are defined as an object that is passed parameters.<ol><li>The parameters must be such that they can be described in a CPR definition.</li></ol></li><li>There is a root class from which all interfaces are derived.</li><li>The root class contains the following methods:<br/><ol><li>getSignals - returns a list of the signals minus the prefixed name.</li><li>getName - returns the name used to prefix a set of signals.</li></ol></li><li>The new TACHL instance function will be passed an array of rendered interfaces that have been generated from getFullSignals.</li><li>The names generated are controlled by how the interface instances are passed to getFullSignals.<ol><li>If you want a hierarchical name (a hierarchical interface like AXI) you pass in a hierarchical object.</li><li>If you want a flat name you only pass in one object.</li></ol></li><li>The instance call and the module port generation must match when they are generating the ports.</li><li>There must be a method by which to change the name of an interface at an instance boundary.<ol><li>Local name refers to the name of the interface in the module where the block is instanced.</li><li>Module name refers to theme of the interface inside the instance module.</li><li>The local name can't affect the parameters passed to generate the instanced module.</li></ol></li></ol><h1 id="TACHLInterfaceProposalRound2-ImplementationDetails:">Implementation Details:</h1><h2 id="TACHLInterfaceProposalRound2-LongTerm:">Long Term:</h2><ol><li>Root class is contained in a centralized location</li><li>Derived classes are described in the CPR definition and are extracted into a shared library.</li></ol><h2 id="TACHLInterfaceProposalRound2-ShortTerm:">Short Term:</h2><ol><li>The root class can be multiply defined in the javascript libraries the need it.</li><li>The derived classes will exist in the Area javascript libraries.</li><li>CPR for interfaces will describe the parameters passed to an interface instance.</li></ol><h1 id="TACHLInterfaceProposalRound2-DataStructure:">Data Structure:</h1><p>Base Object:</p><pre>class interfaceBase {</pre><pre>  constructor(params) {</pre><pre>    const defaultParamet = {};</pre><pre>    this.resSignals = {};</pre><pre>    this.residuulExcludes = [];</pre><pre>    this.params = params || defaultParams;</pre><pre>  } _bitBlast(elem) {} </pre><pre>  getFullSignals(params) {} </pre><pre>  getSignals(params) {}</pre><pre>  getName(params) {} </pre><pre>  setParam() {} </pre><pre>  exclude(name) {} </pre><pre>  include(name) {}</pre><pre>}</pre><p> </p><p>Derived Object:</p><pre>class interfaceATP extends interfaceBase {</pre><pre>  _signalTemplate(params){ </pre><pre>    return[</pre><pre>      {name: 'valid', type: 'logic', dir: 'm_in', excludable: false, width: 1},</pre><pre>      {name: 'ready', type: 'logic', dir: 'm_out', excludable: false, width: 1},</pre><pre>      {name: 'bus', type: 'logic', dir: 'm_in', excludable: false, width: params.width},</pre><pre>      {name: 'prot', type: 'logic', dir: 'm_in', excludable: true, width: params.prot_width}</pre><pre>    ];</pre><pre>  }</pre><pre>} </pre><pre>class interfaceAXIar extends interfaceBase { </pre><pre>  _signalTemplate(params)</pre><pre>    {return[</pre><pre>      {name: valid, type: 'logic', dir 'm_out', excludable: false, width: 1},</pre><pre>      {name: ready, type: 'logic', dir 'm_in', excludable: false, width: 1},</pre><pre>      {name: id, type: 'logic', dir 'm_out', excludable: false, width: params.idWidth},</pre><pre>      {name: addr, type: 'logic', dir 'm_out', excludable: false, width: params.addrWidth},</pre><pre>      {name: len, type: 'logic', dir 'm_out', excludable: false, width: params.lenWidth},</pre><pre>      {name: size, type: 'logic', dir 'm_out', excludable: false, width: params.sizeWidth},</pre><pre>      {name: burst, type: 'logic', dir 'm_out', excludable: false, width: 2}</pre><pre>    ]</pre><pre>  }</pre><pre>} </pre><pre>class interfaceAXIr extends interfaceBase { </pre><pre>  _signalTemplate(params)</pre><pre>    {return[</pre><pre>      {name: valid, type: 'logic', dir 'm_out', excludable: false, width: 1},</pre><pre>      {name: ready, type: 'logic', dir 'm_in', excludable: false, width: 1},</pre><pre>      {name: id, type: 'logic', dir 'm_out', excludable: false, width: params.idWidth},</pre><pre>      {name: data, type: 'logic', dir 'm_out', excludable: false, width: params.addrData},</pre><pre>      {name: resp, type: 'logic', dir 'm_out', excludable: false, width: params.respWidth},</pre><pre>      {name: last, type: 'logic', dir 'm_out', excludable: false, width: 1}</pre><pre>    ]</pre><pre>  }</pre><pre>} </pre><pre>class interfaceAXIaw extends interfaceBase { </pre><pre>  _signalTemplate(params)</pre><pre>    {return[</pre><pre>      {name: valid, type: 'logic', dir 'm_out', excludable: false, width: 1},</pre><pre>      {name: ready, type: 'logic', dir 'm_in', excludable: false, width: 1},</pre><pre>      {name: id, type: 'logic', dir 'm_out', excludable: false, width: params.idWidth},</pre><pre>      {name: addr, type: 'logic', dir 'm_out', excludable: false, width: params.addrWidth},</pre><pre>      {name: len, type: 'logic', dir 'm_out', excludable: false, width: params.lenWidth},</pre><pre>      {name: size, type: 'logic', dir 'm_out', excludable: false, width: params.sizeWidth},</pre><pre>      {name: burst, type: 'logic', dir 'm_out', excludable: false, width: 2}</pre><pre>    ]</pre><pre>  }</pre><pre>} </pre><div><pre>class interfaceAXIw extends interfaceBase { </pre><pre>  _signalTemplate(params)</pre><pre>    {return[</pre><pre>      {name: valid, type: 'logic', dir 'm_out', excludable: false, width: 1},</pre><pre>      {name: ready, type: 'logic', dir 'm_in', excludable: false, width: 1},</pre><pre>      {name: id, type: 'logic', dir 'm_out', excludable: false, width: params.idWidth},</pre><pre>      {name: data, type: 'logic', dir 'm_out', excludable: false, width: params.addrData},</pre><pre>      {name: strb, type: 'logic', dir 'm_out', excludable: false, width: params.strbWidth},</pre><pre>      {name: last, type: 'logic', dir 'm_out', excludable: false, width: 1}</pre><pre>    ]</pre><pre>  }</pre><pre>} </pre><div><pre>class interfaceAXIb extends interfaceBase { </pre><pre>  _signalTemplate(params)</pre><pre>    {return[</pre><pre>      {name: valid, type: 'logic', dir 'm_out', excludable: false, width: 1},</pre><pre>      {name: ready, type: 'logic', dir 'm_in', excludable: false, width: 1},</pre><pre>      {name: id, type: 'logic', dir 'm_out', excludable: false, width: params.idWidth},</pre><pre>      {name: resp, type: 'logic', dir 'm_out', excludable: false, width: params.respwidth}</pre><pre>    ]</pre><pre>  }</pre><pre>} </pre></div></div><pre>class interfaceAXI extends interfaceBase {</pre><pre>  _signalTemplate(params) {</pre><pre>    return[</pre><pre>      {name: ar_, type: 'interface', dir: &quot;master&quot;, excludable: true] def: newInterfaceAXIar(), params: params},</pre><pre>      {name: r_, type: 'interface', dir: &quot;slave&quot;, excludable: true] def: newInterfaceAXIr(), params: params},</pre><pre>      {name: aw_, type: 'interface', dir: &quot;master&quot;, excludable: true] def: newInterfaceAXIaw(), params: params},</pre><pre>      {name: w_, type: 'interface', dir: &quot;master&quot;, excludable: true] def: newInterfaceAXIw(), params: params},</pre><pre>      {name: b_, type: 'interface', dir: &quot;slave&quot;, excludable: true] def: newInterfaceAXIb(), params: params},</pre><pre>   ];</pre><pre>  }</pre><pre>}</pre><h1 id="TACHLInterfaceProposalRound2-Example:">Example:</h1><p>parameters passed to module:</p><pre>var in_params = {width: 56, prot_width: 0}; </pre><pre>var out_params = in_params;</pre><pre>var switch_params = {</pre><pre>  myIOObj: {</pre><pre>    interfaces: {</pre><pre>      'in':[</pre><pre>        {name: 'i0_', params: in_params, interface: obj.userlib.interfaceATP},</pre><pre>        {name: 'i1_', params: in_params, interface: obj.userlib.interfaceATP},</pre><pre>        {name: 'i2_', params: in_params, interface: obj.userlib.interfaceATP}], </pre><pre>      'out':[</pre><pre>        {name: 'o0_', params: in_params, interface: obj.userlib.interfaceATP},</pre><pre>        {name: 'o0_', params: in_params, interface: obj.userlib.interfaceATP},</pre><pre>        {name: 'o0_', params: in_params, interface: obj.userlib.interfaceATP},</pre><pre>        {name: 'o0_', params: in_params, interface: obj.userlib.interfaceATP}]}}; </pre><pre>var inst_interface = []; </pre><pre>var my_interface = {};</pre><pre>for (ii = 0; ii &lt; switch_params.myIOOjb.in.length, ii++) {</pre><pre>  inst_interface[ii] = {}, </pre><pre>  inst_interface[ii].localName = 'inst_0_'+switch_params.myIOObj.interfaces.in[ii].name; // Adding the local name so it doesn't affect sym_switch params</pre><pre>  inst_interface[ii].moduleName = switch_params.myIOObj.interfaces.in[ii].name; </pre><pre>  inst_interfaces[ii].signals = switch_params.myIOObj.interface.in[ii].interface.getSignals(switch_params.myIOObj.interface.in[ii].params);</pre><pre>} for (ii = switch_params.myIOOjbs.in.length; ii &lt;  switch_params.myIOOjb.interfaces.out.length, ii++) { </pre><pre>  my_interface = {};</pre><pre>  my_interface.localname = 'inst_0_'+switch_params.myIOObj.interface.out[ii].name; // Adding the local name so it doesn't affect sym_switch params</pre><pre>  my_interface.moduleName = switch_params.myIOObj.interface.out[ii].name; </pre><pre>  my_interface.signals = switch_params.myIOojbs.interface.out[ii].interface.getSignals(switch_params.myIOObj.interface.out[ii].params); </pre><pre>  inst_interfaces.push(my_interfaces);</pre><pre>} </pre><pre>\=obj.lib.nInstance({</pre><pre>  instanceName: 'inst_0',</pre><pre>  moduleName: 'sym_switch',</pre><pre>  params: switch_params, </pre><pre>  interfaces: inst_interfaces})=\;</pre><p> </p><p>In the code for sym_switch:</p><pre>for (ii = 0; ii &lt; myIOObj.interfaces.in.length; ii++) {obj.lib.nInterface(myIOObj.interfaces.in[ii],'slave');}</pre><pre>for (ii = 0; ii &lt; myIOObj.interfaces.out.length; ii++) {obj.lib.nInterface(myIOObj.interfaces.out[ii],'master');} </pre><pre> </pre><pre>module \=obj.lib.getModuleName()=\ (\=obj.lib.getPorts=\); </pre><pre>endmodule</pre><pre> </pre><p>Parameters passed to module:</p><pre>var axi_params = {dataWidth: 256, addrWidth: 16, idWidth: 4, respWidth: 2, lenwidth: 4, sizeWidth: 3, strbWidth: 32}; </pre><pre>var block_params = { myIOObj: {interfaces: {axiInt: {name: 'axi_', params: axi_params, interface: obj.user.interfaceAXI}}}}; </pre><pre>\=obj.lib.nInstance({</pre><pre>  instanceName: 'U_0', </pre><pre>  moduleName: 'someBlock', </pre><pre>  params: block_params, </pre><pre>  interfaces [{</pre><pre>    local_name: block_params.myIOObj.interfaces.axiInt.name, </pre><pre>    moduleName: block_params.myIOObj.interfaces.axiInt.name,</pre><pre>    signals: block_params.myIOObj.interfaces.axiInt.interface.getSignals(block_params.myIOObj.interfaces.axiInt.params)}]</pre><pre>})=\ </pre><p> </p><p>In the code for someBlock:</p><pre>obj.lib.nInterface(myIOObj.interfaces.axiInt, 'master');</pre><pre>module \=obj.lib.getModuleName()=\ (\=obj.lib.getPorts=\); </pre><pre>endmodule</pre><pre> </pre>