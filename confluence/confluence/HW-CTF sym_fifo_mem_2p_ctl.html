<h1 id="HW-CTFsym_fifo_mem_2p_ctl-module_name"><strong>module_name</strong></h1><p>sym_fifo_mem_2p_ctl</p><h1 id="HW-CTFsym_fifo_mem_2p_ctl-parameters"><strong>parameters</strong></h1><h2 id="HW-CTFsym_fifo_mem_2p_ctl-java_script:"><strong>java_script:</strong></h2><pre class="page view">{
	&quot;width&quot; : any positive integer <br/>        &quot;depth&quot; : any positive integer 4 or greater <br/>        &quot;protectionStyle&quot; : protectionStyle, <br/>        &quot;protectionInterface&quot; : protectionInterface</pre><pre>}</pre><h2 id="HW-CTFsym_fifo_mem_2p_ctl-verilog:"><strong>verilog:</strong></h2><p style="margin-left: 30.0px;">none.</p><h1 id="HW-CTFsym_fifo_mem_2p_ctl-I/O"><strong>I/O</strong></h1><p>u.port('input', 'in_valid', 1);<br/>u.port('output', 'in_ready', 1);<br/>u.port('output', 'out_valid', 1);<br/>u.port('input', 'out_ready', 1);</p><p>// Ports to read buffer<br/>// A rdy_vld_pipe, depth = 2, pF = false, pB = true, exposeValids = true<br/>u.port('input', 'pipe_out_valid', 1);<br/>u.port('output', 'pipe_out_ready', 1);<br/>u.port('output', 'pipe_in_valid', 1);<br/>u.port('input', 'pipe_in_ready', 1);</p><p>// Ports to SRAM<br/>u.port('output', 'wt_sel', 1);<br/>u.port('output', 'wt_addr', addr_width);<br/>u.port('output', 'rd_sel', 1);<br/>u.port('output', 'rd_addr', addr_width);</p><p>// Ports to data mux<br/>u.port('output', 'empty', 1); // The SRAM and external pipe is empty.<br/><br/>u.interface(protectionInterface.name, 'master', protectionInterface.signal); </p><h1 id="HW-CTFsym_fifo_mem_2p_ctl-ModulesUsed"><strong>Modules Used</strong></h1><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16163252/prot_reg" data-linked-resource-id="16163252" data-linked-resource-version="4" data-linked-resource-type="page">prot_reg</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16155739/logic_tree" data-linked-resource-id="16155739" data-linked-resource-version="15" data-linked-resource-type="page">logic_tree</a></p><h1 id="HW-CTFsym_fifo_mem_2p_ctl-Description"><strong>Description</strong></h1><p>The block diagram for <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156391/HW-CTF+sym_fifo_mem_2p" data-linked-resource-id="16156391" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF sym_fifo_mem_2p</a>, which this block is used in, is shown below:</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16156403/sym_fifo_mem_2p_ctl.svg?api=v2"></span></p><p>The control logic to turn a separate read/write port SRAM into a FIFO using ready and valids.</p><p>There are the following internal registers:</p><p style="margin-left: 30.0px;">wt_addr: The write pointer for a circular FIFO<br/>rd_addr: The read pointed for a circular FIFO<br/>wrap: When asserted and wt_addr = rd_addr indicates FIFO is full. When deserted and wt_addr = rd_addr FIFO is empty.<br/>rd_sel_p: Indicates a read was issued on the previous cycle</p><p>These registers are actually stored in one register in the following order: </p><p style="margin-left: 30.0px;">{wrap,rd_sel_p,wt_addr,rd_addr} </p><p>This is done so the protection can be automatically generated using the prot_reg in the most efficient manner possible.</p><p>Internally there are the following wires:</p><p style="margin-left: 30.0px;">wire int_empty; // The SRAM is empty<br/>wire equal; // rd_addr equals wt_addr<br/>wire next_equal; // next_rd_addr equals next_wt_addr<br/>wire full; // The SRAM is full<br/>wire wrap; // The pointers have wrapped<br/>wire next_wrap; // The next fall of wrap<br/>wire [\=addr_width-1=\:0] next_wt_addr; // The next value of the write pointer<br/>wire [\=addr_width-1=\:0] next_rd_addr; // The next value of the read pointed<br/>wire rd_sel_p; // The previous value of rd_sel, meaning a read happened on the previous cycle<br/>wire [\=state_width-1=\:0] state; // The output state of the register<br/>wire [\=state_width-1=\:0] next_state; // The next state of the register</p><p>The loading and unloading of the single register:</p><p style="margin-left: 30.0px;">assign next_state[\=state_width-1=\] = next_wrap;<br/>assign next_state[\=state_width-2=\] = rd_sel;<br/>assign next_state[\=2*addr_width-1=\:\=addr_width=\] = next_wt_addr;<br/>assign next_state[\=addr_width-1=\:0] = next_rd_addr;</p><p style="margin-left: 30.0px;">assign wrap = state[\=state_width-1=\];<br/>assign rd_sel_p = state[\=state_width-2=\];<br/>assign wt_addr = state[\=2*addr_width-1=\:\=addr_width=\];<br/>assign rd_addr = state[\=addr_width-1=\:0];</p><p>The logic_tree block is used twice to calculate equal and next_equal. The two pointers are exclusive NORed, the resulting bits are ORed using the logic_tree module, and the output for the OR tree is whether the two pointers are equal or not.</p><p>Here are the logic equations with descriptions of what they are doing:</p><p style="margin-left: 30.0px;">assign full = equal &amp; wrap;</p><p>If pointers have wrapped, and the pointers are equal, the SRAM FIFO is full. Could just use the wrap bit alone if timing becomes and issue.</p><p style="margin-left: 30.0px;">assign empty = equal &amp; ~wrap &amp; ~pipe_out_valid;</p><p>These is the empty for the entire sym_fifo_mem_2p, so it includes if there is something in the external pipe outside the SRAM. The external pipe is used to maintain throughput from the SRAM FIFO.</p><p style="margin-left: 30.0px;">assign int_empty = equal &amp; ~wrap;</p><p>If the pointers have not wrapped and are equal, then the SRAM FIFO is empty.</p><p style="margin-left: 30.0px;">assign wt_sel = in_valid &amp; ((~empty &amp; ~full) | (~full &amp; ~out_ready));</p><p>The SRAM FIFO is written if there's an input coming in and the block is not empty (not int_empty) and not full or the block is not full and output doesn't have a ready. I don't want to write the SRAM if the SRAM FIFO is empty, the external pipe is empty and the output is ready. In that case, the data is routed around the internal storage and straight to the output. This is what makes the block pipeForward equals false.</p><p style="margin-left: 30.0px;">assign in_ready = ~full;</p><p>The block can't accept data if the SRAM FIFO is full. This is what makes the block pipeBackward equals true. The reason for doing this is most SRAMs can't read and write the same word in the same cycle, so the logic prevents that from happening.</p><p style="margin-left: 30.0px;">assign out_valid = pipe_out_valid | empty &amp; in_valid;</p><p>The block asserts out_valid if the pipe has data in it, or the entire block is empty and there is an in_valid. Because the block wants to forward data if it's empty, valid can be asserted in this case.</p><p style="margin-left: 30.0px;">assign pipe_out_ready = ~empty &amp; out_ready;</p><p>The controls the internal pipe by filtering it's output ready and input valid. The logic makes no assumptions about the depth of the pipe and how the pipeForward and pipeBackward parameters on the pipe are configured. If the pipe has data in it, it can be read out if out_ready is asserted. If the block is not empty, there is either data in the FIFO, data in the external pipe, or data in both. If the external pipe has no data, it won't be asserted valid, and so the block doesn't need to filter empty based on the external pipes state.</p><p style="margin-left: 30.0px;">assign pipe_in_valid = rd_sel_p;</p><p>If the block did a read on SRAM on the previous cycle, then the external pipe needs to suck in data this cycle.</p><p style="margin-left: 30.0px;">assign rd_sel = ~int_empty &amp; (~pipe_in_valid &amp; pipe_in_ready | ~pipe_in_valid &amp; out_ready | pipe_in_valid &amp; out_ready);</p><p>If there's data in the SRAM FIFO, The block can't issue a read if the external pipe is full and there is no ready on the output, otherwise it can.</p><p style="margin-left: 30.0px;">assign next_wt_addr = wt_sel ? ((wt_addr == \=addr_width=\'d\=depth-1=\) ? \=addr_width=\'b0 : wt_addr + 1'b1) : wt_addr;</p><p>If a write is happening, then increment the write pointer.</p><p>assign next_rd_addr = rd_sel ? ((rd_addr == \=addr_width=\'d\=depth-1=\) ? \=addr_width=\'b0 : rd_addr + 1'b1) : rd_addr;</p><p>If a read is happening, then increment the read pointer.</p><p style="margin-left: 30.0px;">assign next_wrap = (~wrap &amp; wt_sel &amp; ~rd_sel &amp; next_equal) | (wrap &amp; (~rd_sel | (wt_sel &amp; rd_sel)));</p><p>If the SRAM FIFO is not going to be empty next cycle, and a write is happening, but not a read and the counters are going to be equal next cycle, a wrap will occur and the SRAM FIFO will be full.</p><p><br/></p>