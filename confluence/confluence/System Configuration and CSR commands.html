<h2 id="SystemConfigurationandCSRcommands-NamingconventioninHierarchicalSystem."><style>[data-colorid=e5jwe7b6b1]{color:#333333} html[data-color-mode=dark] [data-colorid=e5jwe7b6b1]{color:#cccccc}[data-colorid=psarf3se4s]{color:#333333} html[data-color-mode=dark] [data-colorid=psarf3se4s]{color:#cccccc}[data-colorid=s5k2t1wunw]{color:#333333} html[data-color-mode=dark] [data-colorid=s5k2t1wunw]{color:#cccccc}[data-colorid=buyb0k0v1u]{color:#333333} html[data-color-mode=dark] [data-colorid=buyb0k0v1u]{color:#cccccc}</style><br />Naming convention in Hierarchical System.</h2><div><br />In order to assign a value to a particular parameter in the system we need to have a way how to specify that parameter. One of the common ways to refer to the parameter is to use a fully qualified name consisting of submodule instance names, i.e.</div><div><br />top.module1.module2.param</div><div>the name could be global or relative - similar to file naming approach in the file system.</div><div>Name starting with &ldquo;.&rdquo; is a relative name, otherwise it is a global name. Each module has a set of submodules - ports, csr blocks and etc.&nbsp;</div><div><span data-colorid="s5k2t1wunw" style="text-decoration: none;">Beside the&nbsp; &quot;real&quot; modules we will have a &quot;pseudo&quot; module(s). Sim modules will have parameters relevant to entire simulation.&nbsp;</span></div><div>The names for the module parameters are defined by the model developers. The names need to be consistent with the specification.</div><h2 id="SystemConfigurationandCSRcommands-Systeminstantiation.">System instantiation.&nbsp;</h2><p>&nbsp;</p><div>Each unit model has to comply with API in order to do the inquiry and <span data-colorid="e5jwe7b6b1" style="text-decoration: none;">assign </span>the model parameters by name. Each unit model has to verity the value and the type for every parameter that could be changed by the user. To travers the system hierarchy we will have a wrapper object for every model module to be derived from common base class. Beside the parameters the wrapper object will collect the topology information from the tcl config file, we have to bind each output port to an input port in connected module. The parameters are collected in key-value string pairs, the validity of the parameters has to be verified during model instantiation.&nbsp;</div><div>The system model instantiation is a two step process - first we instantiate the wrapper hierarchy, collect all config and topology parameters and only after that instantiate the model modules and later bind the connections between the modules by exchanging the port interfaces.&nbsp;</div><div><span data-colorid="psarf3se4s" style="text-decoration: none;">When we instantiate the model for the entire system - we execute the commands from&nbsp; the tcl configuration file, instantiate wrapper objects for each module, check parameters, then we instantiate each module based on the set of parameters collected in the corresponding wrapped object, then we bind/connect the modules based on topology info. </span></div><h2 id="SystemConfigurationandCSRcommands-Commands."><br />Commands.&nbsp;</h2><p>&nbsp;</p><div>To navigate&nbsp;<span data-colorid="buyb0k0v1u" style="text-decoration: none;">through the system hierarchy</span> In tcl interpreter we need to add a few commands&nbsp;</div><div><br />list, select, assign.</div><h2 id="SystemConfigurationandCSRcommands-list">list</h2><p><br />- show the names/params in the module hierarchy</p><div>List [ <a class="external-link" href="http://module.name" rel="nofollow">module.name</a> | <a class="external-link" href="http://module.name" rel="nofollow">module.name</a>.param ]</div><div>i.e.</div><div>&gt; list</div><div>aiu0<br />aiu1<br />dce0<br />dce1<br />ncb0<br />ncb1<br />dmi0<br />dmi1<br />flexnoc0<br />coda0<br />sim</div><div><br />or <br />&gt; list coda0<br />nsets 1024<br />nways 16<br />scratch_pad_base_address 0x0<br />..</div><div>&gt; list flexnoc0.switch0.port0<br />width 128<br />..</div><div><br />inspect param value</div><div>list &lt;sub_module_name&gt;.&lt;param_name&gt;</div><div>i.e.<br />&gt; list ncb0.stt_size<br />8</div><h2 id="SystemConfigurationandCSRcommands-select&lt;instance_name>"><br />select &lt;instance_name&gt;</h2><p>&nbsp;</p><div>- select module instance name,</div><div>there is only one name that could be selected at any given time.&nbsp;</div><div>A newly selected name will overwrite previously selected name.&nbsp;</div><div>Relative name will use the selected name to construct a fully qualified name.&nbsp;</div><div>select [ instance_name ]</div><div>i.e. <br />&gt; select ncb0<br />&gt; list<br />ott_size 24</div><div><div>stt_size 12<br />nsets&nbsp; 128<br />nways&nbsp; 8<br />...</div><div><br />or <br />&gt; select flexnoc0.switch0<br />&gt; list<br />...</div><h2 id="SystemConfigurationandCSRcommands-assignparamvalue"><br />assign param value</h2><p>&nbsp;</p><div>assign &lt;sub_module_name&gt;.&lt;param_name&gt; &lt;value&gt;</div><div>i.e. <br />&gt; assign coda0.scratch_pad_base_address 0x1000</div><div><br />For simulation param we can use the same approach<br />Example of using a pseudo-module</div><div>&gt; list sim<br />ncycles 10000<br />debug_level 0<br />..</div><div>&gt; assign sim.debug_level 3</div></div><h1 id="SystemConfigurationandCSRcommands-NotesfromPerformanceModelTeamMeetingon11/26">Notes from Performance Model Team Meeting on 11/26</h1><p>Abhinav suggested the following, which can be used with an additional port on Ncore at the system level:</p><p>&nbsp;</p><p>Have a module that is basically a address map to value in a hash. Each Ncore unit will always look up this module to get register values. This module will intercept address writes and update its hash table values. That way everything is in sync. Need to come up with a way to describe the address map.</p>