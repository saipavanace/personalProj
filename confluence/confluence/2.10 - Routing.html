<p>Symphony interconnects work by transporting messages, in the form of packets, from senders to receivers across a fabric. The process of choosing a way from a sender to a receiver across the fabric is called <strong><em>routing</em></strong>.</p><p>Symphony implements <strong>static source routing</strong>. This means that, at the sender, a packet's destination is determined, and a corresponding route is chosen and stored inside the packet header. At every possible bifurcation inside the fabric, the switches retrieve from the route field in the packet header the next predetermined intermediate step (called <em>hop</em>), and ensure that the packet is sent in that direction. If the fabric has virtual channels enabled, the route also specifies which virtual channel to take at every hop. Eventually, the packet is routed to its final destination. If a response is required, the destination extracts from the packet header a field that encodes a source ID; when the response is ready to be sent, the source ID is used to determine the return route, and the same routing process is performed until the response packet reaches back. Note that the route taken by the response is independent from that taken by the request; they may be symmetrical or not, and they may be over the same fabric or over separate fabrics.</p><p>The diag should be simplified. The current dia displays too much of proprietary stuff.</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="https://arterisip.atlassian.net/wiki/download/attachments/16169668/image2019-11-8%2014:35:43.png?api=v2"></span>Routing across a Symphony fabric</p><p>Symphony defines a single route between any two endpoints, that cannot be modified at runtime. This ensures predictable performance as well as the ability to verify that deadlocks and livelocks will not occur. However, this means that the routes must be chosen carefully in view of congestion effects, and that appropriate resource provisions must be made in the fabric (e.g. number of physical and virtual channels, buffer depths), to ensure that the desired performance level is attained.</p><p>The implementation of source routing relies on tables that are implemented in each ATU. Since these tables are fully static, they are efficiently implemented as gates (as opposed to registers) at the circuit level, minimizing area and critical paths. There is, however, a difference between the implementation of the tables at the initiator and target sides of the fabric:</p><ul><li>At the initiator side, the routing tables map an address (as requested by an initiator transaction) into a route.</li><li>At the target side, the routing tables map a destination ID (as carried by the incoming request packet) into a route.</li></ul><p>In other words, the initiator's routing table is determined with awareness of the system's memory map, and multiple non-contiguous address ranges could result in an identical route towards the same destination. The target-side routing table encodes a simpler one-to-one correspondence between an ID and a route.</p><p> </p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="150" src="https://arterisip.atlassian.net/wiki/download/attachments/16169668/image2019-11-8%2014:34:34.png?api=v2"></span>Initiator-side routing table</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="150" src="https://arterisip.atlassian.net/wiki/download/attachments/16169668/image2019-11-8%2014:35:8.png?api=v2"></span>Target-side routing table</p><p>The dia about the routes should be removed</p><p>Note that since the packet format is constant across a fabric, the route field of the packet header contains a fixed (within a fabric) number of bits, regardless of which sender-receiver pair is exchanging that packet. A consequence of that is that the route field for the whole fabric must be sized to hold the binary encoding of the longest route across that fabric. As a first approximation, this is proportional to the number of hops traversed by the geometrically-longest route, although to compute the encoding, the radix (number of output ports) and the number of virtual channels in every switch also matters. The necessary calculations are performed by Maestro.</p><p>The user does not need to manually specify the routing tables; they are automatically calculated by Maestro based on higher-level inputs, i.e. the connectivity table, the set of end-to-end routes, and the system memory map.</p>