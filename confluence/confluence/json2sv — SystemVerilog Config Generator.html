<style type="text/css">/*<![CDATA[*/
div.rbtoc1759726175717 {padding: 0px;}
div.rbtoc1759726175717 ul {list-style: circle;margin-left: 0px;}
div.rbtoc1759726175717 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class="toc-macro rbtoc1759726175717"><style>[data-colorid=r3ghuhik3b]{color:#97a0af} html[data-color-mode=dark] [data-colorid=r3ghuhik3b]{color:#505968}[data-colorid=w9ww6wsicq]{color:#97a0af} html[data-color-mode=dark] [data-colorid=w9ww6wsicq]{color:#505968}</style>
<ul class="toc-indentation">
<li><a href="#json2sv—SystemVerilogConfigGenerator-Introduction">Introduction</a></li>
<li><a href="#json2sv—SystemVerilogConfigGenerator-Whatgetsgenerated">What gets generated</a>
<ul class="toc-indentation">
<li><a href="#json2sv—SystemVerilogConfigGenerator-1.dv_cfg_pkg.sv">1. dv_cfg_pkg.sv</a></li>
<li><a href="#json2sv—SystemVerilogConfigGenerator-2.if_cfg_pkg.sv">2. if_cfg_pkg.sv</a></li>
<li><a href="#json2sv—SystemVerilogConfigGenerator-3.port_bins_auto.sv(onlywith--emit-bins)">3. port_bins_auto.sv (only with --emit-bins)</a></li>
<li><a href="#json2sv—SystemVerilogConfigGenerator-4.tb_report_auto.sv(onlywith--emit-report)">4. tb_report_auto.sv (only with --emit-report)</a></li>
</ul>
</li>
<li><a href="#json2sv—SystemVerilogConfigGenerator-Install&amp;prerequisites">Install &amp; prerequisites</a></li>
<li><a href="#json2sv—SystemVerilogConfigGenerator-Quickstart(exactcommand)">Quick start (exact command)</a></li>
<li><a href="#json2sv—SystemVerilogConfigGenerator-CLIswitches&amp;defaults">CLI switches &amp; defaults</a></li>
<li><a href="#json2sv—SystemVerilogConfigGenerator-Howitworks(highlevel)">How it works (high level)</a></li>
<li><a href="#json2sv—SystemVerilogConfigGenerator-UsingthegeneratedfilesinyourTB">Using the generated files in your TB</a>
<ul class="toc-indentation">
<li><a href="#json2sv—SystemVerilogConfigGenerator-1)UsethesingletonDVconfig">1) Use the singleton DV config</a></li>
<li><a href="#json2sv—SystemVerilogConfigGenerator-2)Driveprotocol-dependent/top-levelports">2) Drive protocol-dependent/top-level ports</a></li>
<li><a href="#json2sv—SystemVerilogConfigGenerator-3)AutobindsfromariaObj.PortList">3) Auto binds from ariaObj.PortList</a></li>
<li><a href="#json2sv—SystemVerilogConfigGenerator-4)OptionalTBreportattime0">4) Optional TB report at time 0</a></li>
</ul>
</li>
<li><a href="#json2sv—SystemVerilogConfigGenerator-End-to-endexample">End-to-end example</a>
<ul class="toc-indentation">
<li><a href="#json2sv—SystemVerilogConfigGenerator-Input(excerpt)">Input (excerpt)</a></li>
<li><a href="#json2sv—SystemVerilogConfigGenerator-Generatedinterfacearrays(conceptually)">Generated interface arrays (conceptually)</a></li>
<li><a href="#json2sv—SystemVerilogConfigGenerator-TBusage(snippet)">TB usage (snippet)</a></li>
<li><a href="#json2sv—SystemVerilogConfigGenerator-Bindsprintout(auto)">Binds printout (auto)</a></li>
</ul>
</li>
<li><a href="#json2sv—SystemVerilogConfigGenerator-Performancenotes">Performance notes</a></li>
<li><a href="#json2sv—SystemVerilogConfigGenerator-Troubleshooting">Troubleshooting</a></li>
<li><a href="#json2sv—SystemVerilogConfigGenerator-Designchoices&amp;limitations">Design choices &amp; limitations</a></li>
<li><a href="#json2sv—SystemVerilogConfigGenerator-FAQ">FAQ</a></li>
</ul>
</div><h1 id="json2sv—SystemVerilogConfigGenerator-Introduction">Introduction</h1><p><strong>json2sv.js</strong> converts a (potentially huge) verification JSON into:</p><ul><li><p>a <strong>SystemVerilog package of hierarchical classes</strong> (singleton) you can use anywhere in TB,</p></li><li><p>a compact <strong>interface/protocol package</strong> (arrays + enums) for per-instance decisions (e.g., which ports to connect),</p></li><li><p>optional <strong>DV&harr;RTL bind wiring</strong> auto-generated from <code>ariaObj.PortList</code>,</p></li><li><p>an optional <strong>human-readable TB report</strong> you can print at time 0.</p></li></ul><p>The tool is <strong>streaming</strong> and <strong>OOM-safe</strong> (does not <code>JSON.parse</code> the entire file). It scales linearly with JSON size and keeps Node&rsquo;s memory modest.</p><hr /><h1 id="json2sv—SystemVerilogConfigGenerator-Whatgetsgenerated">What gets generated</h1><p>All outputs land in <code>--out-dir</code> (default <code>./out</code>):</p><h2 id="json2sv—SystemVerilogConfigGenerator-1.dv_cfg_pkg.sv">1. dv_cfg_pkg.sv</h2><p>Hierarchical <strong>class definitions</strong> mirroring the JSON structure, plus a <strong>singleton</strong>:</p><ol start="1"><li><p><code>function TopLevelDvCfg get_dv_cfg();</code> &mdash; returns the one-and-only config object (constructs lazily)</p></li><li><p><code>function void dv_cfg_reset();</code> &mdash; discards the singleton (rebuild on next <code>get_dv_cfg()</code>)</p></li></ol><p><strong>Types:</strong> for robustness and footprint, all leaf fields are <code>string</code>. Arrays become <strong>queues</strong> (<code>[$]</code>), arrays-of-objects become queues of child classes.</p><h2 id="json2sv—SystemVerilogConfigGenerator-2.if_cfg_pkg.sv">2. if_cfg_pkg.sv</h2><p>Protocol/feature <strong>arrays</strong> for fast, per-instance decisions:</p><ol start="1"><li><p><code>typedef enum int { PROTO_UNKNOWN, PROTO_AXI4, PROTO_AXI5, PROTO_ACE4, PROTO_ACE5, PROTO_ACE_LITE_E, PROTO_CHI_B, PROTO_CHI_E } proto_e;</code></p></li><li><p><code>parameter int n_if;</code></p></li><li><p><code>localparam proto_e axi_proto[n_if];</code> &lt;!-- name kept lowercase per your preference --&gt;</p></li><li><p><code>localparam int wdata[n_if];</code></p></li><li><p>Additional <code>localparam bit/int foo[n_if];</code> for boolean/number knobs we detect (e.g., <code>has_sysco_interface[n_if]</code>).</p></li></ol><p>String knobs may be emitted as small per-type enums (<code>*_e</code>) when the value set is small.</p><h2 id="json2sv—SystemVerilogConfigGenerator-3.port_bins_auto.sv(onlywith--emit-bins)">3. port_bins_auto.sv <em><span data-colorid="w9ww6wsicq">(only with --emit-bins)</span></em></h2><p>A tiny module that <strong>assigns DV signals to RTL</strong> using <code>ariaObj.PortList</code>:</p><ol start="1"><li><p>Displays the pairs at time 0,</p></li><li><p><code>bind TOP dv_port_binds dv_port_binds_i()</code></p></li></ol><h2 id="json2sv—SystemVerilogConfigGenerator-4.tb_report_auto.sv(onlywith--emit-report)">4. tb_report_auto.sv <em><span data-colorid="r3ghuhik3b">(only with --emit-report)</span></em></h2><p><code>tb_report_auto.sv</code> <em>(only with </em><code>--emit-report</code><em>)</em><br />A lightweight time-0 <strong>table printout</strong> of interface <code>proto</code> and <code>wdata</code>, with optional string-knob dumps.</p><hr /><h1 id="json2sv—SystemVerilogConfigGenerator-Install&amp;prerequisites">Install &amp; prerequisites</h1><ul><li><p><strong>Node.js</strong> 14+ (18+ recommended)</p></li><li><p><strong>One-time dependency</strong> for streaming JSON:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">npm i stream-json</pre>
</div></div></li></ul><hr /><h1 id="json2sv—SystemVerilogConfigGenerator-Quickstart(exactcommand)">Quick start (exact command)</h1><blockquote><p>Use your current paths verbatim. The script is streaming; setting a large heap is optional but harmless.</p></blockquote><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">setenv NODE_OPTIONS &quot;--max-old-space-size=16384&quot; ; node json2sv.js &lt;path/to/json&gt; --pkg dv_cfg_pkg --root TopLevelDvCfg --if-pkg if_cfg_pkg --top TOP --out-dir &lt;output/directory&gt; --emit-binds --emit-report</pre>
</div></div><p>Notes:</p><ul><li><p><code>--axi-pkg</code> is an <strong>alias</strong> for <code>--if-pkg</code> (supported for backward compatibility).</p></li><li><p>The script prints <strong>timing, Node RSS, class count, interface count, output sizes</strong>.</p></li></ul><hr /><h1 id="json2sv—SystemVerilogConfigGenerator-CLIswitches&amp;defaults">CLI switches &amp; defaults</h1><div class="table-wrap"><table data-table-width="760" data-layout="default" data-local-id="39f4e75f-1340-4d08-8644-64ee43da9c43" class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>Switch</p></th><th class="confluenceTh"><p>Default</p></th><th class="confluenceTh"><p>Description</p></th></tr><tr><td class="confluenceTd"><p>positional <code>&lt;jsonPath&gt;</code></p></td><td class="confluenceTd"><p>&mdash;</p></td><td class="confluenceTd"><p>Path to the input JSON.</p></td></tr><tr><td class="confluenceTd"><p><code>--pkg</code></p></td><td class="confluenceTd"><p><code>dv_cfg_pkg</code></p></td><td class="confluenceTd"><p>Name of the generated DV package (classes + singleton).</p></td></tr><tr><td class="confluenceTd"><p><code>--root</code></p></td><td class="confluenceTd"><p><code>TopLevelDvCfg</code></p></td><td class="confluenceTd"><p>Root class name for the singleton object.</p></td></tr><tr><td class="confluenceTd"><p><code>--if-pkg</code></p></td><td class="confluenceTd"><p><code>if_cfg_pkg</code></p></td><td class="confluenceTd"><p>Name of the interface/protocol package file.</p></td></tr><tr><td class="confluenceTd"><p><code>--axi-pkg</code></p></td><td class="confluenceTd"><p>&mdash;</p></td><td class="confluenceTd"><p><strong>Alias</strong> of <code>--if-pkg</code>.</p></td></tr><tr><td class="confluenceTd"><p><code>--top</code></p></td><td class="confluenceTd"><p><code>TOP</code></p></td><td class="confluenceTd"><p>Top module name used by the <code>bind</code> in <code>port_binds_auto.sv</code>.</p></td></tr><tr><td class="confluenceTd"><p><code>--out-dir</code></p></td><td class="confluenceTd"><p><code>./out</code></p></td><td class="confluenceTd"><p>Output directory.</p></td></tr><tr><td class="confluenceTd"><p><code>--emit-binds</code></p></td><td class="confluenceTd"><p><em>off</em></p></td><td class="confluenceTd"><p>Generate <code>port_binds_auto.sv</code> from <code>ariaObj.PortList</code>.</p></td></tr><tr><td class="confluenceTd"><p><code>--emit-report</code></p></td><td class="confluenceTd"><p><em>off</em></p></td><td class="confluenceTd"><p>Generate <code>tb_report_auto.sv</code> (time-0 printout).</p></td></tr><tr><td class="confluenceTd"><p><code>--no-fast</code></p></td><td class="confluenceTd"><p><em>fast on by default</em></p></td><td class="confluenceTd"><p>Disable fast mode (kept for future deep inference toggles).</p></td></tr><tr><td class="confluenceTd"><p><code>--max-enum &lt;N&gt;</code></p></td><td class="confluenceTd"><p><code>16</code></p></td><td class="confluenceTd"><p>Max distinct strings for creating per-type enums in <code>if_cfg_pkg</code>.</p></td></tr><tr><td class="confluenceTd"><p><code>--max-array-merge &lt;N&gt;</code></p></td><td class="confluenceTd"><p><code>64</code></p></td><td class="confluenceTd"><p>Reserved (future).</p></td></tr><tr><td class="confluenceTd"><p><code>--drop-keys a,b,c</code></p></td><td class="confluenceTd"><p><em>none</em></p></td><td class="confluenceTd"><p>Reserved (future: prune bulky JSON subtrees).</p></td></tr><tr><td class="confluenceTd"><p><code>--skip-dv</code></p></td><td class="confluenceTd"><p><em>off</em></p></td><td class="confluenceTd"><p>Don&rsquo;t emit <code>dv_cfg_pkg.sv</code>.</p></td></tr><tr><td class="confluenceTd"><p><code>--skip-if</code></p></td><td class="confluenceTd"><p><em>off</em></p></td><td class="confluenceTd"><p>Don&rsquo;t emit <code>if_cfg_pkg.sv</code>.</p></td></tr></tbody></table></div><hr /><h1 id="json2sv—SystemVerilogConfigGenerator-Howitworks(highlevel)">How it works (high level)</h1><ul><li><p><strong>Pass 1 (schema scan)</strong>: Streams the JSON and records where objects/arrays/scalars appear.<br />&rarr; Builds a <strong>class registry</strong> (one SV class per object path) and decides when arrays hold objects vs. scalars.</p></li><li><p><strong>Emit </strong><code>dv_cfg_pkg.sv</code>: Writes classes + a <strong>singleton constructor</strong> <code>__construct_dv_cfg()</code> that <strong>streams the JSON again</strong> and:</p><ul><li><p><code>new()</code> constructs objects at the right paths,</p></li><li><p><code>push_back(new())</code> for array-of-object elements,</p></li><li><p>assigns <strong>leaf strings</strong> (numbers/bools normalized to strings for robustness).</p></li></ul></li><li><p><strong>Scan &amp; emit </strong><code>if_cfg_pkg.sv</code>: Independently streams JSON to collect interface rows by finding objects containing <code>fnNativeInterface</code>, gathering known knobs (e.g., <code>wData</code>, <code>hasSyscoInterface</code>, etc.). Protocol names in arrays are <strong>lowercase identifiers</strong>; the enum values are <code>PROTO_*</code>.</p></li><li><p><strong>Optional binds/report</strong>: Streams only <code>ariaObj.PortList</code> for DV&harr;RTL pairs; emits the simple time-0 report.</p></li></ul><p>Because everything is <strong>streamed</strong>, it scales to very large JSON files with <strong>low memory</strong>.</p><hr /><h1 id="json2sv—SystemVerilogConfigGenerator-UsingthegeneratedfilesinyourTB">Using the generated files in your TB</h1><h2 id="json2sv—SystemVerilogConfigGenerator-1)UsethesingletonDVconfig">1) Use the singleton DV config</h2><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">// tb_top.sv
`timescale 1ns/1ps
module tb_top;

  import dv_cfg_pkg::*;  // classes + get_dv_cfg()
  TopLevelDvCfg cfg;

  initial begin
    cfg = get_dv_cfg();  // singleton; safe to call anywhere, anytime
    $display(&quot;[cfg] chiplet env: %s&quot;, cfg.chiplets.AiuInfo[0].env_name); // example path
  end

endmodule
</pre>
</div></div><blockquote><p><code>dv_cfg_reset()</code> discards the singleton. The next <code>get_dv_cfg()</code> will rebuild it from JSON.</p></blockquote><h2 id="json2sv—SystemVerilogConfigGenerator-2)Driveprotocol-dependent/top-levelports">2) Drive protocol-dependent/top-level ports</h2><p>Import both packages; use <code>if_cfg_pkg</code> to decide which ports to connect per interface:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">// tb_top.sv (continued)
import if_cfg_pkg::*;  // n_if, axi_proto[], wdata[], flags...

generate
  for (genvar i = 0; i &lt; n_if; i++) begin : g_if

    // Example DUT wrapper with conditional ports
    Gen_wrapper dut_i (
      .clk (chip_if[i].clk),
      .ar_valid (chip_if[i].ar_valid),

      // Example optional ACE/ACE5 port:
      .ac_valid ( (axi_proto[i] inside {PROTO_ACE4, PROTO_ACE5}) ? chip_if[i].ac_valid : 1'b0 )

      // More ports can be controlled by flags arrays the tool emits, e.g.:
      // .sysco_p   ( has_sysco_interface[i] ? chip_if[i].sysco_p   : '0 ),
      // .parity_en ( check_type_is_odd_parity[i] ? 1'b1 : 1'b0 )
    );

  end
endgenerate
</pre>
</div></div><p><strong>Notes</strong></p><ul><li><p>Protocol names are <strong>lowercase array identifiers</strong> (<code>axi_proto[i]</code>) with <strong>enum values</strong> (<code>PROTO_*</code>) &mdash; matches your preference.</p></li><li><p>Any boolean/number knobs discovered (e.g., <code>has_sysco_interface</code>) are emitted as <code>localparam bit/int &lt;name&gt;[n_if]</code>; use them the same way.</p></li><li><p>For feature matrices that depend on protocol <em>and</em> another knob, you can layer conditions:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">if ((axi_proto[i] == PROTO_AXI5) &amp;&amp; has_sysco_interface[i]) begin
  // connect extra SysCo ports for AXI5 when enabled
end
</pre>
</div></div></li></ul><h2 id="json2sv—SystemVerilogConfigGenerator-3)AutobindsfromariaObj.PortList">3) Auto binds from <code>ariaObj.PortList</code></h2><p>If you run with <code>--emit-binds</code>, include the file:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence"># compile/args
+incdir+./out
./out/port_binds_auto.sv
</pre>
</div></div><p>It creates a tiny module:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">module dv_port_binds;
  initial begin
    $display(&quot;[port_binds] %0t: applying %0d bindings&quot;, $time, &lt;N&gt;);
    // prints each &quot;&lt;rtl&gt; &lt;- &lt;dv&gt;&quot; pair
  end
  assign \rtl.path.with.dots  = \dv.path.with.dots ; // escaped
endmodule

bind TOP dv_port_binds dv_port_binds_i();
</pre>
</div></div><p>You don&rsquo;t need to instantiate anything &mdash; the <code>bind</code> targets <code>--top</code>.</p><h2 id="json2sv—SystemVerilogConfigGenerator-4)OptionalTBreportattime0">4) Optional TB report at time 0</h2><p>If you run with <code>--emit-report</code>, include the file and instantiate it once (or just compile it; it prints in <code>initial</code>):</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">// tb_top.sv
`include &quot;tb_report_auto.sv&quot; // or compile separately

module tb_top;
  dv_cfg_report _r(); // emits a neat table at t=0
  ...
endmodule
</pre>
</div></div><hr /><h1 id="json2sv—SystemVerilogConfigGenerator-End-to-endexample">End-to-end example</h1><h2 id="json2sv—SystemVerilogConfigGenerator-Input(excerpt)">Input (excerpt)</h2><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">{
  &quot;AiuInfo&quot;: [
    {
      &quot;fnNativeInterface&quot;: &quot;ACE5&quot;,
      &quot;wData&quot;: 256,
      &quot;hasSyscoInterface&quot;: 1,
      &quot;params&quot;: { &quot;wData&quot;: 256 },
      &quot;ariaObj&quot;: {
        &quot;PortList&quot;: [
          { &quot;rtlSignal&quot;: &quot;dut0.ac_valid&quot;, &quot;dvSignal&quot;: &quot;chip_if[0].ac_valid&quot; }
        ]
      }
    },
    {
      &quot;fnNativeInterface&quot;: &quot;AXI4&quot;,
      &quot;wData&quot;: 128,
      &quot;hasSyscoInterface&quot;: 0,
      &quot;ariaObj&quot;: {
        &quot;PortList&quot;: [
          { &quot;rtlSignal&quot;: &quot;dut1.ar_valid&quot;, &quot;dvSignal&quot;: &quot;chip_if[1].ar_valid&quot; }
        ]
      }
    }
  ]
}
</pre>
</div></div><h2 id="json2sv—SystemVerilogConfigGenerator-Generatedinterfacearrays(conceptually)">Generated interface arrays (conceptually)</h2><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">package if_cfg_pkg;
  typedef enum int { PROTO_UNKNOWN, PROTO_AXI4, PROTO_AXI5, PROTO_ACE4, PROTO_ACE5, PROTO_ACE_LITE_E, PROTO_CHI_B, PROTO_CHI_E } proto_e;
  parameter int n_if = 2;
  localparam proto_e axi_proto [n_if] = '{ PROTO_ACE5, PROTO_AXI4 };
  localparam int     wdata     [n_if] = '{ 256, 128 };
  localparam bit     has_sysco_interface [n_if] = '{ 1, 0 };
endpackage
</pre>
</div></div><h2 id="json2sv—SystemVerilogConfigGenerator-TBusage(snippet)">TB usage (snippet)</h2><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">import dv_cfg_pkg::*;
import if_cfg_pkg::*;

TopLevelDvCfg cfg;
initial begin
  cfg = get_dv_cfg();
  $display(&quot;Interface0 proto=%0s wdata=%0d&quot;,
    proto_e_to_string(axi_proto[0]), wdata[0]);
end

generate
  for (genvar i = 0; i &lt; n_if; i++) begin : g
    Gen_wrapper dut_i(
      .ar_valid (chip_if[i].ar_valid),
      .ac_valid ((axi_proto[i] inside {PROTO_ACE4, PROTO_ACE5}) ? chip_if[i].ac_valid : 1'b0),
      .sysco_p  (has_sysco_interface[i] ? chip_if[i].sysco_p : '0)
    );
  end
endgenerate
</pre>
</div></div><h2 id="json2sv—SystemVerilogConfigGenerator-Bindsprintout(auto)">Binds printout (auto)</h2><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">[port_binds]    0: applying 2 bindings
[port_binds]      dut0.ac_valid &lt;- chip_if[0].ac_valid
[port_binds]      dut1.ar_valid &lt;- chip_if[1].ar_valid
</pre>
</div></div><hr /><h1 id="json2sv—SystemVerilogConfigGenerator-Performancenotes">Performance notes</h1><ul><li><p>The tool <strong>streams</strong> the JSON twice (schema + assignment) and streams again for <code>if_cfg_pkg</code>/binds/report. Peak RSS typically stays in the <strong>hundreds of MB</strong>, not GB, regardless of JSON size.</p></li><li><p>End-of-run stats include <strong>elapsed ms</strong> and <strong>Node RSS</strong>:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Build time : 823.41 ms
Node RSS   : 116.4 MB
</pre>
</div></div></li></ul><p>If you ever do need headroom:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">setenv NODE_OPTIONS &quot;--max-old-space-size=16384&quot;</pre>
</div></div><p>&hellip;but the streaming design usually makes this unnecessary.</p><hr /><h1 id="json2sv—SystemVerilogConfigGenerator-Troubleshooting">Troubleshooting</h1><p><strong>&ldquo;Missing dependency 'stream-json'&rdquo;</strong><br />Run <code>npm i stream-json</code>.</p><p><strong>ENAMETOOLONG / weird giant filename</strong><br />Fixed: the script uses <code>nodePath.join(...)</code> consistently and doesn&rsquo;t shadow <code>path</code>. If you ever hand-edit, avoid local variables named <code>path</code>.</p><p><strong>Heap OOM</strong><br />This version does <strong>not</strong> <code>JSON.parse</code> the entire file. If you still see OOM, check <code>ulimit -n</code>, FS throttling, or extremely slow NFS mounts.</p><p><strong>No interfaces detected</strong><br />The tool discovers interfaces by finding objects that contain a <code>fnNativeInterface</code> key. Ensure your JSON follows that convention.</p><p><strong>Unexpected or missing flags</strong><br />Only obvious booleans/ints are emitted (<code>has*</code>, <code>enable*</code>, numbers). If you want additional knobs exported, ping the maintainer to whitelist names.</p><hr /><h1 id="json2sv—SystemVerilogConfigGenerator-Designchoices&amp;limitations">Design choices &amp; limitations</h1><ul><li><p><strong>Leafs are </strong><code>string</code> in <code>dv_cfg_pkg.sv</code>. This keeps type friction low across vendors/simulators and avoids width mismatches. Cast locally where needed.</p></li><li><p><strong>Arrays-of-arrays</strong>: Nested arrays are preserved as queues; deep multi-dimensional semantics aren&rsquo;t expanded (rare in config JSON).</p></li><li><p><strong>Enums</strong> in <code>if_cfg_pkg</code>: Only emitted when the distinct value set is small (<code>--max-enum</code>, default 16). Otherwise, we skip to avoid bloat.</p></li><li><p><strong>Protocol normalization</strong>: We map many spellings to a stable set: <code>AXI4, AXI5, ACE4, ACE5, ACE-LITE-E, CHI-B, CHI-E</code>. Unknowns become <code>PROTO_UNKNOWN</code>.</p></li></ul><hr /><h1 id="json2sv—SystemVerilogConfigGenerator-FAQ">FAQ</h1><p><strong>Q: Why a singleton?</strong><br />So you can safely do <code>get_dv_cfg()</code> anywhere without worrying about duplicate construction or ordering. Call <code>dv_cfg_reset()</code> if you need to rebuild.</p><p><strong>Q: Can I use config values in identifiers/hierarchical paths?</strong><br />That&rsquo;s what your <code>&lt;% %&gt;</code> templating excels at; for TB run-time code, keep that at the generator layer. For port presence/width choices, prefer <code>if_cfg_pkg</code> arrays.</p><p><strong>Q: How do I add more optional ports like parity/checkers?</strong><br />Add boolean/enum fields in JSON under the same interface objects. The tool will export booleans as <code>bit foo[n_if]</code> and (small) strings as enums. Then guard the port connections with those arrays.</p><p><strong>Q: Why are protocol arrays named in lowercase?</strong><br />Per your preference. Array identifiers such as <code>axi_proto</code> are lowercase; enum values remain in caps (e.g., <code>PROTO_ACE5</code>).</p>