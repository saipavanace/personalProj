<p>This is a JS base-class that is meant to be extended or customized for a native interface (AXI, OCP, etc.) and used within Symphony's ATUs.</p><p>The class definitions can be found in the following path:</p><p><strong>hw-sym/js/interfaceMapLibs.js</strong></p><h2 id="HW-CTFInterfaceX2InterfaceY-BaseClass">Base Class</h2><p>None</p><h2 id="HW-CTFInterfaceX2InterfaceY-Purpose">Purpose</h2><p>The Interface X refers to a <strong>known</strong> interface</p><ol><li>The signal width parameters for which are known </li><li>When a new object of the class is created, it is initialized with this interface (hence a known interface).</li><li>Example: Native Layer interfaces such as AXI, OCP, APB etc.</li></ol><p>The Interface Y refers to the <strong>unknown</strong> interface</p><ol><li>The signal width parameters for which are not known and are to be determined based on the known interface, Interface X</li><li>Example: Internal interfaces (internal to ATU) such as CTL.</li></ol><p>Width this definition of the two interfaces, the class can be used to </p><ol><li>Generate a complete Interface Y (internal to ATU) from a known external native interface, interface X.</li><li>Generate mapping between signals of Interface Y and interface X.</li><li>Provide an easy way of overwriting default mappings such as for mapping user bits ( refer <a class="external-link" href="https://confluence.arteris.com/display/ENGR/Generic+Assignment+Proposal" rel="nofollow">Generic Assignment Proposal</a> )</li></ol><p>This allows decoupling of JavaScript code that performs the above tasks from TACHL code involving design, hence allowing the design to be more modular, reusable, and maintainable.</p><p>When a new object of the class is created, it needs to be initialized with three table parameters:</p><ol><li>Y2XMap- has all the signal mappings between input signals of Interface Y and output signals of Interface X.</li><li>X2YMap- has all the signal mappings between input signals of Interface X  and output signals of Interface Y.</li><li>yParamMap- is a dictionary object with signal names of interface Y as keys and their width parameter names as values.</li></ol><h3 id="HW-CTFInterfaceX2InterfaceY-Tablestructures">Table structures</h3><p>Y2XMap and X2YMap have the same structure which is described below.</p><p>{</p><p>  &quot;sel0&quot;: {</p><p>    &quot;output0&quot;: mapping0,<br/>    &quot;output1&quot;: mapping1,<br/>    &quot;output2&quot;: mapping2<br/>    .<br/>    .<br/>    .</p><p>  },</p><p>  &quot;sel1&quot;: {</p><p>    &quot;output0&quot;: mapping20,<br/>    &quot;output1&quot;: mapping21,<br/>    &quot;output2&quot;: mapping22<br/>    .<br/>    .<br/>    .</p><p>  },</p><p>  &quot;sel2&quot;: {</p><p>    &quot;output0&quot;: mapping30,<br/>    &quot;output1&quot;: mapping31,<br/>    &quot;output2&quot;: mapping32<br/>    .<br/>    .<br/>    .</p><p>  },</p><p>  .<br/>  .<br/>  .</p><p>  &quot;default&quot;: {</p><p>    &quot;output0&quot;: mapping40,<br/>    &quot;output1&quot;: mapping41,<br/>    &quot;output2&quot;: mapping42</p><p>  }</p><p>}</p><p><br/></p><p>As shown above, both these data-structure parameters are described as dictionary objects with 2 levels of hierarchy (or a dictionary of dictionaries).The first level is meant to allow the possibility of multiplexing the input-mappings to a single output. Hence we notice in the above example that the same input signal can have multiple-mappings depending on the mux-select value. If multiplexing is not required or isn't present between the two interfaces then just the &quot;default&quot; table can be used.</p><p>The output signal names - &quot;output0&quot;, &quot;output1&quot;, &quot;output2&quot;, ... refer to outputs (signals to be assigned to) of interface Y in Y2XMap and of interface X in X2YMap.</p><p>The mappings &quot;mapping0&quot;, &quot;mapping1&quot;, ... are strings also and must be a list of comma-separated values, with no white-spaces, and with the leftmost value being most-significant. Each value is either a</p><ol><li>Signal name ( r_resp )</li><li>Signal slice ( r_resp[3:2] )</li><li>A Verilog constant literal ( 2'h0, 2'd3 )</li></ol><p><br/></p><p>The yParamMap is just a simple dictionary object with signal names of Interface Y as keys and their width parameter names as values:</p><p>{</p><p>  &quot;signal0&quot;: &quot;param0&quot;,<br/>  &quot;signal1&quot;: &quot;param1&quot;,<br/>  &quot;signal2&quot;: &quot;param2&quot;,<br/>  .<br/>  .<br/>  .</p><p>}</p><p>This map is used to populate a dictionary of width-parameter names and their values, which in turn can be used to generate the unknown interface, Interface Y. </p><p><br/></p><h2 id="HW-CTFInterfaceX2InterfaceY-Interface">Interface</h2><p>The InterfaceX2InterfaceY class provides the following interface methods:</p><p><strong><em>constructor ( interfaceX, Y2XMap, X2YMap, yParamMap )</em></strong></p><p>This is called when an instance of this class is created. The instance object is initialized with the following arguments</p><p>The interfaceX argument is expected to be a flat interface or signal bundle or in JavaScript terms a dictionary object with signal names as keys and widths as values.</p><p>The remaining arguments are explained under the section &quot;Table Structures&quot; above.</p><p><br/></p><p><em><strong>Y2X ( signalY, sel )</strong></em></p><p>This method returns an array of mapping-values for an output signal of interface Y (signalY) and in a given multiplexed channel (sel). If only signalY is passed, sel defaults to &quot;default&quot;.</p><p><br/></p><p><em><strong>X2Y ( signalX, sel )</strong></em></p><p>This method returns an array of mapping-values for an output signal of interface X (signalX) and in a given multiplexed channel (sel). If only signalX is passed, sel defaults to &quot;default&quot;.</p><p><br/></p><p><em><strong>yReqParams ( )</strong></em></p><p>This method returns a dictionary object with width-parameter names as keys and widths as values that can be used to generate the Interface Y (new-style). Width parameters for Y signals that have no mapping in the Y2XMap are removed.</p><p><br/></p><p><em><strong>yRespParams ( )</strong></em></p><p>This method returns a dictionary object with width-parameter names as keys and widths as values that can be used to generate the Interface Y (new-style). Width parameters for Y signals that have no mapping in the X2YMap are removed.</p><p><br/></p><p><em><strong>selectsY2X (  signalY )</strong></em></p><p>This method returns an array of all the select keys or channels (&quot;sel0&quot;, &quot;sel1&quot;...) that have mappings for the input signalY in the Y2XMap. If no mapping is present in any channels, then the method returns an empty array.</p><p><br/></p><p><strong>selectsX2Y (  signalY )</strong></p><p>This method returns an array of all the select keys or channels (&quot;sel0&quot;, &quot;sel1&quot;...) that have mappings for the input signalY in the X2YMap. If no mapping is present in any channels, then the method returns an empty array.</p><p><br/></p><p><br/></p><p><br/></p>