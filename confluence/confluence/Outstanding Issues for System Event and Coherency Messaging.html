<p><br/></p><p><strong>References:</strong></p><p><a class="external-link" href="https://confluence.arteris.com/pages/viewpage.action?spaceKey=ENGR&amp;title=Arch+Ncore+3.2+Docs" rel="nofollow">Arch Ncore 3.2 Docs - Engineering - Confluence (arteris.com)</a></p><p><a class="external-link" href="https://confluence.arteris.com/display/ENGR/System+Event+and+Coherency+Wrapper" rel="nofollow">System Event and Coherency Wrapper - Engineering - Confluence (arteris.com)</a></p><p><a class="external-link" href="https://confluence.arteris.com/display/ENGR/Ncore+3.0+System+Specification" rel="nofollow">Ncore 3.0 System Specification - Engineering - Confluence (arteris.com)</a></p><p><a class="external-link" href="https://confluence.arteris.com/display/ENGR/Ncore+3.0.1+DVE+micro-architecture+specification" rel="nofollow">Ncore 3.0.1 DVE micro-architecture specification - Engineering - Confluence (arteris.com)</a></p><p><br/></p><p><strong>For Ncore 3.2 NXP Release:</strong></p><p><strong>1.Please confirm the legal combinations of Sys.Coh Sender/Receiver and Sys.Event Sender/Receiver for each Concerto Unit.</strong></p><div class="table-wrap"><table class="relative-table wrapped confluenceTable" style="width: 952.8px;"><colgroup><col style="width: 0.0px;"/><col style="width: 0.0px;"/></colgroup><thead><tr><th style="text-align: left;" class="confluenceTh"><p>Concerto Unit</p></th><th style="text-align: left;" class="confluenceTh"><p>Legal Combinations</p></th></tr></thead><tbody><tr><td style="text-align: left;" class="confluenceTd">CHI-AIU</td><td style="text-align: left;" class="confluenceTd"><p>Sys.Coh Sender, Sys.Event Receiver </p></td></tr><tr><td style="text-align: left;" class="confluenceTd">ACE-AIU</td><td style="text-align: left;" class="confluenceTd"><p>Sys.Coh Sender, Sys.Event Receiver </p></td></tr><tr><td style="text-align: left;" class="confluenceTd">AXI-AIU with Proxy Cache (not DVM capable)</td><td style="text-align: left;" class="confluenceTd"><p>Sys.Coh Sender, Sys.Event Receiver</p></td></tr><tr><td colspan="1" class="confluenceTd">AXI-AIU without Proxy Cache (not DVM capable)</td><td colspan="1" class="confluenceTd">none</td></tr><tr><td colspan="1" style="text-align: left;" class="confluenceTd"><p>ACELite-AIU (can be DVM capable)</p><p>ACELiteE-AIU (can be DVM capable)</p></td><td colspan="1" style="text-align: left;" class="confluenceTd">none</td></tr><tr><td colspan="1" style="text-align: left;" class="confluenceTd">DCE</td><td colspan="1" style="text-align: left;" class="confluenceTd">Sys.Coh Receiver + Sys.Event Sender (ExMon event whenever ExclusiveStore passes and resets the monitor)</td></tr><tr><td colspan="1" style="text-align: left;" class="confluenceTd">DVE</td><td colspan="1" style="text-align: left;" class="confluenceTd">Sys.Coh Receiver</td></tr><tr><td colspan="1" style="text-align: left;" class="confluenceTd">DMI</td><td colspan="1" style="text-align: left;" class="confluenceTd">none</td></tr><tr><td colspan="1" style="text-align: left;" class="confluenceTd">DII</td><td colspan="1" style="text-align: left;" class="confluenceTd">none</td></tr></tbody></table></div><p><br/></p><p>Only DCE has Sys.Event Sender to broadcast ExMon event to the caching agents (CHI-AIU, ACE-AIU, AXI-AIU with Proxy Cache) associated with the DCE.</p><p><br/></p><p>The caching agents need to issue Sys.Coh (Attach/Detach) messages to DCE so that DCE can track their attached/detached states via the DCE Snoop Enable register.</p><p>DCE only send ExMon event (Sys.Event message) to Caching Agents that are in the attached states.</p><p>=&gt;Sys.Event messaging testing is tied to Sys.Coh messaging testing, unless SW writes to the DCE Snoop Enable register to all 1s.</p><p><br/></p><p>AIUs do not have Sys.Event Sender and therefore cannot send Sys.Event messages.</p><p><br/></p><p><strong>Maestro is expected to provide the following interface objects</strong>:</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Concerto Unit</th><th class="confluenceTh">Interface Objects required from Maestro generated JSON file</th></tr><tr><td class="confluenceTd"><p>CHI-AIU</p></td><td class="confluenceTd"><p>Sys.Coh Sender: interfaces.uSysDceIdInt, interfaces.uSysDveIdInt</p><p>Sys.Event Receiver: interface.uEvtOutInt</p></td></tr><tr><td colspan="1" class="confluenceTd">ACE-AIU</td><td colspan="1" class="confluenceTd"><p>Sys.Coh Sender: interfaces.uSysDceIdInt, interfaces.uSysDveIdInt</p><p>OPTIONAL: Sys.Event Receiver: interface.uEvtOutInt</p></td></tr><tr><td class="confluenceTd">AXI-AIU with Proxy Cache</td><td class="confluenceTd"><p>Sys.Coh Sender: interfaces.uSysDceIdInt, interfaces.uSysDveIdInt</p><p>Sys.EventReceiver: no interface to talk to external CPU* what for?</p></td></tr><tr><td colspan="1" class="confluenceTd"><p>AXI-AIU without Proxy Cache</p><p><br/></p></td><td colspan="1" class="confluenceTd">none</td></tr><tr><td colspan="1" class="confluenceTd"><p>ACELite-AIU</p><p>ACELiteE-AIU</p></td><td colspan="1" class="confluenceTd">none</td></tr><tr><td colspan="1" class="confluenceTd">DCE</td><td colspan="1" class="confluenceTd"><p>Sys.Coh Receiver: interfaces.uSysCaIdInt, interfaces.uSysCaNodeIdInt</p><p>Sys.Event Sender: none (ExMon event is internally generated)</p></td></tr><tr><td colspan="1" class="confluenceTd">DVE</td><td colspan="1" class="confluenceTd">Sys.Coh Receiver: interfaces.uSysIdInt, interfaces.uSysNodeIdInt</td></tr><tr><td colspan="1" class="confluenceTd">DMI, DII</td><td colspan="1" class="confluenceTd">none</td></tr></tbody></table></div><p><br/></p><p>Sys.Event Receiver generates the following SysRsp.cm_status:</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left;" class="confluenceTh"><p>Sys.Event Receiver's SysRsp cm_status[7:0]</p></th><th style="text-align: left;" class="confluenceTh"><p>Comments</p></th></tr></thead><tbody><tr><td style="text-align: left;" class="confluenceTd"><p>01_000_000</p></td><td style="text-align: left;" class="confluenceTd"><p>SysRsp.Error NoOperationPerformed for arrival error, or event timeout.</p></td></tr><tr><td colspan="1" style="text-align: left;" class="confluenceTd">00_000_011</td><td colspan="1" style="text-align: left;" class="confluenceTd">SysRsp.Ok OperationPerformed for event completion.</td></tr><tr><td style="text-align: left;" class="confluenceTd">00_000_001</td><td style="text-align: left;" class="confluenceTd">SysRsp.Ok Busy for receiver busy.</td></tr><tr><td style="text-align: left;" class="confluenceTd">00_000_000</td><td style="text-align: left;" class="confluenceTd"><p>SysRsp.Ok NoOperationPerformed for receiver disabled.</p></td></tr></tbody></table></div><p><br/></p><p>Sys.Coh Receiver generates the following SysRsp.cm_status:</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left;" class="confluenceTh"><p>Sys.Coh Receiver's SysRsp cm_status[7:0]</p></th><th style="text-align: left;" class="confluenceTh"><p>Comments</p></th></tr></thead><tbody><tr><td style="text-align: left;" class="confluenceTd">00_000_011</td><td style="text-align: left;" class="confluenceTd">SysRsp.Ok OperationPerformed for protocol completion.</td></tr><tr><td style="text-align: left;" class="confluenceTd">01_000_000</td><td style="text-align: left;" class="confluenceTd">SysRsp.Error NoOperationPerformed for arrival error.</td></tr></tbody></table></div><p><br/></p><p><strong>2. Error Logging format and interrupt is undefined in the architecture spec.</strong></p><p><br/></p><p>DVE Sys.Coh Receiver logs the FUnitId for the received SysReq message that has cmstatus arrival error or target not found error.</p><p>DCE Sys.Coh Receiver logs the FUnitId for the received SysReq message that has cmstatus arrival error or target not found error.</p><p>DCE Sys.Evt Sender logs the FUnitId for the received SysRsp message that has cmstatus arrival error, and logs the protocol timeout error, and logs the event timeout error. NOTE: event timeout error is highly unlikely because ExMon event is internally generated.</p><p>AIU Sys.Evt Receiver logs the FUnitId for the received SysReq message that has cmstatus arrival error, and logs the event timeout error.</p><p><br/></p><p>Existing Ncore 3 Error Logging format and interrupt specification (shown as below) needs to be updated to log System Event and Coherency error.</p><h4 id="OutstandingIssuesforSystemEventandCoherencyMessaging-1.1.1.1UncorrectableErrorDetectRegister(xUEDR)">1.1.1.1     Uncorrectable Error Detect Register (xUEDR) </h4><p>Register Description: This register enables the detection of Uncorrectable Errors.  </p><p>Register Fields: </p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/><col/></colgroup><tbody><tr><td class="confluenceTd"><p>Bits </p></td><td class="confluenceTd"><p>Name </p></td><td class="confluenceTd"><p>Access </p></td><td class="confluenceTd"><p>Reset </p></td><td class="confluenceTd"><p>Description </p></td></tr><tr><td class="confluenceTd"><p>0 </p></td><td class="confluenceTd"><p>ProtErrDetEn </p></td><td class="confluenceTd"><p>RW </p></td><td class="confluenceTd"><p>0b0 </p></td><td class="confluenceTd"><p>Protocol Error Detection Enable. When set to 1, this bit enables the detection and logging of Protocol type Uncorrectable Error. </p></td></tr><tr><td class="confluenceTd"><p>1 </p></td><td class="confluenceTd"><p>TransErrDetEn </p></td><td class="confluenceTd"><p>RW </p></td><td class="confluenceTd"><p>0b0 </p></td><td class="confluenceTd"><p>Transport Error Detection Enable. When set to 1, this bit enables the detection and logging of Transport type Uncorrectable Error. </p></td></tr><tr><td class="confluenceTd"><p>2 </p></td><td class="confluenceTd"><p>MemErrDetEn </p></td><td class="confluenceTd"><p>RW </p></td><td class="confluenceTd"><p>0b0 </p></td><td class="confluenceTd"><p>Memory Error Detection Enable. When set to 1, this bit enables the detection and logging of Memory type Uncorrectable Error. This field exists only when there are protected memory arrays in the unit. </p></td></tr><tr><td class="confluenceTd"><p>3 </p></td><td class="confluenceTd"><p>DecErrDetEn </p></td><td class="confluenceTd"><p>RW </p></td><td class="confluenceTd"><p>0b0 </p></td><td class="confluenceTd"><p>Decode Error Detection Enable. When set to 1, this bit enables the detection and logging of Access type Uncorrectable Error. </p></td></tr><tr><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>TimeOutErrDetEn </p></td><td class="confluenceTd"><p>RW </p></td><td class="confluenceTd"><p>0b0 </p></td><td class="confluenceTd"><p>Time Out Error Detection Enable. When set to 1, this bit enables the detection and logging of Time Out Error. </p></td></tr></tbody></table></div><p><br/></p><h4 id="OutstandingIssuesforSystemEventandCoherencyMessaging-1.1.1.2UncorrectableErrorInterruptRegister(xUEIR)">1.1.1.2     Uncorrectable Error Interrupt Register (xUEIR) </h4><p>Register Description: This register enables the interrupt signaling of Uncorrectable Errors.  </p><p>Register Fields: </p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/><col/></colgroup><tbody><tr><td class="confluenceTd"><p>Bits </p></td><td class="confluenceTd"><p>Name </p></td><td class="confluenceTd"><p>Access </p></td><td class="confluenceTd"><p>Reset </p></td><td class="confluenceTd"><p>Description </p></td></tr><tr><td class="confluenceTd"><p>0 </p></td><td class="confluenceTd"><p>ProtErrIntEn </p></td><td class="confluenceTd"><p>RW </p></td><td class="confluenceTd"><p>0b0 </p></td><td class="confluenceTd"><p>Protocol Error Interrupt Enable. When set to 1, this bit enables the assertion of Protocol type Uncorrectable Error Interrupt signal. </p></td></tr><tr><td class="confluenceTd"><p>1 </p></td><td class="confluenceTd"><p>TransErrIntEn </p></td><td class="confluenceTd"><p>RW </p></td><td class="confluenceTd"><p>0b0 </p></td><td class="confluenceTd"><p>Transport Error Interrupt Enable. When set to 1, this bit enables the assertion of Transport type Uncorrectable Error Interrupt signal. </p></td></tr><tr><td class="confluenceTd"><p>2 </p></td><td class="confluenceTd"><p>MemErrIntEn </p></td><td class="confluenceTd"><p>RW </p></td><td class="confluenceTd"><p>0b0 </p></td><td class="confluenceTd"><p>Memory Error Interrupt Enable. When set to 1, this bit enables the assertion of Memory type Uncorrectable Error Interrupt signal. This field exists only when there are protected memory arrays in the unit. </p></td></tr><tr><td class="confluenceTd"><p>3 </p></td><td class="confluenceTd"><p>DecErrIntEn </p></td><td class="confluenceTd"><p>RW </p></td><td class="confluenceTd"><p>0b0 </p></td><td class="confluenceTd"><p>Decode Error Interrupt Enable. When set to 1, this bit enables the assertion of Access type Uncorrectable Error Interrupt signal. </p></td></tr><tr><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>TimeOutErrIntEn </p></td><td class="confluenceTd"><p>RW </p></td><td class="confluenceTd"><p>0b0 </p></td><td class="confluenceTd"><p>Time Out Error Interrupt Enable. When set to 1, this bit enables the assertion of Time Out Error Interrupt signal. </p></td></tr></tbody></table></div><p><br/></p><h4 id="OutstandingIssuesforSystemEventandCoherencyMessaging-1.1.1.3UncorrectableErrorStatusRegister(xUESR)">1.1.1.3     Uncorrectable Error Status Register (xUESR) </h4><p>Register Description: This register logs information about Uncorrectable errors in the unit. If a new Uncorrectable Error attempts to log this register the same cycle xUESAR is configured, this register will contain information from xUESAR. </p><p>Register Fields: </p><p><br/></p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/><col/></colgroup><tbody><tr><td class="confluenceTd"><p>Bits </p></td><td class="confluenceTd"><p>Name </p></td><td class="confluenceTd"><p>Access </p></td><td class="confluenceTd"><p>Reset </p></td><td class="confluenceTd"><p>Description </p></td></tr><tr><td class="confluenceTd"><p>1 </p></td><td class="confluenceTd"><p>ErrVld </p></td><td class="confluenceTd"><p>W1C </p></td><td class="confluenceTd"><p>0b0 </p></td><td class="confluenceTd"><p>Uncorrectable Error Valid. This bit is set when an Uncorrectable Error is detected. xUESR, xUELR0 and xUELR1 contain logged information about this Uncorrectable Error. Write 1 to the field resets it to 0b0. If write 1 to the field and a new Uncorrectable Error is detected at the same cycle, the field is cleared. </p></td></tr><tr><td class="confluenceTd"><p>3:2 </p></td><td class="confluenceTd"><p>Reserved </p></td><td class="confluenceTd"><p>- </p></td><td class="confluenceTd"><p>-- </p></td><td class="confluenceTd"><p>- </p></td></tr><tr><td class="confluenceTd"><p>7:4 </p></td><td class="confluenceTd"><p>ErrType </p></td><td class="confluenceTd"><p>RO </p></td><td class="confluenceTd"><p>0x00 </p></td><td class="confluenceTd"><p>Uncorrectable Error Type. When ErrVld is set to 1, the field indicates the type of error that has been detected and logged. </p></td></tr><tr><td class="confluenceTd"><p>15:8 </p></td><td class="confluenceTd"><p>Reserved </p></td><td class="confluenceTd"><p>- </p></td><td class="confluenceTd"><p>- </p></td><td class="confluenceTd"><p>- </p></td></tr><tr><td class="confluenceTd"><p>31:16 </p></td><td class="confluenceTd"><p>ErrInfo </p></td><td class="confluenceTd"><p>RO </p></td><td class="confluenceTd"><p>0x0000 </p></td><td class="confluenceTd"><p>Uncorrectable Error Information. When ErrVld is set to 1, the field contains additional unit-specific and error-type-specific information about the error. For example, information that could help identify the site of the error. </p></td></tr></tbody></table></div><p><br/></p><h4 id="OutstandingIssuesforSystemEventandCoherencyMessaging-1.1.1.1UncorrectableErrorLocationRegister(xUELR0)">1.1.1.1     Uncorrectable Error Location Register (xUELR0) </h4><p>Register Description: This register logs location information of Uncorrectable Errors in the unit. The information is unit-specific (see <u>Error Type and Information Summary</u>). The fields are made RW accessible to utilize this register as the alias register for error information injection purpose. </p><p>Register Fields: see <u>xCELR0</u> </p><h4 id="OutstandingIssuesforSystemEventandCoherencyMessaging-1.1.1.2UncorrectableErrorLocationRegister(xUELR1)">1.1.1.2     Uncorrectable Error Location Register (xUELR1) </h4><p>Register Description: This register logs extra address information that cannot fit in xUELR0. The fields are made RW accessible to utilize this register as the alias register for error information injection purpose. </p><p>Register Fields: see <u>xCELR1</u> </p><p><br/></p><h4 id="OutstandingIssuesforSystemEventandCoherencyMessaging-1.1.1.1UncorrectableErrorStatusAliasRegister(xUESAR)">1.1.1.1     Uncorrectable Error Status Alias Register (xUESAR) </h4><p>Register Description: This register is used to inject error status into xUESR. If a new Uncorrectable Error attempts to log the same cycle this register is configured, the information in this register will be logged in the xUESR. </p><p>Register Fields: </p><p><br/></p><div class="table-wrap"><table class="wrapped confluenceTable"><tbody><tr><td class="confluenceTd"><p>Bits </p></td><td class="confluenceTd"><p>Name </p></td><td class="confluenceTd"><p>Access </p></td><td class="confluenceTd"><p>Reset </p></td><td class="confluenceTd"><p>Description </p></td></tr><tr><td class="confluenceTd"><p>1 </p></td><td class="confluenceTd"><p>ErrVld </p></td><td class="confluenceTd"><p>W1C </p></td><td class="confluenceTd"><p>0b0 </p></td><td class="confluenceTd"><p>Alias bit for setting ErrVld in xUESR. </p></td></tr><tr><td class="confluenceTd"><p>3:2 </p></td><td class="confluenceTd"><p>Reserved </p></td><td class="confluenceTd"><p>- </p></td><td class="confluenceTd"><p>- </p></td><td class="confluenceTd"><p>- </p></td></tr><tr><td class="confluenceTd"><p>7:4 </p></td><td class="confluenceTd"><p>ErrType </p></td><td class="confluenceTd"><p>RO </p></td><td class="confluenceTd"><p>0x00 </p></td><td class="confluenceTd"><p>Alias field for setting ErrType in xUESR. </p></td></tr><tr><td class="confluenceTd"><p>15:8 </p></td><td class="confluenceTd"><p>Reserved </p></td><td class="confluenceTd"><p>- </p></td><td class="confluenceTd"><p>- </p></td><td class="confluenceTd"><p>- </p></td></tr><tr><td class="confluenceTd"><p>31:16 </p></td><td class="confluenceTd"><p>ErrInfo </p></td><td class="confluenceTd"><p>RO </p></td><td class="confluenceTd"><p>0x0000 </p></td><td class="confluenceTd"><p>Alias field for setting ErrInfo in xUESR. </p></td></tr></tbody></table></div><p><br/></p><h3 id="OutstandingIssuesforSystemEventandCoherencyMessaging-1.1.2ErrorTypeandInformationSummary">1.1.2      Error Type and Information Summary </h3><p><br/></p><h4 id="OutstandingIssuesforSystemEventandCoherencyMessaging-1.1.2.2UncorrectableErrorTypeandInfoTable">1.1.2.2     Uncorrectable ErrorType and Info Table </h4><p><br/></p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/><col/><col/></colgroup><tbody><tr><td rowspan="2" class="confluenceTd"><p>ErrType Code </p></td><td rowspan="2" class="confluenceTd"><p>Error Type and ErrInfo Code </p></td><td colspan="4" class="confluenceTd"><p>Error Location </p></td></tr><tr><td class="confluenceTd"><p>Addr </p></td><td class="confluenceTd"><p>Word </p></td><td class="confluenceTd"><p>Way </p></td><td class="confluenceTd"><p>Entry </p></td></tr><tr><td class="confluenceTd"><p>0x0 </p></td><td class="confluenceTd"><p>Data Uncorrectable Error </p><p>·                     [1:0] – Storage Type </p><p>o        2’b00 - OTT-Data </p><p>o        2’b01 - Read Buffer </p><p>o        2’b10 - Write Buffer </p><p>o        2’b11 - Snoop Filter </p><p>·                     [7:2] – Reserved </p><p>·                     [15:8] – Snoop Filter ID  </p><p>               (Reserved for non-snoop filter)</p></td><td class="confluenceTd"><p>MBZ </p></td><td class="confluenceTd"><p>MBZ/</p><p>N/A</p></td><td class="confluenceTd"><p>MBZ/ </p><p>Way </p></td><td class="confluenceTd"><p>Entry/ </p><p>Set </p></td></tr><tr><td class="confluenceTd"><p>0x1 </p></td><td class="confluenceTd"><p>Cache Uncorrectable Error </p><p>·                     [0] – Array Type </p><p>o        1’b0 - Tag Array </p><p>o        1’b1 - Data Array </p><p><br/></p></td><td class="confluenceTd"><p>MBZ </p></td><td class="confluenceTd"><p>Word </p></td><td class="confluenceTd"><p>Way </p></td><td class="confluenceTd"><p>Set </p></td></tr><tr><td class="confluenceTd"><p>0x2 </p></td><td class="confluenceTd"><p>Native Interface Write Response Error </p><p>·                     [1:0] - Response </p><p>·                     [2] - Security Attribute </p><p>·                     [3]- Eviction </p></td><td colspan="4" class="confluenceTd"><p>Transaction Address </p></td></tr><tr><td class="confluenceTd"><p>0x3 </p></td><td class="confluenceTd"><p>Native Interface Read Response Error </p><p>·                     [1:0] - Response </p><p>·                     [2] - Security Attribute </p><p>·                     [3]- Fill  </p></td><td colspan="4" class="confluenceTd"><p>Transaction Address </p></td></tr><tr><td class="confluenceTd"><p>0x4 </p></td><td class="confluenceTd"><p>Native Interface Snoop Response Error </p><p>·                     [1:0] – Response </p><p>·                     [2] - Security Attribute </p></td><td colspan="4" class="confluenceTd"><p>Transaction Address </p></td></tr><tr><td class="confluenceTd"><p>0x5-0x6 </p></td><td class="confluenceTd"><p>Reserved </p></td><td class="confluenceTd"><p><em>N/A</em> </p></td><td class="confluenceTd"><p><em>N/A</em> </p></td><td class="confluenceTd"><p><em>N/A</em> </p></td><td class="confluenceTd"><p><em>N/A</em> </p></td></tr><tr><td class="confluenceTd"><p>0x7 </p></td><td class="confluenceTd"><p>Decode Error </p><p>·                     [1:0] – Type </p><p>o        2’b00: No address hit </p><p>o        2’b01: Multiple address hit </p><p>o        2’b10: Illegal CSR access format </p><p>o        2’b11: Illegal DII access type </p><p>·                     [3:2] – Reserved  </p><p>·                     [4] – Command Type </p><p>               (Reserved for CHI-AIU &amp; DCE) </p><p>o        1’b0: Read </p><p>o        1’b1: Write </p><p>·                      [5] – Reserved </p><p>·                     [15:6] – Transaction ID/AXID </p><p>               (Reserved for DCE)</p><p><br/></p></td><td colspan="4" class="confluenceTd"><p>Transaction Address </p></td></tr><tr><td class="confluenceTd"><p>0x8 </p></td><td class="confluenceTd"><p>Transport Error </p><p>·                     [0] – Type </p><p>o        1’b0:  Wrong Target Id </p><p>·                     [5:1] – Reserved  </p><p>·                     [15:6] – Source ID (FUnit_Id) </p></td><td colspan="4" class="confluenceTd"><p>-</p></td></tr><tr><td class="confluenceTd"><p>0x9 </p></td><td class="confluenceTd"><p>Timeout Error </p><p>·                     [1:0] - Reserved</p><p>·                     [2] - Security Attribute </p><p>·                     [15:3] - Reserved</p></td><td colspan="4" class="confluenceTd"><p>Transaction Address </p></td></tr><tr><td class="confluenceTd"><p>0xA -0xF </p></td><td class="confluenceTd"><p>Reserved </p></td><td class="confluenceTd"><p><em>N/A</em> </p></td><td class="confluenceTd"><p><em>N/A</em> </p></td><td class="confluenceTd"><p><em>N/A</em> </p></td><td class="confluenceTd"><p><em>N/A</em> </p></td></tr></tbody></table></div><p><br/></p><p><strong>3. The existing DVE Snoop Enable register has the following definition (see DVE uarch spec):</strong></p><p>&quot;&quot;&quot;&quot;</p><p>DVE Snoop Enable Register is a combo register comprising four 32-bit registers:  DVEUSER0, DVEUSER1, DVEUSER2, DVEUSER3 to support a system that has up to 128 AIUs.</p><p>The width of the DVE Snoop Enable Register is nAius (the number of AIUs in the system). Bit 0 is for AIU0, Bit 1 for AIU1, etc. Whether an AIU is DVM capable or not can be found by writing and reading the corresponding bit in the DVE Snoop Enable Register. If writing a 1 to the bit but reading back 0 from the bit, then the AIU associated with the bit is not DVM capable, and software can find out the NUnitId (Node Unit ID) of that AIU which is the bit position.</p><p>In the write bit mask, the number of bits set to 1 is nDVMAgents. (NOTE: nDVMAgents is less than or equal to nAius).</p><p>DVE uses the values in the array of dvm_aiu_n_unit_id (Node Unit IDs from DVM capable AIUs; connected to DVE as input port) to generate the write bit mask.</p><p>&quot;&quot;&quot;&quot;</p><p>DVE generates a target enable bit vector of width=nDVMAgents, by matching the dvm_n_unit_id_array (array length is nDVMAgents) with the corresponding bits in the DVE Snoop Enable Register.</p><p>The target enable bit vector is fed to the DVE protocol manager for snoop control: if the bit for a target is set, then snoop can be sent to that target, otherwise no snoop can be sent to that target.</p><p><br/></p><p><strong>4. The newly created DCE Snoop Enable Register uses the DVM Snoop Enable Register definition but put it in the DCE context.</strong></p><p>&quot;&quot;&quot;&quot;</p><p>DCE Snoop Enable Register is a combo register comprising four 32-bit registers:  DCEUSER0, DCEUSER1, DCEUSER2, DCEUSER3 to support a system that has up to 128 AIUs.</p><p>The width of the DCE Snoop Enable Register is nAius (the number of AIUs in the system). Bit 0 is for AIU0, Bit 1 for AIU1, etc. Whether an AIU is DCE snoop capable or not can be found by writing and reading the corresponding bit in the DCE Snoop Enable Register. If writing a 1 to the bit but reading back 0 from the bit, then the AIU associated with the bit is not DCE snoop capable, and software can find out the NUnitId (Node Unit ID) of that AIU which is the bit position.</p><p>In the write bit mask, the number of bits set to 1 is nCachingAgents. (NOTE: nCachingAgents is less than or equal to nAius).</p><p>DCE uses the values in the array of ca_aiu_n_unit_id (Node Unit IDs from DCE snoop capable AIUs; connected to DCE as input port) to generate the write bit mask.</p><p>&quot;&quot;&quot;&quot;</p><p>DCE generates a target enable bit vector of width=nCachingAgents, by matching the ca_n_unit_id_array (array length is nCachingAgents) with the corresponding bits in the DCE Snoop Enable Register.</p><p>The target enable bit vector is fed to the DCE transaction manager for snoop control: if the bit for a target is set, then snoop can be sent to that target, otherwise no snoop can be sent to that target.</p><p><br/></p><p><strong>Outstanding Questions</strong></p><p>1.Currently DCE has an input port “ca_f_unit_id” which is a bundle of an array of Caching Agent’s FUnitId.</p><p>ca_f_unit_id[N] corresponds to Caching Agent Id=N.    In other words, ca_f_unit_id array is ordered with respect to the Caching Agent Ids.</p><p><br/></p><p>2. Sys.Event Sender has sender enable. Sys.Event Receiver has receiver enable.</p><p>But Sys.Coh Sender doesn't have sender enable, and Sys.Coh Receiver doesn't have receiver enable either. =&gt; These are fine. Not a problem.</p><p><br/></p><p><br/></p><p>3.CHI-AIU SysCo is always HW interface driven. So why the architecture spec also shows CSR-driven SysCo in CHI-AIU?</p><p>Use case is either HW SysCo or CSR-SysCo, NOT both. (CSR-SysCo is a fallback for SW)</p><p><br/></p><p>4.SysReq packet shows there's a field for &quot;R_Message_Id&quot;. What's the use for it?</p><p><br/></p><p>5.What is the definition for ExMon event? The ExMon state bit vector change? i.e. any write event to the ExMon state bit vector.</p><p><br/></p><p>assign exmon_cond_sel[0] = msg_type_load &amp; ~match_tm_addr &amp; 1'b1 &amp; 1'b1 &amp; ~new_tm_avail;<br/>assign exmon_cond_sel[1] = msg_type_load &amp; ~match_tm_addr &amp; 1'b1 &amp; 1'b1 &amp; new_tm_avail;<br/>assign exmon_cond_sel[2] = msg_type_load &amp; match_tm_addr &amp; 1'b1 &amp; 1'b1 &amp; 1'b1;<br/>assign exmon_cond_sel[3] = msg_type_store &amp; ~match_tm_addr &amp; 1'b1 &amp; ~bm_valid &amp; ~new_tm_avail;<br/>assign exmon_cond_sel[4] = msg_type_store &amp; ~match_tm_addr &amp; 1'b1 &amp; ~bm_valid &amp; new_tm_avail;<br/>assign exmon_cond_sel[5] = msg_type_store &amp; ~match_tm_addr &amp; 1'b1 &amp; bm_valid &amp; 1'b1;<br/>assign exmon_cond_sel[6] = msg_type_store &amp; match_tm_addr &amp; ~match_tm_valid &amp; 1'b1 &amp; 1'b1;<br/>assign exmon_cond_sel[7] = msg_type_store &amp; match_tm_addr &amp; match_tm_valid &amp; 1'b1 &amp; 1'b1;</p><p><br/></p><p>For Tagged Monitors:</p><p>assign <strong>addr_cam__cam_wr</strong> = ( exmon_cond_sel[1] | exmon_cond_sel[4] ) &amp; valid_lock_op;</p><p><br/></p><p>For Basic Monitors:</p><p>\js for (var i=0; i &lt; nTaggedMonitors; i++) {</p><p>wire [\=nProcs-1=\:0] mon\=i=\_bitvec;</p><p>    \js for (var j=0; j &lt; nProcs; j++) {</p><p>assign <strong>mon\=i=\_wren\=j=\</strong> = ( mon\=i=\_clr\=j=\ | mon\=i=\_set\=j=\ ) &amp; valid_lock_op;</p><p>assign mon\=i=\_set\=j=\ = ( proc_id_onehot_int[\=j=\] &amp; exmon_cond_sel[1] &amp; tm_mon_valid_sel[\=i=\]) |<br/>( proc_id_onehot_int[\=j=\] &amp; exmon_cond_sel[4] &amp; tm_mon_valid_sel[\=i=\]) |<br/>( proc_id_onehot_int[\=j=\] &amp; exmon_cond_sel[2] &amp; match_tm_addr_vec[\=i=\] ) |<br/>( proc_id_onehot_int[\=j=\] &amp; exmon_cond_sel[6] &amp; match_tm_addr_vec[\=i=\] ) ;</p><p>assign mon\=i=\_clr\=j=\ = ( proc_id_onehot_int[\=j=\] &amp; exmon_cond_sel[1] &amp; ~tm_mon_valid_sel[\=i=\]) |<br/>( proc_id_onehot_int[\=j=\] &amp; exmon_cond_sel[4] &amp; ~tm_mon_valid_sel[\=i=\]) |<br/>( proc_id_onehot_int[\=j=\] &amp; exmon_cond_sel[2] &amp; ~match_tm_addr_vec[\=i=\]) |<br/>( proc_id_onehot_int[\=j=\] &amp; exmon_cond_sel[6] &amp; ~match_tm_addr_vec[\=i=\]) |<br/>( proc_id_onehot_int[\=j=\] &amp; exmon_cond_sel[0] ) |<br/>( proc_id_onehot_int[\=j=\] &amp; exmon_cond_sel[3] ) |<br/>( exmon_cond_sel[7] &amp; match_tm_valid_vec[\=i=\]) ;</p><p>    \js }</p><p>\js }</p><p><br/></p><p>6.EventIn and EventOut interface is implemented using InterfaceGeneric, instead of the existing InterfaceEvt.</p><p><br/>See email titled &quot;Ncore 3.2 SYS message class and Generic Interface for Event&quot; dated &quot;Tuesday, July 6, 2021&quot;</p><p>&quot;&quot;&quot;&quot;</p><p>Note that the “uEvtOutInt” interface object is of type InterfaceGeneric, instead of InterfaceEvt.</p><p>Because InterfaceEvt has two signals “val” and “ack” and they are not symmetric (if the width parameter is 1, then only “val” exists; if the width is N&gt;= 2, then val[N-1:0] and ack exists).</p><p>&quot;&quot;&quot;&quot;</p><p>As a result,</p><p>EventIn interface that is a 2-wire req-ack interface has the following interface signals &quot;in&quot; (for req) and &quot;out&quot; (for ack).</p><p>EventOut interface that is a 2-wire req-ack interface has the following interface signals &quot;in&quot; (for ack) and &quot;out&quot; (for req).</p><p>Do we want to create InterfaceSysEvt.interface.cpr for the EventIn interface and EventOut interface.</p><p><br/></p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">InterfaceSysEvt.interface.cpr
=============================
{
  &quot;name&quot;: &quot;InterfaceSysEvt&quot;,
  &quot;interface&quot;: [
    {
      &quot;name&quot;: &quot;InterfaceSysEvt&quot;,
      &quot;signals&quot;: [
        {
          &quot;name&quot;: &quot;ack&quot;,
          &quot;type&quot;: &quot;logic&quot;,
          &quot;dir&quot;: &quot;m_in&quot;,
          &quot;excludable&quot;: false,
          &quot;width&quot;: &quot;1&quot;
        },
        {
          &quot;name&quot;: &quot;req&quot;,
          &quot;type&quot;: &quot;logic&quot;,
          &quot;dir&quot;: &quot;m_out&quot;,
          &quot;excludable&quot;: false,
          &quot;width&quot;: &quot;1&quot;
        }
      ]
    }
  ]
}

Questions from DV:
1. Should DCE stop sending SnpReqs to the AIU[x] as soon as it receives SysReq.Detach (i.e., Before DCE issues SysRsp)?
2. Does ACE have hardware pin support or ACE should do it through CSR&#39;s?
	ACE doesn&#39;t have hardware pin support and thus it is done through CSR&#39;s.
3. Is DCEUSER still RW for software (i.e., Can software directly write 1/0 to snoop enable register in DCE)?
4. If SER bit for a particular AIU is &quot;0&quot; DCE should not expect any Coherent cmds. If that&#39;s true how should DCE behave when there is a stash from ACELITE-E?
5. IOAIU (proxy cache) steps it has to follow (Flushing its cache) before it sends the Detach?
6. Is DVE&#39;s behavior same as DCE&#39;s and steps that agents should do before sending Detach to DVE?


</pre>
</div></div><p><br/></p><p><br/></p><p><br/></p><p><br/></p>