<p> </p><p>Agenda</p><p>2 hrs - Architectural Requirements for Maestro Data Model - Manadher</p><p>4 hrs - Technical requirements of the Data model - All</p><p>2 hrs - Modules and Data Flow next level details - Manadher</p><p> </p><p>Editing data - should do asap validation of the data.</p><p>System validation requires</p><ul style="list-style-type: square;"><li>Awareness of contex that can make some sanitization</li><li>Data access and data segmentation trade-offs</li><li>ASAP and incremental validation</li><li>You are in a context exclusively.  discussion on going back to a previous context, what it does, what it invalidates, etc.</li><li>New spec leans toward propagating changes and invalidate as little as possible;  could be difficult in implementation.</li></ul><p>Uniformity to allow different engines to read each others data.</p><ul style="list-style-type: square;"><li>Graph traversal of connected data</li><li>Algorithms need to go through data in a complete way</li><li>APIs should make it easy to access the data but make their containers hidden</li><li>Repeatability on constant inputs</li><li>Everything that can be traversed needs to have an iterator that does not require knowledge of the data container</li><li>Iterators can have filters.</li></ul><p>Data Orientated architecture is a requirement</p><ul><li>Requirement is to have a flow for parameters from BtB into C++ (params, constraints and derivations)</li><li>Requirement is to at run time to be able to change entity types (AI - Manadher to give use case)</li></ul><p>Data Structures</p><ul><li>As much as possible support static type checking</li><li>SW Fundamentals and Best Practices</li></ul><p>Parallelism is a requirement for scalability and performance.</p><p>Maestro architecture to support multi-threading where it makes sense.  Need criteria (ex: parameter handlers and multiple algorithm).  Application responsibility to keep it safe.</p><ul style="list-style-type: square;"><li>Example approach: GUI, DB single-threaded; applications can be multi-threaded; access from application to the GUI goes through single lock (or other technique) which limits the performance speed-up.</li></ul><p> </p><p> </p><p> </p><p><strong>LibDM is the DM for all the data captured from the user; HW related types come from BtB.  Other user types may come from BtB.</strong></p><p><strong>Not all information in LibDM needs to be in BtB but we may chose to require that for uniformity.</strong></p><p><strong>While LibDM is a ECS (Entity Component System) architecture, which captures the problem domain, the rest of the DM for the solution domain will be OOP based.</strong></p><ul style="list-style-type: square;"><li><strong>While we could extend all the DM to be ECS, that is not our architectural direction.</strong></li></ul><p><strong>Need an architectural solution for interfacing between ECS and OOP.</strong></p><p><strong>Complex modules are likely to require a component that generates a derive/extend DM to fit the needs of the application and the design objective is to make that component as simple as possible.</strong></p><p> </p><p><strong>Follow-up Items</strong></p><ol><li>Data Segmentation</li><li>Reconcile Invalidation - ncore3 flow; new presto flow</li><li>Error handling with TCL scripting</li><li>Repeatability</li><li>ECO Mode</li><li>Dynamic entity type handlling</li><li>Multi-threading criteria and concerns that need to be addressed</li></ol><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p>