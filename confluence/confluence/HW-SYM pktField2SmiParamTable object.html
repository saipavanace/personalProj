<h2 id="HW-SYMpktField2SmiParamTableobject-Location:">Location:</h2><p>&lt;workarea&gt;/hw-sym/js/pkt2Smi.js</p><h2 id="HW-SYMpktField2SmiParamTableobject-Usage:">Usage:</h2><p>var pktField2SmiParamTable<span> </span>= obj.userLib.smiLib.pktField2SmiParamTable;</p><p>The above object provides the following methods:</p><p><strong>function pktFld2SmiParam(fieldName)</strong><br/><strong>function pktDef2SmiParams(packetArray, nSmiVC=1, nSmiDPvc=1, extras={})</strong><br/><strong>function pktDef2SmiInterface(packetArray,direction,name=&quot;&quot;,nSmiVC=1,nSmiDPvc=1,extras={})</strong></p><p>-fieldName: a string. It is the name of the field as it appears in the link packet definition with the integer suffix at the end of string removed.<br/>-packetArray is an array of packet field descriptions (Example: linkPktdef.packets[0].packet or Value returned by getPacketArray( ) function)<br/>-nSmiVC : an integer. It is the number of VCs in SMI NDP<br/>-nSmiDPvc: an integer. It is the number of VCs in SMI DP<br/>-extras is an object that can be used to optionally overwrite or add additional SMI params. To be specified as { &quot;SMI-signal1&quot;: signal-width1, &quot;SMI-signal2&quot;: signal-width2... }<br/>-name is a string that is used as a prefix for signal names in the SMI interface to be generated.<br/>-direction is a string. This can take only following values - 'master' and 'slave'.</p><h2 id="HW-SYMpktField2SmiParamTableobject-Description:">Description:</h2><p>The purpose of this object is to provide methods to derive SMI interface and SMI interface parameters from a link packet definition when available.</p><p>The pktFld2SmiParam(...) method takes as input a packet field name (string) and is used to lookup an internal table to return the corresponding SMI signal-width parameter.</p><p>The pktDef2SmiParams(...) method takes as input at least the packet array (which can be obtained from a link packet definition) and returns an object of SMI parameter names as keys and their widths as values. Optionally number of VCs can be passed for each of the sub-interfaces (ndp and dp). In addition, an optional parameter object, extras can be passed to provide additional SMI parameter values or overwrite SMI parameter values that cannot be derived from link packet definitions.</p><p>The pktDef2SmiInterface(...) method takes in addition to the parameters described in the function above, two other parameters - direction and name. direction specifies whether the interface to be generated is to be a master or a slave interface. And name is the prefix that is added to all signal names in the interface. This function returns a SMI interface instance object, instantiated via SMI parameters computed from the function above. The SMI interface instance object returned can then be used to generate signal names and widths using interface methods.</p><h2 id="HW-SYMpktField2SmiParamTableobject-Examples:">Examples:</h2><p>The <strong>pktField2SmiParamTable</strong> object can be accessed from through<br/><strong>obj.userLib.smiLib</strong></p><p>const p2s             = obj.userLib.smiLib.pktField2SmiParamTable;</p><p><strong>Fetching SMI width params from field names individually:<br/></strong>p2s.pktFld2SmiParam(&quot;H_tier&quot;)  // returns string &quot;wSmiTier&quot;<br/>p2s.pktFld2SmiParam(&quot;H_route&quot;) // returns string &quot;wSmiRoute&quot;<br/>p2s.pktFld2SmiParam(&quot;H_abcd&quot;) // throws an errror saying packet field doesn't exist in table.</p><p><strong>Fetching SMI params object (parameter names as keys, widths as values):<br/></strong>const interfaces     = obj.userLib.hierGetParam('interfaces',u.getParam); // Read the interfaces parameter for your block<br/>const packet          = new obj.userLib[interfaces.inInterface.pktDef.packet];   // inInterface is assumed to be of type ATP here<br/>const packetArray  = packet.getPacketArray(interfaces.inInterface.pktDef.packet); // Get the packet array which is just an array of field descriptions.</p><p>p2s.pktDef2SmiParams(packetArray) // returns an object: { nSmiVC: 1, nSmiDPvc: 1, wSmiRoute: 6.... }<br/>p2s.pktDef2SmiParams(packetArray, 4, 4) // returns { nSmiVC: 4, nSmiDPvc: 4, wSmiRoute: 6.... }<br/>p2s.pktDef2SmiParams(packetArray,1,1,{&quot;wSmiRoute&quot;: 0}) // Overwrite width of SMI route field with extras object. Returns { nSmiVC: 4, nSmiDPvc: 4, wSmiRoute: 0.... } <br/><br/><strong>Fetching SMI interface from packet definition</strong><br/>const interfaces     = obj.userLib.hierGetParam('interfaces',u.getParam); // Read the interfaces parameter for your block<br/>const packet          = new obj.userLib[interfaces.inInterface.pktDef.packet];   // inInterface is assumed to be of type ATP here<br/>const packetArray  = packet.getPacketArray(interfaces.inInterface.pktDef.packet); // Get the packet array which is just an array of field descriptions.</p><p>const smiInterface= p2s.pktDef2SmiInterface(packetArray,&quot;slave&quot;,&quot;smi_&quot;)  // returns an object like this: { name: &quot;smi_&quot;, interface: &quot;InterfaceSMI&quot;, params: { nSmiVC: 1, nSmiDPvc: 1, wSmiRoute: 6.... }, direction: &quot;slave&quot; }<br/>const smiInstance = new obj.userLib[smiInterface.interface] or<br/>                                 new obj.userLib[&quot;InterfaceSMI&quot;] // Create an instance of InterfaceSMI<br/>const smiSignals   = smiInstance.getSignalsBundle(smiInterface.params); // Pass in derived-SMI-interface params to getSignalsBundle to return an object like this: { &quot;ndp_&quot;: {&quot;valid&quot;: 1, &quot;ready&quot;: -1, &quot;msg_addr&quot;: 6, ...}, &quot;dp_&quot;: { &quot;valid: 1, &quot;ready&quot;: -1, &quot;data&quot;: 32, ... } }<br/><br/></p><h2 id="HW-SYMpktField2SmiParamTableobject-Updatingthetables:">Updating the tables:</h2><p>To update the tables in <strong>pktField2SmiParamTable</strong> object or fix anything, you need to update the script that generates <strong>pkt2Smi.js</strong> which is <strong>gen_smi_lib.js </strong>which reads the <strong>interface_param_map.json </strong>to generate the tables inside pkt2Smi.js. Whenever there are a new set of parameters or signals are added in the spreadsheet, the steps to be followed to update even the interface_param_map.json are on this page:<br/><br/><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16162609/HW-SYM+Updating+Symphony+CPR+and+TACHL+libraries+to+match+protocol+translation+spreadsheet" data-linked-resource-id="16162609" data-linked-resource-version="13" data-linked-resource-type="page">HW-SYM Updating Symphony CPR and TACHL libraries to match protocol translation spreadsheet</a></p>