<p>The main component in the performance monitoring and debug infrastructure is the PMON Stats block which is describe below (3.9.1). The registers in the link probes and the ATUs can be used to generate events that a Stats block can receive. The other important component associated with performance monitoring is the link probe which is described in section 3.4.6.</p><h2 id="id-3.9-PMON-3.9.1PMONStats">3.9.1 PMON Stats</h2><p>The PMON Stats block provides a pool of counters that can also work as timers. Every PMON timer has start, stop, reset, and count inputs, which can be driven by a set of events listed in the <em>tmrEvtMap</em> data-structure parameter. Each of the timers has a tmr_out output signal which in turn can be used to generate interrupts or other events to count other counters or timers.</p><p> </p><p><span class="confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image image-center" height="400" src="https://arterisip.atlassian.net/wiki/download/attachments/16169589/image2019-11-8%2016:38:1.png?api=v2"></span></p><p> </p><p>The following list of parameters are used to generate the block:</p><p><strong>baseAddress:</strong> A non-negative integer. This sets the baseAddress for all the registers generated.</p><p><strong>nodeID:</strong> A non-negative integer distinct from that of all other blocks in Symphony.</p><p><strong>tmrEvtMap:</strong> This is an array of objects, each of which defines a timer and the list of events to drive each input of the timer. Below is the structure of each of these objects:</p><p> {</p><p>   <strong>name:</strong> A string that is the name of the timer.<br/>   <strong>width:</strong> A positive integer that becomes the width of this timer.<br/>   <strong>iEvtMap:</strong> An array of objects, each of which specifies the list of events to choose from for each of the timer inputs. The array is expected to have as many objects as the number of timer inputs or less.<br/>   <strong>oEvtMap:</strong> An array of objects, each of which specifies the list of events to choose from for each of the timer inputs. The array is expected to have only one entry corresponding to the only timer output - &quot;tmr&quot;.</p><p> }</p><p>The structure of each object in the <em>iEvtMap</em> or <em>oEvtMap</em> arrays is described below:</p><p>{</p><p>  <strong>input:</strong> A string that is one of the following - &quot;start&quot;, &quot;stop&quot;, &quot;reset&quot;, &quot;count&quot; for iEvtMap and &quot;tmr&quot; for oEvtMap.<br/>  <strong>evts:</strong> An array of strings each of which is one of the following events - &quot;iEvt_i&quot;, &quot;tEvt_i&quot;, and &quot;int_i&quot; (for oEvtMap only), where i is a non-negative integer suffix. For <em>iEvtMap</em> this specifies the list of selectable events to choose as input. For <em>oEvtMap</em>, this specifies the list of events to map the timer output event to.</p><p>}</p><p><strong>evtDefines:</strong> This is an array of objects. Each object defines one of the events generated by the probe. Hence the length of this array corresponds to the number of events generated by the probe. Each object in the array has the following structure:</p><p>{</p><p>  <strong>id</strong>: A non-negative integer distinct from ids of all other events in the array.<br/>  <strong>conditions</strong>: An array of strings each of which is a Verilog expression that describes the condition for generating this event.<br/>}</p><p>The possible Verilog expressions supported in the <em>conditions</em> array and the list of signal names that can be used are limited. Below is a list of supported expressions:</p><ol><li>Expressions with a signal_name or a constant and possibly a unary operator. Ex: &quot;iEvt_2&quot;, &quot;1'b0&quot;, &quot;3'd2&quot;.</li><li>Expressions with a binary operator separating two signals or a signal and a constant. Only the following list of relational and equality operators are supported: '&gt;', '&lt;', '&gt;=', '&lt;=', '==', '!='. Ex: &quot;tEvt_3 == cfg_cmp_val1&quot;.</li><li>Expressions with a binary operator separated by expressions of type 1 or 2. The list of operators supported are the same as in 2. Ex: &quot;iEvt_3  &amp;&amp; tEvt_2&quot;.</li></ol><p>The list of signal names supported are &quot;iEvt&quot;, &quot;tEvt&quot;, &quot;int&quot; with a suffix of &quot;_i&quot; where i is any non-negative integer. The iEvts refer to events that are inputs to the block, the tEvts refer to internally generated events, and the ints refer to interrupts generated from the block.</p><p> </p>