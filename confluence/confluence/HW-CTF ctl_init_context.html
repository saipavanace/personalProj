<p><strong>module_name:</strong></p><p><span>ctl_init_context</span></p><p><span>Note: This module is undergoing major changes and probably wont be stable until the end of our first release.</span></p><p><span><style type='text/css'>/*<![CDATA[*/
div.rbtoc1759723455271 {padding: 0px;}
div.rbtoc1759723455271 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1759723455271 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class='toc-macro rbtoc1759723455271'>
<ul class='toc-indentation'>
<li><a href='#HW-CTFctl_init_context-Features'>Features</a></li>
<li><a href='#HW-CTFctl_init_context-I/O'>I/O</a>
<ul class='toc-indentation'>
<li><a href='#HW-CTFctl_init_context-Parameters'>Parameters</a></li>
</ul>
</li>
<li><a href='#HW-CTFctl_init_context-ModulesUsed'>Modules Used</a>
<ul class='toc-indentation'>
<li><a href='#HW-CTFctl_init_context-ControlInterfaces'>Control Interfaces</a></li>
<li><a href='#HW-CTFctl_init_context-ContextKeys'>Context Keys</a></li>
<li><a href='#HW-CTFctl_init_context-InternalParameterDefinitions'>Internal Parameter Definitions</a></li>
<li><a href='#HW-CTFctl_init_context-FunctionalSections'>Functional Sections</a>
<ul class='toc-indentation'>
<li><a href='#HW-CTFctl_init_context-Mechanics'>Mechanics</a>
<ul class='toc-indentation'>
<li><a href='#HW-CTFctl_init_context-ValidReadySignalingonRequest'>Valid Ready Signaling on Request</a></li>
<li><a href='#HW-CTFctl_init_context-ValidReadySignalingonResponse'>Valid Ready Signaling on Response</a></li>
<li><a href='#HW-CTFctl_init_context-PerContextLoop'>Per Context Loop</a></li>
<li><a href='#HW-CTFctl_init_context-RequestBlockingLogic'>Request Blocking Logic</a></li>
<li><a href='#HW-CTFctl_init_context-ResponseBlockingLogic'>Response Blocking Logic</a></li>
<li><a href='#HW-CTFctl_init_context-NonContextRegister'>Non Context Register</a></li>
<li><a href='#HW-CTFctl_init_context-response_matched_entry_vec'>response_matched_entry_vec</a></li>
<li><a href='#HW-CTFctl_init_context-FindError'>Find Error</a></li>
<li><a href='#HW-CTFctl_init_context-FindEntry'>Find Entry</a></li>
</ul>
</li>
<li><a href='#HW-CTFctl_init_context-BurstTypeModificationintoContext'>Burst Type Modification into Context</a></li>
<li><a href='#HW-CTFctl_init_context-LastDPBeatIndicator'>Last DP Beat Indicator</a></li>
<li><a href='#HW-CTFctl_init_context-Busy'>Busy</a></li>
<li><a href='#HW-CTFctl_init_context-ErrorDetectionLogic'>Error Detection Logic</a>
<ul class='toc-indentation'>
<li><a href='#HW-CTFctl_init_context-ExclusiveErrorLogic'>Exclusive Error Logic</a></li>
<li><a href='#HW-CTFctl_init_context-DomainErrorLogic'>Domain Error Logic</a></li>
<li><a href='#HW-CTFctl_init_context-RWErrorLogic'>RW Error Logic</a></li>
<li><a href='#HW-CTFctl_init_context-DecodeError'>Decode Error</a></li>
<li><a href='#HW-CTFctl_init_context-TimeoutError'>Timeout Error</a></li>
<li><a href='#HW-CTFctl_init_context-SeqnumAlignFIFOforTimeoutError'>Seqnum Align FIFO for Timeout Error</a></li>
<li><a href='#HW-CTFctl_init_context-DropFromError'>Drop From Error</a></li>
</ul>
</li>
<li><a href='#HW-CTFctl_init_context-ErrorResponseGeneration'>Error Response Generation</a></li>
<li><a href='#HW-CTFctl_init_context-ErrorLock'>Error Lock</a></li>
<li><a href='#HW-CTFctl_init_context-TargetIDLock'>Target ID Lock</a></li>
<li><a href='#HW-CTFctl_init_context-SplittingResponseAccumulation'>Splitting Response Accumulation</a></li>
<li><a href='#HW-CTFctl_init_context-ReserveBeatBufferIndicator'>Reserve Beat Buffer Indicator</a></li>
<li><a href='#HW-CTFctl_init_context-BeatNumberCalculation'>Beat Number Calculation</a></li>
<li><a href='#HW-CTFctl_init_context-StatsInterfaceLogic'>Stats Interface Logic</a></li>
<li><a href='#HW-CTFctl_init_context-BufferedWriteLogic'>Buffered Write Logic</a></li>
<li><a href='#HW-CTFctl_init_context-RequestDataInterfaceDriver'>Request Data Interface Driver</a></li>
<li><a href='#HW-CTFctl_init_context-ResponseDataInterfaceDriver'>Response Data Interface Driver</a></li>
<li><a href='#HW-CTFctl_init_context-CompressedIDLogic'>Compressed ID Logic</a></li>
<li><a href='#HW-CTFctl_init_context-ReadInterleaveBarrier'>Read Interleave Barrier</a></li>
<li><a href='#HW-CTFctl_init_context-ResponseLookups'>Response Lookups</a></li>
<li><a href='#HW-CTFctl_init_context-DataWidthAdaptionBeatMasking'>Data Width Adaption Beat Masking</a></li>
<li><a href='#HW-CTFctl_init_context-NDPSuppression'>NDP Suppression</a></li>
<li><a href='#HW-CTFctl_init_context-SequenceNumberCapture'>Sequence Number Capture</a></li>
<li><a href='#HW-CTFctl_init_context-SequenceNumberGenerationandHandling'>Sequence Number Generation and Handling</a></li>
<li><a href='#HW-CTFctl_init_context-TransactionCounter'>Transaction Counter</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div></span></p><h1 id="HW-CTFctl_init_context-Features"><strong>Features</strong></h1><p><br/></p><div class="page view"><h1 id="HW-CTFctl_init_context-I/O"><strong>I/O</strong></h1><div class="table-wrap"><table class="wrapped relative-table confluenceTable" style="width: 54.3653%;"><colgroup><col style="width: 25.958%;"/><col style="width: 13.9431%;"/><col style="width: 10.2349%;"/><col style="width: 49.7404%;"/></colgroup><tbody><tr><th class="confluenceTh">Interface/Port Name</th><th colspan="1" class="confluenceTh">Condition</th><th colspan="1" class="confluenceTh">Direction</th><th class="confluenceTh">Description</th></tr><tr><td class="confluenceTd">clkInterface</td><td colspan="1" class="confluenceTd">Always</td><td colspan="1" class="confluenceTd">slave</td><td class="confluenceTd">The Clock Interface with clk and reset</td></tr><tr><td class="confluenceTd"><p>requestInterfaceIn</p><p>requestInterfaceOut</p></td><td colspan="1" class="confluenceTd">Always</td><td colspan="1" class="confluenceTd"><p>slave</p><p>master</p></td><td class="confluenceTd">The CTL Request interface coming in and and going out. This interface contains all lookup values from PAM and needed information from the splitting block.</td></tr><tr><td class="confluenceTd"><p>responseInterfaceIn</p><p>responseInterfaceOut</p></td><td colspan="1" class="confluenceTd">Always</td><td colspan="1" class="confluenceTd"><p>slave</p><p>master</p></td><td class="confluenceTd">The CTL Response interface coming in and and going out. The NDP portion of the response flows through the context block and the context block generates responses on this interface.</td></tr><tr><td class="confluenceTd">responseDpInterfaceIn</td><td colspan="1" class="confluenceTd">Always</td><td colspan="1" class="confluenceTd">slave</td><td class="confluenceTd">This is the CTL DP Response interface used for counting beats of a response. This interface spys the DP interface as it does not flow through the context.</td></tr><tr><td class="confluenceTd">dpRespCtxtInterface</td><td colspan="1" class="confluenceTd">Always</td><td colspan="1" class="confluenceTd">master</td><td class="confluenceTd">This interface contains information for narrow handling, error response generation, and data width adaption support to the response datapath.</td></tr><tr><td class="confluenceTd">ctlReqCtxttoQueueInterface</td><td colspan="1" class="confluenceTd">Always</td><td colspan="1" class="confluenceTd">master</td><td class="confluenceTd">This interface carries information needed by the queue block. (Minimal in R1)</td></tr><tr><td class="confluenceTd">dpReqCtxtInterface</td><td colspan="1" class="confluenceTd">Always</td><td colspan="1" class="confluenceTd">master</td><td class="confluenceTd">This interface carries error and narrow info to the request datapath.</td></tr><tr><td class="confluenceTd"><p>statsTMask</p><p>statsTarg</p><p>statsNewEntry</p><p>statsClearEntry</p></td><td colspan="1" class="confluenceTd">enStats</td><td colspan="1" class="confluenceTd"><p>input</p><p>input</p><p>output</p><p>output</p></td><td class="confluenceTd">These ports contain the statistics indicators to when an entry is set or cleared. In addition the events can be masked based on the target mask in startsTarg. This is enabled through statsTMask</td></tr><tr><td class="confluenceTd">externalTimeoutValue</td><td colspan="1" class="confluenceTd">timeoutErrChk &amp; useExternalTimeout</td><td colspan="1" class="confluenceTd">input</td><td class="confluenceTd">This port carries the timeout amount if defined by registers.</td></tr><tr><td colspan="1" class="confluenceTd">timeoutErrror_seqnum_poison</td><td colspan="1" class="confluenceTd">timeoutErrChk</td><td colspan="1" class="confluenceTd">output</td><td colspan="1" class="confluenceTd">This port informs the ROB what sequence numbers are poisoned in a timeout to clear thier entries. </td></tr><tr><td colspan="1" class="confluenceTd">context_entry_dependency</td><td colspan="1" class="confluenceTd">!noContext</td><td colspan="1" class="confluenceTd">output</td><td colspan="1" class="confluenceTd">Unused in R1</td></tr><tr><td colspan="1" class="confluenceTd"><p>timeoutError</p><p>bufferedWriteError</p><p>rwError</p><p>decodeError</p><p>transportError</p><p>exclusiveError</p><p>domainError</p><p>timeoutErrorTargId</p><p>bufferedWriteErrorTargId</p><p>rwErrorTargId</p><p>decodeErrorTargId</p><p>transportErrorTargId</p><p>exclusiveErrorTargId</p><p>domainErrorTargId</p></td><td colspan="1" class="confluenceTd">Always</td><td colspan="1" class="confluenceTd"><p>output</p><p>output</p><p>output</p><p>output</p><p>output</p><p>output</p><p>output</p><p>output</p><p>output</p><p>output</p><p>output</p><p>output</p><p>output</p><p>output</p></td><td colspan="1" class="confluenceTd">Contains the Error Information to be sent to the registers. All errors are detected and handles inside the context. </td></tr><tr><td colspan="1" class="confluenceTd">aligned_event</td><td colspan="1" class="confluenceTd">enBufWrite | rwResponseGenerationFromError</td><td colspan="1" class="confluenceTd">input</td><td colspan="1" class="confluenceTd">Signal indicating when a full data packet has been sent. </td></tr><tr><td colspan="1" class="confluenceTd"><p>ctl_req_dependency</p><p>ctl_req_dependency_seqnum</p></td><td colspan="1" class="confluenceTd">have_seqnum</td><td colspan="1" class="confluenceTd"><p>output</p><p>output</p></td><td colspan="1" class="confluenceTd">Signals indicating if a transaction has a dependency on another sequence number. This is to be used by the RoB</td></tr><tr><td colspan="1" class="confluenceTd">ctl_req_reserveBeatBuffer</td><td colspan="1" class="confluenceTd">reserveBeatBuffer</td><td colspan="1" class="confluenceTd">output</td><td colspan="1" class="confluenceTd">Signal indicating that a beat buffer is needed for the transaction. This originates in the PAM and can be modified inside the context block.</td></tr><tr><td colspan="1" class="confluenceTd">busy</td><td colspan="1" class="confluenceTd">Always</td><td colspan="1" class="confluenceTd">output</td><td colspan="1" class="confluenceTd">Indicated if the context is busy</td></tr></tbody></table></div><h2 id="HW-CTFctl_init_context-Parameters"><strong>Parameters</strong></h2><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Parameter</th><th class="confluenceTh">Type</th><th colspan="1" class="confluenceTh">Description</th></tr><tr><td class="confluenceTd">dpRespCtxtInterface</td><td class="confluenceTd">Object</td><td colspan="1" class="confluenceTd">The interface definition for the dpRespCtxtInterface interface.</td></tr><tr><td class="confluenceTd">requestInterfaceIn</td><td class="confluenceTd">Object</td><td colspan="1" class="confluenceTd">The interface definition for the requestInterfaceIn interface.</td></tr><tr><td class="confluenceTd">responseInterfaceIn</td><td class="confluenceTd">Object</td><td colspan="1" class="confluenceTd">The interface definition for the responseInterfaceIn interface.</td></tr><tr><td class="confluenceTd">requestInterfaceOut</td><td class="confluenceTd">Object</td><td colspan="1" class="confluenceTd">The interface definition for the requestInterfaceOut interface.</td></tr><tr><td class="confluenceTd">requestInterfaceOut</td><td class="confluenceTd">Object</td><td colspan="1" class="confluenceTd">The interface definition for the requestInterfaceOut interface.</td></tr><tr><td class="confluenceTd">responseDpInterfaceIn</td><td class="confluenceTd">Object</td><td colspan="1" class="confluenceTd">The interface definition for the responseDpInterfaceIn interface.</td></tr><tr><td class="confluenceTd">ctlReqCtxttoQueueInterface</td><td class="confluenceTd">Object</td><td colspan="1" class="confluenceTd">The interface definition for the ctlReqCtxttoQueueInterface interface.</td></tr><tr><td class="confluenceTd">clkInterface</td><td class="confluenceTd">Object</td><td colspan="1" class="confluenceTd">The interface definition for the clkInterface interface.</td></tr><tr><td class="confluenceTd">dpReqCtxtInterface</td><td class="confluenceTd">Object</td><td colspan="1" class="confluenceTd">The interface definition for the dpReqCtxtInterface interface.</td></tr><tr><td class="confluenceTd">nContextEntries</td><td class="confluenceTd">int</td><td colspan="1" class="confluenceTd">The number of context entries to be made.</td></tr><tr><td class="confluenceTd">idCompMask</td><td class="confluenceTd">Object</td><td colspan="1" class="confluenceTd">The object defining what bits of incoming ID to be used for the outgoing id. </td></tr><tr><td class="confluenceTd">nOutstandingReads</td><td class="confluenceTd">int</td><td colspan="1" class="confluenceTd">The number possible outstanding reads.</td></tr><tr><td class="confluenceTd">nOutstandingWrites</td><td class="confluenceTd">int</td><td colspan="1" class="confluenceTd">The number possible outstanding writes.</td></tr><tr><td class="confluenceTd">nOutstanding</td><td class="confluenceTd">int</td><td colspan="1" class="confluenceTd">The number possible outstanding transactions.</td></tr><tr><td class="confluenceTd">wQueue</td><td class="confluenceTd">int</td><td colspan="1" class="confluenceTd">The width of the queue signal. (Can hold largest queue number)</td></tr><tr><td class="confluenceTd">queueMap</td><td class="confluenceTd">Object</td><td colspan="1" class="confluenceTd">Object describing how a transaction is mapped to a queue.</td></tr><tr><td class="confluenceTd">readInterleave</td><td class="confluenceTd">bool</td><td colspan="1" class="confluenceTd">Indication the ATUI the context is in can support read interleaving.</td></tr><tr><td class="confluenceTd">nQueue</td><td class="confluenceTd">int</td><td colspan="1" class="confluenceTd">The number of queues inside the ATUI.</td></tr><tr><td class="confluenceTd">timingCritical</td><td class="confluenceTd">bool</td><td colspan="1" class="confluenceTd">(Not Used atm)</td></tr><tr><td colspan="1" class="confluenceTd">rdEn</td><td colspan="1" class="confluenceTd">bool</td><td colspan="1" class="confluenceTd">Reads are Enabled</td></tr><tr><td colspan="1" class="confluenceTd">wrEn</td><td colspan="1" class="confluenceTd">bool</td><td colspan="1" class="confluenceTd">Writes are Enabled</td></tr><tr><td colspan="1" class="confluenceTd">enStats</td><td colspan="1" class="confluenceTd">bool</td><td colspan="1" class="confluenceTd">Statistics are enabled.</td></tr><tr><td colspan="1" class="confluenceTd">maxPduSz</td><td colspan="1" class="confluenceTd">int</td><td colspan="1" class="confluenceTd">The max size of the transaction in bytes.</td></tr><tr><td colspan="1" class="confluenceTd">enRob</td><td colspan="1" class="confluenceTd">bool</td><td colspan="1" class="confluenceTd">Indication the outgoing transaction will go through a Reorder Buffer</td></tr><tr><td colspan="1" class="confluenceTd">vcMap</td><td colspan="1" class="confluenceTd">Object</td><td colspan="1" class="confluenceTd">How a queue is mapped to a VC</td></tr><tr><td colspan="1" class="confluenceTd">enExclusiveError</td><td colspan="1" class="confluenceTd">bool</td><td colspan="1" class="confluenceTd">Exclusive Errors are enabled.</td></tr><tr><td colspan="1" class="confluenceTd">haveDomainError</td><td colspan="1" class="confluenceTd">bool</td><td colspan="1" class="confluenceTd">Domain Errors are enabled.</td></tr><tr><td colspan="1" class="confluenceTd">rwResponseGenerationFromError</td><td colspan="1" class="confluenceTd">bool</td><td colspan="1" class="confluenceTd">Errors are enabled that can cause a read and or write response.</td></tr><tr><td colspan="1" class="confluenceTd">reserveBeatBuffer</td><td colspan="1" class="confluenceTd">bool</td><td colspan="1" class="confluenceTd">There is a beat buffer inside the ATUI.</td></tr><tr><td colspan="1" class="confluenceTd">contextKeys</td><td colspan="1" class="confluenceTd">Object</td><td colspan="1" class="confluenceTd">The object containing the context fields that are needed for this implementation of context</td></tr><tr><td colspan="1" class="confluenceTd">targ_id_lock</td><td colspan="1" class="confluenceTd">bool</td><td colspan="1" class="confluenceTd">Indication whether the context needs to lock ids with the target.</td></tr><tr><td colspan="1" class="confluenceTd">enBufWrite</td><td colspan="1" class="confluenceTd">bool</td><td colspan="1" class="confluenceTd">Buffered Writes are Enabled.</td></tr><tr><td colspan="1" class="confluenceTd">ctlPipeCtxt</td><td colspan="1" class="confluenceTd">int</td><td colspan="1" class="confluenceTd">Indication the context should be piped.</td></tr><tr><td colspan="1" class="confluenceTd">narrowSupported</td><td colspan="1" class="confluenceTd">bool</td><td colspan="1" class="confluenceTd">Indication the ATUI can recieve narrow transactions.</td></tr><tr><td colspan="1" class="confluenceTd">timeoutErrChk</td><td colspan="1" class="confluenceTd">bool</td><td colspan="1" class="confluenceTd">Indication whether timeout errors are enabled.</td></tr><tr><td colspan="1" class="confluenceTd">timeoutErrCount</td><td colspan="1" class="confluenceTd">int</td><td colspan="1" class="confluenceTd">The amount of cycles needed for a timeout error.</td></tr><tr><td colspan="1" class="confluenceTd">useExternalTimeout</td><td colspan="1" class="confluenceTd">bool</td><td colspan="1" class="confluenceTd">The timeout value will come from registers.</td></tr><tr><td colspan="1" class="confluenceTd">timeoutErrorWidth</td><td colspan="1" class="confluenceTd">int</td><td colspan="1" class="confluenceTd">The width of the timeout value.</td></tr><tr><td colspan="1" class="confluenceTd">wSmiOrderingId</td><td colspan="1" class="confluenceTd">int</td><td colspan="1" class="confluenceTd">The width of the ordering id on SMI.</td></tr><tr><td colspan="1" class="confluenceTd">widthAdaptionSupported</td><td colspan="1" class="confluenceTd">bool</td><td colspan="1" class="confluenceTd">Indication that the context could recieve responses with extra beats. </td></tr></tbody></table></div><p><br/></p><h1 id="HW-CTFctl_init_context-ModulesUsed"><strong>Modules Used</strong></h1><p><br/></p><p><strong style="font-size: 24.0px;">Description</strong></p><h2 id="HW-CTFctl_init_context-ControlInterfaces">Control Interfaces</h2><p>responseDpInterfaceIn</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Interface</th><th class="confluenceTh">Description</th></tr><tr><td class="confluenceTd">ctlRespDpInterface</td><td class="confluenceTd">A copy of the DP Interface signals</td></tr></tbody></table></div><p>dpRespCtxtInterface</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Signal</th><th class="confluenceTh">Width</th><th class="confluenceTh">Condition</th><th colspan="1" class="confluenceTh">Description</th></tr><tr><td class="confluenceTd">valid</td><td class="confluenceTd">1</td><td class="confluenceTd">Always</td><td colspan="1" class="confluenceTd">Valid data is being shown to the Response Datapath</td></tr><tr><td class="confluenceTd">drop</td><td class="confluenceTd">1</td><td class="confluenceTd">Always</td><td colspan="1" class="confluenceTd">Drop a beat of data if an ndp sequence number does not match.</td></tr><tr><td class="confluenceTd">mask_last</td><td class="confluenceTd">1</td><td class="confluenceTd">splitting || striping</td><td colspan="1" class="confluenceTd">Force last to 0 for split reads. </td></tr><tr><td class="confluenceTd">n_valid</td><td class="confluenceTd">1</td><td class="confluenceTd">narrowSupported</td><td colspan="1" class="confluenceTd">Valid narrow data is being shown to the Response Datapath</td></tr><tr><td class="confluenceTd">n_ready</td><td class="confluenceTd">-1</td><td class="confluenceTd">narrowSupported</td><td colspan="1" class="confluenceTd">Datapath is ready for the narrow data. </td></tr><tr><td class="confluenceTd">end_offset</td><td class="confluenceTd">log2ceil(wData/8)</td><td class="confluenceTd">narrowSupported</td><td colspan="1" class="confluenceTd">The offset within the beat the narrow transaction stops</td></tr><tr><td class="confluenceTd">start_offset</td><td class="confluenceTd">log2ceil(wData/8)</td><td class="confluenceTd">narrowSupported</td><td colspan="1" class="confluenceTd">The offset within the beat the narrow transaction starts</td></tr><tr><td class="confluenceTd">wrap_len</td><td class="confluenceTd">log2ceil(wData/8)</td><td class="confluenceTd">narrowSupported</td><td colspan="1" class="confluenceTd">The length of a wrap in bytes</td></tr><tr><td class="confluenceTd">burst_size</td><td class="confluenceTd">wBurstSize</td><td class="confluenceTd">narrowSupported</td><td colspan="1" class="confluenceTd">The burst size of the transaction</td></tr><tr><td class="confluenceTd">burst_type</td><td class="confluenceTd">wBurstType</td><td class="confluenceTd">narrowSupported</td><td colspan="1" class="confluenceTd">The burst type of the transaction.</td></tr><tr><td class="confluenceTd">dw_mask_valid</td><td class="confluenceTd">1</td><td class="confluenceTd">widthAdaptionSupported</td><td colspan="1" class="confluenceTd">Drop a beat of data from the data width adaption.</td></tr><tr><td class="confluenceTd">dw_force_last</td><td class="confluenceTd">1</td><td class="confluenceTd">widthAdaptionSupported</td><td colspan="1" class="confluenceTd">Force last on a beat of data from the data width adaption.</td></tr><tr><td class="confluenceTd">err_valid</td><td class="confluenceTd">1</td><td class="confluenceTd">rwResponseGenerationError</td><td colspan="1" class="confluenceTd">Valid error data is being shown to the Response Datapath</td></tr><tr><td colspan="1" class="confluenceTd">err_ready</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">rwResponseGenerationError</td><td colspan="1" class="confluenceTd">Datapath is ready for the error data. </td></tr><tr><td colspan="1" class="confluenceTd">err_beats</td><td colspan="1" class="confluenceTd">wCtlLen</td><td colspan="1" class="confluenceTd">rwResponseGenerationError</td><td colspan="1" class="confluenceTd">Amount of beats to be sent back for the error.</td></tr><tr><td colspan="1" class="confluenceTd">err_ordering_id</td><td colspan="1" class="confluenceTd">wCtllRespOrderingId</td><td colspan="1" class="confluenceTd">rwResponseGenerationError</td><td colspan="1" class="confluenceTd">The ordering id of the error txn.</td></tr><tr><td colspan="1" class="confluenceTd">err_channel_id</td><td colspan="1" class="confluenceTd">wCtllRespChannelId</td><td colspan="1" class="confluenceTd">rwResponseGenerationError</td><td colspan="1" class="confluenceTd">The channel id of the error txn.</td></tr><tr><td colspan="1" class="confluenceTd">err_id</td><td colspan="1" class="confluenceTd">wCtlId</td><td colspan="1" class="confluenceTd">rwResponseGenerationError</td><td colspan="1" class="confluenceTd">The id of the error txn.</td></tr><tr><td colspan="1" class="confluenceTd">err_last</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">rwResponseGenerationError &amp;&amp; (splitting || striping)</td><td colspan="1" class="confluenceTd">Indicating this is the last error txn in a split error txn</td></tr><tr><td colspan="1" class="confluenceTd">err_start_offset</td><td colspan="1" class="confluenceTd">log2ceil(wData/8)</td><td colspan="1" class="confluenceTd">rwResponseGenerationError &amp;&amp; narrowSupported</td><td colspan="1" class="confluenceTd">The offset within the beat the narrow transaction stops</td></tr><tr><td colspan="1" class="confluenceTd">err_end_offset</td><td colspan="1" class="confluenceTd">log2ceil(wData/8)</td><td colspan="1" class="confluenceTd">rwResponseGenerationError &amp;&amp; narrowSupported</td><td colspan="1" class="confluenceTd">The offset within the beat the narrow transaction starts</td></tr><tr><td colspan="1" class="confluenceTd">err_burst_size</td><td colspan="1" class="confluenceTd">wBurstSize</td><td colspan="1" class="confluenceTd">rwResponseGenerationError &amp;&amp; narrowSupported</td><td colspan="1" class="confluenceTd">The burst size of the transaction</td></tr><tr><td colspan="1" class="confluenceTd">err_burst_type</td><td colspan="1" class="confluenceTd">wBurstType</td><td colspan="1" class="confluenceTd">rwResponseGenerationError &amp;&amp; narrowSupported</td><td colspan="1" class="confluenceTd">The burst type of the transaction.</td></tr><tr><td colspan="1" class="confluenceTd">err_narrow</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">rwResponseGenerationError &amp;&amp; narrowSupported</td><td colspan="1" class="confluenceTd">Indicating the error txn was narrow.</td></tr></tbody></table></div><p>ctlReqCtxttoQueueInterface</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Signal</th><th colspan="1" class="confluenceTh">Width</th><th colspan="1" class="confluenceTh">Condition</th><th colspan="1" class="confluenceTh">Description</th></tr><tr><td class="confluenceTd">queue</td><td colspan="1" class="confluenceTd">log2ceil(nQueue)</td><td colspan="1" class="confluenceTd">Always</td><td colspan="1" class="confluenceTd">The queue the transaction goes to.</td></tr></tbody></table></div><p>dpReqCtxtInterface</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Signal</th><th class="confluenceTh">Width</th><th class="confluenceTh">Condition</th><th class="confluenceTh">Description</th></tr><tr><td class="confluenceTd">valid</td><td class="confluenceTd">1</td><td class="confluenceTd">narrowSupported || rwResponseGenerationError </td><td class="confluenceTd">Indication valid signaling to the request datapath.</td></tr><tr><td class="confluenceTd">ready</td><td class="confluenceTd">-1</td><td class="confluenceTd">narrowSupported || rwResponseGenerationError </td><td class="confluenceTd">Indication the request datapath can acceot signals.</td></tr><tr><td class="confluenceTd">error</td><td class="confluenceTd">1</td><td class="confluenceTd">narrowSupported || rwResponseGenerationError </td><td class="confluenceTd">Indication the request has an error.</td></tr><tr><td class="confluenceTd">start_offset</td><td class="confluenceTd">log2ceil(wData)</td><td class="confluenceTd">narrowSupported</td><td class="confluenceTd">Start offset within the beat for the txn.</td></tr><tr><td colspan="1" class="confluenceTd">wrap_len</td><td colspan="1" class="confluenceTd">wCtlLen</td><td colspan="1" class="confluenceTd">narrowSupported</td><td colspan="1" class="confluenceTd">The length of the wrap in bytes of the request.</td></tr><tr><td colspan="1" class="confluenceTd">burst_size</td><td colspan="1" class="confluenceTd">wCtlBurstSize</td><td colspan="1" class="confluenceTd">narrowSupported</td><td colspan="1" class="confluenceTd">The burst size of the request.</td></tr><tr><td colspan="1" class="confluenceTd">burst_type</td><td colspan="1" class="confluenceTd">wCtlBurstType</td><td colspan="1" class="confluenceTd">narrowSupported</td><td colspan="1" class="confluenceTd">The burst type of the request.</td></tr></tbody></table></div><h2 id="HW-CTFctl_init_context-ContextKeys">Context Keys</h2><p>Context keys is the method in which the top level is able to determine what entries the context needs.</p><p>var context_has_unique = ['timeout_error','atomic_rr','atomic_wr','beats'];</p><div class="table-wrap"><table class="wrapped relative-table confluenceTable" style="width: 58.4285%;"><colgroup><col style="width: 13.065%;"/><col style="width: 33.9045%;"/><col style="width: 18.8154%;"/><col style="width: 7.26855%;"/><col style="width: 11.5929%;"/><col style="width: 15.2271%;"/></colgroup><tbody><tr><th class="confluenceTh">Key</th><th class="confluenceTh">Width</th><th colspan="1" class="confluenceTh">Driver</th><th colspan="1" class="confluenceTh">Set</th><th colspan="1" class="confluenceTh">Clear</th><th colspan="1" class="confluenceTh">Description</th></tr><tr><td class="confluenceTd">vc</td><td class="confluenceTd">wVc</td><td colspan="1" class="confluenceTd">destination_vc</td><td colspan="1" class="confluenceTd">write_this_entry</td><td colspan="1" class="confluenceTd">zero</td><td colspan="1" class="confluenceTd">Which VC the transaction went on.</td></tr><tr><td class="confluenceTd">resp_sent</td><td class="confluenceTd">1</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">clear_resp_match</td><td colspan="1" class="confluenceTd">write_this_entry</td><td colspan="1" class="confluenceTd">NDP portion of response was sent.</td></tr><tr><td class="confluenceTd">dp_sent</td><td class="confluenceTd">1</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">clear_dp_match</td><td colspan="1" class="confluenceTd">write_this_entry</td><td colspan="1" class="confluenceTd">DP Portion of response was sent.</td></tr><tr><td colspan="1" class="confluenceTd">wr_data_rcvd</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">set_entry_aligned</td><td colspan="1" class="confluenceTd">write_this_entry</td><td colspan="1" class="confluenceTd">Indicates that the transaction has received all write data from the Common Layer Interface.</td></tr><tr><td class="confluenceTd">id</td><td class="confluenceTd"><a class="external-link" href="http://requestInterfaceIn.signals.id" rel="nofollow">requestInterfaceIn.signals.id</a>,</td><td colspan="1" class="confluenceTd"><a class="external-link" href="http://requestInterfaceIn.name" rel="nofollow">requestInterfaceIn.name</a>+'pipe_id'</td><td colspan="1" class="confluenceTd">write_this_entry</td><td colspan="1" class="confluenceTd">youngest_clear</td><td colspan="1" class="confluenceTd">ID of the transaction.</td></tr><tr><td class="confluenceTd">compressed_id</td><td class="confluenceTd">wSmiOrderingId</td><td colspan="1" class="confluenceTd">new_compressed_id</td><td colspan="1" class="confluenceTd">write_this_entry</td><td colspan="1" class="confluenceTd">zero</td><td colspan="1" class="confluenceTd">Compressed ID of the transaction</td></tr><tr><td class="confluenceTd">seq_num</td><td class="confluenceTd">log2ceil(nSeqNum)</td><td colspan="1" class="confluenceTd">next_seq_num</td><td colspan="1" class="confluenceTd">write_this_entry</td><td colspan="1" class="confluenceTd">zero</td><td colspan="1" class="confluenceTd">Sequence Number of Transaction.</td></tr><tr><td class="confluenceTd">addr</td><td class="confluenceTd">requestInterfaceOut.signals.addr</td><td colspan="1" class="confluenceTd"><a class="external-link" href="http://requestInterfaceIn.name" rel="nofollow">requestInterfaceIn.name</a>+'pipe_addr'</td><td colspan="1" class="confluenceTd">write_this_entry</td><td colspan="1" class="confluenceTd">zero</td><td colspan="1" class="confluenceTd">Address of Transaction.</td></tr><tr><td class="confluenceTd">exclusive</td><td class="confluenceTd">1</td><td colspan="1" class="confluenceTd"><a class="external-link" href="http://requestInterfaceIn.name" rel="nofollow">requestInterfaceIn.name</a>+'pipe_atomic[1]'</td><td colspan="1" class="confluenceTd">write_this_entry</td><td colspan="1" class="confluenceTd">zero</td><td colspan="1" class="confluenceTd">If transaction is exlclusive.</td></tr><tr><td class="confluenceTd">valid</td><td class="confluenceTd">1</td><td colspan="1" class="confluenceTd"><a class="external-link" href="http://requestInterfaceIn.name" rel="nofollow">requestInterfaceIn.name</a>+'pipe_valid'</td><td colspan="1" class="confluenceTd">write_this_entry</td><td colspan="1" class="confluenceTd">response_matched_this_entry</td><td colspan="1" class="confluenceTd">If context entry is valid.</td></tr><tr><td colspan="1" class="confluenceTd">oldest</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">set_oldest_seqnum</td><td colspan="1" class="confluenceTd">clear_oldest</td><td colspan="1" class="confluenceTd">Set when context holds the oldest sequence number.</td></tr><tr><td class="confluenceTd">youngest</td><td class="confluenceTd">1</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">write_this_entry</td><td colspan="1" class="confluenceTd">zero</td><td colspan="1" class="confluenceTd">If context entry is youngest.</td></tr><tr><td class="confluenceTd">targ_id</td><td class="confluenceTd">(requestInterfaceOut.signals.targ_id == undefined) ? 0 : requestInterfaceOut.signals.targ_id</td><td colspan="1" class="confluenceTd"><a class="external-link" href="http://requestInterfaceIn.name" rel="nofollow">requestInterfaceIn.name</a>+'pipe_targ_id'</td><td colspan="1" class="confluenceTd">write_this_entry</td><td colspan="1" class="confluenceTd">zero</td><td colspan="1" class="confluenceTd">Target ID of Transaction.</td></tr><tr><td class="confluenceTd">ordering_id</td><td class="confluenceTd">(requestInterfaceIn.signals.txn_ordering_id == undefined) ?  0 : requestInterfaceIn.signals.txn_ordering_id</td><td colspan="1" class="confluenceTd"><a class="external-link" href="http://requestInterfaceIn.name" rel="nofollow">requestInterfaceIn.name</a>+'pipe_txn_ordering_id'</td><td colspan="1" class="confluenceTd">write_this_entry</td><td colspan="1" class="confluenceTd">zero</td><td colspan="1" class="confluenceTd">Ordering ID of Transaction.</td></tr><tr><td class="confluenceTd">channel_id</td><td class="confluenceTd">(requestInterfaceIn.signals.txn_channel_id == undefined) ?  0 : requestInterfaceIn.signals.txn_channel_id</td><td colspan="1" class="confluenceTd"><a class="external-link" href="http://requestInterfaceIn.name" rel="nofollow">requestInterfaceIn.name</a>+'pipe_txn_channel_id'</td><td colspan="1" class="confluenceTd">write_this_entry</td><td colspan="1" class="confluenceTd">zero</td><td colspan="1" class="confluenceTd">Channel ID of Transaction.</td></tr><tr><td class="confluenceTd">queue</td><td class="confluenceTd">wQueue</td><td colspan="1" class="confluenceTd">queue_map_out</td><td colspan="1" class="confluenceTd">write_this_entry</td><td colspan="1" class="confluenceTd">zero</td><td colspan="1" class="confluenceTd">Queue of Transaction.</td></tr><tr><td class="confluenceTd">type</td><td class="confluenceTd">1</td><td colspan="1" class="confluenceTd"><a class="external-link" href="http://requestInterfaceIn.name" rel="nofollow">requestInterfaceIn.name</a>+'pipe_msgTypeAttr[4]'</td><td colspan="1" class="confluenceTd">write_this_entry</td><td colspan="1" class="confluenceTd">zero</td><td colspan="1" class="confluenceTd">Whether transaction is R/W</td></tr><tr><td class="confluenceTd">split</td><td class="confluenceTd">1</td><td colspan="1" class="confluenceTd"><a class="external-link" href="http://requestInterfaceIn.name" rel="nofollow">requestInterfaceIn.name</a>+'pipe_split_req'</td><td colspan="1" class="confluenceTd">write_this_entry</td><td colspan="1" class="confluenceTd">zero</td><td colspan="1" class="confluenceTd">Whether transaction is split.</td></tr><tr><td class="confluenceTd">last</td><td class="confluenceTd">1</td><td colspan="1" class="confluenceTd"><a class="external-link" href="http://requestInterfaceIn.name" rel="nofollow">requestInterfaceIn.name</a>+'pipe_last'</td><td colspan="1" class="confluenceTd">write_this_entry</td><td colspan="1" class="confluenceTd">zero</td><td colspan="1" class="confluenceTd">Whether transaction is first in the series of split transactions.</td></tr><tr><td colspan="1" class="confluenceTd">first</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd"><a class="external-link" href="http://requestInterfaceIn.name" rel="nofollow">requestInterfaceIn.name</a>+'pipe_first'</td><td colspan="1" class="confluenceTd">write_this_entry</td><td colspan="1" class="confluenceTd">zero</td><td colspan="1" class="confluenceTd">Whether transaction is last in the series of split transactions.</td></tr><tr><td colspan="1" class="confluenceTd">buf_write</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">&quot;buffered &amp; ~blocked&quot;</td><td colspan="1" class="confluenceTd">write_this_entry</td><td colspan="1" class="confluenceTd">zero</td><td colspan="1" class="confluenceTd">Whether transaction is a buffered write. (Sent an early response)</td></tr><tr><td colspan="1" class="confluenceTd">narrow</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">narrow</td><td colspan="1" class="confluenceTd">write_this_entry</td><td colspan="1" class="confluenceTd">zero</td><td colspan="1" class="confluenceTd">Whether transaction is a narrow txn.</td></tr><tr><td colspan="1" class="confluenceTd">atomic</td><td colspan="1" class="confluenceTd">4</td><td colspan="1" class="confluenceTd"><a class="external-link" href="http://requestInterfaceIn.name" rel="nofollow">requestInterfaceIn.name</a>+'pipe_txn_atomic[7:4]'</td><td colspan="1" class="confluenceTd">write_this_entry</td><td colspan="1" class="confluenceTd">zero</td><td colspan="1" class="confluenceTd">Whether transaction is an atomic txn.</td></tr><tr><td colspan="1" class="confluenceTd">atomic_rr</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">atomic_rr_drive</td><td colspan="1" class="confluenceTd">atomic_rr_set</td><td colspan="1" class="confluenceTd">zero</td><td colspan="1" class="confluenceTd">??? Not in R1</td></tr><tr><td colspan="1" class="confluenceTd">atomic_wr</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">atomic_wr_drive</td><td colspan="1" class="confluenceTd">atomic_wr_set</td><td colspan="1" class="confluenceTd">zero</td><td colspan="1" class="confluenceTd">Whether a write has seen its read response. </td></tr><tr><td colspan="1" class="confluenceTd">burst_size</td><td colspan="1" class="confluenceTd">requestInterfaceIn.signals.txn_hdr_burstSize</td><td colspan="1" class="confluenceTd"><a class="external-link" href="http://requestInterfaceIn.name" rel="nofollow">requestInterfaceIn.name</a>+'pipe_txn_hdr_burstSize'</td><td colspan="1" class="confluenceTd">write_this_entry</td><td colspan="1" class="confluenceTd">zero</td><td colspan="1" class="confluenceTd">Burst Size of Transaction.</td></tr><tr><td colspan="1" class="confluenceTd">burst_type</td><td colspan="1" class="confluenceTd">requestInterfaceIn.signals.txn_hdr_burstType</td><td colspan="1" class="confluenceTd">burst_type_in</td><td colspan="1" class="confluenceTd">write_this_entry</td><td colspan="1" class="confluenceTd">zero</td><td colspan="1" class="confluenceTd">Burst Type of Transaction.</td></tr><tr><td colspan="1" class="confluenceTd">narrow_offset</td><td colspan="1" class="confluenceTd">log2ceil(responseDpInterfaceIn.signals.data/8)</td><td colspan="1" class="confluenceTd">narrow_offset</td><td colspan="1" class="confluenceTd">write_this_entry</td><td colspan="1" class="confluenceTd">zero</td><td colspan="1" class="confluenceTd">Address offset of Transaction. Place in beat where the transaction starts.</td></tr><tr><td colspan="1" class="confluenceTd">narrow_end_offset</td><td colspan="1" class="confluenceTd">log2ceil(responseDpInterfaceIn.signals.data/8)</td><td colspan="1" class="confluenceTd">narrow_end_offset</td><td colspan="1" class="confluenceTd">write_this_entry</td><td colspan="1" class="confluenceTd">zero</td><td colspan="1" class="confluenceTd">Place in beat where the transaction ends.</td></tr><tr><td colspan="1" class="confluenceTd">rw_error</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">rw_error</td><td colspan="1" class="confluenceTd">write_this_entry</td><td colspan="1" class="confluenceTd">sent_error_response</td><td colspan="1" class="confluenceTd">Indicates this transaction has a RW error.</td></tr><tr><td colspan="1" class="confluenceTd">decode_error</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">exclusive_error</td><td colspan="1" class="confluenceTd">write_this_entry</td><td colspan="1" class="confluenceTd">sent_error_response</td><td colspan="1" class="confluenceTd">Indicates this transaction has a decode error.</td></tr><tr><td colspan="1" class="confluenceTd">exclusive_error</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">domain_error</td><td colspan="1" class="confluenceTd">write_this_entry</td><td colspan="1" class="confluenceTd">sent_error_response</td><td colspan="1" class="confluenceTd">Indicates this transaction has a exclusive error.</td></tr><tr><td colspan="1" class="confluenceTd">domain_error</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd"><a class="external-link" href="http://requestInterfaceIn.name" rel="nofollow">requestInterfaceIn.name</a>+'pipe_decode_error'</td><td colspan="1" class="confluenceTd">write_this_entry</td><td colspan="1" class="confluenceTd">sent_error_response</td><td colspan="1" class="confluenceTd">Indicates this transaction has a domain error.</td></tr><tr><td colspan="1" class="confluenceTd">beats</td><td colspan="1" class="confluenceTd">Math.min( log2ceil(Math.pow(2,requestInterfaceIn.signals.len)/(responseDpInterfaceIn.signals.data/8)), log2ceil(maxPduSz/(responseDpInterfaceIn.signals.data/8))) + 1</td><td colspan="1" class="confluenceTd">transaction_in_beats</td><td colspan="1" class="confluenceTd">update_beats</td><td colspan="1" class="confluenceTd">zero</td><td colspan="1" class="confluenceTd">The amount of beats the transaction should expect on the response data path.</td></tr><tr><td colspan="1" class="confluenceTd">timeout_error</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">timeout_error_occured</td><td colspan="1" class="confluenceTd">timeout_tick</td><td colspan="1" class="confluenceTd">response_matched_this_entry</td><td colspan="1" class="confluenceTd">Indicates there has been a timeout error.</td></tr><tr><td colspan="1" class="confluenceTd">timeout</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">timeout_tick</td><td colspan="1" class="confluenceTd">timeout_tick</td><td colspan="1" class="confluenceTd">sent_error_response</td><td colspan="1" class="confluenceTd">Indicates that the transaction has seen a tick of the timeout timer.</td></tr></tbody></table></div><p class="auto-cursor-target">contextKeys Generation done inside ctl_init</p><div class="table-wrap"><table class="relative-table wrapped confluenceTable" style="width: 43.1498%;"><colgroup><col style="width: 27.352%;"/><col style="width: 28.785%;"/><col style="width: 43.7383%;"/></colgroup><tbody><tr><th class="confluenceTh">Description</th><th class="confluenceTh">Condition</th><th class="confluenceTh">Keys / Parameters</th></tr><tr><td class="confluenceTd">VC Flow Storage</td><td class="confluenceTd">smiReqInterface.msg_valid</td><td class="confluenceTd">vc</td></tr><tr><td class="confluenceTd">Ordering ID Storage with Absence of Seqnum</td><td class="confluenceTd">wMsgSeqnum == 0 </td><td class="confluenceTd">(ctlReqInterface.txn_ordering_id exists) ? ordering_id : id</td></tr><tr><td class="confluenceTd">Width Adaption in the Network</td><td class="confluenceTd">widthAdaptionSupported</td><td class="confluenceTd">beats,valid,type</td></tr><tr><td class="confluenceTd">ID Compression</td><td class="confluenceTd">wCtlOrderingId &gt; wSmiOrderingId</td><td class="confluenceTd">ordering_id, valid, type, seq_num</td></tr><tr><td class="confluenceTd">Storage of Targ ID for Interrupt Registers</td><td class="confluenceTd">interfaces.apbInt != undefined</td><td class="confluenceTd">targ_id</td></tr><tr><td class="confluenceTd">If the Reorder Buffer Exists</td><td class="confluenceTd">enRob</td><td class="confluenceTd"><p>seq_num, valid, type, <s>youngest</s></p><p>(ctlReqInterface.txn_ordering_id exists) ? ordering_id : id</p><p>(ctlReqInterface.txn_channel_id exists)  ? channel_id </p><p>targ_id_lock = 0</p></td></tr><tr><td class="confluenceTd">If the Reorder Buffer Doesnt Exist</td><td class="confluenceTd">!enRob</td><td class="confluenceTd"><p>targ_id, valid, type</p><p>(ctlReqInterface.txn_ordering_id exists) ? ordering_id : id</p><p>(ctlReqInterface.txn_channel_id exists)  ? channel_id </p><p>targ_id_lock = 1</p></td></tr><tr><td colspan="1" class="confluenceTd">Exclusive Errir Enabled</td><td colspan="1" class="confluenceTd">enExclusiveError</td><td colspan="1" class="confluenceTd">seq_num, valid, type, exclusive_error, beats, oldest</td></tr><tr><td class="confluenceTd">RW Error Enabled</td><td class="confluenceTd">needRWError</td><td class="confluenceTd">seq_num, valid, type, rw_error, beats, oldest</td></tr><tr><td class="confluenceTd">Decode Error Enabled</td><td class="confluenceTd">enDecodeError</td><td class="confluenceTd">seq_num, valid, type, decode_error, beats, oldest</td></tr><tr><td class="confluenceTd">Domain Error Enabled</td><td class="confluenceTd">haveDomainError</td><td class="confluenceTd">seq_num, valid, type, domain_error, beats, oldest</td></tr><tr><td colspan="1" class="confluenceTd">Timeout Error Enabled</td><td colspan="1" class="confluenceTd">timeoutErrChk</td><td colspan="1" class="confluenceTd">seq_num, valid, type, timeout, beats, timeout_error, id, wr_data_rcvd, oldest</td></tr><tr><td colspan="1" class="confluenceTd">Statistics Enabled</td><td colspan="1" class="confluenceTd">interfaces.statsInt != undefined</td><td colspan="1" class="confluenceTd">targ_id, valid, type, </td></tr><tr><td colspan="1" class="confluenceTd">Seqnuence Number Exists</td><td colspan="1" class="confluenceTd">wMsgSeqnum</td><td colspan="1" class="confluenceTd">seq_num, valid, type, </td></tr><tr><td colspan="1" class="confluenceTd">Atomics Enabled</td><td colspan="1" class="confluenceTd">atomicsSupported</td><td colspan="1" class="confluenceTd">seq_num, valid, type, atomic</td></tr><tr><td colspan="1" class="confluenceTd">Narrows Enabled</td><td colspan="1" class="confluenceTd">narrowSupported</td><td colspan="1" class="confluenceTd">valid, type, narrow, burst_size, burst_type, narrow_offset, narrow_end_offset</td></tr><tr><td colspan="1" class="confluenceTd">Buffered Write Enabled</td><td colspan="1" class="confluenceTd">enBufWrite</td><td colspan="1" class="confluenceTd"><p>valid, type, seq_num, buf_write</p><p>(ctlReqInterface.txn_ordering_id exists) ? ordering_id</p><p>(ctlReqInterface.txn_channel_id exists)  ? channel_id </p><p>(ctlReqInterface.txn_ordering_model exists)  ? ordering_model</p></td></tr><tr><td colspan="1" class="confluenceTd">Base Fields Needed</td><td colspan="1" class="confluenceTd">enContextKeys.length != 0</td><td colspan="1" class="confluenceTd">resp_sent, dp_sent</td></tr><tr><td colspan="1" class="confluenceTd">Have Splitting and Striping Functionality</td><td colspan="1" class="confluenceTd">have_striping | have_splitting</td><td colspan="1" class="confluenceTd"><p>seq_num, split, valid, last, first, type, orderin_id</p><p>if (!readInterleaveSupported)</p><p>   targ_id</p></td></tr></tbody></table></div><h2 id="HW-CTFctl_init_context-InternalParameterDefinitions">Internal Parameter Definitions</h2><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Parameter</th><th class="confluenceTh">Definition</th></tr><tr><td class="confluenceTd">nSeqNum</td><td class="confluenceTd">nContextEntries * 2</td></tr><tr><td class="confluenceTd">wSeqNum</td><td class="confluenceTd">log2ceil(nSeqNum)</td></tr><tr><td class="confluenceTd">wSeqNumInt</td><td class="confluenceTd">have_seqnum ? requestInterfaceOut.signals.seq_num :  0</td></tr><tr><td class="confluenceTd">timeout_width</td><td class="confluenceTd">(timeoutErrChk == 0) ? 0 : (useExternalTimeout) ? timeoutErrorWidth : log2ceil(timeoutErrCount);</td></tr><tr><td class="confluenceTd">noContext</td><td class="confluenceTd">enContextKeys.length == 0</td></tr><tr><td class="confluenceTd">zeroOutstanding</td><td class="confluenceTd">(nOutstandingReads + nOutstandingWrites) == 0</td></tr><tr><td class="confluenceTd">log2ceilnContextEntries</td><td class="confluenceTd">(nContextEntries == 1 | zeroOutstanding) ?  1 : log2ceil(nContextEntries)</td></tr><tr><td class="confluenceTd">have_seqnum</td><td class="confluenceTd">enContextKeys.includes(&quot;seq_num&quot;) &amp; requestInterfaceOut.signals.seq_num != 0 &amp; requestInterfaceOut.signals.seq_num != undefined</td></tr><tr><td class="confluenceTd">have_compressed_id</td><td class="confluenceTd">wSmiOrderingId &lt; requestInterfaceIn.signals.txn_ordering_id; //(enContextKeys.includes(&quot;compressed_id&quot;))</td></tr><tr><td class="confluenceTd">have_ordering_id</td><td class="confluenceTd">(requestInterfaceIn.signals.txn_ordering_id != 0) &amp; (requestInterfaceIn.signals.txn_ordering_id != undefined)</td></tr><tr><td class="confluenceTd">have_channel_id</td><td class="confluenceTd">(enContextKeys.includes(&quot;channel_id&quot;)</td></tr><tr><td class="confluenceTd">have_in_resp_ordering_id</td><td class="confluenceTd">(responseInterfaceIn.signals.txn_ordering_id != 0) &amp; (responseInterfaceIn.signals.txn_ordering_id != undefined)</td></tr><tr><td class="confluenceTd">have_resp_ordering_id</td><td class="confluenceTd">(responseInterfaceOut.signals.txn_ordering_id != 0) &amp; (responseInterfaceOut.signals.txn_ordering_id != undefined)</td></tr><tr><td colspan="1" class="confluenceTd">have_resp_channel_id</td><td colspan="1" class="confluenceTd">(responseInterfaceIn.signals.txn_channel_id != 0) &amp; (responseInterfaceIn.signals.txn_channel_id != undefined)</td></tr><tr><td colspan="1" class="confluenceTd">have_resp_dummy</td><td colspan="1" class="confluenceTd">(responseDpInterfaceIn.signals.dummy != 0) &amp; (responseDpInterfaceIn.signals.dummy != undefined)</td></tr><tr><td colspan="1" class="confluenceTd">nOutstandingMax</td><td colspan="1" class="confluenceTd">Math.max(nOutstandingReads,nOutstandingWrites)</td></tr><tr><td colspan="1" class="confluenceTd">wOutstandingRd</td><td colspan="1" class="confluenceTd">log2ceil(nOutstandingReads)+1</td></tr><tr><td colspan="1" class="confluenceTd">wOutstandingWr</td><td colspan="1" class="confluenceTd">log2ceil(nOutstandingWrites)+1</td></tr><tr><td colspan="1" class="confluenceTd">wOutstandingMax</td><td colspan="1" class="confluenceTd">log2ceil(nOutstandingMax)+1</td></tr><tr><td colspan="1" class="confluenceTd">wOutstandingTotal</td><td colspan="1" class="confluenceTd">log2ceil(nOutstanding)+1</td></tr><tr><td colspan="1" class="confluenceTd">wOutstandingMaxTotal</td><td colspan="1" class="confluenceTd">Math.max(wOutstandingMax,wOutstandingTotal)</td></tr><tr><td colspan="1" class="confluenceTd">zerosOutstandingRd</td><td colspan="1" class="confluenceTd">wOutstandingMaxTotal&lt;=wOutstandingRd ? &quot;&quot; : (wOutstandingMaxTotal-wOutstandingRd)+&quot;'d0,&quot;;</td></tr><tr><td colspan="1" class="confluenceTd">zerosOutstandingWr</td><td colspan="1" class="confluenceTd">wOutstandingMaxTotal&lt;=wOutstandingWr ? &quot;&quot; : /* istanbul ignore next env legato */ (wOutstandingMaxTotal-wOutstandingWr)+&quot;'d0,&quot;</td></tr><tr><td colspan="1" class="confluenceTd">enableErrors</td><td colspan="1" class="confluenceTd">timeoutErrChk | rwResponseGenerationFromError</td></tr></tbody></table></div></div><h2 id="HW-CTFctl_init_context-FunctionalSections">Functional Sections</h2><p>These sections are not in the same order as in the TACHL Block</p><h3 id="HW-CTFctl_init_context-Mechanics">Mechanics</h3><h4 id="HW-CTFctl_init_context-ValidReadySignalingonRequest">Valid Ready Signaling on Request</h4><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="https://arterisip.atlassian.net/wiki/download/attachments/16157225/image2021-1-17_9-14-46.png?api=v2"></span></p><p>On the request path the valid can be modified by:</p><ul style="list-style-type: square;"><li>Held if No open context entries.</li><li>Held of Blocking Logic Defined Below.</li><li>Dropped from a possible error.</li></ul><p>On the request path the ready can be modified by:</p><ul><li>Held if No open context entries.</li><li>Held of Blocking Logic Defined Below.</li><li>Held for a buffered write that can be sent but ready is not asserted. (See Buffered Writes for more mechanical detail)</li><li>Dropped from a possible error.</li></ul><h4 id="HW-CTFctl_init_context-ValidReadySignalingonResponse">Valid Ready Signaling on Response</h4><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="https://arterisip.atlassian.net/wiki/download/attachments/16157225/image2021-1-17_9-25-15.png?api=v2"></span></p><p>On the response path the valid can be driven from three paths:</p><ul><li>First Priority : Buffered Writes (buffered_write_sel). If this is selected buffered_write_valid determines validity.</li><li>Second Priority : Errors (error_sel). If this is selected error_valid determines validity. This can be masked from response_mask if it is a split transaction. </li><li>Third Priority: From SMI Interface. This can be:<ul><li>Held from block_response</li><li>Dropped from split_mask_valid</li><li>Dropped from supress_ndp_resp</li><li>Dropped from Buffered Write</li></ul></li></ul><p>On the response path the ready:</p><ul style="list-style-type: square;"><li>Will be driven to 1 in the Error or Buffered Write case since it is being generated.</li><li>In the SMI case it can be:<ul style="list-style-type: square;"><li>Held from block_response</li><li>Dropped from split_mask_valid</li><li>Dropped from supress_ndp_resp</li><li>Dropped from Buffered Write</li></ul></li></ul><p>Piping the Context. If the context is piped the response has to correctly travel alongside the piped lookup. This is done by splitting the response into two valid/ready interfaces which are then rejoined after the lookuup. This is done before the mechanics above.</p><p>                   assign \=<a class="external-link" href="http://responseInterfaceIn.name" rel="nofollow">responseInterfaceIn.name</a>=\ready = \=<a class="external-link" href="http://responseInterfaceIn.name" rel="nofollow">responseInterfaceIn.name</a>=\fifo_ready &amp; respPipeInReady;</p><p>                   assign \=<a class="external-link" href="http://responseInterfaceIn.name" rel="nofollow">responseInterfaceIn.name</a>=\pipe_valid = \=<a class="external-link" href="http://responseInterfaceIn.name" rel="nofollow">responseInterfaceIn.name</a>=\fifo_pipe_valid &amp; respPipeOutValid;</p><p>                   assign respPipeInValid = \=<a class="external-link" href="http://responseInterfaceIn.name" rel="nofollow">responseInterfaceIn.name</a>=\valid &amp; \=<a class="external-link" href="http://responseInterfaceIn.name" rel="nofollow">responseInterfaceIn.name</a>=\ready;</p><p>                   assign respPipeOutReady = \=<a class="external-link" href="http://responseInterfaceIn.name" rel="nofollow">responseInterfaceIn.name</a>=\pipe_ready;</p><p>                   assign \=<a class="external-link" href="http://responseInterfaceIn.name" rel="nofollow">responseInterfaceIn.name</a>=\fifo_valid = \=<a class="external-link" href="http://responseInterfaceIn.name" rel="nofollow">responseInterfaceIn.name</a>=\valid &amp; \=<a class="external-link" href="http://responseInterfaceIn.name" rel="nofollow">responseInterfaceIn.name</a>=\ready;</p><p>                   assign \=<a class="external-link" href="http://responseInterfaceIn.name" rel="nofollow">responseInterfaceIn.name</a>=\fifo_pipe_ready = \=<a class="external-link" href="http://responseInterfaceIn.name" rel="nofollow">responseInterfaceIn.name</a>=\pipe_ready &amp; respPipeOutValid;</p><p> Where the naming is the following:</p><ul style="list-style-type: square;"><li>respPipe* are going to the lookup blocks.</li><li>*_pipe is the combined interface. </li><li>*fifo_ is the signals into the fifo that holds the response.</li><li>*fifo_pipe is going out of the fifo that holds the response.</li></ul><h4 id="HW-CTFctl_init_context-PerContextLoop">Per Context Loop</h4><div class="table-wrap"><table class="relative-table wrapped confluenceTable" style="width: 100.0%;"><colgroup><col style="width: 10.5%;"/><col style="width: 89.4444%;"/></colgroup><tbody><tr><th class="confluenceTh">Signal/Operation</th><th class="confluenceTh"><br/></th></tr><tr><td class="confluenceTd">Register Logic</td><td class="confluenceTd">Each key will get its own register. The width of the register is determined by its definition. Then it is &quot;set&quot; from the specified set signal to the driven value inside &quot;driver&quot;, and then cleared by the respective &quot;clear&quot; signal.</td></tr><tr><td class="confluenceTd"><p>clear_dp_match</p></td><td class="confluenceTd">Indicates the last beat of data has come in for this entry, or indicates that error information has been sent to the response datapath.</td></tr><tr><td class="confluenceTd">clear_resp_match</td><td class="confluenceTd">Indicates the response has been sent for this entry, or indicates the error response has been sent for this entry.</td></tr><tr><td class="confluenceTd">clear_resp</td><td class="confluenceTd">Indicates that the Response should be seen as sent. Can either be the registered context_*_resp sent or the more timing intensive context_*_resp sent | context_*_resp sent_set</td></tr><tr><td class="confluenceTd">clear_dp</td><td class="confluenceTd">Indicates that the Data Response should be seen as sent. Can either be the registered context_*_dp sent or the more timing intensive context_*_dp_sent | context_*_dp_sent_set</td></tr><tr><td class="confluenceTd">clear_match</td><td class="confluenceTd">Depending of if its a write or read indicates if teh entry can be cleared. (Write is resp sent, read is resp_sent and dp_sent)</td></tr><tr><td class="confluenceTd">response_matched_this_entry</td><td class="confluenceTd">Equal to clear_match and the validity of the entry.</td></tr><tr><td class="confluenceTd">cleared_entry</td><td class="confluenceTd">Equal to response_matched_this_entry.</td></tr><tr><td class="confluenceTd">cleared_last_split_entry</td><td class="confluenceTd">response_matched_this_entry &amp; context_*_split &amp; context_*_last</td></tr><tr><td class="confluenceTd">error_invalid</td><td class="confluenceTd">Indicates that this transaction has one of its error fields asserted. </td></tr><tr><td class="confluenceTd">response_sent</td><td class="confluenceTd">Mechanical signal of the valid and ready of ndp response interface.</td></tr><tr><td class="confluenceTd">update_beats</td><td class="confluenceTd">Its either asserted when entry is written or a valid data beat is seen that matches this entry. </td></tr><tr><td class="confluenceTd">transaction_in_beats</td><td class="confluenceTd">(Different from outer transaction_in_beats) If its being set for the first time it is the amount of beats the transaction is. Otherwise its the current value minus 1.</td></tr><tr><td class="confluenceTd">atomic_wr_drive</td><td class="confluenceTd">Not in R1</td></tr><tr><td class="confluenceTd">atomic_rr_drive</td><td class="confluenceTd">Not in R1</td></tr><tr><td class="confluenceTd">atomic_wr_set</td><td class="confluenceTd">Not in R1</td></tr><tr><td class="confluenceTd">atomic_rr_set</td><td class="confluenceTd">Not in R1</td></tr><tr><td class="confluenceTd">clear_*_from_*_error</td><td class="confluenceTd">Tied to that context entries value for that error.</td></tr><tr><td class="confluenceTd">context_clear_from_error</td><td class="confluenceTd">An or of all clear_*_from_*_error for that entry. </td></tr><tr><td colspan="1" class="confluenceTd">drop_error_response</td><td colspan="1" class="confluenceTd">Indicates that an error response should not be sent as it is a split transaction and its not the last or first of a split series. </td></tr><tr><td colspan="1" class="confluenceTd">sent_error_response</td><td colspan="1" class="confluenceTd">Indicates that this entry has been selected to send its ndp error response and it has left the context.</td></tr><tr><td colspan="1" class="confluenceTd">context_error_vec</td><td colspan="1" class="confluenceTd">An or of all context_*_*_error for that entry with the qualification it is not a buffered write.</td></tr></tbody></table></div><h4 id="HW-CTFctl_init_context-RequestBlockingLogic">Request Blocking Logic</h4><p>The request can be had of line blocked based on the following signaling. </p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Signal Description</th><th colspan="1" class="confluenceTh">Condition (Either directly or indirectly)</th><th class="confluenceTh">Description</th></tr><tr><td class="confluenceTd">block_no_seqnum</td><td colspan="1" class="confluenceTd">Always</td><td class="confluenceTd">The next Sequence Number is correctly being used</td></tr><tr><td class="confluenceTd">block_no_seqnum_split &amp; split_req</td><td colspan="1" class="confluenceTd">Have Split Key</td><td class="confluenceTd">The next Sequence Number + 1 is being used. This addresses a corner case when merging errors on the response channel for split transactions. See the <p><strong>Splitting Response Accumulation</strong> section for more info.</p></td></tr><tr><td colspan="1" class="confluenceTd">seqnum_fifo_block</td><td colspan="1" class="confluenceTd">timeoutErrChk</td><td colspan="1" class="confluenceTd">If the queue which holds sequence numbers which are sent is full the request path needs to back pressure.</td></tr><tr><td class="confluenceTd">idMatchError</td><td colspan="1" class="confluenceTd">drop_from_error_en</td><td class="confluenceTd">The transaction matches another transaction with the same ordering/channel id which is sending an error response.</td></tr><tr><td class="confluenceTd">align_count_block</td><td colspan="1" class="confluenceTd">reResponseGenerationFromError</td><td class="confluenceTd">The transaction needs to guarantee all write data is accepted before response is sent.,</td></tr><tr><td class="confluenceTd">block_too_many_outstanding</td><td colspan="1" class="confluenceTd">Always</td><td class="confluenceTd">The transaction can block if there are too many outstanding reads and/or writes</td></tr><tr><td class="confluenceTd">idMatchDiffTarget</td><td colspan="1" class="confluenceTd">targ_id_lock</td><td class="confluenceTd">If id locking is needed then an outstanding ordering/channel id combo can only be going to a single target.</td></tr><tr><td class="confluenceTd">idMatchSameVcTarg</td><td colspan="1" class="confluenceTd">Have VC Key</td><td class="confluenceTd">You cannot send a transaction through two VCs to the same target. This will violate ordering to a target.</td></tr><tr><td class="confluenceTd">reqDataBlock</td><td colspan="1" class="confluenceTd">Always</td><td class="confluenceTd">Need to block if the Request Data block cannot accept request info. </td></tr><tr><td colspan="1" class="confluenceTd">|split_no_interleave_match_vec</td><td colspan="1" class="confluenceTd">Always</td><td colspan="1" class="confluenceTd">If the initiator cannot interleave responses a split transaction needs to be executed fully to the target. </td></tr></tbody></table></div><h4 id="HW-CTFctl_init_context-ResponseBlockingLogic">Response Blocking Logic</h4><p>The response will be blocked if it is a read and the context block cannot yet accept the sequence number to be capture. </p><h4 id="HW-CTFctl_init_context-NonContextRegister">Non Context Register</h4><p>The context also has a large register to store state not related to individual entries. This is one of two registers outside the context register. This register stores information related to:</p><ul style="list-style-type: square;"><li>Transaction Counting</li><li>Sequence Number Tracking</li><li>Sequence Number Suppression </li><li>Align Counts</li><li>Buffered Write Operation</li></ul><h4 id="HW-CTFctl_init_context-response_matched_entry_vec">response_matched_entry_vec</h4><ul style="list-style-type: square;"><li>A response will match an entry depending on the incoming Sequence Number only for R1.</li><li>This signal is driven directly from the incoming interface before any piping so is used to drive the lookups.</li></ul><h4 id="HW-CTFctl_init_context-FindError">Find Error</h4><ul style="list-style-type: square;"><li>An errored entry can be sent once it is the oldest sequence number that is outstanding. </li><li>This means only a single entry can be eligible to send its error at any given time. </li></ul><h4 id="HW-CTFctl_init_context-FindEntry">Find Entry</h4><ul style="list-style-type: square;"><li>Open entries are found from the top entry down.</li></ul><h3 id="HW-CTFctl_init_context-BurstTypeModificationintoContext">Burst Type Modification into Context</h3><p>If narrowSupported is enabled and the ATUI can split a transaction then the burst type can possibly be modified when put into context. This is because the original burst type defines the narrow behaviour on the Common Layer interface.</p><p>assign burst_type_in = (single_beat_wrap_transform)                           ? WRAP :<br/>                                     (\=<a class="external-link" href="http://requestInterfaceIn.name" rel="nofollow">requestInterfaceIn.name</a>=\pipe_orig_fixed) ? FIXED : <br/>                                      \=<a class="external-link" href="http://requestInterfaceIn.name" rel="nofollow">requestInterfaceIn.name</a>=\pipe_txn_hdr_burstType;</p><h3 id="HW-CTFctl_init_context-LastDPBeatIndicator">Last DP Beat Indicator</h3><p>The last DP indicator is used by the context to detect when the last data beat of a transaction comes into the context. This signals looks at the valid, ready, and last however it also needs to take into account:</p><ul style="list-style-type: square;"><li>Data Width Adaption added beats.</li><li>Dummy Signals</li></ul><h3 id="HW-CTFctl_init_context-Busy">Busy</h3><p>The busy signal is driven if any of the contect entries are valid or there is incoming valid data. </p><h3 id="HW-CTFctl_init_context-ErrorDetectionLogic">Error Detection Logic</h3><p>The context will drive domainError, exclusiveError, rwError, decodeError with the logic below. </p><h4 id="HW-CTFctl_init_context-ExclusiveErrorLogic">Exclusive Error Logic</h4><p>An exclusive error is detected if split_req is asserted and the transaction is an exclusive transaction.</p><h4 id="HW-CTFctl_init_context-DomainErrorLogic">Domain Error Logic</h4><p>The domain error originates at the PAM and then is detected inside the context. It travels along the domain_err signal.</p><h4 id="HW-CTFctl_init_context-RWErrorLogic">RW Error Logic</h4><p>The context has an incoming signal rw which indicates if the target is read only, write only, or rw. This signal is compared to whether the incoming transaction is a read or write and an error will possibly be generated.</p><h4 id="HW-CTFctl_init_context-DecodeError">Decode Error</h4><p>An incoming signal from the PAM will indicate if the transaction has a decode error.</p><h4 id="HW-CTFctl_init_context-TimeoutError">Timeout Error</h4><p>A counter will be implemented which will consistently produce a timeout_tick at regular intervals. If a context entry has its timeout field 0 it will be driven to 1 at the timeout_tick. If it is already 1 then the entry will be considered having a timeout error. At this point any remaining responses received will be dropped and an error response will complete the transaction. If it times out in the middle of a read burst then the context will respond with the appropriate amount of beats. The sequence number of that respective transaction will then be poisoned. </p><h4 id="HW-CTFctl_init_context-SeqnumAlignFIFOforTimeoutError">Seqnum Align FIFO for Timeout Error</h4><p>There is a corner case where a timeout occurs but all of the write data has not been accepted. This means each entry needs to keep track of whether it received all of its data in a wr_data_rcvd field. To do this two things are kept track of:</p><ul style="list-style-type: square;"><li>Outgoing Sequence Numbers in a FIFO</li><li>A count of the aligned_event signal. </li></ul><p>On the output of the FIFO, if the count of aligned events is positive that means the sequence number on the output of the FIFO has received data. The appropriate entry is then updated. Once an entry is updated the aligned event count decrements and the top entry of the FIFO is popped. This is not timing critical so this can take a couple cycles if necessary. </p><h4 id="HW-CTFctl_init_context-DropFromError">Drop From Error</h4><p>drop_from_error is driven if there is a decode_error, rw_error, exclusive_error, or a domain_error. This means the transaction will not move forward outside the context. This also means that the request data path needs to drop all data assosiated with the transaction. </p><h3 id="HW-CTFctl_init_context-ErrorResponseGeneration">Error Response Generation</h3><p>Error responses are generated in strict order with respect to the sequence number. The oldest outstanding sequence number is being tracked and once the oldest_seq_num matches an entry which has an error to send the response will be sent. If it is a write only an ndp will be generated, but if its a read an ndp will be generated and information for the data response will be sent to the data path. The context entry is not cleared until the ndp and/or dp information is sent.</p><p>If an incoming transaction is dropped from an error it will be held until the data path is aligned and all write data has been received as to not break the Common Layer protocol. This is done through a counter that keeps track of DP packets and requests that travel through the CTL layer. Once aligned a response will be generated and the request will be dropped. </p><h3 id="HW-CTFctl_init_context-ErrorLock">Error Lock</h3><p>(idMatchError) To keep order, if any dependencies coming in match an entry that is expecting to send an error response the context will block. The oldest_seq_num strict ordering will only work for ordering with respect to transactions in front of it. </p><h3 id="HW-CTFctl_init_context-TargetIDLock">Target ID Lock</h3><p>(idMatchDiffTarget) If there is no RoB to keep order the context block will block any ordering match that is going to a different target.</p><h3 id="HW-CTFctl_init_context-SplittingResponseAccumulation">Splitting Response Accumulation</h3><p>In the case of write responses, errors travel along the ndp error field, however for split transactions all of the transaction's ndp responses will be dropped but the last one. This means that the context block must merge errors from write responses to be sent in the last ndp that is sent out. This information cannot be stored in context as context is cleared once its part of the split transaction is completed. Luckily we can take advantage of the properties of sequence numbers in that a split transaction will always have sequential sequence numbers. This means that a sequence number if dropped can store a message for the next sequence number, and so on, until the last sequence number that is not dropped. This allows error accumulation until the last ndp message that is not dropped.</p><p>High Level View:</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="512" src="https://arterisip.atlassian.net/wiki/download/attachments/16157225/image2021-1-20_11-31-46.png?api=v2"></span></p><p>Some notes:</p><ul style="list-style-type: square;"><li>The encoded err value is stored.</li><li>The entry for a sequence number will be cleared for the following conditions:<ul style="list-style-type: square;"><li>If its the last in a chain of split transactions as indicated by:<ul style="list-style-type: square;"><li>split_mask_valid &amp; response_split (A split response which has been allowed through)</li></ul></li><li>When the response passes by this block for a sequence number. (Only a single entry will have an accumulated err at a time for a chain of transactions.</li></ul></li><li>This logic is why the blocking signal block_no_seqnum_split &amp; split_req is needed. This logic cannot differentiate if the next sequence number is in the same striping chain as the sequence numbers could wrap around on itself. <ul style="list-style-type: square;"><li>The case is when the context is in the middle of a splitting chain, however there is still a lingering chain that is taking a log time to finish. This can cause sequential sequence numbers to not be in the same chain. </li></ul></li></ul><h3 id="HW-CTFctl_init_context-ReserveBeatBufferIndicator">Reserve Beat Buffer Indicator</h3><p>The reserve beat buffer indicator originates inside the PAM, however the context could mask this bit if the transaction is FIXED in burst type. This is done here because the lookup doesn't have access to the per transaction burst type.</p><h3 id="HW-CTFctl_init_context-BeatNumberCalculation">Beat Number Calculation </h3><p>The number of beats returned is kept track of in every context entry. This is needed for both sending back error responses and properly dropping beats that could be added from data width adapters.</p><p>The signal transaction_in_beats is driven with:</p><ul style="list-style-type: square;"><li>If its a Fixed or a Wrap there is no length adjustment. <ul style="list-style-type: square;"><li>Then if its Fixed that amount is divided by Burst Size.</li><li>If it is a WRAP its divided by Data Width. </li></ul></li><li>If it an INCR the length is adjusted by the address offset.<ul style="list-style-type: square;"><li>It is then divided by data width.</li><li>Then 1 is added if there is a remainder.</li></ul></li></ul><h3 id="HW-CTFctl_init_context-StatsInterfaceLogic">Stats Interface Logic</h3><p>The stats interface out is driven will all of the entry set and clear signals. These signals could be masked to specify a specific target.</p><h3 id="HW-CTFctl_init_context-BufferedWriteLogic">Buffered Write Logic</h3><p>The context block handles buffered writes with a special valid/ready mechanic. There are three main cases:</p><ul style="list-style-type: square;"><li>Ordering is not resolved for the Buffered Write in which case an early response is not sent.</li><li>Ordering is resolved and the response path is ready for the response. An early response is sent.</li><li>Ordering is resolved and the response path is not ready for the response. The context will block until the path is ready and then an early response is sent.</li></ul><p>In the last two cases the transaction will also be held until the data is aligned with the request as to not break the Common Layer protocol. This is done through a counter that keeps track of DP packets and requests that travel through the CTL layer.</p><h3 id="HW-CTFctl_init_context-RequestDataInterfaceDriver">Request Data Interface Driver</h3><p>The context must drive appropriate information to the request data path to handle narrows and errors.</p><div class="table-wrap"><table class="relative-table wrapped confluenceTable" style="width: 58.1541%;"><colgroup><col style="width: 10.7049%;"/><col style="width: 89.1756%;"/></colgroup><tbody><tr><th class="confluenceTh">Signal</th><th class="confluenceTh">Description</th></tr><tr><td class="confluenceTd">error</td><td class="confluenceTd">drop_from_error</td></tr><tr><td class="confluenceTd">start_offset</td><td class="confluenceTd">This is the burst size aligned address plus the split_wrap_offset. </td></tr><tr><td colspan="1" class="confluenceTd">wrap_len</td><td colspan="1" class="confluenceTd">Driven from the len signal of the incoming transaction.</td></tr><tr><td colspan="1" class="confluenceTd">burst_size</td><td colspan="1" class="confluenceTd">Driven from the burst size signal of the incoming transaction.</td></tr><tr><td colspan="1" class="confluenceTd">burst_type</td><td colspan="1" class="confluenceTd">If splitting exists then this can be forced to WRAP in the case of single_beat_wrap_transform, otherwise its the incoming burst type.</td></tr></tbody></table></div><h3 id="HW-CTFctl_init_context-ResponseDataInterfaceDriver">Response Data Interface Driver</h3><p>The context must drive appropriate information to the request data path to handle narrows and errors.</p><div class="table-wrap"><table class="relative-table wrapped confluenceTable" style="width: 58.1541%;"><colgroup><col style="width: 10.7049%;"/><col style="width: 89.1756%;"/></colgroup><tbody><tr><th class="confluenceTh">Signal</th><th class="confluenceTh">Description</th></tr><tr><td class="confluenceTd">start_offset</td><td class="confluenceTd"><p>Captured start_offset from Sequence Number Lookup. (Comes from narrow_offset context field) This is equal to:</p><ul style="list-style-type: square;"><li>size_aligned_address plus the split_wrap_offset</li></ul></td></tr><tr><td colspan="1" class="confluenceTd">end_offset</td><td colspan="1" class="confluenceTd"><p>Captured end_offset  from Sequence Number Lookup. (Comes from narrow_end_offset context field) This is equal to:</p><ul><li>If fixed its the size aligned address.</li><li>If its an INCR and not a single beat wrap transform the size aligned address plus the len of the transaction.</li><li>Otherwise its the length of the transaction</li></ul></td></tr><tr><td colspan="1" class="confluenceTd">wrap_len</td><td colspan="1" class="confluenceTd"><p>Captured <strong>end_offset</strong>  from Sequence Number Lookup. (Comes from narrow_end_offset context field) Note: Can possibly remove.</p></td></tr><tr><td colspan="1" class="confluenceTd">burst_size</td><td colspan="1" class="confluenceTd">Captured Burst Size from Sequence Number Lookup</td></tr><tr><td colspan="1" class="confluenceTd">burst_type</td><td colspan="1" class="confluenceTd">Captured Burst Type from Sequence Number Lookup</td></tr><tr><td colspan="1" class="confluenceTd">err_valid</td><td colspan="1" class="confluenceTd">Asserted when there is an error to be returned</td></tr><tr><td colspan="1" class="confluenceTd">err_ordering_id</td><td colspan="1" class="confluenceTd">The lookued up ordering id field of the error.</td></tr><tr><td colspan="1" class="confluenceTd">err_channel_id</td><td colspan="1" class="confluenceTd">The lookued up channel id field of the error.</td></tr><tr><td colspan="1" class="confluenceTd">err_id</td><td colspan="1" class="confluenceTd">The looked up id field of the error.</td></tr><tr><td colspan="1" class="confluenceTd">err_narrow</td><td colspan="1" class="confluenceTd">The looked up narrow field of the error.</td></tr><tr><td colspan="1" class="confluenceTd">err_burst_size</td><td colspan="1" class="confluenceTd">The looked up burst size field of the error.</td></tr><tr><td colspan="1" class="confluenceTd">err_burst_type</td><td colspan="1" class="confluenceTd">The looked up burst type field of the error.</td></tr><tr><td colspan="1" class="confluenceTd">err_start_offset</td><td colspan="1" class="confluenceTd">The looked up start offset field of the error.</td></tr><tr><td colspan="1" class="confluenceTd">err_end_offset</td><td colspan="1" class="confluenceTd">The looked up end offset field of the error.</td></tr><tr><td colspan="1" class="confluenceTd">err_last</td><td colspan="1" class="confluenceTd">The looked up last field of the error.</td></tr><tr><td colspan="1" class="confluenceTd">err_beats</td><td colspan="1" class="confluenceTd">The looked up beats field of the error.</td></tr><tr><td colspan="1" class="confluenceTd">drop</td><td colspan="1" class="confluenceTd">responseDpNoMatch</td></tr><tr><td colspan="1" class="confluenceTd">mask_last</td><td colspan="1" class="confluenceTd">~ (responseDpLast &amp; responseDpSplit)</td></tr><tr><td colspan="1" class="confluenceTd">dw_mask_last</td><td colspan="1" class="confluenceTd">Lookup up value of context_\=i=\_beats == 0</td></tr><tr><td colspan="1" class="confluenceTd">dw_force_last</td><td colspan="1" class="confluenceTd">Lookup up value of context_\=i=\_beats == 1</td></tr></tbody></table></div><h3 id="HW-CTFctl_init_context-CompressedIDLogic">Compressed ID Logic</h3><p>If the width of the SMI Ordering ID is smaller than the CTL Ordering ID compression will be used to make the smaller sequence number. All ordering will be done on the more restrictive smaller sequence number. By default the compressed sequence number is just the lower bits of the incoming ID, however this could be modified through the idCompMask parameter.</p><h3 id="HW-CTFctl_init_context-ReadInterleaveBarrier">Read Interleave Barrier</h3><p>There are three cases where if the initiator cannot interleave a barrier has to be put in:</p><ul style="list-style-type: square;"><li>A striped transaction across targets as no transactions can fall in-between those transactions.</li><li>A split transaction needs to be streamed to a target as no responses can fall in-between the split transaction.</li><li>If the target can interleave but the initiator cant then only a single transaction of each {ordering_id, channel_id} combo can be sent to a target at once.</li></ul><h3 id="HW-CTFctl_init_context-ResponseLookups">Response Lookups</h3><p>NDP Lookups are done using the response_matched_entry_vec and the following context entries have a lookup using the path_lookup block. When ctlCtxtPipe is enabled this lookup can take multiple cycles.</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Lookup </th><th class="confluenceTh">Condition</th></tr><tr><td class="confluenceTd">ordering_id</td><td class="confluenceTd">have_compressed_id | enContextKeys.includes(&quot;split&quot;)</td></tr><tr><td class="confluenceTd">split</td><td class="confluenceTd">enContextKeys.includes(&quot;split&quot;)</td></tr><tr><td class="confluenceTd">last</td><td class="confluenceTd">enContextKeys.includes(&quot;last&quot;)</td></tr><tr><td class="confluenceTd">first</td><td class="confluenceTd">enContextKeys.includes(&quot;first&quot;)</td></tr><tr><td class="confluenceTd">narrow_offset</td><td class="confluenceTd">enContextKeys.includes(&quot;narrow_offset&quot;)</td></tr><tr><td class="confluenceTd">narrow_end_offset</td><td class="confluenceTd">enContextKeys.includes(&quot;narrow_end_offset&quot;)</td></tr><tr><td class="confluenceTd">burst_size</td><td class="confluenceTd">enContextKeys.includes(&quot;burst_size&quot;)</td></tr><tr><td class="confluenceTd">burst_type</td><td class="confluenceTd">enContextKeys.includes(&quot;burst_type&quot;)</td></tr><tr><td class="confluenceTd">resp_sent</td><td class="confluenceTd">have_seqnum</td></tr><tr><td colspan="1" class="confluenceTd">targ_id</td><td colspan="1" class="confluenceTd">enContextKeys.includes(&quot;targ_id&quot;)</td></tr><tr><td colspan="1" class="confluenceTd">buf_write</td><td colspan="1" class="confluenceTd">enContextKeys.includes(&quot;buf_write&quot;)</td></tr></tbody></table></div><h3 id="HW-CTFctl_init_context-DataWidthAdaptionBeatMasking">Data Width Adaption Beat Masking</h3><p>Based on a responseDpMatch signal from the sequence number capture logic a lookup is done to see how many beats a context entry has left. If the beat value is 0 that means the rest of the data beats must be masked, and if it is 1 that means it is the last data beat and the last must be forced. </p><h3 id="HW-CTFctl_init_context-NDPSuppression">NDP Suppression</h3><p>It is possible an incoming NDP must be suppressed as to not send multiple NDPs for a single data packet. On the CTL interface its a 1 for 1 transaction to ndp where as on SMI a single transaction can have multiple NDPs if interleaved.</p><p>This condition can occur when a transaction is split or a transaction is interleaved. The ndp is supressed depending on the lookup value of resp_sent. </p><h3 id="HW-CTFctl_init_context-SequenceNumberCapture">Sequence Number Capture</h3><p>To get context data for the data path the sequence number must be known for the current transaction that is on the data path. This means it must be captured as the ndp comes in, and released once a DP packet has finished. Timing can also be split by capturing other attributes next to the sequence number.</p><p>One property to enable single cycle is that this capture can be bypassed. </p><p>The following fields are captured alongside the sequence number:</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Field</th><th class="confluenceTh">Condition</th><th colspan="1" class="confluenceTh">Description</th></tr><tr><td class="confluenceTd">captured_seq_num_valid</td><td class="confluenceTd">Always</td><td colspan="1" class="confluenceTd">Indication that the captured value is valid or there is an incoming valid NDP.</td></tr><tr><td class="confluenceTd">captured_burst_size</td><td class="confluenceTd">narrowSupported</td><td colspan="1" class="confluenceTd">The captured lookup for the burst size of the transaction.</td></tr><tr><td class="confluenceTd">captured_burst_type</td><td class="confluenceTd">narrowSupported</td><td colspan="1" class="confluenceTd">The captured lookup for the burst type of the transaction.</td></tr><tr><td class="confluenceTd">captured_start_offset</td><td class="confluenceTd">narrowSupported</td><td colspan="1" class="confluenceTd">The captured lookup for the start offset of the transaction.</td></tr><tr><td class="confluenceTd">captured_end_offset</td><td class="confluenceTd">narrowSupported</td><td colspan="1" class="confluenceTd">The captured lookup for the end offset of the transaction.</td></tr><tr><td colspan="1" class="confluenceTd">captured_seq_num_out</td><td colspan="1" class="confluenceTd">have_seq_num</td><td colspan="1" class="confluenceTd">The captured sequence number from the ndp path.</td></tr><tr><td colspan="1" class="confluenceTd">captured_id_out</td><td colspan="1" class="confluenceTd">have_in_resp_ordering_id</td><td colspan="1" class="confluenceTd">The captured id from the ndp path.</td></tr><tr><td colspan="1" class="confluenceTd">responseDpNoMatch</td><td colspan="1" class="confluenceTd">Always</td><td colspan="1" class="confluenceTd">Captured whether the NDP matched with any entries. If not the data is dropped. </td></tr><tr><td colspan="1" class="confluenceTd">responseDpMatch</td><td colspan="1" class="confluenceTd">Always</td><td colspan="1" class="confluenceTd">Captured  what entry the DP matched. Used to break up long timing path. </td></tr></tbody></table></div><h3 id="HW-CTFctl_init_context-SequenceNumberGenerationandHandling">Sequence Number Generation and Handling</h3><p>For any context there is 2 * the number of context entries of sequence numbers. They are issued in order and you cannot skip sequence numbers. So if the last selected sequence number was 6 and 7 is still outstanding then the context will block. </p><p>Sequence numbers are set when a transaction leaves the context and is cleared once its either last beat of data and or ndp has been returned. This is differant than when its respective context entry is cleared. Its possible to clear a context entry early.</p><p>Sequence numbers can also be poisoned when they timeout. A poisoned sequence number cannot be used again and will be skipped for assignment. They will all un-poison with either a reset or they are all poisoned.</p><p>The oldest sequence number outstanding is also kept track of for error responses. It increments through the sequence number until it sees a valid non poisoned one. Once that sequence number is cleared it continues iterating until another valid one is found.</p><h3 id="HW-CTFctl_init_context-TransactionCounter">Transaction Counter</h3><p>The number of reads and writes outstanding are also kept track of. They are two simple counters that increment purely on if an outgoing transaction was a read/write or if incoming responses are reads or writes. There is no special per transaction information. </p><p><br/></p>