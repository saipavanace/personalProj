<h3 id="QuickguidetofunctionalprogramminginTACHLJavaScript-Overview">Overview</h3><p>This page is meant to serve as a quick guide to understanding and using functional programming patterns in the JavaScript portion of TACHL code. The guide includes mostly basic functional programming patterns such as anonymous functions, higher-order functions, composition, and factory functions.</p><h3 id="QuickguidetofunctionalprogramminginTACHLJavaScript-Firstclassfunctions">First class functions</h3><p>All JavaScript functions are first-class functions. This means that functions can be treated like any other object that can be passed as arguments to functions (Ex: map, forEach) and returned by functions (Ex: bind, compose). Functions also come with some useful properties and methods on them.</p><h3 id="QuickguidetofunctionalprogramminginTACHLJavaScript-Anonymousfunctions">Anonymous functions</h3><p>An anonymous function is an <strong>expression</strong> that evaluates to a function object. Because it is an expression it doesn't have a name itself (anonymous) and hence needs to be assigned to a variable or passed as an argument in a function call to be useful.</p><p>A convenient way to create an anonymous function is by using the <strong>Big-arrow</strong> (=&gt;) operator.</p><p>Example 1:<br/>var f    = (a, b) =&gt; {            // Equivalent to function f (a, b) { ... }<br/>    var sum        = a + b;  <br/>    var product  = a * b; <br/>    return { sum, product };<br/>};</p><p>var c   = f(3,4);   // f can now be called using ( ). In this case it returns { sum: 7, prod: 12 }</p><p>In the above example, the variable 'f' on the LHS is bound to a function object evaluated by the expression on the RHS. Function parameters are comma-separated and enclosed within parenthesis on the left of =&gt;. And the function body is defined on the right of =&gt; and enclosed with curly braces { }.</p><h4 id="QuickguidetofunctionalprogramminginTACHLJavaScript-Simplification1:">Simplification 1:</h4><p>If the function body has a <strong>return statement</strong> <strong>only</strong>, <strong>skip the braces and the 'return' keyword</strong>. For example the following anonymous function:</p><p>Example 2:<br/>var prod   = (a, b) =&gt; {<br/>    var c            = a * b<br/>    return c;<br/>};</p><p>can be simplified to</p><p>var prod   = (a, b) =&gt; a * b;<br/>prod (5, 3)   // Returns 15<br/><br/>Example 1 mentioned earlier could also be simplified to<br/>var f        = (a, b) =&gt; ( { sum: a+b, product: a*b } );  // Parentheses are necessary when returning objects literals.</p><p>Note that the parentheses was necessary above around the return value because otherwise the compiler confuses the curly braces { } for those around a function body.</p><h4 id="QuickguidetofunctionalprogramminginTACHLJavaScript-Simplification2:">Simplification 2:</h4><p>If the function accepts <strong>exactly one parameter, skip the parentheses</strong> around the parameter.</p><p>Example 3:<br/>var incr       = x =&gt; x + 1;<br/>incr(3)    // Returns 4</p><p>This is the most common way to use anonymous functions when using built-in JS functions and methods such as map, filter, find etc.</p><h3 id="QuickguidetofunctionalprogramminginTACHLJavaScript-Higherorderfunctions">Higher order functions</h3><p>A higher order function is any function that accepts a function as a parameter. The function that is passed as an argument when calling a higher order function is called a callback function. Most commonly used JavaScript higher order functions are the ones that are available as methods on array objects.</p><h4 id="QuickguidetofunctionalprogramminginTACHLJavaScript-Higherorderarraymethods">Higher order array methods</h4><h5 id="QuickguidetofunctionalprogramminginTACHLJavaScript-Callbackfunctionrules"><strong>Callback function rules</strong></h5><p>The callback functions passed to array methods are most commonly unary functions i.e. they take exactly one argument, even though a function that take two arguments can also be used. In either case,</p><ol><li>The first parameter of the callback function always receives an element from the array </li><li>The second parameter ( if it exists) receives the index of the element in the array</li></ol><p>The above rules are true for most higher order array methods except reduce.</p><p>The most useful higher order functions/methods on array objects are described described below:</p><p><br/></p><h5 id="QuickguidetofunctionalprogramminginTACHLJavaScript-.map(fn)">.map( fn )</h5><p>The map method returns a new array the elements of which are computed by applying the function fn on every element of the input array i.e. the array on which the method is called. Hence the output array length = input array length.</p><p>Example 4:<br/>function add3 ( x ) {<br/>   return x + 3;<br/>}<br/>var a  = [ 3, 4, 5, 6, 7 ];<br/>var b  = a.map( add3 );  // Returns [ 6, 7, 8, 9, 10 ]<br/><br/>Alternatively the callback function, add3 could have been defined in-line inside the function call as an anonymous function:<br/>var b  = a.map( x =&gt; x+3 ); // Returns [ 6, 7, 8, 9, 10 ] </p><p><br/></p><h5 id="QuickguidetofunctionalprogramminginTACHLJavaScript-.filter(fn)">.filter( fn )</h5><p>The filter method returns a new array that consists of a sub-set of elements of the input array, such that if x is an element of input array, then it is also included in the new array only if fn(x) evaluates to <em>true</em> in boolean context. Hence output array length &lt;= input array length.</p><p>Example 5:</p><p>var c  = a.filter( x =&gt; x%3 === 0 );  // Returns [ 3, 6 ]</p><p>var d  = [ 3, 5, 0, 6, 0, 7 ].filter( x =&gt; x ); // Returns [ 3, 5, 6, 7] because 0 evaluates to false in boolean context</p><p><br/></p><h5 id="QuickguidetofunctionalprogramminginTACHLJavaScript-.find(fn)">.find( fn )</h5><p>The find method returns the first element x in the input array such that fn( x ) evaluates to <em>true</em> in boolean context. If fn( x ) returns false for all the elements, the functions returns an <em>undefined</em> value.</p><p>Example: 6</p><p>var c  = a.find( x =&gt; x &gt; 4 ); // Returns 5</p><p>Because the return value of the .find( ) method is undefined when an entry was not found and because <em>undefined</em> evaluates to <em>false</em> in a boolean context, we could set defaults using shorting when used on an array of objects.</p><p>Example: 7</p><p>function calcRoute ( routeTable, target ) {<br/>    // Assume routeTable is an array of objects that looks something like this: [ { target: 3, route: 4 }, { target: 4, route 7 }, { target: 1, route: 2 } ];<br/>    var routeLookup  = routeTable.find( x =&gt; x.target === target ) || { target: 0, route: 0 };     // If no matching target found, routeLookup defaults to the value { target: 0, route: 0 }.<br/>    return routeLookup.route;   // variable 'routeLookup' will never be undefined because it has a default and hence this line will never error out.<br/>}<br/><br/></p><h3 id="QuickguidetofunctionalprogramminginTACHLJavaScript-Partialapplication(usingbind)">Partial application (using bind)</h3><p>When a function is called with all the arguments, we say that the function was 'applied' to those arguments. Doing so evaluates to the return value of the function. In the functional programming paradigm, functions can also be 'partially' applied only to some of the arguments. Doing so evaluates to a function of the remaining parameters. This is useful to create specialized functions with fewer parameters from functions that take more parameters. One way to partially apply functions is by calling the .bind( ) method provided on function objects in JavaScript.</p><p>Example 8:</p><p>Suppose we have a general function that takes as input three parameters type, direction and name as input parameters to return an interface object:</p><p>getInterface( type, direction, name ).</p><p>And say we have two lists of interrupt names as below:<br/>var error = [ &quot;timeout_&quot;, &quot;decode_&quot;, &quot;overflow_&quot; ];<br/>var info   = [ &quot;done_&quot;, &quot;status_&quot; ];<br/><br/>Our goal is to generate slave interrupt interfaces using the names above. To do so, we first partially apply the first two arguments of the function using bind( ) on the getInterface( ) function as follows:<br/>var getSlvIntInterface   = getInterface.bind( null, &quot;InterfaceINT&quot;, &quot;slave&quot; );     // Returns a function that now is a function of the only remaining parameter: '<em>name</em>'</p><p>The getSlvIntInterface( ) function is now a unary function that can be used to create interfaces for the error and info interrupts above as follows:</p><p>var errorInterfaces   = error.map( getSlvIntInterface );  // Returns an array of interface objects of type &quot;InterfaceInt&quot;, direction &quot;slave&quot;, and names taken from the error array above<br/>var infoInterfaces     = info.map( getSlvIntInterface );   // Returns an array of interface objects of type &quot;InterfaceInt&quot;, direction &quot;slave&quot;, and names taken from the info array above</p><h5 id="QuickguidetofunctionalprogramminginTACHLJavaScript-.bind(thisArg,arg1,arg2,...)">.bind( thisArg, arg1, arg2, ... )</h5><p>The .bind( ) function returns a new function that is bound to the arguments passed to bind( ). And this new function now accepts only the remaining parameters of the method or function on which .bind( ) was called. The first argument (thisArg) to bind is used only for methods inside an object i.e. functions that have '<em>this</em>' references inside. But for all other functions, we just pass a <em>null</em> instead indicating that it's unused.</p><h3 id="QuickguidetofunctionalprogramminginTACHLJavaScript-Functioncomposition">Function composition</h3><p>Suppose we have two unary functions, g and h. Then the function composition f of functions g and h, is a unary function such that f(x) = g(h(x)) .i.e. the return value of h(x) is used as the input argument to another function g.</p><p>Example 9:</p><p>Suppose we have an array of binary-encoded Verilog constants (strings):</p><p>var binValues = [ &quot;2'd2&quot;, &quot;2'd3&quot;, &quot;2'd0&quot;, &quot;2'd1&quot; ]</p><p>We wish to transform every value in the array above to equivalent one-hot encoded values. To do this we make use of two library functions in lib_utils.js: parseVlogConst( ) and genVlogConst( ) ( described here: <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16167365/js+Library+Functions" data-linked-resource-id="16167365" data-linked-resource-version="10" data-linked-resource-type="page">js Library Functions</a> ). The parseVlogConst takes a verilog-constant string and returns an object with 3 values: { width, radix, value }. The genVlogConst takes the same type of object and returns back a verilog constant string. We also create a third function that takes one such object and converts the value to a one hot encoded value as below:<br/><br/>var parsedBin2OneHot    = x =&gt; ( { width: 1&lt;&lt;x.width, value: BigInt(1)&lt;&lt;x.value, radix: 2 } );      // parsedBin2OneHort is now a function that returns this modified object. Note that the type of '<em>value</em>' property in the object is a BigInt and hence the need to do BigInt(1)</p><p>Now instead of doing<br/>var oneHotValues          = binValues.map(  x =&gt; genVlogConst( parsedBin2OneHot( parseVlogConst(x) ) ) );    // Too much noise and hard to read because of function call nesting<br/>Or<br/>var oneHotValues         = binValues.map( parseVlogConst ).map( parsedBin2OneHot ).map( genVlogConst ); // Leads to multiple map calls and multiple iterations</p><p>A better solution is to use the <strong>compose( ) or pipe( ) utility</strong> function to generate the composition of the three functions: parseVlogConst, parsedBin2OneHot, and genVlogConst:</p><p>var bin2OneHot            = compose( genVlogConst, parsedBin2OneHot, parseVlogConst );  // This is now a function that takes a verilog constant string and returns another. No function call nesting.<br/>OR<br/>var bin2OneHot            = pipe( parseVlogConst, parsedBin2OneHot, genVlogConst ); // Same as above except the order in which the functions are passed is reversed so that it works similar to Unix pipe.</p><p>And use the composed function with map:</p><p>var oneHotValues          = binValues.map( bin2OneHot );  // Returns [ &quot;4'b100&quot;, &quot;4'b1000&quot;, &quot;4'b1&quot;, &quot;4'b10&quot; ] in a single iteration and without noise. </p><h3 id="QuickguidetofunctionalprogramminginTACHLJavaScript-Closure">Closure</h3><p>JavaScript allows function definitions to be nested i.e. a function can be defined inside another function. When</p><ol><li>The nested function accesses variables in the outer function's scope and</li><li>The outer function returns the nested function</li></ol><p>the returned function remembers the values of outer-scope variables at the time it was created and returned. Such a function is called a closure. Because closures retain state, they provide an alternative means to traditional class-based approach for creating objects. A closure also provides complete data privacy unlike objects created from prototypes or classes.</p><h3 id="QuickguidetofunctionalprogramminginTACHLJavaScript-Factoryfunctiona.k.aModulepattern">Factory function a.k.a Module pattern</h3><p>A factory function approach is an alternative means of encapsulating data and functionality into objects without using classes or prototypes. A factory function when called returns an object with functions. The functions returned inside the object are defined inside the factory function. When such functions access variables in the factory-function's scope, they become closures. The closures remember the values of such variables at the time the factory function was called, hence providing a way to initialize the objects created.</p><p>Example 10:</p><p>Suppose we want a factory function that can create an object representing a slice on a bit-vector. We wish to initialize the object during it's creation with a pair of start and end indices. And we would like to have functions that calculate width, shift a slice, compare if two slices are equal etc.</p><p>// Define a factory function to create a slice object<br/>function slice(start, end) {<br/>    const width             = start - end + 1;<br/><br/>    function equal( sliceObj ) {<br/>        return (sliceObj.start( ) === start ) &amp;&amp; (sliceObj.end( ) === end);<br/>    }<br/><br/>    function shift( offset ) {<br/>       return slice( start+offset, end+offset );<br/>    }<br/><br/>    return { <br/>                 &quot;width&quot;: ( ) =&gt; width, <br/>                 &quot;start&quot;: ( ) =&gt; start,<br/>                 &quot;end&quot;: ( ) =&gt; end,<br/>                  shift,<br/>                  equal<br/>              };        // Return an object with functions<br/>}</p><p>Now we can create slice objects this way</p><p>var sliceA         = slice( 3, 0 );    // Returns a slice object initialized with start index 7 and end index 4<br/>var sliceB         = slice( 7, 4 );<br/><br/>And now functions inside the object can be called as though they are methods on that object:</p><p>var total           = sliceA.width( )  + sliceB.width( );   // Returns 4 + 4 = 8<br/>var sliceC          = sliceA.shift( 2 );  // Returns a slice object with start index 5, end index 2<br/>var result          = sliceB.equal( sliceC ); // Returns boolean false<br/>OR<br/>var result          = sliceA.shift( 4 ).equal( sliceB ); // Returns boolean true</p><p><br/></p><p>Note that although the function calls above look like method calls, they are different from methods in the sense that they don't have references to <em>this</em> (context) and are not defined on any function's prototype. This means if you ever use <em>.bind</em>( ) on one of the functions returned by a factory, the first argument must be passed <em>null</em>.</p><p><br/></p>