<h2 id="HW-CTFsym_apb_csr-module_name">module_name</h2><div class="wiki-content"><p>sym_apb_csr</p><h2 id="HW-CTFsym_apb_csr-JavaScriptparameters">JavaScript parameters</h2><p><strong><em>csr:</em></strong> An object that follows the <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16154965/csr" data-linked-resource-id="16154965" data-linked-resource-version="35" data-linked-resource-type="page">csr</a> specification. It has the descriptions of all the registers that need to be put down. Only spaceBlock[0] will be used and others ignored. <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16154965/csr" data-linked-resource-id="16154965" data-linked-resource-version="35" data-linked-resource-type="page">csr</a> objects with multiple spaceBlocks need to be broken into multiple <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16154965/csr" data-linked-resource-id="16154965" data-linked-resource-version="35" data-linked-resource-type="page">csr</a> objects with a single spaceBlock before using sym_apb_csr module.</p><p><em><strong>flopAPB:</strong></em> A string that is either &quot;yes&quot; or &quot;no&quot;. Setting to &quot;yes&quot; pipelines the cfgInterface described in the section &quot;Interfaces&quot;.</p><p><em><strong>enSwWritePorts:</strong></em> An integer that is either one or zero. Setting to 1 creates software write ports (See under the section &quot;ports&quot;).</p><p><em><strong>enSwReadPorts:</strong></em> An integer that is either one or zero. Setting to 1 creates software read ports (See under the section &quot;ports&quot;).</p><p><em><strong>protectionStyle:</strong></em> <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16169044/protectionStyle" data-linked-resource-id="16169044" data-linked-resource-version="15" data-linked-resource-type="page">protectionStyle</a></p><h2 id="HW-CTFsym_apb_csr-I/O">I/O</h2><h3 id="HW-CTFsym_apb_csr-Interfaces">Interfaces</h3><p><strong><em>clkInterface:</em></strong> A slave interface of type <a class="external-link" href="https://confluence.arteris.com/display/ENGR/InterfaceCLK" rel="nofollow">InterfaceCLK</a></p><p><strong><em>cfgInterface:</em></strong> Config Interface to provide software access to registers. This is a slave interface of type <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168579/InterfaceAPB" data-linked-resource-id="16168579" data-linked-resource-version="2" data-linked-resource-type="page">InterfaceAPB</a>.</p><p><strong><em>protectionInterface:</em></strong> This is an optional interface. A master interface of type <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168667/InterfacePROT" data-linked-resource-id="16168667" data-linked-resource-version="16" data-linked-resource-type="page">InterfacePROT</a>.</p><h3 id="HW-CTFsym_apb_csr-Ports">Ports</h3><p>The block also creates certain individual ports depending on design parameters and register, field definitions. They can be grouped as below:</p><p><strong><em>Hardware-access-ports</em>:</strong> These ports are signals to allow hardware to update register-fields or to read them. The output ports are named &quot;<em><strong>reg_field_out</strong></em>&quot;, where <em>reg</em> is the register name and <em>field</em> is the field name. And the input ports are named &quot;<em><strong>reg_field_in</strong></em>&quot; and &quot;<em><strong>reg_field_wr</strong></em>&quot;. The &quot;<em>reg_field_in</em>&quot; and &quot;<em>reg_field_out</em>&quot; are of the same width as that of the register-field width. The &quot;<em>reg_field_out</em>&quot; signals are created only if the &quot;hardware&quot; property in the CSR JSON is set to either &quot;RO&quot; or &quot;RW&quot; types. The &quot;<em>reg_field_in</em>&quot; and &quot;<em>reg_field_wr</em>&quot; ports are created when the property &quot;<em>hardware</em>&quot; for the given field is set to one of the following types: &quot;WO&quot;, &quot;RW&quot;. And when both <em>hardware</em> and <em>access</em> properties for a register-field are set to &quot;RO&quot; (but not Rsvd), only <em>reg_field_in</em> signals are generated.</p><p><strong><em>Software-write-ports</em>:</strong> These are output ports generated for every registers and are named &quot;<em><strong>reg_sw_wr</strong></em>&quot;, and &quot;<em><strong>reg_field_sw_wdata</strong></em>&quot;, where reg is the register name, and <em>field</em> is the field name. To enable this set the parameter <strong><em>enSwWritePorts</em> </strong>to 1. A high on the signal indicates that a write was attempted on the corresponding register.</p><p><strong><em>Software-read-ports</em>:</strong> These are output ports generated for every registers and are named &quot;<em><strong>reg_sw_rd</strong></em>&quot;, where <em>reg</em> is the register name. To enable this set the parameter <strong><em>enSwReadPorts</em> </strong>to 1. A high on the signal indicates that a read was attempted on the corresponding register.</p><p><strong><em>TrustZone-ports</em>:</strong> These are input ports generated per register if the parameter or property <strong><em>tzMode</em> </strong>is set to &quot;<em>programmable</em>&quot;. The names generated for such ports are of the form &quot;<em><strong>reg_tz</strong></em>&quot;, where reg is the register-name. A low on this signal indicates that only secure read and write accesses are allowed on the register. A secure access on the <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168579/InterfaceAPB" data-linked-resource-id="16168579" data-linked-resource-version="2" data-linked-resource-type="page">InterfaceAPB</a> is indicated by a low on PPROT[1]. If the values on the reg_tz signal differs from that on PPROT[1] during a</p><ol><li>Write access - The register-write is prevented. The block responds with an error response (pslverr high).</li><li>Read access- The register-read returns all zeros. The block also responds with an error response (pslverr high).</li></ol><p><strong><em>Register-operation-enable-ports</em>:</strong> This are input ports with names &quot;<em><strong>reg_wr_en</strong></em>&quot; and &quot;<em><strong>reg_rd_en</strong></em>&quot;, where reg is the register name. These ports are created only for those registers for which <strong><em>regOpEn</em> </strong>field exists in the CSR and is set to true. Setting &quot;reg_wr_en&quot; low prevents write and setting reg_rd_en low responds with all-zero data. Both cases will also be responded with an error response (pslverr high).</p><p>For TACHL components that instantiate the sym_apb_csr block, it is recommended that they use the <em>getHWPorts</em> ( ) method in the <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16161120/HW-SYM+Class+CreateCSRObj" data-linked-resource-id="16161120" data-linked-resource-version="19" data-linked-resource-type="page">HW-SYM Class CreateCSRObj</a>, so that the port names for the sym_apb_csr referenced in the block and the port names used inside the sym_apb_csr block all match.</p><h2 id="HW-CTFsym_apb_csr-Description">Description</h2><p>The sym_apb_csr component block implements a set of configuration registers or control-status registers, the specifications for which are provided by means of a <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16154965/csr" data-linked-resource-id="16154965" data-linked-resource-version="35" data-linked-resource-type="page">csr</a> parameter or data-structure. The CSR specification itself is described in the following link and page: <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16154965/csr" data-linked-resource-id="16154965" data-linked-resource-version="35" data-linked-resource-type="page">csr</a>.</p><p>Each field in a register could potentially be accessed by both software and hardware. Accessibility by hardware or software are specified in the <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16154965/csr" data-linked-resource-id="16154965" data-linked-resource-version="35" data-linked-resource-type="page">csr</a> data-structure for each field.</p><p>The component provides an APB slave interface for accessibility through software, and a group of ports for accessibility by hardware. </p><h3 id="HW-CTFsym_apb_csr-Updatingregister-data">Updating register-data</h3><p>The sym_apb_csr block instantiates a single <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16163252/prot_reg" data-linked-resource-id="16163252" data-linked-resource-version="4" data-linked-resource-type="page">prot_reg</a> instance for all non-read-only (both <em>hardware</em> and <em>access</em> set to <em>RO</em>) fields of a register. This means that all of the fields are updated together at the same time with a single-enable for the whole register (not per field). This simplifies logic associated with memory protection (against errors. Refer <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16169044/protectionStyle" data-linked-resource-id="16169044" data-linked-resource-version="15" data-linked-resource-type="page">protectionStyle</a>) of registers, but leads to some complexity in the code in how the registers are updated during write operations:</p><ol><li>If there are multiple writes that are to be used to update the register such as software write, software-clear writes, hardware-writes (per-field), then there's a need to preserve bits that are not being updated by rewriting the same values for each update.</li><li>If there is only a single write signal for the register, then all the bits can be updated at the same time and no need to rewrite or preserve any previous values.</li></ol><p>There can be 3 types of writes that can cause the register to be updated and either none (All read-only) or some or all of them can exist for a given register:</p><ol><li><strong>Hardware writes</strong>: As many hardware writes can update a register as the number of fields in that register with <em>hardware</em> property set to one of the following: RW, WO. The hardware-writes are inputs to the block (*_wr) each of which are generated on a per-register-field basis.</li><li><strong>Software non-clear write</strong>: At most only one software write can update a given register as long as <em>access</em> property for at least one field in the register is set to: RW, WO. Only one can exist per register since a single write transaction will update all such write-able fields in the register. Equation for software non-clear write = register-address-match and pwrite.</li><li><strong>Software clear writes</strong>: As many of these exist as the number of fields in that register with <em>access</em> property set to W1C. Field bits marked as W1C (access) can only be updated to a zero (when software attempts to write a 1) to a bit that is also 1. Since not all such fields in a register may be cleared at the same time, a separate clear-write exists for each such field. Equation for Clear write = | (APB-pwdata-slice &amp; prot_reg flop-bits for that field)  &amp; software non-clear write.</li></ol><p>Note that for a given field, software non-clear write and software clear-write are mutually exclusive - only one of them can be used at a time. However hardware-writes and software-writes can exist simultaneously.</p><p>Corresponding to the the above 3 writes there are three types of data for a given field:</p><ol><li><strong>Hardware data</strong>: which are inputs to the sym_apb_csr block (*_in) each of which are generated on a per-register-field basis.</li><li><strong>Software non-clear data</strong>: A slice of pwdata signal on APB interface such that the width and bits correspond to that of the given field.</li><li><strong>Software clear data</strong>: This is the data with which a W1C field is to be updated with when a software clear write occurs for the field. Only bits on the APB pwdata with ones need to force a zero on the corresponding bits on prot_reg flops. The equation for clear-data = (~pwdata-slice &amp; prot-reg-Q Slice ) iff width of this field &gt; 1 else 0.</li></ol><p>In addition there's a <strong>4th type of data</strong>, that the flop-bits need to be written with. When no writes of the current field are active writes are active for updating other fields in the same register, then the same bits of the field need to be re-written since we are forced to update bits of all fields at the same time. This we call '<strong>saved-data</strong>' which is nothing but a slice of prot-reg Q bits corresponding to the given field.</p></div><div class="wiki-content"><p><br/></p><p>To detect the various writes required to update a field and to determine which kind of data is needed, the software (JS) generates a writeDetectTable:</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">write</th><th class="confluenceTh">data</th><th class="confluenceTh">exists</th><th class="confluenceTh">priority</th></tr><tr><td class="confluenceTd">hardware write</td><td class="confluenceTd">hardware-data</td><td class="confluenceTd"><p><em>hardware</em> = RW or WO</p></td><td class="confluenceTd"><em>opOrder </em>=== SW ? 2 : 3</td></tr><tr><td class="confluenceTd">software non-clear write</td><td class="confluenceTd">software-non-clear-data</td><td class="confluenceTd"><em>access</em> = RW or WO</td><td class="confluenceTd"><em>opOrder </em>=== SW ? 3 : 2</td></tr><tr><td class="confluenceTd">software clear write</td><td class="confluenceTd">software-clear-data</td><td class="confluenceTd"><em>access</em> = W1C</td><td class="confluenceTd"><em>opOrder </em>=== SW ? 3 : 2</td></tr><tr><td class="confluenceTd">None</td><td class="confluenceTd">saved-data</td><td class="confluenceTd">Number of writes that can update this field &lt; Number of writes that can update the register</td><td class="confluenceTd">0</td></tr></tbody></table></div><p><br/></p><p>Using the above generated table, the equation for the input <em>d_in</em> of <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16163252/prot_reg" data-linked-resource-id="16163252" data-linked-resource-version="4" data-linked-resource-type="page">prot_reg</a> per-field can be determined as follows:</p><ol><li>Filter out all rows that fail the condition under the <em>exists</em> column. </li><li>Sort out all the rows according to opOrder to ensure proper priority of one operation over another</li><li>If N rows remain, then the the equation for reg_field_d_in = write0 ? data0 : write1 ? data1 : ... : dataN, where write0, write1,... are writes in column <em>write</em>, data0, data1,... are data under column <em>data</em>. If N===1, then reg_field_d_in = data0;</li></ol><p>For example:</p><p>Suppose a register REG has two fields - field A (<em>access</em>: RW, <em>hardware</em>: RO), field B (<em>access</em>: RO, <em>hardware</em>: RW), then the input equations for the register can be generated from the table as below:</p><p>Total number of writes for the register  =  1 software write (REG_sw_wr) + 1 hardware write (REG_field_B_wr) = 2</p><p>The filtered ordered table (Step 1 and 2) for field A would be (total number of writes that update the field = 1): </p><div class="table-wrap"><table class="wrapped confluenceTable"><tbody><tr><th class="confluenceTh">write</th><th class="confluenceTh">data</th><th class="confluenceTh">exists</th><th class="confluenceTh">priority</th></tr><tr><td class="confluenceTd">REG_sw_wr</td><td class="confluenceTd">pwdata slice</td><td class="confluenceTd">true</td><td class="confluenceTd">2</td></tr><tr><td class="confluenceTd">None</td><td class="confluenceTd">prot-reg flop bits</td><td class="confluenceTd">true</td><td class="confluenceTd">0</td></tr></tbody></table></div><p><br/></p><p>The filtered ordered table (Step 1 and 2) for field B would be (total number of writes that update the field = 1):</p><div class="table-wrap"><table class="wrapped confluenceTable"><tbody><tr><th class="confluenceTh">write</th><th class="confluenceTh">data</th><th class="confluenceTh">exists</th><th class="confluenceTh">priority</th></tr><tr><td class="confluenceTd">REG_field_B_wr</td><td class="confluenceTd">REG_field_B_in</td><td class="confluenceTd">true</td><td class="confluenceTd">3</td></tr><tr><td class="confluenceTd">None</td><td class="confluenceTd">prot-reg flop bits</td><td class="confluenceTd">true</td><td class="confluenceTd">0</td></tr></tbody></table></div><p><br/></p><p>From Step 3, the equations for inputs of  <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16163252/prot_reg" data-linked-resource-id="16163252" data-linked-resource-version="4" data-linked-resource-type="page">prot_reg</a> can be constructed from the above generated tables as follows:</p><p>REG_field_A_d_in = REG_sw_wr ? pwData-slice : prot-reg-flop-bits<br/>REG_field_B_d_in = REG_field_B_wr ? REG_field_B_in : prot-reg-flop-bits<br/>REG_d_in              = { REG_field_B_d_in, REG_field_A_d_in }  // concatenate<br/>REG_en                 = REG_sw_wr | REG_field_B_wr</p><h3 id="HW-CTFsym_apb_csr-Read-onlyfields">Read-only fields</h3><p>When both the <em>hardware</em> and <em>access</em> fields for a register-field is specified to be <em>&quot;RO&quot;</em> there will be no flops inferred for that field in the design. For such fields also, the <em>reg_field_in</em> ports are generated to have external logic control the values of those fields when read. The value when read from such a field is determined by the bitwise-XOR of two values:</p><ol><li>The value on the <em>reg_field_in</em></li><li>The value specified for the property <em>reset</em> in the CSR for the register and field.</li></ol><p>Thus if there is no intention to externally control the read values on these fields, the <em>reg_field_in</em> needs to be tied-off to zero. And the default value of the field can be specified in the <em>reset</em> property in CSR. </p><h3 id="HW-CTFsym_apb_csr-Reservedfields">Reserved fields</h3><p>These are register fields whose names start with the string &quot;Rsvd&quot; or match <strong><em>Rsvd*</em></strong>. Because they are reserved fields their <em>hardware</em> and <em>access</em> properties are also set to &quot;<em>RO&quot;</em>. However unlike the fields described under the section &quot;Read-only fields&quot;, these fields do not result in generation of the <em>reg_field_in</em> ports.</p><h3 id="HW-CTFsym_apb_csr-Supportedvaluesforhardwareandaccesspropertiesofaregisterfield">Supported values for <em>hardware</em> and <em>access</em> properties of a register field</h3><p>Although both <em>hardware</em> and <em>access</em> properties can take any one of the following values individually: &quot;RW&quot;, &quot;RO&quot;, &quot;W1C&quot;, and &quot;WO&quot;, there are only certain combinations of values on the <em>hardware</em> and <em>access properties</em> that are legal or are supported by sym_apb_csr. The table below lists all the support combinations for these two properties:</p><p><br/></p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh"><em>access</em></th><th class="confluenceTh"><em>hardware</em></th><th class="confluenceTh">Supported</th><th class="confluenceTh">Use-case</th></tr><tr><td class="confluenceTd">RW</td><td class="confluenceTd">RO</td><td class="confluenceTd">Yes</td><td class="confluenceTd">Typical read-write register, that can be written and read by software, and read or consumed by hardware logic.</td></tr><tr><td class="confluenceTd">RO</td><td class="confluenceTd">RW</td><td class="confluenceTd">Yes</td><td class="confluenceTd"><p>Timer values are an example of this type that can only be updated by hardware.</p></td></tr><tr><td colspan="1" class="confluenceTd">RO</td><td colspan="1" class="confluenceTd">RO</td><td colspan="1" class="confluenceTd">Yes</td><td colspan="1" class="confluenceTd">Registers that hold an ID value, Reserved fields (Rsvd*).</td></tr><tr><td colspan="1" class="confluenceTd">W1C</td><td colspan="1" class="confluenceTd">RW</td><td colspan="1" class="confluenceTd">Yes</td><td colspan="1" class="confluenceTd">Stands for &quot;Write one to clear&quot;. The logic side is expected to set this bit as indicated with an 'RW' in the <em>hardware</em> column. When software reads the register bit it communicates the status of the hardware to software. Once set, the software is expected to write a 1 to clear the bit. This is recommended for interrupt status bits, or any status bits that have associated data updated by hardware only, but read, acknowledged and cleared by software.</td></tr><tr><td colspan="1" class="confluenceTd">RW</td><td colspan="1" class="confluenceTd">RW</td><td colspan="1" class="confluenceTd">Yes</td><td colspan="1" class="confluenceTd"><p>This can also used for a regular RW register that can be forced to a certain state via hardware signals in debug mode. This would still pass with Ralgen bit-bash test as long as hardware-side updates do not occur in functional mode.</p></td></tr><tr><td colspan="1" class="confluenceTd">WO</td><td colspan="1" class="confluenceTd">RO</td><td colspan="1" class="confluenceTd">Yes</td><td colspan="1" class="confluenceTd">Same as <em>hardware</em>: RW, <em>access</em>: RO, except when read by software, the value returned is all zeros.</td></tr><tr><td colspan="1" class="confluenceTd">RO</td><td colspan="1" class="confluenceTd">WO</td><td colspan="1" class="confluenceTd">No</td><td colspan="1" class="confluenceTd">Consider using <em>hardware</em>: RO, <em>access</em>: RW instead and ignore the <em>reg_field_out</em> ports.</td></tr><tr><td colspan="1" class="confluenceTd">WSC</td><td colspan="1" class="confluenceTd">RW</td><td colspan="1" class="confluenceTd">Partially</td><td colspan="1" class="confluenceTd">WSC stands for &quot;Write Self Clear&quot;. Writing a 1 by software causes or triggers a change in the hardware. HW or logic side will clear the bit in the folllowing cycle (self-clear) and hence register read will always return a zero. Writing a 0 by software has no effect. Only partially supported as hardware-side needs to implement the clearing logic. An example is a software-reset bit that resets logic states when software writes a 1 to that bit. </td></tr><tr><td colspan="1" class="confluenceTd">WO</td><td colspan="1" class="confluenceTd">RW</td><td colspan="1" class="confluenceTd">Yes</td><td colspan="1" class="confluenceTd">Write only registers. Read is not guaranteed to return the same value each time or in other words software is not expected to read it.</td></tr><tr><td colspan="1" class="confluenceTd">RW</td><td colspan="1" class="confluenceTd">WO</td><td colspan="1" class="confluenceTd">No</td><td colspan="1" class="confluenceTd">Consider using <em>hardware</em>: RW, <em>access</em>: RW instead and ignore the <em>reg_field_out</em> ports instead.</td></tr><tr><td colspan="1" class="confluenceTd">WO</td><td colspan="1" class="confluenceTd">WO</td><td colspan="1" class="confluenceTd">No</td><td colspan="1" class="confluenceTd">N/A</td></tr><tr><td colspan="1" class="confluenceTd">W1C</td><td colspan="1" class="confluenceTd">WO</td><td colspan="1" class="confluenceTd">No</td><td colspan="1" class="confluenceTd">N/A</td></tr><tr><td colspan="1" class="confluenceTd">*</td><td colspan="1" class="confluenceTd">W1C</td><td colspan="1" class="confluenceTd">No</td><td colspan="1" class="confluenceTd">N/A</td></tr><tr><td colspan="1" class="confluenceTd">W1C</td><td colspan="1" class="confluenceTd">RO</td><td colspan="1" class="confluenceTd">No</td><td colspan="1" class="confluenceTd">N/A</td></tr></tbody></table></div><p><br/></p><h2 id="HW-CTFsym_apb_csr-LibrariesUsed">Libraries Used</h2><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16161120/HW-SYM+Class+CreateCSRObj" data-linked-resource-id="16161120" data-linked-resource-version="19" data-linked-resource-type="page">HW-SYM Class CreateCSRObj</a></p><h2 id="HW-CTFsym_apb_csr-ModulesUsed">Modules Used</h2><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16163252/prot_reg" data-linked-resource-id="16163252" data-linked-resource-version="4" data-linked-resource-type="page">prot_reg</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16163258/prot_mux" data-linked-resource-id="16163258" data-linked-resource-version="4" data-linked-resource-type="page">prot_mux</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16159151/apb_pipe_adapter+apb_pipe" data-linked-resource-id="16159151" data-linked-resource-version="2" data-linked-resource-type="page">apb_pipe_adapter &amp; apb_pipe</a></p><p><br/></p><p><br/></p><p><br/></p><p><br/></p></div>