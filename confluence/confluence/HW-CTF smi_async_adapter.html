<h1 id="HW-CTFsmi_async_adapter-module_name"><strong>module_name</strong></h1><p>smi_async_adapter</p><p>smi_async_adapter_in</p><p>smi_async_adapter_out</p><h1 id="HW-CTFsmi_async_adapter-parameters"><strong>parameters</strong></h1><h3 id="HW-CTFsmi_async_adapter-smi_async_adapter">smi_async_adapter</h3><pre>{</pre><pre>        &quot;jitterOn&quot; : 0 or 1, // Only for simulation. Causes synchronizer cells to jitter one cycle.</pre><pre>        &quot;async&quot; : true or false, // If true means there is a fixed phase alignment between inClkInterface and outclhkinterface where edges align. </pre><pre>        &quot;pipeOut&quot; : true or false, // If true adds in a optional pipe stage on the output.</pre><pre>        &quot;depth&quot; : 0 or any positive integer, // The depth of the pipeline. divisible by 2 when async = true. When 0, depth is internally calculated as 2*Math.ceil(syncDepth+1.5). </pre><pre>        &quot;syncDepth&quot; : 2 or higher integer, When async = true, depth of synchronizers.</pre><pre>        &quot;interfaces: {<br/>          &quot;inClkInterface&quot; : {InterfaceCLK},</pre><pre>          &quot;outClkInterface&quot; : {InterfaceCLK},else {</pre><pre>          &quot;inPmaControlInterface&quot; : {InterfacePMAControl}, // Optional interface - required when inClkInterface clock domain is switchable</pre><pre>          &quot;outPmaControlInterface&quot; : {InterfacePMAControl}, // Optional interface - required when out ClkInterface clock domain is switchable </pre><pre>          &quot;inInterface&quot; : {InterfaceSMI}, // any interface with ready/valid, like InterfaceATP </pre><pre>          &quot;outInterface&quot; : {InterfaceSMI}, // any interface with ready/valid, like InterfaceATP </pre><pre>          &quot;inProtectionInterface&quot; : {InterfacePROT}, // optional, invoked if protectionStyle !== null or undefined</pre><pre>          &quot;outProtectionInterface&quot; : {InterfacePROT}}, // optional, expected if protectionStyle !== null or undefined</pre><pre>        &quot;protectionStyle&quot; : <a class="external-link" href="https://confluence.arteris.com/display/ENGR/protectionStyle" rel="nofollow">protectionStyle</a>}</pre><pre>}</pre><h3 id="HW-CTFsmi_async_adapter-smi_async_adapter_in">smi_async_adapter_in</h3><pre>{</pre><pre>        &quot;jitterOn&quot; : 0 or 1, // Only for simulation. Causes synchronizer cells to jitter one cycle.</pre><pre>        &quot;async&quot; : true or false, // If false means there is a fixed phase alignment between inClkInterface and outclhkinterface where edges align.</pre><pre>        &quot;depth&quot; : 0 or any positive integer, // The depth of the pipeline. divisible by 2 when async = true. When 0, depth is internally calculated as 2*Math.ceil(syncDepth+1.5).</pre><pre>        &quot;syncDepth&quot; : 2 or higher integer, When async = true, depth of synchronizers. </pre><pre>        &quot;interfaces&quot; : {</pre><pre>          &quot;clkInterface&quot; : {InterfaceCLK},</pre><pre>          &quot;pmaControlInterface&quot; : {InterfacePMAControl}, // Optional interface - required when clkInterface clock domain is switchable </pre><pre>          &quot;inInterface&quot; : {InterfaceSMI}, // any interface with ready/valid, like Interface ATP </pre><pre>          &quot;asyncInterfaceNDP&quot; : {InterfaceAsyncFIFO},</pre><pre>          &quot;asyncInterfaceDP&quot; : {InterfaceAsyncFIFO}, </pre><pre>          &quot;protectionInterface&quot; : {InterfacePROT}}, // optional, expected if protectionSytle !== null or undefined</pre><pre>        &quot;protectionStyle&quot; : <a class="external-link" href="https://confluence.arteris.com/display/ENGR/protectionStyle" rel="nofollow">protectionStyle</a>}</pre><pre>}</pre><h3 id="HW-CTFsmi_async_adapter-smi_async_adapter_out">smi_async_adapter_out</h3><pre>{</pre><pre>        &quot;jitterOn&quot; : 0 or 1, // Only for simulation. Causes synchronizer cells to jitter one cycle.</pre><pre>        &quot;async&quot; : true or false, // If &quot;no&quot; means there is a fixed phase alignment between inClkInterface and outclhkinterface where edges align.</pre><pre>        &quot;pipeOut&quot; : true or false, // If true adds in a optional pipe stage on the output.</pre><pre>        &quot;depth&quot; : 0 or any positive integer, // The depth of the pipeline. divisible by 2 when async = true. When 0, depth is internally calculated as 2*Math.ceil(syncDepth+1.5).</pre><pre>        &quot;syncDepth&quot; : 2 or higher integer, When async = true, depth of synchronizers. </pre><pre>        &quot;interfaces&quot; : {</pre><pre>          &quot;clkInterface&quot; : {IntefaceCLK},</pre><pre>          &quot;pmaControlInterface&quot; : {InterfacePMAControl}, // Optional interface - required when clkInterface clock domain is switchable </pre><pre>          &quot;asyncInterfaceNDP&quot; : {InterfaceAsyncFIFO},</pre><pre>          &quot;asyncInterfaceDP&quot; : {InterfaceAsyncFIFO}, </pre><pre>          &quot;outInterface&quot; : {InterfaceSMI}, // any interface with ready/valid, line interface ATP</pre><pre>          &quot;protectionInterface&quot; : {InterfacePROT}}, // optional, expected if protectionStyle !== null or undefined</pre><pre>        &quot;protectionStyle&quot; : <a class="external-link" href="https://confluence.arteris.com/display/ENGR/protectionStyle" rel="nofollow">protectionStyle</a>}</pre><pre>}</pre><pre><br/></pre><h1 id="HW-CTFsmi_async_adapter-ModulesUsed"><strong>Modules Used</strong></h1><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16163996/async_fifo" data-linked-resource-id="16163996" data-linked-resource-version="5" data-linked-resource-type="page">async_fifo_rd_ctl</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16163996/async_fifo" data-linked-resource-id="16163996" data-linked-resource-version="5" data-linked-resource-type="page">async_fifo_wt_ctl</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16163996/async_fifo" data-linked-resource-id="16163996" data-linked-resource-version="5" data-linked-resource-type="page">async_fifo_reg_dp</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156466/HW-CTF+sym_pipe_adapter" data-linked-resource-id="16156466" data-linked-resource-version="2" data-linked-resource-type="page">sym_pipe_adapter</a></p><h1 id="HW-CTFsmi_async_adapter-Description"><strong>Description</strong></h1><p>The Microarchitecture block diagram is shown below:</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16168605/smi_async_adapter.svg?api=v2"></span></p><p>The top level of this block is just wires. The SMI interface is composed of two sub interfaces that are both ready/valid interfaces that use the generic async adapter twice. The SMI interfaces are split into the two sub interfaces (ndp_ and optional dp_) and those two sub interfaces are fed to their own set of async logic.</p><p>The optional pipes, shown in gray blocks labeled &quot;optional pipe&quot; in the above block diagram, are controlled by parameter pipeOut. These blocks are instances of the sym_pipe_adapter. When pipeOut is true, the optional sym_pipe_adapters get inserted with the following configuration:</p><p style="margin-left: 30.0px;">depth = 2<br/>pipeForward = true<br/>pipeBackward = true<br/>circular = false<br/>simplePipe = false<br/>split = false</p><p>Sym_pipe_adapter is for ATP interfaces, but it can be used generically for any ready/valid interface if split = false and used as a library object inside another block.</p><p>The addition of this pipe affects the latency and number of beats the block can hold which will affect the performance model. When pipeOut = true, it adds 2 to the number for beats the block can hold and adds a latency of 1 out clock to the empty latency.</p><h1 id="HW-CTFsmi_async_adapter-SplittingBlock">Splitting Block</h1><p>The block can be split in two, but when that is done, the parameters for two internal interfaces, asyncInterfaceNDP and asyncInterfaceDP which are InterfaceAsyncFIFO, must be calculated based on the parameters depth, syncDepth and the SMI Interface being used by the block.</p><p>Of these two interface asyncInterfaceDP is optional and whether it exists depends on parameters passed to the SMI interface.</p><p>When the parameter nSmiDPvc &gt; 0, then asyncInterfaceDP exists. If not, the easiest thing to do is set the _SKIP_ parameter in the asyncInterfaceDP to true and calculate the other parameters as normal. </p><p>There are three parameters for the two internal interfaces:</p><p style="margin-left: 30.0px;">width<br/>depth<br/>async</p><p>&quot;async&quot; and &quot;depth&quot; have the same value for both interfaces.</p><p>Interface async = block parameter async<br/>Interface depth is calculated following the following algorithm:</p><pre>if (block depth === 0) { <br/>  Interface depth = 2*(block syncDepth+1.5);<br/>} else {<br/>  Interface depth = block depth<br/>} <br/>Interface depth = async ? 2*Math.ceil(Interface depth/2) : Interface depth;</pre><p>The interface width is calculated by summing all the output signals minus the valid signal for the two sub interfaces of SMI</p><pre>var ndp_width = 0;<br/>var inInterfaceSignals = getSignalBundle(inInterface); // not full syntax
var in_signals = Object.keys(inInterfaceSignals.ndp);
in_signals.sort();
<br/>var ndp_width = 0;
for (i = 0; i &lt; in_signals.length; i++) {
  if ((in_signals[i] !== 'msg_valid') &amp;&amp; (inInterface.signals[in_signals[i]] &gt; 0)) {
    ndp_width = ndp_width + inInterface.signals[in_signals[i]];
  }
}<br/><br/>var in_signals = Object.keys(inInterfaceSignals.dp); <br/>in_signals.sort();<br/><br/>var dp_width = 0;<br/>for (i = 0; i &lt; in_signals.length; i++) {<br/>  if ((in_signals[i] !== 'valid') &amp;&amp; (inInterface.signals[in_signals[i]] &gt; 0)) {<br/>    dp_width = dp_width + inInterface.signals[in_signals[i]];<br/>  }<br/>}<br/><br/></pre><p>The above calculation is repeated for the DP side also. </p><pre>Interface NDP width = ndp_width;<br/>Interface DP width = dp_width;</pre><p><br/></p>