<p><br/></p><p class="auto-cursor-target"><strong>Design team feedback [top few enhancement requests]</strong></p><div class="table-wrap"><table class="relative-table wrapped confluenceTable" style="width: 92.8315%;"><colgroup><col style="width: 3.14501%;"/><col style="width: 63.4575%;"/><col style="width: 12.251%;"/><col style="width: 21.1362%;"/></colgroup><tbody><tr><th class="confluenceTh">ID</th><th class="confluenceTh">Enhancement requested</th><th class="confluenceTh">Domain impacted</th><th colspan="1" class="confluenceTh">AI</th></tr><tr><td class="confluenceTd">1</td><td class="confluenceTd"><ul><li><span>All software visible blocks must have a confluence page describing high level interfaces and parameters.  → Derived from TACHL/CPR/Type file</span></li><li><span>All library elements need a confluence page explaining parameters and functions. (Including JS functions)</span></li><li><span>Modules shared across units should be made lib components. </span></li><li><span>Have Library element tested and verified separately.</span></li></ul></td><td class="confluenceTd">Design team</td><td colspan="1" class="confluenceTd">Design team to talk to Maestro team to automate the parameter value generation process [Why mapping layer?]</td></tr><tr><td class="confluenceTd">2</td><td class="confluenceTd"><ul><li><span>Better organize uArch page to match documents to a version of Ncore. Have common page which can reach all uArch documents, right now we have separate header pages for Legato Blocks, Legato Library Elements, NCore Blocks, NCore library elements, etc. </span></li><li>We should have a standardized tool/way to create diagrams in our documents. </li><li><span class="legacy-color-text-blue3">Need to enforce follow-up actions on the micro-architecture spec after review meeting.<span> </span></span></li><li><span class="legacy-color-text-blue3">The Arch and Uarch specs should be 'Books'. We should have Books with subchapters for the various blocks, features, etc. That way we don't have to browse around for docs that are more or less scattered.<span> </span></span></li></ul></td><td class="confluenceTd">Design team</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">3</td><td class="confluenceTd"><ul><li><span>Have some common coding methodology, existing Ncore code base does not follow a common coding guideline. This makes it harder for designers to help out each other and new designers get brought up. Need to enforce certain degree of modularity of a TACHL module to avoid gigantic monolithic module.</span></li><li><span><span class="legacy-color-text-blue3">Need to add more SVA assertions and SVA cover properties in RTL code, and make sure they have good descriptions</span></span></li><li><span>Having a commenting methodology implemented. Code review to be put in place. </span></li></ul></td><td class="confluenceTd">Design team</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">4</td><td class="confluenceTd">Having things defined through specification updates and then communicated to design/DV. Less things defined in Teams/JIRAs / emails and more by updating the ruling specification.</td><td class="confluenceTd">Architecture/Design/DV teams.</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">5</td><td class="confluenceTd">Have additional DC_NXT licenses and more machines to run synthesis/timing runs. Explore other synthesis tools and power analysis tools.</td><td class="confluenceTd">IT/Management</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">6</td><td class="confluenceTd"><ul><li><span>Need the ability to have a single synthesis flow that supports DC, ZWL &amp; hierarchical runs.</span></li><li><span>Add additional scripts to automate checking for additional issues within each synthesis runs.</span></li><li><span>Add scripts to automate the generation of  a combined synthesis report from the various log files that are generated by DC.</span></li><li><span>Add capability within bucketize to list the logic levels corresponding to a path and then be able to sort report based off LoL [both reported LoL and real LoL].</span></li><li><span>Looking at using hierarchical run as the default run till we hit a WNS threshold.</span></li><li>Need metrics capturing/tracking. sql db with a plotting tool like Grafana.</li><li>Need to move all results/reports, memory wrappers, shared scripts to a common workarea (/engr/dev/tools/scripts).</li></ul></td><td class="confluenceTd">Design team</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">7</td><td class="confluenceTd"><ul><li><span>Have the capability to run any FSYS test on performance model report the theoretical max BW for a given configuration → Look at using a single switch topo </span></li><li><span>More performance checks in the checkin tests. If there are major BW changes, we could just flag that it happens and not block it</span></li></ul></td><td class="confluenceTd">Performance team</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">8</td><td class="confluenceTd"><ul style="text-align: left;"><li><span>Addressing the reproducibility of bugs issue.</span></li><li><span>JIRA's being filed should have path to dump files, logs and some initial debug pointing to the possible rootcause (Failing transaction details, timestamps, scenario descriptions, etc. Instead of simple UVM error messages in the details).</span></li><li><span>Ability to run regressions on branches [both mini as well as full regressions].</span></li><li><span>We need to have verification tests labeled according to features<span class="legacy-color-text-blue3">. This is also good for debug and learning the design.  </span></span></li></ul></td><td class="confluenceTd">Verification team</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">9</td><td class="confluenceTd">Reduce running time for <span>pre-push, check-in to release &amp; refresh_rtl. Better notifications to the design team when we have issues with LINT, <span class="legacy-color-text-blue3">pushq etc. </span></span></td><td class="confluenceTd">Maestro/Verification team</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">10</td><td class="confluenceTd">Add framework within TACHL to aid collection of performance metrics on a per block basis and help correlate that with numbers provided by performance model.</td><td class="confluenceTd">Performance/Design teams</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">11</td><td class="confluenceTd"><ul><li>Generate checklists for every Ncore block to track functionality, timing.. for every release </li><li>Having capability to run sizing studies of individual components within each block from a synthesis/timing POV.</li></ul></td><td class="confluenceTd">Design team</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">12</td><td class="confluenceTd"><ul><li>Have a design flow supporting LEC between 2 RTL models.</li><li><span class="legacy-color-text-blue3">Improved error reporting in tachl compile. Eg: Missing endquote is not reported with a line number. (run debug version of tachl compiler for design team runs)</span></li><li><span class="legacy-color-text-blue3">Need multi-node support from Maestro (need support for 5nm)<span> </span></span></li></ul></td><td class="confluenceTd">Design/Maestro team</td><td colspan="1" class="confluenceTd"><br/></td></tr><tr><td class="confluenceTd">13</td><td class="confluenceTd"><ul><li><span class="legacy-color-text-blue3">Do TACHL coverage a lot earlier. That way we can carve out TACHL that might have been safeguards or not used anymore. Usually when we do coverage its not work the risk totally deleting code and conditions.<span> </span></span></li></ul></td><td class="confluenceTd">Design/Verification team</td><td colspan="1" class="confluenceTd"><br/></td></tr></tbody></table></div><p><br/></p><p><strong>Additional feedback &amp; details:</strong></p><p><strong>Design/RTL enhancements/requests:</strong></p><ul><li><span>Have some capability of automating coding guidelines checks [could some scripts that check for naming conventions associated with signal names...] →Akarsh</span></li><li><span>Modules shared across units should be made lib components. →Kjeld</span></li><li><span>Have a block template which includes a unified way of importing libraries, parameters, interfaces etc. Essentially create a common shell. -ET</span><ul><li><span>Or something along the lines of a script that creates a block space that includes needed coverage exclusion file templets also / Possibly some basic testbench which can be used for simple checking. </span></li><li><span>Space can come with a read me or scripts that can auto run synthesis or spyglass on the block individually</span></li></ul></li><li><span>All software visible blocks must have a confluence page describing high level interfaces and parameters. -ET</span></li><li><span>All library elements need a confluence page explaining parameters and functions. - ET (Including JS functions)</span></li><li><span>More commonality in microarchitecture documents. I feel like DV has a hard time (and honestly, I do find things) -ET</span><ul><li><span>For example, have a common section which specifically describes what can be seen on each concerto message and what fields mean.</span></li><li><span>The Arch and Uarch specs should be 'Books'. We should have Books with subchapters for the various blocks, features, etc. That way we don't have to browse around for docs that are more or less scattered. -Kjeld</span></li></ul></li><li><span>Have some common page which can reach all uArch documents, right now we have separate header pages for Legato Blocks, Legato Library Elements, NCore Blocks, NCore library elements, etc. -ET</span></li><li><span>Have some common methodology, for example, moving from Kjeld'd skid buffer to Nabils IOAIU to my DII to Darshan's packetizer they are all noticeably different. Makes it harder for designers to help out each other and new designers get brought up. ET. It should all be written like the DII skid-buffer.</span></li><li><span>Have Library element tested and verified separately. BM</span></li><li><span>Using the entire maestro infrastructure is heavy during the design phase, I think it would make sense to be able to run some basic test and compile from reference debug json which would be updated once a week or so based on configuration update. It would get rid of the heaviness of refresh_rtl and some of the maestro generation phase. I believe the DV environment might already be able to do it, maybe we should make more use of it. I also agree with Eric on having simple test benches (maybe with autogenerated clocking blocks and instantiation from tachl?) BM</span></li><li><span>Good to have a micro-architecture documentation guideline / template for designers to fill in to ensure certain qualities. For example: action table (state machine-like descriptions), protocol state transition table or explicit and specific references to tables in system spec, input concerto messages and their bit fields that are processed, output concerto messages and their bit fields that are produced, control paths and data paths for a transaction flow, enumeration of a list of detailed features that can be hashed tag / cross referenced for test plan, an appendix to capture critical JIRA issues, special design considerations, etc. -Boon</span></li><li><span>Need to enforce follow-up actions on the micro-architecture spec after review meeting. For example, IOAIU micro-architecture spec doesn't have any description on DVM handling at all, and this is raised during review meeting, but there's no follow-up on that. Therefore, as of today, IOAIU micro-architecture spec still doesn't describe how it handles DVM transactions. -Boon</span></li><li><span>Need to enforce the maximum number of lines of RTL code in a TACHL file. For example, ioaiu_control.tachl has 13,280 lines of RTL code, making it hard to maintain. -Boon</span></li><li><span>Need to enforce certain degree of modularity of a TACHL module to avoid gigantic monolithic modules such as ioaiu_control.tachl that is hard to maintain. -Boon</span></li><li><span>Need to add more SVA assertions and SVA cover properties in RTL code, and make sure they have good descriptions -Boon</span></li><li><span>Do TACHL coverage a lot earlier. That way we can carve out TACHL that might have been safeguards or not used anymore. Usually when we do coverage its not work the risk totally deleting code and conditions. - ET</span></li><li><span>In general we need better uniformity. Eric touched on that. But it needs to be across everything. Documentation, RTL, scripts, tests, checkers, etc. -Kjeld</span></li></ul><p><br/></p><p><strong>Timing/Synthesis enhancements/requests:</strong></p><ul><li><span>Add additional scripts to automate checking for additional issues within each synthesis runs [congestion issues, routing issues, LVT, ULVT % thresholds, memory linking...] → Akarsh</span></li><li><span>Add capability within the synthesis flow to run check-only report issues [eg: memory linking issues] and then kick off the synthesis run following a clean check-only run → Akarsh</span></li><li><span>Add scripts to automate the generation of  a combined synthesis report from the various log files that are generated by DC →Akarsh</span></li><li><span>Add capability within bucketize to list the logic levels corresponding to a path and then be able to sort report based off LoL [both reported LoL and real LoL] → Akarsh</span></li><li><span>Need the ability to have a single synthesis flow that supports DC, ZWL &amp; Hierarchical runs. → Akarsh</span></li><li><span>Ability to auto generate the wrappers based off the best available memories in the library. → Akarsh</span></li><li><span>Need 2-3 server class machines for synths fast turn-around. →Kjeld</span></li><li><span>Do all synthesis with hierarchy until we're below 50ps; only then flatten to eek out the last few ps.  → Bob</span></li><li>Need multi-node support from Maestro (need support for 5nm) → Synth team (Troy, Shiva, David)</li><li>(tools general) Need to use modules for consistent tool setup → Troy</li><li>Need metrics capturing/tracking. sql db with a plotting tool like Grafana → Troy</li><li>(tools general) Need to move all shared scripts to /engr/dev/tools/scripts → Troy</li></ul><p><strong>Verification</strong><strong> enhancements/requests:</strong></p><ul style="text-align: left;"><li><span>Addressing the reproducibility of bugs issue →Akarsh</span></li><li><span>Ability to run regressions on branches [both mini as well as full regressions] &amp; tests labeled according to features →Akarsh</span></li><li><span>refresh_rtl runtime: seems running npm cache clean --force has some effect. Runtime still ~3min. This should really be 15 sec. →Kjeld</span><ul><li><span>I would contend that we should only have to run refresh_rtl once to cause maestro to point directly at our local repositories from which point all local updates will be seen automatically. → jcodd</span></li></ul></li><li><span>check-in to release runtime →Kjeld</span></li><li><span>release numbering →Kjeld</span></li><li><span>Reduce pre-push runtime →Kjeld</span></li><li><span>unit miniregressions quality (not all tests pass) → for the IOAIU raised the issue with DV that 2 tests fails. →Kjeld</span></li><li><span>pre-push should flag if code in progress will cause merge issues. →Kjeld</span></li><li><span>check-in should be able to merge code more extensively. (today a lot of manual merge is required) →Kjeld</span></li><li><span>pushq issues. Dropped pushes observed? Queue issue? This seems to be a recurring issue that upsets checking. →Kjeld</span></li><li><span>Update push_ncr to run LEC on select check-ins for speedup. →Kjeld</span></li><li><span>Open up more uArch Doc JIRAs when something isnt defined or understood verses defining things through JIRAs/emails. - ETs </span></li><li><span>More of a nice to have, but ensure that we get debugged jiras from DV that show good effort and debug has been made. Failing transaction details, timestamps, scenario descriptions, etc. Instead of simple UVM error messages in the details. → Jason</span></li><li>Possibly have area with shared rc files on common configurations → Jason</li><li><span style="letter-spacing: 0.0px;">tools: improved error reporting in tachl compile; one typo of a missing endquote is not reported with a line number.<span> → Bob</span></span></li><li><span style="letter-spacing: 0.0px;"><span>tools: we should have a standardized way to create diagrams in our documents. → Bob</span></span></li><li><span style="letter-spacing: 0.0px;"><span>dv tickets should be filed against tagged rtl</span></span></li><li><span style="letter-spacing: 0.0px;"><span>A list of comprehensive tests for each Concerto Unit with good descriptions on what the tests actually do.</span></span></li><li><span style="letter-spacing: 0.0px;"><span>Easy to understand test error messages -Boon</span></span></li><li><span style="letter-spacing: 0.0px;"><span>Global Unique ID for a failing transaction so that designers can do a grep for the Global Unique ID to see a list of the related transactions that are associated with the failing transaction -Boon</span></span></li><li>One test per Concerto Unit that can hit 95% code coverage of the core functionalities (excluding trace, debug, CSR register testing) - Boon</li><li><span style="letter-spacing: 0.0px;"><span>Many things can be automated and we should take advantage of that. E.g., per module testing for improved coverage. Coverage number generation etc.</span></span></li><li><span style="letter-spacing: 0.0px;"><span>We need a set of single transaction tests for feature verification. This is also good for debug and learning the design.  -Kjeld</span></span></li></ul><p><br/></p><p><strong>Performance analysis/verification enhancements/requests:</strong></p><ul><li><span>Have the capability to run any FSYS test on performance model report the theoretical max BW for a given configuration →Akarsh</span></li><li><span>More performance checks in the checkin tests. If there are major BW changes, we could just flag that it happens and not block it. -ET</span><ul><li><span>Could just be simple full BW cases.</span></li><li><span>Could have caught DII, IOAIU </span>performance bugs that showed up late.</li></ul></li></ul><p><br/></p><p><strong>Architecture enhancements/requests:</strong></p><ul style="list-style-type: square;"><li>Have less things defined in JIRAs / emails. I feel like alot of times certain things get defined through discussion without modification or clarification to the ruling document -ET<ul style="list-style-type: square;"><li>On Design/DV to open Arch JIRAs also. </li></ul></li></ul><p><br/></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16165968/Design+team+feedback+top+10-12+enhancement+requests" data-linked-resource-id="16165968" data-linked-resource-version="12" data-linked-resource-type="page">Design team feedback [top 10-12 enhancement requests]</a></p>