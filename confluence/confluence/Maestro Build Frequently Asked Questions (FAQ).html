<h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-Whoshouldreadthis?">Who should read this?</h2><p>Any developer wishing to gain some understanding of the basics of the Maestro software methodology/build system.</p><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-Idon&#39;tagreewithsomeofthepointsraised.WhatcanIdo?">I don't agree with some of the points raised. What can I do?</h2><p>This document really only serves as the basis for a discussion of the best practices to be followed when developing code on Maestro. We welcome other ideas and proposals. If there is something that you disagree with, or if there is something that you feel could be improved upon, bring this to the teams attention and we can have a discussion.</p><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-Isthereaautomatedbuild,soIdon&#39;thavetogothroughthisprocess?">Is there a automated build, so I don't have to go through this process?</h2><p>Yes, daily builds are archived under /engr/dev/releases/maestro/client.</p><p>To use the latest daily build, find theexecutable at:</p><p>Release version:</p><pre>  /engr/dev/releases/maestro/client/daily_release/latest/maestro-0.0.1-Linux/bin/maestro</pre><p>Debug version:</p><pre>  /engr/dev/releases/maestro/client/daily_debug/latest/maestro-0.0.1-Linux-debug/bin/maestro</pre><p><br/></p><p>For a build for specific date , find the executable at:</p><p>Release version:</p><pre>  /engr/dev/releases/maestro/client/daily_release/&lt;date&gt;/maestro-0.0.1-Linux/bin/maestro</pre><p>Debug version:</p><pre>  /engr/dev/releases/maestro/client/daily_debug/&lt;date&gt;/maestro-0.0.1-Linux-debug/bin/maestro</pre><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-OnwhatserverdowebuildtheMaestrosoftware?">On what server do we build the Maestro software?</h2><p>gr6-3</p><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-WhatenvironmentsetupdoIneedtobuildMaestro?">What environment setup do I need to build Maestro?</h2><ul><li><p>Setup conan configuration (needs to be done once)</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">conan config install /scratch3/maestro/conan/config/conan_config_arteris.tar.gz</pre>
</div></div></li><li><p>Setup environment variables in path (should be done in profile or cshrc)</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">module load maestro</pre>
</div></div></li></ul><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-HowdoIobtaintheMaestrosourcecode?">How do I obtain the Maestro source code?</h2><p>First, make sure your Gitlab profile has been setup with an ssh key - <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16167950/Generating+and+Uploading+Gitlab+SSH+Keys" data-linked-resource-id="16167950" data-linked-resource-version="4" data-linked-resource-type="page">Generating and Uploading Gitlab SSH Keys</a>.</p><p>Maestro is maintained as a GIT repository on gitlab. maestro.git can be cloned using: </p><pre>  git clone <a class="external-link" href="https://confluence.arteris.com/git@gitlab.arteris.com:maestro/maestro.git" rel="nofollow">git@gitlab.arteris.com:maestro/maestro.git</a></pre><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-HowisMaestrobuilt?">How is Maestro built?</h2><p>Maestro is built using CMake (<a class="external-link" href="https://cmake.org/" rel="nofollow">https://cmake.org/</a>). Over the past 5 or so years, CMake has become the de facto build tool for modern C++ projects. Unlike standard, legacy Makefiles, CMake captures semantic information about the interrelationship of project targets. In doing so, CMake can largely automate and abstract the build process from the end user. CMake can be configured to emit build scripts for a number of industry standard build tools (including Makefiles).</p><p>CMake is used by may large scale C++ projects, including: LLVM, Webkit, RocksDB (Facebook). It is free, but under active development. It is being actively supported by popular C++ IDE, including: Jetbrain's CLion, Microsoft Visual Studio.</p><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-Whatareourexternaldependencies?">What are our external dependencies?</h2><p>Presently, the baseline Maestro build requires the following dependencies.</p><ul><li>Boost 1.70</li><li>TCL 8.5</li><li>CMake 3.12</li><li>QT 5</li><li>GCC &gt;= 4.8</li></ul><p>These requirements are aligned with those libraries present in CentOS 7.</p><p>These libraries may be/are out of date, however please do not migrate independently to more recent versions without the expressed permission of others in the team.</p><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-HowdoIinstallthesedependencies?">How do I install these dependencies?</h2><p>These dependencies should be already present on standard Arteris CentOS 7 installations (specifically gr6-3) as this is the platform we actively target. </p><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-Whatprogramminglanguagedowesupport?">What programming language do we support?</h2><p>The Maestro code base is written in C++11. CentOS 7 does not have support for C++14 out of the box and therefore we do not support it. Although contributors are free to use standard C++98/03, we actively encourage users to leverage the new and powerful features that C++11 brings to the table.</p><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-Howareexternaldependenciesmanaged?">How are external dependencies managed?</h2><p>Maestro uses the Conan dependency manager (<a class="external-link" href="http://www.conan.io)" rel="nofollow">www.conan.io)</a>. Conan is Python based system that is closely integrated with CMake and appears to be closely modeled around the NPM package manager seen in the Javascript world. Conan automatically fetches and caches correct versions of external libraries and generated CMake scripts that enable for them to be trivially integrated into an existing project.</p><p>Conan is presently used to manage small, ancillary dependencies: logging libraries and unit test libraries. We have seen integration issues when attempting heavyweight libraries such as QT. For libraries such as these, we expect to revert to the usual 'find_package' approach.</p><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-HowdoIbuildtheMaestrosourcecode?">How do I build the Maestro source code?</h2><p>Maestro is structured as a conventional CMake build project. Assuming that the Maestro code base as been cloned into a directory called &lt;SOURCE ROOT&gt;:</p><pre>  mkdir build  ## create build directory (name is by convention)</pre><pre>  cd build     ## pwd: &lt;SOURCE ROOT&gt;/build</pre><pre>  cmake ..     ## configure project</pre><pre>  make -j      ## build project using generated Makefile</pre><p>Alternatively, the following command can be used to do the above</p><pre>  make build -j </pre><p>By convention, the project is built within a sub-directory called 'build', however you are free to name it as you wish. CMake can support multiple, independent build directories.</p><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-ThetoolsIhavepre-installedareold,wherecanIfindrecentversions?">The tools I have pre-installed are old, where can I find recent versions?</h2><p>CentOS is fairly out of date with respect to just about everything. The maintainers have therefore created pre-built packages for clang, emacs, cmake and python at:</p><pre>   /scratch3/maestro/pkgs</pre><p>These packages have been built against CentOS. We have pre-built packages only for tools that we use for the purpose of development. All tools used for deployment must rely upon those installed by default on CentOS.</p><p>These binaries are available by updated your PATH environment variable accordingly.</p><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-HowdoIcreateadebugbuild?">How do I create a debug build?</h2><p>A debug can be enabled, by running the following command:</p><pre>  cmake .. -DCMAKE_BUILD_TYPE=Debug</pre><p>This is consistent with established CMake conventions. Optimized builds (non debug) are built by default, however they may be explicitly enabled using:</p><pre>  cmake .. -DCMAKE_BUILD_TYPE=Release</pre><p>For debug builds, the generated binaries are annotated with standard debug symbols and all optimizations are disabled.</p><p>Alternatively, the following command can be used to build a debug build into the build_debug directory.</p><pre>  make build_debug -j</pre><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-Whatplatformsaresupported?">What platforms are supported?</h2><p>We target CentOS 7</p><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-WhatisMaestro&#39;sprojectstructure?">What is Maestro's project structure?</h2><p>The &quot;Maestro&quot; project denotes the top-level, end-user application. The project consists of a number of small dependent modules that are written as verified, independent shared libraries. </p><p>The Maestro structure appears as follows:</p><ul><li><strong>cmake</strong><br/>Contains all CMake related scripts and modules used as part of the configuration and build process.</li><li><strong>contrib</strong><br/>Contains modules used by the Maestro main src.</li><li><strong>scripts</strong><br/>Contains a miscellaneous collection of scripts used for the purpose of development.</li><li><strong>src</strong><br/>Contains all source files related to the maestro project.</li><li><strong>tests</strong><br/>Contains all unit tests related to the maestro project (unit tests for dependent shared libraries remains in their own repository).</li><li><em>CMakeLists.txt</em><br/>The CMake top-level configuration script.</li><li><em>conanfile.txt</em><br/>The Conan configuration file containing all dependencies managed by Conan.</li><li><em>Makefile</em><br/>Used to support gmake XXX build shortcuts</li></ul><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-Whataretheprinciplesub-systemsinMaestro?">What are the principle sub-systems in Maestro?</h2><p>To date, the following sub-systems have been identified.</p><ul><li>constraints</li><li>dm</li><li>qor</li><li>utilities</li><li>thirdparty</li><li>nocplacer</li><li>nocdata</li><li>CustomEval</li></ul><p>The role and use of these libraries remain to be defined by the software architect. The API remains TBD.</p><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-HowdoIrunaregressionontheMaestrocodebase?">How do I run a regression on the Maestro code base?</h2><p>Maestro uses GTest and CTest to generate and invoke units tests, respectively. </p><p>From the build directory, CTest is configured to invoke all tests:</p><pre>  &lt;BUILD ROOT&gt;/ctest .</pre><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-HowtoImeasurecoverage?">How to I measure coverage?</h2><p>The Maestro build system supports coverage using the standard GCOV tool, integrated into GCC. Coverage configuration is managed directly by CMake. An unfortunate consequence of this is that all ancillary coverage databases are stored into the CMake build directories that are largely opaque to the end-user. Consequently, coverage is typically, and easily invoked by running the regression suit against a coverage build as follows (from within the build tree):</p><pre>  conan install ../</pre><pre>  cmake -DENABLE_COVERAGE ../</pre><pre>  make -j</pre><pre>  make NightlyCoverage</pre><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-HowdoIperformamemoryanalysis?">How do I perform a memory analysis?</h2><p>Memory analysis is used to identify memory leaks, memory corruption and incorrect use of standard memory allocation routines. Presently, we rely upon the excellent and industry standard 'valgrind' tool. Memory analysis can be carried out manually as:</p><pre>  valgrind ./bin/maestro</pre><p>Or, it can be run as part of a regression on the Unit Test suite using:</p><pre>  conan install ../</pre><pre>  cmake ../</pre><pre>  make -j</pre><pre>  make NightlyMemCheck</pre><p>Valgrind works on either Debug or Release builds, however reports are more useful if run against a debug build (enabled using the -DCMAKE_RELEASE_TYPE=Debug using configuration).</p><p><span style="font-size: 20.0px;">How do I create a Unit Test?</span></p><p>Unit tests are located within the 'tests' directory of Maestro and associated shared libraries. We have standardized around the 'Catch' unit test library. Initial we evaluated GTest as this appeared to be a well-established libraries, however we identified some issues present during integration (poor integration with packaging, warning messages during configuration) and noted that although fairly well used, it does not appear to be under active development. Catch, on the other hand, remains very simple, is present as a single header file, has great integration with CMake and CLion, and appears to be under active development. </p><p>Tests are added by creating either creating a new source file in the tests directory, or by appending a new test to an existing file. The associated CMakeLists.txt file in the tests directory contains a macro called 'create_test' that automatically builds the test and registers it with the CTest driver.</p><p>An example of a simple unit test is:</p><pre>  #define CATCH_CONFIG_MAIN<br/>  #include &quot;catch.hpp&quot;</pre><pre>  TEST_CASE(&quot;basic&quot;, &quot;proof_of_concept&quot;) {<br/>   REQUIRE(true);<br/>  }</pre><p>An example of how it may be integrated into the build is:</p><pre>  create_test(NAME basic SRCS <a class="external-link" href="http://basic.cc" rel="nofollow">basic.cc</a>)</pre><p>Clearly, this is a very trivial example. Consider reviewing the tests directory for more useful and illustrative examples.</p><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-Howisloggingaccomplished?">How is logging accomplished?</h2><p>We currently use the easylogging++ logging library (<a class="external-link" href="https://github.com/muflihun/easyloggingpp" rel="nofollow">https://github.com/muflihun/easyloggingpp</a>). Easylogging is a fairly straight forward logging library that is both simple and lightweight. It exists as a single header and integration is achieved using Conan.</p><p>Usage is fairly simple. The following raises an error:</p><pre>  LOG(ERROR) &lt;&lt; &quot;This is an error&quot;;</pre><p>The following raises an info:</p><pre>  LOG(INFO) &lt;&lt; &quot;This is an info&quot;;</pre><p>Program behavior is dependent upon the configuration of the logger, but for day-to-day logging purposes, this should suffice.</p><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-HowisMaestrodeployed?">How is Maestro deployed?</h2><p>Maestro uses the CPack tool. CPack is deployed alongside and integrated with CMake. CPack is used to generate gzipped tar archives, RPM and DEB.</p><p>The following command:</p><pre>  &lt;BUILD&gt;/cpack .</pre><p>Will produce:</p><pre>  maestro-&lt;VERSION NUMBER&gt;-&lt;PLATFORM&gt;.{deb, rpm, tar.gz}</pre><p>(We do not expect contributors to invoke the deployment process on a day-to-day basis.)</p><p>A shared location shall be established where build/releases may be preserved. We intend to use Git's tagging system to retain information about the precise state of the repository for each release.</p><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-HowisMaestrodocumented?">How is Maestro documented?</h2><p>Documentation and self-describing code is encouraged. We obey the Doxygen style such that documentation can be automatically extracted from the code base (<a class="external-link" href="http://www.stack.nl/~dimitri/doxygen/" rel="nofollow">http://www.stack.nl/~dimitri/doxygen/</a>). </p><p>An example of a Doxygen comment is as follows:</p><pre>  /**</pre><pre>  * @brief A function to compute the square of two integers</pre><pre>  * @param[in] x The number to be squared</pre><pre>  * @return      The result of (x * x)</pre><pre>  */</pre><pre>  int square (int x) {}</pre><p>A detailed discussion of the Doxygen format is out of the scope of this discussion. A full list of Doxygen annotations can be found at (<a class="external-link" href="http://www.stack.nl/~dimitri/doxygen/manual/commands.html" rel="nofollow">http://www.stack.nl/~dimitri/doxygen/manual/commands.html</a>).</p><p>The creation of documentation is time consuming therefore we recommend that the all code should be as self-documenting as possible. Care should be taken to fully document all code representing an API or a module boundary, although this can be taken on a case-by-base basis.</p><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-Howcanthedocumentationbebuilt?">How can the documentation be built?</h2><p>Doxygen can be run over the code base using the following command:</p><pre>  &lt;BUILD ROOT&gt;/make doxygen</pre><p>The generated source code can be viewed at: &lt;BUILD ROOT&gt;/doxygen</p><p>The doxygen configuration and associated scripts can be found in the 'scripts' directory.</p><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-Buildingthedocumentationisalengthy,candocumentationbefoundsomewhere?"><span style="font-size: 20.0px;">Building the documentation is a lengthy, can documentation be found somewhere?</span></h2><p>Yes! Regular builds of the Maestro documentation can be found at:</p><pre>  /scratch3/maestro/doc/latest/index.html</pre><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-Whatisthereleaseprocess?"><span style="font-size: 20.0px;">What is the release process?</span></h2><p>We aim to establish a formal release regression and a release process. This remains TBD.</p><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-Howdowemanagebranches?">How do we manage branches?</h2><p>Branches are very lightweight in Git. No excuse therefore exists not to use them heavily as part of day-to-day development. Specifically, each developer is advised to work from their own branch, commit to their own branch, and merge back to master only once the code is fairly stable and shown not to disrupt other individuals in the team.</p><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-Howdowemanagetags?">How do we manage tags?</h2><p>The master branch shall be tagged on a relatively frequent basis to correspond to key milestones in development. Tags shall correspond with the associate CMake version.</p><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-Whatcodingstandardsdoweobey?">What coding standards do we obey?</h2><p>We reviewed a number of established industry coding standards including LLVM, Google, Webkit, Chromium. Coding styles are largely a subjective endeavor motivated by consistency, readability, maintainability and correctness. We decided to obey the Google coding style (<a class="external-link" href="https://google.github.io/styleguide/cppguide.html" rel="nofollow">https://google.github.io/styleguide/cppguide.html</a>). Of all the coding standards considered, the Google standard appears to have been the one that was the most well rounded. In addition, presented alongside each coding rule was a clear motivating discussion on the how the decision was arrived. This was not always present in competing standards.</p><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-Howtoweenforcecodingstandards?">How to we enforce coding standards?</h2><p>Coding standards are not useful unless they are obeyed. A key motivation in our decision was to leverage existing tools to enforce the coding standards programmatically. The following tools are available to enforce our coding standards:</p><ul><li><p><strong>Google's CPPLINT (<a class="external-link" href="https://github.com/google/styleguide/tree/gh-pages/cpplint" rel="nofollow">https://github.com/google/styleguide/tree/gh-pages/cpplint</a>)</strong><br/>CPPLINT is a widely used script that scans a CPP file to verify compliance with Google Style Guide. It is a script and does not parse CPP directly, therefore it is can raise possible false positives. Nonetheless it appears to be a good first pass tool to catch basic style errors/omissions.</p><pre>  /scratch3/maestro/pkgs/google-styleguide/cpplint/cpplint.py &lt;MY SOURCE FILE&gt;.cpp</pre></li></ul><ul><li><strong>clang-format (<a class="external-link" href="https://clang.llvm.org/docs/ClangFormat.html" rel="nofollow">https://clang.llvm.org/docs/ClangFormat.html</a></strong>) <br/>clang-format has quickly become the industry standard tool to rewrite C++ files to a particular style guideline. Prior to the advent of CLANG, such tools were not available because they required deep understand of C++ syntax. Maestro has been set up to automatically obey the Google coding style. clang-format can be invoked by:</li></ul><pre>       /scratch3/maestro/pkgs/llvm-4.0.0/bin/clang-format -i &lt;MY SOURCE FILE&gt;.cpp</pre><p>NOTE: clang-format, rewrites the entire source file to a particular style guideline. Ensure that post clang-format the consequent revision control DIFF is consistent with any changes that you have made.</p><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-Idon&#39;tcareaboutcodingstandards,whatdoesthismeanforme?">I don't care about coding standards, what does this mean for me?</h2><p>More recent versions of CMake include support for CPPLINT and clang-format as part of the build process. At present they remain disabled by default, however CPPLINT may be enabled using the ENABLE_CPPLINT option and clang-tidy may be enabled using the ENABLE_CLANG_TIDY option. Additionally, a .clang-format script is present in the project root to automate the process of coding formatting for those who do not wish to do so manually.</p><p>CPPLINT verifies compliance with the Google Coding Standards. clang-tidy also verifies compliance, but to a lesser degree. clang-tidy's main role is to ensure that the code looks relatively sane during compilation (but do not expect for it to catch every bug). The build system has been designed to terminate the build should either of these tools raise an objection. Although this is presently disabled out of the box, we intend to enable it in the future. Ensure that your code remains compliant with these throughout the development process. Failure to do this, shall simply result in a sudden and exponential increase in your workload over a very short time as you are forced to manually shift through your code base and remove all violations.</p><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-HowdoIperformstaticanalysis?">How do I perform static analysis?</h2><p>Static analysis is performed using clang-tidy. clang-tidy is an emerging static analysis tool built upon the underlying technology found in clang. clang-tidy makes a fairly reasonable job of identifying obvious memory leaks, use of uninitialized variables, etc. clang-tidy also takes advantage of clang's FixIt scheme where it can automatically rewrite code to resolve common issues or remove deprecated constructs. We do not intent to use such FixIt's on a day-to-day basis.</p><p>clang-tidy is integrated into the build system when using a recent version of cmake, however it can be invoked using:</p><pre>  /scratch3/maestro/pkg/llvm-4.0.0/bin/clang-tidy &lt;MY SOURCE FILE&gt;.cpp</pre><p>clang-tidy can be enabled using the ENABLE_CLANG_TIDY option during cmake configuration.</p><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-mandatory_guidelinesDoyouhaveanykeystyleguidelinesthatImustobey?"><span class="confluence-anchor-link" id="MaestroBuildFrequentlyAskedQuestions(FAQ)-mandatory_guidelines"><span class="confluence-anchor-link" id="mandatory_guidelines"></span></span>Do you have any key style guidelines that I <u style="font-size: 20.0px;">must</u> obey?</h2><p>Yes:</p><ul><li>Lines must be limited to 80 columns</li><li>All indentation must be performed using spaces of depth 2. Tabs are disallowed.</li><li>Whitespace errors are not allowed: trailing whitespace, tabs, lack of trailing newline at the end of file.</li><li>An appropriate copyright must head the source file.</li><li>Source code must compile and it must pass basic sanity checks before it can be checked in.</li><li>Please obey a sane and consistent coding style. If contributing to code written by others, please obey the surrounding code style as appropriate. Of course, we expect all code to be consistent with the Google style, as this is our mandated style.</li><li>Code to be committed, MUST be free of memory leaks or memory corruption bugs as identified by valgrind.</li></ul><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-Whatadditionaltoolscanweusetoensurecorrectness?">What additional tools can we use to ensure correctness?</h2><p>Static analysis tools are very effective at catching basic semantic issues in source code. They can save valuable time when debugging as they can easily detect bugs that may not otherwise be apparent on initial observation. There are two common static analysis tools proposed:</p><ul><li><p><strong>clang-tidy (<a class="external-link" href="http://clang.llvm.org/extra/clang-tidy/" rel="nofollow">http://clang.llvm.org/extra/clang-tidy/</a>)</strong></p><p>clang-tidy is yet-another-llvm-based-tool. clang-tidy, as it leverages LLVM fully parses the C++ source code and therefore produces very accurate lint violations. It is free, under active development and community opinion seems to rate it very highly as the current tool of choice in the domain. </p><pre>clang-tidy &lt;MY_SOURCE_FILE.cpp&gt;</pre></li><li><p><strong>CPPCHECK (<a class="external-link" href="http://cppcheck.sourceforge.net/" rel="nofollow">http://cppcheck.sourceforge.net/</a>)</strong></p><p>CPPCHECK appears to be a fairly well established linter. It does not appear to have the sophistication of clang-tidy, because it cannot fully parse C++. It remains a secondary choice to clang-tidy.</p></li></ul><h2 id="MaestroBuildFrequentlyAskedQuestions(FAQ)-Howdowenavigateoursourcecode?">How do we navigate our source code?</h2><p>It is desirable to have an established database that can be used to navigate our source code. There are a variety of options:</p><ul><li><strong>Doxgyen</strong><br/>Documentation of the Maestro code base is already carried out using Doxygen, we are therefore able to leverage existing code annotations. This is our preferred method.</li><li><strong>CLion</strong><br/>Our canon IDE automatically indexes all source code found by the build system. CLion has extensive capability to search for methods, generate doxygen compliant annotations and perform refactoring.</li></ul><p> Presently, the official and blessed source code browser is Doxygen.</p><p><br/></p><p><br/></p><p><br/></p><p><br/></p>