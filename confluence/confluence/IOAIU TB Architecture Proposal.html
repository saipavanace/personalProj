<style type='text/css'>/*<![CDATA[*/
div.rbtoc1759724764181 {padding: 0px;}
div.rbtoc1759724764181 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1759724764181 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class='toc-macro rbtoc1759724764181'>
<ul class='toc-indentation'>
<li><a href='#IOAIUTBArchitectureProposal-1.DirectoryStructure'>1. Directory Structure</a></li>
<li><a href='#IOAIUTBArchitectureProposal-2.Introduction'>2. Introduction</a></li>
<li><a href='#IOAIUTBArchitectureProposal-3.Philosophy'>3. Philosophy</a></li>
<li><a href='#IOAIUTBArchitectureProposal-4.ArchitectureDiagram'>4. Architecture Diagram</a></li>
<li><a href='#IOAIUTBArchitectureProposal-5.TestBenchStructure'>5. Test Bench Structure</a>
<ul class='toc-indentation'>
<li><a href='#IOAIUTBArchitectureProposal-5.1TBTop'>5.1 TB Top</a></li>
<li><a href='#IOAIUTBArchitectureProposal-5.2TBtopharness'>5.2 TB top harness</a></li>
<li><a href='#IOAIUTBArchitectureProposal-5.3KnobsClass'>5.3 Knobs Class</a></li>
<li><a href='#IOAIUTBArchitectureProposal-5.4ACECacheModel'>5.4 ACE Cache Model</a></li>
<li><a href='#IOAIUTBArchitectureProposal-5.5AddressManager'>5.5 Address Manager</a></li>
<li><a href='#IOAIUTBArchitectureProposal-5.6DCECacheModel'>5.6 DCE Cache Model</a></li>
<li><a href='#IOAIUTBArchitectureProposal-5.7SMIBaseSequence(systemBFM)'>5.7 SMI Base Sequence (system BFM)</a></li>
<li><a href='#IOAIUTBArchitectureProposal-5.8SynopsysAXISequencesandConfigurationfile'>5.8 Synopsys AXI Sequences and Configuration file</a></li>
<li><a href='#IOAIUTBArchitectureProposal-5.9CSRSequences'>5.9 CSR Sequences</a>
<ul class='toc-indentation'>
<li><a href='#IOAIUTBArchitectureProposal-5.9.1APBAgent'>5.9.1 APB Agent</a></li>
<li><a href='#IOAIUTBArchitectureProposal-5.9.2UVMRALModel'>5.9.2 UVM RAL Model</a></li>
<li><a href='#IOAIUTBArchitectureProposal-5.9.3Predictor'>5.9.3 Predictor</a></li>
<li><a href='#IOAIUTBArchitectureProposal-5.9.3Adapter'>5.9.3 Adapter</a></li>
<li><a href='#IOAIUTBArchitectureProposal-5.9.3CSRBaseSequence'>5.9.3 CSR Base Sequence</a></li>
</ul>
</li>
<li><a href='#IOAIUTBArchitectureProposal-5.10ProxyCachestateModel'>5.10 Proxy Cache state Model</a></li>
<li><a href='#IOAIUTBArchitectureProposal-5.11IOAIUBaseVirtualSequence'>5.11 IOAIU Base Virtual Sequence</a></li>
<li><a href='#IOAIUTBArchitectureProposal-5.12BaseScenario'>5.12 Base Scenario</a></li>
<li><a href='#IOAIUTBArchitectureProposal-5.13BaseTest'>5.13 Base Test</a>
<ul class='toc-indentation'>
<li><a href='#IOAIUTBArchitectureProposal-5.13.1buildphase'>5.13.1 build phase</a></li>
<li><a href='#IOAIUTBArchitectureProposal-5.13.2runphase'>5.13.2 run phase</a></li>
</ul>
</li>
<li><a href='#IOAIUTBArchitectureProposal-5.14TestSuite'>5.14 Test Suite</a></li>
<li><a href='#IOAIUTBArchitectureProposal-5.15BaseScoreboard'>5.15 Base Scoreboard</a>
<ul class='toc-indentation'>
<li><a href='#IOAIUTBArchitectureProposal-5.15.1StorageClass:'>5.15.1 Storage Class :</a></li>
<li><a href='#IOAIUTBArchitectureProposal-5.15.2Predictor:'>5.15.2 Predictor:</a></li>
<li><a href='#IOAIUTBArchitectureProposal-5.15.3Comparator:'>5.15.3 Comparator:</a></li>
<li><a href='#IOAIUTBArchitectureProposal-5.15.4DeletionLogic:'>5.15.4 Deletion Logic:</a></li>
<li><a href='#IOAIUTBArchitectureProposal-5.15.5AgingAlgorithm:'>5.15.5 Aging Algorithm:</a></li>
<li><a href='#IOAIUTBArchitectureProposal-5.15.6Exampletransactionflow:'>5.15.6 Example transaction flow:</a></li>
</ul>
</li>
<li><a href='#IOAIUTBArchitectureProposal-5.16CoverageCollector'>5.16 Coverage Collector</a></li>
<li><a href='#IOAIUTBArchitectureProposal-5.17Environment'>5.17 Environment</a></li>
<li><a href='#IOAIUTBArchitectureProposal-5.18MultiportEnvironment'>5.18 Multiport Environment</a></li>
<li><a href='#IOAIUTBArchitectureProposal-5.19SMIDemux'>5.19 SMI Demux</a></li>
</ul>
</li>
<li><a href='#IOAIUTBArchitectureProposal-6.EndofTestMechanism'>6. End of Test Mechanism</a></li>
<li><a href='#IOAIUTBArchitectureProposal-7.CodingGuidelines'>7. Coding Guidelines</a></li>
<li><a href='#IOAIUTBArchitectureProposal-8.FutureImprovements'>8. Future Improvements</a></li>
<li><a href='#IOAIUTBArchitectureProposal-9References'>9 References</a>
<ul class='toc-indentation'>
<li><a href='#IOAIUTBArchitectureProposal-Siemen’sUVMCookbook'>Siemen’s UVM Cookbook</a></li>
<li><a href='#IOAIUTBArchitectureProposal-Yikes!Whyismysystemverilogstillsoslooow-DVCon2019paper'>Yikes! Why is my system verilog still so slooow - DVCon 2019 paper</a></li>
<li><a href='#IOAIUTBArchitectureProposal-UVM-StopHittingyoubrothercodingguidelines-DVCon2020'>UVM - Stop Hitting you brother coding guidelines - DVCon 2020</a></li>
<li><a href='#IOAIUTBArchitectureProposal-AdvancedUVMintherealworld-verilabtutorial'>Advanced UVM in the real world - verilab tutorial</a></li>
</ul>
</li>
<li><a href='#IOAIUTBArchitectureProposal-10.ActionItems'>10. Action Items</a></li>
</ul>
</div><h1 id="IOAIUTBArchitectureProposal-1.DirectoryStructure">1. Directory Structure</h1><p>`--- “ioaiu“</p><p>      |--- “tb“      </p><p>      |--- “env“</p><p style="margin-left: 30.0px;">      |--- “scoreboard“</p><p style="margin-left: 60.0px;">      |--- “predictor“</p><p style="margin-left: 60.0px;">      |--- “storage“</p><p style="margin-left: 60.0px;">      |--- “comparator“</p><p style="margin-left: 60.0px;">      |--- “top_scoreboard”</p><p style="margin-left: 60.0px;">      |--- “ccp_scoreboard“</p><p style="margin-left: 60.0px;">      |--- “ace_scoreboard“</p><p style="margin-left: 60.0px;">      |--- “ace-lite scoreboard“</p><p style="margin-left: 60.0px;">      |--- “ace-lite-e scoreboard“</p><p>      |--- “tests“</p><p style="margin-left: 30.0px;">      |--- “axi4“</p><p style="margin-left: 30.0px;">      |--- “axi4_with_proxy“</p><p style="margin-left: 30.0px;">      |--- “ace“</p><p style="margin-left: 30.0px;">      |--- “ace-lite“</p><p style="margin-left: 30.0px;">      |--- “ace-lite-e“</p><p>      |--- “sequences“</p><p style="margin-left: 30.0px;">      |--- “axi4“</p><p style="margin-left: 30.0px;">      |--- “axi4_with_proxy“</p><p style="margin-left: 30.0px;">      |--- “ace“</p><p style="margin-left: 30.0px;">      |--- “ace-lite“</p><p style="margin-left: 30.0px;">      |--- “ace-lite-e“</p><p style="margin-left: 30.0px;">      |--- “csr_sequences“</p><p style="margin-left: 60.0px;">      |--- “various categories ex: errors“</p><p>      |--- “vip“</p><p>      |--- “scenarios“</p><p style="margin-left: 30.0px;">      |--- “axi4“</p><p style="margin-left: 30.0px;">      |--- “axi4_with_proxy“</p><p style="margin-left: 30.0px;">      |--- “ace“</p><p style="margin-left: 30.0px;">      |--- “ace-lite“</p><p style="margin-left: 30.0px;">      |--- “ace-lite-e“</p><h1 id="IOAIUTBArchitectureProposal-2.Introduction">2. Introduction</h1><p>This document describes the Testbench architecture proposed/implemented in IOAIU. The document starts with the top-level diagram of the testbench and adds few considerations and recommendations towards the end of the document.</p><p>This is a live document and will be getting updated to reflect the latest testbench updates.</p><p>The main goal of this document is to describe a testbench which has improved:</p><ul><li><p>Maintainability</p></li><li><p>Portability</p></li><li><p>Debuggability</p></li><li><p>Scalability</p></li><li><p>Performance</p></li></ul><h1 id="IOAIUTBArchitectureProposal-3.Philosophy">3. Philosophy</h1><p>System verilog was developed to add the concepts of Object Oriented principles to the traditional verilog. By the introduction of these principles our testbench can be given robust properties which enable us to work more efficiently. Therefore, we should stick to these principles and avoid deviating from it at any cost. To emphasize this and ingrain it into the core philosophy on which this testbench is built, the fundamental object oriented principles are introduced in this section.</p><p><u>The four pillars of object oriented programming : </u></p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" src="https://arterisip.atlassian.net/wiki/download/attachments/33980874/image-20230226-030111.png?api=v2"></span><ul><li><p><u>Abstraction:</u></p></li></ul><p>This principle dictates that we isolate individual functionality into their own components (classes). Which means, each class should accomplish at most one functionality. Doing this we make the testbench modular to tame the complexity of verification</p><p>For example, a driver should only drive sequence items, it should not check for anything. A scoreboard should only check for the accuracy of DUT, it should not drive anything on the DUT etc.</p><ul><li><p><u>Inheritance:</u></p></li></ul><p>            When we try to isolate the functionality into logical blocks (abstraction), we hit cases where multiple components have shared functionality. Instead of duplicating the code in both the components, we can use inheritance where the common functionality is abstracted out into a parent class and we have the individual components extend from this parent class and only implement the functionality which is unique</p><ul><li><p><u>Encapsulation:</u></p></li></ul><p>            Every code has 2 parts, data, and behavior. The idea of encapsulation is to separate out the data on which the code executes. In other words, every class / function should only execute on the arguments (which can also be another object) that are passed to the it. By constructing the testbench this way (and along with other rules), we will be able to make changes to one class in the testbench without touching any other class.</p><ul><li><p><u>Polymorphism:</u></p></li></ul><p>            When a function inside a class must be changed to create a different scenario, we can change the function from a child class which extends the parent class and override the function in the child class. This is called polymorphism. This way we don’t have to touch the parent class to make the changes and thus our testbench becomes more modular</p><p /><p>The entire testbench described in the next few sections is built with these principles in mind and the best effort is put not to deviate from these principles to reap maximum benefits offered by UVM</p><h1 id="IOAIUTBArchitectureProposal-4.ArchitectureDiagram">4. Architecture Diagram</h1><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" src="https://arterisip.atlassian.net/wiki/download/attachments/33980874/image-20230302-172423.png?api=v2"></span><h1 id="IOAIUTBArchitectureProposal-5.TestBenchStructure">5. Test Bench Structure</h1><h2 id="IOAIUTBArchitectureProposal-5.1TBTop">5.1 TB Top</h2><p>There is nothing special with this component of the testbench. This just instantiates the DUT, calls the run_test method of UVM and sets various interfaces used into config_db. We can also add any assertions on the RTL at this level. NOTE: We should not add “always” blocks at this level which would read an RTL signal and checks on top of that. Doing so might seem straightforward, but it drastically reduces the maintainability of the testbench. In fact, this was precisely testcases were written before system verilog was introduced which we need to avoid.</p><h2 id="IOAIUTBArchitectureProposal-5.2TBtopharness">5.2 TB top harness</h2><p>TBD</p><p>source : <a class="external-link" href="https://www.verilab.com/files/verification_prowess_with_uvm_harness_presentation.pdf" rel="nofollow">https://www.verilab.com/files/verification_prowess_with_uvm_harness_presentation.pdf</a></p><h2 id="IOAIUTBArchitectureProposal-5.3KnobsClass">5.3 Knobs Class</h2><p>This is a singleton object which brings all the variables that customize the testbench to generate stimulus, under one roof. Every component in the testbench can access variables from this object to modify their behavior but we can write values into this only by plusargs or a testcase.</p><p>This object is first initialized in the base_test with default values for variables and can later be updated with other testcases which extend from the base_test.</p><p>This class can also be used to modify the way we constraint values in our stimulus, thus to create a directed testcase, all we have to do is create a new testcase which extends from the base_test and modify these variables to generate the necessary stimulus</p><p>This class will also be the only class which consumes plusargs making it easy to modularize the code</p><p>NOTE: Minor implementation details still need to be ironed out. For example, we need to try and minimize the total number of places this class is used and read</p><span class="confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image image-center" width="204" src="https://arterisip.atlassian.net/wiki/download/attachments/33980874/image-20230226-204520.png?api=v2"></span><p /><h2 id="IOAIUTBArchitectureProposal-5.4ACECacheModel">5.4 ACE Cache Model</h2><p>This is a UVM_OBJECT which models the external cache. This is a read-only class which can be read by AXI sequences to construct appropriate responses to be driven on the Native interface or can be read by the scoreboard to check for the correctness of the responses generated by the DUT.</p><p>Implementation Note : Make the cache model states read-only outside the model but read-write inside it : <a class="external-link" data-card-appearance="inline" href="https://verificationacademy.com/forums/systemverilog/variable-accessible-inside-class-becomes-read-only-outside-class" rel="nofollow">https://verificationacademy.com/forums/systemverilog/variable-accessible-inside-class-becomes-read-only-outside-class</a> </p><p>The ACE Cache Model subscribes to AXI monitor to update the states (TBD: Can this extend uvm_subscriber?)</p><p>NOTE: We should not have any checks inside of ACE Cache Model as all checks should be inside the scoreboard (to adhere to the “abstraction“ principle of Object Oriented Programming). We can access the ACE Cache Model inside the scoreboard to check if the responses from the DUT, for an address in a given state, is valid.</p><h2 id="IOAIUTBArchitectureProposal-5.5AddressManager">5.5 Address Manager</h2><p>This is a static UVM_OBJECT, in which nothing gets updated. It is just a big lookup table which gives us methods with which we can fetch the addresses that we are interested in. The only component that needs this object are the virtual sequences (confirm?).</p><h2 id="IOAIUTBArchitectureProposal-5.6DCECacheModel">5.6 DCE Cache Model</h2><h2 id="IOAIUTBArchitectureProposal-5.7SMIBaseSequence(systemBFM)">5.7 SMI Base Sequence (system BFM)</h2><p>IOAIU SMI sequence extends from this base sequence. The functionality that is common between IOAIU and CHI (or any other block) should be added to this sequence. Any functionality that is specific to a given block should be abstracted out into a different file which extends from the SMI base sequence. This allows us to have a modular sequence which is easy to maintain and debug.</p><p>TBD: Do we need to have a cache model? I think YES to achieve abstraction</p><h2 id="IOAIUTBArchitectureProposal-5.8SynopsysAXISequencesandConfigurationfile">5.8 Synopsys AXI Sequences and Configuration file</h2><p>From are provided with <a class="external-link" href="https://webfile.arteris.com/~spavan/vip/doc/axi_svt_uvm_class_reference/html/sequencepages.html" rel="nofollow">these </a>sequences from Synopsys. Each of these sequences generate a specific stimulus as described in the document and most likely these sequences will cover all our required stimulus on the native interface side of AXI and ACE.</p><p>The sequences can be modified/controlled through the use of a configuration file.</p><h2 id="IOAIUTBArchitectureProposal-5.9CSRSequences">5.9 CSR Sequences</h2><h3 id="IOAIUTBArchitectureProposal-5.9.1APBAgent">5.9.1 APB Agent</h3><p>APB interface is used to drive APB traffic that programs registers in IOAIU</p><h3 id="IOAIUTBArchitectureProposal-5.9.2UVMRALModel">5.9.2 UVM RAL Model</h3><p>This is a register map model that is automatically generated by runsim script</p><p>Integrating RAL in the environment : <a class="external-link" data-card-appearance="inline" href="https://verificationguide.com/uvm-ral/packaging-and-integrating-register-model/" rel="nofollow">https://verificationguide.com/uvm-ral/packaging-and-integrating-register-model/</a> </p><h3 id="IOAIUTBArchitectureProposal-5.9.3Predictor">5.9.3 Predictor</h3><p>TBD : We currently do not have this block but this is essential to update the register model with the register value changes in the DUT. </p><h3 id="IOAIUTBArchitectureProposal-5.9.3Adapter">5.9.3 Adapter</h3><p>We currently do not have this block but this is essential to move the sequences from block level to system level where a different protocol (AXI) is used to program the registers</p><h3 id="IOAIUTBArchitectureProposal-5.9.3CSRBaseSequence">5.9.3 CSR Base Sequence</h3><p>The base sequence have wrapper tasks on top of the inbuilt uvm ral model tasks with which we can read, write, poll and peek into the registers of the design</p><h2 id="IOAIUTBArchitectureProposal-5.10ProxyCachestateModel">5.10 Proxy Cache state Model</h2><p>This is the cache state model that models the proxy cache state changes. This is mainly used in the scoreboard alone since proxy cache is not visible outside IOAIU</p><h2 id="IOAIUTBArchitectureProposal-5.11IOAIUBaseVirtualSequence">5.11 IOAIU Base Virtual Sequence</h2><p>This is the base virtual sequence from which all other virtual sequences of IOAIU extend from. The main objective of this virtual sequence is to do the following : </p><ul><li><p>Instantiate the Knobs class</p></li><li><p>Instantiate the CSR base sequence to let the users write to registers in between other sequences or other virtual sequences</p></li><li><p>Instantiate the Synopsys AXI sequences</p></li><li><p>Instantiate the SMI Base sequence</p></li><li><p>Instantiate the default CSR sequence</p></li><li><p>Instantiate the ACE Cache Model</p></li><li><p>Instantiate the Address Manager</p></li><li><p>Configure the Synopsys AXI sequences based on the variables in the Knobs Class</p></li><li><p>Configure the SMI Base sequence based on the variables in the Knobs Class</p></li><li><p>Configure the default CSR sequence based on the variables in the Knobs Class</p></li></ul><p>NOTE : The individual AXI sequences or virtual sequences and the SMI Sequence use various read-only components like the ACE Cache Model, Address Manager, (TBD : cache model in System BFM) etc in the same file to generate stimulus</p><p>Also this Base Virtual sequence starts the fundamental transactions on the AXI interface. For more interesting stimulus, we need to create a specific virtual sequence which extends from this base virtual sequence and modify the configurations to provide us with our required stimulus. We might even want to override the Base Virtual Sequence with the new virtual sequence that is created.</p><h2 id="IOAIUTBArchitectureProposal-5.12BaseScenario">5.12 Base Scenario</h2><p>TBD</p><p>Source : <a class="external-link" href="https://ieeexplore.ieee.org/document/7880824" rel="nofollow">https://ieeexplore.ieee.org/document/7880824</a></p><h2 id="IOAIUTBArchitectureProposal-5.13BaseTest">5.13 Base Test</h2><h3 id="IOAIUTBArchitectureProposal-5.13.1buildphase">5.13.1 build phase</h3><ul><li><p>Builds the required environment based on the configuration we have</p></li><li><p>Creates the virtual sequence</p></li></ul><h3 id="IOAIUTBArchitectureProposal-5.13.2runphase">5.13.2 run phase</h3><ul><li><p>Starts the virtual Sequence</p></li></ul><h2 id="IOAIUTBArchitectureProposal-5.14TestSuite">5.14 Test Suite</h2><p>We need to have a suite of testcases that extend from the base_test and modify the stimulus according to the requirements of the directed testcase. These testcases will also do necessary class overrides to modify the behavior of various classes in the testbench. </p><p>For example. Let’s say we want to do error verification and so we want to create a stimulus which introduces an error in our stimulus. We create an independent virtual sequence to do this and override the base virtual sequence (started in the base_test) with the new virtual sequence created in a new and independent testcase. This error introduction would probably need a separate scoreboard to consider the error scenario in our checks. Hence this error testcase will also override the error scoreboard with the actual scoreboard. This approach leaves us with a completely independent infrastructure specific to this testcase. </p><p>Eventually we would have multiple such testcases each doing a specific verification task which leads to a robust verification suite. </p><h2 id="IOAIUTBArchitectureProposal-5.15BaseScoreboard">5.15 Base Scoreboard</h2><p>Base scoreboard is, ideally, the only component which performs all our checks in our testbench. Based on the configuration we are running (AXI4, ACE, etc), we can have multiple child scoreboards which extend the base scoreboard. Each of these child scoreboards contains checks that are specific to the configuration. This approach also enforces the abstraction principle of OOP. </p><p>To make even more modular, the base_scoreboard is divded into the following parts : </p><ul><li><p>Storage Class</p></li><li><p>Predictor</p></li><li><p>Comparator</p></li><li><p>Deletion Logic</p></li><li><p>Aging Algorithm</p></li></ul><span class="confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image image-center" width="340" src="https://arterisip.atlassian.net/wiki/download/attachments/33980874/image-20230301-164203.png?api=v2"></span><p> </p><h3 id="IOAIUTBArchitectureProposal-5.15.1StorageClass:"><u>5.15.1 Storage Class :</u></h3><p>This is a singleton uvm_object class which abstracts out all the queues that are used within the scoreboard allowing multiple sub-logic modules of the scoreboard to read and update them easily. Pulling these out into a separate file will make the rest of the scoreboard clean and elegant. Also, since this is a singleton class, all components view the same copy of the object.</p><h3 id="IOAIUTBArchitectureProposal-5.15.2Predictor:"><u>5.15.2 Predictor:</u></h3><p>This logic module within the scoreboard is responsible to predict the DUT responses in response to the native interface stimulus that is driven into IOAIU. Once the predictor looks at the transaction on the Native interface or the SnpReq transaction on SMI, it will construct all predicted packets (on SMI and native interface) and push them into the storage class to be checked and deleted later.</p><p>The predictor will also refer to the ace_cache_model or the ccp_cache_model (in relevant configs) to construct the predicted packets and also the uvm register model to get the values of registers to aid in the prediction</p><h3 id="IOAIUTBArchitectureProposal-5.15.3Comparator:"><u>5.15.3 Comparator:</u></h3><p>This logic module of the scoreboard is where all checks are active. The comparator snoops the packets coming from the response channels of the RTL and picks the predicted packets from the storage class to do the checking.</p><h3 id="IOAIUTBArchitectureProposal-5.15.4DeletionLogic:"><u>5.15.4 Deletion Logic:</u></h3><p>As the transactions are being initiated and the comparator is checking for the accuracy of the packets generated by RTL, we can have an independent logic which decides when to clear the packets from the storage class. It is cleaner to have this logic abstracted out.</p><h3 id="IOAIUTBArchitectureProposal-5.15.5AgingAlgorithm:"><u>5.15.5 Aging Algorithm:</u></h3><p>TBD : See if this is easy to implement a background thread running to the storage packets to determine if a transaction got stuck</p><h3 id="IOAIUTBArchitectureProposal-5.15.6Exampletransactionflow:"><u>5.15.6 Example transaction flow:</u></h3><span class="confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image image-center" width="340" src="https://arterisip.atlassian.net/wiki/download/attachments/33980874/image-20230226-223537.png?api=v2"></span><h2 id="IOAIUTBArchitectureProposal-5.16CoverageCollector">5.16 Coverage Collector</h2><p>This is a uvm component which extends the uvm_subscriber. We can make this component subscribe to all monitors and write all the coverage inside this component. If we need to do sample coverage in a very specific scenarios which is not entirely possible without the code in the scoreboard, we can also make this component extend the scoreboard instead of the uvm_subscriber (since scoreboard is connected to all monitors anyways).</p><p>TBD : However, keeping it separated out is great for abstraction but more discussion is needed on this</p><h2 id="IOAIUTBArchitectureProposal-5.17Environment">5.17 Environment</h2><p>The environment is where we stitch various components of the testbench and use only those components that are required. Example instead of having a single ioaiu_scoreboard file which has checks that are relevant to both proxy cache and ACE (guarded by JSON parameters), we can have 2 scoreboards for AXI4 and ACE and only use the relevant scoreboard based on the JSON parameter. This way, instead of having the JSON parameter scattered all over the scoreboard file, we will use it once in the environment and thus the testbench will be cleaner </p><h2 id="IOAIUTBArchitectureProposal-5.18MultiportEnvironment">5.18 Multiport Environment</h2><p>This configures as many environments as there are cores in IOAIU</p><h2 id="IOAIUTBArchitectureProposal-5.19SMIDemux">5.19 SMI Demux</h2><p>In IOAIU we have as many environments as there are cores and each environment contains a scoreboard. However, we still only have a single SMI port. Therefore, as each packet on SMI can belong only to a single IOAIU scoreboard, we need some kind of logic that determines the routing of packet. This is managed in SMI Demux component.  The monitor on SMI port connects to the “smi_demux“ component and the smi_demux sends the packets to the individual scoreboards. The SMI Demux component is instantiated in the Multiport environment which also instantiates other environments</p><h1 id="IOAIUTBArchitectureProposal-6.EndofTestMechanism">6. End of Test Mechanism</h1><p>phase.raise_objection and phase.drop_objection are very expensive constructs of UVM (in terms of performance). Hence these need to be avoided as much as possible. Ideally, in the base test, we would have a single phase.raise_objection and then start a virtual sequence and then drop the objection. However, in our scenario, this leads to a problem where we might be dropping objection before finishing the handshake for the previous transaction that was started. Hence, to avoid this scenario, we need to somehow raise an objection, send all the transactions that are required by the test, wait for all the transactions to finish and then drop the objection. </p><p>TBD: Finer implementation details need to be discussed, but one idea is to keep decrementing a counter whenever a transaction finishes and drop the objection once the counter reaches zero (initial counter value = total number of initial transactions). </p><h1 id="IOAIUTBArchitectureProposal-7.CodingGuidelines">7. Coding Guidelines</h1><p>If we want to preserve the testbench architecture and keep it as clean as possible forever, it is also important to standardize the coding style that we follow while coding the various testbench components. These are briefly described <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16777692/NCORE+DV+Coding+Guidelines" data-linked-resource-id="16777692" data-linked-resource-version="25" data-linked-resource-type="page">here</a></p><h1 id="IOAIUTBArchitectureProposal-8.FutureImprovements">8. Future Improvements</h1><h1 id="IOAIUTBArchitectureProposal-9References">9 References</h1><h2 id="IOAIUTBArchitectureProposal-Siemen’sUVMCookbook">Siemen’s UVM Cookbook</h2><p class="media-group"><a href="/wiki/spaces/ENGR/pages/33980874/IOAIU+TB+Architecture+Proposal?preview=%2F33980874%2F175013998%2Fuvm-cookbook.pdf"><span style="background: url('/wiki/s/-672721829/6452/d621ad2a33e27b90ca05c475b216bfab745e08a2/1000.0.0-d621ad2a33e2/_/download/resources/com.atlassian.confluence.plugins.confluence-view-file-macro:view-file-macro-resources/images/placeholder-medium-pdf.png'); width: 333px; height: 95px; display: inline-block; padding-top: 155px; margin: 2px; border: 1px solid #ddd; text-align: center; vertical-align: text-bottom; text-decoration: none; font-size: 12px; color: #000;">uvm-cookbook.pdf</span></a></p><h2 id="IOAIUTBArchitectureProposal-Yikes!Whyismysystemverilogstillsoslooow-DVCon2019paper"><a class="external-link" href="http://www.sunburst-design.com/papers/CummingsDVCon2019_Yikes_SV_Coding_rev1_0.pdf" rel="nofollow">Yikes! Why is my system verilog still so slooow - DVCon 2019 paper</a></h2><h2 id="IOAIUTBArchitectureProposal-UVM-StopHittingyoubrothercodingguidelines-DVCon2020"><a class="external-link" href="https://2020.dvcon-virtual.org/sites/dvcon20/files/2020-05/05_1_P.pdf" rel="nofollow">UVM - Stop Hitting you brother coding guidelines - DVCon 2020</a></h2><h2 id="IOAIUTBArchitectureProposal-AdvancedUVMintherealworld-verilabtutorial"><a class="external-link" href="https://www.verilab.com/files/verilab_dvcon_tutorial_a.pdf" rel="nofollow">Advanced UVM in the real world - verilab tutorial</a></h2><h1 id="IOAIUTBArchitectureProposal-10.ActionItems">10. Action Items</h1><ul><li><p>Check if Synopsys VIP comes with a cache model</p></li></ul><p />