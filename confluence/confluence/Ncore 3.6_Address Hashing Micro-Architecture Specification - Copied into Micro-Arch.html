<p /><p><strong>Background</strong>:<br/>In a set-way cache, multiple sequential streams that have the same mid-lower physical address<br/>bits will be indexed into the same sets, resulting in cache thrashing and the low utilization of<br/>capacity.<br/>Example:<br/>Assuming there is a 1MB, 8-way cache with 64B cachelines. 2048 sets altogether:</p><div class="table-wrap"><table data-table-width="760" data-layout="default" data-local-id="7ccf3671-80bd-4b00-b092-d5570a7f8606" class="confluenceTable"><colgroup><col style="width: 226.67px;"/><col style="width: 226.67px;"/><col style="width: 226.67px;"/></colgroup><tbody><tr><th class="confluenceTh"><p><strong>Tag</strong></p></th><th class="confluenceTh"><p><strong>Index</strong></p></th><th class="confluenceTh"><p><strong>Offset</strong></p></th></tr><tr><td class="confluenceTd"><p>39:17</p></td><td class="confluenceTd"><p>16:6</p></td><td class="confluenceTd"><p>5:0</p></td></tr></tbody></table></div><p>A sequential stream (usually 4KB) is likely to exhaust all permutations of physical address [11:0],<br/>leaving only physical address [16 : 12] as variables. So, the chance that two streams collide is<br/>1/32. They are likely mapped to the same 64 sets even though we have 2048 sets. When we<br/>have more streams, the chance of collision is even higher. And when more than 8 steams<br/>collide, our 8-way cache gets thrashed.<br/></p><p><strong>Proposed solution</strong>:<br/>Apply a hash function that involves the physical tag portion and cache index portion of the<br/>physical address.<br/>Assign PA [16 : 6] ^ PA [27 : 17] &lt;- Use PA [27 : 17] instead of PA [39 : 29] because top<br/>much as lower bits. Exoring the tag and index is the simplest solution. More<br/>advanced hash functions can be applied. A few options to select the top bits can be provided in<br/>case the steams have bigger strides.<br/>Now that the new index is more random, a sequential stream will scatter into different sets,<br/>resulting in less potential same index thrashing.<br/></p><p><strong>To look up</strong>:<br/>Instead of using the old index to read 8 tags, use the new index1 to read 8 tags. Compare the 8 tags with the top PA bits to get a sole hit or a miss.<br/>To linefill or evict, we need the original physical address. There is no need to store it in the<br/>cache. We can exor PA [27:17] with index' to get the original index. Exoring is the simplest hash that’s also easily revervsed. </p><p /><p><strong>Implementation:</strong></p><p><a class="external-link" href="http://gitlab.arteris.com/hardware/hw-lib/-/blob/master/rtl/lib/src/set_select.tachl" rel="nofollow">hw-lib/rtl/lib/src/set_select.tachl</a> has the interleaving/hashing function implementation for Ncore3.2/3.4.</p><p> It’s currently being used by DMI[SMC], DCE [SF] &amp; IOAIU[proxy $]. </p><ul><li><p>The parameter that our customers can use to control this is “<strong>PriSubDiagAddrBits</strong>”.</p></li><li><p>User can specify any bits above the offset bits as primary interleaving/hashing bits.</p></li><li><p>Based on the value passed in PriSubDiagAddrBits we use those bits for hashing/interleaving.</p></li><li><p>There are no operations[Xor, Or…] performed on these bits, we just use these bits for interleaving the data.</p></li></ul><p> </p><p>Design does allow for a secondary set of interleaving/hashing bits. But this is not currently supported and hence it is tied to 0’s.</p><p> </p><p>There is a parameter that could be used by our customer to enable this<strong> [provided we add Maestro support]</strong>: <strong>SecSubRows</strong></p><p> </p><p>Assumption of use:</p><ul><li><p>These additional address bits are used to hash the ways selected by the primary bits.</p></li><li><p>These may not include address bits that are chosen for the Primary bits themselves and offset bits</p></li><li><p>The secondary bits are chosen on a per primary bit basis. The bits within the set for a primary bit are combined together and the primary bit with an Exclusive OR combination. A given address bit may belong to Secondary bit sets of multiple primary bits.</p></li></ul><p> </p><p>This provides secondary masking capabilities which would result in a resultant interleaving/hash function as described below:</p><p> </p><p>Assume PriSubDiagAddrBits to be A[3:0] corresponding to some combination of Tag and/or Index bits.</p><p>Assume SecSubRows to be B[7:0] again corresponding to some combination of Tag and/or Index bits.</p><p> </p><p>The resultant Hash function output C[3:0] would be:</p><p>C[0] = A[0]^B[0]^B[1]….^B[7]</p><p>C[1] = A[1]^B[0]^B[1]….^B[7]</p><p>C[2] = A[2]^B[0]^B[1]….^B[7]</p><p>C[3] = A[3]^B[0]^B[1]….^B[7]</p>