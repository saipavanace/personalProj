<h2 id="AutogenerationofCSRregisterportsandinterfaces-Introduction">Introduction</h2><p>In Ncore, all registers in a given unit are centrally situated in a single instance of the <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16171929/apb_csr" data-linked-resource-id="16171929" data-linked-resource-version="3" data-linked-resource-type="page">apb_csr</a> block. The register bits need to be supplied to or connected to appropriate logic blocks that consume (*_out) them or control (*_in, *_wr) them. There exists a naming convention for such ports that is derived from three parts: register-name (string),  field-name (string), and type (string: &quot;out&quot;, &quot;in&quot;, &quot;wr&quot;).</p><p>Given the register definitions, it is thus possible to generate a list of ports or interface (CSR interface) that connect to those register flops, along with their widths. A given logic block inside an Ncore unit typically reads or controls only a subset of the unit's registers, in which case we are required to generate the list of CSR ports based on that subset. This flow describes the steps to generate such an interface from <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16154965/csr" data-linked-resource-id="16154965" data-linked-resource-version="35" data-linked-resource-type="page">csr</a> register definitions.</p><p>The primary benefit of generating CSR interfaces or ports this way is that when the register definitions change, only the block-specific CSR and the block that consumes the register bits need to be updated. And avoids having to update connectivity in units that instantiate them.</p><p><br/></p><h2 id="AutogenerationofCSRregisterportsandinterfaces-BlockDiagrams">Block Diagrams</h2><p><br/></p><p><br/></p><p><span class="confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image image-center" height="400" src="https://arterisip.atlassian.net/wiki/download/attachments/16160703/image2021-8-19_16-27-32.png?api=v2"></span></p><p style="text-align: center;">Figure 1: Unit CSR generation flow in Maestro-Ncore environment</p><p><br/></p><p><br/></p><p style="text-align: center;"><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="400" src="https://arterisip.atlassian.net/wiki/download/attachments/16160703/image2021-8-19_16-27-19.png?api=v2"></span><br/><br/>Figure 2: CSR interface generation for blocks inside an Ncore unit</p><p><br/></p><p><br/></p><h2 id="AutogenerationofCSRregisterportsandinterfaces-Description">Description</h2><p>The Maestro flow as shown in Figure 1 handles the generation of <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16154965/csr" data-linked-resource-id="16154965" data-linked-resource-version="35" data-linked-resource-type="page">csr</a> objects from the golden definition of registers and fields in the CPR. It then passes each generated <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16154965/csr" data-linked-resource-id="16154965" data-linked-resource-version="35" data-linked-resource-type="page">csr</a> object as a JSON parameter to the appropriate units. The <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16154965/csr" data-linked-resource-id="16154965" data-linked-resource-version="35" data-linked-resource-type="page">csr</a> object is then used by a centralized <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16171929/apb_csr" data-linked-resource-id="16171929" data-linked-resource-version="3" data-linked-resource-type="page">apb_csr</a> block that implements all the registers in that unit. The same apb_csr block also supplies ports to various blocks to control and read from registers.</p><p>Every block in the Ncore unit consumes (control or reads from) only a subset of registers in the <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16154965/csr" data-linked-resource-id="16154965" data-linked-resource-version="35" data-linked-resource-type="page">csr</a> object that is passed to that unit. So we need a way to determine CSR interfaces that consist of register bits consumed only by a particular block. To do so, we follow a two-step process:</p><p><strong>Step 1:</strong></p><p>Call a function: gen&lt;blockName&gt;Registers( <em>registers</em>, <em>prefix</em>, <em>params</em> )</p><p>that returns only a subset of registers in the Ncore-unit's <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16154965/csr" data-linked-resource-id="16154965" data-linked-resource-version="35" data-linked-resource-type="page">csr</a> object that the particular block controls or is controlled by.</p><p>The owner of the block that needs to access registers is expected to code this function. The function must take the following parameters:</p><ol><li><em>registers</em>: Array of all the registers in an address-block ( Ex: csr.spaceBlock[0].registers ) of a <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16154965/csr" data-linked-resource-id="16154965" data-linked-resource-version="35" data-linked-resource-type="page">csr</a> object that is passed to the Ncore unit in which the block is instantiated.</li><li><em>prefix</em>: A string that is specific to each Ncore unit and will be used to prefix register names. Ex: &quot;CAIU&quot; for CHI-AIUs, &quot;XAIU&quot; for IOAIUs, &quot;DMI&quot; for DMIs etc.</li><li><em>params</em> for register generation: Optional. An object of params that is used to determine the type and number of registers that are expected.</li></ol><p>The function is expected to maintain or generate a list of register names that controls or is updated by the block.</p><ol><li>It will simply perform matching of those names to grep out and return a subset of registers from the <em>registers</em> array param in the <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16154965/csr" data-linked-resource-id="16154965" data-linked-resource-version="35" data-linked-resource-type="page">csr</a> object OR</li><li>Alternatively it could modify the names of registers in the returned array to strip off the unit-prefix (&quot;CAIU&quot;, &quot;XAIU&quot; etc.). The advantages of this is described in the section on referencing CSR ports.</li></ol><p><strong>Step 2:</strong></p><p>Call the <span class="legacy-color-text-blue3">createCSRInterfaceGenerator( <em>registers </em>). This returns an object with methods to generate a CSR-interface for those registers as a signal-bundle or an old-style interface, new-style interface (InterfaceGeneric), or to generate the input and output ports of the CSR-interface separately.</span></p><p><span class="legacy-color-text-blue3">Call one of the methods above depending whether the given block uses an old-style interface or a new-style one. When creating the old-style or new-style interface ensure that the &quot;name&quot; property of the interface matches the unit's <em>prefix</em> parameter.</span></p><p><br/></p><h3 id="AutogenerationofCSRregisterportsandinterfaces-ReferencingCSRportsinsideablock"><span class="legacy-color-text-blue3">Referencing CSR ports inside a block</span></h3><p><span class="legacy-color-text-blue3">The names of ports or signals in a CSR interface follow a convention:<br/>&lt;Register&gt;_&lt;Field&gt;_&lt;Type&gt;</span></p><p><span class="legacy-color-text-blue3">where,<br/><em>Register</em>: Name of the register that connects to the port,<br/><em>Field</em>: Name of the register field in the above register that drives or is driven by this port and<br/></span><span class="legacy-color-text-blue3"><em>Type</em>: String that can take the following values: &quot;in&quot;, &quot;wr&quot;, &quot;out&quot;. &quot;in&quot; indicates input wrt the register, &quot;out&quot; indicates output wrt the register, and &quot;wr&quot; also an input to the register used to update the register values.</span><span class="legacy-color-text-blue3"> </span></p><p><span class="legacy-color-text-blue3">It is recommended that in order to align with the conventions for naming CSR Ports (ports coming out and going into the apb_csr block), that users use the following functions in hw-lib/js/lib_utils.js:</span></p><p><span class="legacy-color-text-blue3"><em>queryCsrInterfacePorts</em>( csrInterfaceOldStyle, direction )</span></p><p><span class="legacy-color-text-blue3">The above function returns an object with the below methods:</span></p><p><span class="legacy-color-text-blue3">{<br/>  <em>name</em>( type, register, field ): A function that returns the name of a CSR port of a given type (&quot;in&quot;, &quot;out&quot;, &quot;wr&quot;) that connects to the specified register and field.</span></p><p><span class="legacy-color-text-blue3">  <em>width</em>( type, register, field ): A function that returns the width of a CSR port of a given type (&quot;in&quot;, &quot;out&quot;, &quot;wr&quot;) that connects to the specified register and field. Returns 0 if that port doesn't exist in the interface</span></p><p><span class="legacy-color-text-blue3">  <em>direction</em>( type, register, field ): A function that returns the direction (&quot;input&quot; or &quot;output&quot;) of a CSR port of a given type (&quot;in&quot;, &quot;out&quot;, &quot;wr&quot;) that connects to the specified register and field. <br/></span><span class="legacy-color-text-blue3">}<br/></span></p><p>Example:<br/>var ccrPorts  = queryCsrInterfacePorts( csrInterface, 'slave' );   // Assume csrInterface has the following structure: { name: &quot;CAIU&quot;, signals: { ... } };   <br/>ccrPorts.name( &quot;out&quot;, &quot;CCR2&quot;, &quot;CreditLimit&quot; )   // Returns &quot;CAIUCCR2_CreditLimit_in&quot;,<br/>ccrPorts.width( &quot;wr&quot;, &quot;CCR3&quot;, &quot;CounterState&quot;)  // Returns 1<br/>ccrPorts.direction( &quot;in&quot;, &quot;CCR3&quot;, CounterState&quot;)  // Returns &quot;output&quot; </p><h4 id="AutogenerationofCSRregisterportsandinterfaces-Referencingregisternameswithoutunit-specificprefix"><span class="legacy-color-text-blue3">Referencing register names without unit-specific prefix</span></h4><p><span class="legacy-color-text-blue3">Since a block that accesses CSR registers could potentially be used in different Ncore units, we need a way of referencing the port names without the unit-specific <em>prefix</em> (&quot;CAIU&quot;, &quot;XAIU&quot;, etc.) included in the register names. One way to achieve this is to modify the gen&lt;blockName&gt;Register( ) function described in <strong>Step1</strong> such that it strips off the unit-specific prefix from register names in the returned array of register objects.</span></p><p>Referencing the ports this way ensures that even if the register names for the same block can change from one unit to another (because of the unit-specific <em>prefix</em>), the same TACHL code can be reused in different Ncore units.</p><p><br/></p><p><br/></p><p><br/></p><p><br/></p>