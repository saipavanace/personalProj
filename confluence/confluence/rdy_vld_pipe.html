<h1 id="rdy_vld_pipe-parameters"><strong>parameters</strong></h1><h2 style="margin-left: 30.0px;" id="rdy_vld_pipe-java_script:"><strong>java_script:</strong></h2><pre>{</pre><pre>        &quot;clkGateOn&quot; &quot; true or false, // Instantiate a block gate or not</pre><pre>        &quot;pipeForward&quot; : true or false,  // No timing path between valid_in and valid_out if true.</pre><pre>        &quot;pipeBackward&quot; : true or false, // No timing path between ready_out and ready_in if true.</pre><pre>        &quot;simplePipe&quot; : true or false,   // If depth is greater than one, takes &quot;depth&quot; clocks to propagate from input to output if true.</pre><pre>        &quot;circular&quot; : true or false, // Indicates if the internal structure of the FIFO is circular or not. Circular FIFOs use less power</pre><pre>	&quot;width&quot; : any positive integer 2 or greater, // The width of the data interface</pre><pre>        &quot;depth&quot; : 0 or any positive integer, // The depth of the pipeline.</pre><pre>        &quot;exposeGuts&quot; : true or false, // If true, on output is provided that shows all the pipeline stages in a single output called guts.</pre><pre>        &quot;exposeValids&quot; : true or false, // If true, an output is provided that shows the register valids of the internal FIFO.</pre><pre>        &quot;protectionInterface&quot; :</pre><pre>          {&quot;name&quot; : a_string,</pre><pre>           &quot;signals&quot; : {interface Definition}},</pre><pre>        &quot;protectionStyle&quot; : <a class="external-link" href="https://confluence.arteris.com/display/ENGR/protectionStyle" rel="nofollow">protectionStyle</a>}</pre><pre>}</pre><h1 id="rdy_vld_pipe-I/O"><strong>I/O</strong></h1><pre>if (depth &gt; 0) {<br/> u.port('input','clk',1);<br/> u.port('input','reset_n',1); <br/> if (clkGateOn) {u.port('input', 'test_en',1);}<br/> if (exposeGuts === 'yes') {<br/>  u.port('output','guts',depth*width);<br/> }<br/> if (exposeValids === 'yes') {</pre><pre>  u.port('output','valids',depth); </pre><pre> } </pre><pre> if (protectionStyle !== &quot;&quot;) {<br/>  u.interface(<a class="external-link" href="http://protectionInterface.name" rel="nofollow">protectionInterface.name</a>,'master',protectionInterface.signals);<br/> }<br/>}<br/>u.port('input','in_valid',1);<br/>u.port('output','in_ready',1);<br/>u.port('input','in_data',width);<br/>u.port('output','out_valid',1);<br/>u.port('input','out_ready',1);<br/>u.port('output','out_data',width);</pre><pre><strong style="font-size: 24.0px;font-family: Arial , sans-serif;">Functions Used</strong></pre><p>getEccWidth</p><h1 id="rdy_vld_pipe-ModulesUsed"><strong>Modules Used</strong></h1><p>prot_reg</p><p>rdy_vld_pipe_ctl</p><p>rdy_vld_pipe_dp</p><h1 id="rdy_vld_pipe-Description"><strong>Description</strong></h1><p>The rdy_vld_pipe can be configured in one of three modes as shown below (depth = 3):</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16166765/rdy_vld_pipe.svg?api=v2"></span></p><p>The dotted lines indicate optional circuitry that is added when pipeForward = false to provide a bypass path. All the logic not in rdy_vld_pipe_ctl is in rdy_vld_pipe_dp.</p><p>From an outside point of view, circular FIFO and FIFO are functionally identical. The difference is provided for power and timing reasons.</p><p>The circular FIFO should be smaller, use less power and provide fast input timing, but slow output timing. This should be the default.</p><p>The FIFO will be larger, use more power, have slower input timing but provide very fast output timing. This should only be used when depth is small and output timing is crucial.</p><h1 id="rdy_vld_pipe-Parameters"><strong>Parameters</strong></h1><p>When depth is 0, all parameters are ignored except for width.</p><p>When depth is 1, circular is forced to false regardless of input value.</p><p>When simplePipe = true, circular is ignored.</p><p>The following table is only valid if depth is greater than 0. If depth is 0, then the block is nothing but wires. Basic Pipeline Stage that uses ready and valid to transfer data. Functional description:</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">pipeForward</th><th class="confluenceTh">pipeBackward</th><th class="confluenceTh">SimplePipe</th><th colspan="1" class="confluenceTh">Empty Latency*</th><th colspan="1" class="confluenceTh">Full Latency*</th><th class="confluenceTh">Description</th></tr><tr><td class="confluenceTd">0</td><td class="confluenceTd">0</td><td class="confluenceTd">0</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd"><p>depth</p></td><td class="confluenceTd">A FIFO that can bypass FIFO if empty and ready_out is asserted and can assert ready_in if ready_out is asserted and is FIFO is full.</td></tr><tr><td class="confluenceTd">0</td><td class="confluenceTd">0</td><td class="confluenceTd">1</td><td colspan="1" class="confluenceTd">depth</td><td colspan="1" class="confluenceTd">depth</td><td class="confluenceTd">A delay pipe that can assert ready_in if ready_out is asserted and is full.</td></tr><tr><td class="confluenceTd">0</td><td class="confluenceTd">1</td><td class="confluenceTd">0</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">depth+1</td><td class="confluenceTd">A FIFO that can bypass FIFO if empty and ready_out is asserted, but can't assert ready_in if full.</td></tr><tr><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">depth</td><td colspan="1" class="confluenceTd">depth+1</td><td colspan="1" class="confluenceTd">A delay pipe that can't asserted ready_in if full.</td></tr><tr><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">depth</td><td colspan="1" class="confluenceTd">A FIFO that can't bypass FIFO if empty and ready_out is asserted, but can assert ready_in if ready_out is asserted and FIFO is full.</td></tr><tr><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">depth</td><td colspan="1" class="confluenceTd">depth</td><td colspan="1" class="confluenceTd">Same as 0,0,1.</td></tr><tr><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">depth+1</td><td colspan="1" class="confluenceTd">A FIFO that can't bypass FIFO if empty and ready_out is asserted and can't assert ready_in if ready_out is asserted and FIFO is full.</td></tr><tr><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">1</td><td colspan="1" class="confluenceTd">depth</td><td colspan="1" class="confluenceTd">depth+1</td><td colspan="1" class="confluenceTd">same as 0,1,1.</td></tr></tbody></table></div><p>*For the Empty Latency and Full Latency columns in the above table, out_ready is assumed asserted from beginning to completion of the measurement.</p><p>If circular is true then the internal structure is a circular FIFO and addresses are used to point at the beginning and end of the valid data. Otherwise, the structure uses valid bits.</p><p>If exposeGuts is true, then the outputs of the all the internal registers are concatenated into a single output called guts. exposeGuts can only be true if circular is false.</p><p>protectionStyle only applies to the registers in the control logic which is contained in submodule named rdy_vld_pipe_ctl. The data registers are in submodule rdy_vld_pipe_dp</p><p>When simplePipe is true, pipeForward is ignored.</p><p>For all the microarchitectures the registers/stages are labeled 0 to depth-1 and in FIFO and simple pipe modes, 0 is the register that feeds the output of the block.</p><h2 id="rdy_vld_pipe-MicroarchitecturewhenSimplePipe:">Microarchitecture when SimplePipe:</h2><p>An internal valid vector is created that is two longer than the number of stages.</p><p>For each stage the following equations are implemented:</p><p style="margin-left: 30.0px;">l_ready_n = |(~valid[n:0])</p><p style="margin-left: 30.0px;">next_valid(n) = l_ready_n * valid(n+1) + ~l_ready_n * valid(n)</p><p style="margin-left: 30.0px;">dp_clk_en_n = l_ready_n * valid(n+1) </p><p style="margin-left: 30.0px;">and the two extras are tied off as follows:</p><p style="margin-left: 30.0px;">valid[0] = 1'b0;</p><p style="margin-left: 30.0px;">valid[depth+1] = in_valid &amp; in_ready;</p><p>SimplePipe has no concept of pipeForward = false. Because of this, out_valid has one equation:</p><p style="margin-left: 30.0px;">out_valid = valid[1];</p><p>The in_ready equations changes based in pipeBackward:</p><p style="margin-left: 30.0px;">For pipeBackyard = false:</p><p style="margin-left: 30.0px;">in_ready = |{valid[depth:1],out_ready}</p><p style="margin-left: 30.0px;">For pipeBackyar = true:</p><p style="margin-left: 30.0px;">in_ready = |valid[depth:1]</p><h2 id="rdy_vld_pipe-MicroarchitecturewhenFIFO:">Microarchitecture when FIFO:</h2><p>An internal valid vector is created that is two longer than the number of stages.</p><p>Each stage implements logic that is represented by the following truth table:</p><pre>push pop v(n+1) v(n) v(n-1) | next_v(n) reg_sel mux_sel<br/>0    0   0      0    0      | 0         0       X<br/>0    0   0      0    1      | 0         0       X<br/>0    0   0      1    0      | X         X       X<br/>0    0   0      1    1      | 1         0       X</pre><pre>0    0   1      0    0      | 0         0       X<br/>0    0   1      0    1      | X         X       X<br/>0    0   1      1    0      | X         X       X<br/>0    0   1      1    1      | 1         0       X</pre><pre>0    1   0      0    0      | 0         0       X<br/>0    1   0      0    1      | 0         0       X<br/>0    1   0      1    0      | X         X       X<br/>0    1   0      1    1      | 0         0       X</pre><pre>0    1   1      0    0      | X         X       X<br/>0    1   1      0    1      | X         X       X<br/>0    1   1      1    0      | X         X       X<br/>0    1   1      1    1      | 1         1       1</pre><pre>1    0   0      0    0      | 0         0       X<br/>1    0   0      0    1      | 1         1       0<br/>1    0   0      1    0      | X         X       X<br/>1    0   0      1    1      | 1         0       X</pre><pre>1    0   1      0    0      | X         X       X<br/>1    0   1      0    1      | X         X       X<br/>1    0   1      1    0      | X         X       X<br/>1    0   1      1    1      | 1         0       X</pre><pre>1    1   0      0    0      | 0         0       X<br/>1    1   0      0    1      | 0         0       X<br/>1    1   0      1    0      | X         X       X<br/>1    1   0      1    1      | 1         1       0</pre><pre>1    1   1      0    0      | X         X       X<br/>1    1   1      0    1      | X         X       X<br/>1    1   1      1    0      | X         X       X<br/>1    1   1      1    1      | 1         1       1</pre><p style="margin-left: 30.0px;">push = int_in_valid &amp; in_ready</p><p style="margin-left: 30.0px;">pop = int_out_valid &amp; int_out_ready</p><p style="margin-left: 30.0px;">v = valid</p><p style="margin-left: 30.0px;">next_v = next_valid</p><p style="margin-left: 30.0px;">reg_sel = enable signal to buffer in stage n.</p><p style="margin-left: 30.0px;">mux_sel = signals that selects between in_data (mux_sel = 0) and output from stage n+1.</p><p style="margin-left: 30.0px;">valid[0] = 1'b1</p><p style="margin-left: 30.0px;">valid[depth+1] = 1'b0</p><p style="margin-left: 30.0px;">empty = ~valid[1]</p><p style="margin-left: 30.0px;">full = valid[depth]</p><p style="margin-left: 30.0px;">int_out_valid = ~empty</p><p style="margin-left: 30.0px;">int_in_ready = ~full</p><p>The following translations are made based on pipeForward and pipeBackward:</p><pre>if ((pipeForward === false) &amp; (pipeBackward === false)) {\jsend<br/> assign bypass = empty;<br/> assign int_in_valid = ~(bypass &amp; out_ready) &amp; in_valid;<br/> assign in_ready = out_ready | ~full;<br/> assign out_valid = int_out_valid | in_valid;<br/> assign int_out_ready = ~out_ready;\jsbegin<br/>} else if ((pipeForward === false) &amp; (pipeBackward === true)) {\jsend<br/> assign bypass = empty;<br/> assign int_in_valid = ~(bypass &amp; out_ready) &amp; in_valid;<br/> assign in_ready = ~full;<br/> assign out_valid = int_out_valid | in_valid;<br/> assign int_out_ready = out_ready;\jsbegin<br/>} else if ((pipeForward === true) &amp; (pipeBackward === false)) {\jsend<br/> assign int_in_valid = in_valid;<br/> assign in_ready = out_ready | ~full;<br/> assign out_valid = int_out_valid;<br/> assign int_out_ready = out_ready;\jsbegin<br/>} else {\jsend<br/> assign int_in_valid = in_valid;<br/> assign in_ready = ~full;<br/> assign out_valid = int_out_valid;<br/> assign int_out_ready = out_ready;\jsbegin</pre><h2 id="rdy_vld_pipe-MicroarchitectureforcircularFIFO:">Microarchitecture for circular FIFO:</h2><p>The circular FIFO uses two pointer registers (stop and start) along with a wrap bit to indicated where the FIFO starts and stops in the registers. The wrap bit is use to indicate if the FIFO is full or empty when the start and stop registers are equal.</p><p>The pointers registers are not addresses, but are one hot registers that are of width depth, where one bit corresponds to each register in the FIFO. The start registers indicates the next register to be written into and is the bottom of the FIFO. The stop register indicates where last valid data is and is where the FIFO is read from and is the top of the FIFO. The start and stop registers are &quot;incremented&quot; by shifting left with wrap. Bit 0 of both registers inverts going in and out, so after reset the start and stop registers are both pointing at register 0.</p><p>When the wrap bit is 0 and the start and stop registers are equal, the FIFO is empty. When the wrap bit 1 and the start and stop registers are equal, the FIFO is full. Based on this, where are the equations that control the function of the FIFO:</p><p style="margin-left: 30.0px;">stop_eq_start = |(start &amp; stop)</p><p style="margin-left: 30.0px;">empty = stop_eq_start &amp; ~wrap</p><p style="margin-left: 30.0px;">full = stop_eq_start &amp; wrap</p><p style="margin-left: 30.0px;">next_start = push ? (start shift left with wrap) : start</p><p style="margin-left: 30.0px;">next_stop = pop ? (stop shift left with wrap) : stop</p><p style="margin-left: 30.0px;">next_stop_eq_start = |(next_start &amp; next_stop)</p><p style="margin-left: 30.0px;">next_wrap = wrap ? pop : push &amp; ~pop &amp; next_stop_eq_start</p><p style="margin-left: 30.0px;">int_in_ready = ~full</p><p style="margin-left: 30.0px;">int_out_valid = ~empty</p><p style="margin-left: 30.0px;">push = int_in_valid &amp; int_in_ready</p><p style="margin-left: 30.0px;">pop = int_out_valid &amp; int_out_ready </p><p>The circular FIFO uses that exact same pipeForward and pipeBackward logic as the FIFO does. </p><p>When are valids are being created for &quot;exposeValids&quot; equals &quot;yes&quot; the same logic is used as for the normal FIFO to generate valid, but the valids are not used internally.</p><h1 id="rdy_vld_pipe-FutureEnhancements:">Future Enhancements:</h1><h3 id="rdy_vld_pipe-Security:">Security:</h3><p>The registers inside the pipe are never cleared, only written. This can cause a security concern. There are two methods to address it:</p><ol><li>Low Power Valid Method : AND the internals valids of the registers with the outputs of guts and out_data.</li><li>High Power Method : When internal valid goes from 1 -&gt; 0, write 0s into register.</li></ol><p>Method 1 is low power, but adds delay on the outputs. Method 2 is higher power because it adds to the number of writes to a register, which is increasing the number of times that registers is clocked, but it also adds delay to the circular FIFO input path, because you have to add a way to 0 the data while writing it.</p><p><br/></p>