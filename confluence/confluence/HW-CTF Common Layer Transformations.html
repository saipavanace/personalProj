<h1 id="HW-CTFCommonLayerTransformations-History"><strong>History</strong></h1><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Version</th><th class="confluenceTh">Date</th><th colspan="1" class="confluenceTh">Comments</th><th class="confluenceTh">Editor</th></tr><tr><td class="confluenceTd">0.1</td><td class="confluenceTd">1/15/2020</td><td colspan="1" class="confluenceTd">Accumulation of Common Layer Transformations</td><td class="confluenceTd">Eric Taylor</td></tr></tbody></table></div><h1 id="HW-CTFCommonLayerTransformations-Outline"><strong><span class="inline-comment-marker" data-ref="ebc9c44e-b369-4d56-930c-4e14c0ef058e">Outline</span></strong></h1><p><style type='text/css'>/*<![CDATA[*/
div.rbtoc1759723701915 {padding: 0px;}
div.rbtoc1759723701915 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1759723701915 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class='toc-macro rbtoc1759723701915'>
<ul class='toc-indentation'>
<li><a href='#HW-CTFCommonLayerTransformations-History'>History</a></li>
<li><a href='#HW-CTFCommonLayerTransformations-Outline'>Outline</a></li>
<li><a href='#HW-CTFCommonLayerTransformations-Description'>Description</a></li>
<li><a href='#HW-CTFCommonLayerTransformations-ReferenceSpecification'>Reference Specification</a></li>
<li><a href='#HW-CTFCommonLayerTransformations-Assumptions'>Assumptions</a></li>
<li><a href='#HW-CTFCommonLayerTransformations-NativeLayerto/fromCommonLayerMappings'>Native Layer to/from Common Layer Mappings</a>
<ul class='toc-indentation'>
<li><a href='#HW-CTFCommonLayerTransformations-AXI4to/fromCommonLayer'>AXI4 to/from Common Layer</a>
<ul class='toc-indentation'>
<li><a href='#HW-CTFCommonLayerTransformations-NDP'>NDP</a></li>
<li><a href='#HW-CTFCommonLayerTransformations-DP'>DP</a></li>
</ul>
</li>
<li><a href='#HW-CTFCommonLayerTransformations-APBto/fromCommonLayer'>APB to/from Common Layer</a>
<ul class='toc-indentation'>
<li><a href='#HW-CTFCommonLayerTransformations-NDP.1'>NDP</a></li>
<li><a href='#HW-CTFCommonLayerTransformations-DP.1'>DP</a></li>
</ul>
</li>
</ul>
</li>
<li><a href='#HW-CTFCommonLayerTransformations-CommonLayerRequirementsforNativeLayerConversion'>Common Layer Requirements for Native Layer Conversion</a>
<ul class='toc-indentation'>
<li><a href='#HW-CTFCommonLayerTransformations-AXIATUitoAPBATUt'>AXI ATUi to APB ATUt</a></li>
<li><a href='#HW-CTFCommonLayerTransformations-APBATUitoAXIATUt'>APB ATUi to AXI ATUt</a></li>
<li><a href='#HW-CTFCommonLayerTransformations-AXIATUitoAXIATUt'>AXI ATUi to AXI ATUt</a></li>
</ul>
</li>
<li><a href='#HW-CTFCommonLayerTransformations-CommonLayertoCommonLayerTransformations'>Common Layer to Common Layer Transformations</a>
<ul class='toc-indentation'>
<li><a href='#HW-CTFCommonLayerTransformations-MismatchinwData'>Mismatch in wData</a>
<ul class='toc-indentation'>
<li><a href='#HW-CTFCommonLayerTransformations-BurstType/Unaligned/Narrows'>Burst Type/Unaligned/Narrows</a>
<ul class='toc-indentation'>
<li><a href='#HW-CTFCommonLayerTransformations-Examples(Ifyoupreviewitinbrowserordownloadititisn&#39;tscrunchedup):'>Examples (If you preview it in browser or download it it isn&#39;t scrunched up):</a></li>
</ul>
</li>
<li><a href='#HW-CTFCommonLayerTransformations-250'></a></li>
<li><a href='#HW-CTFCommonLayerTransformations-ReadInterleaving'>Read Interleaving</a></li>
</ul>
</li>
<li><a href='#HW-CTFCommonLayerTransformations-MismatchinnarrowSupported'>Mismatch in narrowSupported</a></li>
<li><a href='#HW-CTFCommonLayerTransformations-MismatchinwrapSupported'>Mismatch in wrapSupported</a></li>
<li><a href='#HW-CTFCommonLayerTransformations-MismatchinincrSupported'>Mismatch in incrSupported</a></li>
<li><a href='#HW-CTFCommonLayerTransformations-MismatchinfixedSupported'>Mismatch in fixedSupported</a></li>
<li><a href='#HW-CTFCommonLayerTransformations-MismatchinreadInterleaveSupported'>Mismatch in readInterleaveSupported</a></li>
<li><a href='#HW-CTFCommonLayerTransformations-MismatchinatomicsSupported(P0:Exclusives)'>Mismatch in atomicsSupported (P0: Exclusives)</a></li>
<li><a href='#HW-CTFCommonLayerTransformations-MismatchinmaxPduSize'>Mismatch in maxPduSize</a></li>
<li><a href='#HW-CTFCommonLayerTransformations-MismatchinwOrderingId/wChannelID'>Mismatch in wOrderingId/wChannelID</a></li>
</ul>
</li>
<li><a href='#HW-CTFCommonLayerTransformations-AppendixA.NarrowRealignmentExample'>Appendix A. Narrow Realignment Example</a></li>
</ul>
</div></p><h1 id="HW-CTFCommonLayerTransformations-Description"><strong>Description</strong></h1><p>This document contains the definition of how two Common Layer Interfaces with different attributes will interact. Mainly describing how a transaction will be transformed by the ATUi and/or the ATUt to satisfy the requirements of the Common Layer interface at the Target.</p><h1 id="HW-CTFCommonLayerTransformations-ReferenceSpecification"><strong>Reference Specification</strong></h1><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156610/HW-CTF+Base+Packet+Parameters+Relationships" data-linked-resource-id="16156610" data-linked-resource-version="4" data-linked-resource-type="page">Base Packet Parameters &amp; Relationships<br /></a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16169110/Symphony+Architecture+Spec" data-linked-resource-id="16169110" data-linked-resource-version="18" data-linked-resource-type="page">Symphony Architecture Spec</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16161575/HW-CTF+Common+Transaction+Layer+Microarchitecture+Specification" data-linked-resource-id="16161575" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF Common Transaction Layer Microarchitecture Specification</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16156866/HW-CTF+Common+Layer+Protocol" data-linked-resource-id="16156866" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF Common Layer Protocol</a></p><h1 id="HW-CTFCommonLayerTransformations-Assumptions"><strong>Assumptions</strong></h1><p>Initiator - A Common Layer interface that can receive requests and request data, and drive responses and response data.</p><p>Target -  A Common Layer interface that can drive requests and request data, and receive responses and response data.</p><p>All Common Layer signals not listed in a To/From mapping will be driven to 0. (e.g. burstType for APB)</p><p><br/></p><div><p>Modifiable/Non Modifiable - The Common Layer will do its best to not modify a transaction if it is non modifiable. If the case is listed below that means the transaction must be transformed even if non-modifiable is true in order to make forward progress and/or satisfy the target requirements. </p><h1 id="HW-CTFCommonLayerTransformations-NativeLayerto/fromCommonLayerMappings"><strong>Native Layer to/from Common Layer Mappings</strong></h1><p><strong>Note: Not all To/From mappings are listed. Most are trivial (e.g. addr -&gt; AxAddr, AxAddr -&gt; addr). Non invertable ones are given two rows (e.g. len-&gt;AxLen/AxSize,AxLen/AxSize -&gt; len) </strong></p><h2 id="HW-CTFCommonLayerTransformations-AXI4to/fromCommonLayer">AXI4 to/from <span class="inline-comment-marker" data-ref="942e982c-68fd-41e5-98b7-aeca7fa37686">Common</span> Layer</h2><h3 id="HW-CTFCommonLayerTransformations-NDP"><span class="inline-comment-marker" data-ref="6b6fa8f7-7c0b-44f7-87db-2e4b4de17303">NDP</span></h3><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/></colgroup><tbody><tr><th colspan="1" class="confluenceTh"><span>Signal A</span></th><th class="confluenceTh">Signal B</th></tr><tr><td colspan="1" class="confluenceTd"><span>txn_ordering_id (or a compressed version using idCompHash)</span></td><td class="confluenceTd">AxID</td></tr><tr><td colspan="1" class="confluenceTd"><span>id </span></td><td colspan="1" class="confluenceTd"><span>AxID (If exclusives enabled at any initiator in the system)</span></td></tr><tr><td colspan="1" class="confluenceTd"><span>txn_channel_id</span><span>, msgTypeAttr[4]</span></td><td class="confluenceTd">Read or Write Channel</td></tr><tr><td colspan="1" class="confluenceTd"><span>addr</span></td><td class="confluenceTd">AxAddress</td></tr><tr><td colspan="1" class="confluenceTd"><span>len</span></td><td class="confluenceTd"><span>(Math.pow(2,AxSize) * (AxLen+1)) - (AxAddr - align(AxAddr,AxSize))</span></td></tr><tr><td colspan="1" class="confluenceTd">AxSize</td><td colspan="1" class="confluenceTd"><span>txn_hdr_burstSize</span></td></tr><tr><td colspan="1" class="confluenceTd">AxLen</td><td colspan="1" class="confluenceTd">(len + <span> (AxAddr - align(AxAddr,AxSize)</span><span>) / <span>txn_hdr_burstSize</span></span></td></tr><tr><td colspan="1" class="confluenceTd"><span>qos</span></td><td class="confluenceTd">AxQos</td></tr><tr><td colspan="1" class="confluenceTd"><span>prot</span></td><td class="confluenceTd">AxProt</td></tr><tr><td colspan="1" class="confluenceTd"><span>user</span></td><td class="confluenceTd">AxUser</td></tr><tr><td colspan="1" class="confluenceTd">txn_hdr_burstType</td><td class="confluenceTd">AxBurst</td></tr><tr><td colspan="1" class="confluenceTd">txn_hdr_burstSize</td><td class="confluenceTd">AxSize</td></tr><tr><td colspan="1" class="confluenceTd"><span>txn_hdr_maxBurstSize</span></td><td colspan="1" class="confluenceTd">Width of Bus</td></tr><tr><td colspan="1" class="confluenceTd"><span>txn_region</span></td><td class="confluenceTd">AxRegion</td></tr><tr><td colspan="1" class="confluenceTd"><span>txn_attr</span></td><td class="confluenceTd">AxCache</td></tr><tr><td colspan="1" class="confluenceTd"><span>msgTypeAttr[3:0]</span></td><td colspan="1" class="confluenceTd"><span>AxCache</span></td></tr><tr><td colspan="1" class="confluenceTd"><span>txn_ordering_model</span></td><td colspan="1" class="confluenceTd">{0,0,1,1}</td></tr><tr><td colspan="1" class="confluenceTd">txn_atomic[0]</td><td colspan="1" class="confluenceTd">AxLock</td></tr><tr><td colspan="1" class="confluenceTd">dp_present</td><td colspan="1" class="confluenceTd">If Write</td></tr><tr><td colspan="1" class="confluenceTd"><p>err[4] = DECERR</p><p>err[5] = SLVERR</p></td><td colspan="1" class="confluenceTd">BRESP</td></tr></tbody></table></div><h3 id="HW-CTFCommonLayerTransformations-DP">DP</h3><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/></colgroup><tbody><tr><th class="confluenceTh"><span>Signal A</span></th><th class="confluenceTh">Signal B</th></tr><tr><td class="confluenceTd">dp_data</td><td class="confluenceTd">WData/RData</td></tr><tr><td colspan="1" class="confluenceTd">dp_ordering_id</td><td colspan="1" class="confluenceTd">RId</td></tr><tr><td class="confluenceTd">dp_be</td><td class="confluenceTd">WStrb</td></tr><tr><td colspan="1" class="confluenceTd"><p>dp_resp[0] = SLVERR</p><p>dp_resp[1] = DECERR</p><p>dp_resp[2] = PREFETCED</p><p>dp_resp[3] = TRANSFAULT</p></td><td colspan="1" class="confluenceTd">RResp</td></tr><tr><td class="confluenceTd">dp_user</td><td class="confluenceTd">WUser/RUser</td></tr><tr><td class="confluenceTd">dp_last</td><td class="confluenceTd">WLast/RLast</td></tr></tbody></table></div><h2 id="HW-CTFCommonLayerTransformations-APBto/fromCommonLayer">APB to/from <span class="inline-comment-marker" data-ref="277af523-479f-4223-b0c8-c3eb576b92a7">Common</span> Layer</h2><h3 id="HW-CTFCommonLayerTransformations-NDP.1">NDP</h3><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/></colgroup><tbody><tr><th colspan="1" class="confluenceTh">Signal A</th><th class="confluenceTh">Signal B</th></tr><tr><td colspan="1" class="confluenceTd">addr</td><td class="confluenceTd">PADDR</td></tr><tr><td colspan="1" class="confluenceTd">len</td><td class="confluenceTd">(<span>wData</span>) - (<span>PADDR</span>- align(<span>PADDR</span>,wData))</td></tr><tr><td colspan="1" class="confluenceTd">prot</td><td class="confluenceTd">PPROT</td></tr><tr><td colspan="1" class="confluenceTd">txn_hdr_burstSize</td><td class="confluenceTd">Width of Bus</td></tr><tr><td colspan="1" class="confluenceTd"><span>txn_hdr_maxBurstSize</span></td><td colspan="1" class="confluenceTd">Width of Bus</td></tr><tr><td colspan="1" class="confluenceTd">msgTypeAttr</td><td colspan="1" class="confluenceTd">PWRITE </td></tr><tr><td colspan="1" class="confluenceTd">dp_present</td><td colspan="1" class="confluenceTd">If Write </td></tr></tbody></table></div><h3 id="HW-CTFCommonLayerTransformations-DP.1">DP</h3><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/></colgroup><tbody><tr><th class="confluenceTh"><span>Signal A</span></th><th class="confluenceTh">Signal B</th></tr><tr><td class="confluenceTd"><span>dp_data</span></td><td class="confluenceTd"><span>PWDATA/PRDATA</span></td></tr><tr><td class="confluenceTd"><span>dp_be</span></td><td class="confluenceTd"><span>if PSTRB then PSTRB else all 1's</span></td></tr></tbody></table></div><h1 id="HW-CTFCommonLayerTransformations-CommonLayerRequirementsforNativeLayerConversion"><strong>Common Layer Requirements for Native Layer Conversion </strong></h1><h2 id="HW-CTFCommonLayerTransformations-AXIATUitoAPBATUt"><strong>AXI ATUi to APB ATUt</strong></h2><p><strong>  Handle in the ATUi</strong></p><ul style="list-style-type: square;"><li>The PAM entry for the APB Target can have maxBurstSize equal to its bus width.<ul style="list-style-type: square;"><li>This means each transaction will be split into single beat Common Layer Transactions for the target.</li><li>The responses from these multiple transactions will be accumulated and be sent back as a single AXI response.</li></ul></li><li>The PAM entry for the APB Target can have splitWrap equal to &quot;true&quot;<strong><br/></strong><ul style="list-style-type: square;"><li>This will cause all WRAPs to be transformed into increments.<br/><br/></li></ul></li><li>Multi Beat Narrow Transactions:<ul><li>They will be transformed into a single large transaction as if it was not narrow. </li><li>That large transaction will then be split according to the first point.</li><li>The accumulated data will come back and the AXI ATUI will make a multi beat narrow response.</li></ul></li></ul><p><strong>   Handle in the ATUt<br/></strong></p><ul style="list-style-type: square;"><li>The ATUt can break up any larger Common Layer Transaction of any burstType to an appropriate amount of single beats to the APB interface.<br/><br/></li></ul><h2 id="HW-CTFCommonLayerTransformations-APBATUitoAXIATUt"><strong>APB ATUi to AXI ATUt</strong></h2><div><ul><li>If there are no PSTRB at the ATUi &amp; packet byte enables are defined, they will be driven to all 1's.</li></ul><h2 id="HW-CTFCommonLayerTransformations-AXIATUitoAXIATUt"><strong>AXI ATUi to AXI ATUt</strong></h2><ul style="list-style-type: square;"><li>If an AXI ATUt gets a WRAP that is a single beat, the WRAP must be coverted to an INCR covering the same bytes.</li></ul></div></div><h1 id="HW-CTFCommonLayerTransformations-CommonLayertoCommonLayerTransformations"><strong style="font-size: 24.0px;">Common Layer to Common Layer Transformations</strong></h1><h2 id="HW-CTFCommonLayerTransformations-MismatchinwData">Mismatch in wData</h2><h3 id="HW-CTFCommonLayerTransformations-BurstType/Unaligned/Narrows">Burst Type/Unaligned/<span class="inline-comment-marker" data-ref="d2dd193a-f306-4fc4-bb22-76551c907cdd">Narrows</span></h3><p>Note: Same As Above means same as the box directly above it.</p><p>Note: Right rotation is MSB to LSB</p><p>Note: Left rotation is LSB to MSB</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col style="width: 29.0px;"/><col style="width: 138.0px;"/><col style="width: 1024.0px;"/><col style="width: 1281.0px;"/><col style="width: 736.0px;"/></colgroup><thead><tr><th class="highlight-grey confluenceTh" colspan="1" data-highlight-colour="grey"><br/></th><th class="highlight-grey confluenceTh" data-highlight-colour="grey"><br/></th><th class="highlight-grey confluenceTh" colspan="3" data-highlight-colour="grey">Target Width Related to Initiator</th></tr></thead><tbody><tr><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey"><br/></td><td class="highlight-grey confluenceTd" data-highlight-colour="grey"><strong>From Initiator</strong></td><td class="highlight-grey confluenceTd" data-highlight-colour="grey"><strong>Same</strong></td><td class="highlight-grey confluenceTd" data-highlight-colour="grey"><strong>Wide</strong></td><td class="highlight-grey confluenceTd" data-highlight-colour="grey"><strong>Narrow</strong></td></tr><tr><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey">1</td><td class="highlight-grey confluenceTd" data-highlight-colour="grey"><strong>Incr</strong></td><td class="confluenceTd">Unchanged</td><td class="confluenceTd"><p><strong>Modifiable</strong></p><ol><li>Use the same start address.</li><li>Target will modify burstSize to match wide bus.</li><li>For Writes, Place incoming data beats into proper alignment on the data bus. This will involve possible left rotation of the data from SMI. Place BE=0 if extra padding needs to be used.</li><li>For Reads, Align data to the initiator so that the critical byte will be received first. This will involve possible right rotation of the data from the response channel.</li></ol><p><strong>Non Modifiable or Exclusive</strong></p><ol><li><p>Use the same start address if not exclusive. If exclusive align address to burstSize at target.</p></li><li>Target will leave burstSize unchanged.</li><li>For Writes, <span>the target will receive packed data. The target must unpack and p</span>lace incoming data beats into proper alignment on the data bus. This will involve possible left rotation of the data from SMI.</li><li>For Reads, Align data to the initiator so that the critical byte will be received first. This will involve possible right rotation of the data from the response channel.</li></ol></td><td class="confluenceTd"><p><strong>Modifiable or </strong><strong>Non Modifiable or Exclusive</strong></p><ol><li><p>Use the same start address if not exclusive. If exclusive align address to burstSize at target.</p></li><li>Target will modify burstSize to match narrow bus.</li><li>For writes, data beats may have to be dropped to get data into the proper alignment.</li><li>For reads, padding may have to be added to the response to get the proper data alignment.<ol><li>The initiator is responsible for collecting enough narrow beats to create the full response.</li></ol></li></ol></td></tr><tr><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey">2</td><td class="highlight-grey confluenceTd" data-highlight-colour="grey"><strong>Incr - Unaligned</strong></td><td class="confluenceTd">Unchanged</td><td class="confluenceTd">Same as Above</td><td class="confluenceTd">Same as Above</td></tr><tr><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey">3</td><td class="highlight-grey confluenceTd" data-highlight-colour="grey"><strong>Incr - Narrow</strong></td><td class="confluenceTd"><p><strong>Modifiable</strong></p><ol><li>Use the same start address.</li><li>Target will modify burstSize to match target bus.</li><li>For Writes, Place incoming data beats into proper alignment on the data bus. This will involve possible left rotation of the data from SMI. Place BE=0 if extra padding needs to be used.</li><li>For Reads, Align data to the initiator so that the critical byte will be received first. This will involve possible right rotation of the data from the response channel.</li></ol><p><strong>Non Modifiable or Exclusive</strong></p><ol><li><p>Use the same start address if not exclusive. If exclusive align address to burstSize at target.</p></li><li>Target will leave burstSize unchanged.</li><li>For Writes, <span>the target will receive packed data. The target must unpack and p</span>lace incoming data beats into proper alignment on the data bus. This will involve possible left rotation of the data from SMI.</li><li>For Reads, Align data to the initiator so that the critical byte will be received first. This will involve possible right rotation of the data from the response channel.</li></ol></td><td class="confluenceTd"><p><strong>Modifiable</strong></p><ol><li>Use the same start address.</li><li>Target will modify burstSize to match target bus.</li><li>For writes, the target will receive packed data. The target must unpack and align the data same as above.</li><li>For reads, the target must pack the data and align it properly like above.<ol><li>The initiator will receive packed data and will unpack the data to complete the Narrow.</li></ol></li></ol><p><strong>Non Modifiable or Exclusive</strong></p><ol><li><p>Use the same start address if not exclusive. If exclusive align address to burstSize at target.</p></li><li>Target will leave burstSize unchanged.</li><li>For writes, the target will receive packed data. The target must unpack and align the data same as above.</li><li>For reads, the target must pack the data and align it properly like above.<ol><li>The initiator will receive packed data and will unpack the data to complete the Narrow.</li></ol></li></ol></td><td class="confluenceTd"><p><strong>Modifiable</strong></p><ol><li>Use same start address.</li><li>Target will modify burstSize to match narrow bus.</li><li>For writes, data beats may have to be dropped to get data into the proper alignment.</li><li>For reads, padding may have to be added to the response to get the proper data alignment.</li></ol><p><strong>Non Modifiable or Exclusive</strong></p><p><em>If burstSize &lt;= narrow bus</em></p><ol><li><p>Use the same start address if not exclusive. If exclusive align address to burstSize at target.</p></li><li>Target will leave burstSize unchanged.</li><li>For writes, the target will receive packed data. The target must unpack and align the data same as above.</li><li>For reads, the target must pack the data and align it properly like above.</li></ol><p><em>If burstSize &gt; narrow bus</em></p><ol><li><p>Use the same start address if not exclusive. If exclusive align address to burstSize at target.</p></li><li>Target will modify burstSize to match narrow bus.</li><li>For writes, data beats may have to be dropped to get data into the proper alignment.</li><li>For reads, padding may have to be added to the response to get the proper data alignment.</li></ol></td></tr><tr><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey">4</td><td class="highlight-grey confluenceTd" data-highlight-colour="grey"><strong>Fixed</strong></td><td class="confluenceTd">Unchanged</td><td class="confluenceTd"><p><strong>Modifiable or </strong><strong>Non Modifiable or Exclusive</strong></p><p>Will be split into single beat INCRs according to the table here:</p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16161575/HW-CTF+Common+Transaction+Layer+Microarchitecture+Specification#HW-CTFCommonTransactionLayerMicroarchitectureSpecification-TransactionBurstTypeandSplitting" data-linked-resource-id="16161575" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF Common Transaction Layer Microarchitecture Specification#TransactionBurstTypeandSplitting</a></p><p>That single beat INCR will continue with the rules above.</p></td><td class="confluenceTd"><p><strong>Modifiable or </strong><strong>Non Modifiable or Exclusive</strong></p><p>Will be split into single beat INCRs according to the table here:</p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16161575/HW-CTF+Common+Transaction+Layer+Microarchitecture+Specification#HW-CTFCommonTransactionLayerMicroarchitectureSpecification-TransactionBurstTypeandSplitting" data-linked-resource-id="16161575" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF Common Transaction Layer Microarchitecture Specification#TransactionBurstTypeandSplitting</a></p><p>That single beat INCR will continue with the rules above.</p></td></tr><tr><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey">5</td><td class="highlight-grey confluenceTd" data-highlight-colour="grey"><strong>Fixed - Unaligned</strong></td><td class="confluenceTd">Unchanged</td><td class="confluenceTd">Same as Above</td><td class="confluenceTd">Same as Above</td></tr><tr><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey">6</td><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey"><strong>Fixed - Narrow</strong></td><td colspan="1" class="confluenceTd">Unchanged</td><td colspan="1" class="confluenceTd">Same as Above</td><td colspan="1" class="confluenceTd"><p>Same as Above</p></td></tr><tr><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey">7</td><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey"><strong>Wrap</strong></td><td colspan="1" class="confluenceTd">Unchanged</td><td colspan="1" class="confluenceTd"><p><strong>Modifiable</strong></p><p><em>If Single Beat at Target:</em></p><ol><li>Transform address to align(address, len)</li><li>Transform transaction into an INCR at target</li><li>Transform burstSize to len.</li><li>For Writes, <span>Place incoming data beats into proper alignment on the data bus. This will involve possible left rotation of the data from SMI. </span></li><li>For Reads, Align data to the initiator so that the critical byte will be received first. This will involve possible right rotation of the data from the response channel .</li></ol><p><em>If Multiple Beats at Target:</em></p><p><em>For Writes:</em></p><ol><li>Use same start address if its aligned to target size, otherwise transform address to be aligned with the next beat of data. To do this follow the following steps:<br/><ol><li>align_address = align(address, target_width)</li><li>bit_boundary = log2(len)</li><li>final_address = align_address[bit_boundary-1:0] + target width.</li></ol></li><li>Transform burstSize to target width.</li><li>Target need to hold to a wide beat of data (for target alignment) and selects the bytes from held bytes and incoming beat for every outgoing beat to the slave. (Creating a left rotation)</li></ol><p>For Reads</p><ol><li>Use same start address (if aligned to target size), otherwise transform address to align(address, target width)</li><li>Transform burstSize to target width.</li><li>For Reads, Align data to the initiator so that the critical byte will be received first. This will involve possible storage and rotation right of the data from the response channel.</li></ol><p><strong>Non Modifiable or Exclusive</strong></p><p><em>If Multiple Beats at Target:</em></p><ol><li>Use same start address.</li><li>Target will leave burstSize unmodified.</li><li>For Writes, Target will receive packet data, and will have to unpack to create narrow write data.</li><li>For Reads, Pack and align data to the initiator so that the critical byte will be received first. This will involve possible storage and right rotation of the data from the response channel .</li></ol><p><strong><br/></strong></p></td><td colspan="1" class="confluenceTd"><p><strong>Modifiable or </strong><strong>Non Modifiable or Exclusive</strong></p><ol><li>Use same start address.</li><li>Target will modify burstSize to match narrow bus.</li><li>For writes, data is sent unmodified</li><li>For reads, data is sent back unmodified.</li></ol></td></tr><tr><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey">8</td><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey"><strong>Wrap - Unaligned</strong></td><td colspan="1" class="confluenceTd">NA</td><td colspan="1" class="confluenceTd"><p>NA</p></td><td colspan="1" class="confluenceTd"><p>NA</p></td></tr><tr><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey">9</td><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey"><strong>Wrap - Narrow</strong></td><td colspan="1" class="confluenceTd"><p>Unchanged</p></td><td colspan="1" class="confluenceTd"><p><strong>Modifiable</strong></p><p><em>If len &lt;= wide bus</em></p><p><u><span class="legacy-color-text-blue1">Modify to a single beat INCR</span></u></p><ol><li>Transform address to align(address, len).</li><li>Target will modify burstSize to len.</li><li>For writes, <span>Place incoming data beats into proper alignment on the data bus. This will involve possible left rotation of the data from SMI. </span></li><li>For reads, <span>Align data to the initiator so that the critical byte will be received first. This will involve possible right rotation of the data from the response channel .</span></li></ol><p><em>If len &gt; wide bus</em></p><p><em>For Writes:</em></p><ol><li>Use same start address if its aligned to target size, otherwise transform address to be aligned with the next beat of data. To do this follow the following steps:<br/><ol><li>align_address = align(address, target_width)</li><li>bit_boundary = log2(len)</li><li>final_address = align_address[bit_boundary-1:0] + target width.</li></ol></li><li>Transform burstSize to target width.</li><li>Target need to hold to a wide beat of data (for target alignment) and selects the bytes from held bytes and incoming beat for every outgoing beat to the slave. (Creating a left rotation)</li></ol><p>For Reads</p><ol><li>Use same start address (if aligned to target size), otherwise transform address to align(address, target width)</li><li>Transform burstSize to target width.</li><li>For Reads, Align data to the initiator so that the critical byte will be received first. This will involve possible storage and rotation right of the data from the response channel.</li></ol><p><strong>Non Modifiable or Exclusive</strong></p><ol><li>Use same start address.</li><li>Target will leave burstSize unchanged.</li><li>For writes, <span>Place incoming data beats into proper alignment on the data bus. This will involve possible left rotation of the data from SMI. </span></li><li>For reads, <span>Align data to the initiator so that the critical byte will be received first. This will involve possible right rotation of the data from the response channel .</span></li></ol></td><td colspan="1" class="confluenceTd"><p><strong>Modifiable</strong></p><p><em>If burstSize &lt;= narrow bus</em></p><ol><li><p><em>If len &gt; narrow bus</em></p><p><em>For Writes:</em></p><ol><li>Use same start address if its aligned to target size, otherwise transform address to be aligned with the next beat of data. To do this follow the following steps:<br/><ol><li>align_address = align(address, target_width)</li><li>bit_boundary = log2(len)</li><li>final_address = align_address[bit_boundary-1:0] + target width.</li></ol></li><li>Transform burstSize to target width.</li><li>Target need to hold to a wide beat of data (for target alignment) and selects the bytes from held bytes and incoming beat for every outgoing beat to the slave. (Creating a left rotation)</li></ol><p>For Reads</p><ol><li>Use same start address (if aligned to target size), otherwise transform address to align(address, target width)</li><li>Transform burstSize to target width.</li><li>For Reads, Align data to the initiator so that the critical byte will be received first. This will involve possible storage and rotation right of the data from the response channel.</li></ol></li><li><em>If len &lt;= narrow bus</em><ol><li>Transform address to align(address, len).</li><li>Target will modify burstSize to len.</li><li>Modyify to INCR</li><li>For writes, <span>Place incoming data beats into proper alignment on the data bus. This will involve possible left rotation of the data from SMI. </span></li><li>For reads, <span>Align data to the initiator so that the critical byte will be received first. This will involve possible right rotation of the data from the response channel .</span></li></ol></li></ol><p><em>If burstSize &gt; narrow bus</em></p><div><ol><li>Transform address to align(address, <em>narrow bus</em>).</li><li>Modify burstSize to match narrow bus.</li><li>For writes, data beats may have to be dropped to align first beat of data if address is unaligned.</li><li>For reads, <span>padding may have to be added to the response to get the proper data alignment. </span></li></ol><p><strong>Non Modifiable or Exclusive</strong></p><p><em>If burstSize &lt;= narrow bus</em></p><ol><li>Leave Address Unchanged</li><li>Target will leave burstSize unchanged.</li><li>For writes, data beats may have to be dropped to align first beat of data if address is unaligned to initiator width</li><li>For reads, <span>padding may have to be added to the response to get the proper data alignment.</span></li></ol><p><em>If burstSize &gt; narrow bus</em></p><ol><li>Transform address to align(address, <em>narrow bus</em>).</li><li>Modify burstSize to match narrow bus.</li><li>For writes, data beats may have to be dropped to align first beat of data if address is unaligned.</li><li>For reads, <span>padding may have to be added to the response to get the proper data alignment. </span></li></ol><p><br/></p></div></td></tr></tbody></table></div><h4 id="HW-CTFCommonLayerTransformations-Examples(Ifyoupreviewitinbrowserordownloadititisn&#39;tscrunchedup):">Examples (If you preview it in browser or download it it isn't scrunched up):</h4><h3 id="HW-CTFCommonLayerTransformations-250"><a href="/wiki/spaces/ENGR/pages/16161505/HW-CTF+Common+Layer+Transformations?preview=%2F16161505%2F16245129%2Ftransaction_transformation_presentation_wByte_5_18.pptx"><span style="background: url('/wiki/s/-672721829/6452/d621ad2a33e27b90ca05c475b216bfab745e08a2/1000.0.0-d621ad2a33e2/_/download/resources/com.atlassian.confluence.plugins.confluence-view-file-macro:view-file-macro-resources/images/placeholder-medium-presentation.png'); width: 333px; height: 95px; display: inline-block; padding-top: 155px; margin: 2px; border: 1px solid #ddd; text-align: center; vertical-align: text-bottom; text-decoration: none; font-size: 12px; color: #000;">transaction_transformati…</span></a></h3><p>Meeting Reviewing Examples:</p><p><a class="external-link" href="https://arteris-my.sharepoint.com/:v:/p/eric_taylor/ER9HYYj5x45HtIGymFG5tdMBjSBOImANWERqE7GSzFDTWg" rel="nofollow">https://arteris-my.sharepoint.com/:v:/p/eric_taylor/ER9HYYj5x45HtIGymFG5tdMBjSBOImANWERqE7GSzFDTWg</a></p><h3 id="HW-CTFCommonLayerTransformations-ReadInterleaving">Read Interleaving</h3><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th class="highlight-grey confluenceTh" colspan="4" data-highlight-colour="grey">Target Width Related to Initiator</th></tr></thead><tbody><tr><td class="highlight-grey confluenceTd" data-highlight-colour="grey"><br/></td><td class="highlight-grey confluenceTd" data-highlight-colour="grey"><strong>Same</strong></td><td class="highlight-grey confluenceTd" data-highlight-colour="grey"><strong>Wide</strong></td><td class="highlight-grey confluenceTd" data-highlight-colour="grey"><strong>Narrow</strong></td></tr><tr><td class="highlight-grey confluenceTd" data-highlight-colour="grey"><br/></td><td class="confluenceTd">Unchanged</td><td class="confluenceTd"><p>Unchanged</p></td><td class="confluenceTd"><p>The target will receive and send back data beats as normal.</p><p>The initiator will collect narrow beats until it can create a larger beat the width of its bus. This may cause the following symptoms on the Common Layer Interface depending on network behavior and where interleave beat ends:</p><ul style="list-style-type: square;"><li>Common Layer Responses to have no data associated with them. (Total data in packet less than data width)</li><li>Common Layer Responses from Target to be dropped entirely. <span>(Total data in packet less than data width)</span></li></ul></td></tr></tbody></table></div><h2 id="HW-CTFCommonLayerTransformations-MismatchinnarrowSupported">Mismatch in narrowSupported</h2><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh"><br/></th><th colspan="2" class="confluenceTh">Target</th></tr><tr><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey"><strong>Initiator </strong></td><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey">True</td><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey">False</td></tr><tr><td class="confluenceTd">True</td><td class="confluenceTd">No Special Behavior Needed</td><td class="confluenceTd"><p><strong>Writes</strong>:</p><p>The initiator will pack the incoming data and send packed narrow data to the target.</p><p>The target then will send an unmodified Address, and Length.</p><p>The target will send a modified burstSize equal to log2(wData) of that Common Layer interface.</p><p><strong>Reads:</strong></p><p>The initiator will send the transaction unmodified to the target.</p><p>The target then will send an unmodified Address, and Length.</p><p>The target will send a modified burstSize equal to log2(wData) of that Common Layer interface.</p><p>The target will receive the data and send it back packed. The initiator will then unpack the data to create a narrow response.</p></td></tr><tr><td class="confluenceTd">False</td><td class="confluenceTd"><span>No Special Behavior Needed</span></td><td class="confluenceTd"><span>No Special Behavior Needed</span></td></tr></tbody></table></div><h2 id="HW-CTFCommonLayerTransformations-MismatchinwrapSupported">Mismatch in wrapSupported</h2><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh"><br/></th><th colspan="2" class="confluenceTh">Target</th></tr><tr><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey"><strong>Initiator </strong></td><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey">True</td><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey">False</td></tr><tr><td class="confluenceTd">True</td><td class="confluenceTd"><span>No Special Behavior Needed</span></td><td class="confluenceTd"><p>This only applies to WRAP transactions,</p><p>The initiator will do one of two things depending on the Start Boundary of the Wrap:</p><p>Start Boundary == Address: The transaction will change to an incremental burst type with no other changes,</p><p>Start Boundary != Address: The transaction will be split into two transactions. The first being from the address to the end boundary, and the second from the start boundary to the address.</p><p>The target will process the increments as normal. If the target doesn't support increments The one or two transactions will be split into single beat transactions for the target.</p></td></tr><tr><td class="confluenceTd">False</td><td class="confluenceTd"><span>No Special Behavior Needed</span></td><td class="confluenceTd"><span>No Special Behavior Needed</span></td></tr></tbody></table></div><h2 id="HW-CTFCommonLayerTransformations-MismatchinincrSupported">Mismatch in incrSupported</h2><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh"><br/></th><th colspan="2" class="confluenceTh">Target</th></tr><tr><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey"><strong>Initiator </strong></td><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey">True</td><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey">False</td></tr><tr><td class="confluenceTd">True</td><td class="confluenceTd"><span>No Special Behavior Needed</span></td><td class="confluenceTd"><p>This only applies to INCR transactions,</p><p>The initiator will split the transaction into single beat transactions for the target.</p></td></tr><tr><td class="confluenceTd">False</td><td class="confluenceTd"><span>No Special Behavior Needed</span></td><td class="confluenceTd"><span>No Special Behavior Needed</span></td></tr></tbody></table></div><h2 id="HW-CTFCommonLayerTransformations-MismatchinfixedSupported">Mismatch in fixedSupported</h2><div class="table-wrap"><table class="wrapped confluenceTable"><tbody><tr><th class="confluenceTh"><br/></th><th colspan="2" class="confluenceTh">Target</th></tr><tr><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey"><strong>Initiator </strong></td><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey">True</td><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey">False</td></tr><tr><td class="confluenceTd">True</td><td class="confluenceTd"><span>No Special Behavior Needed</span></td><td class="confluenceTd"><p>This only applies to FIXED transactions,</p><p><span>The initiator will split the transaction into single beat transactions for the target.</span></p></td></tr><tr><td class="confluenceTd">False</td><td class="confluenceTd"><span>No Special Behavior Needed</span></td><td class="confluenceTd"><span>No Special Behavior Needed</span></td></tr></tbody></table></div><p><br/></p><div><h2 id="HW-CTFCommonLayerTransformations-MismatchinreadInterleaveSupported">Mismatch in readInterleaveSupported</h2><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh"><br/></th><th colspan="2" class="confluenceTh">Target</th></tr><tr><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey"><strong>Initiator </strong></td><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey">True</td><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey">False</td></tr><tr><td class="confluenceTd">True</td><td class="confluenceTd"><span>No Special Behavior Needed</span></td><td class="confluenceTd"><span>No Special Behavior Needed</span></td></tr><tr><td class="confluenceTd">False</td><td class="confluenceTd">The initiator must lock Channel ID and/or Ordering ID for a per target use. This will block any incoming transaction with a different Ordering ID and/or Ordering ID to a target.</td><td class="confluenceTd"><span>No Special Behavior Needed</span></td></tr></tbody></table></div><h2 id="HW-CTFCommonLayerTransformations-MismatchinatomicsSupported(P0:Exclusives)">Mismatch in atomicsSupported (P0: Exclusives)</h2><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh"><br/></th><th colspan="2" class="confluenceTh">Target</th></tr><tr><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey"><strong>Initiator </strong></td><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey">True</td><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey">False</td></tr><tr><td class="confluenceTd">True</td><td class="confluenceTd"><span>No Special Behavior Needed</span></td><td class="confluenceTd">The ATUt will implement a Exclusive Monitor to correctly implement the Architected Symphony exclusive behavior.</td></tr><tr><td class="confluenceTd">False</td><td class="confluenceTd"><span>No Special Behavior Needed</span></td><td class="confluenceTd"><span>No Special Behavior Needed</span></td></tr></tbody></table></div><h2 id="HW-CTFCommonLayerTransformations-MismatchinmaxPduSize">Mismatch in maxPduSize </h2><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh"><br/></th><th colspan="3" class="confluenceTh">Target</th></tr><tr><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey"><strong>Initiator </strong></td><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey">Smaller</td><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey">Same</td><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey">Larger</td></tr><tr><td class="confluenceTd">Exists</td><td class="confluenceTd">The transaction will be split according to the splitting rules defined in the <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16161575/HW-CTF+Common+Transaction+Layer+Microarchitecture+Specification" data-linked-resource-id="16161575" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF Common Transaction Layer Microarchitecture Specification</a></td><td class="confluenceTd"><span>No Special Behavior Needed</span></td><td colspan="1" class="confluenceTd"><span>No Special Behavior Needed</span></td></tr></tbody></table></div><h2 id="HW-CTFCommonLayerTransformations-MismatchinwOrderingId/wChannelID">Mismatch in wOrderingId/wChannelID</h2><p>If the specific widths of each of these signals mismatch ID compression will occur and guarantee below behavior. This section deals specifically the existence of ordering signals.</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh"><br/></th><th colspan="3" class="confluenceTh">Target</th></tr><tr><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey"><strong>Initiator</strong></td><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey">None</td><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey">Ordering ID</td><td class="highlight-grey confluenceTd" colspan="1" data-highlight-colour="grey">Channel ID and Ordering ID</td></tr><tr><td colspan="1" class="confluenceTd">None</td><td colspan="1" class="confluenceTd">No ordering changes are needed.</td><td colspan="1" class="confluenceTd"><p>There is no ordering guarantee at the initiator.</p><p>The transaction at the target will have a constant ordering id causing all transactions to be ordered out of the target interface.</p><p>The transaction responses must be seen in the correct order on the target interface.</p></td><td colspan="1" class="confluenceTd"><p>There is no ordering guarantee at the initiator.</p><p>The transaction at the target will have a constant Ordering ID and Channel ID causing all transactions to be ordered out of the target interface.</p><p>The transaction responses must be seen in the correct order on the target interface.</p></td></tr><tr><td class="confluenceTd">Ordering ID</td><td class="confluenceTd"><p>There will be an ordering guarantee at the initiator.</p><p>The target will only allow a single transaction be outstanding at any given time.</p></td><td class="confluenceTd"><p>No ordering changes are needed.</p></td><td colspan="1" class="confluenceTd"><p>There will be an ordering guarantee at the initiator.</p><p>The target will send the transactions as normal and give them all a constant Channel ID.</p></td></tr><tr><td class="confluenceTd">Channel ID and Ordering ID</td><td class="confluenceTd"><p>There will be an ordering guarantee at the initiator.</p><p>The target will only allow a single transaction be outstanding at any given time.</p></td><td class="confluenceTd"><p>There will be an ordering guarantee at the initiator.</p><p>The target will send transactions unmodified. This is a stricter ordering protocol than having both Ordering ID and Channel ID.</p><p>The target will store the Channel ID in context and return it with the response.</p></td><td colspan="1" class="confluenceTd">No ordering changes are needed.</td></tr></tbody></table></div><h1 id="HW-CTFCommonLayerTransformations-AppendixA.NarrowRealignmentExample"><br/>Appendix A. Narrow Realignment Example</h1><p><br/></p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image confluence-external-resource" width="1200" src="https://confluence.arteris.com/download/attachments/11699744/image2019-4-18%2016%3A56%3A47.png?version=1&amp;modificationDate=1555630942672&amp;api=v2" data-image-src="https://confluence.arteris.com/download/attachments/11699744/image2019-4-18%2016%3A56%3A47.png?version=1&amp;modificationDate=1555630942672&amp;api=v2" loading="lazy"></span></p><p><br/></p><p><br/></p></div><div><strong><br/></strong></div>