<h1 id="HW-CTFpmon_probe-module_name">module_name</h1><p>pmon_probe (or Link Probe)</p><h2 id="HW-CTFpmon_probe-JavaScriptparameters">JavaScript parameters</h2><p><strong><em>nodeId</em></strong>: A non-negative integer,</p><p><strong><em>evtDefines</em></strong>: An array of objects. Each object defines an internal/local event that can used to drive an output event, another local event, or an interrupt. In order to drive an output event, the <em>outEvt</em> field of an event must match the name of one of the events in <em>evtInterfaces</em>. The structure of such an object is defined below:<br/>{<br/><em>name</em> : A string that specifies the name of the output event.<br/><em>width</em> : A positive integer that specifies the width of the event.<br/><em>interrupt</em> : A Boolean true or false. True means this event should trigger interrupt.<br/><em>description</em>: A string describing the event. This is passed to interrupt block if marked interrupt.<br/><em>outEvt </em>: A string that matches the name of one of the event names on the <em>evtInterfaces</em>. If not defined or empty-string, this event will remain internal to the block and doesn't go out as an output of the probe block. <br/><em>conditions</em> : An array of strings each of which is expected to be a syntactically correct Verilog expression. The names of signals should match either on of the following:</p><ol><li>The names of other events described in the <em>evtDefines</em> data-structure. </li><li>The names of a user-defined register fields described in the <em>regFieldDefines</em> data-structure.</li><li>The names of one of the packet fields specified in <em>fieldArray</em> array parameter.</li></ol><p>}</p><p><strong><em>fieldArray</em></strong>: Array of strings that matches the names of packet fields in the link packet definition of the ATP link on which the probe sits. Ex: [&quot;H_msg_id&quot;, &quot;H_msg_type&quot;, &quot;F_data&quot;].</p><p><strong><em>regFieldDefines</em></strong>: An array of objects each of which describes a user-defined register field. The structure of such an object is defined below:<br/>{<br/><em>  name</em> : A string that specifies the name of the internal event. This needs to match the name of the signal as used in the Verilog expressions in the <em>conditions</em> array in <em>evtDefines</em>.<br/>  <em>width</em> : A positive integer that specifies the width of the field.<br/>  <em>access</em> : A string that can take one of the following values - &quot;RW&quot;, &quot;RO&quot;.<br/><em>  description</em>: A string describing the register field.<br/>}</p><p><strong><em>protectionStyle</em></strong>: <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16169044/protectionStyle" data-linked-resource-id="16169044" data-linked-resource-version="15" data-linked-resource-type="page">protectionStyle</a></p><h2 id="HW-CTFpmon_probe-Interfaces">Interfaces</h2><p><em>clkInterface</em>: A slave interface of type <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168894/InterfaceCLK" data-linked-resource-id="16168894" data-linked-resource-version="5" data-linked-resource-type="page">InterfaceCLK</a>.</p><p><em>inInterface</em>: A slave interface of type <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16164453/HW-SYM+InterfaceATP" data-linked-resource-id="16164453" data-linked-resource-version="12" data-linked-resource-type="page">HW-SYM InterfaceATP</a>. This defines the ingress ATP interface.</p><p><em>outInterface</em>: A master interface of type <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16164453/HW-SYM+InterfaceATP" data-linked-resource-id="16164453" data-linked-resource-version="12" data-linked-resource-type="page">HW-SYM InterfaceATP</a>. This defines the egress ATP interface.</p><p><em>cfgInterface</em>: A slave interface of type <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168579/InterfaceAPB" data-linked-resource-id="16168579" data-linked-resource-version="2" data-linked-resource-type="page">InterfaceAPB</a>. This interface is used to program the probe registers.</p><p><em>evtInterfaces</em>: An array of master interfaces of type <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16169167/InterfaceEvt" data-linked-resource-id="16169167" data-linked-resource-version="7" data-linked-resource-type="page">InterfaceEvt</a>.</p><p><em>protInterface</em>: (Optional interface. Not in Presto 1.0). A master interface of type <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168667/InterfacePROT" data-linked-resource-id="16168667" data-linked-resource-version="16" data-linked-resource-type="page">InterfacePROT</a>.</p><p><em>intInterface</em>: A master interface of type <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16160508/InterfaceINT" data-linked-resource-id="16160508" data-linked-resource-version="3" data-linked-resource-type="page">InterfaceINT</a>.</p><p>traceInterfaces: (Optional interface for future use. Not in Presto 1.0) An array of master interfaces of type InterfaceTrace. </p><h2 id="HW-CTFpmon_probe-ModulesUsed">Modules Used</h2><p><strong><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16157292/HW-CTF+sym_atp_depack" data-linked-resource-id="16157292" data-linked-resource-version="1" data-linked-resource-type="page">HW-CTF sym_atp_depack</a></strong></p><p><strong><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16160014/HW-CTF+sym_apb_csr" data-linked-resource-id="16160014" data-linked-resource-version="74" data-linked-resource-type="page">HW-CTF sym_apb_csr</a></strong></p><h2 id="HW-CTFpmon_probe-BlockDescription">Block Description</h2><p>The link probe or the pmon_probe block listens to packets on an ATP link. It can be configured to read specific fields in packets which can then be used in Verilog expressions that are used to generate conditional events. The block also has the ability to generate user-defined programmable register fields which can also be used in such Verilog expressions. Below block-diagram shows the key sub-blocks inside the link probe:</p><p><br/></p><p><span class="confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image image-center" height="250" src="https://arterisip.atlassian.net/wiki/download/attachments/16163549/image2019-12-5%2012:49:43.png?api=v2"></span></p><p><br/></p><p>The Link Probe consists of the following logic blocks or regions:</p><ol><li><strong><em>Depacketizer</em></strong>: This block receives packets transmitted on the ATP link and asserts valid whenever it has captured all the relevant packet fields (specified through the JSON param ‘<em>fieldArray</em>’), which are used to generate conditional events.</li><li><strong><em>Conditional event generation</em></strong>: This generates conditional events according to expressions/conditions specified in the <em>evtDefines</em> data-structure parameter. It also uses the select values in PMON_PROBE_COND_<em>eventName</em> registers to select one of multiple possible conditions for generating that event. </li><li><strong><em>APB CSR</em></strong>: This implements a set of configuration registers that stores compare values to compare with packet fields from depacketizer, and a set of select values to choose among different possible conditions for each event. The CSR structure for this block is generated, based on <em>evtDefines</em> and <em>regFieldDefines</em> parameters during configuration time.</li><li><strong><em>Reference event generation</em></strong>: This block generates some reference events using <em>valid</em>, <em>ready</em>, <em>first</em>, and <em>last</em> signals of the ATP interface, such as:<br/>1. <em>beat_sent</em> – An event that is triggered for every beat sent on the <em>evtInterfaces<br/></em>2. <em>pkt_start</em> – An event that is triggered for every first beat of a packet that is sent on the <em>evtInterfaces</em>.<br/>3. <em>pkt_end</em> – An event that is triggered for every last beat of a packet that is sent on the <em>evtInterfaces</em>.</li></ol><p><br/></p><h2 id="HW-CTFpmon_probe-VCHandling">VC Handling</h2><p>The pmon_probe can have multi-VC ATP interfaces. The recommended way to use a pmon_probe block in a multi-VC ATP network is to add one or more programmable registers in the regFieldDefines data-structure that the user can write VC numbers into. Events defined in evtDefines can then be qualified based on the VC of interest.</p><h2 id="HW-CTFpmon_probe-RegisterDescriptions">Register Descriptions</h2><p>The number of registers the probe block will have depends on the parameters <em>evtDefines</em> and <em>regFieldDefines</em>. The exact number of registers generated can be calculated this way:</p><p>Number of select registers = if (ceil(log2(<em>evtDefines</em>[ i ].conditions.length)) &gt; 0) else 0, for i from 0 to number of events in evtDefines-1<br/>Number of user-defined registers = <em>regFieldDefines</em>.length;<br/>Number of global registers = 1.</p><p>Total Number of registers = global registers + user-defined registers + select registers.</p><h4 id="HW-CTFpmon_probe-1.1.1PMON_PROBE_SEL_eventName">1.1.1      PMON_PROBE_SEL_<em>eventName</em></h4><p>An instance of this register exists for each event in the <em>evtDefines</em> structure, as long as the number of entries in the <em>conditions</em> array for that event is greater than 1.</p><p><br/></p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/><col/></colgroup><tbody><tr><td class="confluenceTd"><p>Field</p></td><td class="confluenceTd"><p>Bits</p></td><td class="confluenceTd"><p>RW</p></td><td class="confluenceTd"><p>Parameterized</p></td><td class="confluenceTd"><p>Description</p></td></tr><tr><td class="confluenceTd"><p>sel</p></td><td class="confluenceTd"><p>Log<sub>2</sub>(No. of conditions to select from to generate the conditional event)</p><p align="center"><br/></p></td><td class="confluenceTd"><p>RW</p></td><td class="confluenceTd"><p>Yes</p></td><td class="confluenceTd"><p>Select value to select condition for event N</p></td></tr></tbody></table></div><p><br/></p><h4 id="HW-CTFpmon_probe-1.1.2PMON_PROBE_USER_N(N=0,1,2,…)">1.1.2      PMON_PROBE_USER_<em>N</em> (N = 0,1, 2, …)</h4><p>These registers are generated to hold register-fields defined in the <em>regFieldDefines</em> data-structure. Currently a separate register is generated for each register field in the <em>regFieldDefines</em> data-structure. However, this might change in future to optimize utilization of an address space.</p><p><br/></p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/><col/></colgroup><tbody><tr><td class="confluenceTd"><p>Field</p></td><td class="confluenceTd"><p>Bits</p></td><td class="confluenceTd"><p>RW</p></td><td class="confluenceTd"><p>Parameterized</p></td><td class="confluenceTd"><p>Description</p></td></tr><tr><td class="confluenceTd"><p style="text-align: left;" align="center">Matches the name of field in <em>regFieldDefines</em></p></td><td class="confluenceTd"><p style="text-align: left;">Matches the width of field in <em>regFieldDefines</em></p></td><td class="confluenceTd"><p>RW</p></td><td class="confluenceTd"><p>Yes</p></td><td class="confluenceTd"><p>Used to generate conditional events according to user-specified conditions</p></td></tr></tbody></table></div><p><br/></p><p><br/></p>