<p><span class="legacy-color-text-blue3">This are a library of JS classes all of which can be found in the following path:</span><br/><strong>hw-lib/js/lib_utils.js</strong></p><p>This library implements the proposal mentioned here : <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16161450/Generating+Verilog+expressions+in+TACHL+Proposal" data-linked-resource-id="16161450" data-linked-resource-version="15" data-linked-resource-type="page">Generating Verilog expressions in TACHL (Proposal)</a>. This library is meant to be used within TACHL code. An object oriented approach is followed to define Verilog signals, literals, and data-structures, on which operations can be performed to generate Verilog expressions.</p><h2 id="Verilogexpressiongenerator-Presentationslides">Presentation slides</h2><p><br/></p><p><a href="/wiki/spaces/ENGR/pages/16160940/Verilog+expression+generator?preview=%2F16160940%2F16320947%2FVerilog_expression_generator.pptx"><span style="background: url('/wiki/s/-672721829/6452/d621ad2a33e27b90ca05c475b216bfab745e08a2/1000.0.0-d621ad2a33e2/_/download/resources/com.atlassian.confluence.plugins.confluence-view-file-macro:view-file-macro-resources/images/placeholder-medium-presentation.png'); width: 333px; height: 95px; display: inline-block; padding-top: 155px; margin: 2px; border: 1px solid #ddd; text-align: center; vertical-align: text-bottom; text-decoration: none; font-size: 12px; color: #000;">Verilog_expression_gener…</span></a></p><h2 id="Verilogexpressiongenerator-Motivation">Motivation</h2><p>There is a frequent need in TACHL code to perform common operations on Verilog expressions such as slicing signals (bit-slice), concatenating, padding, truncating etc.</p><p>One solution designers use to solve such problems is simple JS string concatenation. For example if we wanted to slice a signalA and extract bits from indexHi downto indexLo, we would do:</p><p>signalA+&quot;[&quot; + indexHi +&quot;:&quot; + indexLo +&quot;]&quot;  (JS) OR</p><p>\=signalA=\ [  \=indexHi=\ : \=indexLo=\ ]  (TACHL)</p><p>This is often accompanied by additional if-else conditions to check if the two-indices (indexHi, indexLo) are equal or if signalA is declared as a single wire or a bit-vector. This leads to duplication and boiler-plating of code that has little to do with the main code and hence must be abstracted into separate functions. In addition we would like to perform subsequent operations on the resulting expression, such as padding zeros. Simple string concatenation then makes the code even less readable:</p><p>if ( padlength === 0 ) {  \jsend<br/>   assign result        =  \=signalA=\ [  \=indexHi=\ : \=indexLo=\ ]; \jsbegin<br/>} else { \jsend<br/>   assign result        =  { \=padlength=\'d0, \=signalA=\ [  \=indexHi=\ : \=indexLo=\ ] }; \jsbegin<br/>}</p><p>As can be seen above, with more operations the code becomes harder to read, and adds more lines of code to check for particular conditions while performing the operations, all of which could be separated from the core concern describing the block design. Simple functions that return concatenated strings are also limited since some information is lost such as the width, which prevents further operations on the result.</p><p>To solve such problems we need to define signals and expressions as objects composed of not only strings, but also width, and other parameters, which can be used to perform successive operations and checking each result.</p><h2 id="Verilogexpressiongenerator-Description">Description</h2><p>The library is built out of a set of factory functions and some helper functions, all of which can be accessed by calling the <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16162250/vlogGen" data-linked-resource-id="16162250" data-linked-resource-version="2" data-linked-resource-type="page">vlogGen</a>( ) function. Some of the factory functions return objects that are an extension of objects returned by other factory functions hence implementing inheritance ( but in a functional way ). Hence there exists a hierarchy of vlog* types with <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16161725/vlogExpr" data-linked-resource-id="16161725" data-linked-resource-version="2" data-linked-resource-type="page">vlogExpr</a> (Verilog expression) at the top and almost all other factory functions creating objects that are an extension of <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16161725/vlogExpr" data-linked-resource-id="16161725" data-linked-resource-version="2" data-linked-resource-type="page">vlogExpr</a> objects.</p><p>The library consists of the following class libraries (click link for detailed definition):</p><ol><li><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16161725/vlogExpr" data-linked-resource-id="16161725" data-linked-resource-version="2" data-linked-resource-type="page">vlogExpr</a> (not user-accessible)</li><li><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16162454/vlogSignal" data-linked-resource-id="16162454" data-linked-resource-version="7" data-linked-resource-type="page">vlogSignal</a></li><li><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16162240/vlogArray" data-linked-resource-id="16162240" data-linked-resource-version="1" data-linked-resource-type="page">vlogArray</a></li><li><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16162490/vlogPkdArray" data-linked-resource-id="16162490" data-linked-resource-version="2" data-linked-resource-type="page">vlogPkdArray</a></li><li><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16162515/vlogPkdStruct" data-linked-resource-id="16162515" data-linked-resource-version="5" data-linked-resource-type="page">vlogPkdStruct</a></li></ol><p>And a set of helper functions described here: <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16162213/vlogHelper" data-linked-resource-id="16162213" data-linked-resource-version="2" data-linked-resource-type="page">vlogHelper</a>. Refer the slides for more details on the hierarchy and for the UML diagram.</p><h3 id="Verilogexpressiongenerator-Functioncallchaining">Function call chaining</h3><p>Most methods and operations in the above classes return instances of vlogExpr or vlogSignal, instead of returning plain strings. This allows for easy way to chain function calls, instead of nesting function calls, in the spirit of JS. This improves readability and the ability to express successive Verilog operations on signals.</p><p>For example:</p><p>const myWord                 = vlogSignal ( 16, &quot;word&quot; );                 // This returns an instance of vlogSignal<br/>const myExpr                   = myWord.upper( 8 ).replicate( 2 ).pad0( 16 )  // This results in an instance of VlogExpr with an expression string &quot;{ 16'd0, { 2 { word[ 15: 7 ] } } }&quot;</p><h3 id="Verilogexpressiongenerator-Sizeofconstants">Size of constants</h3><p>The objects created using the vlogConst( ) factory can hold values greater than the size of a typical integer. This is because the value associated with the constants is stored internally as JavaScript BigInts. So the size of value is only limited by the width of the constant which is a regular JS number. This means the max width is 2^31 - 1 and the max value is 2^(2^31 - 1).</p><h3 id="Verilogexpressiongenerator-In-lineTACHLprint">In-line TACHL print</h3><p>Every instance of each of the above classes also has access to JS <em>Object</em> because of prototype object-linking. The JS <em>Object</em> has a default <em>toString</em>( ) method that returns a string each time an JS object is used in a string context.</p><p>The <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16161725/vlogExpr" data-linked-resource-id="16161725" data-linked-resource-version="2" data-linked-resource-type="page">vlogExpr</a> objects override the default <em>toString( )</em> method so as to return the expression string instead. Since all other classes inherit from this class, instances of any of the above classes can be used within the \= and =\ of TACHL code to just print their expressions:</p><p>Example:<br/>const mySignal                = vlogSignal ( 16, &quot;word&quot; );                 // This returns an instance of vlogSignal<br/>const myExpr                   = mySignal.upper(8).replicate(2);       // This returns an instance of vlogExpr</p><p>\jsend<br/>assign bus[15:0]               = \=myExpr=\;        // Prints the expression string computed by myExpr, even though myExpr itself is not a string</p><p>On TACHL compile the above line appears in the generated Verilog code as:  <br/>assign bus[15:0]        =  { 2 { word[7:0] } };<br/><br/></p><p>Even though myExpr is not a string, the <em>toString( )</em> method returns the computed expression string and hence results in the above line.</p><h3 id="Verilogexpressiongenerator-Widthofexpressions">Width of expressions</h3><p>Even though Verilog permits operands of different width in an expression, the expression generator library is much stricter and only allows operations between equal-sized operands. This avoids any lint errors due to width-mismatches. The width of the result of unary and bitwise-binary logical operations are the same as those of their operands. For shift operations the resulting width is determined by the extendWidth parameter.</p><h3 id="Verilogexpressiongenerator-Packedstructures">Packed structures</h3><p>The <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16162515/vlogPkdStruct" data-linked-resource-id="16162515" data-linked-resource-version="5" data-linked-resource-type="page">vlogPkdStruct</a> and <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16162490/vlogPkdArray" data-linked-resource-id="16162490" data-linked-resource-version="2" data-linked-resource-type="page">vlogPkdArray</a> objects can be used to represent packed structures ( akin to System Verilog packed struct and packed array ). A packed structure can be accessed and operated upon as a single Verilog signal, but allows accessing bit-slices of it using array-indexing (packed arrays) or by member name (packed struct). They also support complex or composite data-structures  - array of structs, struct of arrays, array of struct of arrays and so on.</p><h3 id="Verilogexpressiongenerator-VlogBundle">VlogBundle</h3><p>The VlogBundle refers to a type of object (an associate array) in which each value is an instance of one of the user-accessible classes described above. This allows a convenient way to group instances of different types and access them via a key or name string. This isn't a class by itself.</p><p>For example, local wires used in a TACHL component can be grouped into a VlogBundle as below:</p><p>\jsbegin<br/>const local   = {<br/>   const  register                     : vlogSignal ( 32, &quot;reg&quot; );<br/>   const  fifoWData                 : vlogPkdStruct ( &quot;wdata&quot;, [{ name: &quot;bus&quot;, width: 40}, { name: &quot;first&quot;, width: 1 }], <br/>   ...<br/>} \jsend<br/>\=local.fifoWData.idx(&quot;bus&quot;)=\        // Prints wdata [ 40 : 1 ] <br/><br/></p><p>The <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16158757/declareVlogBundle" data-linked-resource-id="16158757" data-linked-resource-version="1" data-linked-resource-type="page">declareVlogBundle</a> function provides an easy way to declare all the instance objects in a VlogBundle. The function simply calls the declare( ) method of each instance in the bundle, exploiting polymorphism to generate the appropriate Verilog declaration for each instance. We could also convert block interfaces into a VlogBundle so that signals in the interfaces have access to all the methods of a VlogSignal class. Refer <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16158130/getVlogBundle" data-linked-resource-id="16158130" data-linked-resource-version="5" data-linked-resource-type="page">getVlogBundle</a> for examples and details.</p><h2 id="Verilogexpressiongenerator-Usageguidelines">Usage guidelines</h2><p>This section describes how to work with the Verilog expression generator libraries in TACHL code.</p><h4 id="Verilogexpressiongenerator-Creatinglocalsignals">Creating local signals</h4><p>It is recommended that the signals inside a module that one wishes to represent as vlog* objects, and that need to be declared, be listed inside a vlogBundle as below:</p><p>const local = {                                       // local is a vlogBundle object</p><p>  wData:  vlogSignal ( 32, &quot;wdata&quot; ),<br/>  rData:   vlogSignal ( 64, &quot;rdata&quot; ),<br/>  bus:      vlogPkdArray ( { width: 8, length: 4 }, &quot;bus&quot; ),</p><p>   .<br/>   .<br/>   .</p><p>}</p><p>The individual signals can now be referenced as <em>local.wData</em>, <em>local.rData</em>, <em>local.bus</em> and so on. Clubbing them into a single bundle results in a single place for specifying all the signal names in the generated code. It also allows easy declaration of all the signals using the declareVlogBundle( ) function:</p><p>\=vlogGen.declareVlogBundle( { type: &quot;wire&quot;, tabs: 1 }, local )=\   // Prints Verilog declarations of all objects in the &quot;local&quot; vlogBundle.</p><p><br/></p><h4 id="Verilogexpressiongenerator-ConvertingI/OsignalstovlogSignalobjects">Converting I/O signals to vlogSignal objects</h4><p>It is possible to convert an entire TACHL interface to a vlogBundle of vlogSignal objects using the getVlogBundle( ) function returned by vlogGen( ). Remember that getVlogBundle( ) function expects old-style interfaces. A new-style interface can be converted to old-style using the getSignalsBundle( ) function. Below is an example of converting an ATP interface from new style to old-style and finally to a vlogBundle.<br/><br/>const vlogGen        = obj.userLib.vlogGen( );<br/>const vlogSignal    = vlogGen.vlogSignal;<br/><br/></p><p>const atpInst          = new obj.userLib[&quot;InterfaceATP&quot;]; // Assume interfaceNewABC is of type &quot;InterfaceATP&quot;.<br/>const interfaceABC = { name: interfaceABC.name, signals: atpInst.getSignalsBundle( interfaceNewABC.params )  }; // interfaceABC is now an old-style interface.<br/>const atpABC          = vlogGen.getVlogBundle( interfaceABC ); // This converts interfaceABC to a vlogBundle called atpABC</p><p>Assume interfaceABC results in <br/>{ name: &quot;atp_&quot;, signals: { valid: 1, ready: -1, bus: 16, first: 1, last: 1 } }; </p><p>Now signals inside the interfaceABC can be accessed as below: </p><p>\=atpABC.valid=\             // Prints &quot;atp_valid&quot;<br/>\=atpABC.bus.msb( )=\    // Prints &quot;atp_bus[31]&quot;</p><p>The getVlogBundle( ) function converts each signal in an interface to a vlogSignal object only. Suppose we instead wanted to represent one of the signals, say &quot;bus&quot;, as a vlogPkdArray instead, then we could call the toPkdArray( ) method to convert it into a packed structure as below:</p><p>const busPkd    = atpABC.bus.toPkdArray({ width: 8, length: 4 }); \jsend<br/>\=busPkd.idx(3)=\  // Prints &quot;atp_bus[ 31 : 24 ]<br/>\=busPkd.idx(1)=\  // Prints &quot;atp_bus[ 15 : 8  ]</p><p><br/>OR the busPkd could be converted into a simple JS array instead:<br/>const busChunks = range( busPkd.length ).map( i =&gt; busPkd.idx(i) ); \jsend<br/>\=busChunks[3]=\   // Prints &quot;atp_bus[ 31 : 24 ]<br/>\=busChunks[2]=\   // Prints &quot;atp_bus[ 23 : 16 ]</p><p><br/></p><h4 id="Verilogexpressiongenerator-Creatingconstants">Creating constants</h4><p>Since constants need not be declared, they can simply be created on the fly:</p><p>const wID       = 4;  // Width of ID<br/>const nodeID = 6; \jsend<br/>assign id_in    = \=vlogConst(wID, 6)=\;  // This prints &quot;assign id_in = 4'd6; \jsbegin<br/><br/></p><p>Radix can be specified as an optional parameter:<br/>const mask            = 0xc5; \jsend<br/>assign out_data     = in_data &amp; \=vlogConst(8, mask, { radix: 16 })=\;  // This prints &quot; assign out_data = in_data &amp; 8'hc5;<br/><br/>Suppose out_data, and in_data were 128-bit wide and we wish to mask the lower half of in_data. A JavaScript variable doesn't allow storage of whole numbers greater than 31-bit wide without loss of precision. So in order to specify integers greater than that, we need to use BigInts:</p><p>const mask            = 0xffffffffffffffff0000000000000000n; // The n at the end implies that the type if 'bigInt' \jsend<br/>assign out_data     = in_data &amp; \=vlogConst(128, mask, { radix: 16 }); // This prints &quot; assign out_data = in_data &amp; 128'hffffffffffffffff0000000000000000;</p><p><br/></p><h4 id="Verilogexpressiongenerator-Signalsliceoperations">Signal slice operations</h4><p>For slice operations, favor the slicer( ) method over slice( ) method. This is because there are functions in Symphony that return start and end indices within a single object ( <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16155846/class+Slice" data-linked-resource-id="16155846" data-linked-resource-version="7" data-linked-resource-type="page">class Slice</a> ), that can be passed directly to the slicer( ) method. In addition if the signal on which slicer( ) is applied is a result of a previous slice operation, then the slicer( ) method automatically interprets the start and end offsets of the slice as relative to the end offset of the signal.</p><p><br/></p><h4 id="Verilogexpressiongenerator-Workingwithoperators">Working with operators</h4><h5 id="Verilogexpressiongenerator-Example1:CreatinganN:1muxofwidthW">Example 1: Creating an N:1 mux of width W</h5><p>const vlogGen        = obj.userLib.vlogGen( );<br/>const vlogSignal     = vlogGen.vlogSignal;<br/>const vlogArray      = vlogGen.vlogArray;<br/>const vlogHelper    = vlogGen.vlogHelper;</p><p>const local = {</p><p>  sel:          vlogSignal ( log2ceil(N), &quot;sel&quot;),  // Binary-encoded select signal<br/>  s:             vlogSignal ( N, &quot;s&quot;),                   // One-hot encoded signal<br/>  outData:  vlogSignal ( W, &quot;out_data&quot; ),<br/>  inData: vlogArray ( { width: W, length: N }, &quot;in_data&quot; )</p><p>};</p><p><br/>\=declareVlogBundle({ tabs: 2}, local)=\;  // Declare all local signals<br/><br/>// Convert binary-encoded select to one-hot signal<br/>\=vlogHelper.bin2OneHot( local.sel, N ).assign( local.s )=\                    // Prints &quot;assign s     = { sel == 2'd2, sel == 2'd1, sel == 2'd0 };&quot; for N=3 \jsbegin<br/><br/>const minterms    = [ ];</p><p>for ( let i=0; i &lt; N; i++ ) {<br/>    const mask            = s.bit( i ).replicate( W );<br/>    minterms.push( local.inData.idx( i ).bitwise(&quot;&amp;&quot;, mask)  );<br/>}<br/><br/>const rhs = vlogHelper.bitwise( &quot;|&quot;, minterms ); \jsend<br/>\=rhs.assign( local.outData )=\                                                     // Prints &quot;assign out_data    = ({8{s[0]}} &amp; in_data_0) | ({8{s[1]}} &amp; in_data_1) | ({8{s[2]}} &amp; in_data_2);&quot; for N=3, W = 8</p><p><br/></p><h2 id="Verilogexpressiongenerator-Tests">Tests</h2><p>A set of tests are written to help verify that any changes made to the libraries do not break existing features. The tests can be found in the following path and file:</p><p>hw-lib/js/test_vlogGen.js</p><p>To run the above test, use the following command in the above directory:</p><p>./test_vlogGen.js<br/><br/>All tests are directed tests and must pass before any changes are pushed in.</p><p><br/></p><p><br/></p><p><br/></p><p><br/></p><p><br/></p><p><br/></p><p><br/></p>