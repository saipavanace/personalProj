<p><a class="confluence-userlink user-mention" data-account-id="624b374545ece00069cca858" href="https://arterisip.atlassian.net/wiki/people/624b374545ece00069cca858?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">Ben Chen (Deactivated)</a> , <a class="confluence-userlink user-mention" data-account-id="624b3780f6a26900695fd12f" href="https://arterisip.atlassian.net/wiki/people/624b3780f6a26900695fd12f?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">Roger Jennings (Deactivated)</a> , <a class="confluence-userlink user-mention" data-account-id="624b3804f813eb00692cb21e" href="https://arterisip.atlassian.net/wiki/people/624b3804f813eb00692cb21e?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">Junie Um (Deactivated)</a> , <a class="confluence-userlink user-mention" data-account-id="624b37684fe01d006ba96e15" href="https://arterisip.atlassian.net/wiki/people/624b37684fe01d006ba96e15?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">Michael Frank (Deactivated)</a> :</p><p><span style="color: inherit;">Below is the followup from our call</span>.</p><h2 id="MaestroQoSsupport-GeneralMaestroSupportForQoS"><strong>General Maestro Support For QoS</strong></h2><ul><li>Going forward, we will try to harmonize Symphony and Ncore QoS support.</li><li>As a general intent, Symphony and Ncore will both try to support &quot;<em><strong>managed QoS</strong></em>&quot;, i.e. the ability - at chip runtime - to program QoS objectives in architecture registers. The hardware will then monitor the actual achieved performance and adjust knobs according to this feedback. This type of QoS provisioning requires relatively little Maestro support because much of it is done dynamically.</li><li>However, Symphony will also need to provide an &quot;<em><strong>unmanaged QoS</strong>&quot;</em> mode where the QoS provisioning is done entirely at chip design time, i.e. via Maestro. In this case, the provisioning is purely a feed-forward mechanism, and the hardware does not self-monitor. This mode will be able to save quite a bit of logic, so it is expected to be desirable for customers in certain segments, like IoT, or for systems that have clearly defined and maybe static workloads. <em><strong>This mode will be the only supported one for Symphony 1.0, thus it is our first implementation priority</strong></em>.<ul><li>The fact that the design is feed-forward makes it difficult to choose good parameters for many of the architectural knobs. For example, making switches use fixed-priority arbitration with uncertain workloads can run into risks of unfairness or even starvation. In this example, hardcoding round-robin arbitration is probably the safest choice.</li><li>We will need to revisit the role of Maestro when we will get to VC instantiation and allocation. This problem is deferred to a later release. </li></ul></li><li>The Ncore architecture documents (Sharepoint or Teams → Architecture → Documents → General, this should be the latest copy: <a class="external-link" href="https://arteris.sharepoint.com/:b:/s/Architecture/EYDETNq14oJAtwCzWsflJ4wBuXAw6wpjpomAUS7pNsMKIw?e=dcvesL" rel="nofollow">https://arteris.sharepoint.com/:b:/s/Architecture/EYDETNq14oJAtwCzWsflJ4wBuXAw6wpjpomAUS7pNsMKIw?e=dcvesL</a>) defines the register interface to specify managed-QoS requirements. It is decided that Maestro will try to provide a similar interface for the specification of unmanaged QoS as well, of course with appropriate changes:<ul><li>For example, the managed-QoS mechanism can just reprogram all registers at chip runtime if the workload changes. In an unmanaged-QoS design, if there are different workload scenarios, Maestro needs to allow the user to enter those scenarios (&quot;<em><strong>use cases</strong></em>&quot;) upfront and explicitly.</li></ul></li></ul><h2 id="MaestroQoSsupport-BaselineMaestroTasks"><strong>Baseline Maestro Tasks</strong></h2><ul><li>Data model<ul><li>Allow the notion of managed- vs. unmanaged-mode QoS, for now only under the hood. <strong>Agile XS</strong></li><li>Allow the definition of use cases. <strong>Agile S</strong></li><li>Allow the entry of QoS requirements for each use case. (This is to some extent already possible, flattened into a single UC; but need to realign to Ncore entry specifications, and migrate any outstanding unit tests + DV tests). <strong>Agile S/M</strong></li><li>Add visibility of ATU rate limiter. <strong>Agile S</strong></li><li>Add visibility/understanding of pipelining options, especially at ATUs. <strong>Agile M</strong></li><li>Add a LatencyAnnotation to blocks. <strong>Agile S</strong></li></ul></li><li>GUI/TCL<ul><li>Provide a use case editor, with a tabbed interface. <strong>Agile L</strong> but with upwards uncertainty depending on features (e.g. just tabular view vs. connectivity table or both; actions like &quot;copy from use case&quot;, &quot;merge use cases&quot;, etc.). 

    

            



<style>
    .jira-issue {
        padding: 0 0 0 2px;
        line-height: 20px;
    }

    .jira-issue img {
        padding-right: 5px;
    }
    .jira-issue .aui-lozenge {
        line-height: 18px;
        vertical-align: top;
    }

    .jira-issue .icon {
        background-position: left center;
        background-repeat: no-repeat;
        display: inline-block;
        font-size: 0;
        max-height: 16px;
        text-align: left;
        text-indent: -9999em;
        vertical-align: text-bottom;
    }
</style>

    <span class="confluence-jim-macro jira-issue" data-jira-key="MAES-1738" >
                <a href="https://arterisip.atlassian.net/browse/MAES-1738?src=confmacro" class="jira-issue-key">MAES-1738</a>
                            </span>
 tracks some ideas, which however are outdated and only partially workable.</li></ul></li><li>Automation<ul><li>No feature development tracked here. However, there will be some interplay with any automation for high frequency operation (e.g.: an automation for pipeline insertion in the ATU to improve frequency affects latency provisioning) and obviously major interplay with topology synthesis (if included in release), see below, currently unscoped.</li></ul></li><li>Mapping<ul><li>No feature development, but some parameters to map, and the following DV iterations. <strong>Agile M</strong></li></ul></li><li>Checkers<ul><li>Basic performance checker: no latency violations (zero-load). The algorithm is trivial, but need to iterate with HW team on values for endpoint and adapter latencies. Also see the &quot;LatencyAnnotation&quot; task. <strong>Agile M + some time of the HW team as well</strong><ul><li><em>Optional add-on (probably for later releases): GUI feedback, scope TBD.</em></li></ul></li><li>Basic performance checker: no bandwidth violations (link peak bandwidth). <strong>Agile S</strong><ul><li><em>Optional add-on (probably for later releases): GUI feedback, scope TBD.</em></li></ul></li><li>Parameter consistency checks. <strong>Agile S</strong></li><li>Need to review (→ <strong><span class="legacy-color-text-pink2">HW team)</span> <span class="legacy-color-text-pink2">if the ATU ROB sizes need to be evaluated by our deadlock checker</span></strong> for possible system-level deadlock situations. If so, we probably need<ul><li>Deadlock checker extensions, based on a HW-team-provided formula. <strong><span class="legacy-color-text-pink2">Agile S?</span></strong></li><li>Maybe some Maestro assistance to set defaults/guide the user's choice of ROB size. <strong><span class="legacy-color-text-pink2">Agile S?</span></strong></li></ul></li></ul></li><li>Backend (librtl/server/Aria)<ul><li>No feature development. New Aria checks are nice-to-have but probably not mandatory, see below.</li></ul></li></ul><h2 id="MaestroQoSsupport-CurrentlyUnscoped"><strong>Currently Unscoped</strong></h2><ul><li>Integration of all the content in this page with the physical synthesis prototype &amp; algorithms.</li></ul><h2 id="MaestroQoSsupport-Nice-to-HaveFeatures"><strong>Nice-to-Have Features</strong></h2><ul><li>Advanced performance checker: bandwidth estimator under load. Research-y subject requiring iterations with HW and Perf teams. <strong>Agile XL</strong></li><li>FIFO insertion advisor automation: suggest the insertion of FIFOs at bandwidth convergence points above a load threshold. <strong>Agile S</strong> (but depends on previous task for more pertinent suggestions; false positives possible)</li><li><strong><span class="legacy-color-text-pink2">Do we want to gate some QoS features behind a license?</span></strong></li><li>Aria may want to add more checks, although these do not appear to be mandatory. <strong><span class="legacy-color-text-pink2">Agile ?</span></strong></li><li><span class="legacy-color-text-default">ARTG optimizations to account for latency requirements</span><ul><li><span class="legacy-color-text-default">choose between buffered vs. flow-through switches depending on criticality of latency vs. frequency. <strong>Agile S</strong></span></li><li><span class="legacy-color-text-default">optimize the routing algorithm to greedily take minimal paths for latency-critical flows, while moving away contending flows.<strong> Agile M</strong></span></li><li><span class="legacy-color-text-default">node allocation advisor based on latency/bandwidth requirements, i.e.: &quot;if possible, place these two IPs in these two adjacent nodes of the mesh&quot;. (Also applies to Ncore, eventually). <strong>Agile XL</strong></span></li></ul></li></ul><h2 id="MaestroQoSsupport-Post-R1.0"><strong>Post-R1.0</strong></h2><ul><li>Handling of end-to-end credits, if and when available in the Symphony architecture</li><li>Handling of VCs</li><li>Handling of Socket-ID-specific QoS requirements</li><li>In-GUI feedback from performance models/simulation &amp; optimization of settings</li></ul>