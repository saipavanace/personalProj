<h1 id="AgeArbiter-module_name"><strong>module_name</strong></h1><p>com_arb_age_buf</p><h1 id="AgeArbiter-parameters"><strong>parameters</strong></h1><h2 id="AgeArbiter-java_script:"><strong>java_script:</strong></h2><pre>{<br/>        &quot;assertOn&quot;: assertion, boolean
	&quot;nPorts&quot; : number of requestor ports, a positive integer<br/>        &quot;nEntries&quot; : number of entries in the age buffer, a positive integer</pre><pre><span>}<br/><br/></span></pre><p>u.paramDefault('assertOn', 'int', 0);</p><p>u.paramDefault('usePipe',  'int', 0); //When 1 pipeline is enabled, and the pipeOption specifies the pipeline options.</p><p>u.paramDefault('pipeOption', 'int', 0); //When 0, pipeline point is at the internal find first result signal “pop_vec”.  When 1, pipeline point is the input “req_vec”.</p><p><span class="legacy-color-text-blue3">u.paramDefault('useOnehotIndex', 'int', 0); //When 1, pop_index and grant_index has a width of nPorts, otherwise wPorts.</span></p><p><br/></p><p>let assertOn = u.getParam('assertOn');</p><p>let usePipe  = u.getParam('usePipe');</p><p>let pipeOption = u.getParam('pipeOption');</p><p><span class="legacy-color-text-blue3">let useOnehotIndex = u.getParam('useOnehotIndex');</span></p><p><br/></p><p>var nPorts   = u.getParam('nPorts');</p><p>let wPorts   = u.getParam('wPorts');</p><p>let nEntries = u.getParam('nEntries');</p><p><br/></p><pre><span><br/></span></pre><h2 id="AgeArbiter-verilog:"><strong>verilog:</strong></h2><p>none.</p><h1 id="AgeArbiter-I/O"><strong>I/O</strong></h1><pre>u.port('input', 'clk', 1);<br/>u.port('input', 'reset_n', 1);<br/><br/>// age buffer push interface<br/>u.port('input', 'push_en', 1);         //or reduce of push_index<br/>u.port('input', 'push_index', nPorts); //onehot0, 1 bit per port<br/><br/>// age buffer pop interface<br/>u.port('input', 'pop_en', 1);<br/>u.port('input', 'pop_index', useOnehotIndex ? nPorts : wPorts);<br/><br/>// arbiter request interface<br/>u.port('input', 'req_vec', nPorts); // input requests; multihot0 bit vector<br/><br/>// arbiter grant interface<br/>u.port('input', 'grant_ack', 1);<br/>u.port('output', 'grant', 1); //Functionally grant = or reduce of grant_vec<br/>u.port('output', 'grant_vec', nPorts); // output grant; onehot0 bit vector<br/>u.port('output', 'grant_index', useOnehotIndex ? nPorts : wPorts); //output grant index<br/><br/>// status interface<br/>u.port('output', 'valid_vec', nEntries);<br/>u.port('output', 'empty', 1);<br/>u.port('output', 'full', 1);</pre><pre><br/></pre><h1 id="AgeArbiter-Description"><strong>Description</strong></h1><p>Age Arbiter that picks the oldest request in the request arrival order.</p><p>If usePipe=0, then the grant is given in the same cycle as the request.</p><p>If usePipe=1, then the grant is given in the next cycle following the request.</p><p>The request arrival order is recorded in an age buffer via the push interface. The entry in the age buffer is retired via the pop interface.</p><p>When a grant is given for a request, the index of the request in the age buffer is also provided.</p><p>The external logic can register the grant index and uses it to drive the pop index when popping the age buffer.</p><p><br/></p><p>nEntries=8</p><pre><br/>                                    +------------------------------+      <br/>req_vec[3:0]    -------------------&gt;|lookup   Age Vector find_first|-----&gt; grant_vec[3:0]<br/>                                    +---------------^--------------+       grant_index[2:0]<br/>                                                    |<br/>                                    +---------------+--------------+ <br/>                                    |         Age Buffer           |<br/>                                    |                              |<br/>push_en----------------------------&gt;| push                     pop |&lt;----- pop<br/>                  +-------------+   |                              |&lt;----- pop_index[2:0]<br/>push_index[7:0]--&gt;|index_encoder|--&gt;| index[2:0]                   |<br/>                  +-------------+   +------------------------------+<br/><br/>The age buffer is implemented as a shift register, shifting from index=0 to index=nEntries-1.<br/>The youngest entry is on the left.<br/>The oldest entry is on the right.<br/>Any valid entry in the age buffer can be popped, and the age buffer will collapse/compress after the pop.</pre>