<style type='text/css'>/*<![CDATA[*/
div.rbtoc1759724867771 {padding: 0px;}
div.rbtoc1759724867771 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1759724867771 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class='toc-macro rbtoc1759724867771'>
<ul class='toc-indentation'>
<li><a href='#Trace_debug(deprecated,justkeptforreference)-1.0trace_trigger(TTRI)verification'>1.0 trace_trigger (TTRI) verification</a>
<ul class='toc-indentation'>
<li><a href='#Trace_debug(deprecated,justkeptforreference)-1.1TTRIchecking'>1.1 TTRI checking</a></li>
<li><a href='#Trace_debug(deprecated,justkeptforreference)-1.2TTRIstimulus'>1.2 TTRI stimulus</a></li>
</ul>
</li>
<li><a href='#Trace_debug(deprecated,justkeptforreference)-2.0(trace_capture)TCAPverification'>2.0 (trace_capture) TCAP verification</a>
<ul class='toc-indentation'>
<li><a href='#Trace_debug(deprecated,justkeptforreference)-2.1TCAPchecking:TraceCaptureScoreboardchecking'>2.1 TCAP checking: Trace Capture Scoreboard checking</a>
<ul class='toc-indentation'>
<li><a href='#Trace_debug(deprecated,justkeptforreference)-TCAPscoreboardintegration'>TCAP scoreboard integration</a></li>
<li><a href='#Trace_debug(deprecated,justkeptforreference)-TCAPstrategy.'>TCAP strategy.</a></li>
<li><a href='#Trace_debug(deprecated,justkeptforreference)-TCAPDroppedtracemessages.'>TCAP Dropped trace messages.</a></li>
<li><a href='#Trace_debug(deprecated,justkeptforreference)-TCAPTimestampchecking.'>TCAP Timestamp checking.</a></li>
<li><a href='#Trace_debug(deprecated,justkeptforreference)-TCAPTimestamprollovertesting.'>TCAP Timestamp rollover testing.</a></li>
<li><a href='#Trace_debug(deprecated,justkeptforreference)-Uncorrectedtrace.'>Uncorrected trace.</a></li>
<li><a href='#Trace_debug(deprecated,justkeptforreference)-Otherchecks.'>Other checks.</a></li>
</ul>
</li>
<li><a href='#Trace_debug(deprecated,justkeptforreference)-2.2TCAPstimulus'>2.2 TCAP stimulus</a>
<ul class='toc-indentation'>
<li><a href='#Trace_debug(deprecated,justkeptforreference)-Parameters'>Parameters</a></li>
<li><a href='#Trace_debug(deprecated,justkeptforreference)-Othertraceanddebuglimitations'>Other trace and debug limitations</a>
<ul class='toc-indentation'>
<li><a href='#Trace_debug(deprecated,justkeptforreference)-End2endDTWchecking'>End2end DTW checking</a></li>
<li><a href='#Trace_debug(deprecated,justkeptforreference)-TraceRegisterprogramming'>Trace Register programming</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href='#Trace_debug(deprecated,justkeptforreference)-3.0FunctionalChecks'>3.0 Functional Checks</a>
<ul class='toc-indentation'>
<li><a href='#Trace_debug(deprecated,justkeptforreference)-3.1TTRIandTCAPfunctionalchecks'>3.1 TTRI and TCAP functional checks</a></li>
</ul>
</li>
<li><a href='#Trace_debug(deprecated,justkeptforreference)-4.0FunctionalCoverage'>4.0 Functional Coverage</a>
<ul class='toc-indentation'>
<li><a href='#Trace_debug(deprecated,justkeptforreference)-4.1TTRIfunctionalcoverage'>4.1 TTRI functional coverage</a></li>
<li><a href='#Trace_debug(deprecated,justkeptforreference)-4.2TTRIfunctionalcoveragecrosses'>4.2 TTRI functional coverage crosses</a></li>
<li><a href='#Trace_debug(deprecated,justkeptforreference)-4.3TCAPfunctionalcoverage'>4.3 TCAP functional coverage</a></li>
</ul>
</li>
</ul>
</div><p>The major recent RTL changes for trace_debug are the following.</p><ol start="1"><li><p>The trace capture block was moved out of the unit, so that it is not duplicated when the unit is duplicated.</p></li><li><p>With multiported IOAIU, each IOAIU core wrapper can have multiple IOAIU cores. Each core has trigger and capture registers. Trigger logic is inside each core. There is a shared capture logic block outside the cores. The shared capture logic uses the values of core0’s capture control register.</p></li></ol><h1 id="Trace_debug(deprecated,justkeptforreference)-1.0trace_trigger(TTRI)verification">1.0 trace_trigger (TTRI) verification</h1><h3 id="Trace_debug(deprecated,justkeptforreference)-1.1TTRIchecking">1.1 TTRI checking</h3><p>The trigger checking is done the following way.<br/>Each IOAIU core scoreboard instantiates a trace_trigger_utils object. So, in a 4-core multiported IOAIU, each of the four cores instantiates a trace_trigger_utils object.<br/>Each IOAIU core sequence calls trace_trigger_utils register write functions whenever a trigger register is written to pass along new register values.<br/>Each IOAIU core scoreboard calls the trace_trigger_utils function gen_expected_traceme() passing a set of native signals and is returned the expected value of traceme.<br/>Each IOAIU core scoreboard compares the actual traceme bit from the SMI with the expected traceme bit from gen_expected_traceme() and reports any miscompares as errors.</p><p>The IOAIU multiported core number is passed into trace_trigger_utils and is printed out to assist multiported IOAIU simulation debug.</p><h3 id="Trace_debug(deprecated,justkeptforreference)-1.2TTRIstimulus">1.2 TTRI stimulus</h3><p>The following test variations should be created from a basic trigger test using the runsim &quot;flavors&quot; testlist feature.<br/>Plusargs will be used at IOAIU block level to control trigger registers.<br/>Register values can either be fully specified, fully randomized, or a mix (some fields specified and others randomized). Register randomization will use weighted random with some biases toward interesting values.</p><p>Limitation: In a multiported IOAIU block simulation, the plusargs are applied to every IOAIU core, so in general each core has similar register values, at least for the “fully specified” fields.</p><p>Limitations. Trigger simulations have few address matches. To improve this, a new plusarg is needed, +TBAHR_TBALR_bench_control, when set to 1, the test bench will be responsible to pick values of tbahr and tbalr that align with the address regions that the test will use, sometimes being aligned to cover some or all of the used addresses, sometimes slightly lower than the used addresses, and sometimes slightly higher. See <a class="external-link" href="https://arterisip.atlassian.net/browse/CONC-8051" rel="nofollow">CONC-8051</a>.</p><p>nTraceRegisters=1-4 will be tested.<br/>Each test should have at least 10 occurrences of traceme = 1, and at least 10 occurrences of traceme = 0.</p><p /><div class="table-wrap"><table data-table-width="1800" data-layout="default" data-local-id="f9fbda7a-a081-4af5-bd2a-040784ea4705" class="confluenceTable"><colgroup><col style="width: 48.0px;"/><col style="width: 166.0px;"/><col style="width: 636.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><p /></td><td class="confluenceTd"><p><strong>Summary of trigger tests</strong></p></td><td class="confluenceTd"><p /></td></tr><tr><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>IOAIU</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>test flavor name</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>description</p></th></tr><tr><td class="confluenceTd"><p>y</p></td><td class="confluenceTd"><p>master_init_only</p></td><td class="confluenceTd"><p>simple master initiated trace</p></td></tr><tr><td class="confluenceTd"><p>y</p></td><td class="confluenceTd"><p>ncore_init_addr_match_rand</p></td><td class="confluenceTd"><p>ncore-initiated, addr match with random base addr, range size=0</p></td></tr><tr><td class="confluenceTd"><p>y</p></td><td class="confluenceTd"><p>ncore_init_addr_match_0s_size(00-1f)</p></td><td class="confluenceTd"><p>ncore-initiated, addr match to address all 0's, different sizes</p></td></tr><tr><td class="confluenceTd"><p>y</p></td><td class="confluenceTd"><p>ncore_init_addr_match_fs_size(00,1f)</p></td><td class="confluenceTd"><p>ncore-initiated, addr match to address all f's, different sizes</p></td></tr><tr><td class="confluenceTd"><p>y</p></td><td class="confluenceTd"><p>ncore_init_op_code_match</p></td><td class="confluenceTd"><p>ncore-initiated, op_code match, random TOPCR</p></td></tr><tr><td class="confluenceTd"><p>y</p></td><td class="confluenceTd"><p>ncore_init_op_code_match_no_valids</p></td><td class="confluenceTd"><p>ncore-initiated, op_code match, valid1-4 all zero, corner case</p></td></tr><tr><td class="confluenceTd"><p>y</p></td><td class="confluenceTd"><p>ncore_init_mem_attr_match(0-f)</p></td><td class="confluenceTd"><p>ncore-initiated, mem_attr match, all values</p></td></tr><tr><td class="confluenceTd"><p>y</p></td><td class="confluenceTd"><p>ncore_init_mem_attr_match_aw</p></td><td class="confluenceTd"><p>ncore-initiated, mem_attr match, writes only</p></td></tr><tr><td class="confluenceTd"><p>y</p></td><td class="confluenceTd"><p>ncore_init_mem_attr_match_ar</p></td><td class="confluenceTd"><p>ncore-initiated, mem_attr match, reads only</p></td></tr><tr><td class="confluenceTd"><p>y</p></td><td class="confluenceTd"><p>ncore_init_mem_attr_match_aw_ar</p></td><td class="confluenceTd"><p>ncore-initiated, mem_attr match, writes and reads</p></td></tr><tr><td class="confluenceTd"><p>y</p></td><td class="confluenceTd"><p>ncore_init_user_match</p></td><td class="confluenceTd"><p>ncore-initiated, user bits match</p></td></tr><tr><td class="confluenceTd"><p>y</p></td><td class="confluenceTd"><p>ncore_init_user_match_mask_0</p></td><td class="confluenceTd"><p>ncore-initiated, user bits match, user mask all 0's, corner case</p></td></tr><tr><td class="confluenceTd"><p>y</p></td><td class="confluenceTd"><p>ncore_init_target_type_dii_match(00-1f)</p></td><td class="confluenceTd"><p>ncore-initiated, dii target type match, test for each HUI value</p></td></tr><tr><td class="confluenceTd"><p>y</p></td><td class="confluenceTd"><p>ncore_init_target_type_dmi_match(00-1f)</p></td><td class="confluenceTd"><p>ncore-initiated, dmi target type match, test for each HUI value</p></td></tr><tr><td class="confluenceTd"><p>no</p></td><td class="confluenceTd"><p>ncore_init_all</p></td><td class="confluenceTd"><p>ncore-initiated, every match type (ANDed)</p></td></tr><tr><td class="confluenceTd"><p>no</p></td><td class="confluenceTd"><p>master_init_and_ncore_init_all</p></td><td class="confluenceTd"><p>master-initiated trace ANDed with ncore-initiated, every match type</p></td></tr></tbody></table></div><p>To get more details than the test summary above, please look at the following:</p><p>(For IOAIU, nTraceRegisters=1-4) see hw-ncr/dv/ioaiu/tb/runsim_testlist.json, tests ttrig_tcap, ttrig_tcap_2sets, trig_tcap_3sets and trig_tcap_4sets with all their flavors.</p><p>Note that all the current Mobileye configs and other multiported configs have nTraceRegisters=1.</p><h1 id="Trace_debug(deprecated,justkeptforreference)-2.0(trace_capture)TCAPverification">2.0 (trace_capture) TCAP verification</h1><h3 id="Trace_debug(deprecated,justkeptforreference)-2.1TCAPchecking:TraceCaptureScoreboardchecking">2.1 TCAP checking: Trace Capture Scoreboard checking</h3><h5 id="Trace_debug(deprecated,justkeptforreference)-TCAPscoreboardintegration">TCAP scoreboard integration</h5><p>Each unit environment instantiates the Trace Capture Scoreboard.</p><p>The unit environment connects the SMI analysis ports to the Trace Capture Scoreboard.</p><p>The unit environment writes to the trace capture scoreboard static register fields whenever the Capture Control Register is written.</p><p>Once the Trace Capture Scoreboard knows the Capture Control Register value and has the SMI analysis port connections it can perform some checking of the actual DTWs output by the Trace Capture block versus what the scoreboard decides are the trace messages that should be seen in the DTWs.</p><h5 id="Trace_debug(deprecated,justkeptforreference)-TCAPstrategy."><strong>TCAP strategy.</strong></h5><p>Starting with Ncore 3.2, the primary test bench for testing trace capture has been DMI. IOAIU will be primarily concerned with checking trace capture connectivity, not testing the internals of the trace capture logic.</p><h5 id="Trace_debug(deprecated,justkeptforreference)-TCAPDroppedtracemessages."><strong>TCAP Dropped trace messages.</strong></h5><p>If the capture system is full including the SMI network input FIFOs, new SMI messages with traceme set will not lead to trace messages that end being output as DTWs. These are dropped trace messages. RTL will use the performance counters to report how many trace messages are dropped, but not which exact trace messages are dropped. At the end of the simulation, the DMI test bench TCAP scoreboards will compare the drop count reported by RTL and report an error if it is different than the DV drop count, but not check which messages should have been dropped. DV will not determine whether it was appropriate for the RTL to drop a message. DV does not model the RTL trace FIFOs, accumulators and buffer. </p><p>Trace messages should not be stuck in the TCAP accumulators or trace buffer at the end of a simulation because the IOAIU waits for RTL to be not busy (including trace messages that have not been output) before ending the simulation. DV compares the number of trace messages processed with the number that RTL reports as completed, so we should report an error if any trace message were still stuck in TCAP at the end of the simulation.</p><h5 id="Trace_debug(deprecated,justkeptforreference)-TCAPTimestampchecking."><strong>TCAP Timestamp checking.</strong></h5><p /><p>Even within a single DTW, timestamp values are not guaranteed to be increasing, they can go up or down, unless only trace capture from one SMI network is specified in the Capture Control Register.</p><p>We do the following TCAP timestamp check.</p><p>The check has a timestamp check interval specified by +tStampChk=1000 (current default value).<br/>Once every 1000 Trace Messages from DTWs are observed, checker does the following.<br/>Compares the average of the timestamps in the current Trace Message, to the average of the timestamps in the Trace Message from 2000 Trace Messages ago (old_Trace_Message_timestamp_average).<br/>Basically, we check that Trace_Message_timestamp_average(n) &gt; Trace_Message_timestamp_average(n-1000).<br/>The new Trace Message timestamp average must be higher than the old Trace Message timestamp average.<br/>We don’t check the timestamp values for Trace Messages 1001-1999, 2001-2999, etc, just 1000, 2000, 3000, etc.<br/>This is clearly not very “rigorous” checking.</p><p>See <a class="external-link" href="https://arterisip.atlassian.net/browse/CONC-8090" rel="nofollow">CONC-8090</a> for a block level test that fails with +tStampChk=1601.</p><h5 id="Trace_debug(deprecated,justkeptforreference)-TCAPTimestamprollovertesting.">TCAP Timestamp rollover testing.</h5><p>In the DMI test bench, in some tests DV will force a non-zero initial value for the RTL timestamp value, often to a value, such as 'hFFFF_FF00, that will soon cause a timestamp rollover.</p><h5 id="Trace_debug(deprecated,justkeptforreference)-Uncorrectedtrace.">Uncorrected trace.</h5><p>For Ncore 3.4 release, the design create trace messages from the uncorrected SMI packet, not the corrected SMI packet. So, this is what DV will checks. See <a class="external-link" href="https://arterisip.atlassian.net/browse/CONC-8091" rel="nofollow">CONC-8091</a>.</p><h5 id="Trace_debug(deprecated,justkeptforreference)-Otherchecks.">Other checks.</h5><p /><p>The trace scoreboard can do some minimal checking of the legality of some DTW fields and which SMI can be used for DTW output.</p><h3 id="Trace_debug(deprecated,justkeptforreference)-2.2TCAPstimulus">2.2 TCAP stimulus</h3><p>The following test variations should be create from a basic test using the runsim flavors testlist feature.<br/></p><div class="table-wrap"><table data-table-width="1800" data-layout="default" data-local-id="b0cfb4b6-21be-46fc-872f-923197b350ff" class="confluenceTable"><colgroup><col style="width: 48.0px;"/><col style="width: 111.0px;"/><col style="width: 691.0px;"/></colgroup><tbody><tr><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>IOAIU</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>test flavor name</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>notes</p></th></tr><tr><td class="confluenceTd"><p>y</p></td><td class="confluenceTd"><p>capture_random</p></td><td class="confluenceTd"><p>All register bits randomized, including SMI inputs, gain value and inc value.</p></td></tr><tr><td class="confluenceTd"><p>y</p></td><td class="confluenceTd"><p>capture_none</p></td><td class="confluenceTd"><p>All SMI bits disabled.</p></td></tr><tr><td class="confluenceTd"><p>y</p></td><td class="confluenceTd"><p>capture_tx0</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>y</p></td><td class="confluenceTd"><p>capture_rx0</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>y</p></td><td class="confluenceTd"><p>capture_tx1</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>y</p></td><td class="confluenceTd"><p>capture_rx1</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>n/a</p></td><td class="confluenceTd"><p>capture_tx2</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>n/a</p></td><td class="confluenceTd"><p>capture_rx2</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>y</p></td><td class="confluenceTd"><p>capture_tx_other</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>y</p></td><td class="confluenceTd"><p>capture_rx_other</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>n/a</p></td><td class="confluenceTd"><p>capture_tx_all_dmi</p></td><td class="confluenceTd"><p>tx-only: DMI</p></td></tr><tr><td class="confluenceTd"><p>n/a</p></td><td class="confluenceTd"><p>capture_rx_all_dmi</p></td><td class="confluenceTd"><p>rx-only: DMI</p></td></tr><tr><td class="confluenceTd"><p>y</p></td><td class="confluenceTd"><p>capture_tx_all_others</p></td><td class="confluenceTd"><p>tx-only: others (DII, CHI, IOAIU)</p></td></tr><tr><td class="confluenceTd"><p>y</p></td><td class="confluenceTd"><p>capture_rx_all_others</p></td><td class="confluenceTd"><p>rx-only: others (DII, CHI, IOAIU)</p></td></tr><tr><td class="confluenceTd"><p>n/a</p></td><td class="confluenceTd"><p>capture_tx_rx_all_dmi</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>y</p></td><td class="confluenceTd"><p>capture_tx_rx_all_others</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>n/a</p></td><td class="confluenceTd"><p>capture_tx_rx_all_dmi_gain(0-f)</p></td><td class="confluenceTd"><p>try all gain values</p></td></tr><tr><td class="confluenceTd"><p>y</p></td><td class="confluenceTd"><p>capture_tx_rx_all_others_gain(0-f)</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>n/a</p></td><td class="confluenceTd"><p>capture_tx_rx_all_dmi_inc</p></td><td class="confluenceTd"><p>try several inc values in 4.8 integer/fraction format</p></td></tr><tr><td class="confluenceTd"><p>several values</p></td><td class="confluenceTd"><p>capture_tx_rx_all_others_inc</p></td><td class="confluenceTd"><p /></td></tr></tbody></table></div><p>To get more details than the test summary above, please look at the following:</p><p>For IOAIU, see hw-ncr/dv/ioaiu/tb/runsim_testlist.json, test ttrig_tcap with all its flavors</p><p>Most of DMI coverage comes from test &quot;random&quot; with randomized CCTRLR.</p><p /><h4 id="Trace_debug(deprecated,justkeptforreference)-Parameters">Parameters</h4><p>TCAP: nUnitTraceBufSize: values of 8 and 16 (the value 16 will only be tested in a single DMI block config) will be tested for the Ncore 3.4 release.<br/>TTRI: nTraceRegisters: values of 1-4 will be tested for in IOAIU block testing.</p><h4 id="Trace_debug(deprecated,justkeptforreference)-Othertraceanddebuglimitations">Other trace and debug limitations</h4><h5 id="Trace_debug(deprecated,justkeptforreference)-End2endDTWchecking"><br/>End2end DTW checking</h5><p>The Ncore 3.4 FYS scoreboard does not yet have the code to make sure that DTW requests and responses travel correctly across different networks. </p><h5 id="Trace_debug(deprecated,justkeptforreference)-TraceRegisterprogramming">Trace Register programming</h5><p /><p>For most tests TTRI and TCAP  control registers will only be programmed once at the beginning of the simulation, before any native traffic starts.<br/>Static variables are being used for trace registers inside DV. The unit needs to pass along the trace register writes to these static registers manually. Full 32-bit register accesses supported, not partial register access.<br/>DV has its own register data structures and does not use the RAL. This means we currently have to be aware of any register spec changes and update our DV code manually.</p><p>For some blocks and tests, DV will sometimes change the trace register values in the middle of a block-level simulation (Dynamic Register Programming). This will require a careful sequence of events to quiesce the system and disable trace checking before changing the register values. </p><h1 id="Trace_debug(deprecated,justkeptforreference)-3.0FunctionalChecks">3.0 Functional Checks</h1><h3 id="Trace_debug(deprecated,justkeptforreference)-3.1TTRIandTCAPfunctionalchecks">3.1 TTRI and TCAP functional checks</h3><div class="table-wrap"><table data-table-width="1800" data-layout="default" data-local-id="513d6430-c48e-4ebf-a6ff-fc4da2999bba" class="confluenceTable"><colgroup><col style="width: 48.0px;"/><col style="width: 213.2px;"/><col style="width: 227.56px;"/><col style="width: 77.68px;"/><col style="width: 48.0px;"/><col style="width: 48.0px;"/><col style="width: 187.56px;"/></colgroup><tbody><tr><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>ID</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Checks</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Hash Tag</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Location</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>TestName</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Status</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Remarks</p></th></tr><tr><td class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>IOAIU: TTRI: Compare Traceme: RTL actual vs DV expected</p></td><td class="confluenceTd"><p>#Check.IOAIU.TTRI.TM_compare</p></td><td class="confluenceTd"><p /></td><td class="confluenceTd"><p>ttrig</p></td><td class="confluenceTd"><p>Done</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>6</p></td><td class="confluenceTd"><p>TCAP: Timestamp incremented after 2000 messages</p></td><td class="confluenceTd"><p /></td><td class="confluenceTd"><p /></td><td class="confluenceTd"><p>random</p></td><td class="confluenceTd"><p>Done</p></td><td class="confluenceTd"><p>This check turned out to not be useful and is no longer an error or not prioritized in regression debug. With the current architecture and micro-architecture, traces can be very out of order.</p></td></tr><tr><td class="confluenceTd"><p>8</p></td><td class="confluenceTd"><p>TCAP: DTWDebugReq only sent out TX2</p></td><td class="confluenceTd"><p>#Check.IOAIU.TCAP.DTWDebugReq_TX2</p></td><td class="confluenceTd"><p /></td><td class="confluenceTd"><p>trig_tcap</p></td><td class="confluenceTd"><p>Done</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>10</p></td><td class="confluenceTd"><p>TCAP: DTWDebugReq never sent out RX</p></td><td class="confluenceTd"><p>#Check.IOAIU.TCAP.DTWDebugReq_RX</p></td><td class="confluenceTd"><p /></td><td class="confluenceTd"><p /></td><td class="confluenceTd"><p>Done</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>11</p></td><td class="confluenceTd"><p>TCAP: DTWDebugReq cannot be all zeros</p></td><td class="confluenceTd"><p>#Check.IOAIU.TCAP.DTWDebugReq_nonzero</p></td><td class="confluenceTd"><p /></td><td class="confluenceTd"><p /></td><td class="confluenceTd"><p>Done</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>12</p></td><td class="confluenceTd"><p>TCAP: Trace message not found</p></td><td class="confluenceTd"><p>#Check.IOAIU.TCAP.TraceMessage_not_found</p></td><td class="confluenceTd"><p /></td><td class="confluenceTd"><p /></td><td class="confluenceTd"><p>Done</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>13</p></td><td class="confluenceTd"><p>TCAP: Check number of SMI ports</p></td><td class="confluenceTd"><p>#Check.IOAIU.TCAP.Num_SMI_ports</p></td><td class="confluenceTd"><p /></td><td class="confluenceTd"><p /></td><td class="confluenceTd"><p>Done</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>14</p></td><td class="confluenceTd"><p>TCAP: Check padding</p></td><td class="confluenceTd"><p>#Check.IOAIU.TCAP.Padding</p></td><td class="confluenceTd"><p /></td><td class="confluenceTd"><p /></td><td class="confluenceTd"><p>Done</p></td><td class="confluenceTd"><p /></td></tr></tbody></table></div><p /><h1 id="Trace_debug(deprecated,justkeptforreference)-4.0FunctionalCoverage">4.0 Functional Coverage</h1><h4 id="Trace_debug(deprecated,justkeptforreference)-4.1TTRIfunctionalcoverage">4.1 TTRI functional coverage</h4><p>The following functional coverage should be written for TTRI, sampled at trace_trigger_utils when gen_expected_traceme is called. </p><p>Functional coverage will be run on CHI and IOAIU block trace tests.</p><p /><p>Coverage for the following register field values passed to trace_trigger_utils.</p><div class="table-wrap"><table data-table-width="1800" data-layout="default" data-local-id="695de10d-35a3-44ca-9a84-561b78121ac5" class="confluenceTable"><colgroup><col style="width: 72.33px;"/><col style="width: 58.33px;"/><col style="width: 85.33px;"/><col style="width: 59.33px;"/><col style="width: 136.0px;"/><col style="width: 295.33px;"/></colgroup><tbody><tr><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Functional Coverage ID (1 coverpoint per trigger set)</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>register</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>field</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>match type</p></th><th class="confluenceTh"><p><strong>hashtag</strong></p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>bins</p></th></tr><tr><td class="confluenceTd"><p>R1</p></td><td class="confluenceTd"><p>TCTRLR</p></td><td class="confluenceTd"><p>native_trace_en</p></td><td class="confluenceTd"><p>native_traceme</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.TCTRLR.native_trace_en</p></td><td class="confluenceTd"><p>0,1</p></td></tr><tr><td class="confluenceTd"><p>R2</p></td><td class="confluenceTd"><p>TCTRLR</p></td><td class="confluenceTd"><p>addr_match_en</p></td><td class="confluenceTd"><p>addr</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.TCTRLR.addr_match_en</p></td><td class="confluenceTd"><p>0,1</p></td></tr><tr><td class="confluenceTd"><p>R3</p></td><td class="confluenceTd"><p>TCTRLR</p></td><td class="confluenceTd"><p>memattr_match_en</p></td><td class="confluenceTd"><p>memattr</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.TCTRLR.memattr_match_en</p></td><td class="confluenceTd"><p>0,1</p></td></tr><tr><td class="confluenceTd"><p>R4</p></td><td class="confluenceTd"><p>TCTRLR</p></td><td class="confluenceTd"><p>opcode_match_en</p></td><td class="confluenceTd"><p>opcode</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.TCTRLR.opcode_match_en</p></td><td class="confluenceTd"><p>0,1</p></td></tr><tr><td class="confluenceTd"><p>R5</p></td><td class="confluenceTd"><p>TCTRLR</p></td><td class="confluenceTd"><p>target_type_en</p></td><td class="confluenceTd"><p>target_type</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.TCTRLR.target_type_match_en</p></td><td class="confluenceTd"><p>0,1</p></td></tr><tr><td class="confluenceTd"><p>R6</p></td><td class="confluenceTd"><p>TCTRLR</p></td><td class="confluenceTd"><p>user_match_en</p></td><td class="confluenceTd"><p>user</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.TCTRLR.user_match_en</p></td><td class="confluenceTd"><p>0,1</p></td></tr><tr><td class="confluenceTd"><p>R7</p></td><td class="confluenceTd"><p>TCTRLR</p></td><td class="confluenceTd"><p>hut</p></td><td class="confluenceTd"><p>target_type</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.TCTRLR.hut</p></td><td class="confluenceTd"><p>0,1</p></td></tr><tr><td class="confluenceTd"><p>R8</p></td><td class="confluenceTd"><p>TCTRLR</p></td><td class="confluenceTd"><p>hui</p></td><td class="confluenceTd"><p>target_type</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.TCTRLR.hui</p></td><td class="confluenceTd"><p>0x0:0xf </p></td></tr><tr><td class="confluenceTd"><p>R9</p></td><td class="confluenceTd"><p>TCTRLR</p></td><td class="confluenceTd"><p>range</p></td><td class="confluenceTd"><p>addr</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.TCTRLR.range</p></td><td class="confluenceTd"><p>0x00:0x1f</p></td></tr><tr><td class="confluenceTd"><p>R10</p></td><td class="confluenceTd"><p>TCTRLR</p></td><td class="confluenceTd"><p>memattr</p></td><td class="confluenceTd"><p>memattr</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.TCTRLR.memattr</p></td><td class="confluenceTd"><p>0x0:0xf</p></td></tr><tr><td class="confluenceTd"><p>R11</p></td><td class="confluenceTd"><p>TCTRLR</p></td><td class="confluenceTd"><p>ar</p></td><td class="confluenceTd"><p>memattr</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.TCTRLR.ar</p></td><td class="confluenceTd"><p>0,1</p></td></tr><tr><td class="confluenceTd"><p>R12</p></td><td class="confluenceTd"><p>TCTRLR</p></td><td class="confluenceTd"><p>aw</p></td><td class="confluenceTd"><p>memattr</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.TCTRLR.aw</p></td><td class="confluenceTd"><p>0,1</p></td></tr><tr><td class="confluenceTd"><p>R13</p></td><td class="confluenceTd"><p>TBAHR, TBALR</p></td><td class="confluenceTd"><p>base addr</p></td><td class="confluenceTd"><p>addr</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.TBAHR_TBALR</p></td><td class="confluenceTd"><p>0s, fs, 8 intermediate ranges</p></td></tr><tr><td class="confluenceTd"><p>R14</p></td><td class="confluenceTd"><p>TOPCR0</p></td><td class="confluenceTd"><p>concat(valid4..1)</p></td><td class="confluenceTd"><p>opcode</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.TOPCR.valid</p></td><td class="confluenceTd"><p>0x0:0xf</p></td></tr><tr><td class="confluenceTd"><p>R15</p></td><td class="confluenceTd"><p>TOPCR0</p></td><td class="confluenceTd"><p>opcode 1</p></td><td class="confluenceTd"><p>opcode</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.TOPCR0.opcode1</p></td><td class="confluenceTd"><p>0x0000:0x3f, default, (:1f for CHI-A)</p></td></tr><tr><td class="confluenceTd"><p>R17</p></td><td class="confluenceTd"><p>TOPCR0</p></td><td class="confluenceTd"><p>opcode 2</p></td><td class="confluenceTd"><p>opcode</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.TOPCR0.opcode2</p></td><td class="confluenceTd"><p>0x0000:0x3f, default, (:1f for CHI-A)</p></td></tr><tr><td class="confluenceTd"><p>R19</p></td><td class="confluenceTd"><p>TOPCR1</p></td><td class="confluenceTd"><p>opcode 3</p></td><td class="confluenceTd"><p>opcode</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.TOPCR1.opcode3</p></td><td class="confluenceTd"><p>0x0000:0x3f, default, (:1f for CHI-A)</p></td></tr><tr><td class="confluenceTd"><p>R21</p></td><td class="confluenceTd"><p>TOPCR1</p></td><td class="confluenceTd"><p>opcode 4</p></td><td class="confluenceTd"><p>opcode</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.TOPCR1.opcode4</p></td><td class="confluenceTd"><p>0x0000:0x3f, default, (:1f for CHI-A)</p></td></tr><tr><td class="confluenceTd"><p>R22</p></td><td class="confluenceTd"><p>TUBMR</p></td><td class="confluenceTd"><p>user bits</p></td><td class="confluenceTd"><p>user</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.TUBMR.user_mask</p></td><td class="confluenceTd"><p>0x0:0xf (depends on width), 0xffff_ffff (if width ==32)</p></td></tr><tr><td class="confluenceTd"><p>R23</p></td><td class="confluenceTd"><p>TUBMR</p></td><td class="confluenceTd"><p>TUBR masked by TUBMR</p></td><td class="confluenceTd"><p>masked user</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.TUBR_masked_by_TUBMR</p></td><td class="confluenceTd"><p>0x0:0xf (depends on width), 0xffff_ffff (if width ==32)</p></td></tr></tbody></table></div><p /><p /><p>Coverage for the following native signals passed to trace_trigger_utils.</p><div class="table-wrap"><table data-table-width="1800" data-layout="default" data-local-id="c7cc47a6-a127-48c3-98b0-f8670ab0dead" class="confluenceTable"><colgroup><col style="width: 108.0px;"/><col style="width: 102.0px;"/><col style="width: 94.0px;"/><col style="width: 170.0px;"/><col style="width: 376.0px;"/></colgroup><tbody><tr><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Functional Coverage ID</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>signal</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>match type</p></th><th class="confluenceTh"><p><strong>hashtag</strong></p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>bins</p></th></tr><tr><td class="confluenceTd"><p>N1</p></td><td class="confluenceTd"><p>native_traceme</p></td><td class="confluenceTd"><p>native_traceme</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.native_traceme</p></td><td class="confluenceTd"><p>0,1</p></td></tr><tr><td class="confluenceTd"><p>N2</p></td><td class="confluenceTd"><p>native_addr</p></td><td class="confluenceTd"><p>addr</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.native_addr</p></td><td class="confluenceTd"><p>0s, fs, 8 intermediate ranges (only hitting 1/10 bins)</p></td></tr><tr><td class="confluenceTd"><p>N3</p></td><td class="confluenceTd"><p>native_ar </p></td><td class="confluenceTd"><p>memattr</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.native_ar</p></td><td class="confluenceTd"><p>0,1</p></td></tr><tr><td class="confluenceTd"><p>N4</p></td><td class="confluenceTd"><p>native_aw</p></td><td class="confluenceTd"><p>memattr</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.native_aw</p></td><td class="confluenceTd"><p>0,1</p></td></tr><tr><td class="confluenceTd"><p>N5</p></td><td class="confluenceTd"><p>native_dii_hit</p></td><td class="confluenceTd"><p>target_type</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.native_dii_hit</p></td><td class="confluenceTd"><p>0,1</p></td></tr><tr><td class="confluenceTd"><p>N6</p></td><td class="confluenceTd"><p>native_dmi_hit</p></td><td class="confluenceTd"><p>target_type</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.native_dmi_hit</p></td><td class="confluenceTd"><p>0,1</p></td></tr><tr><td class="confluenceTd"><p>N7</p></td><td class="confluenceTd"><p>native_dii_hui_unitid</p></td><td class="confluenceTd"><p>target_type</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.native_dii_hui_nunitid</p></td><td class="confluenceTd"><p>only hitting 0 and 1, (Khaeel said only 0x0:0x2 for HII hui nUnitId)</p></td></tr><tr><td class="confluenceTd"><p /></td><td class="confluenceTd"><p>native_dmi_hui_mig</p></td><td class="confluenceTd"><p>target_type</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.native_dmi_hui_mig</p></td><td class="confluenceTd"><p>0x0 to 0xf (only hitting 0 and 1)</p></td></tr><tr><td class="confluenceTd"><p>N8</p></td><td class="confluenceTd"><p>native_memattr</p></td><td class="confluenceTd"><p>memattr</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.native_memattr</p></td><td class="confluenceTd"><p>CHI: 0..5, d (ignoring c which might be illegal and is being seen), IOAIU: 0..3, 6..7, a..b, e..f (DVM), others ignored</p></td></tr><tr><td class="confluenceTd"><p>N9</p></td><td class="confluenceTd"><p>native_opcode</p></td><td class="confluenceTd"><p>opcode</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.native_opcode</p></td><td class="confluenceTd"><p>CHI-A all 5-bit values -unsupported. CHI-B all 6-bit values -unsupported. IOAIU: bit 6 guarded by eAtomic, bit 5 guarded by eDomain</p></td></tr><tr><td class="confluenceTd"><p>N10</p></td><td class="confluenceTd"><p>native_user</p></td><td class="confluenceTd"><p>user</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.native_user</p></td><td class="confluenceTd"><p>0,1 for each of bits 0..2 if they exist as well as for MSB.</p></td></tr></tbody></table></div><p /><p>Coverage for the following expected signals created by trace_trigger_utils.<br/></p><div class="table-wrap"><table data-table-width="1800" data-layout="default" data-local-id="b32bc0be-db49-4798-b871-62bcf2d65fe0" class="confluenceTable"><colgroup><col style="width: 88.0px;"/><col style="width: 108.0px;"/><col style="width: 88.0px;"/><col style="width: 195.0px;"/><col style="width: 371.0px;"/></colgroup><tbody><tr><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Functional Coverage ID (1 coverpoint per trigger_set)</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>signal</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>match type</p></th><th class="confluenceTh"><p><strong>hashtag</strong></p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>bins</p></th></tr><tr><td class="confluenceTd"><p>E1</p></td><td class="confluenceTd"><p>native_matched</p></td><td class="confluenceTd"><p>native_traceme</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.native_matched</p></td><td class="confluenceTd"><p>0,1</p></td></tr><tr><td class="confluenceTd"><p>E2</p></td><td class="confluenceTd"><p>addr_matched</p></td><td class="confluenceTd"><p>addr</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.addr_matched</p></td><td class="confluenceTd"><p>0,1</p></td></tr><tr><td class="confluenceTd"><p>E3</p></td><td class="confluenceTd"><p>memattr_matched</p></td><td class="confluenceTd"><p>memattr</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.memattr_matched</p></td><td class="confluenceTd"><p>0,1</p></td></tr><tr><td class="confluenceTd"><p>E4</p></td><td class="confluenceTd"><p>opcode_matched</p></td><td class="confluenceTd"><p>opcode</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.opcode_matched</p></td><td class="confluenceTd"><p>0,1</p></td></tr><tr><td class="confluenceTd"><p>E5</p></td><td class="confluenceTd"><p>target_type_matched</p></td><td class="confluenceTd"><p>target_type</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.target_type_matched</p></td><td class="confluenceTd"><p>0,1</p></td></tr><tr><td class="confluenceTd"><p>E6</p></td><td class="confluenceTd"><p>user_matched</p></td><td class="confluenceTd"><p>user</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.user_matched</p></td><td class="confluenceTd"><p>0,1</p></td></tr><tr><td class="confluenceTd"><p>E7</p></td><td class="confluenceTd"><p>trace[3:0]</p></td><td class="confluenceTd"><p>all</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.traceme_out_expected_per_set</p></td><td class="confluenceTd"><p>0x0:0xf </p></td></tr><tr><td class="confluenceTd"><p>E8</p></td><td class="confluenceTd"><p>traceme</p></td><td class="confluenceTd"><p>all</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI.traceme_out_expected</p></td><td class="confluenceTd"><p>0,1</p></td></tr></tbody></table></div><p /><h4 id="Trace_debug(deprecated,justkeptforreference)-4.2TTRIfunctionalcoveragecrosses">4.2 TTRI functional coverage crosses</h4><p>All Individual cover points will be crossed with trigger register set number (0-3).</p><p>Note that with multiported IOAIU, the number of cover points can increase by a factor or 4 or even 8, so we will need to significantly reduce the number of crosses captured.</p><div class="table-wrap"><table data-table-width="1800" data-layout="default" data-local-id="d13fdab0-82c9-4cf2-a3fd-05b98f7d1332" class="confluenceTable"><colgroup><col style="width: 103.0px;"/><col style="width: 65.0px;"/><col style="width: 157.0px;"/><col style="width: 83.0px;"/><col style="width: 276.0px;"/></colgroup><tbody><tr><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Functional Coverage Cross ID</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>match type</p></th><th class="confluenceTh"><p><strong>hashtag</strong></p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Functional Coverage IDs crossed</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>cross bins</p></th></tr><tr><td class="confluenceTd"><p>each of these still needs to be coded</p></td><td class="confluenceTd"><p /></td><td class="confluenceTd"><p /></td><td class="confluenceTd"><p /></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p>C1</p></td><td class="confluenceTd"><p>memattr regs</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI_cross.TCTRLR.memattr_fields</p></td><td class="confluenceTd"><p>R10, R11, R12</p></td><td class="confluenceTd"><p>all combinations</p></td></tr><tr><td class="confluenceTd"><p>C2</p></td><td class="confluenceTd"><p>memattr</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI_cross.native.memattr_fields</p></td><td class="confluenceTd"><p>N3, N4, N8</p></td><td class="confluenceTd"><p>all combinations</p></td></tr><tr><td class="confluenceTd"><p>C3</p></td><td class="confluenceTd"><p>opcode</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI_cross.native.opcode_fields</p></td><td class="confluenceTd"><p>N9, E4</p></td><td class="confluenceTd"><p>all combinations</p></td></tr><tr><td class="confluenceTd"><p>C4</p></td><td class="confluenceTd"><p>match_enables</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI_cross.TCTRLR.match_enables</p></td><td class="confluenceTd"><p>R1-R6</p></td><td class="confluenceTd"><p>all combinations</p></td></tr><tr><td class="confluenceTd"><p>C5</p></td><td class="confluenceTd"><p>matches</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI_cross.matches</p></td><td class="confluenceTd"><p>E1-E6</p></td><td class="confluenceTd"><p>all combinations</p></td></tr><tr><td class="confluenceTd"><p>C6</p></td><td class="confluenceTd"><p>native_matched</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI_cross.native_matched_per_set</p></td><td class="confluenceTd"><p>E1 for every trigger set</p></td><td class="confluenceTd"><p>match sure matched happens in each set, but not necessarily at the same time.</p></td></tr><tr><td class="confluenceTd"><p>C7</p></td><td class="confluenceTd"><p>addr_matched</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI_cross.addr_matched_per_set</p></td><td class="confluenceTd"><p>E2 for every trigger set</p></td><td class="confluenceTd"><p>match sure matched happens in each set, but not necessarily at the same time.</p></td></tr><tr><td class="confluenceTd"><p>C8</p></td><td class="confluenceTd"><p>memattr_matched</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI_cross.memattr_matched_per_set</p></td><td class="confluenceTd"><p>E3 for every trigger set</p></td><td class="confluenceTd"><p>match sure matched happens in each set, but not necessarily at the same time.</p></td></tr><tr><td class="confluenceTd"><p>C9</p></td><td class="confluenceTd"><p>target_type_matched</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI_cross.target_type_matched_per_set</p></td><td class="confluenceTd"><p>E5 for every trigger set</p></td><td class="confluenceTd"><p>match sure matched happens in each set, but not necessarily at the same time.</p></td></tr><tr><td class="confluenceTd"><p>C10</p></td><td class="confluenceTd"><p>user_matched</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TTRI_cross.user_matched_per_set</p></td><td class="confluenceTd"><p>E6 for every trigger set</p></td><td class="confluenceTd"><p>match sure matched happens in each set, but not necessarily at the same time.</p></td></tr></tbody></table></div><h4 id="Trace_debug(deprecated,justkeptforreference)-4.3TCAPfunctionalcoverage">4.3 TCAP functional coverage</h4><p>The following functional coverage should be written for TCAP.</p><p>Only the CCTRLR for core0 will be covered, since the other CCTRLRs for multiported IOAIU are ignored.</p><p>Note that with multiported IOAIU, the number of cover points can increase by a factor or 4 or even 8, so we will need to significantly reduce the number of crosses captured.</p><div class="table-wrap"><table data-table-width="1800" data-layout="default" data-local-id="5c7a9376-eacf-4c3e-a9a1-c62cebfb7045" class="confluenceTable"><colgroup><col style="width: 112.0px;"/><col style="width: 57.0px;"/><col style="width: 145.0px;"/><col style="width: 269.0px;"/><col style="width: 267.0px;"/></colgroup><tbody><tr><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Functional Coverage ID</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Register</p></th><th class="confluenceTh"><p><strong>hashtag</strong></p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>Field</p></th><th data-highlight-colour="#f0f0f0" class="confluenceTh"><p>bins</p></th></tr><tr><td class="confluenceTd"><p>R1</p></td><td class="confluenceTd"><p>CCTRLR</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TCAP.CCTRLR.enables</p></td><td class="confluenceTd"><p>snoop and capture enables (6 for IOAIU, but 8 for DMI)</p></td><td class="confluenceTd"><p>cover all combinations</p></td></tr><tr><td class="confluenceTd"><p>R2</p></td><td class="confluenceTd"><p>CCTRLR</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TCAP.CCTRLR.gain</p></td><td class="confluenceTd"><p>gain (4 bits)</p></td><td class="confluenceTd"><p>cover all values</p></td></tr><tr><td class="confluenceTd"><p>R3</p></td><td class="confluenceTd"><p>CCTRLR</p></td><td class="confluenceTd"><p>#Cover.IOAIU.TCAP.CCTRLR.incr</p></td><td class="confluenceTd"><p>incr (12 bits, 4 integer, 8 fractional)</p></td><td class="confluenceTd"><p>cover all integers, cover each fractional bit </p></td></tr></tbody></table></div><p /><p>Other coverage for CHI, IOAIU, DMI, DII instances:</p><p><strong>Function coverage should be written for the following::</strong></p><p>Fcov::::: Check combinations of CCTRLR register. Fields such as:: (Inc, Gain, SMI Ports)<br/>Fcov::::: Check for free Running Counter (FRC) Altered and  Wrapped.<br/>Fcov::::: Make sure TM-Bit is set for all Concerto message request - block where TCap exists.<br/>            This might be very tricky, but nonetheless doable. That would include transactions from::<br/>            DMI, DII, CIAU and NCAIU[Ace, Axi with proxy and Axi without proxy]<br/>Fcov::::: During back pressure, new MSGs can be added into the accumulator that has a timeout counter less than 2^10.<br/>            This has been voided... not part of architecture defined.<br/>Fcov::::: This functional coverage is mostly for the arbiter, if accumulator_A timeout counter has expired and the buffers<br/>             are full.... under no conditions, accumulator_B or accumulator_C can bypass twice accumulator_A...<br/>This arbitration logic is share throughout Ncore, therefore, it would be considered wastefull to check it<br/>validity at this point.</p><p><strong>Function coverage will not be written for the scenarios listed below. The bench already has checks for them</strong>.</p><p>Bench:::: number of DTWDebugReq processed per simulation (per SMI input)<br/>Bench:::: Timeout counter should not exceed 2^10 under any conditions (Added here, no need for functional coverage)<br/>Bench:::: number of trace messages per DTW<br/>Bench:::: DTW_debug_req<br/>Bench:::: DTW_debug_rsp<br/>Bench:::: padding length<br/>Bench:::: trace message length</p><p>Perfmon:: number of trace messages processed per simulation (per SMI input)<br/>Perfmon:: number of trace messages dropped per simulation<br/>Perfmon:: percent of trace messages dropped per simulation</p><p><strong>The following required some discussions, as it is unclear at the moment.</strong></p><p>Not Clear:: trace message timestamp bit values</p>