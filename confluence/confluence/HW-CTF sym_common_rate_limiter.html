<p><strong>module_name:</strong></p><p><span>sym_common_rate_limiter</span></p><h1 id="HW-CTFsym_common_rate_limiter-Features"><strong>Features</strong></h1><ul><li>Can be configurable through external signaling (CSR Dynamic Configuration) or through parameters (Static COnfiguration)</li><li>Rate Limits the number of Queues through a leaky bucket mechanism.</li><li>Each queue has a bucket in addition to a global bucket.</li><li>Each queue can demote their priority to use a second bucket.<br/><br/></li></ul><div class="page view"><div class="wiki-content"><h1 id="HW-CTFsym_common_rate_limiter-I/O"><strong>I/O</strong></h1><p>u.port('input', 'queue_valid' , 1); // Which queue was selected</p><p>u.port('input', 'queue_ready' , 1); // Which queue was selected</p><p>u.port('input', 'queue_selected' , log2ceil(nQueue)); // Which queue was selected</p><p>u.port('input', 'queue_length' , wLen); // The Length of the selected queue</p><p><br/></p><div><p>u.port('output', 'queue_block' , nQueue); // Indicates if a queue has no credits (primary or secondary) and no global credits exist.</p><p>u.port('output', 'queue_demote' , nQueue); // Indicates if a queue is currently using secondary bucket credits.</p></div><div><p><br/></p><p>if(useExternalValues) {</p><p>    u.port('input', 'rateLmtEn' , 1); // Enable the rate limiting buckets. No buckets will be updated if disabled.</p><p>    u.port('input', 'credit_refresh' , 1); // Refresh the Bucket Values</p><p>    u.port('input', 'credit_refresh_cycles' , 32); // Number of cycles to refresh the buckets after</p><p>    u.port('input', 'rateLmtRefCntGlobal', w_rateLmtRefCntGlobal);</p><p>    u.port('input', 'refreshAmtGlobal', w_refreshAmtGlobal);</p><p>    u.port('input', 'rateLmtBktGlobal',w_rateLmtBktQueue);</p><p>    for(let queue = 0; queue &lt; nQueue; queue++) {</p><p>         u.port('input', 'rateLmtRefCntQueue_p'+queue, w_rateLmtRefCntQueue[queue]);</p><p>         u.port('input', 'refreshAmtQueue_p'+queue, w_refreshAmtQueue[queue]);</p><p>         u.port('input', 'rateLmtBktQueue_p'+queue,w_rateLmtBktQueue[queue]);</p><p><br/></p><p>         u.port('input', 'rateLmtRefCntQueue_s'+queue, w_rateLmtRefCntQueue[queue]);</p><p>         u.port('input', 'refreshAmtQueue_s'+queue, w_refreshAmtQueue[queue]);</p><p>         u.port('input', 'rateLmtBktQueue_s'+queue,w_rateLmtBktQueue[queue]);</p><p>    }</p><p>}</p><p><br/></p></div><div><p><span class="inline-comment-marker" data-ref="7e46451a-060e-4e31-8565-b4d798beba33">u.interface('', 'slave', clkInterface, []); // This clock must be ungated</span></p><p><strong style="font-size: 20.0px;">Parameters</strong></p></div><p>{</p><p>   en: int, // Rate limiter is enabled</p><p>   wLen: int, // Width of the len field inside the packet</p><p>   useExternalValues : 0 or 1, // Indicates whether external values are to be used in place of rateLmtRefCntGlobal, rateLmtRefCntQueue, refreshAmtGlobal, refreshAmtQueue, wRateLmtBktGlobal, wRateLmtBktQueue</p><p>   widthOfControlSignals : {</p><p>       w_rateLmtRefCntGlobal&quot; : int, </p><p>       w_rateLmtRefCntQueue_p&quot; : [int, int, ...] , </p><p>       w_rateLmtRefCntQueue_s&quot; : [int, int, ...] , </p><p>       w_refreshAmtGlobal&quot;: int, </p><p>       w_refreshAmtQueue_p&quot; : [int, int, ...] , </p><p>       w_refreshAmtQueue_s&quot; : [int, int, ...] , </p><p>       w_rateLmtBktGlobal&quot; : int,</p><p>       w_rateLmtBktQueue_p&quot; :  [int, int, ...] , (0 == Disabled, No Limiting)</p><p>       w_rateLmtBktQueue_s&quot; :  [int, int, ...]  (0 == Disabled, No Limiting)</p><p>   }, // Used if useExternalValues == 1, Holds the widths of the respective control signals. Defined by CSR object above.</p><p>   maxPduSize: int, // The size of the maximum packet</p><p>   nQueue : int, // The number of queues that a transaction can be mapped to.</p><p>   rateLmtRefCntGlobal&quot; : int, // Rate of refresh for the global buckets in clock cycles</p><p>   rateLmtRefCntQueue_p&quot; : [int, int, ...] , //  Rate of refresh for the queue primary  buckets in clock cycles</p><p>   rateLmtRefCntQueue_s&quot; : [int, int, ...] , //  Rate of refresh for the queue secondary buckets in clock cycles</p><p>   refreshAmtGlobal&quot; : int, // The amount of bytes added to the bucket each refresh cycle</p><p>   refreshAmtQueue_p&quot; : [int, int, ...] , //  The amount of bytes added to the primary  bucket each refresh cycle</p><p>   refreshAmtQueue_s&quot; : [int, int, ...] , //  The amount of bytes added to the secondary  bucket each refresh cycle</p><p>   rateLmtBktGlobal&quot; : int, //  The total size of the global bucket</p><p>   rateLmtBktQueue_p&quot; :  [int, int, ...]  // The total size of the queue primary buckets (0 == Disabled, No Limiting)</p><p>   rateLmtBktQueue_s&quot; :  [int, int, ...]  // The total size of the queue  secondary buckets (0 == Disabled, No Limiting),</p><p>   blkClkGateOn : bool, // Indicates if clock gating is enabled</p><p>   testEn: bool, // Indicates if clk interface has a test en signal</p><p>   clkInterface : object, // The incoming Clock Interface</p><p>}</p><h1 id="HW-CTFsym_common_rate_limiter-ModulesUsed"><strong>Modules Used</strong></h1><p>prot_reg</p><p><strong style="font-size: 24.0px;">Description</strong></p><p><strong style="font-size: 24.0px;"><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="1200" src="https://arterisip.atlassian.net/wiki/download/attachments/16157308/image2020-12-14_11-27-30.png?api=v2"></span></strong></p><h2 id="HW-CTFsym_common_rate_limiter-Summary">Summary</h2><p>The rate limiter is able to keep track of global and queue level credits. The credits are used in a leaky bucket style fashion where each queue can have a primary (and possibly secondary) bucket that filled with a certain amount of credits at specific intervals. These buckets are depleted every time a transaction is selected for a queue. </p><p><br/></p></div><div class="wiki-content"><h2 id="HW-CTFsym_common_rate_limiter-Buckets">Buckets</h2><p>There are three optional buckets of parametrized size </p><p>1)      Global bucket -  tracks the request rate for all input queues</p><p>2)      Queue Primary Bucket - tracks the request rate per queue</p><p>3)      Queue Secondary Bucket - tracks the request rate per queue for a secondary demoted priority </p><p><strong>Bucket Size</strong></p><p>The max amount of credits a bucket can hold is either Math.pow(2,w_rateLmtBkt*) if useExternalValues = 1 or rateLmtBkt* if useExternalValues = 0. Once a bucket is filled with credits it will stay full until either a refresh indication or a transaction is selected.</p><p><strong>Bucket Refresh Rate</strong></p><p>The bucket will filled with a specific amount of credits on a periodic basis. The amount of credits either comes from a register if useExternalValues = 1 or comes from the refreshAmt* parameter value.</p><p>The refresh period either comes from registers if useExternalValues = 1 or comes from the rateLmtRefCnt* parameter values if useExternalValues = 0.</p><p><strong>Bucket Credit Decrements</strong></p><p>For every request selected by the arbiter, the corresponding bucket is decremented by the size of the transaction in bytes. So if queue_demote is asserted credits will be taken from the secondary queue, of not the credits will be taken from the primary queue. The credits are always taken out of the global queue. </p><p>The updated bucket amount does not have to be ready until the cycle after arbiter selection (timing critical path). A bucket is empty if  bucket size &lt;= maxPduSize, or &lt;= 2x maxPduSize (if a decrement pending)</p><p><strong>Bucket Demotion</strong></p><p>When the Primary Bucket for a queue is considered empty, the secondary bucket will be used which will send traffic at a demoted priority (as signaled by queue_demote). Once this secondary bucket is empty the queue cannot send anymore traffic. </p><p><strong>Credit Refresh</strong></p><p>All buckets will empty their credits and timers will reset if credit_refresh is asserted or every credit_refresh_cycles number of cycles if its non 0.</p><p>In addition all buckets will empty their credits and timers will reset if rate limiting is disabled through registers.</p><p><strong>Credit Refresh Period</strong></p><p>The credits and timers will be refresh as stated above every credit_refresh_cycles number of cycles. The counter for this period resets every credit_refresh_cycles and when rateLmtEn goes low.</p><h2 id="HW-CTFsym_common_rate_limiter-BucketControlLogicPathsPerQueue(TwoBuckets,OneBucket,OnlyGlobalBucket,NoBuckets)">Bucket Control Logic Paths Per Queue (Two Buckets, One Bucket, Only Global Bucket, No Buckets)</h2><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="1200" src="https://arterisip.atlassian.net/wiki/download/attachments/16157308/image2020-12-14_11-19-45.png?api=v2"></span></p><h2 id="HW-CTFsym_common_rate_limiter-ClockGating">Clock Gating</h2><p>The Rate Limiter block will gate its own clock if  the buckets aren't being used (either rate limiting is disabled through registers or all bucket sizes are set to 0 inside registers)</p></div></div><p><br/></p><p><br/></p><p><br/></p><p><br/></p><p><br/></p><div class="wiki-content"><br/></div>