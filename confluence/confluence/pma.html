<div class="wiki-content"><style>[data-colorid=v1yltty9fs]{color:#333333} html[data-color-mode=dark] [data-colorid=v1yltty9fs]{color:#cccccc}[data-colorid=ce4n5z2ocv]{color:#333333} html[data-color-mode=dark] [data-colorid=ce4n5z2ocv]{color:#cccccc}[data-colorid=wbwlqkg82r]{color:#333333} html[data-color-mode=dark] [data-colorid=wbwlqkg82r]{color:#cccccc}[data-colorid=skmclvk9oe]{color:#333333} html[data-color-mode=dark] [data-colorid=skmclvk9oe]{color:#cccccc}[data-colorid=p5p2kcy5dq]{color:#333333} html[data-color-mode=dark] [data-colorid=p5p2kcy5dq]{color:#cccccc}[data-colorid=aezsliv6w3]{color:#333333} html[data-color-mode=dark] [data-colorid=aezsliv6w3]{color:#cccccc}[data-colorid=fj1weh4mua]{color:#333333} html[data-color-mode=dark] [data-colorid=fj1weh4mua]{color:#cccccc}[data-colorid=zsrle7pn7m]{color:#333333} html[data-color-mode=dark] [data-colorid=zsrle7pn7m]{color:#cccccc}[data-colorid=wqwj6iuyqz]{color:#333333} html[data-color-mode=dark] [data-colorid=wqwj6iuyqz]{color:#cccccc}[data-colorid=p9gj4z27yj]{color:#333333} html[data-color-mode=dark] [data-colorid=p9gj4z27yj]{color:#cccccc}[data-colorid=dvbcfd1lkh]{color:#333333} html[data-color-mode=dark] [data-colorid=dvbcfd1lkh]{color:#cccccc}[data-colorid=dcuxen4txu]{color:#333333} html[data-color-mode=dark] [data-colorid=dcuxen4txu]{color:#cccccc}[data-colorid=fc15y9dh24]{color:#333333} html[data-color-mode=dark] [data-colorid=fc15y9dh24]{color:#cccccc}</style><h1 id="pma-Description"><strong>Description</strong></h1><p>PMA stands for Power Management Agent and is used for both clock and power domains. The PMA consists of two modules. The master module which accumulates the responses of the slave blocks and responds for the group of slaves as a whole, and the slave module is responsible for the status of a block of logic. This page first describes the master module and then the slave module.</p><h1 id="pma-Features"><strong>Features</strong></h1><p><strong>Master</strong></p><ul style="list-style-type: square;"><li>Supports Q Channel and P Channel for Master Interface.</li><li>Supports P/Q Channel for Slave Interface when Master Interface is P Channel.</li><li>Supports Q Channel for Slave Interface when Master&nbsp;Interface&nbsp;is Q Channel.</li><li>Supports two power states: 0 - Sleep Ready, 1 - Active</li><li>Can reset to either state based on STATE/REQn signals at reset deassertion.</li><li>Supports top level abort for Q Powerdown requests.</li><li>No theoretical limit for number of slaves.</li><li>Supports protection for internal state.</li></ul><p><strong>Slave</strong></p><ul><li>Supports Q or P Channel Interfacef\</li><li>Supports two power states: 0 - Sleep Ready, 1 - Active</li><li>Configurable timeout timer for power down requests through APB or JSON..</li><li>Supports abort from block level for P/Q powerdown requests.</li><li>Supports protection for internal state and APB register (separate interfaces).</li></ul><h1 id="pma-Interfaces"><strong>Interfaces</strong></h1><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16168995/InterfacePQChannel" data-linked-resource-id="16168995" data-linked-resource-version="6" data-linked-resource-type="page">InterfacePQChannel</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16164503/InterfacePMAControl" data-linked-resource-id="16164503" data-linked-resource-version="6" data-linked-resource-type="page">InterfacePMAControl</a></p><h1 id="pma-Specification"><strong>Specification</strong></h1><p><a class="unresolved" href="#">ARM P/Q-Channel Specification</a></p><h1 id="pma-module_name"><strong>module_name</strong></h1><div class="page view"><div class="wiki-content"><p>pma_master</p><h1 id="pma-parameters"><strong>parameters</strong></h1><h2 id="pma-java_script:"><strong>java_script:</strong></h2><pre>{&nbsp; &nbsp; &nbsp; &nbsp; </pre><pre>        &quot;masterChannel&quot; : P or Q,
</pre><pre>        &quot;slaveChannel&quot; : P or Q,</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; &quot;syncReq&quot; : Y or N,</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; &quot;syncAcceptDeny&quot; : Y or N,</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; &quot;assertOn&quot; : Y or N,</pre><pre>        &quot;interfaces&quot; : {</pre><pre>            &quot;clkInterface&quot; : {InterfaceCLK},&nbsp;</pre><pre>&nbsp;           &quot;masterInterface&quot; :&nbsp;{InterfacePQChannel}, </pre><pre class="wiki-content">            &quot;slaveInterfaces&quot; : [{InterfacePQChannel},,,], // array of slave interfaces (All must be P or Q)</pre><pre class="wiki-content">            &quot;protectionInterface&quot; : {InterfacePROT} // optional, expected if protectionStyle is not null</pre><pre class="wiki-content">         },<span>&nbsp;</span></pre><pre>&nbsp;       &quot;protectionStyle&quot; : &quot;&quot; or&nbsp;{<a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16169044/protectionStyle" data-linked-resource-id="16169044" data-linked-resource-version="15" data-linked-resource-type="page">protectionStyle</a>}</pre><pre><span>}</span></pre><p>Note: The only supported combinations of masterChannel and slaveChannel will be (P,P),(Q,Q),(P,Q)</p><h2 id="pma-Example:"><strong>Example:</strong></h2><p><strong><br /></strong></p><div><pre>{<br />        &quot;masterChannel&quot; : &quot;Q&quot;,<br />        &quot;slaveChannel&quot; : &quot;Q&quot;,<br />        &quot;syncReq&quot; : &quot;Y&quot;,<br />        &quot;syncAcceptDeny&quot; : &quot;Y&quot;,</pre><pre>        &quot;assertOn&quot; : &quot;N&quot;<br />        &quot;interfaces&quot;: {<br />             &quot;clkInt&quot;:    {<br />                             &quot;name&quot;: &quot;a_&quot;,<br />                             &quot;params&quot;: {},<br />                             &quot;direction&quot;: &quot;slave&quot;,<br />                             &quot;interface&quot;: &quot;InterfaceCLK&quot;<br />                          },<br />             &quot;masterInt&quot;: {<br />                             &quot;name&quot;: &quot;pma_master_&quot;,<br />                             &quot;params&quot;: {<br />                                        &quot;wActive&quot; : 1, &quot;channelType&quot; : &quot;Q&quot;<br />                                       },<br />                             &quot;direction&quot;: &quot;slave&quot;,<br />                             &quot;interface&quot;: &quot;InterfacePQChannel&quot;<br />                          },<br />             &quot;slaveInterfaces&quot; : [<br />                                   {<br />                                       &quot;name&quot;: &quot;pma_slave_0_&quot;,<br />                                       &quot;params&quot;: { &quot;wActive&quot; : 1, &quot;channelType&quot; : &quot;Q&quot; },</pre><pre>                                       &quot;direction&quot;: &quot;master&quot;,<br />                                       &quot;interface&quot;: &quot;InterfacePQChannel&quot;<br />                                   },<br />                                   {<br />                                       &quot;name&quot;: &quot;pma_slave_1_&quot;,<br />                                       &quot;params&quot;: { &quot;wActive&quot; : 1, &quot;channelType&quot; : &quot;Q&quot;},</pre><pre>                                       &quot;direction&quot;: &quot;master&quot;,<br />                                       &quot;interface&quot;: &quot;InterfacePQChannel&quot;<br />                                   },<br />                                   {<br />                                       &quot;name&quot;: &quot;pma_slave_2_&quot;,<br />                                       &quot;params&quot;: { &quot;wActive&quot; : 1, &quot;channelType&quot; : &quot;Q&quot; },</pre><pre>                                       &quot;direction&quot;: &quot;master&quot;,<br />                                       &quot;interface&quot;: &quot;InterfacePQChannel&quot;<br />                                   }<br />                                  ]<br />                                }, <br />          &quot;protectionStyle&quot; : null<br />}</pre></div><h1 id="pma-I/O"><strong>I/O</strong></h1><p>u.nInterfaces(interfaces);</p><pre><strong style="font-size: 24.0px;font-family: Arial , sans-serif;">Functions Used</strong></pre><p>none</p><h1 id="pma-ModulesUsed"><strong>Modules Used</strong></h1><p>logic_tree</p><p>dffre</p><p>dffr_sync</p><p>sym_reg</p><h1 id="pma-Resets"><strong>Resets</strong></h1><p>On reset the PMA_m will reset all state machines to the IDLE state. The controlling block must ensure that the proper REQn/STATE is held for enough cycles before reset deassertion for the proper value to propagate through the PMA_m and PMA_s's syncs..&nbsp;(cycles = depth of PMA_m sync + depth of PMA_s sync + slave_REQn/STATE Flop)</p><h1 id="pma-NonReset-ableFlops"><strong>Non </strong><span style="font-size: 24.0px;"><strong>Reset-able</strong></span><strong>&nbsp;Flops</strong></h1><p>The REQn sync (Q Master Channel) , slave_REQn flops (Q Slave Channel)&nbsp;, STATE flop (P Master Channel), and slave_STATE flops&nbsp;(P Slave Channel) will not have a connected reset. The REQn/STATE value must propagate through the block during reset so all blocks go to the same state upon reset deassertion.&nbsp;</p><p>&nbsp;</p><p><strong style="font-size: 20.0px;">Master Logic Description</strong>:</p><p>The master module accumulates the responses of the slave blocks and responds for the group of slaves as a whole in addition to broadcasting any requests to all slaves.</p><p>Note: A single register will hold all state information and will be connected to the protection interface.&nbsp;</p><p>Note: A P-Channel&nbsp;Power Down&nbsp;Request CANNOT&nbsp;be aborted externally&nbsp;(deassert REQ before an ACCEPT or DENY)</p><p>Note: A Q-Channel Power Down Request CAN be aborted externally (deassert REQn before an ACCEPTn or DENY)</p><h3 id="pma-Q-InQ-OutChannelMode">Q-In Q-Out Channel Mode</h3><p>slave_REQn bits will be the synced reqn value.</p><p>In order to assert ACCEPTn all slave_ACCEPTn bits must assert and reqn must be asserted.</p><p>If any of the slave_DENY bits assert the PMA will assert DENY when all slaves have responded. The assertion of DENY will cause REQn to deassert causing slave_REQn to deassert. DENY cannot deassert until all slaves enter back into the running state.(DENY - Low, ACCEPTn - High)</p><p>ACTIVE is simply an OR of all the slave_ACTIVE signals.</p><h3 id="pma-"><span data-colorid="v1yltty9fs" style="text-decoration: none;"><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="750" src="https://arterisip.atlassian.net/wiki/download/attachments/16166820/image2018-9-13%2015:5:10.png?api=v2" /></span>&nbsp;</span></h3><h3 id="pma-P-InP-OutChannelMode">P-In P-Out Channel Mode</h3><p><span data-colorid="dvbcfd1lkh" style="text-decoration: none;">In P-Channel master mode the block will create a P-Interface for each slave and will broadcast&nbsp; any request on the P-Channel. The block will wait until all P-Channels accept, or for a denial to occur before a response is sent back upstream.&nbsp;</span></p><p><span data-colorid="dcuxen4txu" style="text-decoration: none;">If a slave device denies a request then the block will revert each slave to the previous state. The block will not complete the request until all slave channels have gone to the previous state.</span></p><p><span data-colorid="p5p2kcy5dq" style="text-decoration: none;">This logic has 4 states:</span></p><p><span data-colorid="wqwj6iuyqz" style="text-decoration: none;">1) Idle</span></p><p><span data-colorid="ce4n5z2ocv" style="text-decoration: none;">2) Request</span></p><p><span data-colorid="wbwlqkg82r" style="text-decoration: none;">3) Sucess</span></p><p><span data-colorid="aezsliv6w3" style="text-decoration: none;">4) Wait&nbsp;</span></p><p><span data-colorid="fc15y9dh24" style="text-decoration: none;">When in the &quot;Idle&quot; state the PMA is waiting for REQ to assert. When it asserts the PMA will move into the &quot;Request&quot; state.</span></p><p><span data-colorid="fj1weh4mua" style="text-decoration: none;">In the &quot;Request&quot; state the PMA will assert REQ to all slave P Channels and the slave_STATE will be populated from the incoming STATE.</span></p><p><u><span data-colorid="zsrle7pn7m" style="text-decoration: none;">Success Sequence</span></u></p><p><span data-colorid="p9gj4z27yj" style="text-decoration: none;">Once in the &quot;Request&quot; state ACCEPT will assert once all slave interfaces assert their respective slave_ACCEPT signals. Once all of the slave_ACCEPT signals assert the PMA will move to the &quot;Success&quot; state.</span></p><p><span data-colorid="skmclvk9oe" style="text-decoration: none;">In the &quot;Success&quot; state the PMA will deassert slave_REQ to all of the slaves and then wait for all the slaves to deassert slave_ACCEPT in addition to REQ deasserting. Once those conditions are satisfied the PMA will move back to the Idle state.</span>&nbsp;</p><p>In the &quot;Idle&quot; state ACCEPT will deassert.</p><p><u>Deny Sequence</u></p><p>In the &quot;Request&quot; state DENY could also assert once a slave channel asserts its slave_DENY signal. Once this occurs the PMA will assert DENY and wait until all slaves respond.</p><p>Once all slaves respond the PMA will move to the &quot;Wait&quot; state where slave_REQ will be deasserted. Once all slaves have deasserted their slave_DENY/slave_ACCEPT signals and REQ deasserts and the PMA will move back to the &quot;Request&quot; state.&nbsp;</p><p>At the deassertion of REQ STATE has to be driven to the previous state from the up stream P-Channel control block. This means when slave_REQ asserts in the &quot;Request&quot; state the PMA is moving all the slaves back to their previous state.</p><p><span>Once all of the slave_ACCEPT signals assert the PMA will move to the &quot;Success&quot; state.</span></p><p><span>In the &quot;Success&quot; state the PMA will deassert slave_REQ to all of the slaves and then wait for all the slaves to deassert slave_ACCEPT. Once those conditions are satisfied the PMA will move to the &quot;Idle&quot; state.</span>&nbsp;</p><p>In the &quot;Idle&quot; state DENY will deassert.</p><h4 id="pma-SuccessSequence">Success Sequence</h4><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="1600" src="https://arterisip.atlassian.net/wiki/download/attachments/16166820/image2018-8-8%2017:8:7.png?api=v2" /></span></p><h4 id="pma-DenySequence">Deny Sequence</h4><div><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="1600" src="https://arterisip.atlassian.net/wiki/download/attachments/16166820/image2018-8-8%2017:6:34.png?api=v2" /></span></div><div><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="1200" src="https://arterisip.atlassian.net/wiki/download/attachments/16166820/image2018-9-13%2014:56:20.png?api=v2" /></span></div><div>Note: At reset STATE must be driven to the corresponding resetState given through configuration parameters.&nbsp;</div><p>Note: (From P Chanel Spec) When the outside controller sees the DENY signal STATE must revert to the previous state before REQ deasserts.</p><h3 id="pma-P-InQ-OutChannelMode">P-In Q-Out Channel Mode</h3><p>Working diagram moving the P-Slave logic up to the master for each of the slaves.</p><p><strong>Success Sequence</strong></p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="1600" src="https://arterisip.atlassian.net/wiki/download/attachments/16166820/image2018-9-5%2010:58:3.png?api=v2" /></span></p><p><strong>Fail Sequence</strong></p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="1600" src="https://arterisip.atlassian.net/wiki/download/attachments/16166820/image2018-9-5%2010:58:29.png?api=v2" /></span></p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="1200" src="https://arterisip.atlassian.net/wiki/download/attachments/16166820/image2018-9-13%2014:57:24.png?api=v2" /></span></p><p>&nbsp;</p><h1 id="pma-FlopandCellCounts@1.6GHz(Cell/Flop)"><strong>Flop and Cell Counts @ 1.6GHz&nbsp;(Cell/Flop)</strong></h1><h3 id="pma-MasterConfiguration(w/ARMrecommendedsyncsonports)">Master Configuration&nbsp; (w/ ARM recommended syncs on ports)</h3><div><p>&nbsp;</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th style="text-align: center;" class="confluenceTh">Interface</th><th style="text-align: center;" class="confluenceTh">2 Slaves</th><th style="text-align: center;" class="confluenceTh">4 Slaves</th><th style="text-align: center;" class="confluenceTh">8 Slaves</th><th colspan="1" style="text-align: center;" class="confluenceTh">X Slaves</th></tr><tr><td style="text-align: center;" class="confluenceTd">Q in, Q out</td><td style="text-align: center;" class="confluenceTd">22/15</td><td style="text-align: center;" class="confluenceTd">33/25</td><td style="text-align: center;" class="confluenceTd">60/45</td><td colspan="1" style="text-align: center;" class="confluenceTd">Flops: (5 + 5*X)</td></tr><tr><td style="text-align: center;" class="confluenceTd">P in, P out (Parity on 3 State bits)</td><td style="text-align: center;" class="confluenceTd">38/24</td><td style="text-align: center;" class="confluenceTd">52/36</td><td style="text-align: center;" class="confluenceTd">88/60</td><td colspan="1" style="text-align: center;" class="confluenceTd">Flops: (12 + 6*X)</td></tr><tr><td colspan="1" class="confluenceTd">P in, Q out (Parity on 5 State bits)</td><td colspan="1" style="text-align: center;" class="confluenceTd">37/22</td><td colspan="1" style="text-align: center;" class="confluenceTd">48/32</td><td colspan="1" style="text-align: center;" class="confluenceTd">75/52</td><td colspan="1" style="text-align: center;" class="confluenceTd">Flops: (12 + 5*X)</td></tr></tbody></table></div><p>&nbsp;</p><h1 id="pma-module_name.1"><strong>module_name</strong></h1><div class="page view"><div class="wiki-content"><p>pma_slave</p><h1 id="pma-parameters.1"><strong>parameters</strong></h1><h2 id="pma-java_script:.1"><strong>java_script:</strong></h2><pre>{</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; &quot;channel&quot; : P or Q,
</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; &quot;timeoutDelay&quot; &nbsp;: &nbsp;0 or any positive integer. 0 indicates no timeout delay., // Ignored if configurable == &quot;Y&quot;</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; &quot;delayDecClkCnt&quot; : any positive integer, // Ignored if configurable == &quot;Y&quot;</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; &quot;configurable&quot; : Y or N,</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; &quot;slaveAbort&quot; : Y or N,</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; &quot;syncReq&quot; : Y or N,</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; &quot;activeWidth&quot; : any positive integer,</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; &quot;assertOn&quot; : Y or N,</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; &quot;CSR&quot; : {register definition object},</pre><pre>&nbsp;       &quot;regProtectionStyle&quot; : &quot;&quot; or&nbsp;{<a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16169044/protectionStyle" data-linked-resource-id="16169044" data-linked-resource-version="15" data-linked-resource-type="page">protectionStyle</a>},</pre><pre>&nbsp;       &quot;stateProtectionStyle&quot; : &quot;&quot; or&nbsp;{<a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16169044/protectionStyle" data-linked-resource-id="16169044" data-linked-resource-version="15" data-linked-resource-type="page">protectionStyle</a>},</pre><pre>        &quot;interfaces&quot; : {</pre><pre>            &quot;clkInt&quot; : {InterfaceCLK},&nbsp;</pre><pre>            &quot;apbInt&quot; : {InterfaceAPB},&nbsp;// optional, expected if configurable = &quot;Y&quot;</pre><pre>&nbsp;           &quot;masterInt&quot; :&nbsp;{InterfacePQChannel},</pre><pre class="wiki-content">            &quot;pmaControlInt&quot; :{InterfacePMAControl}, </pre><pre class="wiki-content">            &quot;regProtectionInt&quot; : {InterfacePROT}, // optional, expected if regProtectionStyle is not null</pre><pre class="wiki-content">            &quot;stateProtectionInt&quot; : {InterfacePROT} // optional, expected if stateProtectionStyle is not null</pre><pre class="wiki-content">         },&nbsp;</pre><pre>}</pre><h2 id="pma-Example:.1"><strong>Example:</strong></h2><pre>{<br />         &quot;channel&quot; : &quot;Q&quot;,<br />         &quot;timeoutDelay&quot; : 250,<br />         &quot;delayDecClkCnt&quot; : 250,<br />         &quot;configurable&quot; : &quot;Y&quot;,<br />         &quot;assertOn&quot; : &quot;N&quot;,<br />         &quot;slaveAbort&quot; : &quot;Y&quot;,<br />         &quot;syncReq&quot; : &quot;Y&quot;,<br />         &quot;interfaces&quot;: {<br />             &quot;clkInt&quot;:        {<br />                                &quot;name&quot;: &quot;a_&quot;,<br />                                &quot;params&quot;: {},<br />                                &quot;direction&quot;: &quot;slave&quot;,<br />                                &quot;interface&quot;: &quot;InterfaceCLK&quot;<br />                       },<br />             &quot;apbInt&quot;:        {<br />                                &quot;name&quot;: &quot;pma_apb_&quot;,<br />                                 &quot;params&quot;: {<br />                                            &quot;wAddr&quot;: 12,<br />                                            &quot;wData&quot;: 32,<br />                                            &quot;wPSlverr&quot;: 1<br />                                           },<br />                                 &quot;direction&quot;: &quot;slave&quot;,<br />                                 &quot;interface&quot;: &quot;InterfaceAPB&quot;<br />                              },<br />             &quot;masterInt&quot;:     {<br />                                 &quot;name&quot;: &quot;pma_master_&quot;,<br />                                 &quot;params&quot;: {&quot;wActive&quot; : 1, &quot;channelType&quot; : &quot;Q&quot;},</pre><pre>                                 &quot;direction&quot;: &quot;slave&quot;,<br />                                 &quot;interface&quot;: &quot;InterfacePQChannel&quot;<br />                              },<br />             &quot;pmaControlInt&quot;: {<br />                                 &quot;name&quot;: &quot;pma_ctl_&quot;,<br />                                 &quot;params&quot;: {},<br />                                 &quot;direction&quot;: &quot;master&quot;,<br />                                 &quot;interface&quot;: &quot;InterfacePMAControl&quot;<br />                              }<br />                         },<br />          &quot;activeWidth&quot; : 1,<br />          &quot;regProtectionStyle&quot; : null,<br />          &quot;stateProtectionStyle&quot; : null,<br />          &quot;CSR&quot; :&nbsp;[CSR Object]<br />}</pre><h1 id="pma-I/O.1"><strong>I/O</strong></h1><p>u.nInterfaces(interfaces);</p><h1 id="pma-FunctionsUsed"><strong>Functions Used</strong></h1><p>symGetEccWidth</p><p>log2ceil</p><p>getHWPortsCSR</p><h1 id="pma-ModulesUsed.1"><strong>Modules Used</strong></h1><p>logic_tree</p><p>dffre</p><p>dffr_sync</p><p>sym_apb_csr</p><p>sym_reg</p><h1 id="pma-Registers(IfConfigurable)"><strong>Registers (If Configurable)</strong></h1><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th class="confluenceTh">Offset</th><th colspan="1" class="confluenceTh">Name</th><th colspan="1" class="confluenceTh">Field</th><th colspan="1" class="confluenceTh">Start</th><th colspan="1" class="confluenceTh">Width</th><th class="confluenceTh">SW Access</th><th colspan="1" class="confluenceTh">HW Access</th><th class="confluenceTh">Reset</th><th class="confluenceTh">Description</th></tr><tr><td class="confluenceTd">0x0</td><td colspan="1" class="confluenceTd">PMA_TMR_TIMEOUT</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td class="confluenceTd">&nbsp;</td><td class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">timeoutDelay&nbsp;</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">timeoutDelayWidth (defined by CSR object)</td><td colspan="1" class="confluenceTd">RW&nbsp;</td><td colspan="1" class="confluenceTd">RO</td><td colspan="1" class="confluenceTd">Max Value</td><td colspan="1" class="confluenceTd">Timeout Delay Value</td></tr><tr><td colspan="1" class="confluenceTd">0x4</td><td colspan="1" class="confluenceTd">PMA_TMR_DELAY</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">delayDecClkCnt&nbsp;</td><td colspan="1" class="confluenceTd">0</td><td colspan="1" class="confluenceTd">delayDecClkCntWidth (defined by CSR object)</td><td colspan="1" class="confluenceTd">RW&nbsp;</td><td colspan="1" class="confluenceTd">RO</td><td colspan="1" class="confluenceTd">0x1</td><td colspan="1" class="confluenceTd">Amount of clock cycles per timeoutDelay decrement.</td></tr></tbody></table></div><h1 id="pma-Reset"><strong>Reset</strong></h1><p>The PMA_s will reset to the state indicated by REQn/STATE when reset deasserts. (1 - On, 0 - Sleep) The controlling block must ensure that the proper REQn/STATE is held for enough cycles before reset deassertion for the proper value to propagate through the PMA_s's syncs (cycles = depth of sync)..</p><h1 id="pma-NonReset-ableFlops.1"><strong>Non&nbsp;</strong><strong>Reset-able</strong><strong>&nbsp;Flops</strong></h1><p>The REQn sync (Q Channel), STATE flop (P Channel) will not have a connected reset. The REQn/STATE value must propagate through the block during reset.&nbsp;</p><p>&nbsp;</p><p><strong style="font-size: 20.0px;">Slave Logic Description</strong><span style="font-size: 20.0px;font-weight: normal;">:</span></p><p>The slave module is responsible for the status of a block of logic and interfaces with an upstream power controller or PMA_m.&nbsp;</p><p>Note: There are two protection interfaces. One for the configurable registers and one for register which holds the state.</p><p>Note: A P-Channel Power Down Request CANNOT&nbsp;be aborted externally (deassert REQ before an ACCEPT or DENY)</p><p>Note: A Q-Channel Power Down Request CAN be aborted externally (deassert REQn before an ACCEPTn or DENY)</p><h3 id="pma-SlaveBlockInterface">Slave Block Interface</h3><p>&nbsp; output asleep - Indication that the block is powered down and is in the &quot;Sleep&quot; state,</p><p>&nbsp; output goto_sleep - Asserted when the PMA receives a powerdown request from its master. Will deassert once the the request is complete and the PMA goes into the &quot;sleep&quot; state or when the request is denied and the PMA goes back to the &quot;Active&quot; state.&nbsp;</p><p>&nbsp; input busy - Signal driven by the slave unit indicating the block is still active and is tied to the ACTIVE output. The PMA will only transition to the &quot;Sleep&quot; state once busy deasserts.</p><p>&nbsp; input abort - Signal driven by the slave unit indicating the block should automatically deny the power state change request. This signal will be checked the cycle after goto_sleep asserts.</p><h4 id="pma-SlaveInterfaceFunctionalBehavior(TakenfromP-ChannelSlaveMode)">Slave Interface Functional Behavior (Taken from P-Channel Slave Mode)&nbsp;</h4><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="1600" src="https://arterisip.atlassian.net/wiki/download/attachments/16166820/image2018-7-31%2015:17:5.png?api=v2" /></span></p><h3 id="pma-QChannelMode"><span>Q Channel Mode</span></h3><p>The slave logic has five states:</p><p>&nbsp; 1) active</p><p>&nbsp; 2) entering sleep</p><p>&nbsp; 3) sleep</p><p>&nbsp; 4) aborting sleep</p><p>&nbsp; 5) exiting sleep&nbsp;</p><p>When in &quot;active&quot; state, REQn must be deasserted, ACCEPTn must be deasserted and DENY must be deasserted. This can be a reset state, but the inputs must match the state requirements.</p><p>When entering the &quot;active&quot; state the output asleep will deassert.</p><p>When in the &quot;active&quot; state, the output goto_sleep is asserted when REQn is asserted. goto_sleep is only asserted in this state and in the &quot;entering sleep&quot; state.</p><p>The block enters &quot;entering sleep&quot; when REQn asserts. It is considered in that state until either ACCEPTn (!busy) asserts, DENY (tdcz | abort) asserts or REQn (qreqn_sync) deasserts.</p><p>When in the &quot;entering sleep&quot; state&nbsp;and the input REQn deasserts before ACCEPTn or DENY asserts, the logic returns to active state.</p><p>ACCEPTn can only assert under two conditions:1) when the block is in the &quot;entering sleep&quot; state and the busy input is deasserted. If this occurs the logic enters &quot;sleep&quot; state. 2) When reset is asserted</p><p>DENY can only assert if the block is 1) in &quot;entering sleep&quot; state, 2) the timer function and/or abort function is enabled, and 3) the timer reaches 0 and busy input is asserted (if timer is enabled) or abort is asserted (if abort is enabled). If this occurs the logic enters &quot;aborting sleep&quot; state.&nbsp;</p><p><span>In &quot;aborting sleep&quot; state, the block waits for REQn to deassert. When REQn deasserts, the block enters &quot;active&quot; state.</span></p><p><span>When entering the &quot;sleep&quot; state, the output asleep will assert.</span></p><p>When in the &quot;sleep&quot; state, ACCEPTn must be asserted, REQn must be asserted, DENY must be deasserted, ACTIVE must be deasserted and busy must be deasserted.&nbsp;This can be a reset state but the inputs must match the state requirements.</p><p>When in the &quot;sleep&quot; state, if&nbsp;<span>REQn&nbsp;</span>deasserts then the block enters &quot;exiting sleep&quot; state.</p><p>In &quot;exiting sleep&quot; state, the block deasserts ACCEPTn and enters &quot;active&quot; state.</p><p>Having a timeout_delay other than 0 only makes sense in the slave mode. Having the ability to configure the logic only makes sense when timeout_delay is greater than 0. Delay_dec_clk_cnt describes the number of clocks on input clk for every decrement the counter. When configuration is enabled, both timeout_delay and delay_dec_clk_cnt can be configured. The number of bits in the counter is controlled the number of bits needed to implement timeout_delay. The same is true for delay_dec_clk_cnt.</p><h4 id="pma-Q-InterfaceFunctionalBehavior">Q-Interface Functional Behavior</h4><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="https://arterisip.atlassian.net/wiki/download/attachments/16166820/image2018-7-20%2015:1:7.png?api=v2" /></span></p><h4 id="pma-Q-InterfaceResetBehavior">Q-Interface Reset Behavior</h4><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="https://arterisip.atlassian.net/wiki/download/attachments/16166820/image2018-7-20%2015:1:48.png?api=v2" /></span></p><h4 id="pma-Q-InterfaceImplementation">Q-Interface Implementation</h4><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="1000" src="https://arterisip.atlassian.net/wiki/download/attachments/16166820/image2018-9-12%2017:3:0.png?api=v2" /></span></p><p>Note: that the synchronizer on the incoming REQn signal and the outbound flops are only needed if this block is set up to use a Q-Interface.</p><p><span>Note: The two counters will reset to their appropriate configured values and count down to 0</span></p><h3 id="pma-PChannelMode"><span>P</span><span>&nbsp;Channel Mode</span></h3><p><span>Since only two P-States are supported the block will convert the P request to the equivalent Q channel request. Functionally a P2Q converter will be used to drive the logic described in Q-Channel mode.</span></p><p><span>If at any time it is decided more than two states are needed the Q Channel + P2Q Converter can be replaced with specialized P-Channel state logic.</span></p><p><span>Note: The P-Channel transaction cannot be aborted early by the master side like Q-Channel.</span></p><h4 id="pma-P-InterfaceFunctionalBehavior"><span>P-Interface Functional Behavior<br /></span></h4><p><span><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="700" src="https://arterisip.atlassian.net/wiki/download/attachments/16166820/image2018-7-20%2015:6:12.png?api=v2" /></span></span></p><h3 id="pma-P-InterfaceResetBehavior"><span>P-Interface Reset Behavior</span></h3><p><span><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="650" src="https://arterisip.atlassian.net/wiki/download/attachments/16166820/image2018-7-20%2015:7:25.png?api=v2" /></span></span></p><h3 id="pma-P-InterfaceImplementation">P-Interface Implementation</h3><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="1300" src="https://arterisip.atlassian.net/wiki/download/attachments/16166820/image2018-9-10%2016:52:29.png?api=v2" /></span></p><p>Note: This circuit assumes there is only 2 STATEs: 0 == OFF, 1 == ON</p><p>Note: (From Q/P Chanel Spec) STATE is captured when 1) REQ is deasserted/qdeny is asserted and 2) when REQ is asserted</p><p>Note: (From Q/P Chanel Spec) When the outside controller sees the DENY signal STATE must revert to the previous state before REQ deasserts.</p><p>&nbsp;</p><p>Note: At reset STATE must be driven to the corresponding resetState given through configuration parameters.&nbsp;</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="900" src="https://arterisip.atlassian.net/wiki/download/attachments/16166820/image2018-9-10%2010:27:12.png?api=v2" /></span></p><p>Note: The no_change signal is to detect if the requested state is the same as the state the device is already in. In this case the Q-Logic may never assert QACCEPTn so ACCEPT has to be asserted manually.&nbsp;</p><h1 id="pma-FlopandCellCounts@1.6GHz(Cell/Flop).1"><strong>Flop and Cell Counts @ 1.6GHz&nbsp;(Cell/Flop)</strong></h1><h3 id="pma-SlaveConfiguration(w/ARMrecommendedsyncsonports+DENYFlop)">Slave Configuration (w/ ARM recommended syncs on ports + DENY Flop)</h3><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th class="confluenceTh">Interface</th><th class="confluenceTh">Base</th><th class="confluenceTh">+ 8 bit timeoutDelay/delayDecCnt (Parity Protection)</th><th class="confluenceTh">+ Configurable 8 bit timeoutDelay/delayDecCnt (Parity Protection)</th></tr><tr><td style="text-align: center;" class="confluenceTd">Q (Parity on 4 State Bits)</td><td style="text-align: center;" class="confluenceTd">22/9</td><td style="text-align: center;" class="confluenceTd">45/29</td><td style="text-align: center;" class="confluenceTd">101/47</td></tr><tr><td style="text-align: center;" class="confluenceTd">P <span>(Parity on 6 State Bits)</span></td><td style="text-align: center;" class="confluenceTd">35/14</td><td style="text-align: center;" class="confluenceTd">58/34</td><td style="text-align: center;" class="confluenceTd">116/53</td></tr></tbody></table></div><p>&nbsp;</p><h1 id="pma-CommonSystemVerilogFunctionalAssertions"><strong>Common SystemVerilog Functional Assertions&nbsp;</strong></h1><h2 id="pma-P-Channel"><strong>P-Channel</strong></h2><p><strong><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="600" src="https://arterisip.atlassian.net/wiki/download/attachments/16166820/image2018-7-31%2017:11:3.png?api=v2" /></span></strong></p><p>posREQ:&nbsp; &nbsp; &nbsp; &nbsp;assert property (@(posedge REQ)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;!ACCEPT &amp; !DENY);<br />negREQ:&nbsp; &nbsp; &nbsp; &nbsp;assert property (@(negedge REQ)&nbsp; &nbsp; &nbsp; &nbsp; ((ACCEPT &amp; !DENY) | (!ACCEPT &amp; DENY)));<br />chSTATE:&nbsp; &nbsp; &nbsp; assert property (@(STATE)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*<span class="legacy-color-text-red2"><s>!REQ &amp;</s></span> !ACCEPT &amp; !DENY) | ((REQ &amp; DENY) &amp; (!ACCEPT)));<br />posACCEPT: assert property (@(posedge ACCEPT)&nbsp; (REQ &amp; !DENY));<br />negACCEPT: assert property (@(negedge ACCEPT) (!REQ &amp; !DENY));<br />posDENY:&nbsp; &nbsp; &nbsp; assert property (@(posedge DENY)&nbsp; &nbsp; &nbsp; (REQ &amp; !ACCEPT));<br />negDENY:&nbsp; &nbsp; &nbsp; assert property (@(negedge DENY)&nbsp; &nbsp; &nbsp;(!REQ &amp; !ACCEPT));<br />stateCheck:&nbsp; &nbsp;assert property (@(negedge DENY or negedge ACCEPT) ((STATE) ? (!asleep) : (asleep)));</p><p>&nbsp;</p><div><div class="page view"><div class="wiki-content"><p>*This condition describes when STATE asserts to abort a powerdown. In theory this breaks P Channel Spec on the Power Manager side, however as long as the behavior is properly described it should be permissible.&nbsp;</p></div></div></div><h2 id="pma-Q-Channel"><strong>Q-Channel</strong></h2><div><strong><br /></strong></div><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="600" src="https://arterisip.atlassian.net/wiki/download/attachments/16166820/image2018-7-31%2017:12:32.png?api=v2" /></span></p><p>negREQn:&nbsp; &nbsp; &nbsp; &nbsp; assert property (@(negedge REQn)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ACCEPTn &amp; !DENY);<br />posREQn:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;assert property (@(posedge REQn)&nbsp; &nbsp; &nbsp; &nbsp; (!ACCEPTn &amp; !DENY) | (ACCEPTn &amp; DENY) &nbsp;<span class="legacy-color-text-red2">*| (ACCEPTn &amp; !DENY)</span>);<br />negACCEPTn : assert property (@(negedge ACCEPTn)&nbsp; !REQn &amp; !DENY);<br />posACCEPTn: assert property&nbsp; (@(posedge ACCEPTn)&nbsp; &nbsp;REQn &amp; !DENY);<br />negDENY:&nbsp; &nbsp; &nbsp; &nbsp; assert property (@(negedge DENY)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; REQn &amp; ACCEPTn);<br />posDENY:&nbsp; &nbsp; &nbsp; &nbsp; assert property (@(posedge DENY)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;!REQn &amp; ACCEPTn);<br />stateCheck:&nbsp; &nbsp; &nbsp;assert property (@(ACCEPTn) ((REQn) ? !asleep : asleep));</p><p>*This condition describes when REQn deasserts to abort a powerdown. In theory this breaks Q Channel Spec on the Power Manager side, however as long as the behavior is properly described it should be permissible.&nbsp;</p></div></div></div><p><strong><br /></strong></p></div></div></div>