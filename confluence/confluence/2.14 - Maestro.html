<p>The Symphony design flow is driven by a software cockpit named Maestro.</p><p>Maestro comprises a <em>client</em> component and a <em>server</em> component.</p><ul><li>The client component includes all designer-visible functionality, including a GUI as well as a TCL scripting interface. The client oversees specification entry, design definition, design refinement, and design checking.</li><li>The server component, which can be running at Arteris or on-premises depending on the license agreements, is invoked during the design flow to generate RTL and collaterals, which are then downloaded onto the client’s filesystem.</li></ul><p> <span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16169664/image2019-11-8%2014:48:51.png?api=v2"></span>Maestro client/server design</p><p>The Maestro flow encompasses a sequence of design actions, driven by the user and assisted by Maestro. In detail, the flow (see Figure <span class="legacy-color-text-orange2">XXXX</span>) comprises:</p><ol><li>Chip Specification, which defines clock and power regions, and (in upcoming releases) floorplan inputs.</li><li>System Assembly, which defines sockets, connectivity requirements and memory maps, and (in upcoming releases) subsystem composition and decomposition.</li><li>Architectural Design, which is the step during which one or multiple solutions are conceived to implement the requirements. The creation is either fully manual or assisted by Maestro; for example, see 2.1.2 on how Maestro can create a fully-connected regular topology to realize the connectivity.</li><li>Mapping, which casts the solution(s) of the previous point into specific versions of specific components in the Arteris IP library. This step is currently fully automatic.</li><li>Architectural Refinement, during which the designer can fine-tune parameters to achieve specific PPA objectives; for example, choosing buffer sizes, tweaking arbitration policies, deploying pipe stages to achieve timing closure, etc.</li><li>Export, which invokes the server component of Maestro to generate RTL and collaterals. This process is only allowed if the design is clear of any outstanding errors.</li></ol><p> <span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="https://arterisip.atlassian.net/wiki/download/attachments/16169664/image2019-11-8%2014:50:48.png?api=v2"></span>Maestro design flow</p><p>Through the design flow, Maestro provides guidance to the designer about the current and next steps. Several actions are automated to minimize the iteration time and the possibility of misconfigurations. Additionally, checks are deployed to ensure that incorrect parameterizations cannot propagate far along the flow.</p><p>Maestro provides a GUI, currently in development. Maestro is also entirely scriptable via TCL, to provide a way to automate testing, to generate design variants in the background, and to maximize developer efficiency.</p><h2 id="id-2.14-Maestro-2.14.1TopologyDesign">2.14.1 Topology Design</h2><p>During the “Architectural Design” phase, Maestro allows the designer to create one or more NoC implementations to fulfil the requirements set forth in the specifications. This phase is the most important in terms of configuring a suitable solution. In this phase, design primitives – such as interfaces, switches, links, adapters – are instantiated, connected and coarsely parameterized to achieve the design objectives.</p><p>The prime task in this phase is the choice of a network topology to connect all components together, as well as the establishment of the routes along which traffic will travel. The main objectives are:</p><ul><li>Instantiating components that will functionally connect all communicating endpoints</li><li>Ensuring those components are sized to support the required bandwidths</li><li>Connecting them in a way that offers the lowest possible latency for critical traffic</li><li>Choosing routes that are as direct as possible for critical traffic, and otherwise distribute the traffic load to minimize contention hotspots</li><li>Ensuring that the routes do not create deadlocks</li></ul><p>Maestro allows the designer to perform these tasks manually (with tool assistance) or, for designs that are suitably regular, automatically.</p><h3 id="id-2.14-Maestro-2.14.1.1ManualTopologyDesign">2.14.1.1 Manual Topology Design</h3><p>Maestro allows customers to define topologies and routes manually, while still automating tedious and error-prone sub-tasks. An example flow might be as follows:</p><ol><li>Maestro automatically creates interface units based on designer inputs – for example, an ATU in front of each socket.</li><li>The designer – graphically or via TCL – defines any number of switches to implement the NoC. The designer then connects them – graphically or via TCL – to describe routes. This process can be as iterative as needed.</li><li>Whenever the connectivity spans clock boundaries or data width boundaries, Maestro automatically injects appropriate adapters to implement the timing or packet conversion.</li><li>The designer can manually inject other primitives to satisfy functional or non-functional objectives; for example, firewalls (for access control), extra buffering elements (to improve performance), or pipeline stages (to facilitate timing closure).</li></ol><p>Maestro imposes no restrictions on the choice of topology by the designer, while at the same time helping ensure that the outcome is correct and efficient. Maestro also provides a built-in deadlock checker to assist the customer in the verification of the design.</p><h3 id="id-2.14-Maestro-2.14.1.2AutomatedTopologyGeneration">2.14.1.2 Automated Topology Generation</h3><p>For designs that exhibit a high degree of symmetry, Maestro can largely automate the generation of the topology. Four templates are available:</p><ul><li>Simple crossbar (for small, simple designs, or as an early starting point for manual design)</li><li>Ring (for low-performance, heavily PPA-constrained systems)</li><li>Mesh (for highly regular, repetitive arrays of symmetrical units)</li><li>Torus (for highly regular, repetitive arrays of symmetrical units, with additional emphasis on high bandwidth and low latency)</li></ul><p>Maestro allows the designer to specify a few constraints, e.g., to what node of the mesh each IP should be associated. After that, an automation routine configures the whole interconnect trying to meet objectives such as congestion minimization, latency minimization and area minimization. The resulting outcome can then be manually tweaked by the designer.</p><p>Note that automatically-generated topologies are deadlock-free by construction. However, if the customer chooses to then manually edit the initial provided regular topology, it is always possible to run the same deadlock checker mentioned in the previous subsection, to reverify that the topology is still deadlock-free.</p>