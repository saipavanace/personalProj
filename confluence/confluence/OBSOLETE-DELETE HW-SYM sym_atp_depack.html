<h1 id="OBSOLETE-DELETEHW-SYMsym_atp_depack-module_name"><strong>module_name</strong></h1><p>sym_atp_depack</p><h1 id="OBSOLETE-DELETEHW-SYMsym_atp_depack-parameters"><strong>parameters</strong></h1><h2 style="margin-left: 30.0px;" id="OBSOLETE-DELETEHW-SYMsym_atp_depack-java_script:"><strong>java_script:</strong></h2><pre>{</pre><pre>        &quot;pipeBackward&quot; : &quot;yes&quot; or &quot;no&quot;, // No timing path between ready_out and ready_in if yes.</pre><pre>        &quot;simplePipe&quot; : &quot;yes&quot; or &quot;no&quot;,   // If depth is greater than one, takes &quot;depth&quot; clocks to propagate from input to output if yes.</pre><pre>        &quot;circular&quot; : &quot;yes&quot; or &quot;no&quot;, // Indicates if the internal structure of the FIFO is circular or not. Circular FIFOs use less power</pre><pre>        &quot;addStage&quot; : &quot;yes&quot; or &quot;no&quot;, // add an additional stage to sym_pipe.</pre><pre>        &quot;fieldArray&quot; : [], // array of fields desired from packet</pre><pre>        &quot;clkInterface&quot; : {&quot;name&quot; : &quot;a_string&quot;, &quot;signals&quot; : {interface definition}}, </pre><pre>        &quot;inInterface&quot; : {&quot;name&quot; : &quot;a_string&quot;, &quot;signals&quot; : {interface definition}, &quot;pktDef&quot;: []},<span> </span></pre><pre>        &quot;outInterface&quot; : {&quot;name&quot; : &quot;a_string&quot;, &quot;signals&quot; : {interface definition}}, </pre><pre>        &quot;protectionInterface&quot; :</pre><pre>          {&quot;name&quot; : a_string,</pre><pre>           &quot;signals&quot; : {interface Definition}},</pre><pre>        &quot;protectionStyle&quot; : <a class="external-link" href="https://confluence.arteris.com/display/ENGR/protectionStyle" rel="nofollow">protectionStyle</a>}</pre><pre>}</pre><h2 style="margin-left: 30.0px;" id="OBSOLETE-DELETEHW-SYMsym_atp_depack-verilog:"><strong>verilog:</strong></h2><p style="margin-left: 30.0px;">none.</p><h1 id="OBSOLETE-DELETEHW-SYMsym_atp_depack-I/O"><strong>I/O</strong></h1><pre>u.interface(clkInterface.name,'slave',clkInterface.signals);</pre><pre>u.interface(inInteface.name,'slave',inInteface.signals);</pre><pre>u.interface(outInterface.name,'master',outInterface.signals);</pre><pre>u.port('output','fields_valid',1); </pre><pre>for (i = 0; i &lt; fieldArray.length; i++) {</pre><pre>  u.port('output',fieldArray[i],getWidth(inInterface.linkPketDef[fieldArray[i]))</pre><pre>}</pre><pre>if (protectionStyle !== &quot;&quot;) {<br/>  u.interface(<a class="external-link" href="http://protectioninterface.name/" rel="nofollow">protectionInterface.name</a>,'master',protectionInterface.signals);<br/>}<br/><br/></pre><h1 id="OBSOLETE-DELETEHW-SYMsym_atp_depack-FunctionsUsed"><strong>Functions Used</strong></h1><p>N/A</p><h1 id="OBSOLETE-DELETEHW-SYMsym_atp_depack-ModulesUsed"><strong>Modules Used</strong></h1><p>sym_pipe</p><h1 id="OBSOLETE-DELETEHW-SYMsym_atp_depack-Description"><strong>Description</strong></h1><p>inInteface.signals and outInterface.signals must be identical. That interface needs the following signals: &quot;ready&quot; and &quot;valid&quot;. All the rest of the signals must be outputs and they need to sum to at least two bits.</p><p>The blocks uses sym_pipe in simple pipe mode with gutExposed and validsExposed set to &quot;yes.&quot;</p><p>The fields that are desired are passed into with the parameter fieldArray. The block will use this to determine how many beats of a packet are needed to accumulate all the fields and this determines the depth of the sym_pipe.</p><p>if addStage is &quot;yes&quot; then the field data will always come from an internal register. If addStage is &quot;no,&quot; some fields or parts of fields may come from the inInterface signals directly.</p><p>When a new packet reaches the output of the imbedded sym_pipe (first is asserted for that beat,) &quot;valid&quot; on the outInterface will not go asserted until all the beats needed to display all the fields have been accumulated. If there are no bubbles in the packet, this will happen when the first beat of a the packet reaches the output of sym_pipe. When this happens, valid will assert on outInterface and fields_valid will also assert. When ready is asserted on outInterface, fields_valid will deassert on the next beat and the packet will pass through the block with valid unfiltered until another first is detected. In other words, if you can't use the results from the block that cycle, don't assert ready.</p><p>The block will generate outputs from fieldArray using the following rules:</p><ol><li>The output will always be the string passed in an entry in fieldArray.</li><li>If the search of the linkPktDef only returns one field, the output will have the width of that field.</li><li>If the search of the linkPktDef returns multiple fields the output will be the sum of the widths of all the fields returned.</li><li>If the search returns multiple fields of the form &quot;field_search_string&quot;_n (fss_n); where n is an integer, the output will be of the form: {fss_n, fss_n-1, fss_n-2 . . . ,fss_0}.</li><li>If the search returns multiple fields that don't follow 4, then the fields will be concatenated in the order they are found in the packet.</li></ol>