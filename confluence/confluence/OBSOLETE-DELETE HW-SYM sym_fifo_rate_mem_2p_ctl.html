<h1 id="OBSOLETE-DELETEHW-SYMsym_fifo_rate_mem_2p_ctl-module_name"><strong>module_name</strong></h1><p>sym_fifo_rate_mem_2p_ctl</p><h1 id="OBSOLETE-DELETEHW-SYMsym_fifo_rate_mem_2p_ctl-parameters"><strong>parameters</strong></h1><h2 id="OBSOLETE-DELETEHW-SYMsym_fifo_rate_mem_2p_ctl-java_script:"><strong>java_script:</strong></h2><pre class="page view">{
	&quot;width&quot; : any positive integer <br/>        &quot;depth&quot; : any positive integer 4 or greater <br/>        &quot;ratio&quot; : [I,J], // I is the number of in valid beats per J beats on the output, Specifies ratio of beats.<br/>        &quot;protectionStyle&quot; : protectionStyle, <br/>        &quot;protectionInterface&quot; : protectionInterface</pre><pre>}</pre><h2 id="OBSOLETE-DELETEHW-SYMsym_fifo_rate_mem_2p_ctl-verilog:"><strong>verilog:</strong></h2><p style="margin-left: 30.0px;">none.</p><h1 id="OBSOLETE-DELETEHW-SYMsym_fifo_rate_mem_2p_ctl-I/O"><strong>I/O</strong></h1><p>u.port('input', 'in_valid', 1);<br/>u.port('input', 'in_first', 1);<br/>u.port('input', 'in_last', 1);<br/>u.port('output', 'in_ready', 1);<br/>u.port('output', 'out_valid', 1);<br/>u.port('input', 'out_ready', 1);</p><p>// Ports to read buffer<br/>// A rdy_vld_pipe, depth = 2, pF = false, pB = true, exposeValids = true<br/>u.port('input', 'pipe_out_valid', 1);<br/>u.port('output', 'pipe_out_ready', 1);<br/>u.port('output', 'pipe_in_valid', 1);<br/>u.port('input', 'pipe_in_ready', 1);<br/>u.port('input', 'pipe_in_first', 1);<br/>u.port('input', 'pipe_in_last', 1);</p><p>// Ports to SRAM<br/>u.port('output', 'wt_sel', 1);<br/>u.port('output', 'wt_addr', addr_width);<br/>u.port('output', 'rd_sel', 1);<br/>u.port('output', 'rd_addr', addr_width);</p><p>// Ports to data mux<br/>u.port('output', 'empty', 1);</p><p>u.interface(protectionInterface.name, 'master', protectionInterface.signal);</p><h1 id="OBSOLETE-DELETEHW-SYMsym_fifo_rate_mem_2p_ctl-ModulesUsed"><strong>Modules Used</strong></h1><p><a class="external-link" href="https://confluence.arteris.com/display/ENGR/prot_reg" rel="nofollow">prot_reg</a></p><p><a class="external-link" href="https://confluence.arteris.com/display/ENGR/logic_tree" rel="nofollow">logic_tree</a></p><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16167580/logic_tree_bus" data-linked-resource-id="16167580" data-linked-resource-version="11" data-linked-resource-type="page">logic_tree_bus</a></p><h1 id="OBSOLETE-DELETEHW-SYMsym_fifo_rate_mem_2p_ctl-Description"><strong>Description</strong></h1><p>The control logic to turn a separate read/write port SRAM into a FIFO based rate adapter using ready and valids. The block diagram of the <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16171439/OBSOLETE-DELETE+HW-SYM+sym_fifo_rate_mem_2p" data-linked-resource-id="16171439" data-linked-resource-version="7" data-linked-resource-type="page">OBSOLETE-DELETE HW-SYM sym_fifo_rate_mem_2p</a> where this block is used is shown below:</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16171445/sym_fifo_rate_mem_2p_ctl.svg?api=v2"></span></p><p><strong>ratio: </strong>I represents the number of valid beats per J beats on the output. So, if a packet is coming into the block with a valid every other beat, which can happen from a data width adapter, then I = 1 and J = 2. Another way of saying this is the in side has a bubble every other cycle. If the in side has a bubble once ever three cycles, then I = 2 and J = 3. If the in side had two bubbles every 5 cycles, then I = 3 and J = 5.</p><p>The purpose of rate control is to only allow the FIFO to start unloading if the loading of the FIFO will cause no bubbles in a packet on the out side. It does this by calculating an offset from the present write pointer when a packet starts that the FIFO will have to reach when loading a packet of depth beats such that it can start to unload and not cause bubbles on the output. If the packet ends before reaching the offset, the packet is started on the output.</p><p>The microarchitecture of the block is based off of the <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16169283/OBSOLETE-DELETE+HW-SYM+sym_fifo_mem_2p_ctl" data-linked-resource-id="16169283" data-linked-resource-version="9" data-linked-resource-type="page">OBSOLETE-DELETE HW-SYM sym_fifo_mem_2p_ctl</a>. A filter is added in place to de-assert the out_valid signal when the FIFO is filling until it reaches the offset described above or a packet is completed.</p><p>There are the following internal registers:</p><p>wt_addr: The write pointer<br/>rd_addr: The read pointer<br/>wrap: When asserted and wt_addr = rd_addr indicates FIFO is full. When deserted and wt_addr = rd_addr FIFO is empty.<br/>rd_sel_p: Indicates a read was issued on the previous cycle.<br/>prev_trigger: There was a packet release trigger on the previous cycle.<br/>pkt_cnt: The number of packets in the FIFO.<br/>trigger_pt: The calculated offset from the wt_addr that must be reach for a packet with depth beats must reach before the packet can start unloading</p><p>These registers are actually stored in one register in the following order:</p><p style="margin-left: 30.0px;">{wrap,rd_sel_p,prev_trigger,pkt_cnt,trigger_pt,wt_addr,rd_addr} </p><p>Internally there are the following wires:</p><p style="margin-left: 30.0px;">wire int_empty;<br/>wire equal;<br/>wire next_equal;<br/>wire full;<br/>wire wrap;<br/>wire next_wrap;<br/>wire [\=addr_width-1=\:0] next_wt_addr;<br/>wire [\=addr_width-1=\:0] next_rd_addr;<br/>wire trigger;<br/>wire prev_trigger;<br/>wire [\=addr_width-1=\:0] next_trigger_pt;<br/>wire [\=addr_width-1=\:0] trigger_pt;<br/>wire trigger_pt_hit;<br/>wire rd_sel_p;<br/>wire [\=state_width-1=\:0] state;<br/>wire [\=state_width-1=\:0] next_state;<br/>wire [\=pkt_cnt_width-1=\:0] pkt_cnt;<br/>wire [\=pkt_cnt_width-1=\:0] pkt_cnt_p0;<br/>wire [\=pkt_cnt_width-1=\:0] pkt_cnt_p1;<br/>wire [\=pkt_cnt_width-1=\:0] pkt_cnt_m1;<br/>wire [\=pkt_cnt_width-1=\:0] next_pkt_cnt;<br/>wire sel_p0;<br/>wire sel_p1;<br/>wire sel_m1;<br/>wire pkt_cnt_not_zero;<br/>wire next_pkt_cnt_not_zero;<br/>wire in_has_last;<br/>wire in_has_first;<br/>wire pipe_has_last;</p><p>The loading and unloaded on the single register:</p><p style="margin-left: 30.0px;">assign next_state[\=state_width-1=\] = next_wrap;<br/>assign next_state[\=state_width-2=\] = rd_sel;<br/>assign next_state[\=state_width-3=\] = trigger;<br/>assign next_state[\=3*addr_width+pkt_cnt_width-1=\:\=3*addr_width=\] = next_pkt_cnt;<br/>assign next_state[\=3*addr_width-1=\:\=2*addr_width=\] = next_trigger_pt;<br/>assign next_state[\=2*addr_width-1=\:\=addr_width=\] = next_wt_addr;<br/>assign next_state[\=addr_width-1=\:0] = next_rd_addr;</p><p style="margin-left: 30.0px;">assign wrap = state[\=state_width-1=\];<br/>assign rd_sel_p = state[\=state_width-2=\];<br/>assign prev_trigger = state[\=state_width-3=\];<br/>assign pkt_cnt = state[\=3*addr_width+pkt_cnt_width-1=\:\=3*addr_width=\];<br/>assign trigger_pt = state[\=3*addr_width-1=\:\=2*addr_width=\];<br/>assign wt_addr = state[\=2*addr_width-1=\:\=addr_width=\];<br/>assign rd_addr = state[\=addr_width-1=\:0];</p><p>The logic_tree block is used three times to calculate equal, next_equal and trigger_pt_hit. The two pointers are exclusive NORed, the resulting bits are ORed using the logic_tree module, and the output for the OR tree is whether the two pointers are equal or not. </p><p>The logic_tree block is used two additional times to calculate pkt_cnt_not_zero and next_pkt_cnt_not_zero. In the case the pkt_cnt and next_pkt_cnt are bit was ORed together to create the signals.</p><p>A logic_tree_bus block is used to create a mux between three calculated values for next_pkt_cnt. The three inputs are ANDed per bit with the a select signal before (as shown in below equations) being inputed into the logic_tree_bus. These three inputs are pkt_cnt_p1, pkt_cnt_m1 and pkt_cnt_p0.</p><p>Here are the logic equations with descriptions of what they are doing. It shows both the original equation from <a class="external-link" href="https://confluence.arteris.com/display/ENGR/sym_fifo_mem_2p_ctl" rel="nofollow">sym_mem_2p_ctl</a> and the modified one.</p><p><strong>New Equations:</strong></p><p style="margin-left: 30.0px;">assign in_has_last = in_valid &amp; in_ready &amp; in_last &amp; (~int_empty | ~pipe_out_valid) ;</p><p>Is the present beat coming in the last beat of a packet.</p><p style="margin-left: 30.0px;">assign in_has_first = in_valid &amp; in_ready &amp; in_first;</p><p>Is the present beat coming in the first beat of a packet.</p><p style="margin-left: 30.0px;">assign pipe_has_last = pipe_in_valid &amp; pipe_in_ready &amp; pipe_in_last;</p><p>Does the external pipe have the last beat of data.</p><p style="margin-left: 30.0px;">assign sel_p1 = in_has_last &amp; ~pipe_has_last;</p><p>Add to the packet count if it's the last beat coming in. Don't increment if a beat leaving the memory also has last at the same time.</p><p>assign sel_m1 = ~in_has_last &amp; pipe_has_last;</p><p>Subtract from the packet count if the beat leaving the memory has last. Don't decrement if the beat coming into the memory has last at the same time.</p><p style="margin-left: 30.0px;">assign sel_p0 = ~(in_has_last ^ pipe_has_last);</p><p>Leave the count the same if nothing is happening or both side have last.</p><p style="margin-left: 30.0px;">assign pkt_cnt_p1 = {\=pkt_cnt_width=\{sel_p1}} &amp; (pkt_cnt + 1'b1);</p><p>Calculate the packet count plus 1 and qualify with the signal that selects the condition.</p><p style="margin-left: 30.0px;">assign pkt_cnt_m1 = {\=pkt_cnt_width=\{sel_m1}} &amp; (pkt_cnt - 1'b1);</p><p>Calculate the packet count minus 1 and qualify with the signal that selects the condition.</p><p style="margin-left: 30.0px;">assign pkt_cnt_p0 = {\=pkt_cnt_width=\{sel_p0}} &amp; pkt_cnt;</p><p>Qualify the packet with the don't change condition.</p><p style="margin-left: 30.0px;">assign trigger = (~prev_trigger &amp; (trigger_pt_hit | next_pkt_cnt_not_zero | full)) | (prev_trigger &amp; ~(pipe_has_last &amp; ~next_pkt_cnt_not_zero));</p><p>Trigger means start unloading the packet. It is used as the filter. You trigger when the next packet count is greater than 0 or you have reached the trigger point while the next packet count is 0. You release trigger when when next packet count is 0.</p><p style="margin-left: 30.0px;">assign next_trigger_pt =<br/>  in_has_first ?<br/>  ((wt_addr &gt;= \=addr_width=\'d\=depth-valid_trigger_num=\) ?<br/>    wt_addr - \=addr_width=\'d\=depth-valid_trigger_num=\ :<br/>    wt_addr + \=valid_trigger=\ ) :<br/>    trigger_pt;</p><p>You set the next trigger point at beginning of a packet that's written into the FIFO. Because the FIFO is circular and can be a non-power of two, things can get complicated.</p><p><strong>Equations that didn't change (see <a class="external-link" href="https://confluence.arteris.com/display/ENGR/sym_fifo_mem_2p_ctl" rel="nofollow">sym_mem_2p_ctl</a> for descriptions):</strong></p><p style="margin-left: 30.0px;">assign full = equal &amp; wrap;</p><p style="margin-left: 30.0px;">assign empty = equal &amp; ~wrap &amp; ~pipe_out_valid;</p><p style="margin-left: 30.0px;">assign int_empty = equal &amp; ~wrap;</p><p style="margin-left: 30.0px;">assign in_ready = ~full ;</p><p style="margin-left: 30.0px;">assign pipe_in_valid = rd_sel_p;</p><p style="margin-left: 30.0px;">assign next_wt_addr = wt_sel ? ((wt_addr == \=addr_width=\'d\=depth-1=\) ? \=addr_width=\'b0 : wt_addr + 1'b1) : wt_addr;</p><p style="margin-left: 30.0px;">assign next_rd_addr = rd_sel ? ((rd_addr == \=addr_width=\'d\=depth-1=\) ? \=addr_width=\'b0 : rd_addr + 1'b1) : rd_addr;</p><p style="margin-left: 30.0px;">assign next_wrap = (~wrap &amp; wt_sel &amp; ~rd_sel &amp; next_equal) | (wrap &amp; (~rd_sel | (wt_sel &amp; rd_sel)));</p><p style="margin-left: 30.0px;"><strong>Equations that changed:</strong></p><p style="margin-left: 30.0px;">assign wt_sel = in_valid &amp; ((~empty &amp; ~full) | (~full &amp; ~out_ready));</p><p style="margin-left: 30.0px;">changed to:</p><p style="margin-left: 30.0px;">assign wt_sel = in_valid &amp; ((~empty &amp; ~full) | (~full &amp; ~(out_ready &amp; trigger)));</p><p>The SRAM FIFO is written if there's an input coming in and the block is not empty (not int_empty) and not full or the block is not full and output doesn't have a ready. I don't want to write the SRAM if the SRAM FIFO is empty, the external pipe is empty and the output is ready. In that case, the data is routed around the internal storage and straight to the output. This is what makes the block pipeForward equals false.</p><p>Trigger is being used to filter out_ready. If trigger is not asserted, out_valid can't assert, so the out_ready must be masked.</p><p style="margin-left: 30.0px;">assign out_valid = pipe_out_valid | empty &amp; in_valid;</p><p style="margin-left: 30.0px;">changed to:</p><p style="margin-left: 30.0px;">assign out_valid = pipe_out_valid &amp; trigger | empty &amp; in_valid;</p><p>The block asserts out_valid if the pipe has data in it, or the entire block is empty and there is an in_valid. Because the block wants to forward data if it's empty, valid can be asserted in this case.</p><p>Trigger is being used to filter the external pipe valid so the transaction isn't presented on the output of the block if trigger hasn't fired.</p><p style="margin-left: 30.0px;">assign pipe_out_ready = ~empty &amp; out_ready;</p><p style="margin-left: 30.0px;">changed to:</p><p style="margin-left: 30.0px;">assign pipe_out_ready = ~empty &amp; out_ready &amp; trigger;</p><p>The controls the internal pipe by filtering it's output ready and input valid. The logic makes no assumptions about the depth of the pipe and how the pipeForward and pipeBackward parameters on the pipe are configured. If the pipe has data in it, it can be read out if out_ready is asserted. If the block is not empty, there is either data in the FIFO, data in the external pipe, or data in both. If the external pipe has no data, it won't be asserted valid, and so the block doesn't need to filter empty based on the external pipes state.</p><p>Trigger is being used to filter out_ready. If trigger is not asserted, out_valid can't assert, so the out_ready must be masked.</p><p style="margin-left: 30.0px;">assign rd_sel = ~int_empty &amp; (~pipe_in_valid &amp; pipe_in_ready | ~pipe_in_valid &amp; out_ready | pipe_in_valid &amp; out_ready);</p><p style="margin-left: 30.0px;">changed to:</p><p style="margin-left: 30.0px;">assign rd_sel = ~int_empty &amp; (~pipe_in_valid &amp; pipe_in_ready | ~pipe_in_valid &amp; out_ready &amp; trigger | pipe_in_valid &amp; out_ready &amp; trigger);</p><p>If there's data in the SRAM FIFO, The block can't issue a read if the external pipe is full and there is no ready on the output, otherwise it can.</p><p>Trigger is being used to filter the out_ready. If trigger is not asserted, out_valid can't assert, so the out_ready must be masked.</p><p style="margin-left: 30.0px;"><br/></p>