<h2 id="GeneratingVerilogexpressionsinTACHL(Proposal)-Motivation">Motivation</h2><p>In TACHL code, the we often need to generate Verilog expressions. In simpler cases, we can accomplish this by turning off JS portion of code with a \jsend and writing actual Verilog expressions. This work well for cases involving simple operations on a fixed set of signals (independent of block parameter values) but has limitations. More complex cases involve such as:</p><ol><li>Operations on an array of signals or constants. They may even be generated based on block JS params in which case there is no prior knowledge of which signals will exist. Examples: bitwise-logical operations, Concatenate, comparison operations.</li><li>Operations on a single signal. Examples: Slicing (bus[3:2]), Indexing (bus[1]), replication ( { 2 { bus[ 4 : 2 ] } } )</li><li>Operations on a constant. Examples: Replication { 4 { 2'd2 } } </li></ol><p> </p><ol><li>For case 1, we generally use JS control structures (for-loops, if-else) or in some cases join() method. This creates more scopes for bugs - was the order of iterations correct? Was limits of the loop correct ?</li><li>For case 2, a common approach is to calculate bus indices and constants in JS and interpolate them as strings in TACHL code. This creates more variables and often doesn't handle limiting cases leading to expressions like &quot;bus[3:3]&quot;, which means creating more if-else statements to handle specific cases.</li><li>For case 3, interpolated JS variables that store constants, in TACHL code look like this { \=n=\ { \=width=\' d\=constant=\ }</li></ol><p>All the above approaches lead to</p><ol><li>Repeated boiler-plate code (repeated operations on similar variables (indices), if-else conditions to check limiting cases etc.)</li><li>Hard-to-read code with frequent intermixing of JS and Verilog expressions, sometimes in the same line.</li><li>No automatic way of checking if the sets of parameter values for the block (illegal configurations) lead to either illegal or unintended Verilog expressions.</li><li>More boiler-plate code also means more errors, no standard way to handle conditions, all of which slows down development.</li></ol><h2 id="GeneratingVerilogexpressionsinTACHL(Proposal)-Proposal">Proposal</h2><p>A way to overcome some of the problems described above is to have library primitives in JavaScript that can generate frequently used Verilog expressions. The following classes are proposed to describe this approach:</p><h3 id="GeneratingVerilogexpressionsinTACHL(Proposal)-classVlogExpr">class VlogExpr</h3><p>This will be the base class and the most fundamental primitive that shall be used to represent any Verilog expression. An expression can be a constant, a signal, or a combination of those using operators (composite expression).</p><p><strong><em>constructor </em>( width, expr)</strong><br/>An instance of this class is called with two arguments both of which become properties of the instance object created:</p><ol><li>width - a number &gt;= 0</li><li>expr (expression) - a string that holds the verilog expression.</li></ol><p>An expression can be any Verilog expression which can be as complex as such as &quot;(bus[3:2] &gt; 3'h0)&quot; or something as simple as a signal name &quot;bus&quot; or just a constant &quot;3'd2&quot;. All expressions will have an associated width, which describes the width of the resulting expression.</p><p> </p><p>The class shall support the following methods to generate composite expressions from the current expression object:</p><p><strong>replicate ( n )</strong> <br/>Returns another instance of VlogExpr type that replicates n times the VlogExpr on which this is called. Example: if myExpr is of type vlogExpr such that it' properties are set to { width: 2, expr: &quot;bus[4:3]&quot; }, then myExpr.replicate(3) returns { width: 6, expr: &quot;{ 3, { bus[4:3] } }&quot; }</p><p><strong>pad0 ( width )<br/></strong>Returns an expression padded with width number of zero bits.</p><p><strong>pad1 ( width )<br/></strong>Returns an expression padded with width number of one bits.</p><p><strong>bitwiseAND ( ...expressions )</strong> (Similar functions for other bitwise logical operations OR, XOR shall exist)<br/>Returns the bitwise-AND operation of all expressions along with the expression on which this method is called. Example: if myExpr = { width: 8, expr: &quot;bus[7:0]&quot; }, and if A = { width: 8, expr: &quot;mask&quot;, B = { width: 8, &quot;8'hf5&quot;, then myExpr.bitwiseAND( A, B) returns { width: 8, expr: &quot;(bus[7:0] &amp; mask &amp; 8'hf5)&quot; }.</p><p>Note: Defining the argument, &quot;expressions&quot; with a spread operator(...) instead of an array argument</p><ol><li>Implies that the function can accept variable number of arguments (variadic). Each argument is expected to be an instanceOf VlogExpr.</li><li>Avoids having to handle the case when number of expressions passed is either 0 or 1.</li><li>Reduces clutter in function or method calls.</li><li>This works similar to and is modeled after some built-in JavaScript methods such as Array.prototype.concat ( ), Math.max(), Object.assign() etc.</li></ol><p><strong>cmp (type, expression)</strong><br/>Return the expression that compares this expression with the input expression. Type specifies the type of comparison. Example: if myExpr = { width: 8, expr: &quot;addr[7:0]&quot; }. and if A = { width: 8, expr: &quot;8'hc0&quot; }, this returns { width: 1, expr: &quot; bus[7:0]&quot; }</p><p><strong>assign( rhs, widthCorrect)</strong><br/>Returns an assignment (string value) with LHS as the current or this expression and RHS as the argument rhs (instancOf VlogExpr). The widthCorrect is an array whose values specify the kind of correction required in case of a mismatch: &quot;pad1&quot;, &quot;pad0&quot;, &quot;trunc&quot;. If array is empty and widths don't match it errors out.</p><p> </p><p>The class shall <strong>override</strong> the default method to generate string representation of the class's instance objects:</p><p><strong>toString()</strong><br/>Returns the &quot;expr&quot; string in context of string operations, printing, and interpolating (in TACHL code). This avoids having to specifiy a vlogExpr instance in TACHL code as \=myExpr.expr=\. Instead it can simply be specified as \=myExpr=\.</p><p> </p><p>All the above methods shall have checks to ensure that only legal operations are generated such as ensuring the widths of all signals, expressions, constants match for bitwise logical operations.  </p><h3 id="GeneratingVerilogexpressionsinTACHL(Proposal)-classVlogConst">class VlogConst</h3><p>This shall be an extended class of its parent class VlogExpr so that it can inherit all the methods of the parent class.</p><p><em><strong>constructor( width, base, value)</strong></em><br/>An instance of this class is called with three arguments:</p><ol><li>width - a number &gt;= 0</li><li>value - a number &gt;= 0.</li><li>base - a number that specifies the base. Only following values shall be supported - 2, 10, 16.</li></ol><p>Example: var myConst = new VlogConst (3, 2) ). myConst now returns three properties: { width: 3, expr: &quot;3'd2&quot; }</p><p>Because VlogConst has access to all methods in VlogExpr, following operations are possible with myConst:</p><p>myConst.replicate(3) returns { width: 9, expr: &quot;{ 3 { 3'd2 } }&quot; }</p><h3 id="GeneratingVerilogexpressionsinTACHL(Proposal)-classVlogSignal">class VlogSignal</h3><p>This shall be an extended class of its parent class VlogExpr so that it can inherit all the methods of the parent class.</p><p><strong><em>constructor( width, name, size)</em></strong><br/>An instance of this class is called with two arguments:</p><ol><li>width - a number &gt;= 0</li><li>name - a string that is the name of the signal.</li><li>size  - (Optional) a number &gt;= 1. This can be optional and can default to 1 if not specified. This will be used for signal arrays.</li></ol><p> </p><p>In addition to having access to classes in its parent type, vlogExpr, the class shall support the following methods to generate composite expressions from the current expression object:</p><p><strong>slice (start, end)</strong><br/>Returns a bit slice of the signal. Errors out if slice is beyond bounds. Example: var mySignal = new VlogSignal ( 8, &quot;bus&quot; ); Then, mySignal.slice(4, 2) returns an instanceOf VlogExpr ({ width: 2, expr: &quot;bus[4:2]&quot; }).</p><p><strong>sliceUpper ( width, start )</strong><br/>Returns a bit slice of the signal starting from the MSB of the signal or from start index and lower if start is specified. </p><p><strong>sliceLower ( width, start )</strong><br/>Returns a bit slice of the signal starting from the LSB of the signal or from start index and above if start is specified</p><p><strong>trunc ( width )<br/></strong>Returns a signal that is truncated by width bits from MSB by default.</p><p><strong>bit ( i )</strong><br/>Returns the bit indexed by i of the signal. Errors out if index out of bounds. Width of the returned signal is always one.</p><h2 id="GeneratingVerilogexpressionsinTACHL(Proposal)-Buildingcompositeexpressions">Building composite expressions</h2><p>The methods described as above will allow for building more composite expressions. Suppose</p><p>var myExpr = new VlogSignal ( 8, &quot;bus&quot; );</p><p>myExpr .slice({ start: 3, end: 0 }) .replicate( 2 ) will return </p><p>{ width: 8, expr: &quot;{ 2 { bus[3:0] } }&quot; }</p><p> </p><p>Note that any of the methods associated with a class can be called like individual functions without having to invoke it on an instance by accessing it as class.prototype.method( args ). This is useful in a situation like below:</p><p>Suppose you have a set of signals each of m-bits generated in an array that need to be ORed, say generated as below</p><p>var orSignals   = [ ];</p><p>for (let i = 0; i &lt; N; i++) {<br/>  orSignals.push( new VlogSignal ( 5, &quot;signal&quot;+i ) );<br/>}</p><p>Then in order to OR them all one could just do<br/>VlogSignal.prototype.bitwiseOR ( ...orSignals )   // This will return { width: 5, expr: &quot;( signal0 | signal1 | signal2 | ... | signalN-1 )&quot; }</p><h2 id="GeneratingVerilogexpressionsinTACHL(Proposal)-Nostringparsingtoestimatewidths">No string parsing to estimate widths</h2><p>The above classes are designed so that there's no need to parse strings ever to determine the widths of composite expressions. This is because all widths are defined by the user when the constructor is called. And widths of composite expressions can be estimated based on the type of operation. Preserving and estimating the widths will allow for verifying widths of even composite expressions. </p><h2 id="GeneratingVerilogexpressionsinTACHL(Proposal)-ConvertinginterfacesignalstoVlogSignaltypes">Converting interface signals to VlogSignal types</h2><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p>