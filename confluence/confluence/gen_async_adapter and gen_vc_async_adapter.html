<div class="wiki-content"><style>[data-colorid=uqje4t8oq0]{color:#707070} html[data-color-mode=dark] [data-colorid=uqje4t8oq0]{color:#8f8f8f}</style><h1 id="gen_async_adapterandgen_vc_async_adapter-module_name"><strong>module_name</strong></h1><p>gen_async_adapter</p><p>gen_async_adapter_in</p><p>gen_async_adapter_out</p><p>gen_vc_async_adapter</p><p>gen_vc_async_adapter_in</p><p>gen_vc_async_adapter_out</p><h1 id="gen_async_adapterandgen_vc_async_adapter-parameters"><strong>parameters</strong></h1><h2 id="gen_async_adapterandgen_vc_async_adapter-java_script:"><strong>java_script:</strong></h2><h3 id="gen_async_adapterandgen_vc_async_adapter-gen_async_adapter&amp;gen_vc_async_adapter:">gen_async_adapter &amp; gen_vc_async_adapter:</h3><pre>{</pre><pre>        &quot;jitterOn&quot; : 0 or 1, // Only for simulation. Causes synchronizer cells to jitter one cycle.</pre><pre>        &quot;async&quot; : true or false, // If true means there is a fixed phase alignment between inClkInterface and outclhkinterface where edges align.</pre><pre>        &quot;depth&quot; : 0 or any positive integer, // The depth of the pipeline. divisible by 2 when async = true. When 0, depth is internally calculated as 2*Math.ceil(syncDepth+1.5).</pre><pre>        &quot;syncDepth&quot; : 2 or higher integer, When async = true, depth of synchronizers.</pre><pre>        &quot;interfaces: {<br />          &quot;inClkInterface&quot; : {InterfaceCLK},</pre><pre>          &quot;outClkInterface&quot; : {InterfaceCLK},</pre><pre>          &quot;inPmaControlInterface&quot; : {InterfacePMAControl}, // Optional interface - required when inClkInterface clock domain is switchable</pre><pre>          &quot;outPmaControlInterface&quot; : {InterfacePMAControl}, // Optional interface - required when out ClkInterface clock domain is switchable </pre><pre>          &quot;inInterface&quot; : {InterfaceReadyValid}, // any interface with ready/valid, like InterfaceATP&nbsp;</pre><pre>          &quot;outInterface&quot; : {InterfaceReadyValid}, // any interface with ready/valid, like InterfaceATP&nbsp;</pre><pre>          &quot;inProtectionInterface&quot; : {InterfacePROT}, // optional, invoked if protectionStyle !== null or undefined</pre><pre>          &quot;outProtectionInterface&quot; : {InterfacePROT}}, // optional, expected if protectionStyle !== null or undefined</pre><pre>        &quot;protectionStyle&quot; : <a class="external-link" href="https://confluence.arteris.com/display/ENGR/protectionStyle" rel="nofollow" style="text-decoration: none;">protectionStyle</a>}</pre><pre>}</pre><h3 id="gen_async_adapterandgen_vc_async_adapter-gen_async_adapter_in&amp;gen_vc_async_adapter_in:">gen_async_adapter_in &amp; gen_vc_async_adapter_in:</h3><pre>{</pre><pre>        &quot;jitterOn&quot; : 0 or 1, // Only for simulation. Causes synchronizer cells to jitter one cycle.</pre><pre>        &quot;async&quot; : true or false, // If false means there is a fixed phase alignment between inClkInterface and outclhkinterface where edges align.</pre><pre>        &quot;depth&quot; : 0 or any positive integer, // The depth of the pipeline. divisible by 2 when async = true. When 0, depth is internally calculated as 2*Math.ceil(syncDepth+1.5).</pre><pre>        &quot;syncDepth&quot; : 2 or higher integer, When async = true, depth of synchronizers. </pre><pre>        &quot;fromClk&quot; : string, // Name of out clock. Used to create a comment in dffr_sync generated verilog.</pre><pre>        &quot;interfaces&quot; : {</pre><pre>          &quot;clkInterface&quot; : {InterfaceCLK},</pre><pre>          &quot;pmaControlInterface&quot; : {InterfacePMAControl}, // Optional interface - required when clkInterface clock domain is switchable&nbsp;</pre><pre>          &quot;inInterface&quot; : {InterfaceReadyValid}, // any interface with ready/valid, like Interface ATP&nbsp;</pre><pre>          &quot;asyncInterface&quot; : {InterfaceAsyncFIFO},&nbsp;</pre><pre>          &quot;protectionInterface&quot; : {InterfacePROT}}, // optional, expected if protectionSytle !== null or undefined</pre><pre>        &quot;protectionStyle&quot; : <a class="external-link" href="https://confluence.arteris.com/display/ENGR/protectionStyle" rel="nofollow" style="text-decoration: none;">protectionStyle</a>}</pre><pre>}</pre><h3 id="gen_async_adapterandgen_vc_async_adapter-gen_async_adapter_out&amp;gen_vc_async_adapter_out:">gen_async_adapter_out &amp; gen_vc_async_adapter_out:</h3><pre>{</pre><pre>        &quot;jitterOn&quot; : 0 or 1, // Only for simulation. Causes synchronizer cells to jitter one cycle.</pre><pre>        &quot;async&quot; : true or false, // If &quot;no&quot; means there is a fixed phase alignment between inClkInterface and outclhkinterface where edges align.</pre><pre>        &quot;depth&quot; : 0 or any positive integer, // The depth of the pipeline. divisible by 2 when async = true. When 0, depth is internally calculated as 2*Math.ceil(syncDepth+1.5).</pre><pre>        &quot;syncDepth&quot; : 2 or higher integer, When async = true, depth of synchronizers. </pre><pre>        &quot;fromClk&quot; : string, // Name of in clock. Used to create a comment in dffr_sync generated verilog.</pre><pre>        &quot;interfaces&quot; : {</pre><pre>          &quot;clkInterface&quot; : {IntefaceCLK},</pre><pre>          &quot;pmaControlInterface&quot; : {InterfacePMAControl}, // Optional interface - required when clkInterface clock domain is switchable&nbsp;</pre><pre>          &quot;asyncInterface&quot; : {InterfaceAsyncFIFO},&nbsp;</pre><pre>          &quot;outInterface&quot; : {InterfaceReadyValid},&nbsp;// any interface with ready/valid, line interface ATP</pre><pre>          &quot;protectionInterface&quot; : {InterfacePROT}}, // optional, expected if protectionStyle !== null or undefined</pre><pre>        &quot;protectionStyle&quot; : <a class="external-link" href="https://confluence.arteris.com/display/ENGR/protectionStyle" rel="nofollow" style="text-decoration: none;">protectionStyle</a>}</pre><pre>}</pre><h1 id="gen_async_adapterandgen_vc_async_adapter-FunctionsUsed"><strong>Functions Used</strong></h1><p>N/A</p><h1 id="gen_async_adapterandgen_vc_async_adapter-ModulesUsed"><strong>Modules Used</strong></h1><p>async_fifo_wt_ctl</p><p>async_fifo_rd_ctl</p><p>async_fifo_reg_dp</p><h1 id="gen_async_adapterandgen_vc_async_adapter-Description"><strong>Description</strong></h1><p>for a detailed description of the internal architecture, refer to&nbsp;<a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16163996/async_fifo" data-linked-resource-id="16163996" data-linked-resource-version="5" data-linked-resource-type="page">async_fifo</a>&nbsp;specification. The below figure shows how the block(s) are constructed:</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16158701/async%20fifo%20adapter.svg?api=v2" /></span></p><p>The are four difference between the gen_async_adapter and the gen_vc_async_adapter:</p><ol><li>The valid vector is included in the data pushed into the FIFO registers.</li><li>The write control logic clones the ready to all virtual channel readies: in_ready =&nbsp;{numVc{int_in_ready}};</li><li>The read control logic generates the virtual channel readies by using the data and in_out ready: out_valid = data[] &amp;&nbsp;{numVc{int_out_valid}};</li><li>The read control logic generates int_out_ready by OR reducing the AND of out_valid and out_ready: int_in_ready = |(out_valid &amp; out_ready);<br /><br /></li></ol><p>The async Interface is an&nbsp;<a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16169745/InterfaceAsyncFIFO" data-linked-resource-id="16169745" data-linked-resource-version="7" data-linked-resource-type="page">InterfaceAsyncFIFO</a> that has three parameters:</p><p style="margin-left: 30.0px;">depth<br />width<br />async</p><p>They have the following relationships to block parameters.</p><p style="margin-left: 30.0px;">gen_async_adapter_in and gen_async_adapter_in_out</p><p style="margin-left: 60.0px;">InterfaceAsyncFIFO.depth = depth<br />InterfaceAsyncFIFO.async = async<br />InterfaceAsyncFIFO.width = Sum of widths of outputs for the ready/valid interface - 1.&nbsp;</p><p style="margin-left: 30.0px;">gen_vc_async_adapter_in and&nbsp;gen_vc_async_adapter_in_out</p><p style="margin-left: 60.0px;">InterfaceAsyncFIFO.depth = depth<br />InterfaceAsyncFIFO.async = async<br />InterfaceAsyncFIFO.width = Sum of widths of outputs for the ready/valid interface.&nbsp;</p></div><h1 id="gen_async_adapterandgen_vc_async_adapter-PowerControl">Power Control</h1><p>The only signal used from both the inPmaControlInterface and outPmaControlInterface is asleep. The circuit below shows how the local resets are controlled when the in side and out side are powered up:</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16158701/async_powerControl.svg?api=v2" /></span></p><div class="wiki-content"><p style="margin-left: 30.0px;">The in_off in the top circuit is connected to the in_off through a keeper cell that holds to 1. The out_off on the bottom circuit is tied to the top circuit through a keeper cells that holds to a 1.</p></div><div><div><a class="external-link" href="https://confluence.arteris.com/" rel="nofollow"><span data-colorid="uqje4t8oq0" class="aui-icon aui-icon-small aui-iconfont-like">&nbsp;</span></a></div></div>