<p>The following proposal is put forward for how to implement interfaces in TACHL</p><p>1) The presents functions and integration of the old TACHL interface implementation will be left in place. It can be decided to remove these in the future but not necessary.</p><p>2) That the intstance function be rewritten to add support for parsing I/Os out the parameters being passed to the module being instantiated</p><p style="margin-left: 30.0px;">a) The present parameters interfaces and ports be left as is and still parsed to generate I/Os at the instance</p><p style="margin-left: 30.0px;">b) The function looks for an parameter called &quot;io&quot; in the parameters being passed to the module and processes that object to create ports on the instance.</p><p style="margin-left: 30.0px;">c) The object &quot;io&quot; will have the following structure:</p><pre style="margin-left: 30.0px;">{interfaces: [], extInterfaceNames: [], ports: []}</pre><p style="margin-left: 30.0px;">The arrays for interfaces and extInterfacesNames will be the same length:</p><pre style="margin-left: 30.0px;">Each object in interfaces will have the structure: </pre><pre style="margin-left: 30.0px;"> {name: &quot;a_string&quot;, signals: [], interfaces: [], exclusions[], meta: {}}. </pre><pre style="margin-left: 30.0px;">Each object in signals will have the structure:</pre><pre style="margin-left: 30.0px;"> {name: &quot;a_string&quot;, direction: &quot;in&quot; or &quot;out&quot;, width: expression resulting in an integer, excludable: true or false, meta: {}}.</pre><pre style="margin-left: 30.0px;">Each object in interfaces is another interface object. </pre><pre style="margin-left: 30.0px;">Each object in exclusions is a string. The string is composed of a name of an signal or interface and if a signal the bits of the signal being excluded.</pre><pre style="margin-left: 30.0px;">Each object in the array extInterfaceNames is a string, and represents the string prefixed onto the base interface signal name for the wire that is connected to an interface at the instance and each string at an index is used for the interface at the same index in the array interfaces. </pre><pre style="margin-left: 30.0px;">Each object in ports has the structure: {extSig: &quot;a_string&quot;, intSig: &quot;a_string&quot;, direction: &quot;in&quot; or &quot;out&quot;, width: integer, meta: {}}. &quot;extSig&quot; is the name of the wire for a signal at the instance level. &quot;intSig&quot; is the name of the port in the module definition. </pre><pre style="margin-left: 30.0px;">Each object at meta is an object place holder for software to use as they desire. From this point of view, it doesn't need to exist in BtB templates.</pre><p>3) A function will be written that will take the new Interface object and create a rendered bundle that follows the present definition of an interface.</p><p>4) A function will be written that takes the new Interface object and adds it to the port data base for creating the I/O within a module.</p><p>5) A function will be written that takes the new ports object and adds it to the port data base for creating the I/O within a module.</p><p>6) The json file passed to the instance's call will be modified before it is passed to the module for code generation. Two things will happen:</p><p style="margin-left: 30.0px;">a) The extInterfaceNames array and extSigs in ports will be set to null. This is done so that the hashing of the parameters isn't different between two blocks the have the same internal pin names but connect to different external wires.</p><p style="margin-left: 30.0px;">b) The ports widths will be modified based on the exclusions and the exclusions removed. </p><h1 id="TACHLInterfaceProposal-Examples:">Examples:</h1><h2 id="TACHLInterfaceProposal-OldStyle:">Old Style:</h2><pre>\jsbegin<br/>var atpInterface = {&quot;ready&quot;: 1, &quot;valid&quot;: -1, &quot;bus&quot;: 45};<br/>var atpIntExtName = &quot;ext_&quot;;<br/>var atpIntIntName = &quot;int_&quot;;</pre><pre>\jsend</pre><pre>//<br/>// At the instance<br/>//<br/>\=u.instance({<br/> &quot;instanceName&quot;: &quot;u_name&quot;,<br/> &quot;moduleName&quot;: &quot;a_module&quot;,<br/> &quot;params&quot;: {&quot;fstParam&quot;: 10,<br/>            &quot;sndParam&quot;: &quot;yes&quot;,<br/>            &quot;atpInterface&quot; : atpInterface,<br/>            &quot;atpIntName&quot; &quot; atpIntIntName},<br/> &quot;ports&quot;: {&quot;clk&quot; : &quot;a_clk&quot;,<br/>           &quot;reset_n&quot; : &quot;a_reset_n&quot;},<br/> &quot;interfaces&quot; :[{&quot;interface&quot; : atpInterface,<br/>                 &quot;localPrefix&quot; : atpIntExtName,<br/>                 &quot;modulePrefix&quot; : atpIntIntName}] // Notice that atpInterface and atpIntIntName are passed twice.<br/> })=\\jsbegin</pre><pre><br/>//<br/>// In the module<br/>//<br/>u.interface(atpIntName,&quot;master&quot;,atpInterface);<br/>u.port(&quot;input&quot;, &quot;clk&quot;, 1);<br/>u.port(&quot;input&quot;, &quot;reset_n&quot;, 1);\jsend<br/>module \= u.getModuleName()=\ (\=u.getPorts('\n ')=\);\jsbegin</pre><h2 id="TACHLInterfaceProposal-NewStyle:">New Style:</h2><pre>\jsbegin<br/>//<br/>// New style is more verbose in setting up Interfaces, but enables error checking<br/>//<br/>var atpSignals = [<br/> {&quot;name&quot; : &quot;ready&quot;, &quot;direction&quot; : &quot;out&quot;, &quot;width&quot; : 1,  &quot;excludable&quot; : false, &quot;meta&quot; : null},<br/> {&quot;name&quot; : &quot;valid&quot;, &quot;direction&quot; : &quot;in&quot;,  &quot;width&quot; : 1,  &quot;excludable&quot; : false, &quot;meta&quot; : null},<br/> {&quot;name&quot; : &quot;bus&quot;,   &quot;direction&quot; : &quot;out&quot;, &quot;width&quot; : 45, &quot;excludable&quot; : false, &quot;meta&quot; : null}];</pre><pre>var atpInterface = {&quot;name&quot; : &quot;int_&quot;, &quot;signals&quot; : atpSignals, &quot;interfaces&quot; : null, &quot;exclusions&quot; : null, &quot;meta&quot; : null};</pre><pre>var atpExtName = &quot;ext_&quot;;</pre><pre>//<br/>// New port style is nearly the same number of characters typed.<br/>//<br/>// If you write a function to generate your ports based on parameters,<br/>// it's the equivalent of implicit connections. All you need to is copy<br/>// the javascript from your present module and paste it into a function in the<br/>// common library. Now other people can use it also.<br/>//<br/>var ports = [<br/> {&quot;extSig&quot; : &quot;a_clk&quot;,     &quot;intSig&quot; : &quot;clk&quot;,     &quot;direction&quot; : &quot;in&quot;, &quot;width&quot; : 1},<br/> {&quot;extSig&quot; : &quot;a_reset_n&quot;, &quot;intSig&quot; : &quot;reset_n&quot;, &quot;direction&quot; : &quot;in&quot;, &quot;width&quot; : 1}];</pre><pre>var io = {&quot;interfaces&quot; : [atpInterface],<br/> &quot;extInterfaceNames&quot; : [atp_extName],<br/> &quot;ports&quot; : ports};</pre><pre>//<br/>// At the instance<br/>//<br/>// At the instance new style is less verbose, interfaces are only passed once so less error prone \jsend<br/>\=u.instance({<br/> &quot;instanceName&quot;: &quot;u_name&quot;,<br/> &quot;moduleName&quot;: &quot;a_module&quot;,<br/> &quot;params&quot;: {&quot;io&quot; : io,<br/>            &quot;fstParam&quot;: 10,<br/>            &quot;sndParam&quot;: &quot;yes&quot;}<br/> })=\\jsbegin</pre><pre>//<br/>// In the module<br/>//<br/>// In the module there is also less typing. The ports automatically match<br/>// up with the instance, so less error prone, especially if you use a<br/>// common function to generate your ports or interfaces.<br/>//<br/><a class="external-link" href="http://u.io" rel="nofollow">u.io</a>(io);\jsend<br/>module \= u.getModuleName()=\ (\=u.getPorts('\n ')=\);\jsbegin</pre><pre><span style="font-size: 24.0px;font-family: Arial , sans-serif;">Discussion</span></pre><p>While an interface is recursive, it need not be when described in a BtB template. Any given interface will have a set number of levels, and each level can be described with a separate BtB type description where the final object has no &quot;interfaces&quot; variable in it's object. The only issue I see is that you are going to want to take a template and give a value of null to interfaces. Is null supported in BtB templates as a value or default value?</p><h1 id="TACHLInterfaceProposal-6/14/2018MeetingNotes:">6/14/2018 Meeting Notes:</h1><p>1) <a class="confluence-userlink user-mention" data-account-id="624b37fc258562006fa692fa" href="https://arterisip.atlassian.net/wiki/people/624b37fc258562006fa692fa?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">John Coddington (Deactivated)</a> explained his proposal.</p><p>2) <a class="confluence-userlink user-mention" data-account-id="624b37b82e101c006a910636" href="https://arterisip.atlassian.net/wiki/people/624b37b82e101c006a910636?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">Manadher Kharroubi (Deactivated)</a> expressed a different proposal : <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16157579/Interface+Definition+and+use+model+Manadher+s+proposal" data-linked-resource-id="16157579" data-linked-resource-version="17" data-linked-resource-type="page">Interface Definition and use model (Manadher's proposal)</a></p><p>3) <a class="confluence-userlink user-mention" data-account-id="624b37b82e101c006a910636" href="https://arterisip.atlassian.net/wiki/people/624b37b82e101c006a910636?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">Manadher Kharroubi (Deactivated)</a> was asked to document his proposal complete with examples so the proposal could be discussed.</p><h1 id="TACHLInterfaceProposal-ActionItems:">Action Items:</h1><p>1) <a class="confluence-userlink user-mention" data-account-id="624b37b82e101c006a910636" href="https://arterisip.atlassian.net/wiki/people/624b37b82e101c006a910636?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">Manadher Kharroubi (Deactivated)</a> creates a confluence page to express his proposal by <time datetime="2018-06-18" class="date-past">18 Jun 2018</time> morning.</p><h1 id="TACHLInterfaceProposal-8/7/2018MeetingNotes:">8/7/2018 Meeting Notes:</h1><p>1) Manadher started on overview of why we ended up with the decision to use a templated flow vs. a generator flow. The presentation was not completed and will complete on another day.</p><p>During the presentation John stated that one of the big reasons we ended up with a templated flow was the belief that templated flows are more ECOable than generator flows.</p><p>2) John feels that the things being passed to represent interfaces should be interface instances, not just the parameters associated with generating the width of signals in an interface.</p><p>3) Manadher said not all parameters passed to a block need to be documented in BtB templates.</p><p>4) George said that we need to formally document how info generated during the creation of the RTL code is passed back to software.</p><h1 id="TACHLInterfaceProposal-Actionitems:">Action items:</h1><ul class="inline-task-list" data-inline-tasks-content-id="16167296"><li class="checked" data-inline-task-id="35"><span><a class="confluence-userlink user-mention" data-account-id="624b37fc258562006fa692fa" href="https://arterisip.atlassian.net/wiki/people/624b37fc258562006fa692fa?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">John Coddington (Deactivated)</a> publishes needed functionality on web page and sends link to all on meeting list. (To be added in comments).</span></li><li data-inline-task-id="36"><span><a class="confluence-userlink user-mention" data-account-id="624b37b82e101c006a910636" href="https://arterisip.atlassian.net/wiki/people/624b37b82e101c006a910636?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">Manadher Kharroubi (Deactivated)</a> documents how software is going to meet functionality 2 requirement from John's list (don't pass things twice and auto generate port list from instance info.)</span></li><li data-inline-task-id="37"><span><a class="confluence-userlink user-mention" data-account-id="624b37b82e101c006a910636" href="https://arterisip.atlassian.net/wiki/people/624b37b82e101c006a910636?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">Manadher Kharroubi (Deactivated)</a> </span>documents a set of rules that documents the type of parameters that need to be in a BtB template and which do not.</li><li data-inline-task-id="40"><a class="confluence-userlink user-mention" data-account-id="624b37b82e101c006a910636" href="https://arterisip.atlassian.net/wiki/people/624b37b82e101c006a910636?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">Manadher Kharroubi (Deactivated)</a> documents how the information about parameters not described in a BtB template are communicated to software.</li><li data-inline-task-id="38"><a class="confluence-userlink user-mention" data-account-id="624b37b82e101c006a910636" href="https://arterisip.atlassian.net/wiki/people/624b37b82e101c006a910636?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">Manadher Kharroubi (Deactivated)</a> documents the proposed flow where TACHL code generates information read by SW. This is how TACHL code does things like reports the number of registers or creates IPXACT registers descriptions for blocks that can't really be done in a BtB template (because that parameters needed to create it aren't in the BtB template.)</li><li data-inline-task-id="39"><a class="confluence-userlink user-mention" data-account-id="624b37b82e101c006a910636" href="https://arterisip.atlassian.net/wiki/people/624b37b82e101c006a910636?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">Manadher Kharroubi (Deactivated)</a> responds to the other requirements in John's list that are not coverage by other action items.</li></ul>
<p> </p><p> </p><p> </p>