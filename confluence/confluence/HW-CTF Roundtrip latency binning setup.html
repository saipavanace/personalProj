<p>This page describes a proposal on how to set up events and timer resources in the PMON blocks using their parameters to generate logic for roundtrip latency binning in Symphony. Roundtrip latency is measured as the number of clocks it takes from the moment a context entry is allocated to a request in the ATU till the moment that entry is deallocated ( on arrival of the response ). Events are generated by the ATU for allocation and deallocation of every context entry in the ATU. They are then used with timer resources in the pmon_stats to measure latencies and to count the number of times the latencies fall in a given range (binning). </p><h2 id="HW-CTFRoundtriplatencybinningsetup-Events">Events</h2><p>This setup uses the context-allocation (alloc) and context-deallocation (dealloc) events generated from an ATU Initiator to measure latency. Symphony ATU initiators generate an alloc event and a dealloc event for each context entry in the CTL block. The number of such events generated is determined as follows:</p><p>Number of alloc events  = Number of dealloc events = Number of context entries = maxOutTotal = N</p><p>maxOutTotal or the number of outstanding transactions (read or write) is one of the parameters of the atui_axi and atui_apb. </p><p>In Symphony R1, there is a pmon_stats block can be inserted on a per-ATU-initiator basis. All alloc events and dealloc events of an ATU initiator go to the pmon_stats block associated with it. In addition, this setup requires a number of derived internal count events described in the section below on binning counters.</p><h2 id="HW-CTFRoundtriplatencybinningsetup-Latencytimers">Latency timers</h2><p>As many latency timers are created in pmon_stats as the number of context entries in the ATU initiator = N: LAT_TMR_0, LAT_TMR_1, ... LAT_TMR_N-1. The timer is setup so that an alloc event from a context-entry i, starts the ith timer, and a dealloc event from the same entry resets and stops the timer. Number of latency timers = maxOutTotal.</p><h2 id="HW-CTFRoundtriplatencybinningsetup-Binningcounters">Binning counters</h2><p>As many binning counters exist as the number of bins specified by the nBins parameter. Every bin has an associated set of two registers to define the upper and lower boundaries for range of latencies that must fall in that bin. These boundary registers can be set up as user-defined registers using the regFieldDefines parameter in pmon_stats, with names: bin_i_ul and bin_i_ll for the ith bin.</p><p>To count each bin we generate conditional (internal) events within the PMON stats is explained below.</p><p>The count event for the ith bin can be derived as</p><p>count_bin_i       = count_bin_i_entry_0 | count_bin_i_entry_1 | ... | count_bin_i_entry_N-1.</p><p><br/></p><p>where N is the number of context entries, and count_bin_i_entry_j is the event that is generated whenever the roundtrip latency for request in context-entry j falls in the bin i. It can be derived as:</p><p>count_bin_i_entry_j  = (LAT_TMR_j_val_val_out &gt; bin_i_ul) &amp; (LAT_TMR_j_val_val_out &lt;= bin_i_ll) &amp; (dealloc_j).</p><p>Where LAT_TMR_j and dealloc_j are the latency timer and dealloc event for context entry j. LAT_TMR_j_val is the timer value register associated with the LAT_TMR_j and LAT_TMR_j_val_val_out is the register-field.</p><h2 id="HW-CTFRoundtriplatencybinningsetup-Registers">Registers</h2><p>Each Latency timer and binning counter will create 4 registers:</p><ol><li>Timer value</li><li>Timer limit</li><li>Timer control </li><li>Timer enable and mode</li></ol><p>In addition, there will be 2 boundary registers for every bin, which need to be specified as part of the regFieldDefines parameter in pmon_stats. Thus the number of registers required for implementing roundtrip latency binning can be computed as:</p><p>(N + nBins ) x 4 + nBins x 2</p><p>where N is the number of context entries and nBins is the number of bins.</p><p><br/></p>