<p>The uart_wrapper instantiates two free IPs</p><p style="margin-left: 30.0px;"><a href="https://arterisip.atlassian.net/wiki/download/attachments/16162103/wbspec_b3.pdf?version=1&amp;modificationDate=1623335155970&amp;cacheVersion=1&amp;api=v2" data-linked-resource-id="16191864" data-linked-resource-version="1" data-linked-resource-type="attachment" data-linked-resource-default-alias="wbspec_b3.pdf" data-nice-type="PDF Document" data-linked-resource-content-type="application/pdf" data-linked-resource-container-id="16162103" data-linked-resource-container-version="8">axim2wbsp</a>: AXI to Wishbone gasket</p><p style="margin-left: 30.0px;"><a href="https://arterisip.atlassian.net/wiki/download/attachments/16162103/UART_spec.pdf?version=1&amp;modificationDate=1623335149415&amp;cacheVersion=1&amp;api=v2" data-linked-resource-id="16191889" data-linked-resource-version="1" data-linked-resource-type="attachment" data-linked-resource-default-alias="UART_spec.pdf" data-nice-type="PDF Document" data-linked-resource-content-type="application/pdf" data-linked-resource-container-id="16162103" data-linked-resource-container-version="8">uart16550</a>: Wishbone to UART</p><p style="margin-left: 30.0px;"><a href="https://arterisip.atlassian.net/wiki/download/attachments/16162103/wbspec_b4.pdf?version=1&amp;modificationDate=1623589431412&amp;cacheVersion=1&amp;api=v2" data-linked-resource-id="16186270" data-linked-resource-version="1" data-linked-resource-type="attachment" data-linked-resource-default-alias="wbspec_b4.pdf" data-nice-type="PDF Document" data-linked-resource-content-type="application/pdf" data-linked-resource-container-id="16162103" data-linked-resource-container-version="8">wishboneB4</a>: Latest version of wishbone interface spec.</p><p style="margin-left: 30.0px;"><span class="legacy-color-text-blue1">UART 16550 SPEC</span>: <a href="/wiki/spaces/ENGR/pages/16162103/uart_wrapper?preview=%2F16162103%2F16191889%2FUART_spec.pdf"><span style="background: url('/wiki/s/-672721829/6452/d621ad2a33e27b90ca05c475b216bfab745e08a2/1000.0.0-d621ad2a33e2/_/download/resources/com.atlassian.confluence.plugins.confluence-view-file-macro:view-file-macro-resources/images/placeholder-medium-pdf.png'); width: 333px; height: 95px; display: inline-block; padding-top: 155px; margin: 2px; border: 1px solid #ddd; text-align: center; vertical-align: text-bottom; text-decoration: none; font-size: 12px; color: #000;">UART_spec.pdf</span></a></p><h1 id="uart_wrapper-Code">Code</h1><p>The following link is a tar to the *.v files:</p><p style="margin-left: 30.0px;"><a href="https://arterisip.atlassian.net/wiki/download/attachments/16162103/uart_wrapper.tar?version=3&amp;modificationDate=1623589494663&amp;cacheVersion=1&amp;api=v2" data-linked-resource-id="16191662" data-linked-resource-version="3" data-linked-resource-type="attachment" data-linked-resource-default-alias="uart_wrapper.tar" data-linked-resource-content-type="application/x-tar" data-linked-resource-container-id="16162103" data-linked-resource-container-version="8">uart_wrapper.tar</a></p><h1 id="uart_wrapper-I/O">I/O</h1><pre>module uart_wrapper <br/>  #(<br/>    localparam C_AXI_ID_WIDTH = 11,        // The AXI id width used for R&amp;W<br/>                                                      // This is an int between 1-16<br/>    localparam C_AXI_DATA_WIDTH     = 64, // Width of the AXI R&amp;W data<br/>    localparam C_AXI_ADDR_WIDTH = 44, // AXI Address width<br/>    localparam AXI_LSBS = $clog2(C_AXI_DATA_WIDTH)-3,<br/>    localparam DW = C_AXI_DATA_WIDTH,<br/>    localparam AW = C_AXI_ADDR_WIDTH - AXI_LSBS,<br/>    localparam LGFIFO = 5,<br/>    localparam [0:0] OPT_READONLY = 1'b0,<br/>    localparam [0:0] OPT_WRITEONLY = 1'b0,<br/>    localparam uart_data_width = `UART_DATA_WIDTH,<br/>    localparam uart_addr_width = `UART_ADDR_WIDTH<br/>    ) <br/>   (<br/>    input wire                          S_AXI_ACLK, // System clock<br/>    input wire                          S_AXI_ARESETN,<br/><br/> // AXI write address channel signals<br/> // {{{<br/>    input wire                          S_AXI_AWVALID,<br/>    output wire                         S_AXI_AWREADY,<br/>    input wire [C_AXI_ID_WIDTH-1:0]     S_AXI_AWID,<br/>    input wire [C_AXI_ADDR_WIDTH-1:0]   S_AXI_AWADDR,<br/>    input wire [7:0]                    S_AXI_AWLEN,<br/>    input wire [2:0]                    S_AXI_AWSIZE,<br/>    input wire [1:0]                    S_AXI_AWBURST,<br/>    input wire [0:0]                    S_AXI_AWLOCK,<br/>    input wire [3:0]                    S_AXI_AWCACHE,<br/>    input wire [2:0]                    S_AXI_AWPROT,<br/>    input wire [3:0]                    S_AXI_AWQOS,<br/> // }}}<br/> // AXI write data channel signals<br/> // {{{<br/>    input wire                          S_AXI_WVALID,<br/>    output wire                         S_AXI_WREADY, <br/>    input wire [C_AXI_DATA_WIDTH-1:0]   S_AXI_WDATA,<br/>    input wire [C_AXI_DATA_WIDTH/8-1:0] S_AXI_WSTRB,<br/>    input wire                          S_AXI_WLAST,<br/> // }}}<br/> // AXI write response channel signals<br/> // {{{<br/>    output wire                         S_AXI_BVALID, <br/>    input wire                          S_AXI_BREADY,<br/>    output wire [C_AXI_ID_WIDTH-1:0]    S_AXI_BID,<br/>    output wire [1:0]                   S_AXI_BRESP,<br/> // }}}<br/> // AXI read address channel signals<br/> // {{{<br/>    input wire                          S_AXI_ARVALID,<br/>    output wire                         S_AXI_ARREADY,<br/>    input wire [C_AXI_ID_WIDTH-1:0]     S_AXI_ARID,<br/>    input wire [C_AXI_ADDR_WIDTH-1:0]   S_AXI_ARADDR,<br/>    input wire [7:0]                    S_AXI_ARLEN,<br/>    input wire [2:0]                    S_AXI_ARSIZE,<br/>    input wire [1:0]                    S_AXI_ARBURST,<br/>    input wire [0:0]                    S_AXI_ARLOCK,<br/>    input wire [3:0]                    S_AXI_ARCACHE,<br/>    input wire [2:0]                    S_AXI_ARPROT,<br/>    input wire [3:0]                    S_AXI_ARQOS,<br/> // }}}<br/> // AXI read data channel signals<br/> // {{{<br/>    output wire                         S_AXI_RVALID, // Rd rslt valid<br/>    input wire                          S_AXI_RREADY, // Rd rslt ready<br/>    output wire [C_AXI_ID_WIDTH-1:0]    S_AXI_RID, // Response ID<br/>    output wire [C_AXI_DATA_WIDTH-1:0]  S_AXI_RDATA,// Read data<br/>    output wire                         S_AXI_RLAST, // Read last<br/>    output wire [1:0]                   S_AXI_RRESP, // Read response<br/><br/>                // UART signals<br/>    output wire                         int_o,<br/>    input wire                          srx_pad_i,<br/>    output wire                         stx_pad_o);</pre><h1 id="uart_wrapper-AddressMap">Address Map</h1><p>Because of the DII only supports 64 bits of data and the UART only supports 8 bits of data, and the AXI to wishbone gasket forces the data width to be the same on both interfaces, the address for the UART block get modified to the following:</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh">Name</th><th class="confluenceTh">AXI Address[5:3]</th><th class="confluenceTh">Width</th><th class="confluenceTh">Access</th><th class="confluenceTh">Description</th></tr><tr><td class="confluenceTd">Receiving Buffer</td><td class="confluenceTd">3'd0</td><td class="confluenceTd">8</td><td class="confluenceTd">R</td><td class="confluenceTd">Receiver FIFO output</td></tr><tr><td class="confluenceTd">Transmitter Holding Register</td><td class="confluenceTd">3'd0</td><td class="confluenceTd">8</td><td class="confluenceTd">W</td><td class="confluenceTd">Transmit FIFO input</td></tr><tr><td class="confluenceTd">Interrupt Enable</td><td class="confluenceTd">3'd1</td><td class="confluenceTd">8</td><td class="confluenceTd">RW</td><td class="confluenceTd">Enable/Mask interrupts generated by UART</td></tr><tr><td class="confluenceTd">Interrupt Identification</td><td class="confluenceTd">3'd2</td><td class="confluenceTd">8</td><td class="confluenceTd">R</td><td class="confluenceTd"><p>Get interrupt information</p></td></tr><tr><td class="confluenceTd">FIFO control</td><td class="confluenceTd">3'd2</td><td class="confluenceTd">8</td><td class="confluenceTd">W</td><td class="confluenceTd">Control FIFO options</td></tr><tr><td class="confluenceTd">Line Control Register</td><td class="confluenceTd">3'd3</td><td class="confluenceTd">8</td><td class="confluenceTd">RW</td><td class="confluenceTd">Control connection</td></tr><tr><td class="confluenceTd">Modem Control Register</td><td class="confluenceTd">3'd4</td><td class="confluenceTd">8</td><td class="confluenceTd">W</td><td class="confluenceTd">Controls modem</td></tr><tr><td colspan="1" class="confluenceTd">Line Status</td><td colspan="1" class="confluenceTd">3'd5</td><td colspan="1" class="confluenceTd">8</td><td colspan="1" class="confluenceTd">R</td><td colspan="1" class="confluenceTd">Status information</td></tr><tr><td colspan="1" class="confluenceTd">Modem Status</td><td colspan="1" class="confluenceTd">3'd6</td><td colspan="1" class="confluenceTd">8</td><td colspan="1" class="confluenceTd">R</td><td colspan="1" class="confluenceTd">Modem Status</td></tr></tbody></table></div><p class="auto-cursor-target">The AXI address bits [43:6] and [2:0] are ignored by the logic, and so these registers are repeated across the entire AXI address space</p><h1 class="auto-cursor-target" id="uart_wrapper-WrapperGlueLogic">Wrapper Glue Logic</h1><p class="auto-cursor-target">The gasket plus wrapper can only handle a single beat transaction at a time (read and writes combined.) To handle this, the following logic is implemented in the wrapper:</p><pre>always @(posedge S_AXI_ACLK or negedge S_AXI_ARESETN)<br/>  if (!S_AXI_ARESETN)<br/>    begin<br/>      busy &lt;= 1'b0;<br/>      busy_is_read &lt;= 1'b0;<br/>      read_write_b &lt;= 1'b0;<br/>      write_data_hap &lt;= 1'b0;<br/>    end<br/>  else<br/>    begin<br/>      busy &lt;= next_busy;<br/>      busy_is_read &lt;= next_busy_is_read;<br/>      read_write_b &lt;= ~read_write_b;<br/>      write_data_hap &lt;= next_write_data_hap;<br/>    end<br/><br/>assign next_write_data_hap = (~write_data_hap &amp; S_AXI_WVALID &amp; S_AXI_WREADY &amp; S_AXI_WLAST) |<br/>                             (write_data_hap &amp; ~(S_AXI_BVALID &amp; S_AXI_BREADY));<br/><br/>assign next_busy = (busy &amp; ~((S_AXI_RVALID &amp; S_AXI_RREADY) | (S_AXI_BVALID &amp; S_AXI_BREADY))) |<br/>                   (~busy &amp; ((S_AXI_ARREADY &amp; S_AXI_ARVALID) | (S_AXI_AWREADY &amp; S_AXI_AWVALID)));<br/><br/>assign next_busy_is_read = (~busy &amp; ((S_AXI_ARVALID &amp; S_AXI_ARREADY))) |<br/>                           (busy &amp; busy_is_read);<br/><br/>assign int_S_AXI_ARVALID = S_AXI_ARVALID &amp; ~busy &amp; read_write_b;<br/>assign S_AXI_ARREADY = int_S_AXI_ARREADY &amp; ~busy &amp; read_write_b;<br/><br/>assign int_S_AXI_AWVALID = S_AXI_AWVALID &amp; ~busy &amp; ~read_write_b;<br/>assign S_AXI_AWREADY = int_S_AXI_AWREADY &amp; ~busy &amp; ~read_write_b;<br/><br/>assign int_S_AXI_WVALID = S_AXI_WVALID &amp; (~busy &amp; ~read_write_b &amp; S_AXI_AWREADY &amp; S_AXI_AWVALID | busy &amp; ~busy_is_read &amp; ~write_data_hap);<br/>assign S_AXI_WREADY = int_S_AXI_WREADY &amp; (~busy &amp; ~read_write_b &amp; S_AXI_AWREADY &amp; S_AXI_AWVALID | busy &amp; ~busy_is_read &amp; ~write_data_hap);</pre><p class="auto-cursor-target">To tie off the unused modem signals, the following logic was added:</p><pre>// Tie off unused signals<br/>assign cts_pad_i = 1'b0;<br/>assign dsr_pad_i = 1'b0;<br/>assign ri_pad_i = 1'b0;<br/>assign dcd_pad_i = 1'b0;</pre><p><br/>To handle the width mismatches between the wishbone interface coming out of the axi to wishbone gasket and the wishbone interface on the UART, the following logic is used:</p><pre>// Connect up the wishbones and tie off unused bits:<br/>assign wb_adr_i = o_wb_addr[2:0];<br/>assign wb_dat_i = o_wb_data[63:56];<br/>assign i_wb_data[7:0] = wb_dat_o;<br/>assign i_wb_data[63:8] = 56'b0;<br/>assign wb_we_i = o_wb_we;<br/>assign wb_stb_i = o_wb_stb;<br/>assign wb_cyc_i = o_wb_cyc;<br/>assign i_wb_ack = wb_ack_o;<br/>assign i_wb_stall = o_wb_cyc &amp; ~wb_ack_o;<br/>assign i_wb_err = 1'b0;</pre><p class="auto-cursor-target">This results in the read and write data to only be valid in bits [7:0] of the read and write data buses.</p>