<h1 id="OBSOLETE-DELETEHW-SYMsym_switch-module_name"><strong>module_name</strong></h1><p>sym_switch</p><h1 id="OBSOLETE-DELETEHW-SYMsym_switch-parameters"><strong>parameters</strong></h1><pre>{</pre><pre> interfaces:{</pre><pre>   clkInterface: {name: &quot;a_string&quot;, params: {}, direction: &quot;master&quot; or &quot;slave&quot;, interface: &quot;a_string&quot;},</pre><pre>   cfgInterface: {name: &quot;a_string&quot;, params: {}, direction: &quot;master&quot; or &quot;slave&quot;, interface: &quot;a_string&quot;}, // Optional based on weightsProg</pre><pre>   protectionInterface: {name: &quot;a_string&quot;, params: {}, direction: &quot;master&quot; or &quot;slave&quot;, interface: &quot;a_string&quot;}, // Optional based on protectionStyle</pre><pre>   inInterfaces: [</pre><pre>     {name: &quot;a_string&quot;,</pre><pre>      params: {nVc: positive integer, wBus: positive integer, wProt: non negative integer},</pre><pre>      direction: &quot;slave&quot;, </pre><pre>      interface: &quot;InterfaceATP&quot;, </pre><pre>      pktDef: {params: {ATP Packet Params}, packet: &quot;a_string&quot;}},</pre><pre>     {},{}], //array depth sets numIngress, width of &quot;valid&quot; in interface sets numVc</pre><pre>   outInterfaces: [</pre><pre>     {name: &quot;a_string&quot;,</pre><pre>      params: {nVc: positive integer, wBus: positive integer, wProt: non negative integer},</pre><pre>      direction: &quot;master&quot;,</pre><pre>      interface: &quot;InterfaceATP&quot;,</pre><pre>      pktDef: {params: {ATP Packet Params}, packet: &quot;a_string&quot;}},</pre><pre>     {},{}] //array depth sets numEgress</pre><pre>   }, </pre><pre> assertOn: boolean // Simulation only, used to turn on asserts.</pre><pre> mstrArbLck: boolean // true master arb locks, false master arb doesn't lock. Default false.</pre><pre> vcLckStyleVld: boolean // Lock Style of VC arbiters. true locks on valid, false locks on ready. Default false.</pre><pre> mstrLckStyleVld: boolean // Lock Style of master arbiter. true locks on valid, false locks on ready. Default false.</pre><pre> weightsProg: Boolean, </pre><pre> numPri: positive integer, </pre><pre> routeFields: [{rf:[&quot;a_string&quot;,&quot;&quot;,&quot;&quot;]}, // array depth variable</pre><pre>   {rf:[]},{rf:[]}], // array depth = numIngress </pre><pre> routeShift: [non negative integer, , ,] array depth = numIngress </pre><pre> routeMap: [rm:{[{bitPat: &quot;a_string&quot;, egressPort: non negative integer},{},{}]}, // array depth min = 1, array depth max = numEgress</pre><pre>   {rm:[]},{rm:[]}], // array depth = numIngress </pre><pre> arbType: [{</pre><pre>   master: &quot;a_string&quot;, </pre><pre>   vcs: [&quot;a_string&quot;,&quot;a_string&quot;] // array depth = vcMap depth for given egress port.</pre><pre>   },{},{}], // array depth = numEgress </pre><pre> masterArbReadyAware: [boolean,,], // array depth = numEgress </pre><pre> vcMap: [{vm:[non negative integer,,]}, // array depth min = 1, array depth max = numVc</pre><pre>   {vm:[]},{vm:[]}], // array depth = numEgress </pre><pre> portMap: [</pre><pre>     {ports: [non negative integer,,], // array depth min = 1, array depth max = numIngress</pre><pre>      vcs: [{vc:[non negative integer,,]}, // array depth min = 1, array depth max = ports.length</pre><pre>        {vc:[]},{vc:[]}] // array depth = vcMap depth for given egress port</pre><pre>     },</pre><pre>   {},{}], // array depth = numEgress </pre><pre> weights: [{master: [positive integer,,], // array depth = vcMap depth for given egress port</pre><pre>            vcs: [{vc:[positive integer,,]}, // array depth = portMap depth for given egress port per given VC</pre><pre>                  {vc:[]},{vc:[]}] // array depth = vcMap depth for given egress port},</pre><pre>           {},{}], // array depth = numEgress </pre><pre> protectionStyle: &quot;&quot; or {<a class="external-link" href="https://confluence.arteris.com/display/ENGR/protectionStyle" rel="nofollow">protectionStyle</a>} // applies to internal registers, not to interface.</pre><pre>}</pre><h1 class="page view" id="OBSOLETE-DELETEHW-SYMsym_switch-ParameterDescription:">Parameter Description:</h1><p><strong>numIngress</strong>: length of inInterfaces array</p><p><strong>numEgress</strong>: length of outInterfaces array</p><p><strong>numVc</strong>: width of valid and ready signals in any ATP interface; all must match</p><p><strong>routeFields</strong>: [{rf:[&quot;a_string&quot;,&quot;b_string&quot;]},{},{}]</p><p><strong>Discussion</strong>: Two dimensional array. Entry 0 in top array correlates to inInterfaces[0] and so on. Strings in sub array describes which fields in the header will be used to determine route. Multiple strings indicate multiple fields that are concatenated together to determine the bits used to route a packet to an egress port. A check will be done to verify that the number of egress ports can be encoded in the width of the fields provided.</p><p><strong>routeMap</strong>: [{rm:[{bitPat: &quot;a_string&quot;,egressPort: int},{},{}]},{},{}]</p><p><strong>Discussion</strong>: Two dimensional array. Entry 0 in top array correlates to inInterfaces[0] and so on. The subarrays is an array of bit patterns that map the bits defined in routeFields to an egress port.</p><p><strong>routeShift</strong>: [int,int,,]</p><p><strong>Discussion:</strong> An array indicating the the number of bits the route field is shifted per ingress port. There is a check run to verify that when shift is greater than 0, there is only one field being shifted. The value indicates the number of positions shifted. The shift style is rotate left.</p><p>Example: Use field H_route[3] to define routing for a 2x2 switch on all ingress ports.</p><p>routeFields:[{rf:[&quot;H_route[3]&quot;]},{rf:[&quot;H_route[3]&quot;]}],</p><p>routeMap:[{rm:[</p><p>{bitPat:&quot;1'b0&quot;,out: 0},</p><p>{bitPat:&quot;1'b1&quot;,out: 1}],</p><p>{bitPat:&quot;1'b0&quot;,out: 0},</p><p>{bitPat:&quot;1'b1&quot;,out: 1}]}],</p><p>routeShift: [1,1],</p><p><strong>arbType</strong>: [{master: &quot;a_string&quot;, vcs: [&quot;a_string&quot;,&quot;a_string&quot;]},{},{}]</p><p><strong>Discussion:</strong> An array indicating the type of arbiters used for each egress port. Entry 0 in top array correlates to outInterfaces[0] and so on. For any given egress port that are one or more arbiters. There is an arbiter per VC that is mapped to an egress port (see below) and if there is more than 1 VC, there is a master arbiter. The array vcs[0] corresponds to the first vc mapped to an egress port and so on. The strings correspond to the module names of the primitive arbiters that exist in the library.</p><p>Example: A 2x2 arbiter with 2 VCs per egress port used arb_rr1 for vc arbiters and arb_pri_rr1 for master arbiters.</p><p>arbType: [{master: &quot;arb_pri_rr1&quot;, vcs:[&quot;arb_rr1&quot;,&quot;arb_rr1&quot;]},{master: &quot;arb_pri_rr1&quot;, vcs:[&quot;arb_rr1&quot;,&quot;arb_rr1&quot;]}],</p><p><strong>masterArbReadyAware</strong>: [boolean,,]</p><p><strong>Discussion</strong>: An array indicating if the master arbiter for an egress port is ready away. Only an egress port talking directly to a buffering element or ATU target can be ready away. Entry 0 in top array correlates to outInterface[0] and so on.</p><p><strong>vcMap</strong>: [{vm:[int,int,int]},{},{}]</p><p><strong>Discussion</strong>: An array indicating which VCs go to which egress ports. Not all VCs will go to any given egress port and significant logic can be saved by reducing mux widths on data path and timing saved by reducing ports on arbiters. Entry 0 in top array correlates to outInterface[0] and so on.</p><p>Example. A 2x2 arbiter with 4 VCs, where all VCs go to egress port 0, but only VCs 1 and 3 got to egress port 1.</p><p>vcMap:[{vm:[0,1,2,3]},{vm:[1,3]}],</p><p><strong>portMap</strong>:[{ports:[int,int,int],vcs[{vc:[int,int,int]},{},{}]},{},{}]</p><p><strong>Discussion</strong>: An array indicating which ingress ports can talk to which egress ports. Not all ingress ports will talk to all egress ports and not all ingress ports that go to an egress port use all the VCs and significant logic can be saved by reducing mux widths on data path and timing saved by reducing ports on arbiters. Entry 0 in top array correlates to outInterface[0] and so on. portMap[0].vcs array entry 0 corresponds to vcMap[0][0] and so on.</p><p>Example. Using the vcMap in the vcMap example, show a port map where egress port 0 gets both ingress ports, but egress port 1 only gets ingress port 1 requests for VC 3 and port 0 requests for VC 1.</p><p>portMap:[{ports[0,1],vcs[{vc:[0,1]},{vc:[0,1]},{vc:[0,1]},[0,1]]},{ports[0,1],vcs[{vc:[0]},{vc:[1]}]}],</p><p>portMap[1].vcs[0] corresponds to VC 1 and portMap[1].vcs[1] corresponds to VC 3. An equivalent map would be:</p><p>portMap:[{ports[0,1],vcs[{vc:[0,1]},{vc:[0,1]},{vc:[0,1]},{vc:[0,1]}]},{ports[1,0],vcs[{vc:[1]},{vc:[0]}]}],</p><p><strong>weights</strong>: [{master:[int,int,int],vcs[{vc:[int,int,int]},{},{}]},{},{}]</p><p><strong>Discussion</strong>: One of the type of arbiters is arb_wrr_rr1, which is a weighted round robin. When a weighted round robin arbiter is used there are weights that are assigned to each request port an arbiter. The weights parameter assumes all arbiters are weighted round robin, though they may not be. Entry 0 in the top array corresponds to outInterface[0] and weights[0].master will have the same number of entries as vcMap[0] and weights[0].vcs[0] will have the same number of entries as portMap[0].vcs[0].</p><p>Example. Assuming the examples giving in 15 and 16 use all weighted round robin arbiters if they exist.</p><p>weights:[{master:[1,1,1,1],vcs[{vc:[1,1]},{vc:[1,1]},{vc:[1,1]},{vc:[1,1]}]},{master:[1,1],vcs[{vc:[1]},{vc:{[1]}]},</p><p><strong>weightsProg</strong>: boolean</p><p><strong>Discussion</strong>: Weights may be hard coded, weightsProg:false or programable, weightsProg:true. When true, the weights values are the bit width of the weights as stored in a registers.</p><p><strong>vcLckStyleVld</strong>: boolean</p><p><strong>Discussion</strong>: When VC arbiters lock, do they lock on first valid of a packet, vcLckStyleVld: true, or on the first ready of a packet, vcLckStyleVld: false. For a detailed description refer to <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16167479/OBSOLETE-DELETE+HW-SYM+sym_sw_arb" data-linked-resource-id="16167479" data-linked-resource-version="50" data-linked-resource-type="page">OBSOLETE-DELETE HW-SYM sym_sw_arb</a></p><p><strong>mstrArbLck</strong>: boolean</p><p><strong>Discussion</strong>: Master Arbiters soft locks on packets, mstrArbLck: true or does not, mstrArbLck: false. For a detailed description refer to <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16167479/OBSOLETE-DELETE+HW-SYM+sym_sw_arb" data-linked-resource-id="16167479" data-linked-resource-version="50" data-linked-resource-type="page">OBSOLETE-DELETE HW-SYM sym_sw_arb</a></p><p><strong>mstrLckStyleVld</strong>: boolean</p><p><strong>Discussion</strong>: When master arbiters lock, do they lock on first valid of a packet, mstrLckStyleVld: true, or on the first ready of a packet, mstrLckStyleVld: false. For a detailed description refer to <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16167479/OBSOLETE-DELETE+HW-SYM+sym_sw_arb" data-linked-resource-id="16167479" data-linked-resource-version="50" data-linked-resource-type="page">OBSOLETE-DELETE HW-SYM sym_sw_arb</a></p><h1 id="OBSOLETE-DELETEHW-SYMsym_switch-I/O:"><strong>I/O:</strong><span style="font-size: 14.0px;"> </span></h1><pre>var clkInterfaceFunc = new obj.userLib[interfaces.clkInterface.interface];</pre><pre>var clkInterface = clkInterfaceFunc.getSignalsBundle(interfaces.clkInterface.params);</pre><pre>u.interface(interfaces.clkInterface.name, 'slave', clkInterface);</pre><pre>if (weightsProg === &quot;yes&quot;) {</pre><pre>  var cfgInterfaceFunc = new obj.userLib[interfaces.cfgInterface.interface];</pre><pre>  var cfgInterface = cfgInterfaceFunc.getSignalsBundle(interfaces.cfgInterface.params);</pre><pre>  u.interface(interfaces.cfgInterface.name, 'slave', cfgInterface);</pre><pre>} </pre><pre>var inInterfaces = []; </pre><pre>var inInterfaceFuncs = [];</pre><pre>for (i = 0; i &lt; interfaces.inInterfaces.length; i++) { </pre><pre>  inInterfaceFuncs[i] = new obj.userLib[interfaces.inInterfaces[i].interface]; </pre><pre>  inInterfaces[i] = inInterfaceFuncs[i].getSignalsBundle(interfaces.inInterfaces[i].params);</pre><pre>  u.interface(interfaces.inInterfaces[i].name, 'slave', inInterfaces[i]);</pre><pre>}</pre><pre>var outInterfaceFuncs = []; </pre><pre>var outInterfaces = [];</pre><pre>for (i = 0; i &lt; interface.outInterfaces.length; i++) {<span style="font-family: Arial , sans-serif;"> </span></pre><pre>  outInterfaceFuncs[i] = new obj.userLib[interfaces.outInterfaces[i].interface]; <span style="font-family: Arial , sans-serif;"> </span></pre><pre>  outInterfaces[i] = outInterfaceFuncs[i].getSignalsBundle(interfaces.outInterfaces[i].params);<span style="font-family: Arial , sans-serif;"> </span></pre><pre>  u.interface(interfaces.outInterfaces[I].name, 'master', outInterfaces[i]);</pre><pre>}</pre><pre>if (protectionStyle !== &quot;&quot;) {</pre><pre>  var protectionInterfaceFunc = new obj.userLib[interfaces.protectionInterface.interface];</pre><pre>  var protectionInterface = protectionInterfaceFunc.getSignalsBundle(interfaces.protectionInterface.params);</pre><pre> u.interface(protectionInterface.name, 'slave', protectionInterface);</pre><pre>}</pre><pre>or</pre><pre>u.nInterfaces(interfaces);</pre><pre><strong style="font-size: 24.0px;font-family: Arial , sans-serif;">Functions Used</strong></pre><p>N/A</p><h1 id="OBSOLETE-DELETEHW-SYMsym_switch-ModulesUsed"><strong>Modules Used</strong></h1><p>sym_sw_arb</p><h1 id="OBSOLETE-DELETEHW-SYMsym_switch-Description"><strong>Description</strong></h1><p>The top block diagram is shown below assuming a 3x3 switch with 3 VCs. Doesn't show the priority signals.</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16169027/SwitchMicroArch.svg?api=v2"></span></p><p>The interfaces inInterfaces and outInterfaces are the ATP interface descriptions and any meta data associated with those interfaces. In this description will be a the signals in the interface. All ATP interfaces must have the same number and width of signals.</p><p>The pktDef in an ATP interface is the link packet definition that describes the format of the packet that is traversing the interface. All ATP interfaces must have matching link packet definitions.</p><p>The routeFields is an array of strings that describes the fields in the packet that an ingress port will use to determine which egress port a packet is heading for.</p><p>The routeShift is a number that tells the depacketizer how many bits to left shift with wrap the route field in the packet that exits the switch. It can only be greater than zero if the following conditions are met. There is only one field and if there is protection it is only parity associated with one parity bit. If there is ECC protection on the field it can't be shifted. If there are multiple parity bits associated with a field, it can't be shifted. Conceptually this field will only be used if a &quot;route&quot; field is being used to route a packet and the shift field tells the switch how for to shift the route field in preparation for the next switch. So, if three bits are needed to determine an output port at this switch and the route field is 11 bits wide, routeFields would be &quot;route[10:8]&quot; and routeShift would be three. After the shift new route[10:0] would equal old {route[7:0],route[10:8]}. Functionally, bits [10:8] could be dumped, but they are wrapped to maintain parity if parity is being used to protect the &quot;route&quot; field.</p><p>The routeMap is a bundle that describes a case statement used to determine the egress field based on the routeFields description treated as one vector that is the width of the sum of the fields defined in routeFields.</p><p>The DePacketizer uses the linkInterface, the linkPktDesc, the routeFields, the routeShift and routeMap to determine how many beats it has to buffer before it can route a packet, and it will shift the route Field if routeShift is non 0.</p><h1 id="OBSOLETE-DELETEHW-SYMsym_switch-Reviews:">Reviews:</h1><h2 id="OBSOLETE-DELETEHW-SYMsym_switch-2018_01_12Review:">2018_01_12 Review:</h2><h3 id="OBSOLETE-DELETEHW-SYMsym_switch-attendees:">attendees:</h3><p><a class="confluence-userlink user-mention" data-account-id="624b37fc258562006fa692fa" href="https://arterisip.atlassian.net/wiki/people/624b37fc258562006fa692fa?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">John Coddington (Deactivated)</a></p><p><a class="confluence-userlink user-mention" data-account-id="624b373df6a26900695fd0fc" href="https://arterisip.atlassian.net/wiki/people/624b373df6a26900695fd0fc?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">Syed Shah (Deactivated)</a></p><p><a class="confluence-userlink user-mention" data-account-id="624b3757258562006fa69287" href="https://arterisip.atlassian.net/wiki/people/624b3757258562006fa69287?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">Sanjay Deshpande (Deactivated)</a></p><p><a class="confluence-userlink user-mention" data-account-id="624b3704f813eb00692cb18c" href="https://arterisip.atlassian.net/wiki/people/624b3704f813eb00692cb18c?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">Shailendra Aulakh (Deactivated)</a></p><p><a class="confluence-userlink user-mention" data-account-id="624b3798699649006ae98ff8" href="https://arterisip.atlassian.net/wiki/people/624b3798699649006ae98ff8?ref=confluence" target="_blank" data-linked-resource-id="756836" data-linked-resource-version="1" data-linked-resource-type="userinfo" data-base-url="https://arterisip.atlassian.net/wiki">Darshan Alagud</a>dash</p><p><a class="confluence-userlink user-mention" data-account-id="5ed63c82037d930c16bd8c73" href="https://arterisip.atlassian.net/wiki/people/5ed63c82037d930c16bd8c73?ref=confluence" target="_blank" data-linked-resource-id="327834" data-linked-resource-version="1" data-linked-resource-type="userinfo" data-base-url="https://arterisip.atlassian.net/wiki">Saad Zahid</a></p><p><a class="confluence-userlink user-mention" data-account-id="624b37b7258562006fa692b4" href="https://arterisip.atlassian.net/wiki/people/624b37b7258562006fa692b4?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">Sumit Dhamanwala (Deactivated)</a></p><p><a class="confluence-userlink user-mention" data-account-id="624b36d6f4079800705922a6" href="https://arterisip.atlassian.net/wiki/people/624b36d6f4079800705922a6?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">Andrew Brock (Deactivated)</a></p><h3 id="OBSOLETE-DELETEHW-SYMsym_switch-ActionItems:">Action Items:</h3><ul class="inline-task-list" data-inline-tasks-content-id="16169027"><li class="checked" data-inline-task-id="1"><a class="confluence-userlink user-mention" data-account-id="624b37fc258562006fa692fa" href="https://arterisip.atlassian.net/wiki/people/624b37fc258562006fa692fa?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">John Coddington (Deactivated)</a> Update documentation to reflect route is used before shift.</li><li class="checked" data-inline-task-id="2"><a class="confluence-userlink user-mention" data-account-id="624b37fc258562006fa692fa" href="https://arterisip.atlassian.net/wiki/people/624b37fc258562006fa692fa?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">John Coddington (Deactivated)</a> Update documentation to document what is in the lock logic.</li></ul><p><br/></p><h2 id="OBSOLETE-DELETEHW-SYMsym_switch-2018_01_29Review:">2018_01_29 Review:</h2><h3 id="OBSOLETE-DELETEHW-SYMsym_switch-attendees:.1">attendees:</h3><p><a class="confluence-userlink user-mention" data-account-id="624b37fc258562006fa692fa" href="https://arterisip.atlassian.net/wiki/people/624b37fc258562006fa692fa?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">John Coddington (Deactivated)</a></p><p><a class="confluence-userlink user-mention" data-account-id="624b374a258562006fa6926d" href="https://arterisip.atlassian.net/wiki/people/624b374a258562006fa6926d?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">Chandra Veedhi (Deactivated)</a></p><p><a class="confluence-userlink user-mention" data-account-id="5ed63c82037d930c16bd8c73" href="https://arterisip.atlassian.net/wiki/people/5ed63c82037d930c16bd8c73?ref=confluence" target="_blank" data-linked-resource-id="327834" data-linked-resource-version="1" data-linked-resource-type="userinfo" data-base-url="https://arterisip.atlassian.net/wiki">Saad Zahid</a></p><h3 id="OBSOLETE-DELETEHW-SYMsym_switch-Notes:">Notes:</h3><p>Changing Parameter Names and associating all signals with an Interface to aid software in generating top level TACHL code.</p><h3 id="OBSOLETE-DELETEHW-SYMsym_switch-ActionItems:.1">Action Items:</h3><ul class="inline-task-list" data-inline-tasks-content-id="16169027"><li class="checked" data-inline-task-id="4"><span><a class="confluence-userlink user-mention" data-account-id="624b37fc258562006fa692fa" href="https://arterisip.atlassian.net/wiki/people/624b37fc258562006fa692fa?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">John Coddington (Deactivated)</a> to update documentation and communicate changes to <a class="confluence-userlink user-mention" data-account-id="5ed63c82037d930c16bd8c73" href="https://arterisip.atlassian.net/wiki/people/5ed63c82037d930c16bd8c73?ref=confluence" target="_blank" data-linked-resource-id="327834" data-linked-resource-version="1" data-linked-resource-type="userinfo" data-base-url="https://arterisip.atlassian.net/wiki">Saad Zahid</a> and <a class="confluence-userlink user-mention" data-account-id="624b374a258562006fa6926d" href="https://arterisip.atlassian.net/wiki/people/624b374a258562006fa6926d?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">Chandra Veedhi (Deactivated)</a>.</span></li><li data-inline-task-id="5"><span><a class="confluence-userlink user-mention" data-account-id="624b374a258562006fa6926d" href="https://arterisip.atlassian.net/wiki/people/624b374a258562006fa6926d?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">Chandra Veedhi (Deactivated)</a> review changes communicate any questions or issues discovered to <a class="confluence-userlink user-mention" data-account-id="624b37fc258562006fa692fa" href="https://arterisip.atlassian.net/wiki/people/624b37fc258562006fa692fa?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">John Coddington (Deactivated)</a>.<br/></span></li><li data-inline-task-id="6"><span><a class="confluence-userlink user-mention" data-account-id="624b37fc258562006fa692fa" href="https://arterisip.atlassian.net/wiki/people/624b37fc258562006fa692fa?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">John Coddington (Deactivated)</a> makes updates if necessary based on <a class="confluence-userlink user-mention" data-account-id="624b374a258562006fa6926d" href="https://arterisip.atlassian.net/wiki/people/624b374a258562006fa6926d?ref=confluence" target="_blank" data-base-url="https://arterisip.atlassian.net/wiki">Chandra Veedhi (Deactivated)</a> feedback.<br/></span></li></ul>