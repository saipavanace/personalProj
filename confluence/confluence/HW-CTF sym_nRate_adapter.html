<h1 id="HW-CTFsym_nRate_adapter-parameters"><strong>parameters</strong></h1><pre>{</pre><pre><span> interfaces: {</span></pre><pre>    clkInterface: {name: &quot;a_string&quot;, params: {}, direction: &quot;master&quot; or &quot;slave&quot;, interface: &quot;a_string&quot;},  // Optional based on depth &gt; 0</pre><pre>    protectionInterface: {name: &quot;a_string&quot;, params: {}, direction: &quot;master&quot; or &quot;slave&quot;, interface: &quot;a_string&quot;}, // Optional based on protectionStyle</pre><pre>    inInterface: </pre><pre>      {name: &quot;a_string&quot;,</pre><pre>       params: {interface parameters},</pre><pre>       direction: &quot;slave&quot;, </pre><pre>       pktStyle: &quot;serial&quot;, &quot;parallel&quot; or &quot;fixed&quot;, </pre><pre>       wData: int // power of 2 8 or greater. </pre><pre>       pktDef: {packet: &quot;a_string&quot;} // link packet definition</pre><pre>       interface: &quot;InterfaceATP&quot;}, // Interface must have a 1 bit wide ready and valid.</pre><pre>    outInterface:</pre><pre>      {name: &quot;a_string&quot;,</pre><pre>       params: {interface parameters}, // parameters must match inInterface</pre><pre>       direction: &quot;master&quot;, </pre><pre>       pktStyle: &quot;serial&quot;, &quot;parallel&quot; or &quot;fixed&quot;, </pre><pre>       wData: int // power of 2 8 or greater. </pre><pre>       pktDef: {packet: &quot;a_string&quot;} // link packet definition</pre><pre>       interface: &quot;InterfaceATP&quot;}, // Interface must match inInterface </pre><pre><br/></pre><div>    }, </div><pre>  &quot;ratio&quot; : [I,J], // I is input bandwidth and J is the output bandwidth. I and J must be integers (a SW restriction)</pre><pre>  &quot;depth&quot; : 2 or greater integer, // The depth of the pipeline. </pre><pre>  &quot;pipeForward&quot; : boolean, </pre><pre>  &quot;pipeBackward&quot; : boolean,</pre><pre>  &quot;protectionStyle&quot; : <a class="external-link" href="https://confluence.arteris.com/display/ENGR/protectionStyle" rel="nofollow">protectionStyle</a>}</pre><pre>}</pre><h1 id="HW-CTFsym_nRate_adapter-ModulesUsed"><strong>Modules Used</strong></h1><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166765/rdy_vld_pipe" data-linked-resource-id="16166765" data-linked-resource-version="33" data-linked-resource-type="page">rdy_vld_pipe</a></p><h1 id="HW-CTFsym_nRate_adapter-Description"><strong>Description</strong></h1><p>The block diagram is below:</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16168493/sym_nRate_adapter.svg?api=v2"></span></p><p>The block tries to hold off asserting valid on the outInterface until it's guaranteed that the entire packet can be broadcast into the outInterface with no bubbles. It does this to prevent a faster network from being block unnecessarily by slow packets with bubbles. Because of this, bubble between packets are not a bad as bubbles in a packet, because bubbles between packets allow the fast network to use the bubbles to send packets from other ports into it. The block uses <strong>ratio</strong> to calculate the point in a packet with the beats of <strong>depth</strong> when it can start asserting valid. Packets that have less beats than depth will cause excessive bubbles between packets. If the packet coming in has unexpected bubbles than this will cause bubbles in the packet coming out of the block.</p><p>It does this by using the rdy_vld_pipe in circular mode and then accesses the read pointer. When a packet starts, the block calculates the read pointer value needed for the block to start broadcasting. It does this by incrementing a packet counter when it hits this value or the last beat of a packet is reached. The valid on the output side only asserts when the counter is greater than 0. An exception is done when pipeForward = false if the rate adapter is empty and the incoming packet is one beat, first = last = 1. The size of the counter must be large enough to hold the number of packets the block can hold. Because packets can be one beat, than the number of packets is assumed to be the same as depth.</p><h2 id="HW-CTFsym_nRate_adapter-TriggerPointCalculation">Trigger Point Calculation</h2><p>Based on the configuration, the block calculates a trigger point that is added to the present read pointer the it needs to reach before it will allow the packet to progress to the output, The calculation is:</p><p><code style="text-decoration: none;">trigger_point = Math.ceil((1-(ratio[0]/ratio[1]))*depth)+1;</code></p><p>However, the results of this equation is modified. If trigger point = 0, it's forced to 1 and if it's equal to depth, it's forced to depth - 1. There is one exception, when depth = 2 and pipeBackward = true, the trigger point is forced to 2. This is to limit that amount of bubbles that happen in a packet for this configuration, but it's impossible to stop all bubbles in 2 beat packets for this configuration.</p><p><strong>inInterface</strong> and <strong>outInterface</strong> must match in all parameters except name.</p><p><strong>ratio: </strong>I/J represents the input to output bandwidth ratio. So if the bandwidth ratio is 1/2, that is, on the input is 1 valid beat for every two beats on the output, then I would 1 and J would be 2. Values of I=2 and J=4 would also work. The ratio is given as two integers because floating point parameters are not supported.</p><p><strong>pipeForward</strong>: If true, then valid in the outInterface comes from a register, else when false, valid is both a function of the internal state and the inInterface. This enables single beat packets to bypass the rate adapter when it's empty.</p><p><strong>pipeBackward</strong>: If true, the ready in the inInterface comes from a register, else when false, ready is both a function of the internal state and the outInterface. This enables a beat to push into the rate adapter even if it's full if the outInterface has ready and valid asserted.</p><p><strong>depth</strong>: Depth represents the packet size in beats the block is optimized for. Packets larger than depth will result in the bubbles in the outInterface packets and packets smaller than depth will result in bubbles between packets. The exception to this is one beat packets. One beat packet can stream through the block with now bubbles if the output ready stays asserted.</p><p><br/></p>