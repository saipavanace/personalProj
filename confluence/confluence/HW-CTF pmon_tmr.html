<h2 id="HW-CTFpmon_tmr-module_name:">module_name<strong>:</strong></h2><p>pmon_stats</p><h2 id="HW-CTFpmon_tmr-JavaScriptparameters:">JavaScript parameters:</h2><p><em>width</em>: A positive integer. This specifies the width of the timer or counter. This needs to match the width of the <em>val_in</em> and <em>val_out</em> signals of the <em>cfgValInterface</em> of the timer.<br/><em>internalState</em>: A boolean parameter. True indicates that the timer-state/counter flops are instantiated inside the block and a <em>stateInterface</em> is created. Otherwise the timer-state/counter flops are assumed to be instantiated outside and can be read through the <em>cfgValInterface</em>.</p><p><br/></p><h2 id="HW-CTFpmon_tmr-Derivedparameters:">Derived parameters:</h2><p><em>nLimits</em>: A positive integer. This equals the number of <em>limit</em> values specified and is calculated as the Math.max( width of <em>tmr</em> event, 1 ). This means if the <em>tmr</em> event exists in the <em>evtTmrInterface</em>, then the width of the <em>tmr</em> event = <em>nLimits</em>.</p><p><br/></p><h2 id="HW-CTFpmon_tmr-Interfaces:">Interfaces:</h2><p><em>clkInterface</em>: A slave interface of type <a class="external-link" href="https://confluence.arteris.com/display/ENGR/InterfaceCLK" rel="nofollow">InterfaceCLK</a>.</p><p><em>cfgValInterface</em>: A slave interface for bringing in the register bits (Timer value register) that the timer controls. The interface the following signals:<br/>{<br/><em>  val_in</em>: <em>width</em>,<br/>  <em>val_out</em>: -<em>width</em>,<br/>  <em>val_wr</em>: -1<br/>}</p><p><em>evtTmrInterface</em>: A slave interface with the following signals and widths:<br/>{<br/><em>  start</em>: 1,<br/>  <em>stop</em>: 1,<br/>  <em>reset</em>: 1,<br/>  <em>count</em>: 1,<br/>  <em>tmr</em>: <em>nLimits</em> or 0 (optional),<br/>  <em>ovf</em>: -1 or 0 (optional),<br/>  <em>limit_hit</em>: -1 or 0 (optional)<br/>}</p><p><em>stateInterface</em>: A master interface created only when the param <em>internalState</em> = true. This interface includes the following signals:<br/>{<br/>  val: <em>width</em><br/>}<br/><br/></p><h2 id="HW-CTFpmon_tmr-Ports">Ports</h2><p><em>limit</em>: Input of size = <em>width*nLimits</em>. This consists of a set of packed <em>limit</em> values each of which must match the width of the timer/counter. In run mode, a <em>tmr</em> event bit is asserted a cycle before the counter value exceeds its corresponding <em>limit</em> value. In freeze and wrap modes, all <em>limit</em> values other than the least significant one is ignored. When the timer exceeds the least significant <em>limit, </em>it either rolls over back to zero (in wrap mode) or stops accumulating or incrementing (in freeze mode). In load mode, <em>limit</em> is completely ignored.</p><p><em>mode</em>: Input of size = 2. 0 - Wrap mode, 1 - Freeze mode, 2 - Run mode, 3 - Load mode.</p><p><em>en</em>: Input of size = 1. 1 enables the timer, 0 disables it.</p><p><br/></p><h2 id="HW-CTFpmon_tmr-Blockdescription:">Block description:</h2><p>The PMON timer block implements the control logic for an incrementing counter that accumulates the value on its <em>count</em> input. The timer or counter register/flops/state itself can lie either inside the block or outside the block depending on the boolean parameter <em>internalState:</em></p><ol><li>External state: <em>internalState</em> = false. In this case, the timer or counter register is assumed to exist outside the block. The pmon_tmr block provides the write signal (val_wr) and the register value (val_out) to update the register with. And reads the current value/state of the counter through the val_in signal. val_wr, val_out, val_in signals are part of the <em>cfgValInterface</em>.</li><li>Internal state: <em>internalState</em> = true. In this case, the timer or counter register exists inside the block and provides a <em>stateInterface</em> to allow logic outside the <em>pmon_tmr</em> block to read the current counter value if required.</li></ol><p>In all the accumulate-modes, the control logic increments the counter value only when the count input is non-zero. So if the count input is 1-bit wide and tied to an always one, it works as a timer or free-running counter (A timer is a counter that counts every clock).</p><p><br/></p><p><span class="confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image image-center" height="250" src="https://arterisip.atlassian.net/wiki/download/attachments/16170326/image2021-9-28_12-17-54.png?api=v2"></span></p><p style="text-align: center;">Block diagram showing pmon_tmr with external state (<em>internalState</em> = false)</p><p><br/></p><p><br/></p><p><span class="confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image image-center" height="250" src="https://arterisip.atlassian.net/wiki/download/attachments/16170326/image2021-9-28_12-18-6.png?api=v2"></span></p><p style="text-align: center;">Block diagram showing pmon_tmr with internal state (<em>internalState</em> = true)</p><p><br/></p><p><br/></p><h2 id="HW-CTFpmon_tmr-TimerModes">Timer Modes</h2><p>The timer/counter works in 4 different modes and they can be classified into two types:</p><ol><li>Accumulate: This includes wrap mode, freeze mode, and run mode. In these modes, the block accumulates the value on the <em>count</em> input i.e. adds the current value of counter to value on <em>count</em> input, every clock as long as <em>en</em> input is high.</li><li>Non-accumulate: This includes just the Load mode. In this mode, the block simply updates the counter register with the value on the <em>count</em> input.</li></ol><p><br/></p><h4 id="HW-CTFpmon_tmr-Accumulatemodes">Accumulate modes</h4><p><strong>Wrap mode</strong>: (<em>mode</em> = 0). In this mode, if the counter is enabled, it accumulates the count values every clock as long as the current counter value &lt; <em>limit</em> value. If adding the current <em>count</em> value exceeds the limit value, then the counter wraps back to zero in the following cycle.</p><p><strong>Freeze mode</strong>: (<em>mode</em> = 1). In this mode, if the counter is enabled, it accumulates the count values every clock as long as the current counter value &lt; limit value. If the current <em>count</em> value equals or exceeds the limit value, then the counter freezes (stops accumulating). The value at which the counter value freezes equals the limit value if wCount = 1, but can be greater than the limit value if wCount &gt; 1.</p><p><strong>Run mode</strong>: (<em>mode</em> = 2). In this mode, if the counter is enabled, it accumulates the count values ever clock and continues to run even after crossing the limit value. If adding the current <em>count</em> value pushes the result beyond one of the limit values, then the counter generates the corresponding timer event (<em>tmr</em>).</p><p><br/></p><h4 id="HW-CTFpmon_tmr-Non-accumulatemodes">Non-accumulate modes</h4><p><strong>Load mode</strong>: (<em>mode</em> = 3). In this mode, if the counter is enabled, the value on the <em>count</em> input is zero-extended and loaded on to the counter value register. If the counter is not enabled, then the counter value stays the same as the previous value.</p><p><br/></p><h2 id="HW-CTFpmon_tmr-Timerevents">Timer events</h2><p>The timer/counter accepts a set of input events and generates optional output events all of which are brought in as a single interface: <em>evtTmrInterface</em>. An event is said to occur on any of these signals (except <em>limit_hit</em>) during a clock cycle if that signal is driven with a non-zero value in that clock cycle.</p><h4 id="HW-CTFpmon_tmr-Inputevents">Input events</h4><ol><li><em>start</em> and <em>stop</em> events: The counter does not accumulate count input values even after asserting enable until it receives a <em>start</em> event. And the counter stops accumulating when it receives the <em>stop</em> event. If both <em>start</em> and <em>stop</em> events occur during the same clock, then the stop event has higher priority and will stop the counter.</li><li><em>reset</em>: The counter resets synchronously when this event occurs.</li><li><em>count</em>: This can be a multi-bit event and the counter simply accumulates or adds this value onto the current counter value.</li></ol><p><br/></p><h4 id="HW-CTFpmon_tmr-Outputevents">Output events</h4><ol><li><em>tmr</em>: Timer wrap or limit-cross event. In wrap mode, this event occurs on the cycle before the counter value wraps back to a zero. In run mode, this event occurs on the cycle before the counter value exceeds the specified limit value. In all other modes, this event never occurs. If this input is a multi-bit vector, the number of bits must match the number of <em>limit</em> values coming in, and the each bit must be interpreted as a separate single-bit event.</li><li><em>ovf</em>: Overflow event. An overflow occurs a cycle before the counter rolls back to a zero. This can be used to daisy chain two pmon_tmr blocks. This event never occurs in load mode.</li></ol><p><br/></p><h4 id="HW-CTFpmon_tmr-Thelimit_hitoutput">The <em>limit_hit</em> output</h4><p>This is not an event, but a status bit output asserted only in the freeze mode. The <em>limit_hit</em> output is asserted when the current <em>count</em> value equals or exceeds the <em>limit</em> value.</p><p><br/></p><h2 id="HW-CTFpmon_tmr-TimerStateMachine">Timer State Machine</h2><p>The control logic inside the block includes a 2-state state-machine. The two states are:</p><ol><li>IDLE: This is the reset state. The timer stays at this state as long as the <em>start</em> event input is low. The timer does not increment or accumulate in this state even if the <em>count</em> input is asserted.</li><li>RUN: The timer enters this state when the <em>start</em> event input is asserted. The timer can increment or accumulate in this state but only if the <em>count</em> is also asserted.</li></ol><p><br/></p><p><br/></p><p><span class="confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image image-center" height="174" src="https://arterisip.atlassian.net/wiki/download/attachments/16170326/image2021-9-8_16-34-51.png?api=v2"></span></p><p style="text-align: center;">Timer State Machine diagram</p><p><br/></p><h4 id="HW-CTFpmon_tmr-Free-runningcounter">Free-running counter</h4><p>The pmon_tmr block can be used as a free-running counter that counts ever clock by tying off the <em>count</em> input to a 1. For the counter to actually start counting, the <em>start</em> event input must be asserted for at least a clock. The <em>stop</em> event input can be used to stop or freeze the counter from accumulating or incrementing.</p><p><br/></p>