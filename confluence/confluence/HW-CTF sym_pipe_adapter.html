<h1 id="HW-CTFsym_pipe_adapter-module_name"><strong>module_name</strong></h1><p>sym_pipe_adapter</p><h1 id="HW-CTFsym_pipe_adapter-parameters"><strong>parameters</strong></h1><pre>{</pre><pre><span> interfaces: {</span></pre><pre>    clkInterface: {name: &quot;a_string&quot;, params: {}, direction: &quot;master&quot; or &quot;slave&quot;, interface: &quot;a_string&quot;},  // Optional based on depth &gt; 0</pre><pre>    protectionInterface: {name: &quot;a_string&quot;, params: {}, direction: &quot;master&quot; or &quot;slave&quot;, interface: &quot;a_string&quot;}, // Optional based on protectionStyle</pre><pre>    inInterface: </pre><pre>      {name: &quot;a_string&quot;,</pre><pre>       params: {interface parameters},</pre><pre>       direction: &quot;slave&quot;, </pre><pre>       pktStyle: &quot;serial&quot;, &quot;parallel&quot; or &quot;fixed&quot;, </pre><pre>       wData: int // power of 2 8 or greater. </pre><pre>       pktDef: {packet: &quot;a_string&quot;} // link packet definition</pre><pre>       interface: &quot;InterfaceATP&quot;}, // Interface must have a 1 bit wide ready and valid.</pre><pre>    outInterface:</pre><pre>      {name: &quot;a_string&quot;,</pre><pre>       params: {interface parameters}, // parameters must match inInterface</pre><pre>       direction: &quot;master&quot;, </pre><pre>       pktStyle: &quot;serial&quot;, &quot;parallel&quot; or &quot;fixed&quot;, </pre><pre>       wData: int // power of 2 8 or greater. </pre><pre>       pktDef: {packet: &quot;a_string&quot;} // link packet definition</pre><pre>       interface: &quot;InterfaceATP&quot;}, // Interface must match inInterface</pre><pre>  }, </pre><pre>  &quot;pipeForward&quot; : boolean,  // No timing path between valid_in and valid_out if true.</pre><pre>  &quot;pipeBackward&quot; : boolean, // No timing path between ready_out and ready_in if true. </pre><pre>  &quot;lckStyleVld&quot; : boolean, // defaults to false</pre><pre>  &quot;split&quot; : boolean, // Split off header field from data if true and pktStyoe = parallel, otherwise ignored (default is false)</pre><pre>  &quot;simplePipe&quot; : boolean,   // If depth is greater than one, takes &quot;depth&quot; clocks to propagate from input to output if true.</pre><pre>  &quot;circular&quot; : boolean, // Indicates if the internal structure of the FIFO is circular or not. Circular FIFOs use less power.</pre><pre>  &quot;depth&quot; : 0 or any positive integer, // The depth of the pipeline. &quot; &quot;forceClk&quot;: boolean // optional default false. True forces clk interface if depth = 0. </pre><pre>  &quot;hDepth&quot; : 0 or any positive integer, // If split=true and pktStyle=parallel, depth of header FIFO, </pre><pre>                                        // If split=true and pktStyle~=parallel, FIFO depth is depth+hDepth, otherwise ignored. Default is 0.</pre><pre>  &quot;protectionStyle&quot; : <a class="external-link" href="https://confluence.arteris.com/display/ENGR/protectionStyle" rel="nofollow">protectionStyle</a>}</pre><pre>}</pre><h1 id="HW-CTFsym_pipe_adapter-I/O"><strong>I/O</strong></h1><pre>obj.lib.nInterfaces(interfaces);</pre><h1 id="HW-CTFsym_pipe_adapter-ModulesUsed"><strong>Modules Used</strong></h1><p><a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166765/rdy_vld_pipe" data-linked-resource-id="16166765" data-linked-resource-version="33" data-linked-resource-type="page">rdy_vld_pipe</a></p><h1 id="HW-CTFsym_pipe_adapter-Description"><strong>Description</strong></h1><p>This block adds pipe stages to an InterfaceATP. InterfaceATP is a ready/valid interface. A ready/valid interface is any interfaces that has a valid output, a ready input and any number of 1 or more outputs of any width. This blocks makes extensive use of the rdy_vld_pipe block that can pipe line any ready/valid interface. Follow link for a full description and microarchitecture of <a href="https://arterisip.atlassian.net/wiki/spaces/ENGR/pages/16166765/rdy_vld_pipe" data-linked-resource-id="16166765" data-linked-resource-version="33" data-linked-resource-type="page">rdy_vld_pipe</a>.</p><p>inInterface.signals and outInterface.signals, pktStyle, wData and pktDef must be identical between the two interface.</p><p>The parameter spit changes the internal microarchitecture of the block.</p><h2 id="HW-CTFsym_pipe_adapter-Split=false">Split = false</h2><p>When split = false, the microarchitecture is shown in the figure below:</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16156466/sym_pipe_adapter_noSplit.svg?api=v2"></span></p><p>All the block does is feed atp interfaces directly to the rdy_vld_pipe. </p><h2 id="HW-CTFsym_pipe_adapter-Split=true">Split = true</h2><p>When split = true and pktStyle is not parallel, the microarchitecture is the same as shown for split = false, except the depth passed to the rdy_vld_pipe is the sum of depth + hDepth.</p><p>When split = true and pktStyle = parallel, the microarchitecture is shown in the figure below:</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="https://arterisip.atlassian.net/wiki/download/attachments/16156466/sym_pipe_adapter_split.svg?api=v2"></span></p><p>The headers fields are put in a separate rdy_vld_pipe from the data where the depth of the rdy_vld_pipe is hDepth. The signals first, last and sb_prot are pushed onto the data rdy_vld_pipe. The bus signal is split between header fields and data fields and the headers fields are put into the header rdy_vld_pipe and the data fields are pushed onto the data rdy_vld_pipe. The parameter pipeForward, pipeBackward, simplePipe and circular are passed unmodified to the two rdy_vld_pipes.</p><p>When lckStyleVld = false a third rdy_vld_pipe is added between the input and the splitting of the packet between header and data. It's parameters are hard coded as:</p><p style="margin-left: 30.0px;">depth = 1<br/>pipeForward = false<br/>pipeBackward = false<br/>circular = false<br/>simplePipe = false</p><p>When lckStyleVld = false, the ATP interfaces are retracting. To keep ready from being a function of vld, this pipe stage grabs a beat of data so that internal logic can determine when to push data onto the header and data rdy_vld_pipes. The loading equations in pseudo code are (where \=int_in_name=\ represents the atp interface that feeds the header and data rdy_vld_pipes and ndp_ is header and dp_ is data):</p><p style="margin-left: 30.0px;">reg dp_ready_valid_first;<br/>reg ndp_ready_valid_first;</p><p style="margin-left: 30.0px;">assign next_dp_ready_valid_first = <br/>  ( dp_ready_valid_first &amp; \=int_in_name=\valid &amp; \=int_in_name=\first &amp; ~ndp_\=int_in_name=\ready) |<br/>  (~ndp_ready_valid_first &amp; \=int_in_name=\valid &amp; \=int_in_name=\first &amp; dp_\=int_in_name=\ready &amp; ~ndp_\=int_in_name=\ready);</p><p style="margin-left: 30.0px;">assign next_ndp_ready_valid_first =<br/>  (ndp_ready_valid_first &amp; \=int_in_name=\valid &amp; \=int_in_name=\first &amp; ~dp_\=int_in_name=\ready) |<br/>  (~dp_ready_valid_first &amp; \=int_in_name=\valid &amp; \=int_in_name=\first &amp; ~dp_\=int_in_name=\ready &amp; ndp_\=int_in_name=\ready);</p><p style="margin-left: 30.0px;">assign ndp_\=int_in_name=\valid = \=int_in_name=\first ? \=int_in_name=\valid &amp; ~(ndp_ready_valid_first &amp; ~dp_ready_valid_first) : 1'b0;<br/>assign dp_\=int_in_name=\valid = \=int_in_name=\first ? \=int_in_name=\valid &amp; ~(dp_ready_valid_first &amp; ~ndp_ready_valid_first) : \=int_in_name=\valid;<br/>assign \=int_in_name=\ready = \=int_in_name=\first ? <br/> (ndp_\=int_in_name=\ready &amp; dp_\=int_in_name=\ready) | <br/> (~ndp_ready_valid_first &amp; dp_ready_valid_first &amp; ndp_\=int_in_name=\ready) | <br/> (ndp_ready_valid_first &amp; ~dp_ready_valid_first &amp; dp_\=int_in_name=\ready) : <br/> dp_\=int_in_name=\ready;</p><p>The unloading equations in pseudo code are (where \int_out_name\ comes from the header and data rdy_vld_pipes and ndp_ represents header and dp_ represents data):</p><p style="margin-left: 30.0px;">assign \=<a class="external-link" href="http://outInterface.name" rel="nofollow">outInterface.name</a>=\valid = \=<a class="external-link" href="http://outInterface.name" rel="nofollow">outInterface.name</a>=\first ? ndp_\=int_out_name=\valid &amp; dp_\=int_out_name=\valid : dp_\=int_out_name=\valid;<br/>assign ndp_\=int_out_name=\ready = \=<a class="external-link" href="http://outInterface.name" rel="nofollow">outInterface.name</a>=\ready &amp; \=<a class="external-link" href="http://outInterface.name" rel="nofollow">outInterface.name</a>=\first &amp; dp_\=int_out_name=\valid ;<br/>assign dp_\=int_out_name=\ready = \=<a class="external-link" href="http://outInterface.name" rel="nofollow">outInterface.name</a>=\ready;</p><div><strong><br/></strong></div>