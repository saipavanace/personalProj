<style type="text/css">/*<![CDATA[*/
div.rbtoc1759725356024 {padding: 0px;}
div.rbtoc1759725356024 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1759725356024 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class="toc-macro rbtoc1759725356024"><style>[data-colorid=kfy76nmrnf]{color:#0747a6} html[data-color-mode=dark] [data-colorid=kfy76nmrnf]{color:#5999f8}[data-colorid=oegt9os6u3]{color:#0747a6} html[data-color-mode=dark] [data-colorid=oegt9os6u3]{color:#5999f8}[data-colorid=jh08rbhc4m]{color:#0747a6} html[data-color-mode=dark] [data-colorid=jh08rbhc4m]{color:#5999f8}[data-colorid=x8wxqre5c5]{color:#0747a6} html[data-color-mode=dark] [data-colorid=x8wxqre5c5]{color:#5999f8}[data-colorid=lo59q6rleu]{color:#0747a6} html[data-color-mode=dark] [data-colorid=lo59q6rleu]{color:#5999f8}[data-colorid=ldym8vsrh6]{color:#0747a6} html[data-color-mode=dark] [data-colorid=ldym8vsrh6]{color:#5999f8}[data-colorid=ufw7q78eru]{color:#0747a6} html[data-color-mode=dark] [data-colorid=ufw7q78eru]{color:#5999f8}[data-colorid=nmaxfd7u55]{color:#0747a6} html[data-color-mode=dark] [data-colorid=nmaxfd7u55]{color:#5999f8}[data-colorid=jn5qf0csrk]{color:#0747a6} html[data-color-mode=dark] [data-colorid=jn5qf0csrk]{color:#5999f8}[data-colorid=wdg9jv2szt]{color:#0747a6} html[data-color-mode=dark] [data-colorid=wdg9jv2szt]{color:#5999f8}[data-colorid=mfngn5i54r]{color:#0747a6} html[data-color-mode=dark] [data-colorid=mfngn5i54r]{color:#5999f8}[data-colorid=c49fhc4kfj]{color:#0747a6} html[data-color-mode=dark] [data-colorid=c49fhc4kfj]{color:#5999f8}[data-colorid=yg9qe9g34h]{color:#0747a6} html[data-color-mode=dark] [data-colorid=yg9qe9g34h]{color:#5999f8}[data-colorid=okyrub7oqz]{color:#0747a6} html[data-color-mode=dark] [data-colorid=okyrub7oqz]{color:#5999f8}[data-colorid=yatx2wv3t2]{color:#0747a6} html[data-color-mode=dark] [data-colorid=yatx2wv3t2]{color:#5999f8}[data-colorid=hfabcmpi5x]{color:#0747a6} html[data-color-mode=dark] [data-colorid=hfabcmpi5x]{color:#5999f8}[data-colorid=ad5xeo771g]{color:#0747a6} html[data-color-mode=dark] [data-colorid=ad5xeo771g]{color:#5999f8}[data-colorid=aic2gebpil]{color:#0747a6} html[data-color-mode=dark] [data-colorid=aic2gebpil]{color:#5999f8}[data-colorid=rc9lnlqsdn]{color:#ff5630} html[data-color-mode=dark] [data-colorid=rc9lnlqsdn]{color:#cf2600}[data-colorid=wrwkhkfw6n]{color:#0747a6} html[data-color-mode=dark] [data-colorid=wrwkhkfw6n]{color:#5999f8}[data-colorid=dg38fizhmr]{color:#0747a6} html[data-color-mode=dark] [data-colorid=dg38fizhmr]{color:#5999f8}[data-colorid=druw9n7gfq]{color:#0747a6} html[data-color-mode=dark] [data-colorid=druw9n7gfq]{color:#5999f8}[data-colorid=cwztkj9mcj]{color:#0747a6} html[data-color-mode=dark] [data-colorid=cwztkj9mcj]{color:#5999f8}[data-colorid=x4c9crq52g]{color:#0747a6} html[data-color-mode=dark] [data-colorid=x4c9crq52g]{color:#5999f8}[data-colorid=ccgehd3iil]{color:#0747a6} html[data-color-mode=dark] [data-colorid=ccgehd3iil]{color:#5999f8}[data-colorid=ahtv7ivfi3]{color:#0747a6} html[data-color-mode=dark] [data-colorid=ahtv7ivfi3]{color:#5999f8}[data-colorid=u7iqkrvsf6]{color:#0747a6} html[data-color-mode=dark] [data-colorid=u7iqkrvsf6]{color:#5999f8}[data-colorid=jk5kuhbikw]{color:#0747a6} html[data-color-mode=dark] [data-colorid=jk5kuhbikw]{color:#5999f8}[data-colorid=tufz4859gb]{color:#0747a6} html[data-color-mode=dark] [data-colorid=tufz4859gb]{color:#5999f8}[data-colorid=ebjvmbs9sh]{color:#0747a6} html[data-color-mode=dark] [data-colorid=ebjvmbs9sh]{color:#5999f8}[data-colorid=r8npvoxhlt]{color:#0747a6} html[data-color-mode=dark] [data-colorid=r8npvoxhlt]{color:#5999f8}[data-colorid=pu4phmapvl]{color:#0747a6} html[data-color-mode=dark] [data-colorid=pu4phmapvl]{color:#5999f8}[data-colorid=u8dywfn46k]{color:#0747a6} html[data-color-mode=dark] [data-colorid=u8dywfn46k]{color:#5999f8}[data-colorid=ymcqrvo2ly]{color:#0747a6} html[data-color-mode=dark] [data-colorid=ymcqrvo2ly]{color:#5999f8}[data-colorid=wk4tdrfo3z]{color:#0747a6} html[data-color-mode=dark] [data-colorid=wk4tdrfo3z]{color:#5999f8}[data-colorid=tu2pa2xwk7]{color:#0747a6} html[data-color-mode=dark] [data-colorid=tu2pa2xwk7]{color:#5999f8}</style>
<ul class="toc-indentation">
<li><a href="#NCorestandardtestbenchmethodology-1Stimulus">1 Stimulus</a></li>
<li><a href="#NCorestandardtestbenchmethodology-2Check">2 Check</a></li>
<li><a href="#NCorestandardtestbenchmethodology-3Coverage">3 Coverage</a></li>
<li><a href="#NCorestandardtestbenchmethodology-4uvm_envstructure">4 uvm_env structure</a></li>
</ul>
</div><h1 id="NCorestandardtestbenchmethodology-1Stimulus">1 Stimulus</h1><p /><ol start="1"><li><p>Sequences should have proper <strong><span data-colorid="tu2pa2xwk7">logic in place to determine when all transactions' are completely executed</span></strong>. </p><ol start="1"><li><p>Helps in test end mechanism. Eliminates the need of supporting logic in tests to prevent premature test exit.</p></li></ol></li><li><p><strong><span data-colorid="mfngn5i54r">Raise/Drop objections in pre/post-start methods</span></strong> of sequence. Refer to below pseudo code.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">class my_sequence extends uvm_sequence#(my_transaction);
  `uvm_object_utils(my_sequence)

  // pre_start() is called before start()
  task pre_start();
    // raise objection if started as a root sequence
    starting_phase = get_starting_phase();  // UVM 1.2
    if ( starting_phase != null )
      starting_phase.raise_objection(this);
  endtask

  task body();
    // do interesting activity
    //...
  endtask

  // post_start() is called after start() completes
  task post_start();
    // drop objection if started as a root sequence
    if ( starting_phase != null )
      starting_phase.drop_objection(this);
  endtask
endclass

class my_test extends uvm_test;
  `uvm_component_utils(my_test)

  my_env       m_env;
  my_sequence  seq;

  //...
  task main_phase(uvm_phase phase);
    seq.set_starting_phase(phase); // UVM-1.2
    seq.start(m_env.m_sequencer);
  endtask
  //...
endclass</pre>
</div></div></li><li><p>Don&rsquo;t pre-generate all stimulus. <strong><span data-colorid="u8dywfn46k">Use late randomization for generating transaction items</span></strong>. Where a transaction item is generated right before sending it out to the driver. </p><ol start="1"><li><p>This <strong><span data-colorid="jk5kuhbikw">improves memory usage</span></strong> in test bench by not needing large memory to store all pre-generated transaction items.</p></li><li><p>Late randomization helps take in <strong><span data-colorid="hfabcmpi5x">design and other component&rsquo;s status into account while generating a transaction item</span></strong>. For example, cache states, cache eviction prediction, etc.</p></li></ol></li><li><p><strong><span data-colorid="dg38fizhmr">Implement functions to check register values</span></strong>. To be invoked at the end of the test.</p><ol start="1"><li><p>This function reads status register values and matches them against expectation. </p></li><li><p><strong><span data-colorid="pu4phmapvl">Must use RAL to access registers</span></strong>. Should have options for front-door/backdoor register access.</p></li><li><p>Invoke these functions at the end of the test/sequence to verify RTL functionality; both for error and non-error scenarios. </p></li><li><p>Possibly in <strong><span data-colorid="nmaxfd7u55">post_start() method of sequence</span></strong>, to automate the function call.</p></li></ol></li><li><p>Any changes to boot sequence or base configuration should be done using RAL.</p><ol start="1"><li><p>Helps <strong><span data-colorid="c49fhc4kfj">eliminate testplus args communication between stimulus and checks</span></strong>.</p></li></ol></li><li><p>Use a configuration object with <strong><span data-colorid="ccgehd3iil">set() get() methods</span></strong> OR set() get() methods in sequence itself to tweak sequence randomization/behavior.</p><ol start="1"><li><p>Avoid adding constraints etc in extended sequences, keep reuse in mind before adding any code that may add dependency. </p></li><li><p><strong><span data-colorid="ahtv7ivfi3">Do not use plusargs to control test traffic</span></strong>. Plusargs makes the code static and messy when used wrong. Plusargs variables can only be changed once during the test duration, while SV variables can be changed multiple times as test progresses to control the flow of traffic with RTL feedback in mind.</p></li><li><p>Use sequence config object variables &amp; functions to control test traffic. </p></li><li><p>Reserve the usage of plusargs only to communicate hierarchy related control, checker en/disable, coverage en/disable information.</p></li></ol></li><li><p><strong><span data-colorid="tufz4859gb">Prevent the usage of events</span></strong>. Review their purpose and figure out an alternate way to implement it.</p></li><li><p><strong><span data-colorid="aic2gebpil">No communication between stimulus and checkers</span></strong>.</p></li><li><p><strong><span data-colorid="wrwkhkfw6n">Use a single test</span></strong>, provide sequence to override with in the command line.</p></li></ol><h1 id="NCorestandardtestbenchmethodology-2Check">2 Check</h1><p /><p><strong><span data-colorid="rc9lnlqsdn">Terminology:</span></strong> </p><ul><li><p><strong>Packet</strong>: An uvm object received on AP from any of the monitors. For example, SMI packet, AXI addr/data/resp packet, CHI packet on any of the channels.</p></li><li><p><strong>Transaction</strong>: Refers to a flow of read, write, recall, cache eviction etc transactions. Will include one or more packets from multiple interfaces. For example: 1 complete AXI transaction will include multiple AXI and SMI packets.</p></li></ul><p /><ol start="1"><li><p><strong><span data-colorid="kfy76nmrnf">Scoreboard structure</span></strong>: Example structure of scoreboard in below code. Use imp ports to receive packets from monitor. Implement write methods for each port. Majority of scoreboard logic will be implemented in these write methods.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">`uvm_analysis_imp_decl(_port_a)
`uvm_analysis_imp_decl(_port_b)
class component_b extends uvm_component;
  
  transaction trans;
  uvm_analysis_imp_port_a #(transaction,component_b) analysis_imp_a;  
  uvm_analysis_imp_port_b #(transaction,component_b) analysis_imp_b; 
  
  `uvm_component_utils(component_b)
  
  //--------------------------------------- 
  // Constructor
  //---------------------------------------
  function new(string name, uvm_component parent);
    super.new(name, parent);
    analysis_imp_a = new(&quot;analysis_imp_a&quot;, this);
    analysis_imp_b = new(&quot;analysis_imp_b&quot;, this);
  endfunction : new
  
  //---------------------------------------
  // Analysis port write method
  //---------------------------------------
  virtual function void write_port_a(transaction trans);
    `uvm_info(get_type_name(),$sformatf(&quot; Inside write_port_a method. 
                                          Recived trans On Analysis Imp Port&quot;),UVM_LOW)
    `uvm_info(get_type_name(),$sformatf(&quot; Printing trans, \n %s&quot;,
                                          trans.sprint()),UVM_LOW)
  endfunction
  
  //---------------------------------------
  // Analysis port write method
  //---------------------------------------
  virtual function void write_port_b(transaction trans);
    `uvm_info(get_type_name(),$sformatf(&quot; Inside write_port_b method. 
                                          Recived trans On Analysis Imp Port&quot;),UVM_LOW)
    `uvm_info(get_type_name(),$sformatf(&quot; Printing trans, \n %s&quot;,
                                          trans.sprint()),UVM_LOW)
  endfunction
  
endclass : component_b</pre>
</div></div></li><li><p>Create a <strong><span data-colorid="jn5qf0csrk">scb_txn class</span></strong> to store information related to the scoreboard&rsquo;s transaction flow. Create a <strong><span data-colorid="yatx2wv3t2">transaction_q of type scb_txn</span></strong>, which will carry information of the transaction that flows through the unit. Add a <strong><span data-colorid="u7iqkrvsf6">print_me() method</span></strong> in this class to print useful debug information about the transaction. </p></li><li><p><strong><span data-colorid="wk4tdrfo3z">Every fields of outgoing packets</span></strong> should be predicted and compared. </p></li><li><p><strong><span data-colorid="jh08rbhc4m">Every fields of incoming packet</span></strong> should be checked against legal/allowable values. These checks will help with fast fails, easy debug.</p></li><li><p>Use <strong><span data-colorid="r8npvoxhlt">do_compare() method</span></strong> to compare packets. Use either the UVM in-built version or create your own.  </p></li><li><p>Modularize the code. Increase re-use within scoreboard by using <strong><span data-colorid="ebjvmbs9sh">functions for repeated logic</span></strong>.</p></li><li><p>Implement <strong><span data-colorid="yg9qe9g34h">pre_abort() and check_phase()</span></strong> methods to print useful debug information. Add limit of 5/10 when printing queue items to avoid large logfiles. Do not add any error message in pre_abort() method. </p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">This callback is executed when the message system is executing a UVM_EXIT action.  
The exit action causes an immediate termination of the simulation, but the pre_abort callback hook gives 
components an opportunity to provide additional information to the user before the termination happens.  
For example, a test may want to executed the report function of a particular component even when an error 
condition has happened to force a premature termination you would write a function like:

function void mycomponent::pre_abort();
  report();
endfunction
The pre_abort() callback hooks are called in a bottom-up fashion.</pre>
</div></div></li><li><p><strong><span data-colorid="lo59q6rleu">Do not use internal RTL signals</span></strong> to verify the DUT. Talk to architects and uArchitects if a certain logic is not verifiable without internal RTL signal probing.</p></li><li><p><strong><span data-colorid="ufw7q78eru">Only use RAL</span></strong> to get (shadow copy/backdoor read) register configurations information. </p></li><li><p>Predict DUT behavior only based on AP packets and register configuration. When an error is observed, <strong><span data-colorid="okyrub7oqz">adapt the scoreboard checking to match RTL behavior</span></strong>.</p></li><li><p><strong><span data-colorid="druw9n7gfq">Do not use test plusargs in scoreboard</span></strong> to add error checks, etc. These checks should be added in sequence/tests that injected the error.</p></li><li><p><strong><span data-colorid="oegt9os6u3">Modularize the scoreboard structure</span></strong>:</p><ol start="1"><li><p>Use RTL&rsquo;s external interfaces as main AP write() methods in scoreboard. For any other internal logic verification, use a separate component and integrate that in your scoreboard.  </p></li><li><p>For example: </p><ol start="1"><li><p>IOAIU &amp; DMI scoreboards should integrate CCP scoreboard for any CCP interface related checks/logic. </p></li><li><p>Implement and integrate a separate snoop filter, directory management component in DCE scoreboard.</p></li><li><p>FSYS Scoreboard should re-use and integrate CCP scoreboard, snoop filter, etc components.  </p></li><li><p>Implement an exclusive monitor component and integrate in multiple scoreboards. This is already in place.</p></li></ol></li></ol></li><li><p><strong><span data-colorid="x8wxqre5c5">Do not use objections</span></strong> in scoreboards. Since scoreboard won&rsquo;t stop the test from ending due to pending packets(because we will remove objections), there should be a check_phase() implemented. Which will catch any leftover transactions and error out if test ends early.</p></li><li><p>Add hooks to <strong><span data-colorid="wdg9jv2szt">collect latency, bandwidth data</span></strong>.</p></li><li><p>Add <strong><span data-colorid="ymcqrvo2ly">analysis ports for coverage component</span></strong> to collect functional coverage information.</p></li></ol><h1 id="NCorestandardtestbenchmethodology-3Coverage">3 Coverage</h1><p /><ol start="1"><li><p>Use the scoreboard data to collect coverage on. <strong><span data-colorid="ldym8vsrh6">Connect coverage component to scoreboard&rsquo;s analysis ports</span></strong>. Refer chapter 2, point 15.</p></li></ol><h1 id="NCorestandardtestbenchmethodology-4uvm_envstructure">4 uvm_env structure</h1><p /><ol start="1"><li><p>Create an all encapsulating <strong><span data-colorid="cwztkj9mcj">uvm_env object for each test bench</span></strong>. </p></li><li><p><strong><span data-colorid="ad5xeo771g">Each uvm_env should have an env_config</span></strong> class defined to contain env components configuration objects and any other appropriate configuration information.</p></li><li><p>Env config object should have <strong><span data-colorid="x4c9crq52g">enable/disable switches for components</span></strong>. For example: scoreboard, coverage, etc.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">class verif_env_t extends uvm_env;
  `uvm_component_utils(verif_env_t)

  // Testbench methodology components
  //...
  verif_env_config_t m_env_cfg;

  function new(string name, uvm_component parent);
    super.new(name,parent);
  endfunction : new

  function void build_phase(uvm_phase phase);
    // Get m_env_cfg object from config database(DB), uvm_config_db(#...)::get()
    // Error if m_env_cfg is not received from config DB
    // ...
    // Instantiate top-level components using the factory, if their enable bit is set in m_env_cfg
    // set these component's respective config objects, using uvm_config_db.  
    // These config objects should be member objects of m_env_cfg class.
    //...
  endfunction: build_phase

  virtual function void connect_phase(uvm_phase phase);
    // Connect ports-to-exports
    //...
  endfunction: connect_phase

endclass: verif_env_t</pre>
</div></div></li><li><p>Read plusargs once in a variable and use that variable across the bench/file. Don&rsquo;t use &ldquo;if($test$plusargs(&quot;EXAMPLE&quot;)) begin&rdquo; statements all over. An example of coherency checker plusarg usage below:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">if ($value$plusargs(&quot;EN_COH_CHECK=%0d&quot;, coh_check)) begin
      `uvm_info(&quot;fsys_coherency_checker&quot;, $psprintf(&quot;Coherency checker is %0s&quot;, coh_check ? &quot;enabled&quot; : &quot;disabled&quot;), UVM_NONE);
   end else begin
      coh_check = 1; //enabled by default
      `uvm_info(&quot;fsys_coherency_checker&quot;, &quot;Coherency checker is enabled&quot;, UVM_NONE);
   end
   if (coh_check) begin
      coherency_checker = fsys_coherency_checker::type_id::create(&quot;COH_CHECK&quot;, this);
      uvm_config_db#(fsys_coherency_checker)::set(uvm_root::get(), &quot;&quot;, &quot;coherency_checker&quot;, coherency_checker);
   end</pre>
</div></div></li></ol>